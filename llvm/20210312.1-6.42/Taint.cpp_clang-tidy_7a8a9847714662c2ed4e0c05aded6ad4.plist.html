<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "content": "//===--- APValue.h - Union class for APFloat/APSInt/Complex -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the APValue class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_APVALUE_H\n#define LLVM_CLANG_AST_APVALUE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/APFixedPoint.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace clang {\nnamespace serialization {\ntemplate <typename T> class BasicReaderBase;\n} // end namespace serialization\n\n  class AddrLabelExpr;\n  class ASTContext;\n  class CharUnits;\n  class CXXRecordDecl;\n  class Decl;\n  class DiagnosticBuilder;\n  class Expr;\n  class FieldDecl;\n  struct PrintingPolicy;\n  class Type;\n  class ValueDecl;\n  class QualType;\n\n/// Symbolic representation of typeid(T) for some type T.\nclass TypeInfoLValue {\n  const Type *T;\n\npublic:\n  TypeInfoLValue() : T() {}\n  explicit TypeInfoLValue(const Type *T);\n\n  const Type *getType() const { return T; }\n  explicit operator bool() const { return T; }\n\n  void *getOpaqueValue() { return const_cast<Type*>(T); }\n  static TypeInfoLValue getFromOpaqueValue(void *Value) {\n    TypeInfoLValue V;\n    V.T = reinterpret_cast<const Type*>(Value);\n    return V;\n  }\n\n  void print(llvm::raw_ostream &Out, const PrintingPolicy &Policy) const;\n};\n\n/// Symbolic representation of a dynamic allocation.\nclass DynamicAllocLValue {\n  unsigned Index;\n\npublic:\n  DynamicAllocLValue() : Index(0) {}\n  explicit DynamicAllocLValue(unsigned Index) : Index(Index + 1) {}\n  unsigned getIndex() { return Index - 1; }\n\n  explicit operator bool() const { return Index != 0; }\n\n  void *getOpaqueValue() {\n    return reinterpret_cast<void *>(static_cast<uintptr_t>(Index)\n                                    << NumLowBitsAvailable);\n  }\n  static DynamicAllocLValue getFromOpaqueValue(void *Value) {\n    DynamicAllocLValue V;\n    V.Index = reinterpret_cast<uintptr_t>(Value) >> NumLowBitsAvailable;\n    return V;\n  }\n\n  static unsigned getMaxIndex() {\n    return (std::numeric_limits<unsigned>::max() >> NumLowBitsAvailable) - 1;\n  }\n\n  static constexpr int NumLowBitsAvailable = 3;\n};\n}\n\nnamespace llvm {\ntemplate<> struct PointerLikeTypeTraits<clang::TypeInfoLValue> {\n  static void *getAsVoidPointer(clang::TypeInfoLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::TypeInfoLValue getFromVoidPointer(void *P) {\n    return clang::TypeInfoLValue::getFromOpaqueValue(P);\n  }\n  // Validated by static_assert in APValue.cpp; hardcoded to avoid needing\n  // to include Type.h.\n  static constexpr int NumLowBitsAvailable = 3;\n};\n\ntemplate<> struct PointerLikeTypeTraits<clang::DynamicAllocLValue> {\n  static void *getAsVoidPointer(clang::DynamicAllocLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::DynamicAllocLValue getFromVoidPointer(void *P) {\n    return clang::DynamicAllocLValue::getFromOpaqueValue(P);\n  }\n  static constexpr int NumLowBitsAvailable =\n      clang::DynamicAllocLValue::NumLowBitsAvailable;\n};\n}\n\nnamespace clang {\n/// APValue - This class implements a discriminated union of [uninitialized]\n/// [APSInt] [APFloat], [Complex APSInt] [Complex APFloat], [Expr + Offset],\n/// [Vector: N * APValue], [Array: N * APValue]\nclass APValue {\n  typedef llvm::APFixedPoint APFixedPoint;\n  typedef llvm::APSInt APSInt;\n  typedef llvm::APFloat APFloat;\npublic:\n  enum ValueKind {\n    /// There is no such object (it's outside its lifetime).\n    None,\n    /// This object has an indeterminate value (C++ [basic.indet]).\n    Indeterminate,\n    Int,\n    Float,\n    FixedPoint,\n    ComplexInt,\n    ComplexFloat,\n    LValue,\n    Vector,\n    Array,\n    Struct,\n    Union,\n    MemberPointer,\n    AddrLabelDiff\n  };\n\n  class LValueBase {\n    typedef llvm::PointerUnion<const ValueDecl *, const Expr *, TypeInfoLValue,\n                               DynamicAllocLValue>\n        PtrTy;\n\n  public:\n    LValueBase() : Local{} {}\n    LValueBase(const ValueDecl *P, unsigned I = 0, unsigned V = 0);\n    LValueBase(const Expr *P, unsigned I = 0, unsigned V = 0);\n    static LValueBase getDynamicAlloc(DynamicAllocLValue LV, QualType Type);\n    static LValueBase getTypeInfo(TypeInfoLValue LV, QualType TypeInfo);\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    template <class T>\n    bool is() const { return Ptr.is<T>(); }\n\n    template <class T>\n    T get() const { return Ptr.get<T>(); }\n\n    template <class T>\n    T dyn_cast() const { return Ptr.dyn_cast<T>(); }\n\n    void *getOpaqueValue() const;\n\n    bool isNull() const;\n\n    explicit operator bool() const;\n\n    unsigned getCallIndex() const;\n    unsigned getVersion() const;\n    QualType getTypeInfoType() const;\n    QualType getDynamicAllocType() const;\n\n    QualType getType() const;\n\n    friend bool operator==(const LValueBase &LHS, const LValueBase &RHS);\n    friend bool operator!=(const LValueBase &LHS, const LValueBase &RHS) {\n      return !(LHS == RHS);\n    }\n    friend llvm::hash_code hash_value(const LValueBase &Base);\n    friend struct llvm::DenseMapInfo<LValueBase>;\n\n  private:\n    PtrTy Ptr;\n    struct LocalState {\n      unsigned CallIndex, Version;\n    };\n    union {\n      LocalState Local;\n      /// The type std::type_info, if this is a TypeInfoLValue.\n      void *TypeInfoType;\n      /// The QualType, if this is a DynamicAllocLValue.\n      void *DynamicAllocType;\n    };\n  };\n\n  /// A FieldDecl or CXXRecordDecl, along with a flag indicating whether we\n  /// mean a virtual or non-virtual base class subobject.\n  typedef llvm::PointerIntPair<const Decl *, 1, bool> BaseOrMemberType;\n\n  /// A non-discriminated union of a base, field, or array index.\n  class LValuePathEntry {\n    static_assert(sizeof(uintptr_t) <= sizeof(uint64_t),\n                  \"pointer doesn't fit in 64 bits?\");\n    uint64_t Value;\n\n  public:\n    LValuePathEntry() : Value() {}\n    LValuePathEntry(BaseOrMemberType BaseOrMember);\n    static LValuePathEntry ArrayIndex(uint64_t Index) {\n      LValuePathEntry Result;\n      Result.Value = Index;\n      return Result;\n    }\n\n    BaseOrMemberType getAsBaseOrMember() const {\n      return BaseOrMemberType::getFromOpaqueValue(\n          reinterpret_cast<void *>(Value));\n    }\n    uint64_t getAsArrayIndex() const { return Value; }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    friend bool operator==(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value == B.Value;\n    }\n    friend bool operator!=(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value != B.Value;\n    }\n    friend llvm::hash_code hash_value(LValuePathEntry A) {\n      return llvm::hash_value(A.Value);\n    }\n  };\n  class LValuePathSerializationHelper {\n    const void *ElemTy;\n\n  public:\n    ArrayRef<LValuePathEntry> Path;\n\n    LValuePathSerializationHelper(ArrayRef<LValuePathEntry>, QualType);\n    QualType getType();\n  };\n  struct NoLValuePath {};\n  struct UninitArray {};\n  struct UninitStruct {};\n\n  template <typename Impl> friend class clang::serialization::BasicReaderBase;\n  friend class ASTImporter;\n  friend class ASTNodeImporter;\n\nprivate:\n  ValueKind Kind;\n\n  struct ComplexAPSInt {\n    APSInt Real, Imag;\n    ComplexAPSInt() : Real(1), Imag(1) {}\n  };\n  struct ComplexAPFloat {\n    APFloat Real, Imag;\n    ComplexAPFloat() : Real(0.0), Imag(0.0) {}\n  };\n  struct LV;\n  struct Vec {\n    APValue *Elts;\n    unsigned NumElts;\n    Vec() : Elts(nullptr), NumElts(0) {}\n    ~Vec() { delete[] Elts; }\n  };\n  struct Arr {\n    APValue *Elts;\n    unsigned NumElts, ArrSize;\n    Arr(unsigned NumElts, unsigned ArrSize);\n    ~Arr();\n  };\n  struct StructData {\n    APValue *Elts;\n    unsigned NumBases;\n    unsigned NumFields;\n    StructData(unsigned NumBases, unsigned NumFields);\n    ~StructData();\n  };\n  struct UnionData {\n    const FieldDecl *Field;\n    APValue *Value;\n    UnionData();\n    ~UnionData();\n  };\n  struct AddrLabelDiffData {\n    const AddrLabelExpr* LHSExpr;\n    const AddrLabelExpr* RHSExpr;\n  };\n  struct MemberPointerData;\n\n  // We ensure elsewhere that Data is big enough for LV and MemberPointerData.\n  typedef llvm::AlignedCharArrayUnion<void *, APSInt, APFloat, ComplexAPSInt,\n                                      ComplexAPFloat, Vec, Arr, StructData,\n                                      UnionData, AddrLabelDiffData> DataType;\n  static const size_t DataSize = sizeof(DataType);\n\n  DataType Data;\n\npublic:\n  APValue() : Kind(None) {}\n  explicit APValue(APSInt I) : Kind(None) {\n    MakeInt(); setInt(std::move(I));\n  }\n  explicit APValue(APFloat F) : Kind(None) {\n    MakeFloat(); setFloat(std::move(F));\n  }\n  explicit APValue(APFixedPoint FX) : Kind(None) {\n    MakeFixedPoint(std::move(FX));\n  }\n  explicit APValue(const APValue *E, unsigned N) : Kind(None) {\n    MakeVector(); setVector(E, N);\n  }\n  APValue(APSInt R, APSInt I) : Kind(None) {\n    MakeComplexInt(); setComplexInt(std::move(R), std::move(I));\n  }\n  APValue(APFloat R, APFloat I) : Kind(None) {\n    MakeComplexFloat(); setComplexFloat(std::move(R), std::move(I));\n  }\n  APValue(const APValue &RHS);\n  APValue(APValue &&RHS);\n  APValue(LValueBase B, const CharUnits &O, NoLValuePath N,\n          bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, N, IsNullPtr);\n  }\n  APValue(LValueBase B, const CharUnits &O, ArrayRef<LValuePathEntry> Path,\n          bool OnePastTheEnd, bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, Path, OnePastTheEnd, IsNullPtr);\n  }\n  APValue(UninitArray, unsigned InitElts, unsigned Size) : Kind(None) {\n    MakeArray(InitElts, Size);\n  }\n  APValue(UninitStruct, unsigned B, unsigned M) : Kind(None) {\n    MakeStruct(B, M);\n  }\n  explicit APValue(const FieldDecl *D, const APValue &V = APValue())\n      : Kind(None) {\n    MakeUnion(); setUnion(D, V);\n  }\n  APValue(const ValueDecl *Member, bool IsDerivedMember,\n          ArrayRef<const CXXRecordDecl*> Path) : Kind(None) {\n    MakeMemberPointer(Member, IsDerivedMember, Path);\n  }\n  APValue(const AddrLabelExpr* LHSExpr, const AddrLabelExpr* RHSExpr)\n      : Kind(None) {\n    MakeAddrLabelDiff(); setAddrLabelDiff(LHSExpr, RHSExpr);\n  }\n  static APValue IndeterminateValue() {\n    APValue Result;\n    Result.Kind = Indeterminate;\n    return Result;\n  }\n\n  APValue &operator=(const APValue &RHS);\n  APValue &operator=(APValue &&RHS);\n\n  ~APValue() {\n    if (Kind != None && Kind != Indeterminate)\n      DestroyDataAndMakeUninit();\n  }\n\n  /// Returns whether the object performed allocations.\n  ///\n  /// If APValues are constructed via placement new, \\c needsCleanup()\n  /// indicates whether the destructor must be called in order to correctly\n  /// free all allocated memory.\n  bool needsCleanup() const;\n\n  /// Swaps the contents of this and the given APValue.\n  void swap(APValue &RHS);\n\n  /// profile this value. There is no guarantee that values of different\n  /// types will not produce the same profiled value, so the type should\n  /// typically also be profiled if it's not implied by the context.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  ValueKind getKind() const { return Kind; }\n\n  bool isAbsent() const { return Kind == None; }\n  bool isIndeterminate() const { return Kind == Indeterminate; }\n  bool hasValue() const { return Kind != None && Kind != Indeterminate; }\n\n  bool isInt() const { return Kind == Int; }\n  bool isFloat() const { return Kind == Float; }\n  bool isFixedPoint() const { return Kind == FixedPoint; }\n  bool isComplexInt() const { return Kind == ComplexInt; }\n  bool isComplexFloat() const { return Kind == ComplexFloat; }\n  bool isLValue() const { return Kind == LValue; }\n  bool isVector() const { return Kind == Vector; }\n  bool isArray() const { return Kind == Array; }\n  bool isStruct() const { return Kind == Struct; }\n  bool isUnion() const { return Kind == Union; }\n  bool isMemberPointer() const { return Kind == MemberPointer; }\n  bool isAddrLabelDiff() const { return Kind == AddrLabelDiff; }\n\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  void printPretty(raw_ostream &OS, const ASTContext &Ctx, QualType Ty) const;\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy, QualType Ty,\n                   const ASTContext *Ctx = nullptr) const;\n\n  std::string getAsString(const ASTContext &Ctx, QualType Ty) const;\n\n  APSInt &getInt() {\n    assert(isInt() && \"Invalid accessor\");\n    return *(APSInt *)(char *)&Data;\n  }\n  const APSInt &getInt() const {\n    return const_cast<APValue*>(this)->getInt();\n  }\n\n  /// Try to convert this value to an integral constant. This works if it's an\n  /// integer, null pointer, or offset from a null pointer. Returns true on\n  /// success.\n  bool toIntegralConstant(APSInt &Result, QualType SrcTy,\n                          const ASTContext &Ctx) const;\n\n  APFloat &getFloat() {\n    assert(isFloat() && \"Invalid accessor\");\n    return *(APFloat *)(char *)&Data;\n  }\n  const APFloat &getFloat() const {\n    return const_cast<APValue*>(this)->getFloat();\n  }\n\n  APFixedPoint &getFixedPoint() {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    return *(APFixedPoint *)(char *)&Data;\n  }\n  const APFixedPoint &getFixedPoint() const {\n    return const_cast<APValue *>(this)->getFixedPoint();\n  }\n\n  APSInt &getComplexIntReal() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Real;\n  }\n  const APSInt &getComplexIntReal() const {\n    return const_cast<APValue*>(this)->getComplexIntReal();\n  }\n\n  APSInt &getComplexIntImag() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Imag;\n  }\n  const APSInt &getComplexIntImag() const {\n    return const_cast<APValue*>(this)->getComplexIntImag();\n  }\n\n  APFloat &getComplexFloatReal() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Real;\n  }\n  const APFloat &getComplexFloatReal() const {\n    return const_cast<APValue*>(this)->getComplexFloatReal();\n  }\n\n  APFloat &getComplexFloatImag() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Imag;\n  }\n  const APFloat &getComplexFloatImag() const {\n    return const_cast<APValue*>(this)->getComplexFloatImag();\n  }\n\n  const LValueBase getLValueBase() const;\n  CharUnits &getLValueOffset();\n  const CharUnits &getLValueOffset() const {\n    return const_cast<APValue*>(this)->getLValueOffset();\n  }\n  bool isLValueOnePastTheEnd() const;\n  bool hasLValuePath() const;\n  ArrayRef<LValuePathEntry> getLValuePath() const;\n  unsigned getLValueCallIndex() const;\n  unsigned getLValueVersion() const;\n  bool isNullPointer() const;\n\n  APValue &getVectorElt(unsigned I) {\n    assert(isVector() && \"Invalid accessor\");\n    assert(I < getVectorLength() && \"Index out of range\");\n    return ((Vec *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getVectorElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getVectorElt(I);\n  }\n  unsigned getVectorLength() const {\n    assert(isVector() && \"Invalid accessor\");\n    return ((const Vec *)(const void *)&Data)->NumElts;\n  }\n\n  APValue &getArrayInitializedElt(unsigned I) {\n    assert(isArray() && \"Invalid accessor\");\n    assert(I < getArrayInitializedElts() && \"Index out of range\");\n    return ((Arr *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getArrayInitializedElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getArrayInitializedElt(I);\n  }\n  bool hasArrayFiller() const {\n    return getArrayInitializedElts() != getArraySize();\n  }\n  APValue &getArrayFiller() {\n    assert(isArray() && \"Invalid accessor\");\n    assert(hasArrayFiller() && \"No array filler\");\n    return ((Arr *)(char *)&Data)->Elts[getArrayInitializedElts()];\n  }\n  const APValue &getArrayFiller() const {\n    return const_cast<APValue*>(this)->getArrayFiller();\n  }\n  unsigned getArrayInitializedElts() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->NumElts;\n  }\n  unsigned getArraySize() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->ArrSize;\n  }\n\n  unsigned getStructNumBases() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumBases;\n  }\n  unsigned getStructNumFields() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumFields;\n  }\n  APValue &getStructBase(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumBases() && \"base class index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[i];\n  }\n  APValue &getStructField(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumFields() && \"field index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[getStructNumBases() + i];\n  }\n  const APValue &getStructBase(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructBase(i);\n  }\n  const APValue &getStructField(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructField(i);\n  }\n\n  const FieldDecl *getUnionField() const {\n    assert(isUnion() && \"Invalid accessor\");\n    return ((const UnionData *)(const char *)&Data)->Field;\n  }\n  APValue &getUnionValue() {\n    assert(isUnion() && \"Invalid accessor\");\n    return *((UnionData *)(char *)&Data)->Value;\n  }\n  const APValue &getUnionValue() const {\n    return const_cast<APValue*>(this)->getUnionValue();\n  }\n\n  const ValueDecl *getMemberPointerDecl() const;\n  bool isMemberPointerToDerivedMember() const;\n  ArrayRef<const CXXRecordDecl*> getMemberPointerPath() const;\n\n  const AddrLabelExpr* getAddrLabelDiffLHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->LHSExpr;\n  }\n  const AddrLabelExpr* getAddrLabelDiffRHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->RHSExpr;\n  }\n\n  void setInt(APSInt I) {\n    assert(isInt() && \"Invalid accessor\");\n    *(APSInt *)(char *)&Data = std::move(I);\n  }\n  void setFloat(APFloat F) {\n    assert(isFloat() && \"Invalid accessor\");\n    *(APFloat *)(char *)&Data = std::move(F);\n  }\n  void setFixedPoint(APFixedPoint FX) {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    *(APFixedPoint *)(char *)&Data = std::move(FX);\n  }\n  void setVector(const APValue *E, unsigned N) {\n    MutableArrayRef<APValue> InternalElts = setVectorUninit(N);\n    for (unsigned i = 0; i != N; ++i)\n      InternalElts[i] = E[i];\n  }\n  void setComplexInt(APSInt R, APSInt I) {\n    assert(R.getBitWidth() == I.getBitWidth() &&\n           \"Invalid complex int (type mismatch).\");\n    assert(isComplexInt() && \"Invalid accessor\");\n    ((ComplexAPSInt *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPSInt *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setComplexFloat(APFloat R, APFloat I) {\n    assert(&R.getSemantics() == &I.getSemantics() &&\n           \"Invalid complex float (type mismatch).\");\n    assert(isComplexFloat() && \"Invalid accessor\");\n    ((ComplexAPFloat *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPFloat *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setLValue(LValueBase B, const CharUnits &O, NoLValuePath,\n                 bool IsNullPtr);\n  void setLValue(LValueBase B, const CharUnits &O,\n                 ArrayRef<LValuePathEntry> Path, bool OnePastTheEnd,\n                 bool IsNullPtr);\n  void setUnion(const FieldDecl *Field, const APValue &Value);\n  void setAddrLabelDiff(const AddrLabelExpr* LHSExpr,\n                        const AddrLabelExpr* RHSExpr) {\n    ((AddrLabelDiffData *)(char *)&Data)->LHSExpr = LHSExpr;\n    ((AddrLabelDiffData *)(char *)&Data)->RHSExpr = RHSExpr;\n  }\n\nprivate:\n  void DestroyDataAndMakeUninit();\n  void MakeInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)&Data) APSInt(1);\n    Kind = Int;\n  }\n  void MakeFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFloat(0.0);\n    Kind = Float;\n  }\n  void MakeFixedPoint(APFixedPoint &&FX) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFixedPoint(std::move(FX));\n    Kind = FixedPoint;\n  }\n  void MakeVector() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) Vec();\n    Kind = Vector;\n  }\n  void MakeComplexInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPSInt();\n    Kind = ComplexInt;\n  }\n  void MakeComplexFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPFloat();\n    Kind = ComplexFloat;\n  }\n  void MakeLValue();\n  void MakeArray(unsigned InitElts, unsigned Size);\n  void MakeStruct(unsigned B, unsigned M) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) StructData(B, M);\n    Kind = Struct;\n  }\n  void MakeUnion() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) UnionData();\n    Kind = Union;\n  }\n  void MakeMemberPointer(const ValueDecl *Member, bool IsDerivedMember,\n                         ArrayRef<const CXXRecordDecl*> Path);\n  void MakeAddrLabelDiff() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) AddrLabelDiffData();\n    Kind = AddrLabelDiff;\n  }\n\nprivate:\n  /// The following functions are used as part of initialization, during\n  /// deserialization and importing. Reserve the space so that it can be\n  /// filled in by those steps.\n  MutableArrayRef<APValue> setVectorUninit(unsigned N) {\n    assert(isVector() && \"Invalid accessor\");\n    Vec *V = ((Vec *)(char *)&Data);\n    V->Elts = new APValue[N];\n    V->NumElts = N;\n    return {V->Elts, V->NumElts};\n  }\n  MutableArrayRef<LValuePathEntry>\n  setLValueUninit(LValueBase B, const CharUnits &O, unsigned Size,\n                  bool OnePastTheEnd, bool IsNullPtr);\n  MutableArrayRef<const CXXRecordDecl *>\n  setMemberPointerUninit(const ValueDecl *Member, bool IsDerivedMember,\n                         unsigned Size);\n};\n\n} // end namespace clang.\n\nnamespace llvm {\ntemplate<> struct DenseMapInfo<clang::APValue::LValueBase> {\n  static clang::APValue::LValueBase getEmptyKey();\n  static clang::APValue::LValueBase getTombstoneKey();\n  static unsigned getHashValue(const clang::APValue::LValueBase &Base);\n  static bool isEqual(const clang::APValue::LValueBase &LHS,\n                      const clang::APValue::LValueBase &RHS);\n};\n}\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTConcept.h", "content": "//===--- ASTConcept.h - Concepts Related AST Data Structures ----*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief This file provides AST data structures related to concepts.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTCONCEPT_H\n#define LLVM_CLANG_AST_ASTCONCEPT_H\n#include \"clang/AST/Expr.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <string>\n#include <utility>\nnamespace clang {\nclass ConceptDecl;\nclass ConceptSpecializationExpr;\n\n/// The result of a constraint satisfaction check, containing the necessary\n/// information to diagnose an unsatisfied constraint.\nclass ConstraintSatisfaction : public llvm::FoldingSetNode {\n  // The template-like entity that 'owns' the constraint checked here (can be a\n  // constrained entity or a concept).\n  const NamedDecl *ConstraintOwner = nullptr;\n  llvm::SmallVector<TemplateArgument, 4> TemplateArgs;\n\npublic:\n\n  ConstraintSatisfaction() = default;\n\n  ConstraintSatisfaction(const NamedDecl *ConstraintOwner,\n                         ArrayRef<TemplateArgument> TemplateArgs) :\n      ConstraintOwner(ConstraintOwner), TemplateArgs(TemplateArgs.begin(),\n                                                     TemplateArgs.end()) { }\n\n  using SubstitutionDiagnostic = std::pair<SourceLocation, StringRef>;\n  using Detail = llvm::PointerUnion<Expr *, SubstitutionDiagnostic *>;\n\n  bool IsSatisfied = false;\n\n  /// \\brief Pairs of unsatisfied atomic constraint expressions along with the\n  /// substituted constraint expr, if the template arguments could be\n  /// substituted into them, or a diagnostic if substitution resulted in an\n  /// invalid expression.\n  llvm::SmallVector<std::pair<const Expr *, Detail>, 4> Details;\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C) {\n    Profile(ID, C, ConstraintOwner, TemplateArgs);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C,\n                      const NamedDecl *ConstraintOwner,\n                      ArrayRef<TemplateArgument> TemplateArgs);\n};\n\n/// Pairs of unsatisfied atomic constraint expressions along with the\n/// substituted constraint expr, if the template arguments could be\n/// substituted into them, or a diagnostic if substitution resulted in\n/// an invalid expression.\nusing UnsatisfiedConstraintRecord =\n    std::pair<const Expr *,\n              llvm::PointerUnion<Expr *,\n                                 std::pair<SourceLocation, StringRef> *>>;\n\n/// \\brief The result of a constraint satisfaction check, containing the\n/// necessary information to diagnose an unsatisfied constraint.\n///\n/// This is safe to store in an AST node, as opposed to ConstraintSatisfaction.\nstruct ASTConstraintSatisfaction final :\n    llvm::TrailingObjects<ASTConstraintSatisfaction,\n                          UnsatisfiedConstraintRecord> {\n  std::size_t NumRecords;\n  bool IsSatisfied : 1;\n\n  const UnsatisfiedConstraintRecord *begin() const {\n    return getTrailingObjects<UnsatisfiedConstraintRecord>();\n  }\n\n  const UnsatisfiedConstraintRecord *end() const {\n    return getTrailingObjects<UnsatisfiedConstraintRecord>() + NumRecords;\n  }\n\n  ASTConstraintSatisfaction(const ASTContext &C,\n                            const ConstraintSatisfaction &Satisfaction);\n\n  static ASTConstraintSatisfaction *\n  Create(const ASTContext &C, const ConstraintSatisfaction &Satisfaction);\n};\n\n/// \\brief Common data class for constructs that reference concepts with\n/// template arguments.\nclass ConceptReference {\nprotected:\n  // \\brief The optional nested name specifier used when naming the concept.\n  NestedNameSpecifierLoc NestedNameSpec;\n\n  /// \\brief The location of the template keyword, if specified when naming the\n  /// concept.\n  SourceLocation TemplateKWLoc;\n\n  /// \\brief The concept name used.\n  DeclarationNameInfo ConceptName;\n\n  /// \\brief The declaration found by name lookup when the expression was\n  /// created.\n  /// Can differ from NamedConcept when, for example, the concept was found\n  /// through a UsingShadowDecl.\n  NamedDecl *FoundDecl;\n\n  /// \\brief The concept named.\n  ConceptDecl *NamedConcept;\n\n  /// \\brief The template argument list source info used to specialize the\n  /// concept.\n  const ASTTemplateArgumentListInfo *ArgsAsWritten;\n\npublic:\n\n  ConceptReference(NestedNameSpecifierLoc NNS, SourceLocation TemplateKWLoc,\n                   DeclarationNameInfo ConceptNameInfo, NamedDecl *FoundDecl,\n                   ConceptDecl *NamedConcept,\n                   const ASTTemplateArgumentListInfo *ArgsAsWritten) :\n      NestedNameSpec(NNS), TemplateKWLoc(TemplateKWLoc),\n      ConceptName(ConceptNameInfo), FoundDecl(FoundDecl),\n      NamedConcept(NamedConcept), ArgsAsWritten(ArgsAsWritten) {}\n\n  ConceptReference() : NestedNameSpec(), TemplateKWLoc(), ConceptName(),\n      FoundDecl(nullptr), NamedConcept(nullptr), ArgsAsWritten(nullptr) {}\n\n  const NestedNameSpecifierLoc &getNestedNameSpecifierLoc() const {\n    return NestedNameSpec;\n  }\n\n  const DeclarationNameInfo &getConceptNameInfo() const { return ConceptName; }\n\n  SourceLocation getConceptNameLoc() const {\n    return getConceptNameInfo().getLoc();\n  }\n\n  SourceLocation getTemplateKWLoc() const { return TemplateKWLoc; }\n\n  NamedDecl *getFoundDecl() const {\n    return FoundDecl;\n  }\n\n  ConceptDecl *getNamedConcept() const {\n    return NamedConcept;\n  }\n\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief Whether or not template arguments were explicitly specified in the\n  /// concept reference (they might not be in type constraints, for example)\n  bool hasExplicitTemplateArgs() const {\n    return ArgsAsWritten != nullptr;\n  }\n};\n\nclass TypeConstraint : public ConceptReference {\n  /// \\brief The immediately-declared constraint expression introduced by this\n  /// type-constraint.\n  Expr *ImmediatelyDeclaredConstraint = nullptr;\n\npublic:\n  TypeConstraint(NestedNameSpecifierLoc NNS,\n                 DeclarationNameInfo ConceptNameInfo, NamedDecl *FoundDecl,\n                 ConceptDecl *NamedConcept,\n                 const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                 Expr *ImmediatelyDeclaredConstraint) :\n      ConceptReference(NNS, /*TemplateKWLoc=*/SourceLocation(), ConceptNameInfo,\n                       FoundDecl, NamedConcept, ArgsAsWritten),\n      ImmediatelyDeclaredConstraint(ImmediatelyDeclaredConstraint) {}\n\n  /// \\brief Get the immediately-declared constraint expression introduced by\n  /// this type-constraint, that is - the constraint expression that is added to\n  /// the associated constraints of the enclosing declaration in practice.\n  Expr *getImmediatelyDeclaredConstraint() const {\n    return ImmediatelyDeclaredConstraint;\n  }\n\n  void print(llvm::raw_ostream &OS, PrintingPolicy Policy) const;\n};\n\n} // clang\n\n#endif // LLVM_CLANG_AST_ASTCONCEPT_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "content": "//===- ASTContext.h - Context to hold long-lived AST nodes ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::ASTContext interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTCONTEXT_H\n#define LLVM_CLANG_AST_ASTCONTEXT_H\n\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/CanonicalType.h\"\n#include \"clang/AST/CommentCommandTraits.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/RawCommentList.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/NoSanitizeList.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/ProfileList.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/XRayLists.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass APFixedPoint;\nclass FixedPointSemantics;\nstruct fltSemantics;\ntemplate <typename T, unsigned N> class SmallPtrSet;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass APValue;\nclass ASTMutationListener;\nclass ASTRecordLayout;\nclass AtomicExpr;\nclass BlockExpr;\nclass BuiltinTemplateDecl;\nclass CharUnits;\nclass ConceptDecl;\nclass CXXABI;\nclass CXXConstructorDecl;\nclass CXXMethodDecl;\nclass CXXRecordDecl;\nclass DiagnosticsEngine;\nclass ParentMapContext;\nclass DynTypedNode;\nclass DynTypedNodeList;\nclass Expr;\nclass GlobalDecl;\nclass MangleContext;\nclass MangleNumberingContext;\nclass MaterializeTemporaryExpr;\nclass MemberSpecializationInfo;\nclass Module;\nstruct MSGuidDeclParts;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCContainerDecl;\nclass ObjCImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCMethodDecl;\nclass ObjCPropertyDecl;\nclass ObjCPropertyImplDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nclass OMPTraitInfo;\nstruct ParsedTargetAttr;\nclass Preprocessor;\nclass Stmt;\nclass StoredDeclsMap;\nclass TargetAttr;\nclass TargetInfo;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass TemplateTemplateParmDecl;\nclass TemplateTypeParmDecl;\nclass UnresolvedSetIterator;\nclass UsingShadowDecl;\nclass VarTemplateDecl;\nclass VTableContextBase;\nstruct BlockVarCopyInit;\n\nnamespace Builtin {\n\nclass Context;\n\n} // namespace Builtin\n\nenum BuiltinTemplateKind : int;\nenum OpenCLTypeKind : uint8_t;\n\nnamespace comments {\n\nclass FullComment;\n\n} // namespace comments\n\nnamespace interp {\n\nclass Context;\n\n} // namespace interp\n\nnamespace serialization {\ntemplate <class> class AbstractTypeReader;\n} // namespace serialization\n\nstruct TypeInfo {\n  uint64_t Width = 0;\n  unsigned Align = 0;\n  bool AlignIsRequired : 1;\n\n  TypeInfo() : AlignIsRequired(false) {}\n  TypeInfo(uint64_t Width, unsigned Align, bool AlignIsRequired)\n      : Width(Width), Align(Align), AlignIsRequired(AlignIsRequired) {}\n};\n\nstruct TypeInfoChars {\n  CharUnits Width;\n  CharUnits Align;\n  bool AlignIsRequired : 1;\n\n  TypeInfoChars() : AlignIsRequired(false) {}\n  TypeInfoChars(CharUnits Width, CharUnits Align, bool AlignIsRequired)\n      : Width(Width), Align(Align), AlignIsRequired(AlignIsRequired) {}\n};\n\n/// Holds long-lived AST nodes (such as types and decls) that can be\n/// referred to throughout the semantic analysis of a file.\nclass ASTContext : public RefCountedBase<ASTContext> {\n  friend class NestedNameSpecifier;\n\n  mutable SmallVector<Type *, 0> Types;\n  mutable llvm::FoldingSet<ExtQuals> ExtQualNodes;\n  mutable llvm::FoldingSet<ComplexType> ComplexTypes;\n  mutable llvm::FoldingSet<PointerType> PointerTypes;\n  mutable llvm::FoldingSet<AdjustedType> AdjustedTypes;\n  mutable llvm::FoldingSet<BlockPointerType> BlockPointerTypes;\n  mutable llvm::FoldingSet<LValueReferenceType> LValueReferenceTypes;\n  mutable llvm::FoldingSet<RValueReferenceType> RValueReferenceTypes;\n  mutable llvm::FoldingSet<MemberPointerType> MemberPointerTypes;\n  mutable llvm::ContextualFoldingSet<ConstantArrayType, ASTContext &>\n      ConstantArrayTypes;\n  mutable llvm::FoldingSet<IncompleteArrayType> IncompleteArrayTypes;\n  mutable std::vector<VariableArrayType*> VariableArrayTypes;\n  mutable llvm::FoldingSet<DependentSizedArrayType> DependentSizedArrayTypes;\n  mutable llvm::FoldingSet<DependentSizedExtVectorType>\n    DependentSizedExtVectorTypes;\n  mutable llvm::FoldingSet<DependentAddressSpaceType>\n      DependentAddressSpaceTypes;\n  mutable llvm::FoldingSet<VectorType> VectorTypes;\n  mutable llvm::FoldingSet<DependentVectorType> DependentVectorTypes;\n  mutable llvm::FoldingSet<ConstantMatrixType> MatrixTypes;\n  mutable llvm::FoldingSet<DependentSizedMatrixType> DependentSizedMatrixTypes;\n  mutable llvm::FoldingSet<FunctionNoProtoType> FunctionNoProtoTypes;\n  mutable llvm::ContextualFoldingSet<FunctionProtoType, ASTContext&>\n    FunctionProtoTypes;\n  mutable llvm::FoldingSet<DependentTypeOfExprType> DependentTypeOfExprTypes;\n  mutable llvm::FoldingSet<DependentDecltypeType> DependentDecltypeTypes;\n  mutable llvm::FoldingSet<TemplateTypeParmType> TemplateTypeParmTypes;\n  mutable llvm::FoldingSet<ObjCTypeParamType> ObjCTypeParamTypes;\n  mutable llvm::FoldingSet<SubstTemplateTypeParmType>\n    SubstTemplateTypeParmTypes;\n  mutable llvm::FoldingSet<SubstTemplateTypeParmPackType>\n    SubstTemplateTypeParmPackTypes;\n  mutable llvm::ContextualFoldingSet<TemplateSpecializationType, ASTContext&>\n    TemplateSpecializationTypes;\n  mutable llvm::FoldingSet<ParenType> ParenTypes;\n  mutable llvm::FoldingSet<ElaboratedType> ElaboratedTypes;\n  mutable llvm::FoldingSet<DependentNameType> DependentNameTypes;\n  mutable llvm::ContextualFoldingSet<DependentTemplateSpecializationType,\n                                     ASTContext&>\n    DependentTemplateSpecializationTypes;\n  llvm::FoldingSet<PackExpansionType> PackExpansionTypes;\n  mutable llvm::FoldingSet<ObjCObjectTypeImpl> ObjCObjectTypes;\n  mutable llvm::FoldingSet<ObjCObjectPointerType> ObjCObjectPointerTypes;\n  mutable llvm::FoldingSet<DependentUnaryTransformType>\n    DependentUnaryTransformTypes;\n  mutable llvm::ContextualFoldingSet<AutoType, ASTContext&> AutoTypes;\n  mutable llvm::FoldingSet<DeducedTemplateSpecializationType>\n    DeducedTemplateSpecializationTypes;\n  mutable llvm::FoldingSet<AtomicType> AtomicTypes;\n  llvm::FoldingSet<AttributedType> AttributedTypes;\n  mutable llvm::FoldingSet<PipeType> PipeTypes;\n  mutable llvm::FoldingSet<ExtIntType> ExtIntTypes;\n  mutable llvm::FoldingSet<DependentExtIntType> DependentExtIntTypes;\n\n  mutable llvm::FoldingSet<QualifiedTemplateName> QualifiedTemplateNames;\n  mutable llvm::FoldingSet<DependentTemplateName> DependentTemplateNames;\n  mutable llvm::FoldingSet<SubstTemplateTemplateParmStorage>\n    SubstTemplateTemplateParms;\n  mutable llvm::ContextualFoldingSet<SubstTemplateTemplateParmPackStorage,\n                                     ASTContext&>\n    SubstTemplateTemplateParmPacks;\n\n  /// The set of nested name specifiers.\n  ///\n  /// This set is managed by the NestedNameSpecifier class.\n  mutable llvm::FoldingSet<NestedNameSpecifier> NestedNameSpecifiers;\n  mutable NestedNameSpecifier *GlobalNestedNameSpecifier = nullptr;\n\n  /// A cache mapping from RecordDecls to ASTRecordLayouts.\n  ///\n  /// This is lazily created.  This is intentionally not serialized.\n  mutable llvm::DenseMap<const RecordDecl*, const ASTRecordLayout*>\n    ASTRecordLayouts;\n  mutable llvm::DenseMap<const ObjCContainerDecl*, const ASTRecordLayout*>\n    ObjCLayouts;\n\n  /// A cache from types to size and alignment information.\n  using TypeInfoMap = llvm::DenseMap<const Type *, struct TypeInfo>;\n  mutable TypeInfoMap MemoizedTypeInfo;\n\n  /// A cache from types to unadjusted alignment information. Only ARM and\n  /// AArch64 targets need this information, keeping it separate prevents\n  /// imposing overhead on TypeInfo size.\n  using UnadjustedAlignMap = llvm::DenseMap<const Type *, unsigned>;\n  mutable UnadjustedAlignMap MemoizedUnadjustedAlign;\n\n  /// A cache mapping from CXXRecordDecls to key functions.\n  llvm::DenseMap<const CXXRecordDecl*, LazyDeclPtr> KeyFunctions;\n\n  /// Mapping from ObjCContainers to their ObjCImplementations.\n  llvm::DenseMap<ObjCContainerDecl*, ObjCImplDecl*> ObjCImpls;\n\n  /// Mapping from ObjCMethod to its duplicate declaration in the same\n  /// interface.\n  llvm::DenseMap<const ObjCMethodDecl*,const ObjCMethodDecl*> ObjCMethodRedecls;\n\n  /// Mapping from __block VarDecls to BlockVarCopyInit.\n  llvm::DenseMap<const VarDecl *, BlockVarCopyInit> BlockVarCopyInits;\n\n  /// Mapping from GUIDs to the corresponding MSGuidDecl.\n  mutable llvm::FoldingSet<MSGuidDecl> MSGuidDecls;\n\n  /// Mapping from APValues to the corresponding TemplateParamObjects.\n  mutable llvm::FoldingSet<TemplateParamObjectDecl> TemplateParamObjectDecls;\n\n  /// A cache mapping a string value to a StringLiteral object with the same\n  /// value.\n  ///\n  /// This is lazily created.  This is intentionally not serialized.\n  mutable llvm::StringMap<StringLiteral *> StringLiteralCache;\n\n  /// MD5 hash of CUID. It is calculated when first used and cached by this\n  /// data member.\n  mutable std::string CUIDHash;\n\n  /// Representation of a \"canonical\" template template parameter that\n  /// is used in canonical template names.\n  class CanonicalTemplateTemplateParm : public llvm::FoldingSetNode {\n    TemplateTemplateParmDecl *Parm;\n\n  public:\n    CanonicalTemplateTemplateParm(TemplateTemplateParmDecl *Parm)\n        : Parm(Parm) {}\n\n    TemplateTemplateParmDecl *getParam() const { return Parm; }\n\n    void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C) {\n      Profile(ID, C, Parm);\n    }\n\n    static void Profile(llvm::FoldingSetNodeID &ID,\n                        const ASTContext &C,\n                        TemplateTemplateParmDecl *Parm);\n  };\n  mutable llvm::ContextualFoldingSet<CanonicalTemplateTemplateParm,\n                                     const ASTContext&>\n    CanonTemplateTemplateParms;\n\n  TemplateTemplateParmDecl *\n    getCanonicalTemplateTemplateParmDecl(TemplateTemplateParmDecl *TTP) const;\n\n  /// The typedef for the __int128_t type.\n  mutable TypedefDecl *Int128Decl = nullptr;\n\n  /// The typedef for the __uint128_t type.\n  mutable TypedefDecl *UInt128Decl = nullptr;\n\n  /// The typedef for the target specific predefined\n  /// __builtin_va_list type.\n  mutable TypedefDecl *BuiltinVaListDecl = nullptr;\n\n  /// The typedef for the predefined \\c __builtin_ms_va_list type.\n  mutable TypedefDecl *BuiltinMSVaListDecl = nullptr;\n\n  /// The typedef for the predefined \\c id type.\n  mutable TypedefDecl *ObjCIdDecl = nullptr;\n\n  /// The typedef for the predefined \\c SEL type.\n  mutable TypedefDecl *ObjCSelDecl = nullptr;\n\n  /// The typedef for the predefined \\c Class type.\n  mutable TypedefDecl *ObjCClassDecl = nullptr;\n\n  /// The typedef for the predefined \\c Protocol class in Objective-C.\n  mutable ObjCInterfaceDecl *ObjCProtocolClassDecl = nullptr;\n\n  /// The typedef for the predefined 'BOOL' type.\n  mutable TypedefDecl *BOOLDecl = nullptr;\n\n  // Typedefs which may be provided defining the structure of Objective-C\n  // pseudo-builtins\n  QualType ObjCIdRedefinitionType;\n  QualType ObjCClassRedefinitionType;\n  QualType ObjCSelRedefinitionType;\n\n  /// The identifier 'bool'.\n  mutable IdentifierInfo *BoolName = nullptr;\n\n  /// The identifier 'NSObject'.\n  mutable IdentifierInfo *NSObjectName = nullptr;\n\n  /// The identifier 'NSCopying'.\n  IdentifierInfo *NSCopyingName = nullptr;\n\n  /// The identifier '__make_integer_seq'.\n  mutable IdentifierInfo *MakeIntegerSeqName = nullptr;\n\n  /// The identifier '__type_pack_element'.\n  mutable IdentifierInfo *TypePackElementName = nullptr;\n\n  QualType ObjCConstantStringType;\n  mutable RecordDecl *CFConstantStringTagDecl = nullptr;\n  mutable TypedefDecl *CFConstantStringTypeDecl = nullptr;\n\n  mutable QualType ObjCSuperType;\n\n  QualType ObjCNSStringType;\n\n  /// The typedef declaration for the Objective-C \"instancetype\" type.\n  TypedefDecl *ObjCInstanceTypeDecl = nullptr;\n\n  /// The type for the C FILE type.\n  TypeDecl *FILEDecl = nullptr;\n\n  /// The type for the C jmp_buf type.\n  TypeDecl *jmp_bufDecl = nullptr;\n\n  /// The type for the C sigjmp_buf type.\n  TypeDecl *sigjmp_bufDecl = nullptr;\n\n  /// The type for the C ucontext_t type.\n  TypeDecl *ucontext_tDecl = nullptr;\n\n  /// Type for the Block descriptor for Blocks CodeGen.\n  ///\n  /// Since this is only used for generation of debug info, it is not\n  /// serialized.\n  mutable RecordDecl *BlockDescriptorType = nullptr;\n\n  /// Type for the Block descriptor for Blocks CodeGen.\n  ///\n  /// Since this is only used for generation of debug info, it is not\n  /// serialized.\n  mutable RecordDecl *BlockDescriptorExtendedType = nullptr;\n\n  /// Declaration for the CUDA cudaConfigureCall function.\n  FunctionDecl *cudaConfigureCallDecl = nullptr;\n\n  /// Keeps track of all declaration attributes.\n  ///\n  /// Since so few decls have attrs, we keep them in a hash map instead of\n  /// wasting space in the Decl class.\n  llvm::DenseMap<const Decl*, AttrVec*> DeclAttrs;\n\n  /// A mapping from non-redeclarable declarations in modules that were\n  /// merged with other declarations to the canonical declaration that they were\n  /// merged into.\n  llvm::DenseMap<Decl*, Decl*> MergedDecls;\n\n  /// A mapping from a defining declaration to a list of modules (other\n  /// than the owning module of the declaration) that contain merged\n  /// definitions of that entity.\n  llvm::DenseMap<NamedDecl*, llvm::TinyPtrVector<Module*>> MergedDefModules;\n\n  /// Initializers for a module, in order. Each Decl will be either\n  /// something that has a semantic effect on startup (such as a variable with\n  /// a non-constant initializer), or an ImportDecl (which recursively triggers\n  /// initialization of another module).\n  struct PerModuleInitializers {\n    llvm::SmallVector<Decl*, 4> Initializers;\n    llvm::SmallVector<uint32_t, 4> LazyInitializers;\n\n    void resolve(ASTContext &Ctx);\n  };\n  llvm::DenseMap<Module*, PerModuleInitializers*> ModuleInitializers;\n\n  ASTContext &this_() { return *this; }\n\npublic:\n  /// A type synonym for the TemplateOrInstantiation mapping.\n  using TemplateOrSpecializationInfo =\n      llvm::PointerUnion<VarTemplateDecl *, MemberSpecializationInfo *>;\n\nprivate:\n  friend class ASTDeclReader;\n  friend class ASTReader;\n  friend class ASTWriter;\n  template <class> friend class serialization::AbstractTypeReader;\n  friend class CXXRecordDecl;\n\n  /// A mapping to contain the template or declaration that\n  /// a variable declaration describes or was instantiated from,\n  /// respectively.\n  ///\n  /// For non-templates, this value will be NULL. For variable\n  /// declarations that describe a variable template, this will be a\n  /// pointer to a VarTemplateDecl. For static data members\n  /// of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member variable that was\n  /// instantiated or specialized. Thus, the mapping will keep track of\n  /// the static data member templates from which static data members of\n  /// class template specializations were instantiated.\n  ///\n  /// Given the following example:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   static T value;\n  /// };\n  ///\n  /// template<typename T>\n  ///   T X<T>::value = T(17);\n  ///\n  /// int *x = &X<int>::value;\n  /// \\endcode\n  ///\n  /// This mapping will contain an entry that maps from the VarDecl for\n  /// X<int>::value to the corresponding VarDecl for X<T>::value (within the\n  /// class template X) and will be marked TSK_ImplicitInstantiation.\n  llvm::DenseMap<const VarDecl *, TemplateOrSpecializationInfo>\n  TemplateOrInstantiation;\n\n  /// Keeps track of the declaration from which a using declaration was\n  /// created during instantiation.\n  ///\n  /// The source and target declarations are always a UsingDecl, an\n  /// UnresolvedUsingValueDecl, or an UnresolvedUsingTypenameDecl.\n  ///\n  /// For example:\n  /// \\code\n  /// template<typename T>\n  /// struct A {\n  ///   void f();\n  /// };\n  ///\n  /// template<typename T>\n  /// struct B : A<T> {\n  ///   using A<T>::f;\n  /// };\n  ///\n  /// template struct B<int>;\n  /// \\endcode\n  ///\n  /// This mapping will contain an entry that maps from the UsingDecl in\n  /// B<int> to the UnresolvedUsingDecl in B<T>.\n  llvm::DenseMap<NamedDecl *, NamedDecl *> InstantiatedFromUsingDecl;\n\n  llvm::DenseMap<UsingShadowDecl*, UsingShadowDecl*>\n    InstantiatedFromUsingShadowDecl;\n\n  llvm::DenseMap<FieldDecl *, FieldDecl *> InstantiatedFromUnnamedFieldDecl;\n\n  /// Mapping that stores the methods overridden by a given C++\n  /// member function.\n  ///\n  /// Since most C++ member functions aren't virtual and therefore\n  /// don't override anything, we store the overridden functions in\n  /// this map on the side rather than within the CXXMethodDecl structure.\n  using CXXMethodVector = llvm::TinyPtrVector<const CXXMethodDecl *>;\n  llvm::DenseMap<const CXXMethodDecl *, CXXMethodVector> OverriddenMethods;\n\n  /// Mapping from each declaration context to its corresponding\n  /// mangling numbering context (used for constructs like lambdas which\n  /// need to be consistently numbered for the mangler).\n  llvm::DenseMap<const DeclContext *, std::unique_ptr<MangleNumberingContext>>\n      MangleNumberingContexts;\n  llvm::DenseMap<const Decl *, std::unique_ptr<MangleNumberingContext>>\n      ExtraMangleNumberingContexts;\n\n  /// Side-table of mangling numbers for declarations which rarely\n  /// need them (like static local vars).\n  llvm::MapVector<const NamedDecl *, unsigned> MangleNumbers;\n  llvm::MapVector<const VarDecl *, unsigned> StaticLocalNumbers;\n  /// Mapping the associated device lambda mangling number if present.\n  mutable llvm::DenseMap<const CXXRecordDecl *, unsigned>\n      DeviceLambdaManglingNumbers;\n\n  /// Mapping that stores parameterIndex values for ParmVarDecls when\n  /// that value exceeds the bitfield size of ParmVarDeclBits.ParameterIndex.\n  using ParameterIndexTable = llvm::DenseMap<const VarDecl *, unsigned>;\n  ParameterIndexTable ParamIndices;\n\n  ImportDecl *FirstLocalImport = nullptr;\n  ImportDecl *LastLocalImport = nullptr;\n\n  TranslationUnitDecl *TUDecl;\n  mutable ExternCContextDecl *ExternCContext = nullptr;\n  mutable BuiltinTemplateDecl *MakeIntegerSeqDecl = nullptr;\n  mutable BuiltinTemplateDecl *TypePackElementDecl = nullptr;\n\n  /// The associated SourceManager object.\n  SourceManager &SourceMgr;\n\n  /// The language options used to create the AST associated with\n  ///  this ASTContext object.\n  LangOptions &LangOpts;\n\n  /// NoSanitizeList object that is used by sanitizers to decide which\n  /// entities should not be instrumented.\n  std::unique_ptr<NoSanitizeList> NoSanitizeL;\n\n  /// Function filtering mechanism to determine whether a given function\n  /// should be imbued with the XRay \"always\" or \"never\" attributes.\n  std::unique_ptr<XRayFunctionFilter> XRayFilter;\n\n  /// ProfileList object that is used by the profile instrumentation\n  /// to decide which entities should be instrumented.\n  std::unique_ptr<ProfileList> ProfList;\n\n  /// The allocator used to create AST objects.\n  ///\n  /// AST objects are never destructed; rather, all memory associated with the\n  /// AST objects will be released when the ASTContext itself is destroyed.\n  mutable llvm::BumpPtrAllocator BumpAlloc;\n\n  /// Allocator for partial diagnostics.\n  PartialDiagnostic::DiagStorageAllocator DiagAllocator;\n\n  /// The current C++ ABI.\n  std::unique_ptr<CXXABI> ABI;\n  CXXABI *createCXXABI(const TargetInfo &T);\n\n  /// The logical -> physical address space map.\n  const LangASMap *AddrSpaceMap = nullptr;\n\n  /// Address space map mangling must be used with language specific\n  /// address spaces (e.g. OpenCL/CUDA)\n  bool AddrSpaceMapMangling;\n\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  clang::PrintingPolicy PrintingPolicy;\n  std::unique_ptr<interp::Context> InterpContext;\n  std::unique_ptr<ParentMapContext> ParentMapCtx;\n\npublic:\n  IdentifierTable &Idents;\n  SelectorTable &Selectors;\n  Builtin::Context &BuiltinInfo;\n  mutable DeclarationNameTable DeclarationNames;\n  IntrusiveRefCntPtr<ExternalASTSource> ExternalSource;\n  ASTMutationListener *Listener = nullptr;\n\n  /// Returns the clang bytecode interpreter context.\n  interp::Context &getInterpContext();\n\n  /// Returns the dynamic AST node parent map context.\n  ParentMapContext &getParentMapContext();\n\n  // A traversal scope limits the parts of the AST visible to certain analyses.\n  // RecursiveASTVisitor::TraverseAST will only visit reachable nodes, and\n  // getParents() will only observe reachable parent edges.\n  //\n  // The scope is defined by a set of \"top-level\" declarations.\n  // Initially, it is the entire TU: {getTranslationUnitDecl()}.\n  // Changing the scope clears the parent cache, which is expensive to rebuild.\n  std::vector<Decl *> getTraversalScope() const { return TraversalScope; }\n  void setTraversalScope(const std::vector<Decl *> &);\n\n  /// Forwards to get node parents from the ParentMapContext. New callers should\n  /// use ParentMapContext::getParents() directly.\n  template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);\n\n  const clang::PrintingPolicy &getPrintingPolicy() const {\n    return PrintingPolicy;\n  }\n\n  void setPrintingPolicy(const clang::PrintingPolicy &Policy) {\n    PrintingPolicy = Policy;\n  }\n\n  SourceManager& getSourceManager() { return SourceMgr; }\n  const SourceManager& getSourceManager() const { return SourceMgr; }\n\n  llvm::BumpPtrAllocator &getAllocator() const {\n    return BumpAlloc;\n  }\n\n  void *Allocate(size_t Size, unsigned Align = 8) const {\n    return BumpAlloc.Allocate(Size, Align);\n  }\n  template <typename T> T *Allocate(size_t Num = 1) const {\n    return static_cast<T *>(Allocate(Num * sizeof(T), alignof(T)));\n  }\n  void Deallocate(void *Ptr) const {}\n\n  /// Return the total amount of physical memory allocated for representing\n  /// AST nodes and type information.\n  size_t getASTAllocatedMemory() const {\n    return BumpAlloc.getTotalMemory();\n  }\n\n  /// Return the total memory used for various side tables.\n  size_t getSideTableAllocatedMemory() const;\n\n  PartialDiagnostic::DiagStorageAllocator &getDiagAllocator() {\n    return DiagAllocator;\n  }\n\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n\n  /// getIntTypeForBitwidth -\n  /// sets integer QualTy according to specified details:\n  /// bitwidth, signed/unsigned.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getIntTypeForBitwidth(unsigned DestWidth,\n                                 unsigned Signed) const;\n\n  /// getRealTypeForBitwidth -\n  /// sets floating point QualTy according to specified bitwidth.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getRealTypeForBitwidth(unsigned DestWidth, bool ExplicitIEEE) const;\n\n  bool AtomicUsesUnsupportedLibcall(const AtomicExpr *E) const;\n\n  const LangOptions& getLangOpts() const { return LangOpts; }\n\n  // If this condition is false, typo correction must be performed eagerly\n  // rather than delayed in many places, as it makes use of dependent types.\n  // the condition is false for clang's C-only codepath, as it doesn't support\n  // dependent types yet.\n  bool isDependenceAllowed() const {\n    return LangOpts.CPlusPlus || LangOpts.RecoveryAST;\n  }\n\n  const NoSanitizeList &getNoSanitizeList() const { return *NoSanitizeL; }\n\n  const XRayFunctionFilter &getXRayFilter() const {\n    return *XRayFilter;\n  }\n\n  const ProfileList &getProfileList() const { return *ProfList; }\n\n  DiagnosticsEngine &getDiagnostics() const;\n\n  FullSourceLoc getFullLoc(SourceLocation Loc) const {\n    return FullSourceLoc(Loc,SourceMgr);\n  }\n\n  /// All comments in this translation unit.\n  RawCommentList Comments;\n\n  /// True if comments are already loaded from ExternalASTSource.\n  mutable bool CommentsLoaded = false;\n\n  /// Mapping from declaration to directly attached comment.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const RawComment *> DeclRawComments;\n\n  /// Mapping from canonical declaration to the first redeclaration in chain\n  /// that has a comment attached.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const Decl *> RedeclChainComments;\n\n  /// Keeps track of redeclaration chains that don't have any comment attached.\n  /// Mapping from canonical declaration to redeclaration chain that has no\n  /// comments attached to any redeclaration. Specifically it's mapping to\n  /// the last redeclaration we've checked.\n  ///\n  /// Shall not contain declarations that have comments attached to any\n  /// redeclaration in their chain.\n  mutable llvm::DenseMap<const Decl *, const Decl *> CommentlessRedeclChains;\n\n  /// Mapping from declarations to parsed comments attached to any\n  /// redeclaration.\n  mutable llvm::DenseMap<const Decl *, comments::FullComment *> ParsedComments;\n\n  /// Attaches \\p Comment to \\p OriginalD and to its redeclaration chain\n  /// and removes the redeclaration chain from the set of commentless chains.\n  ///\n  /// Don't do anything if a comment has already been attached to \\p OriginalD\n  /// or its redeclaration chain.\n  void cacheRawCommentForDecl(const Decl &OriginalD,\n                              const RawComment &Comment) const;\n\n  /// \\returns searches \\p CommentsInFile for doc comment for \\p D.\n  ///\n  /// \\p RepresentativeLocForDecl is used as a location for searching doc\n  /// comments. \\p CommentsInFile is a mapping offset -> comment of files in the\n  /// same file where \\p RepresentativeLocForDecl is.\n  RawComment *getRawCommentForDeclNoCacheImpl(\n      const Decl *D, const SourceLocation RepresentativeLocForDecl,\n      const std::map<unsigned, RawComment *> &CommentsInFile) const;\n\n  /// Return the documentation comment attached to a given declaration,\n  /// without looking into cache.\n  RawComment *getRawCommentForDeclNoCache(const Decl *D) const;\n\npublic:\n  void addComment(const RawComment &RC);\n\n  /// Return the documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param OriginalDecl if not nullptr, is set to declaration AST node that\n  /// had the comment, if the comment we found comes from a redeclaration.\n  const RawComment *\n  getRawCommentForAnyRedecl(const Decl *D,\n                            const Decl **OriginalDecl = nullptr) const;\n\n  /// Searches existing comments for doc comments that should be attached to \\p\n  /// Decls. If any doc comment is found, it is parsed.\n  ///\n  /// Requirement: All \\p Decls are in the same file.\n  ///\n  /// If the last comment in the file is already attached we assume\n  /// there are not comments left to be attached to \\p Decls.\n  void attachCommentsToJustParsedDecls(ArrayRef<Decl *> Decls,\n                                       const Preprocessor *PP);\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param PP the Preprocessor used with this TU.  Could be nullptr if\n  /// preprocessor is not available.\n  comments::FullComment *getCommentForDecl(const Decl *D,\n                                           const Preprocessor *PP) const;\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached. Does not look at any\n  /// redeclarations of the declaration.\n  comments::FullComment *getLocalCommentForDeclUncached(const Decl *D) const;\n\n  comments::FullComment *cloneFullComment(comments::FullComment *FC,\n                                         const Decl *D) const;\n\nprivate:\n  mutable comments::CommandTraits CommentCommandTraits;\n\n  /// Iterator that visits import declarations.\n  class import_iterator {\n    ImportDecl *Import = nullptr;\n\n  public:\n    using value_type = ImportDecl *;\n    using reference = ImportDecl *;\n    using pointer = ImportDecl *;\n    using difference_type = int;\n    using iterator_category = std::forward_iterator_tag;\n\n    import_iterator() = default;\n    explicit import_iterator(ImportDecl *Import) : Import(Import) {}\n\n    reference operator*() const { return Import; }\n    pointer operator->() const { return Import; }\n\n    import_iterator &operator++() {\n      Import = ASTContext::getNextLocalImport(Import);\n      return *this;\n    }\n\n    import_iterator operator++(int) {\n      import_iterator Other(*this);\n      ++(*this);\n      return Other;\n    }\n\n    friend bool operator==(import_iterator X, import_iterator Y) {\n      return X.Import == Y.Import;\n    }\n\n    friend bool operator!=(import_iterator X, import_iterator Y) {\n      return X.Import != Y.Import;\n    }\n  };\n\npublic:\n  comments::CommandTraits &getCommentCommandTraits() const {\n    return CommentCommandTraits;\n  }\n\n  /// Retrieve the attributes for the given declaration.\n  AttrVec& getDeclAttrs(const Decl *D);\n\n  /// Erase the attributes corresponding to the given declaration.\n  void eraseDeclAttrs(const Decl *D);\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  // FIXME: Remove ?\n  MemberSpecializationInfo *getInstantiatedFromStaticDataMember(\n                                                           const VarDecl *Var);\n\n  TemplateOrSpecializationInfo\n  getTemplateOrSpecializationInfo(const VarDecl *Var);\n\n  /// Note that the static data member \\p Inst is an instantiation of\n  /// the static data member template \\p Tmpl of a class template.\n  void setInstantiatedFromStaticDataMember(VarDecl *Inst, VarDecl *Tmpl,\n                                           TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  void setTemplateOrSpecializationInfo(VarDecl *Inst,\n                                       TemplateOrSpecializationInfo TSI);\n\n  /// If the given using decl \\p Inst is an instantiation of a\n  /// (possibly unresolved) using decl from a template instantiation,\n  /// return it.\n  NamedDecl *getInstantiatedFromUsingDecl(NamedDecl *Inst);\n\n  /// Remember that the using decl \\p Inst is an instantiation\n  /// of the using decl \\p Pattern of a class template.\n  void setInstantiatedFromUsingDecl(NamedDecl *Inst, NamedDecl *Pattern);\n\n  void setInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst,\n                                          UsingShadowDecl *Pattern);\n  UsingShadowDecl *getInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst);\n\n  FieldDecl *getInstantiatedFromUnnamedFieldDecl(FieldDecl *Field);\n\n  void setInstantiatedFromUnnamedFieldDecl(FieldDecl *Inst, FieldDecl *Tmpl);\n\n  // Access to the set of methods overridden by the given C++ method.\n  using overridden_cxx_method_iterator = CXXMethodVector::const_iterator;\n  overridden_cxx_method_iterator\n  overridden_methods_begin(const CXXMethodDecl *Method) const;\n\n  overridden_cxx_method_iterator\n  overridden_methods_end(const CXXMethodDecl *Method) const;\n\n  unsigned overridden_methods_size(const CXXMethodDecl *Method) const;\n\n  using overridden_method_range =\n      llvm::iterator_range<overridden_cxx_method_iterator>;\n\n  overridden_method_range overridden_methods(const CXXMethodDecl *Method) const;\n\n  /// Note that the given C++ \\p Method overrides the given \\p\n  /// Overridden method.\n  void addOverriddenMethod(const CXXMethodDecl *Method,\n                           const CXXMethodDecl *Overridden);\n\n  /// Return C++ or ObjC overridden methods for the given \\p Method.\n  ///\n  /// An ObjC method is considered to override any method in the class's\n  /// base classes, its protocols, or its categories' protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  void getOverriddenMethods(\n                        const NamedDecl *Method,\n                        SmallVectorImpl<const NamedDecl *> &Overridden) const;\n\n  /// Notify the AST context that a new import declaration has been\n  /// parsed or implicitly created within this translation unit.\n  void addedLocalImportDecl(ImportDecl *Import);\n\n  static ImportDecl *getNextLocalImport(ImportDecl *Import) {\n    return Import->getNextLocalImport();\n  }\n\n  using import_range = llvm::iterator_range<import_iterator>;\n\n  import_range local_imports() const {\n    return import_range(import_iterator(FirstLocalImport), import_iterator());\n  }\n\n  Decl *getPrimaryMergedDecl(Decl *D) {\n    Decl *Result = MergedDecls.lookup(D);\n    return Result ? Result : D;\n  }\n  void setPrimaryMergedDecl(Decl *D, Decl *Primary) {\n    MergedDecls[D] = Primary;\n  }\n\n  /// Note that the definition \\p ND has been merged into module \\p M,\n  /// and should be visible whenever \\p M is visible.\n  void mergeDefinitionIntoModule(NamedDecl *ND, Module *M,\n                                 bool NotifyListeners = true);\n\n  /// Clean up the merged definition list. Call this if you might have\n  /// added duplicates into the list.\n  void deduplicateMergedDefinitonsFor(NamedDecl *ND);\n\n  /// Get the additional modules in which the definition \\p Def has\n  /// been merged.\n  ArrayRef<Module*> getModulesWithMergedDefinition(const NamedDecl *Def);\n\n  /// Add a declaration to the list of declarations that are initialized\n  /// for a module. This will typically be a global variable (with internal\n  /// linkage) that runs module initializers, such as the iostream initializer,\n  /// or an ImportDecl nominating another module that has initializers.\n  void addModuleInitializer(Module *M, Decl *Init);\n\n  void addLazyModuleInitializers(Module *M, ArrayRef<uint32_t> IDs);\n\n  /// Get the initializations to perform when importing a module, if any.\n  ArrayRef<Decl*> getModuleInitializers(Module *M);\n\n  TranslationUnitDecl *getTranslationUnitDecl() const { return TUDecl; }\n\n  ExternCContextDecl *getExternCContextDecl() const;\n  BuiltinTemplateDecl *getMakeIntegerSeqDecl() const;\n  BuiltinTemplateDecl *getTypePackElementDecl() const;\n\n  // Builtin Types.\n  CanQualType VoidTy;\n  CanQualType BoolTy;\n  CanQualType CharTy;\n  CanQualType WCharTy;  // [C++ 3.9.1p5].\n  CanQualType WideCharTy; // Same as WCharTy in C++, integer type in C99.\n  CanQualType WIntTy;   // [C99 7.24.1], integer type unchanged by default promotions.\n  CanQualType Char8Ty;  // [C++20 proposal]\n  CanQualType Char16Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType Char32Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType SignedCharTy, ShortTy, IntTy, LongTy, LongLongTy, Int128Ty;\n  CanQualType UnsignedCharTy, UnsignedShortTy, UnsignedIntTy, UnsignedLongTy;\n  CanQualType UnsignedLongLongTy, UnsignedInt128Ty;\n  CanQualType FloatTy, DoubleTy, LongDoubleTy, Float128Ty;\n  CanQualType ShortAccumTy, AccumTy,\n      LongAccumTy;  // ISO/IEC JTC1 SC22 WG14 N1169 Extension\n  CanQualType UnsignedShortAccumTy, UnsignedAccumTy, UnsignedLongAccumTy;\n  CanQualType ShortFractTy, FractTy, LongFractTy;\n  CanQualType UnsignedShortFractTy, UnsignedFractTy, UnsignedLongFractTy;\n  CanQualType SatShortAccumTy, SatAccumTy, SatLongAccumTy;\n  CanQualType SatUnsignedShortAccumTy, SatUnsignedAccumTy,\n      SatUnsignedLongAccumTy;\n  CanQualType SatShortFractTy, SatFractTy, SatLongFractTy;\n  CanQualType SatUnsignedShortFractTy, SatUnsignedFractTy,\n      SatUnsignedLongFractTy;\n  CanQualType HalfTy; // [OpenCL 6.1.1.1], ARM NEON\n  CanQualType BFloat16Ty;\n  CanQualType Float16Ty; // C11 extension ISO/IEC TS 18661-3\n  CanQualType FloatComplexTy, DoubleComplexTy, LongDoubleComplexTy;\n  CanQualType Float128ComplexTy;\n  CanQualType VoidPtrTy, NullPtrTy;\n  CanQualType DependentTy, OverloadTy, BoundMemberTy, UnknownAnyTy;\n  CanQualType BuiltinFnTy;\n  CanQualType PseudoObjectTy, ARCUnbridgedCastTy;\n  CanQualType ObjCBuiltinIdTy, ObjCBuiltinClassTy, ObjCBuiltinSelTy;\n  CanQualType ObjCBuiltinBoolTy;\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  CanQualType OCLSamplerTy, OCLEventTy, OCLClkEventTy;\n  CanQualType OCLQueueTy, OCLReserveIDTy;\n  CanQualType IncompleteMatrixIdxTy;\n  CanQualType OMPArraySectionTy, OMPArrayShapingTy, OMPIteratorTy;\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n#define SVE_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/RISCVVTypes.def\"\n\n  // Types for deductions in C++0x [stmt.ranged]'s desugaring. Built on demand.\n  mutable QualType AutoDeductTy;     // Deduction against 'auto'.\n  mutable QualType AutoRRefDeductTy; // Deduction against 'auto &&'.\n\n  // Decl used to help define __builtin_va_list for some targets.\n  // The decl is built when constructing 'BuiltinVaListDecl'.\n  mutable Decl *VaListTagDecl = nullptr;\n\n  // Implicitly-declared type 'struct _GUID'.\n  mutable TagDecl *MSGuidTagDecl = nullptr;\n\n  /// Keep track of CUDA/HIP static device variables referenced by host code.\n  llvm::DenseSet<const VarDecl *> CUDAStaticDeviceVarReferencedByHost;\n\n  ASTContext(LangOptions &LOpts, SourceManager &SM, IdentifierTable &idents,\n             SelectorTable &sels, Builtin::Context &builtins);\n  ASTContext(const ASTContext &) = delete;\n  ASTContext &operator=(const ASTContext &) = delete;\n  ~ASTContext();\n\n  /// Attach an external AST source to the AST context.\n  ///\n  /// The external AST source provides the ability to load parts of\n  /// the abstract syntax tree as needed from some external storage,\n  /// e.g., a precompiled header.\n  void setExternalSource(IntrusiveRefCntPtr<ExternalASTSource> Source);\n\n  /// Retrieve a pointer to the external AST source associated\n  /// with this AST context, if any.\n  ExternalASTSource *getExternalSource() const {\n    return ExternalSource.get();\n  }\n\n  /// Attach an AST mutation listener to the AST context.\n  ///\n  /// The AST mutation listener provides the ability to track modifications to\n  /// the abstract syntax tree entities committed after they were initially\n  /// created.\n  void setASTMutationListener(ASTMutationListener *Listener) {\n    this->Listener = Listener;\n  }\n\n  /// Retrieve a pointer to the AST mutation listener associated\n  /// with this AST context, if any.\n  ASTMutationListener *getASTMutationListener() const { return Listener; }\n\n  void PrintStats() const;\n  const SmallVectorImpl<Type *>& getTypes() const { return Types; }\n\n  BuiltinTemplateDecl *buildBuiltinTemplateDecl(BuiltinTemplateKind BTK,\n                                                const IdentifierInfo *II) const;\n\n  /// Create a new implicit TU-level CXXRecordDecl or RecordDecl\n  /// declaration.\n  RecordDecl *buildImplicitRecord(StringRef Name,\n                                  RecordDecl::TagKind TK = TTK_Struct) const;\n\n  /// Create a new implicit TU-level typedef declaration.\n  TypedefDecl *buildImplicitTypedef(QualType T, StringRef Name) const;\n\n  /// Retrieve the declaration for the 128-bit signed integer type.\n  TypedefDecl *getInt128Decl() const;\n\n  /// Retrieve the declaration for the 128-bit unsigned integer type.\n  TypedefDecl *getUInt128Decl() const;\n\n  //===--------------------------------------------------------------------===//\n  //                           Type Constructors\n  //===--------------------------------------------------------------------===//\n\nprivate:\n  /// Return a type with extended qualifiers.\n  QualType getExtQualType(const Type *Base, Qualifiers Quals) const;\n\n  QualType getTypeDeclTypeSlow(const TypeDecl *Decl) const;\n\n  QualType getPipeType(QualType T, bool ReadOnly) const;\n\npublic:\n  /// Return the uniqued reference to the type for an address space\n  /// qualified type with the specified type and address space.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the address\n  /// space. If T already has an address space specifier, it is silently\n  /// replaced.\n  QualType getAddrSpaceQualType(QualType T, LangAS AddressSpace) const;\n\n  /// Remove any existing address space on the type and returns the type\n  /// with qualifiers intact (or that's the idea anyway)\n  ///\n  /// The return type should be T with all prior qualifiers minus the address\n  /// space.\n  QualType removeAddrSpaceQualType(QualType T) const;\n\n  /// Apply Objective-C protocol qualifiers to the given type.\n  /// \\param allowOnPointerType specifies if we can apply protocol\n  /// qualifiers on ObjCObjectPointerType. It can be set to true when\n  /// constructing the canonical type of a Objective-C type parameter.\n  QualType applyObjCProtocolQualifiers(QualType type,\n      ArrayRef<ObjCProtocolDecl *> protocols, bool &hasError,\n      bool allowOnPointerType = false) const;\n\n  /// Return the uniqued reference to the type for an Objective-C\n  /// gc-qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the gc\n  /// attribute.\n  QualType getObjCGCQualType(QualType T, Qualifiers::GC gcAttr) const;\n\n  /// Remove the existing address space on the type if it is a pointer size\n  /// address space and return the type with qualifiers intact.\n  QualType removePtrSizeAddrSpace(QualType T) const;\n\n  /// Return the uniqued reference to the type for a \\c restrict\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c restrict.\n  QualType getRestrictType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  /// Return the uniqued reference to the type for a \\c volatile\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c volatile.\n  QualType getVolatileType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Return the uniqued reference to the type for a \\c const\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and \\c const.\n  ///\n  /// It can be reasonably expected that this will always be equivalent to\n  /// calling T.withConst().\n  QualType getConstType(QualType T) const { return T.withConst(); }\n\n  /// Change the ExtInfo on a function type.\n  const FunctionType *adjustFunctionType(const FunctionType *Fn,\n                                         FunctionType::ExtInfo EInfo);\n\n  /// Adjust the given function result type.\n  CanQualType getCanonicalFunctionResultType(QualType ResultType) const;\n\n  /// Change the result type of a function type once it is deduced.\n  void adjustDeducedFunctionResultType(FunctionDecl *FD, QualType ResultType);\n\n  /// Get a function type and produce the equivalent function type with the\n  /// specified exception specification. Type sugar that can be present on a\n  /// declaration of a function with an exception specification is permitted\n  /// and preserved. Other type sugar (for instance, typedefs) is not.\n  QualType getFunctionTypeWithExceptionSpec(\n      QualType Orig, const FunctionProtoType::ExceptionSpecInfo &ESI);\n\n  /// Determine whether two function types are the same, ignoring\n  /// exception specifications in cases where they're part of the type.\n  bool hasSameFunctionTypeIgnoringExceptionSpec(QualType T, QualType U);\n\n  /// Change the exception specification on a function once it is\n  /// delay-parsed, instantiated, or computed.\n  void adjustExceptionSpec(FunctionDecl *FD,\n                           const FunctionProtoType::ExceptionSpecInfo &ESI,\n                           bool AsWritten = false);\n\n  /// Get a function type and produce the equivalent function type where\n  /// pointer size address spaces in the return type and parameter tyeps are\n  /// replaced with the default address space.\n  QualType getFunctionTypeWithoutPtrSizes(QualType T);\n\n  /// Determine whether two function types are the same, ignoring pointer sizes\n  /// in the return type and parameter types.\n  bool hasSameFunctionTypeIgnoringPtrSizes(QualType T, QualType U);\n\n  /// Return the uniqued reference to the type for a complex\n  /// number with the specified element type.\n  QualType getComplexType(QualType T) const;\n  CanQualType getComplexType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getComplexType((QualType) T));\n  }\n\n  /// Return the uniqued reference to the type for a pointer to\n  /// the specified type.\n  QualType getPointerType(QualType T) const;\n  CanQualType getPointerType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getPointerType((QualType) T));\n  }\n\n  /// Return the uniqued reference to a type adjusted from the original\n  /// type to a new type.\n  QualType getAdjustedType(QualType Orig, QualType New) const;\n  CanQualType getAdjustedType(CanQualType Orig, CanQualType New) const {\n    return CanQualType::CreateUnsafe(\n        getAdjustedType((QualType)Orig, (QualType)New));\n  }\n\n  /// Return the uniqued reference to the decayed version of the given\n  /// type.  Can only be called on array and function types which decay to\n  /// pointer types.\n  QualType getDecayedType(QualType T) const;\n  CanQualType getDecayedType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getDecayedType((QualType) T));\n  }\n\n  /// Return the uniqued reference to the atomic type for the specified\n  /// type.\n  QualType getAtomicType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a block of the\n  /// specified type.\n  QualType getBlockPointerType(QualType T) const;\n\n  /// Gets the struct used to keep track of the descriptor for pointer to\n  /// blocks.\n  QualType getBlockDescriptorType() const;\n\n  /// Return a read_only pipe type for the specified type.\n  QualType getReadPipeType(QualType T) const;\n\n  /// Return a write_only pipe type for the specified type.\n  QualType getWritePipeType(QualType T) const;\n\n  /// Return an extended integer type with the specified signedness and bit\n  /// count.\n  QualType getExtIntType(bool Unsigned, unsigned NumBits) const;\n\n  /// Return a dependent extended integer type with the specified signedness and\n  /// bit count.\n  QualType getDependentExtIntType(bool Unsigned, Expr *BitsExpr) const;\n\n  /// Gets the struct used to keep track of the extended descriptor for\n  /// pointer to blocks.\n  QualType getBlockDescriptorExtendedType() const;\n\n  /// Map an AST Type to an OpenCLTypeKind enum value.\n  OpenCLTypeKind getOpenCLTypeKind(const Type *T) const;\n\n  /// Get address space for OpenCL type.\n  LangAS getOpenCLTypeAddrSpace(const Type *T) const;\n\n  void setcudaConfigureCallDecl(FunctionDecl *FD) {\n    cudaConfigureCallDecl = FD;\n  }\n\n  FunctionDecl *getcudaConfigureCallDecl() {\n    return cudaConfigureCallDecl;\n  }\n\n  /// Returns true iff we need copy/dispose helpers for the given type.\n  bool BlockRequiresCopying(QualType Ty, const VarDecl *D);\n\n  /// Returns true, if given type has a known lifetime. HasByrefExtendedLayout\n  /// is set to false in this case. If HasByrefExtendedLayout returns true,\n  /// byref variable has extended lifetime.\n  bool getByrefLifetime(QualType Ty,\n                        Qualifiers::ObjCLifetime &Lifetime,\n                        bool &HasByrefExtendedLayout) const;\n\n  /// Return the uniqued reference to the type for an lvalue reference\n  /// to the specified type.\n  QualType getLValueReferenceType(QualType T, bool SpelledAsLValue = true)\n    const;\n\n  /// Return the uniqued reference to the type for an rvalue reference\n  /// to the specified type.\n  QualType getRValueReferenceType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a member pointer to\n  /// the specified type in the specified class.\n  ///\n  /// The class \\p Cls is a \\c Type because it could be a dependent name.\n  QualType getMemberPointerType(QualType T, const Type *Cls) const;\n\n  /// Return a non-unique reference to the type for a variable array of\n  /// the specified element type.\n  QualType getVariableArrayType(QualType EltTy, Expr *NumElts,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals,\n                                SourceRange Brackets) const;\n\n  /// Return a non-unique reference to the type for a dependently-sized\n  /// array of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedArrayType(QualType EltTy, Expr *NumElts,\n                                      ArrayType::ArraySizeModifier ASM,\n                                      unsigned IndexTypeQuals,\n                                      SourceRange Brackets) const;\n\n  /// Return a unique reference to the type for an incomplete array of\n  /// the specified element type.\n  QualType getIncompleteArrayType(QualType EltTy,\n                                  ArrayType::ArraySizeModifier ASM,\n                                  unsigned IndexTypeQuals) const;\n\n  /// Return the unique reference to the type for a constant array of\n  /// the specified element type.\n  QualType getConstantArrayType(QualType EltTy, const llvm::APInt &ArySize,\n                                const Expr *SizeExpr,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals) const;\n\n  /// Return a type for a constant array for a string literal of the\n  /// specified element type and length.\n  QualType getStringLiteralArrayType(QualType EltTy, unsigned Length) const;\n\n  /// Returns a vla type where known sizes are replaced with [*].\n  QualType getVariableArrayDecayedType(QualType Ty) const;\n\n  // Convenience struct to return information about a builtin vector type.\n  struct BuiltinVectorTypeInfo {\n    QualType ElementType;\n    llvm::ElementCount EC;\n    unsigned NumVectors;\n    BuiltinVectorTypeInfo(QualType ElementType, llvm::ElementCount EC,\n                          unsigned NumVectors)\n        : ElementType(ElementType), EC(EC), NumVectors(NumVectors) {}\n  };\n\n  /// Returns the element type, element count and number of vectors\n  /// (in case of tuple) for a builtin vector type.\n  BuiltinVectorTypeInfo\n  getBuiltinVectorTypeInfo(const BuiltinType *VecTy) const;\n\n  /// Return the unique reference to a scalable vector type of the specified\n  /// element type and scalable number of elements.\n  ///\n  /// \\pre \\p EltTy must be a built-in type.\n  QualType getScalableVectorType(QualType EltTy, unsigned NumElts) const;\n\n  /// Return the unique reference to a vector type of the specified\n  /// element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getVectorType(QualType VectorType, unsigned NumElts,\n                         VectorType::VectorKind VecKind) const;\n  /// Return the unique reference to the type for a dependently sized vector of\n  /// the specified element type.\n  QualType getDependentVectorType(QualType VectorType, Expr *SizeExpr,\n                                  SourceLocation AttrLoc,\n                                  VectorType::VectorKind VecKind) const;\n\n  /// Return the unique reference to an extended vector type\n  /// of the specified element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getExtVectorType(QualType VectorType, unsigned NumElts) const;\n\n  /// \\pre Return a non-unique reference to the type for a dependently-sized\n  /// vector of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedExtVectorType(QualType VectorType,\n                                          Expr *SizeExpr,\n                                          SourceLocation AttrLoc) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  ///\n  /// \\pre \\p ElementType must be a valid matrix element type (see\n  /// MatrixType::isValidElementType).\n  QualType getConstantMatrixType(QualType ElementType, unsigned NumRows,\n                                 unsigned NumColumns) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  QualType getDependentSizedMatrixType(QualType ElementType, Expr *RowExpr,\n                                       Expr *ColumnExpr,\n                                       SourceLocation AttrLoc) const;\n\n  QualType getDependentAddressSpaceType(QualType PointeeType,\n                                        Expr *AddrSpaceExpr,\n                                        SourceLocation AttrLoc) const;\n\n  /// Return a K&R style C function type like 'int()'.\n  QualType getFunctionNoProtoType(QualType ResultTy,\n                                  const FunctionType::ExtInfo &Info) const;\n\n  QualType getFunctionNoProtoType(QualType ResultTy) const {\n    return getFunctionNoProtoType(ResultTy, FunctionType::ExtInfo());\n  }\n\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionType(QualType ResultTy, ArrayRef<QualType> Args,\n                           const FunctionProtoType::ExtProtoInfo &EPI) const {\n    return getFunctionTypeInternal(ResultTy, Args, EPI, false);\n  }\n\n  QualType adjustStringLiteralBaseType(QualType StrLTy) const;\n\nprivate:\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionTypeInternal(QualType ResultTy, ArrayRef<QualType> Args,\n                                   const FunctionProtoType::ExtProtoInfo &EPI,\n                                   bool OnlyWantCanonical) const;\n\npublic:\n  /// Return the unique reference to the type for the specified type\n  /// declaration.\n  QualType getTypeDeclType(const TypeDecl *Decl,\n                           const TypeDecl *PrevDecl = nullptr) const {\n    assert(Decl && \"Passed null for Decl param\");\n    if (Decl->TypeForDecl) return QualType(Decl->TypeForDecl, 0);\n\n    if (PrevDecl) {\n      assert(PrevDecl->TypeForDecl && \"previous decl has no TypeForDecl\");\n      Decl->TypeForDecl = PrevDecl->TypeForDecl;\n      return QualType(PrevDecl->TypeForDecl, 0);\n    }\n\n    return getTypeDeclTypeSlow(Decl);\n  }\n\n  /// Return the unique reference to the type for the specified\n  /// typedef-name decl.\n  QualType getTypedefType(const TypedefNameDecl *Decl,\n                          QualType Underlying = QualType()) const;\n\n  QualType getRecordType(const RecordDecl *Decl) const;\n\n  QualType getEnumType(const EnumDecl *Decl) const;\n\n  QualType getInjectedClassNameType(CXXRecordDecl *Decl, QualType TST) const;\n\n  QualType getAttributedType(attr::Kind attrKind,\n                             QualType modifiedType,\n                             QualType equivalentType);\n\n  QualType getSubstTemplateTypeParmType(const TemplateTypeParmType *Replaced,\n                                        QualType Replacement) const;\n  QualType getSubstTemplateTypeParmPackType(\n                                          const TemplateTypeParmType *Replaced,\n                                            const TemplateArgument &ArgPack);\n\n  QualType\n  getTemplateTypeParmType(unsigned Depth, unsigned Index,\n                          bool ParameterPack,\n                          TemplateTypeParmDecl *ParmDecl = nullptr) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args,\n                                         QualType Canon = QualType()) const;\n\n  QualType\n  getCanonicalTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         const TemplateArgumentListInfo &Args,\n                                         QualType Canon = QualType()) const;\n\n  TypeSourceInfo *\n  getTemplateSpecializationTypeInfo(TemplateName T, SourceLocation TLoc,\n                                    const TemplateArgumentListInfo &Args,\n                                    QualType Canon = QualType()) const;\n\n  QualType getParenType(QualType NamedType) const;\n\n  QualType getMacroQualifiedType(QualType UnderlyingTy,\n                                 const IdentifierInfo *MacroII) const;\n\n  QualType getElaboratedType(ElaboratedTypeKeyword Keyword,\n                             NestedNameSpecifier *NNS, QualType NamedType,\n                             TagDecl *OwnedTagDecl = nullptr) const;\n  QualType getDependentNameType(ElaboratedTypeKeyword Keyword,\n                                NestedNameSpecifier *NNS,\n                                const IdentifierInfo *Name,\n                                QualType Canon = QualType()) const;\n\n  QualType getDependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,\n                                                  NestedNameSpecifier *NNS,\n                                                  const IdentifierInfo *Name,\n                                    const TemplateArgumentListInfo &Args) const;\n  QualType getDependentTemplateSpecializationType(\n      ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n      const IdentifierInfo *Name, ArrayRef<TemplateArgument> Args) const;\n\n  TemplateArgument getInjectedTemplateArg(NamedDecl *ParamDecl);\n\n  /// Get a template argument list with one argument per template parameter\n  /// in a template parameter list, such as for the injected class name of\n  /// a class template.\n  void getInjectedTemplateArgs(const TemplateParameterList *Params,\n                               SmallVectorImpl<TemplateArgument> &Args);\n\n  /// Form a pack expansion type with the given pattern.\n  /// \\param NumExpansions The number of expansions for the pack, if known.\n  /// \\param ExpectPackInType If \\c false, we should not expect \\p Pattern to\n  ///        contain an unexpanded pack. This only makes sense if the pack\n  ///        expansion is used in a context where the arity is inferred from\n  ///        elsewhere, such as if the pattern contains a placeholder type or\n  ///        if this is the canonical type of another pack expansion type.\n  QualType getPackExpansionType(QualType Pattern,\n                                Optional<unsigned> NumExpansions,\n                                bool ExpectPackInType = true);\n\n  QualType getObjCInterfaceType(const ObjCInterfaceDecl *Decl,\n                                ObjCInterfaceDecl *PrevDecl = nullptr) const;\n\n  /// Legacy interface: cannot provide type arguments or __kindof.\n  QualType getObjCObjectType(QualType Base,\n                             ObjCProtocolDecl * const *Protocols,\n                             unsigned NumProtocols) const;\n\n  QualType getObjCObjectType(QualType Base,\n                             ArrayRef<QualType> typeArgs,\n                             ArrayRef<ObjCProtocolDecl *> protocols,\n                             bool isKindOf) const;\n\n  QualType getObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                ArrayRef<ObjCProtocolDecl *> protocols) const;\n  void adjustObjCTypeParamBoundType(const ObjCTypeParamDecl *Orig,\n                                    ObjCTypeParamDecl *New) const;\n\n  bool ObjCObjectAdoptsQTypeProtocols(QualType QT, ObjCInterfaceDecl *Decl);\n\n  /// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in\n  /// QT's qualified-id protocol list adopt all protocols in IDecl's list\n  /// of protocols.\n  bool QIdProtocolsAdoptObjCObjectProtocols(QualType QT,\n                                            ObjCInterfaceDecl *IDecl);\n\n  /// Return a ObjCObjectPointerType type for the given ObjCObjectType.\n  QualType getObjCObjectPointerType(QualType OIT) const;\n\n  /// GCC extension.\n  QualType getTypeOfExprType(Expr *e) const;\n  QualType getTypeOfType(QualType t) const;\n\n  /// C++11 decltype.\n  QualType getDecltypeType(Expr *e, QualType UnderlyingType) const;\n\n  /// Unary type transforms\n  QualType getUnaryTransformType(QualType BaseType, QualType UnderlyingType,\n                                 UnaryTransformType::UTTKind UKind) const;\n\n  /// C++11 deduced auto type.\n  QualType getAutoType(QualType DeducedType, AutoTypeKeyword Keyword,\n                       bool IsDependent, bool IsPack = false,\n                       ConceptDecl *TypeConstraintConcept = nullptr,\n                       ArrayRef<TemplateArgument> TypeConstraintArgs ={}) const;\n\n  /// C++11 deduction pattern for 'auto' type.\n  QualType getAutoDeductType() const;\n\n  /// C++11 deduction pattern for 'auto &&' type.\n  QualType getAutoRRefDeductType() const;\n\n  /// C++17 deduced class template specialization type.\n  QualType getDeducedTemplateSpecializationType(TemplateName Template,\n                                                QualType DeducedType,\n                                                bool IsDependent) const;\n\n  /// Return the unique reference to the type for the specified TagDecl\n  /// (struct/union/class/enum) decl.\n  QualType getTagDeclType(const TagDecl *Decl) const;\n\n  /// Return the unique type for \"size_t\" (C99 7.17), defined in\n  /// <stddef.h>.\n  ///\n  /// The sizeof operator requires this (C99 6.5.3.4p4).\n  CanQualType getSizeType() const;\n\n  /// Return the unique signed counterpart of\n  /// the integer type corresponding to size_t.\n  CanQualType getSignedSizeType() const;\n\n  /// Return the unique type for \"intmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getIntMaxType() const;\n\n  /// Return the unique type for \"uintmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getUIntMaxType() const;\n\n  /// Return the unique wchar_t type available in C++ (and available as\n  /// __wchar_t as a Microsoft extension).\n  QualType getWCharType() const { return WCharTy; }\n\n  /// Return the type of wide characters. In C++, this returns the\n  /// unique wchar_t type. In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWideCharType() const { return WideCharTy; }\n\n  /// Return the type of \"signed wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getSignedWCharType() const;\n\n  /// Return the type of \"unsigned wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getUnsignedWCharType() const;\n\n  /// In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWIntType() const { return WIntTy; }\n\n  /// Return a type compatible with \"intptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getIntPtrType() const;\n\n  /// Return a type compatible with \"uintptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getUIntPtrType() const;\n\n  /// Return the unique type for \"ptrdiff_t\" (C99 7.17) defined in\n  /// <stddef.h>. Pointer - pointer requires this (C99 6.5.6p9).\n  QualType getPointerDiffType() const;\n\n  /// Return the unique unsigned counterpart of \"ptrdiff_t\"\n  /// integer type. The standard (C11 7.21.6.1p7) refers to this type\n  /// in the definition of %tu format specifier.\n  QualType getUnsignedPointerDiffType() const;\n\n  /// Return the unique type for \"pid_t\" defined in\n  /// <sys/types.h>. We need this to compute the correct type for vfork().\n  QualType getProcessIDType() const;\n\n  /// Return the C structure type used to represent constant CFStrings.\n  QualType getCFConstantStringType() const;\n\n  /// Returns the C struct type for objc_super\n  QualType getObjCSuperType() const;\n  void setObjCSuperType(QualType ST) { ObjCSuperType = ST; }\n\n  /// Get the structure type used to representation CFStrings, or NULL\n  /// if it hasn't yet been built.\n  QualType getRawCFConstantStringType() const {\n    if (CFConstantStringTypeDecl)\n      return getTypedefType(CFConstantStringTypeDecl);\n    return QualType();\n  }\n  void setCFConstantStringType(QualType T);\n  TypedefDecl *getCFConstantStringDecl() const;\n  RecordDecl *getCFConstantStringTagDecl() const;\n\n  // This setter/getter represents the ObjC type for an NSConstantString.\n  void setObjCConstantStringInterface(ObjCInterfaceDecl *Decl);\n  QualType getObjCConstantStringInterface() const {\n    return ObjCConstantStringType;\n  }\n\n  QualType getObjCNSStringType() const {\n    return ObjCNSStringType;\n  }\n\n  void setObjCNSStringType(QualType T) {\n    ObjCNSStringType = T;\n  }\n\n  /// Retrieve the type that \\c id has been defined to, which may be\n  /// different from the built-in \\c id if \\c id has been typedef'd.\n  QualType getObjCIdRedefinitionType() const {\n    if (ObjCIdRedefinitionType.isNull())\n      return getObjCIdType();\n    return ObjCIdRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines \\c id.\n  void setObjCIdRedefinitionType(QualType RedefType) {\n    ObjCIdRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that \\c Class has been defined to, which may be\n  /// different from the built-in \\c Class if \\c Class has been typedef'd.\n  QualType getObjCClassRedefinitionType() const {\n    if (ObjCClassRedefinitionType.isNull())\n      return getObjCClassType();\n    return ObjCClassRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCClassRedefinitionType(QualType RedefType) {\n    ObjCClassRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that 'SEL' has been defined to, which may be\n  /// different from the built-in 'SEL' if 'SEL' has been typedef'd.\n  QualType getObjCSelRedefinitionType() const {\n    if (ObjCSelRedefinitionType.isNull())\n      return getObjCSelType();\n    return ObjCSelRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCSelRedefinitionType(QualType RedefType) {\n    ObjCSelRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the identifier 'NSObject'.\n  IdentifierInfo *getNSObjectName() const {\n    if (!NSObjectName) {\n      NSObjectName = &Idents.get(\"NSObject\");\n    }\n\n    return NSObjectName;\n  }\n\n  /// Retrieve the identifier 'NSCopying'.\n  IdentifierInfo *getNSCopyingName() {\n    if (!NSCopyingName) {\n      NSCopyingName = &Idents.get(\"NSCopying\");\n    }\n\n    return NSCopyingName;\n  }\n\n  CanQualType getNSUIntegerType() const;\n\n  CanQualType getNSIntegerType() const;\n\n  /// Retrieve the identifier 'bool'.\n  IdentifierInfo *getBoolName() const {\n    if (!BoolName)\n      BoolName = &Idents.get(\"bool\");\n    return BoolName;\n  }\n\n  IdentifierInfo *getMakeIntegerSeqName() const {\n    if (!MakeIntegerSeqName)\n      MakeIntegerSeqName = &Idents.get(\"__make_integer_seq\");\n    return MakeIntegerSeqName;\n  }\n\n  IdentifierInfo *getTypePackElementName() const {\n    if (!TypePackElementName)\n      TypePackElementName = &Idents.get(\"__type_pack_element\");\n    return TypePackElementName;\n  }\n\n  /// Retrieve the Objective-C \"instancetype\" type, if already known;\n  /// otherwise, returns a NULL type;\n  QualType getObjCInstanceType() {\n    return getTypeDeclType(getObjCInstanceTypeDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the Objective-C\n  /// \"instancetype\" type.\n  TypedefDecl *getObjCInstanceTypeDecl();\n\n  /// Set the type for the C FILE type.\n  void setFILEDecl(TypeDecl *FILEDecl) { this->FILEDecl = FILEDecl; }\n\n  /// Retrieve the C FILE type.\n  QualType getFILEType() const {\n    if (FILEDecl)\n      return getTypeDeclType(FILEDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C jmp_buf type.\n  void setjmp_bufDecl(TypeDecl *jmp_bufDecl) {\n    this->jmp_bufDecl = jmp_bufDecl;\n  }\n\n  /// Retrieve the C jmp_buf type.\n  QualType getjmp_bufType() const {\n    if (jmp_bufDecl)\n      return getTypeDeclType(jmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C sigjmp_buf type.\n  void setsigjmp_bufDecl(TypeDecl *sigjmp_bufDecl) {\n    this->sigjmp_bufDecl = sigjmp_bufDecl;\n  }\n\n  /// Retrieve the C sigjmp_buf type.\n  QualType getsigjmp_bufType() const {\n    if (sigjmp_bufDecl)\n      return getTypeDeclType(sigjmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C ucontext_t type.\n  void setucontext_tDecl(TypeDecl *ucontext_tDecl) {\n    this->ucontext_tDecl = ucontext_tDecl;\n  }\n\n  /// Retrieve the C ucontext_t type.\n  QualType getucontext_tType() const {\n    if (ucontext_tDecl)\n      return getTypeDeclType(ucontext_tDecl);\n    return QualType();\n  }\n\n  /// The result type of logical operations, '<', '>', '!=', etc.\n  QualType getLogicalOperationType() const {\n    return getLangOpts().CPlusPlus ? BoolTy : IntTy;\n  }\n\n  /// Emit the Objective-CC type encoding for the given type \\p T into\n  /// \\p S.\n  ///\n  /// If \\p Field is specified then record field names are also encoded.\n  void getObjCEncodingForType(QualType T, std::string &S,\n                              const FieldDecl *Field=nullptr,\n                              QualType *NotEncodedT=nullptr) const;\n\n  /// Emit the Objective-C property type encoding for the given\n  /// type \\p T into \\p S.\n  void getObjCEncodingForPropertyType(QualType T, std::string &S) const;\n\n  void getLegacyIntegralTypeEncoding(QualType &t) const;\n\n  /// Put the string version of the type qualifiers \\p QT into \\p S.\n  void getObjCEncodingForTypeQualifier(Decl::ObjCDeclQualifier QT,\n                                       std::string &S) const;\n\n  /// Emit the encoded type for the function \\p Decl into \\p S.\n  ///\n  /// This is in the same format as Objective-C method encodings.\n  ///\n  /// \\returns true if an error occurred (e.g., because one of the parameter\n  /// types is incomplete), false otherwise.\n  std::string getObjCEncodingForFunctionDecl(const FunctionDecl *Decl) const;\n\n  /// Emit the encoded type for the method declaration \\p Decl into\n  /// \\p S.\n  std::string getObjCEncodingForMethodDecl(const ObjCMethodDecl *Decl,\n                                           bool Extended = false) const;\n\n  /// Return the encoded type for this block declaration.\n  std::string getObjCEncodingForBlock(const BlockExpr *blockExpr) const;\n\n  /// getObjCEncodingForPropertyDecl - Return the encoded type for\n  /// this method declaration. If non-NULL, Container must be either\n  /// an ObjCCategoryImplDecl or ObjCImplementationDecl; it should\n  /// only be NULL when getting encodings for protocol properties.\n  std::string getObjCEncodingForPropertyDecl(const ObjCPropertyDecl *PD,\n                                             const Decl *Container) const;\n\n  bool ProtocolCompatibleWithProtocol(ObjCProtocolDecl *lProto,\n                                      ObjCProtocolDecl *rProto) const;\n\n  ObjCPropertyImplDecl *getObjCPropertyImplDeclForPropertyDecl(\n                                                  const ObjCPropertyDecl *PD,\n                                                  const Decl *Container) const;\n\n  /// Return the size of type \\p T for Objective-C encoding purpose,\n  /// in characters.\n  CharUnits getObjCEncodingTypeSize(QualType T) const;\n\n  /// Retrieve the typedef corresponding to the predefined \\c id type\n  /// in Objective-C.\n  TypedefDecl *getObjCIdDecl() const;\n\n  /// Represents the Objective-CC \\c id type.\n  ///\n  /// This is set up lazily, by Sema.  \\c id is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCIdType() const {\n    return getTypeDeclType(getObjCIdDecl());\n  }\n\n  /// Retrieve the typedef corresponding to the predefined 'SEL' type\n  /// in Objective-C.\n  TypedefDecl *getObjCSelDecl() const;\n\n  /// Retrieve the type that corresponds to the predefined Objective-C\n  /// 'SEL' type.\n  QualType getObjCSelType() const {\n    return getTypeDeclType(getObjCSelDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the predefined\n  /// Objective-C 'Class' type.\n  TypedefDecl *getObjCClassDecl() const;\n\n  /// Represents the Objective-C \\c Class type.\n  ///\n  /// This is set up lazily, by Sema.  \\c Class is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCClassType() const {\n    return getTypeDeclType(getObjCClassDecl());\n  }\n\n  /// Retrieve the Objective-C class declaration corresponding to\n  /// the predefined \\c Protocol class.\n  ObjCInterfaceDecl *getObjCProtocolDecl() const;\n\n  /// Retrieve declaration of 'BOOL' typedef\n  TypedefDecl *getBOOLDecl() const {\n    return BOOLDecl;\n  }\n\n  /// Save declaration of 'BOOL' typedef\n  void setBOOLDecl(TypedefDecl *TD) {\n    BOOLDecl = TD;\n  }\n\n  /// type of 'BOOL' type.\n  QualType getBOOLType() const {\n    return getTypeDeclType(getBOOLDecl());\n  }\n\n  /// Retrieve the type of the Objective-C \\c Protocol class.\n  QualType getObjCProtoType() const {\n    return getObjCInterfaceType(getObjCProtocolDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_va_list type.\n  TypedefDecl *getBuiltinVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_va_list type.\n  QualType getBuiltinVaListType() const {\n    return getTypeDeclType(getBuiltinVaListDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __va_list_tag type used to help define the \\c __builtin_va_list type\n  /// for some targets.\n  Decl *getVaListTagDecl() const;\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_ms_va_list type.\n  TypedefDecl *getBuiltinMSVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_ms_va_list type.\n  QualType getBuiltinMSVaListType() const {\n    return getTypeDeclType(getBuiltinMSVaListDecl());\n  }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' declaration.\n  TagDecl *getMSGuidTagDecl() const { return MSGuidTagDecl; }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' type.\n  QualType getMSGuidType() const {\n    assert(MSGuidTagDecl && \"asked for GUID type but MS extensions disabled\");\n    return getTagDeclType(MSGuidTagDecl);\n  }\n\n  /// Return whether a declaration to a builtin is allowed to be\n  /// overloaded/redeclared.\n  bool canBuiltinBeRedeclared(const FunctionDecl *) const;\n\n  /// Return a type with additional \\c const, \\c volatile, or\n  /// \\c restrict qualifiers.\n  QualType getCVRQualifiedType(QualType T, unsigned CVR) const {\n    return getQualifiedType(T, Qualifiers::fromCVRMask(CVR));\n  }\n\n  /// Un-split a SplitQualType.\n  QualType getQualifiedType(SplitQualType split) const {\n    return getQualifiedType(split.Ty, split.Quals);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(QualType T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return T.withFastQualifiers(Qs.getFastQualifiers());\n    QualifierCollector Qc(Qs);\n    const Type *Ptr = Qc.strip(T);\n    return getExtQualType(Ptr, Qc);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(const Type *T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return QualType(T, Qs.getFastQualifiers());\n    return getExtQualType(T, Qs);\n  }\n\n  /// Return a type with the given lifetime qualifier.\n  ///\n  /// \\pre Neither type.ObjCLifetime() nor \\p lifetime may be \\c OCL_None.\n  QualType getLifetimeQualifiedType(QualType type,\n                                    Qualifiers::ObjCLifetime lifetime) {\n    assert(type.getObjCLifetime() == Qualifiers::OCL_None);\n    assert(lifetime != Qualifiers::OCL_None);\n\n    Qualifiers qs;\n    qs.addObjCLifetime(lifetime);\n    return getQualifiedType(type, qs);\n  }\n\n  /// getUnqualifiedObjCPointerType - Returns version of\n  /// Objective-C pointer type with lifetime qualifier removed.\n  QualType getUnqualifiedObjCPointerType(QualType type) const {\n    if (!type.getTypePtr()->isObjCObjectPointerType() ||\n        !type.getQualifiers().hasObjCLifetime())\n      return type;\n    Qualifiers Qs = type.getQualifiers();\n    Qs.removeObjCLifetime();\n    return getQualifiedType(type.getUnqualifiedType(), Qs);\n  }\n\n  unsigned char getFixedPointScale(QualType Ty) const;\n  unsigned char getFixedPointIBits(QualType Ty) const;\n  llvm::FixedPointSemantics getFixedPointSemantics(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMax(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMin(QualType Ty) const;\n\n  DeclarationNameInfo getNameForTemplate(TemplateName Name,\n                                         SourceLocation NameLoc) const;\n\n  TemplateName getOverloadedTemplateName(UnresolvedSetIterator Begin,\n                                         UnresolvedSetIterator End) const;\n  TemplateName getAssumedTemplateName(DeclarationName Name) const;\n\n  TemplateName getQualifiedTemplateName(NestedNameSpecifier *NNS,\n                                        bool TemplateKeyword,\n                                        TemplateDecl *Template) const;\n\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        const IdentifierInfo *Name) const;\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        OverloadedOperatorKind Operator) const;\n  TemplateName getSubstTemplateTemplateParm(TemplateTemplateParmDecl *param,\n                                            TemplateName replacement) const;\n  TemplateName getSubstTemplateTemplateParmPack(TemplateTemplateParmDecl *Param,\n                                        const TemplateArgument &ArgPack) const;\n\n  enum GetBuiltinTypeError {\n    /// No error\n    GE_None,\n\n    /// Missing a type\n    GE_Missing_type,\n\n    /// Missing a type from <stdio.h>\n    GE_Missing_stdio,\n\n    /// Missing a type from <setjmp.h>\n    GE_Missing_setjmp,\n\n    /// Missing a type from <ucontext.h>\n    GE_Missing_ucontext\n  };\n\n  QualType DecodeTypeStr(const char *&Str, const ASTContext &Context,\n                         ASTContext::GetBuiltinTypeError &Error,\n                         bool &RequireICE, bool AllowTypeModifiers) const;\n\n  /// Return the type for the specified builtin.\n  ///\n  /// If \\p IntegerConstantArgs is non-null, it is filled in with a bitmask of\n  /// arguments to the builtin that are required to be integer constant\n  /// expressions.\n  QualType GetBuiltinType(unsigned ID, GetBuiltinTypeError &Error,\n                          unsigned *IntegerConstantArgs = nullptr) const;\n\n  /// Types and expressions required to build C++2a three-way comparisons\n  /// using operator<=>, including the values return by builtin <=> operators.\n  ComparisonCategories CompCategories;\n\nprivate:\n  CanQualType getFromTargetType(unsigned Type) const;\n  TypeInfo getTypeInfoImpl(const Type *T) const;\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Predicates.\n  //===--------------------------------------------------------------------===//\n\npublic:\n  /// Return one of the GCNone, Weak or Strong Objective-C garbage\n  /// collection attributes.\n  Qualifiers::GC getObjCGCAttrKind(QualType Ty) const;\n\n  /// Return true if the given vector types are of the same unqualified\n  /// type or if they are equivalent to the same GCC vector type.\n  ///\n  /// \\note This ignores whether they are target-specific (AltiVec or Neon)\n  /// types.\n  bool areCompatibleVectorTypes(QualType FirstVec, QualType SecondVec);\n\n  /// Return true if the given types are an SVE builtin and a VectorType that\n  /// is a fixed-length representation of the SVE builtin for a specific\n  /// vector-length.\n  bool areCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the given vector types are lax-compatible SVE vector types,\n  /// false otherwise.\n  bool areLaxCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the type has been explicitly qualified with ObjC ownership.\n  /// A type may be implicitly qualified with ownership under ObjC ARC, and in\n  /// some cases the compiler treats these differently.\n  bool hasDirectOwnershipQualifier(QualType Ty) const;\n\n  /// Return true if this is an \\c NSObject object with its \\c NSObject\n  /// attribute set.\n  static bool isObjCNSObjectType(QualType Ty) {\n    return Ty->isObjCNSObjectType();\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Sizing and Analysis\n  //===--------------------------------------------------------------------===//\n\n  /// Return the APFloat 'semantics' for the specified scalar floating\n  /// point type.\n  const llvm::fltSemantics &getFloatTypeSemantics(QualType T) const;\n\n  /// Get the size and alignment of the specified complete type in bits.\n  TypeInfo getTypeInfo(const Type *T) const;\n  TypeInfo getTypeInfo(QualType T) const { return getTypeInfo(T.getTypePtr()); }\n\n  /// Get default simd alignment of the specified complete type in bits.\n  unsigned getOpenMPDefaultSimdAlign(QualType T) const;\n\n  /// Return the size of the specified (complete) type \\p T, in bits.\n  uint64_t getTypeSize(QualType T) const { return getTypeInfo(T).Width; }\n  uint64_t getTypeSize(const Type *T) const { return getTypeInfo(T).Width; }\n\n  /// Return the size of the character type, in bits.\n  uint64_t getCharWidth() const {\n    return getTypeSize(CharTy);\n  }\n\n  /// Convert a size in bits to a size in characters.\n  CharUnits toCharUnitsFromBits(int64_t BitSize) const;\n\n  /// Convert a size in characters to a size in bits.\n  int64_t toBits(CharUnits CharSize) const;\n\n  /// Return the size of the specified (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeSizeInChars(QualType T) const;\n  CharUnits getTypeSizeInChars(const Type *T) const;\n\n  Optional<CharUnits> getTypeSizeInCharsIfKnown(QualType Ty) const {\n    if (Ty->isIncompleteType() || Ty->isDependentType())\n      return None;\n    return getTypeSizeInChars(Ty);\n  }\n\n  Optional<CharUnits> getTypeSizeInCharsIfKnown(const Type *Ty) const {\n    return getTypeSizeInCharsIfKnown(QualType(Ty, 0));\n  }\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// bits.\n  unsigned getTypeAlign(QualType T) const { return getTypeInfo(T).Align; }\n  unsigned getTypeAlign(const Type *T) const { return getTypeInfo(T).Align; }\n\n  /// Return the ABI-specified natural alignment of a (complete) type \\p T,\n  /// before alignment adjustments, in bits.\n  ///\n  /// This alignment is curently used only by ARM and AArch64 when passing\n  /// arguments of a composite type.\n  unsigned getTypeUnadjustedAlign(QualType T) const {\n    return getTypeUnadjustedAlign(T.getTypePtr());\n  }\n  unsigned getTypeUnadjustedAlign(const Type *T) const;\n\n  /// Return the alignment of a type, in bits, or 0 if\n  /// the type is incomplete and we cannot determine the alignment (for\n  /// example, from alignment attributes). The returned alignment is the\n  /// Preferred alignment if NeedsPreferredAlignment is true, otherwise is the\n  /// ABI alignment.\n  unsigned getTypeAlignIfKnown(QualType T,\n                               bool NeedsPreferredAlignment = false) const;\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeAlignInChars(QualType T) const;\n  CharUnits getTypeAlignInChars(const Type *T) const;\n\n  /// Return the PreferredAlignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getPreferredTypeAlignInChars(QualType T) const {\n    return toCharUnitsFromBits(getPreferredTypeAlign(T));\n  }\n\n  /// getTypeUnadjustedAlignInChars - Return the ABI-specified alignment of a type,\n  /// in characters, before alignment adjustments. This method does not work on\n  /// incomplete types.\n  CharUnits getTypeUnadjustedAlignInChars(QualType T) const;\n  CharUnits getTypeUnadjustedAlignInChars(const Type *T) const;\n\n  // getTypeInfoDataSizeInChars - Return the size of a type, in chars. If the\n  // type is a record, its data size is returned.\n  TypeInfoChars getTypeInfoDataSizeInChars(QualType T) const;\n\n  TypeInfoChars getTypeInfoInChars(const Type *T) const;\n  TypeInfoChars getTypeInfoInChars(QualType T) const;\n\n  /// Determine if the alignment the type has was required using an\n  /// alignment attribute.\n  bool isAlignmentRequired(const Type *T) const;\n  bool isAlignmentRequired(QualType T) const;\n\n  /// Return the \"preferred\" alignment of the specified type \\p T for\n  /// the current target, in bits.\n  ///\n  /// This can be different than the ABI alignment in cases where it is\n  /// beneficial for performance or backwards compatibility preserving to\n  /// overalign a data type. (Note: despite the name, the preferred alignment\n  /// is ABI-impacting, and not an optimization.)\n  unsigned getPreferredTypeAlign(QualType T) const {\n    return getPreferredTypeAlign(T.getTypePtr());\n  }\n  unsigned getPreferredTypeAlign(const Type *T) const;\n\n  /// Return the default alignment for __attribute__((aligned)) on\n  /// this target, to be used if no alignment value is specified.\n  unsigned getTargetDefaultAlignForAttributeAligned() const;\n\n  /// Return the alignment in bits that should be given to a\n  /// global variable with type \\p T.\n  unsigned getAlignOfGlobalVar(QualType T) const;\n\n  /// Return the alignment in characters that should be given to a\n  /// global variable with type \\p T.\n  CharUnits getAlignOfGlobalVarInChars(QualType T) const;\n\n  /// Return a conservative estimate of the alignment of the specified\n  /// decl \\p D.\n  ///\n  /// \\pre \\p D must not be a bitfield type, as bitfields do not have a valid\n  /// alignment.\n  ///\n  /// If \\p ForAlignof, references are treated like their underlying type\n  /// and  large arrays don't get any special treatment. If not \\p ForAlignof\n  /// it computes the value expected by CodeGen: references are treated like\n  /// pointers and large arrays get extra alignment.\n  CharUnits getDeclAlign(const Decl *D, bool ForAlignof = false) const;\n\n  /// Return the alignment (in bytes) of the thrown exception object. This is\n  /// only meaningful for targets that allocate C++ exceptions in a system\n  /// runtime, such as those using the Itanium C++ ABI.\n  CharUnits getExnObjectAlignment() const;\n\n  /// Get or compute information about the layout of the specified\n  /// record (struct/union/class) \\p D, which indicates its size and field\n  /// position information.\n  const ASTRecordLayout &getASTRecordLayout(const RecordDecl *D) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C interface.\n  const ASTRecordLayout &getASTObjCInterfaceLayout(const ObjCInterfaceDecl *D)\n    const;\n\n  void DumpRecordLayout(const RecordDecl *RD, raw_ostream &OS,\n                        bool Simple = false) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C implementation.\n  ///\n  /// This may differ from the interface if synthesized ivars are present.\n  const ASTRecordLayout &\n  getASTObjCImplementationLayout(const ObjCImplementationDecl *D) const;\n\n  /// Get our current best idea for the key function of the\n  /// given record decl, or nullptr if there isn't one.\n  ///\n  /// The key function is, according to the Itanium C++ ABI section 5.2.3:\n  ///   ...the first non-pure virtual function that is not inline at the\n  ///   point of class definition.\n  ///\n  /// Other ABIs use the same idea.  However, the ARM C++ ABI ignores\n  /// virtual functions that are defined 'inline', which means that\n  /// the result of this computation can change.\n  const CXXMethodDecl *getCurrentKeyFunction(const CXXRecordDecl *RD);\n\n  /// Observe that the given method cannot be a key function.\n  /// Checks the key-function cache for the method's class and clears it\n  /// if matches the given declaration.\n  ///\n  /// This is used in ABIs where out-of-line definitions marked\n  /// inline are not considered to be key functions.\n  ///\n  /// \\param method should be the declaration from the class definition\n  void setNonKeyFunction(const CXXMethodDecl *method);\n\n  /// Loading virtual member pointers using the virtual inheritance model\n  /// always results in an adjustment using the vbtable even if the index is\n  /// zero.\n  ///\n  /// This is usually OK because the first slot in the vbtable points\n  /// backwards to the top of the MDC.  However, the MDC might be reusing a\n  /// vbptr from an nv-base.  In this case, the first slot in the vbtable\n  /// points to the start of the nv-base which introduced the vbptr and *not*\n  /// the MDC.  Modify the NonVirtualBaseAdjustment to account for this.\n  CharUnits getOffsetOfBaseWithVBPtr(const CXXRecordDecl *RD) const;\n\n  /// Get the offset of a FieldDecl or IndirectFieldDecl, in bits.\n  uint64_t getFieldOffset(const ValueDecl *FD) const;\n\n  /// Get the offset of an ObjCIvarDecl in bits.\n  uint64_t lookupFieldBitOffset(const ObjCInterfaceDecl *OID,\n                                const ObjCImplementationDecl *ID,\n                                const ObjCIvarDecl *Ivar) const;\n\n  /// Find the 'this' offset for the member path in a pointer-to-member\n  /// APValue.\n  CharUnits getMemberPointerPathAdjustment(const APValue &MP) const;\n\n  bool isNearlyEmpty(const CXXRecordDecl *RD) const;\n\n  VTableContextBase *getVTableContext();\n\n  /// If \\p T is null pointer, assume the target in ASTContext.\n  MangleContext *createMangleContext(const TargetInfo *T = nullptr);\n\n  void DeepCollectObjCIvars(const ObjCInterfaceDecl *OI, bool leafClass,\n                            SmallVectorImpl<const ObjCIvarDecl*> &Ivars) const;\n\n  unsigned CountNonClassIvars(const ObjCInterfaceDecl *OI) const;\n  void CollectInheritedProtocols(const Decl *CDecl,\n                          llvm::SmallPtrSet<ObjCProtocolDecl*, 8> &Protocols);\n\n  /// Return true if the specified type has unique object representations\n  /// according to (C++17 [meta.unary.prop]p9)\n  bool hasUniqueObjectRepresentations(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                            Type Operators\n  //===--------------------------------------------------------------------===//\n\n  /// Return the canonical (structural) type corresponding to the\n  /// specified potentially non-canonical type \\p T.\n  ///\n  /// The non-canonical version of a type may have many \"decorated\" versions of\n  /// types.  Decorators can include typedefs, 'typeof' operators, etc. The\n  /// returned type is guaranteed to be free of any of these, allowing two\n  /// canonical types to be compared for exact equality with a simple pointer\n  /// comparison.\n  CanQualType getCanonicalType(QualType T) const {\n    return CanQualType::CreateUnsafe(T.getCanonicalType());\n  }\n\n  const Type *getCanonicalType(const Type *T) const {\n    return T->getCanonicalTypeInternal().getTypePtr();\n  }\n\n  /// Return the canonical parameter type corresponding to the specific\n  /// potentially non-canonical one.\n  ///\n  /// Qualifiers are stripped off, functions are turned into function\n  /// pointers, and arrays decay one level into pointers.\n  CanQualType getCanonicalParamType(QualType T) const;\n\n  /// Determine whether the given types \\p T1 and \\p T2 are equivalent.\n  bool hasSameType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n  bool hasSameType(const Type *T1, const Type *T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n\n  /// Return this type as a completely-unqualified array type,\n  /// capturing the qualifiers in \\p Quals.\n  ///\n  /// This will remove the minimal amount of sugaring from the types, similar\n  /// to the behavior of QualType::getUnqualifiedType().\n  ///\n  /// \\param T is the qualified type, which may be an ArrayType\n  ///\n  /// \\param Quals will receive the full set of qualifiers that were\n  /// applied to the array.\n  ///\n  /// \\returns if this is an array type, the completely unqualified array type\n  /// that corresponds to it. Otherwise, returns T.getUnqualifiedType().\n  QualType getUnqualifiedArrayType(QualType T, Qualifiers &Quals);\n\n  /// Determine whether the given types are equivalent after\n  /// cvr-qualifiers have been removed.\n  bool hasSameUnqualifiedType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1).getTypePtr() ==\n           getCanonicalType(T2).getTypePtr();\n  }\n\n  bool hasSameNullabilityTypeQualifier(QualType SubT, QualType SuperT,\n                                       bool IsParam) const {\n    auto SubTnullability = SubT->getNullability(*this);\n    auto SuperTnullability = SuperT->getNullability(*this);\n    if (SubTnullability.hasValue() == SuperTnullability.hasValue()) {\n      // Neither has nullability; return true\n      if (!SubTnullability)\n        return true;\n      // Both have nullability qualifier.\n      if (*SubTnullability == *SuperTnullability ||\n          *SubTnullability == NullabilityKind::Unspecified ||\n          *SuperTnullability == NullabilityKind::Unspecified)\n        return true;\n\n      if (IsParam) {\n        // Ok for the superclass method parameter to be \"nonnull\" and the subclass\n        // method parameter to be \"nullable\"\n        return (*SuperTnullability == NullabilityKind::NonNull &&\n                *SubTnullability == NullabilityKind::Nullable);\n      }\n      // For the return type, it's okay for the superclass method to specify\n      // \"nullable\" and the subclass method specify \"nonnull\"\n      return (*SuperTnullability == NullabilityKind::Nullable &&\n              *SubTnullability == NullabilityKind::NonNull);\n    }\n    return true;\n  }\n\n  bool ObjCMethodsAreEqual(const ObjCMethodDecl *MethodDecl,\n                           const ObjCMethodDecl *MethodImp);\n\n  bool UnwrapSimilarTypes(QualType &T1, QualType &T2);\n  bool UnwrapSimilarArrayTypes(QualType &T1, QualType &T2);\n\n  /// Determine if two types are similar, according to the C++ rules. That is,\n  /// determine if they are the same other than qualifiers on the initial\n  /// sequence of pointer / pointer-to-member / array (and in Clang, object\n  /// pointer) types and their element types.\n  ///\n  /// Clang offers a number of qualifiers in addition to the C++ qualifiers;\n  /// those qualifiers are also ignored in the 'similarity' check.\n  bool hasSimilarType(QualType T1, QualType T2);\n\n  /// Determine if two types are similar, ignoring only CVR qualifiers.\n  bool hasCvrSimilarType(QualType T1, QualType T2);\n\n  /// Retrieves the \"canonical\" nested name specifier for a\n  /// given nested name specifier.\n  ///\n  /// The canonical nested name specifier is a nested name specifier\n  /// that uniquely identifies a type or namespace within the type\n  /// system. For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   struct S {\n  ///     template<typename T> struct X { typename T* type; };\n  ///   };\n  /// }\n  ///\n  /// template<typename T> struct Y {\n  ///   typename N::S::X<T>::type member;\n  /// };\n  /// \\endcode\n  ///\n  /// Here, the nested-name-specifier for N::S::X<T>:: will be\n  /// S::X<template-param-0-0>, since 'S' and 'X' are uniquely defined\n  /// by declarations in the type system and the canonical type for\n  /// the template type parameter 'T' is template-param-0-0.\n  NestedNameSpecifier *\n  getCanonicalNestedNameSpecifier(NestedNameSpecifier *NNS) const;\n\n  /// Retrieves the default calling convention for the current target.\n  CallingConv getDefaultCallingConvention(bool IsVariadic,\n                                          bool IsCXXMethod,\n                                          bool IsBuiltin = false) const;\n\n  /// Retrieves the \"canonical\" template name that refers to a\n  /// given template.\n  ///\n  /// The canonical template name is the simplest expression that can\n  /// be used to refer to a given template. For most templates, this\n  /// expression is just the template declaration itself. For example,\n  /// the template std::vector can be referred to via a variety of\n  /// names---std::vector, \\::std::vector, vector (if vector is in\n  /// scope), etc.---but all of these names map down to the same\n  /// TemplateDecl, which is used to form the canonical template name.\n  ///\n  /// Dependent template names are more interesting. Here, the\n  /// template name could be something like T::template apply or\n  /// std::allocator<T>::template rebind, where the nested name\n  /// specifier itself is dependent. In this case, the canonical\n  /// template name uses the shortest form of the dependent\n  /// nested-name-specifier, which itself contains all canonical\n  /// types, values, and templates.\n  TemplateName getCanonicalTemplateName(TemplateName Name) const;\n\n  /// Determine whether the given template names refer to the same\n  /// template.\n  bool hasSameTemplateName(TemplateName X, TemplateName Y);\n\n  /// Retrieve the \"canonical\" template argument.\n  ///\n  /// The canonical template argument is the simplest template argument\n  /// (which may be a type, value, expression, or declaration) that\n  /// expresses the value of the argument.\n  TemplateArgument getCanonicalTemplateArgument(const TemplateArgument &Arg)\n    const;\n\n  /// Type Query functions.  If the type is an instance of the specified class,\n  /// return the Type pointer for the underlying maximally pretty type.  This\n  /// is a member of ASTContext because this may need to do some amount of\n  /// canonicalization, e.g. to move type qualifiers into the element type.\n  const ArrayType *getAsArrayType(QualType T) const;\n  const ConstantArrayType *getAsConstantArrayType(QualType T) const {\n    return dyn_cast_or_null<ConstantArrayType>(getAsArrayType(T));\n  }\n  const VariableArrayType *getAsVariableArrayType(QualType T) const {\n    return dyn_cast_or_null<VariableArrayType>(getAsArrayType(T));\n  }\n  const IncompleteArrayType *getAsIncompleteArrayType(QualType T) const {\n    return dyn_cast_or_null<IncompleteArrayType>(getAsArrayType(T));\n  }\n  const DependentSizedArrayType *getAsDependentSizedArrayType(QualType T)\n    const {\n    return dyn_cast_or_null<DependentSizedArrayType>(getAsArrayType(T));\n  }\n\n  /// Return the innermost element type of an array type.\n  ///\n  /// For example, will return \"int\" for int[m][n]\n  QualType getBaseElementType(const ArrayType *VAT) const;\n\n  /// Return the innermost element type of a type (which needn't\n  /// actually be an array type).\n  QualType getBaseElementType(QualType QT) const;\n\n  /// Return number of constant array elements.\n  uint64_t getConstantArrayElementCount(const ConstantArrayType *CA) const;\n\n  /// Perform adjustment on the parameter type of a function.\n  ///\n  /// This routine adjusts the given parameter type @p T to the actual\n  /// parameter type used by semantic analysis (C99 6.7.5.3p[7,8],\n  /// C++ [dcl.fct]p3). The adjusted parameter type is returned.\n  QualType getAdjustedParameterType(QualType T) const;\n\n  /// Retrieve the parameter type as adjusted for use in the signature\n  /// of a function, decaying array and function types and removing top-level\n  /// cv-qualifiers.\n  QualType getSignatureParameterType(QualType T) const;\n\n  QualType getExceptionObjectType(QualType T) const;\n\n  /// Return the properly qualified result of decaying the specified\n  /// array type to a pointer.\n  ///\n  /// This operation is non-trivial when handling typedefs etc.  The canonical\n  /// type of \\p T must be an array type, this returns a pointer to a properly\n  /// qualified element of the array.\n  ///\n  /// See C99 6.7.5.3p7 and C99 6.3.2.1p3.\n  QualType getArrayDecayedType(QualType T) const;\n\n  /// Return the type that \\p PromotableType will promote to: C99\n  /// 6.3.1.1p2, assuming that \\p PromotableType is a promotable integer type.\n  QualType getPromotedIntegerType(QualType PromotableType) const;\n\n  /// Recurses in pointer/array types until it finds an Objective-C\n  /// retainable type and returns its ownership.\n  Qualifiers::ObjCLifetime getInnerObjCOwnership(QualType T) const;\n\n  /// Whether this is a promotable bitfield reference according\n  /// to C99 6.3.1.1p2, bullet 2 (and GCC extensions).\n  ///\n  /// \\returns the type this bit-field will promote to, or NULL if no\n  /// promotion occurs.\n  QualType isPromotableBitField(Expr *E) const;\n\n  /// Return the highest ranked integer type, see C99 6.3.1.8p1.\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getIntegerTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of the two specified floating point types,\n  /// ignoring the domain of the type (i.e. 'double' == '_Complex double').\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getFloatingTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of two floating point types as above, but compare equal\n  /// if both types have the same floating-point semantics on the target (i.e.\n  /// long double and double on AArch64 will return 0).\n  int getFloatingTypeSemanticOrder(QualType LHS, QualType RHS) const;\n\n  /// Return a real floating point or a complex type (based on\n  /// \\p typeDomain/\\p typeSize).\n  ///\n  /// \\param typeDomain a real floating point or complex type.\n  /// \\param typeSize a real floating point or complex type.\n  QualType getFloatingTypeOfSizeWithinDomain(QualType typeSize,\n                                             QualType typeDomain) const;\n\n  unsigned getTargetAddressSpace(QualType T) const {\n    return getTargetAddressSpace(T.getQualifiers());\n  }\n\n  unsigned getTargetAddressSpace(Qualifiers Q) const {\n    return getTargetAddressSpace(Q.getAddressSpace());\n  }\n\n  unsigned getTargetAddressSpace(LangAS AS) const;\n\n  LangAS getLangASForBuiltinAddressSpace(unsigned AS) const;\n\n  /// Get target-dependent integer value for null pointer which is used for\n  /// constant folding.\n  uint64_t getTargetNullPointerValue(QualType QT) const;\n\n  bool addressSpaceMapManglingFor(LangAS AS) const {\n    return AddrSpaceMapMangling || isTargetAddressSpace(AS);\n  }\n\nprivate:\n  // Helper for integer ordering\n  unsigned getIntegerRank(const Type *T) const;\n\npublic:\n  //===--------------------------------------------------------------------===//\n  //                    Type Compatibility Predicates\n  //===--------------------------------------------------------------------===//\n\n  /// Compatibility predicates used to check assignment expressions.\n  bool typesAreCompatible(QualType T1, QualType T2,\n                          bool CompareUnqualified = false); // C99 6.2.7p1\n\n  bool propertyTypesAreCompatible(QualType, QualType);\n  bool typesAreBlockPointerCompatible(QualType, QualType);\n\n  bool isObjCIdType(QualType T) const {\n    return T == getObjCIdType();\n  }\n\n  bool isObjCClassType(QualType T) const {\n    return T == getObjCClassType();\n  }\n\n  bool isObjCSelType(QualType T) const {\n    return T == getObjCSelType();\n  }\n\n  bool ObjCQualifiedIdTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                         const ObjCObjectPointerType *RHS,\n                                         bool ForCompare);\n\n  bool ObjCQualifiedClassTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                            const ObjCObjectPointerType *RHS);\n\n  // Check the safety of assignment from LHS to RHS\n  bool canAssignObjCInterfaces(const ObjCObjectPointerType *LHSOPT,\n                               const ObjCObjectPointerType *RHSOPT);\n  bool canAssignObjCInterfaces(const ObjCObjectType *LHS,\n                               const ObjCObjectType *RHS);\n  bool canAssignObjCInterfacesInBlockPointer(\n                                          const ObjCObjectPointerType *LHSOPT,\n                                          const ObjCObjectPointerType *RHSOPT,\n                                          bool BlockReturnType);\n  bool areComparableObjCPointerTypes(QualType LHS, QualType RHS);\n  QualType areCommonBaseCompatible(const ObjCObjectPointerType *LHSOPT,\n                                   const ObjCObjectPointerType *RHSOPT);\n  bool canBindObjCObjectType(QualType To, QualType From);\n\n  // Functions for calculating composite types\n  QualType mergeTypes(QualType, QualType, bool OfBlockPointer=false,\n                      bool Unqualified = false, bool BlockReturnType = false);\n  QualType mergeFunctionTypes(QualType, QualType, bool OfBlockPointer=false,\n                              bool Unqualified = false, bool AllowCXX = false);\n  QualType mergeFunctionParameterTypes(QualType, QualType,\n                                       bool OfBlockPointer = false,\n                                       bool Unqualified = false);\n  QualType mergeTransparentUnionType(QualType, QualType,\n                                     bool OfBlockPointer=false,\n                                     bool Unqualified = false);\n\n  QualType mergeObjCGCQualifiers(QualType, QualType);\n\n  /// This function merges the ExtParameterInfo lists of two functions. It\n  /// returns true if the lists are compatible. The merged list is returned in\n  /// NewParamInfos.\n  ///\n  /// \\param FirstFnType The type of the first function.\n  ///\n  /// \\param SecondFnType The type of the second function.\n  ///\n  /// \\param CanUseFirst This flag is set to true if the first function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param CanUseSecond This flag is set to true if the second function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param NewParamInfos The composite list of ExtParameterInfo. The list is\n  /// empty if none of the flags are set.\n  ///\n  bool mergeExtParameterInfo(\n      const FunctionProtoType *FirstFnType,\n      const FunctionProtoType *SecondFnType,\n      bool &CanUseFirst, bool &CanUseSecond,\n      SmallVectorImpl<FunctionProtoType::ExtParameterInfo> &NewParamInfos);\n\n  void ResetObjCLayout(const ObjCContainerDecl *CD);\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Predicates\n  //===--------------------------------------------------------------------===//\n\n  // The width of an integer, as defined in C99 6.2.6.2. This is the number\n  // of bits in an integer type excluding any padding bits.\n  unsigned getIntWidth(QualType T) const;\n\n  // Per C99 6.2.5p6, for every signed integer type, there is a corresponding\n  // unsigned integer type.  This method takes a signed type, and returns the\n  // corresponding unsigned integer type.\n  // With the introduction of fixed point types in ISO N1169, this method also\n  // accepts fixed point types and returns the corresponding unsigned type for\n  // a given fixed point type.\n  QualType getCorrespondingUnsignedType(QualType T) const;\n\n  // Per ISO N1169, this method accepts fixed point types and returns the\n  // corresponding saturated type for a given fixed point type.\n  QualType getCorrespondingSaturatedType(QualType Ty) const;\n\n  // This method accepts fixed point types and returns the corresponding signed\n  // type. Unlike getCorrespondingUnsignedType(), this only accepts unsigned\n  // fixed point types because there are unsigned integer types like bool and\n  // char8_t that don't have signed equivalents.\n  QualType getCorrespondingSignedFixedPointType(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Values\n  //===--------------------------------------------------------------------===//\n\n  /// Make an APSInt of the appropriate width and signedness for the\n  /// given \\p Value and integer \\p Type.\n  llvm::APSInt MakeIntValue(uint64_t Value, QualType Type) const {\n    // If Type is a signed integer type larger than 64 bits, we need to be sure\n    // to sign extend Res appropriately.\n    llvm::APSInt Res(64, !Type->isSignedIntegerOrEnumerationType());\n    Res = Value;\n    unsigned Width = getIntWidth(Type);\n    if (Width != Res.getBitWidth())\n      return Res.extOrTrunc(Width);\n    return Res;\n  }\n\n  bool isSentinelNullExpr(const Expr *E);\n\n  /// Get the implementation of the ObjCInterfaceDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCImplementationDecl *getObjCImplementation(ObjCInterfaceDecl *D);\n\n  /// Get the implementation of the ObjCCategoryDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCCategoryImplDecl *getObjCImplementation(ObjCCategoryDecl *D);\n\n  /// Return true if there is at least one \\@implementation in the TU.\n  bool AnyObjCImplementation() {\n    return !ObjCImpls.empty();\n  }\n\n  /// Set the implementation of ObjCInterfaceDecl.\n  void setObjCImplementation(ObjCInterfaceDecl *IFaceD,\n                             ObjCImplementationDecl *ImplD);\n\n  /// Set the implementation of ObjCCategoryDecl.\n  void setObjCImplementation(ObjCCategoryDecl *CatD,\n                             ObjCCategoryImplDecl *ImplD);\n\n  /// Get the duplicate declaration of a ObjCMethod in the same\n  /// interface, or null if none exists.\n  const ObjCMethodDecl *\n  getObjCMethodRedeclaration(const ObjCMethodDecl *MD) const;\n\n  void setObjCMethodRedeclaration(const ObjCMethodDecl *MD,\n                                  const ObjCMethodDecl *Redecl);\n\n  /// Returns the Objective-C interface that \\p ND belongs to if it is\n  /// an Objective-C method/property/ivar etc. that is part of an interface,\n  /// otherwise returns null.\n  const ObjCInterfaceDecl *getObjContainingInterface(const NamedDecl *ND) const;\n\n  /// Set the copy initialization expression of a block var decl. \\p CanThrow\n  /// indicates whether the copy expression can throw or not.\n  void setBlockVarCopyInit(const VarDecl* VD, Expr *CopyExpr, bool CanThrow);\n\n  /// Get the copy initialization expression of the VarDecl \\p VD, or\n  /// nullptr if none exists.\n  BlockVarCopyInit getBlockVarCopyInit(const VarDecl* VD) const;\n\n  /// Allocate an uninitialized TypeSourceInfo.\n  ///\n  /// The caller should initialize the memory held by TypeSourceInfo using\n  /// the TypeLoc wrappers.\n  ///\n  /// \\param T the type that will be the basis for type source info. This type\n  /// should refer to how the declarator was written in source code, not to\n  /// what type semantic analysis resolved the declarator to.\n  ///\n  /// \\param Size the size of the type info to create, or 0 if the size\n  /// should be calculated based on the type.\n  TypeSourceInfo *CreateTypeSourceInfo(QualType T, unsigned Size = 0) const;\n\n  /// Allocate a TypeSourceInfo where all locations have been\n  /// initialized to a given location, which defaults to the empty\n  /// location.\n  TypeSourceInfo *\n  getTrivialTypeSourceInfo(QualType T,\n                           SourceLocation Loc = SourceLocation()) const;\n\n  /// Add a deallocation callback that will be invoked when the\n  /// ASTContext is destroyed.\n  ///\n  /// \\param Callback A callback function that will be invoked on destruction.\n  ///\n  /// \\param Data Pointer data that will be provided to the callback function\n  /// when it is called.\n  void AddDeallocation(void (*Callback)(void *), void *Data) const;\n\n  /// If T isn't trivially destructible, calls AddDeallocation to register it\n  /// for destruction.\n  template <typename T> void addDestruction(T *Ptr) const {\n    if (!std::is_trivially_destructible<T>::value) {\n      auto DestroyPtr = [](void *V) { static_cast<T *>(V)->~T(); };\n      AddDeallocation(DestroyPtr, Ptr);\n    }\n  }\n\n  GVALinkage GetGVALinkageForFunction(const FunctionDecl *FD) const;\n  GVALinkage GetGVALinkageForVariable(const VarDecl *VD);\n\n  /// Determines if the decl can be CodeGen'ed or deserialized from PCH\n  /// lazily, only when used; this is only relevant for function or file scoped\n  /// var definitions.\n  ///\n  /// \\returns true if the function/var must be CodeGen'ed/deserialized even if\n  /// it is not used.\n  bool DeclMustBeEmitted(const Decl *D);\n\n  /// Visits all versions of a multiversioned function with the passed\n  /// predicate.\n  void forEachMultiversionedFunctionVersion(\n      const FunctionDecl *FD,\n      llvm::function_ref<void(FunctionDecl *)> Pred) const;\n\n  const CXXConstructorDecl *\n  getCopyConstructorForExceptionObject(CXXRecordDecl *RD);\n\n  void addCopyConstructorForExceptionObject(CXXRecordDecl *RD,\n                                            CXXConstructorDecl *CD);\n\n  void addTypedefNameForUnnamedTagDecl(TagDecl *TD, TypedefNameDecl *TND);\n\n  TypedefNameDecl *getTypedefNameForUnnamedTagDecl(const TagDecl *TD);\n\n  void addDeclaratorForUnnamedTagDecl(TagDecl *TD, DeclaratorDecl *DD);\n\n  DeclaratorDecl *getDeclaratorForUnnamedTagDecl(const TagDecl *TD);\n\n  void setManglingNumber(const NamedDecl *ND, unsigned Number);\n  unsigned getManglingNumber(const NamedDecl *ND) const;\n\n  void setStaticLocalNumber(const VarDecl *VD, unsigned Number);\n  unsigned getStaticLocalNumber(const VarDecl *VD) const;\n\n  /// Retrieve the context for computing mangling numbers in the given\n  /// DeclContext.\n  MangleNumberingContext &getManglingNumberContext(const DeclContext *DC);\n  enum NeedExtraManglingDecl_t { NeedExtraManglingDecl };\n  MangleNumberingContext &getManglingNumberContext(NeedExtraManglingDecl_t,\n                                                   const Decl *D);\n\n  std::unique_ptr<MangleNumberingContext> createMangleNumberingContext() const;\n\n  /// Used by ParmVarDecl to store on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  void setParameterIndex(const ParmVarDecl *D, unsigned index);\n\n  /// Used by ParmVarDecl to retrieve on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  unsigned getParameterIndex(const ParmVarDecl *D) const;\n\n  /// Return a string representing the human readable name for the specified\n  /// function declaration or file name. Used by SourceLocExpr and\n  /// PredefinedExpr to cache evaluated results.\n  StringLiteral *getPredefinedStringLiteralFromCache(StringRef Key) const;\n\n  /// Return a declaration for the global GUID object representing the given\n  /// GUID value.\n  MSGuidDecl *getMSGuidDecl(MSGuidDeclParts Parts) const;\n\n  /// Return the template parameter object of the given type with the given\n  /// value.\n  TemplateParamObjectDecl *getTemplateParamObjectDecl(QualType T,\n                                                      const APValue &V) const;\n\n  /// Parses the target attributes passed in, and returns only the ones that are\n  /// valid feature names.\n  ParsedTargetAttr filterFunctionTargetAttrs(const TargetAttr *TD) const;\n\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             const FunctionDecl *) const;\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             GlobalDecl GD) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Statistics\n  //===--------------------------------------------------------------------===//\n\n  /// The number of implicitly-declared default constructors.\n  unsigned NumImplicitDefaultConstructors = 0;\n\n  /// The number of implicitly-declared default constructors for\n  /// which declarations were built.\n  unsigned NumImplicitDefaultConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy constructors.\n  unsigned NumImplicitCopyConstructors = 0;\n\n  /// The number of implicitly-declared copy constructors for\n  /// which declarations were built.\n  unsigned NumImplicitCopyConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared move constructors.\n  unsigned NumImplicitMoveConstructors = 0;\n\n  /// The number of implicitly-declared move constructors for\n  /// which declarations were built.\n  unsigned NumImplicitMoveConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy assignment operators.\n  unsigned NumImplicitCopyAssignmentOperators = 0;\n\n  /// The number of implicitly-declared copy assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitCopyAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared move assignment operators.\n  unsigned NumImplicitMoveAssignmentOperators = 0;\n\n  /// The number of implicitly-declared move assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitMoveAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared destructors.\n  unsigned NumImplicitDestructors = 0;\n\n  /// The number of implicitly-declared destructors for which\n  /// declarations were built.\n  unsigned NumImplicitDestructorsDeclared = 0;\n\npublic:\n  /// Initialize built-in types.\n  ///\n  /// This routine may only be invoked once for a given ASTContext object.\n  /// It is normally invoked after ASTContext construction.\n  ///\n  /// \\param Target The target\n  void InitBuiltinTypes(const TargetInfo &Target,\n                        const TargetInfo *AuxTarget = nullptr);\n\nprivate:\n  void InitBuiltinType(CanQualType &R, BuiltinType::Kind K);\n\n  class ObjCEncOptions {\n    unsigned Bits;\n\n    ObjCEncOptions(unsigned Bits) : Bits(Bits) {}\n\n  public:\n    ObjCEncOptions() : Bits(0) {}\n    ObjCEncOptions(const ObjCEncOptions &RHS) : Bits(RHS.Bits) {}\n\n#define OPT_LIST(V)                                                            \\\n  V(ExpandPointedToStructures, 0)                                              \\\n  V(ExpandStructures, 1)                                                       \\\n  V(IsOutermostType, 2)                                                        \\\n  V(EncodingProperty, 3)                                                       \\\n  V(IsStructField, 4)                                                          \\\n  V(EncodeBlockParameters, 5)                                                  \\\n  V(EncodeClassNames, 6)                                                       \\\n\n#define V(N,I) ObjCEncOptions& set##N() { Bits |= 1 << I; return *this; }\nOPT_LIST(V)\n#undef V\n\n#define V(N,I) bool N() const { return Bits & 1 << I; }\nOPT_LIST(V)\n#undef V\n\n#undef OPT_LIST\n\n    LLVM_NODISCARD ObjCEncOptions keepingOnly(ObjCEncOptions Mask) const {\n      return Bits & Mask.Bits;\n    }\n\n    LLVM_NODISCARD ObjCEncOptions forComponentType() const {\n      ObjCEncOptions Mask = ObjCEncOptions()\n                                .setIsOutermostType()\n                                .setIsStructField();\n      return Bits & ~Mask.Bits;\n    }\n  };\n\n  // Return the Objective-C type encoding for a given type.\n  void getObjCEncodingForTypeImpl(QualType t, std::string &S,\n                                  ObjCEncOptions Options,\n                                  const FieldDecl *Field,\n                                  QualType *NotEncodedT = nullptr) const;\n\n  // Adds the encoding of the structure's members.\n  void getObjCEncodingForStructureImpl(RecordDecl *RD, std::string &S,\n                                       const FieldDecl *Field,\n                                       bool includeVBases = true,\n                                       QualType *NotEncodedT=nullptr) const;\n\npublic:\n  // Adds the encoding of a method parameter or return type.\n  void getObjCEncodingForMethodParameter(Decl::ObjCDeclQualifier QT,\n                                         QualType T, std::string& S,\n                                         bool Extended) const;\n\n  /// Returns true if this is an inline-initialized static data member\n  /// which is treated as a definition for MSVC compatibility.\n  bool isMSStaticDataMemberInlineDefinition(const VarDecl *VD) const;\n\n  enum class InlineVariableDefinitionKind {\n    /// Not an inline variable.\n    None,\n\n    /// Weak definition of inline variable.\n    Weak,\n\n    /// Weak for now, might become strong later in this TU.\n    WeakUnknown,\n\n    /// Strong definition.\n    Strong\n  };\n\n  /// Determine whether a definition of this inline variable should\n  /// be treated as a weak or strong definition. For compatibility with\n  /// C++14 and before, for a constexpr static data member, if there is an\n  /// out-of-line declaration of the member, we may promote it from weak to\n  /// strong.\n  InlineVariableDefinitionKind\n  getInlineVariableDefinitionKind(const VarDecl *VD) const;\n\nprivate:\n  friend class DeclarationNameTable;\n  friend class DeclContext;\n\n  const ASTRecordLayout &\n  getObjCLayout(const ObjCInterfaceDecl *D,\n                const ObjCImplementationDecl *Impl) const;\n\n  /// A set of deallocations that should be performed when the\n  /// ASTContext is destroyed.\n  // FIXME: We really should have a better mechanism in the ASTContext to\n  // manage running destructors for types which do variable sized allocation\n  // within the AST. In some places we thread the AST bump pointer allocator\n  // into the datastructures which avoids this mess during deallocation but is\n  // wasteful of memory, and here we require a lot of error prone book keeping\n  // in order to track and run destructors while we're tearing things down.\n  using DeallocationFunctionsAndArguments =\n      llvm::SmallVector<std::pair<void (*)(void *), void *>, 16>;\n  mutable DeallocationFunctionsAndArguments Deallocations;\n\n  // FIXME: This currently contains the set of StoredDeclMaps used\n  // by DeclContext objects.  This probably should not be in ASTContext,\n  // but we include it here so that ASTContext can quickly deallocate them.\n  llvm::PointerIntPair<StoredDeclsMap *, 1> LastSDM;\n\n  std::vector<Decl *> TraversalScope;\n\n  std::unique_ptr<VTableContextBase> VTContext;\n\n  void ReleaseDeclContextMaps();\n\npublic:\n  enum PragmaSectionFlag : unsigned {\n    PSF_None = 0,\n    PSF_Read = 0x1,\n    PSF_Write = 0x2,\n    PSF_Execute = 0x4,\n    PSF_Implicit = 0x8,\n    PSF_ZeroInit = 0x10,\n    PSF_Invalid = 0x80000000U,\n  };\n\n  struct SectionInfo {\n    NamedDecl *Decl;\n    SourceLocation PragmaSectionLocation;\n    int SectionFlags;\n\n    SectionInfo() = default;\n    SectionInfo(NamedDecl *Decl, SourceLocation PragmaSectionLocation,\n                int SectionFlags)\n        : Decl(Decl), PragmaSectionLocation(PragmaSectionLocation),\n          SectionFlags(SectionFlags) {}\n  };\n\n  llvm::StringMap<SectionInfo> SectionInfos;\n\n  /// Return a new OMPTraitInfo object owned by this context.\n  OMPTraitInfo &getNewOMPTraitInfo();\n\n  /// Whether a C++ static variable may be externalized.\n  bool mayExternalizeStaticVar(const Decl *D) const;\n\n  /// Whether a C++ static variable should be externalized.\n  bool shouldExternalizeStaticVar(const Decl *D) const;\n\n  StringRef getCUIDHash() const;\n\nprivate:\n  /// All OMPTraitInfo objects live in this collection, one per\n  /// `pragma omp [begin] declare variant` directive.\n  SmallVector<std::unique_ptr<OMPTraitInfo>, 4> OMPTraitInfoVector;\n};\n\n/// Insertion operator for diagnostics.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      const ASTContext::SectionInfo &Section);\n\n/// Utility function for constructing a nullary selector.\ninline Selector GetNullarySelector(StringRef name, ASTContext &Ctx) {\n  IdentifierInfo* II = &Ctx.Idents.get(name);\n  return Ctx.Selectors.getSelector(0, &II);\n}\n\n/// Utility function for constructing an unary selector.\ninline Selector GetUnarySelector(StringRef name, ASTContext &Ctx) {\n  IdentifierInfo* II = &Ctx.Idents.get(name);\n  return Ctx.Selectors.getSelector(1, &II);\n}\n\n} // namespace clang\n\n// operator new and delete aren't allowed inside namespaces.\n\n/// Placement new for using the ASTContext's allocator.\n///\n/// This placement form of operator new uses the ASTContext's allocator for\n/// obtaining memory.\n///\n/// IMPORTANT: These are also declared in clang/AST/ASTContextAllocate.h!\n/// Any changes here need to also be made there.\n///\n/// We intentionally avoid using a nothrow specification here so that the calls\n/// to this operator will not perform a null check on the result -- the\n/// underlying allocator never returns null pointers.\n///\n/// Usage looks like this (assuming there's an ASTContext 'Context' in scope):\n/// @code\n/// // Default alignment (8)\n/// IntegerLiteral *Ex = new (Context) IntegerLiteral(arguments);\n/// // Specific alignment\n/// IntegerLiteral *Ex2 = new (Context, 4) IntegerLiteral(arguments);\n/// @endcode\n/// Memory allocated through this placement new operator does not need to be\n/// explicitly freed, as ASTContext will free all of this memory when it gets\n/// destroyed. Please note that you cannot use delete on the pointer.\n///\n/// @param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// @param C The ASTContext that provides the allocator.\n/// @param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// @return The allocated memory. Could be nullptr.\ninline void *operator new(size_t Bytes, const clang::ASTContext &C,\n                          size_t Alignment /* = 8 */) {\n  return C.Allocate(Bytes, Alignment);\n}\n\n/// Placement delete companion to the new above.\n///\n/// This operator is just a companion to the new above. There is no way of\n/// invoking it directly; see the new operator for more details. This operator\n/// is called implicitly by the compiler if a placement new expression using\n/// the ASTContext throws in the object constructor.\ninline void operator delete(void *Ptr, const clang::ASTContext &C, size_t) {\n  C.Deallocate(Ptr);\n}\n\n/// This placement form of operator new[] uses the ASTContext's allocator for\n/// obtaining memory.\n///\n/// We intentionally avoid using a nothrow specification here so that the calls\n/// to this operator will not perform a null check on the result -- the\n/// underlying allocator never returns null pointers.\n///\n/// Usage looks like this (assuming there's an ASTContext 'Context' in scope):\n/// @code\n/// // Default alignment (8)\n/// char *data = new (Context) char[10];\n/// // Specific alignment\n/// char *data = new (Context, 4) char[10];\n/// @endcode\n/// Memory allocated through this placement new[] operator does not need to be\n/// explicitly freed, as ASTContext will free all of this memory when it gets\n/// destroyed. Please note that you cannot use delete on the pointer.\n///\n/// @param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// @param C The ASTContext that provides the allocator.\n/// @param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// @return The allocated memory. Could be nullptr.\ninline void *operator new[](size_t Bytes, const clang::ASTContext& C,\n                            size_t Alignment /* = 8 */) {\n  return C.Allocate(Bytes, Alignment);\n}\n\n/// Placement delete[] companion to the new[] above.\n///\n/// This operator is just a companion to the new[] above. There is no way of\n/// invoking it directly; see the new[] operator for more details. This operator\n/// is called implicitly by the compiler if a placement new[] expression using\n/// the ASTContext throws in the object constructor.\ninline void operator delete[](void *Ptr, const clang::ASTContext &C, size_t) {\n  C.Deallocate(Ptr);\n}\n\n/// Create the representation of a LazyGenerationalUpdatePtr.\ntemplate <typename Owner, typename T,\n          void (clang::ExternalASTSource::*Update)(Owner)>\ntypename clang::LazyGenerationalUpdatePtr<Owner, T, Update>::ValueType\n    clang::LazyGenerationalUpdatePtr<Owner, T, Update>::makeValue(\n        const clang::ASTContext &Ctx, T Value) {\n  // Note, this is implemented here so that ExternalASTSource.h doesn't need to\n  // include ASTContext.h. We explicitly instantiate it for all relevant types\n  // in ASTContext.cpp.\n  if (auto *Source = Ctx.getExternalSource())\n    return new (Ctx) LazyData(Source, Value);\n  return Value;\n}\n\n#endif // LLVM_CLANG_AST_ASTCONTEXT_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTVector.h", "content": "//===- ASTVector.h - Vector that uses ASTContext for allocation ---*- C++ -*-=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides ASTVector, a vector  ADT whose contents are\n//  allocated using the allocator associated with an ASTContext..\n//\n//===----------------------------------------------------------------------===//\n\n// FIXME: Most of this is copy-and-paste from BumpVector.h and SmallVector.h.\n// We can refactor this core logic into something common.\n\n#ifndef LLVM_CLANG_AST_ASTVECTOR_H\n#define LLVM_CLANG_AST_ASTVECTOR_H\n\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <iterator>\n#include <memory>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\n\ntemplate<typename T>\nclass ASTVector {\nprivate:\n  T *Begin = nullptr;\n  T *End = nullptr;\n  llvm::PointerIntPair<T *, 1, bool> Capacity;\n\n  void setEnd(T *P) { this->End = P; }\n\nprotected:\n  // Make a tag bit available to users of this class.\n  // FIXME: This is a horrible hack.\n  bool getTag() const { return Capacity.getInt(); }\n  void setTag(bool B) { Capacity.setInt(B); }\n\npublic:\n  // Default ctor - Initialize to empty.\n  ASTVector() : Capacity(nullptr, false) {}\n\n  ASTVector(ASTVector &&O) : Begin(O.Begin), End(O.End), Capacity(O.Capacity) {\n    O.Begin = O.End = nullptr;\n    O.Capacity.setPointer(nullptr);\n    O.Capacity.setInt(false);\n  }\n\n  ASTVector(const ASTContext &C, unsigned N) : Capacity(nullptr, false) {\n    reserve(C, N);\n  }\n\n  ASTVector &operator=(ASTVector &&RHS) {\n    ASTVector O(std::move(RHS));\n\n    using std::swap;\n\n    swap(Begin, O.Begin);\n    swap(End, O.End);\n    swap(Capacity, O.Capacity);\n    return *this;\n  }\n\n  ~ASTVector() {\n    if (std::is_class<T>::value) {\n      // Destroy the constructed elements in the vector.\n      destroy_range(Begin, End);\n    }\n  }\n\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  // forward iterator creation methods.\n  iterator begin() { return Begin; }\n  const_iterator begin() const { return Begin; }\n  iterator end() { return End; }\n  const_iterator end() const { return End; }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin()            { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend()              { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}\n\n  bool empty() const { return Begin == End; }\n  size_type size() const { return End-Begin; }\n\n  reference operator[](unsigned idx) {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n  const_reference operator[](unsigned idx) const {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n\n  reference front() {\n    return begin()[0];\n  }\n  const_reference front() const {\n    return begin()[0];\n  }\n\n  reference back() {\n    return end()[-1];\n  }\n  const_reference back() const {\n    return end()[-1];\n  }\n\n  void pop_back() {\n    --End;\n    End->~T();\n  }\n\n  T pop_back_val() {\n    T Result = back();\n    pop_back();\n    return Result;\n  }\n\n  void clear() {\n    if (std::is_class<T>::value) {\n      destroy_range(Begin, End);\n    }\n    End = Begin;\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  pointer data() {\n    return pointer(Begin);\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const {\n    return const_pointer(Begin);\n  }\n\n  void push_back(const_reference Elt, const ASTContext &C) {\n    if (End < this->capacity_ptr()) {\n    Retry:\n      new (End) T(Elt);\n      ++End;\n      return;\n    }\n    grow(C);\n    goto Retry;\n  }\n\n  void reserve(const ASTContext &C, unsigned N) {\n    if (unsigned(this->capacity_ptr()-Begin) < N)\n      grow(C, N);\n  }\n\n  /// capacity - Return the total number of elements in the currently allocated\n  /// buffer.\n  size_t capacity() const { return this->capacity_ptr() - Begin; }\n\n  /// append - Add the specified range to the end of the SmallVector.\n  template<typename in_iter>\n  void append(const ASTContext &C, in_iter in_start, in_iter in_end) {\n    size_type NumInputs = std::distance(in_start, in_end);\n\n    if (NumInputs == 0)\n      return;\n\n    // Grow allocated space if needed.\n    if (NumInputs > size_type(this->capacity_ptr()-this->end()))\n      this->grow(C, this->size()+NumInputs);\n\n    // Copy the new elements over.\n    // TODO: NEED To compile time dispatch on whether in_iter is a random access\n    // iterator to use the fast uninitialized_copy.\n    std::uninitialized_copy(in_start, in_end, this->end());\n    this->setEnd(this->end() + NumInputs);\n  }\n\n  /// append - Add the specified range to the end of the SmallVector.\n  void append(const ASTContext &C, size_type NumInputs, const T &Elt) {\n    // Grow allocated space if needed.\n    if (NumInputs > size_type(this->capacity_ptr()-this->end()))\n      this->grow(C, this->size()+NumInputs);\n\n    // Copy the new elements over.\n    std::uninitialized_fill_n(this->end(), NumInputs, Elt);\n    this->setEnd(this->end() + NumInputs);\n  }\n\n  /// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {\n    std::uninitialized_copy(I, E, Dest);\n  }\n\n  iterator insert(const ASTContext &C, iterator I, const T &Elt) {\n    if (I == this->end()) {  // Important special case for empty vector.\n      push_back(Elt, C);\n      return this->end()-1;\n    }\n\n    if (this->End < this->capacity_ptr()) {\n    Retry:\n      new (this->end()) T(this->back());\n      this->setEnd(this->end()+1);\n      // Push everything else over.\n      std::copy_backward(I, this->end()-1, this->end());\n      *I = Elt;\n      return I;\n    }\n    size_t EltNo = I-this->begin();\n    this->grow(C);\n    I = this->begin()+EltNo;\n    goto Retry;\n  }\n\n  iterator insert(const ASTContext &C, iterator I, size_type NumToInsert,\n                  const T &Elt) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) { // Important special case for empty vector.\n      append(C, NumToInsert, Elt);\n      return this->begin() + InsertElt;\n    }\n\n    // Ensure there is enough space.\n    reserve(C, static_cast<unsigned>(this->size() + NumToInsert));\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(C, this->end()-NumToInsert, this->end());\n\n      // Copy the existing elements that get replaced.\n      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::fill_n(I, NumToInsert, Elt);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Copy over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->setEnd(this->end() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    std::fill_n(I, NumOverwritten, Elt);\n\n    // Insert the non-overwritten middle part.\n    std::uninitialized_fill_n(OldEnd, NumToInsert-NumOverwritten, Elt);\n    return I;\n  }\n\n  template<typename ItTy>\n  iterator insert(const ASTContext &C, iterator I, ItTy From, ItTy To) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) { // Important special case for empty vector.\n      append(C, From, To);\n      return this->begin() + InsertElt;\n    }\n\n    size_t NumToInsert = std::distance(From, To);\n\n    // Ensure there is enough space.\n    reserve(C, static_cast<unsigned>(this->size() + NumToInsert));\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(C, this->end()-NumToInsert, this->end());\n\n      // Copy the existing elements that get replaced.\n      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::copy(From, To, I);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Copy over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->setEnd(this->end() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    for (; NumOverwritten > 0; --NumOverwritten) {\n      *I = *From;\n      ++I; ++From;\n    }\n\n    // Insert the non-overwritten middle part.\n    this->uninitialized_copy(From, To, OldEnd);\n    return I;\n  }\n\n  void resize(const ASTContext &C, unsigned N, const T &NV) {\n    if (N < this->size()) {\n      this->destroy_range(this->begin()+N, this->end());\n      this->setEnd(this->begin()+N);\n    } else if (N > this->size()) {\n      if (this->capacity() < N)\n        this->grow(C, N);\n      construct_range(this->end(), this->begin()+N, NV);\n      this->setEnd(this->begin()+N);\n    }\n  }\n\nprivate:\n  /// grow - double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(const ASTContext &C, size_type MinSize = 1);\n\n  void construct_range(T *S, T *E, const T &Elt) {\n    for (; S != E; ++S)\n      new (S) T(Elt);\n  }\n\n  void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\nprotected:\n  const_iterator capacity_ptr() const {\n    return (iterator) Capacity.getPointer();\n  }\n\n  iterator capacity_ptr() { return (iterator)Capacity.getPointer(); }\n};\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T>\nvoid ASTVector<T>::grow(const ASTContext &C, size_t MinSize) {\n  size_t CurCapacity = this->capacity();\n  size_t CurSize = size();\n  size_t NewCapacity = 2*CurCapacity;\n  if (NewCapacity < MinSize)\n    NewCapacity = MinSize;\n\n  // Allocate the memory from the ASTContext.\n  T *NewElts = new (C, alignof(T)) T[NewCapacity];\n\n  // Copy the elements over.\n  if (Begin != End) {\n    if (std::is_class<T>::value) {\n      std::uninitialized_copy(Begin, End, NewElts);\n      // Destroy the original elements.\n      destroy_range(Begin, End);\n    } else {\n      // Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).\n      memcpy(NewElts, Begin, CurSize * sizeof(T));\n    }\n  }\n\n  // ASTContext never frees any memory.\n  Begin = NewElts;\n  End = NewElts+CurSize;\n  Capacity.setPointer(Begin+NewCapacity);\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_ASTVECTOR_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/AttrIterator.h", "content": "//===- AttrIterator.h - Classes for attribute iteration ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Attr vector and specific_attr_iterator interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ATTRITERATOR_H\n#define LLVM_CLANG_AST_ATTRITERATOR_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace clang {\n\nclass ASTContext;\nclass Attr;\n\n/// AttrVec - A vector of Attr, which is how they are stored on the AST.\nusing AttrVec = SmallVector<Attr *, 4>;\n\n/// specific_attr_iterator - Iterates over a subrange of an AttrVec, only\n/// providing attributes that are of a specific type.\ntemplate <typename SpecificAttr, typename Container = AttrVec>\nclass specific_attr_iterator {\n  using Iterator = typename Container::const_iterator;\n\n  /// Current - The current, underlying iterator.\n  /// In order to ensure we don't dereference an invalid iterator unless\n  /// specifically requested, we don't necessarily advance this all the\n  /// way. Instead, we advance it when an operation is requested; if the\n  /// operation is acting on what should be a past-the-end iterator,\n  /// then we offer no guarantees, but this way we do not dereference a\n  /// past-the-end iterator when we move to a past-the-end position.\n  mutable Iterator Current;\n\n  void AdvanceToNext() const {\n    while (!isa<SpecificAttr>(*Current))\n      ++Current;\n  }\n\n  void AdvanceToNext(Iterator I) const {\n    while (Current != I && !isa<SpecificAttr>(*Current))\n      ++Current;\n  }\n\npublic:\n  using value_type = SpecificAttr *;\n  using reference = SpecificAttr *;\n  using pointer = SpecificAttr *;\n  using iterator_category = std::forward_iterator_tag;\n  using difference_type = std::ptrdiff_t;\n\n  specific_attr_iterator() = default;\n  explicit specific_attr_iterator(Iterator i) : Current(i) {}\n\n  reference operator*() const {\n    AdvanceToNext();\n    return cast<SpecificAttr>(*Current);\n  }\n  pointer operator->() const {\n    AdvanceToNext();\n    return cast<SpecificAttr>(*Current);\n  }\n\n  specific_attr_iterator& operator++() {\n    ++Current;\n    return *this;\n  }\n  specific_attr_iterator operator++(int) {\n    specific_attr_iterator Tmp(*this);\n    ++(*this);\n    return Tmp;\n  }\n\n  friend bool operator==(specific_attr_iterator Left,\n                         specific_attr_iterator Right) {\n    assert((Left.Current == nullptr) == (Right.Current == nullptr));\n    if (Left.Current < Right.Current)\n      Left.AdvanceToNext(Right.Current);\n    else\n      Right.AdvanceToNext(Left.Current);\n    return Left.Current == Right.Current;\n  }\n  friend bool operator!=(specific_attr_iterator Left,\n                         specific_attr_iterator Right) {\n    return !(Left == Right);\n  }\n};\n\ntemplate <typename SpecificAttr, typename Container>\ninline specific_attr_iterator<SpecificAttr, Container>\n          specific_attr_begin(const Container& container) {\n  return specific_attr_iterator<SpecificAttr, Container>(container.begin());\n}\ntemplate <typename SpecificAttr, typename Container>\ninline specific_attr_iterator<SpecificAttr, Container>\n          specific_attr_end(const Container& container) {\n  return specific_attr_iterator<SpecificAttr, Container>(container.end());\n}\n\ntemplate <typename SpecificAttr, typename Container>\ninline bool hasSpecificAttr(const Container& container) {\n  return specific_attr_begin<SpecificAttr>(container) !=\n          specific_attr_end<SpecificAttr>(container);\n}\ntemplate <typename SpecificAttr, typename Container>\ninline SpecificAttr *getSpecificAttr(const Container& container) {\n  specific_attr_iterator<SpecificAttr, Container> i =\n      specific_attr_begin<SpecificAttr>(container);\n  if (i != specific_attr_end<SpecificAttr>(container))\n    return *i;\n  else\n    return nullptr;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_ATTRITERATOR_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "content": "//===- CanonicalType.h - C Language Family Type Representation --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CanQual class template, which provides access to\n//  canonical types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_CANONICALTYPE_H\n#define LLVM_CLANG_AST_CANONICALTYPE_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n\nnamespace clang {\n\ntemplate<typename T> class CanProxy;\ntemplate<typename T> struct CanProxyAdaptor;\nclass CXXRecordDecl;\nclass EnumDecl;\nclass Expr;\nclass IdentifierInfo;\nclass ObjCInterfaceDecl;\nclass RecordDecl;\nclass TagDecl;\nclass TemplateTypeParmDecl;\n\n//----------------------------------------------------------------------------//\n// Canonical, qualified type template\n//----------------------------------------------------------------------------//\n\n/// Represents a canonical, potentially-qualified type.\n///\n/// The CanQual template is a lightweight smart pointer that provides access\n/// to the canonical representation of a type, where all typedefs and other\n/// syntactic sugar has been eliminated. A CanQualType may also have various\n/// qualifiers (const, volatile, restrict) attached to it.\n///\n/// The template type parameter @p T is one of the Type classes (PointerType,\n/// BuiltinType, etc.). The type stored within @c CanQual<T> will be of that\n/// type (or some subclass of that type). The typedef @c CanQualType is just\n/// a shorthand for @c CanQual<Type>.\n///\n/// An instance of @c CanQual<T> can be implicitly converted to a\n/// @c CanQual<U> when T is derived from U, which essentially provides an\n/// implicit upcast. For example, @c CanQual<LValueReferenceType> can be\n/// converted to @c CanQual<ReferenceType>. Note that any @c CanQual type can\n/// be implicitly converted to a QualType, but the reverse operation requires\n/// a call to ASTContext::getCanonicalType().\ntemplate<typename T = Type>\nclass CanQual {\n  /// The actual, canonical type.\n  QualType Stored;\n\npublic:\n  /// Constructs a NULL canonical type.\n  CanQual() = default;\n\n  /// Converting constructor that permits implicit upcasting of\n  /// canonical type pointers.\n  template <typename U>\n  CanQual(const CanQual<U> &Other,\n          std::enable_if_t<std::is_base_of<T, U>::value, int> = 0);\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type.\n  ///\n  /// The underlying pointer must not be nullptr.\n  const T *getTypePtr() const { return cast<T>(Stored.getTypePtr()); }\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type, or nullptr.\n  const T *getTypePtrOrNull() const {\n    return cast_or_null<T>(Stored.getTypePtrOrNull());\n  }\n\n  /// Implicit conversion to a qualified type.\n  operator QualType() const { return Stored; }\n\n  /// Implicit conversion to bool.\n  explicit operator bool() const { return !isNull(); }\n\n  bool isNull() const {\n    return Stored.isNull();\n  }\n\n  SplitQualType split() const { return Stored.split(); }\n\n  /// Retrieve a canonical type pointer with a different static type,\n  /// upcasting or downcasting as needed.\n  ///\n  /// The getAs() function is typically used to try to downcast to a\n  /// more specific (canonical) type in the type system. For example:\n  ///\n  /// @code\n  /// void f(CanQual<Type> T) {\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) {\n  ///     // look at Ptr's pointee type\n  ///   }\n  /// }\n  /// @endcode\n  ///\n  /// \\returns A proxy pointer to the same type, but with the specified\n  /// static type (@p U). If the dynamic type is not the specified static type\n  /// or a derived class thereof, a NULL canonical type.\n  template<typename U> CanProxy<U> getAs() const;\n\n  template<typename U> CanProxy<U> castAs() const;\n\n  /// Overloaded arrow operator that produces a canonical type\n  /// proxy.\n  CanProxy<T> operator->() const;\n\n  /// Retrieve all qualifiers.\n  Qualifiers getQualifiers() const { return Stored.getLocalQualifiers(); }\n\n  /// Retrieve the const/volatile/restrict qualifiers.\n  unsigned getCVRQualifiers() const { return Stored.getLocalCVRQualifiers(); }\n\n  /// Determines whether this type has any qualifiers\n  bool hasQualifiers() const { return Stored.hasLocalQualifiers(); }\n\n  bool isConstQualified() const {\n    return Stored.isLocalConstQualified();\n  }\n\n  bool isVolatileQualified() const {\n    return Stored.isLocalVolatileQualified();\n  }\n\n  bool isRestrictQualified() const {\n    return Stored.isLocalRestrictQualified();\n  }\n\n  /// Determines if this canonical type is furthermore\n  /// canonical as a parameter.  The parameter-canonicalization\n  /// process decays arrays to pointers and drops top-level qualifiers.\n  bool isCanonicalAsParam() const {\n    return Stored.isCanonicalAsParam();\n  }\n\n  /// Retrieve the unqualified form of this type.\n  CanQual<T> getUnqualifiedType() const;\n\n  /// Retrieves a version of this type with const applied.\n  /// Note that this does not always yield a canonical type.\n  QualType withConst() const {\n    return Stored.withConst();\n  }\n\n  /// Determines whether this canonical type is more qualified than\n  /// the @p Other canonical type.\n  bool isMoreQualifiedThan(CanQual<T> Other) const {\n    return Stored.isMoreQualifiedThan(Other.Stored);\n  }\n\n  /// Determines whether this canonical type is at least as qualified as\n  /// the @p Other canonical type.\n  bool isAtLeastAsQualifiedAs(CanQual<T> Other) const {\n    return Stored.isAtLeastAsQualifiedAs(Other.Stored);\n  }\n\n  /// If the canonical type is a reference type, returns the type that\n  /// it refers to; otherwise, returns the type itself.\n  CanQual<Type> getNonReferenceType() const;\n\n  /// Retrieve the internal representation of this canonical type.\n  void *getAsOpaquePtr() const { return Stored.getAsOpaquePtr(); }\n\n  /// Construct a canonical type from its internal representation.\n  static CanQual<T> getFromOpaquePtr(void *Ptr);\n\n  /// Builds a canonical type from a QualType.\n  ///\n  /// This routine is inherently unsafe, because it requires the user to\n  /// ensure that the given type is a canonical type with the correct\n  // (dynamic) type.\n  static CanQual<T> CreateUnsafe(QualType Other);\n\n  void dump() const { Stored.dump(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n};\n\ntemplate<typename T, typename U>\ninline bool operator==(CanQual<T> x, CanQual<U> y) {\n  return x.getAsOpaquePtr() == y.getAsOpaquePtr();\n}\n\ntemplate<typename T, typename U>\ninline bool operator!=(CanQual<T> x, CanQual<U> y) {\n  return x.getAsOpaquePtr() != y.getAsOpaquePtr();\n}\n\n/// Represents a canonical, potentially-qualified type.\nusing CanQualType = CanQual<Type>;\n\ninline CanQualType Type::getCanonicalTypeUnqualified() const {\n  return CanQualType::CreateUnsafe(getCanonicalTypeInternal());\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             CanQualType T) {\n  DB << static_cast<QualType>(T);\n  return DB;\n}\n\n//----------------------------------------------------------------------------//\n// Internal proxy classes used by canonical types\n//----------------------------------------------------------------------------//\n\n#define LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(Accessor)                    \\\nCanQualType Accessor() const {                                           \\\nreturn CanQualType::CreateUnsafe(this->getTypePtr()->Accessor());      \\\n}\n\n#define LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Type, Accessor)             \\\nType Accessor() const { return this->getTypePtr()->Accessor(); }\n\n/// Base class of all canonical proxy types, which is responsible for\n/// storing the underlying canonical type and providing basic conversions.\ntemplate<typename T>\nclass CanProxyBase {\nprotected:\n  CanQual<T> Stored;\n\npublic:\n  /// Retrieve the pointer to the underlying Type\n  const T *getTypePtr() const { return Stored.getTypePtr(); }\n\n  /// Implicit conversion to the underlying pointer.\n  ///\n  /// Also provides the ability to use canonical type proxies in a Boolean\n  // context,e.g.,\n  /// @code\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) { ... }\n  /// @endcode\n  operator const T*() const { return this->Stored.getTypePtrOrNull(); }\n\n  /// Try to convert the given canonical type to a specific structural\n  /// type.\n  template<typename U> CanProxy<U> getAs() const {\n    return this->Stored.template getAs<U>();\n  }\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Type::TypeClass, getTypeClass)\n\n  // Type predicates\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessBuiltinType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteOrObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVariablyModifiedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isEnumeralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBooleanType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isWideCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArithmeticType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDerivedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isScalarType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAggregateType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isMemberFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isInterfaceType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureOrClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnionType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isNullPtrType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDependentType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isOverloadableType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArrayType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasObjCPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasSignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasUnsignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasFloatingRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isPromotableIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isConstantSizeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSpecifierType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(CXXRecordDecl*, getAsCXXRecordDecl)\n\n  /// Retrieve the proxy-adaptor type.\n  ///\n  /// This arrow operator is used when CanProxyAdaptor has been specialized\n  /// for the given type T. In that case, we reference members of the\n  /// CanProxyAdaptor specialization. Otherwise, this operator will be hidden\n  /// by the arrow operator in the primary CanProxyAdaptor template.\n  const CanProxyAdaptor<T> *operator->() const {\n    return static_cast<const CanProxyAdaptor<T> *>(this);\n  }\n};\n\n/// Replaceable canonical proxy adaptor class that provides the link\n/// between a canonical type and the accessors of the type.\n///\n/// The CanProxyAdaptor is a replaceable class template that is instantiated\n/// as part of each canonical proxy type. The primary template merely provides\n/// redirection to the underlying type (T), e.g., @c PointerType. One can\n/// provide specializations of this class template for each underlying type\n/// that provide accessors returning canonical types (@c CanQualType) rather\n/// than the more typical @c QualType, to propagate the notion of \"canonical\"\n/// through the system.\ntemplate<typename T>\nstruct CanProxyAdaptor : CanProxyBase<T> {};\n\n/// Canonical proxy type returned when retrieving the members of a\n/// canonical type or as the result of the @c CanQual<T>::getAs member\n/// function.\n///\n/// The CanProxy type mainly exists as a proxy through which operator-> will\n/// look to either map down to a raw T* (e.g., PointerType*) or to a proxy\n/// type that provides canonical-type access to the fields of the type.\ntemplate<typename T>\nclass CanProxy : public CanProxyAdaptor<T> {\npublic:\n  /// Build a NULL proxy.\n  CanProxy() = default;\n\n  /// Build a proxy to the given canonical type.\n  CanProxy(CanQual<T> Stored) { this->Stored = Stored; }\n\n  /// Implicit conversion to the stored canonical type.\n  operator CanQual<T>() const { return this->Stored; }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Implement simplify_type for CanQual<T>, so that we can dyn_cast from\n/// CanQual<T> to a specific Type class. We're prefer isa/dyn_cast/cast/etc.\n/// to return smart pointer (proxies?).\ntemplate<typename T>\nstruct simplify_type< ::clang::CanQual<T>> {\n  using SimpleType = const T *;\n\n  static SimpleType getSimplifiedValue(::clang::CanQual<T> Val) {\n    return Val.getTypePtr();\n  }\n};\n\n// Teach SmallPtrSet that CanQual<T> is \"basically a pointer\".\ntemplate<typename T>\nstruct PointerLikeTypeTraits<clang::CanQual<T>> {\n  static void *getAsVoidPointer(clang::CanQual<T> P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static clang::CanQual<T> getFromVoidPointer(void *P) {\n    return clang::CanQual<T>::getFromOpaquePtr(P);\n  }\n\n  // qualifier information is encoded in the low bits.\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\n//----------------------------------------------------------------------------//\n// Canonical proxy adaptors for canonical type nodes.\n//----------------------------------------------------------------------------//\n\n/// Iterator adaptor that turns an iterator over canonical QualTypes\n/// into an iterator over CanQualTypes.\ntemplate <typename InputIterator>\nstruct CanTypeIterator\n    : llvm::iterator_adaptor_base<\n          CanTypeIterator<InputIterator>, InputIterator,\n          typename std::iterator_traits<InputIterator>::iterator_category,\n          CanQualType,\n          typename std::iterator_traits<InputIterator>::difference_type,\n          CanProxy<Type>, CanQualType> {\n  CanTypeIterator() = default;\n  explicit CanTypeIterator(InputIterator Iter)\n      : CanTypeIterator::iterator_adaptor_base(std::move(Iter)) {}\n\n  CanQualType operator*() const { return CanQualType::CreateUnsafe(*this->I); }\n  CanProxy<Type> operator->() const;\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ComplexType> : public CanProxyBase<ComplexType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<PointerType> : public CanProxyBase<PointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<BlockPointerType>\n  : public CanProxyBase<BlockPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ReferenceType> : public CanProxyBase<ReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<LValueReferenceType>\n  : public CanProxyBase<LValueReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<RValueReferenceType>\n  : public CanProxyBase<RValueReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<MemberPointerType>\n  : public CanProxyBase<MemberPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const Type *, getClass)\n};\n\n// CanProxyAdaptors for arrays are intentionally unimplemented because\n// they are not safe.\ntemplate<> struct CanProxyAdaptor<ArrayType>;\ntemplate<> struct CanProxyAdaptor<ConstantArrayType>;\ntemplate<> struct CanProxyAdaptor<IncompleteArrayType>;\ntemplate<> struct CanProxyAdaptor<VariableArrayType>;\ntemplate<> struct CanProxyAdaptor<DependentSizedArrayType>;\n\ntemplate<>\nstruct CanProxyAdaptor<DependentSizedExtVectorType>\n  : public CanProxyBase<DependentSizedExtVectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const Expr *, getSizeExpr)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(SourceLocation, getAttributeLoc)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<VectorType> : public CanProxyBase<VectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumElements)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ExtVectorType> : public CanProxyBase<ExtVectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumElements)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionType> : public CanProxyBase<FunctionType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionNoProtoType>\n  : public CanProxyBase<FunctionNoProtoType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionProtoType>\n  : public CanProxyBase<FunctionProtoType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumParams)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasExtParameterInfos)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(\n            ArrayRef<FunctionProtoType::ExtParameterInfo>, getExtParameterInfos)\n\n  CanQualType getParamType(unsigned i) const {\n    return CanQualType::CreateUnsafe(this->getTypePtr()->getParamType(i));\n  }\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVariadic)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Qualifiers, getMethodQuals)\n\n  using param_type_iterator =\n      CanTypeIterator<FunctionProtoType::param_type_iterator>;\n\n  param_type_iterator param_type_begin() const {\n    return param_type_iterator(this->getTypePtr()->param_type_begin());\n  }\n\n  param_type_iterator param_type_end() const {\n    return param_type_iterator(this->getTypePtr()->param_type_end());\n  }\n\n  // Note: canonical function types never have exception specifications\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TypeOfType> : public CanProxyBase<TypeOfType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<DecltypeType> : public CanProxyBase<DecltypeType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Expr *, getUnderlyingExpr)\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n};\n\ntemplate <>\nstruct CanProxyAdaptor<UnaryTransformType>\n    : public CanProxyBase<UnaryTransformType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getBaseType)\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(UnaryTransformType::UTTKind, getUTTKind)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TagType> : public CanProxyBase<TagType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(TagDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<RecordType> : public CanProxyBase<RecordType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(RecordDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasConstFields)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<EnumType> : public CanProxyBase<EnumType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(EnumDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TemplateTypeParmType>\n  : public CanProxyBase<TemplateTypeParmType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getDepth)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getIndex)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isParameterPack)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(TemplateTypeParmDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(IdentifierInfo *, getIdentifier)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ObjCObjectType>\n  : public CanProxyBase<ObjCObjectType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getBaseType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const ObjCInterfaceDecl *,\n                                      getInterface)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCUnqualifiedId)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCUnqualifiedClass)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedId)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedClass)\n\n  using qual_iterator = ObjCObjectPointerType::qual_iterator;\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_begin)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_end)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, qual_empty)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumProtocols)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ObjCObjectPointerType>\n  : public CanProxyBase<ObjCObjectPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const ObjCInterfaceType *,\n                                      getInterfaceType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCIdType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedIdType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedClassType)\n\n  using qual_iterator = ObjCObjectPointerType::qual_iterator;\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_begin)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_end)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, qual_empty)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumProtocols)\n};\n\n//----------------------------------------------------------------------------//\n// Method and function definitions\n//----------------------------------------------------------------------------//\ntemplate<typename T>\ninline CanQual<T> CanQual<T>::getUnqualifiedType() const {\n  return CanQual<T>::CreateUnsafe(Stored.getLocalUnqualifiedType());\n}\n\ntemplate<typename T>\ninline CanQual<Type> CanQual<T>::getNonReferenceType() const {\n  if (CanQual<ReferenceType> RefType = getAs<ReferenceType>())\n    return RefType->getPointeeType();\n  else\n    return *this;\n}\n\ntemplate<typename T>\nCanQual<T> CanQual<T>::getFromOpaquePtr(void *Ptr) {\n  CanQual<T> Result;\n  Result.Stored = QualType::getFromOpaquePtr(Ptr);\n  assert((!Result || Result.Stored.getAsOpaquePtr() == (void*)-1 ||\n          Result.Stored.isCanonical()) && \"Type is not canonical!\");\n  return Result;\n}\n\ntemplate<typename T>\nCanQual<T> CanQual<T>::CreateUnsafe(QualType Other) {\n  assert((Other.isNull() || Other.isCanonical()) && \"Type is not canonical!\");\n  assert((Other.isNull() || isa<T>(Other.getTypePtr())) &&\n         \"Dynamic type does not meet the static type's requires\");\n  CanQual<T> Result;\n  Result.Stored = Other;\n  return Result;\n}\n\ntemplate<typename T>\ntemplate<typename U>\nCanProxy<U> CanQual<T>::getAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with getAs!\");\n\n  if (Stored.isNull())\n    return CanProxy<U>();\n\n  if (isa<U>(Stored.getTypePtr()))\n    return CanQual<U>::CreateUnsafe(Stored);\n\n  return CanProxy<U>();\n}\n\ntemplate<typename T>\ntemplate<typename U>\nCanProxy<U> CanQual<T>::castAs() const {\n  static_assert(!TypeIsArrayType<U>::value,\n                \"ArrayType cannot be used with castAs!\");\n\n  assert(!Stored.isNull() && isa<U>(Stored.getTypePtr()));\n  return CanQual<U>::CreateUnsafe(Stored);\n}\n\ntemplate<typename T>\nCanProxy<T> CanQual<T>::operator->() const {\n  return CanProxy<T>(*this);\n}\n\ntemplate <typename InputIterator>\nCanProxy<Type> CanTypeIterator<InputIterator>::operator->() const {\n  return CanProxy<Type>(*this);\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_CANONICALTYPE_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "content": "//===- Decl.h - Classes for representing declarations -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECL_H\n#define LLVM_CLANG_AST_DECL_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nstruct ASTTemplateArgumentListInfo;\nclass Attr;\nclass CompoundStmt;\nclass DependentFunctionTemplateSpecializationInfo;\nclass EnumDecl;\nclass Expr;\nclass FunctionTemplateDecl;\nclass FunctionTemplateSpecializationInfo;\nclass FunctionTypeLoc;\nclass LabelStmt;\nclass MemberSpecializationInfo;\nclass Module;\nclass NamespaceDecl;\nclass ParmVarDecl;\nclass RecordDecl;\nclass Stmt;\nclass StringLiteral;\nclass TagDecl;\nclass TemplateArgumentList;\nclass TemplateArgumentListInfo;\nclass TemplateParameterList;\nclass TypeAliasTemplateDecl;\nclass TypeLoc;\nclass UnresolvedSetImpl;\nclass VarTemplateDecl;\n\n/// The top declaration context.\nclass TranslationUnitDecl : public Decl, public DeclContext {\n  ASTContext &Ctx;\n\n  /// The (most recently entered) anonymous namespace for this\n  /// translation unit, if one has been created.\n  NamespaceDecl *AnonymousNamespace = nullptr;\n\n  explicit TranslationUnitDecl(ASTContext &ctx);\n\n  virtual void anchor();\n\npublic:\n  ASTContext &getASTContext() const { return Ctx; }\n\n  NamespaceDecl *getAnonymousNamespace() const { return AnonymousNamespace; }\n  void setAnonymousNamespace(NamespaceDecl *D) { AnonymousNamespace = D; }\n\n  static TranslationUnitDecl *Create(ASTContext &C);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TranslationUnit; }\n  static DeclContext *castToDeclContext(const TranslationUnitDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TranslationUnitDecl*>(D));\n  }\n  static TranslationUnitDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TranslationUnitDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a `#pragma comment` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaCommentDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaCommentDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  PragmaMSCommentKind CommentKind;\n\n  PragmaCommentDecl(TranslationUnitDecl *TU, SourceLocation CommentLoc,\n                    PragmaMSCommentKind CommentKind)\n      : Decl(PragmaComment, TU, CommentLoc), CommentKind(CommentKind) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaCommentDecl *Create(const ASTContext &C, TranslationUnitDecl *DC,\n                                   SourceLocation CommentLoc,\n                                   PragmaMSCommentKind CommentKind,\n                                   StringRef Arg);\n  static PragmaCommentDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned ArgSize);\n\n  PragmaMSCommentKind getCommentKind() const { return CommentKind; }\n\n  StringRef getArg() const { return getTrailingObjects<char>(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaComment; }\n};\n\n/// Represents a `#pragma detect_mismatch` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaDetectMismatchDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaDetectMismatchDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  size_t ValueStart;\n\n  PragmaDetectMismatchDecl(TranslationUnitDecl *TU, SourceLocation Loc,\n                           size_t ValueStart)\n      : Decl(PragmaDetectMismatch, TU, Loc), ValueStart(ValueStart) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaDetectMismatchDecl *Create(const ASTContext &C,\n                                          TranslationUnitDecl *DC,\n                                          SourceLocation Loc, StringRef Name,\n                                          StringRef Value);\n  static PragmaDetectMismatchDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID, unsigned NameValueSize);\n\n  StringRef getName() const { return getTrailingObjects<char>(); }\n  StringRef getValue() const { return getTrailingObjects<char>() + ValueStart; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaDetectMismatch; }\n};\n\n/// Declaration context for names declared as extern \"C\" in C++. This\n/// is neither the semantic nor lexical context for such declarations, but is\n/// used to check for conflicts with other extern \"C\" declarations. Example:\n///\n/// \\code\n///   namespace N { extern \"C\" void f(); } // #1\n///   void N::f() {}                       // #2\n///   namespace M { extern \"C\" void f(); } // #3\n/// \\endcode\n///\n/// The semantic context of #1 is namespace N and its lexical context is the\n/// LinkageSpecDecl; the semantic context of #2 is namespace N and its lexical\n/// context is the TU. However, both declarations are also visible in the\n/// extern \"C\" context.\n///\n/// The declaration at #3 finds it is a redeclaration of \\c N::f through\n/// lookup in the extern \"C\" context.\nclass ExternCContextDecl : public Decl, public DeclContext {\n  explicit ExternCContextDecl(TranslationUnitDecl *TU)\n    : Decl(ExternCContext, TU, SourceLocation()),\n      DeclContext(ExternCContext) {}\n\n  virtual void anchor();\n\npublic:\n  static ExternCContextDecl *Create(const ASTContext &C,\n                                    TranslationUnitDecl *TU);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ExternCContext; }\n  static DeclContext *castToDeclContext(const ExternCContextDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExternCContextDecl*>(D));\n  }\n  static ExternCContextDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExternCContextDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// This represents a decl that may have a name.  Many decls have names such\n/// as ObjCMethodDecl, but not \\@class, etc.\n///\n/// Note that not every NamedDecl is actually named (e.g., a struct might\n/// be anonymous), and not every name is an identifier.\nclass NamedDecl : public Decl {\n  /// The name of this declaration, which is typically a normal\n  /// identifier but may also be a special kind of name (C++\n  /// constructor, Objective-C selector, etc.)\n  DeclarationName Name;\n\n  virtual void anchor();\n\nprivate:\n  NamedDecl *getUnderlyingDeclImpl() LLVM_READONLY;\n\nprotected:\n  NamedDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName N)\n      : Decl(DK, DC, L), Name(N) {}\n\npublic:\n  /// Get the identifier that names this declaration, if there is one.\n  ///\n  /// This will return NULL if this declaration has no name (e.g., for\n  /// an unnamed class) or if the name is a special name (C++ constructor,\n  /// Objective-C selector, etc.).\n  IdentifierInfo *getIdentifier() const { return Name.getAsIdentifierInfo(); }\n\n  /// Get the name of identifier for this declaration as a StringRef.\n  ///\n  /// This requires that the declaration have a name and that it be a simple\n  /// identifier.\n  StringRef getName() const {\n    assert(Name.isIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier() ? getIdentifier()->getName() : \"\";\n  }\n\n  /// Get a human-readable name for the declaration, even if it is one of the\n  /// special kinds of names (C++ constructor, Objective-C selector, etc).\n  ///\n  /// Creating this name requires expensive string manipulation, so it should\n  /// be called only when performance doesn't matter. For simple declarations,\n  /// getNameAsCString() should suffice.\n  //\n  // FIXME: This function should be renamed to indicate that it is not just an\n  // alternate form of getName(), and clients should move as appropriate.\n  //\n  // FIXME: Deprecated, move clients to getName().\n  std::string getNameAsString() const { return Name.getAsString(); }\n\n  /// Pretty-print the unqualified name of this declaration. Can be overloaded\n  /// by derived classes to provide a more user-friendly name when appropriate.\n  virtual void printName(raw_ostream &os) const;\n\n  /// Get the actual, stored name of the declaration, which may be a special\n  /// name.\n  ///\n  /// Note that generally in diagnostics, the non-null \\p NamedDecl* itself\n  /// should be sent into the diagnostic instead of using the result of\n  /// \\p getDeclName().\n  ///\n  /// A \\p DeclarationName in a diagnostic will just be streamed to the output,\n  /// which will directly result in a call to \\p DeclarationName::print.\n  ///\n  /// A \\p NamedDecl* in a diagnostic will also ultimately result in a call to\n  /// \\p DeclarationName::print, but with two customisation points along the\n  /// way (\\p getNameForDiagnostic and \\p printName). These are used to print\n  /// the template arguments if any, and to provide a user-friendly name for\n  /// some entities (such as unnamed variables and anonymous records).\n  DeclarationName getDeclName() const { return Name; }\n\n  /// Set the name of this declaration.\n  void setDeclName(DeclarationName N) { Name = N; }\n\n  /// Returns a human-readable qualified name for this declaration, like\n  /// A::B::i, for i being member of namespace A::B.\n  ///\n  /// If the declaration is not a member of context which can be named (record,\n  /// namespace), it will return the same result as printName().\n  ///\n  /// Creating this name is expensive, so it should be called only when\n  /// performance doesn't matter.\n  void printQualifiedName(raw_ostream &OS) const;\n  void printQualifiedName(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  /// Print only the nested name specifier part of a fully-qualified name,\n  /// including the '::' at the end. E.g.\n  ///    when `printQualifiedName(D)` prints \"A::B::i\",\n  ///    this function prints \"A::B::\".\n  void printNestedNameSpecifier(raw_ostream &OS) const;\n  void printNestedNameSpecifier(raw_ostream &OS,\n                                const PrintingPolicy &Policy) const;\n\n  // FIXME: Remove string version.\n  std::string getQualifiedNameAsString() const;\n\n  /// Appends a human-readable name for this declaration into the given stream.\n  ///\n  /// This is the method invoked by Sema when displaying a NamedDecl\n  /// in a diagnostic.  It does not necessarily produce the same\n  /// result as printName(); for example, class template\n  /// specializations are printed with their template arguments.\n  virtual void getNameForDiagnostic(raw_ostream &OS,\n                                    const PrintingPolicy &Policy,\n                                    bool Qualified) const;\n\n  /// Determine whether this declaration, if known to be well-formed within\n  /// its context, will replace the declaration OldD if introduced into scope.\n  ///\n  /// A declaration will replace another declaration if, for example, it is\n  /// a redeclaration of the same variable or function, but not if it is a\n  /// declaration of a different kind (function vs. class) or an overloaded\n  /// function.\n  ///\n  /// \\param IsKnownNewer \\c true if this declaration is known to be newer\n  /// than \\p OldD (for instance, if this declaration is newly-created).\n  bool declarationReplaces(NamedDecl *OldD, bool IsKnownNewer = true) const;\n\n  /// Determine whether this declaration has linkage.\n  bool hasLinkage() const;\n\n  using Decl::isModulePrivate;\n  using Decl::setModulePrivate;\n\n  /// Determine whether this declaration is a C++ class member.\n  bool isCXXClassMember() const {\n    const DeclContext *DC = getDeclContext();\n\n    // C++0x [class.mem]p1:\n    //   The enumerators of an unscoped enumeration defined in\n    //   the class are members of the class.\n    if (isa<EnumDecl>(DC))\n      DC = DC->getRedeclContext();\n\n    return DC->isRecord();\n  }\n\n  /// Determine whether the given declaration is an instance member of\n  /// a C++ class.\n  bool isCXXInstanceMember() const;\n\n  /// Determine what kind of linkage this entity has.\n  ///\n  /// This is not the linkage as defined by the standard or the codegen notion\n  /// of linkage. It is just an implementation detail that is used to compute\n  /// those.\n  Linkage getLinkageInternal() const;\n\n  /// Get the linkage from a semantic point of view. Entities in\n  /// anonymous namespaces are external (in c++98).\n  Linkage getFormalLinkage() const {\n    return clang::getFormalLinkage(getLinkageInternal());\n  }\n\n  /// True if this decl has external linkage.\n  bool hasExternalFormalLinkage() const {\n    return isExternalFormalLinkage(getLinkageInternal());\n  }\n\n  bool isExternallyVisible() const {\n    return clang::isExternallyVisible(getLinkageInternal());\n  }\n\n  /// Determine whether this declaration can be redeclared in a\n  /// different translation unit.\n  bool isExternallyDeclarable() const {\n    return isExternallyVisible() && !getOwningModuleForLinkage();\n  }\n\n  /// Determines the visibility of this entity.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Determines the linkage and visibility of this entity.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// Kinds of explicit visibility.\n  enum ExplicitVisibilityKind {\n    /// Do an LV computation for, ultimately, a type.\n    /// Visibility may be restricted by type visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForType,\n\n    /// Do an LV computation for, ultimately, a non-type declaration.\n    /// Visibility may be restricted by value visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForValue\n  };\n\n  /// If visibility was explicitly specified for this\n  /// declaration, return that visibility.\n  Optional<Visibility>\n  getExplicitVisibility(ExplicitVisibilityKind kind) const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// True if something has required us to compute the linkage\n  /// of this declaration.\n  ///\n  /// Language features which can retroactively change linkage (like a\n  /// typedef name for linkage purposes) may need to consider this,\n  /// but hopefully only in transitory ways during parsing.\n  bool hasLinkageBeenComputed() const {\n    return hasCachedLinkage();\n  }\n\n  /// Looks through UsingDecls and ObjCCompatibleAliasDecls for\n  /// the underlying named decl.\n  NamedDecl *getUnderlyingDecl() {\n    // Fast-path the common case.\n    if (this->getKind() != UsingShadow &&\n        this->getKind() != ConstructorUsingShadow &&\n        this->getKind() != ObjCCompatibleAlias &&\n        this->getKind() != NamespaceAlias)\n      return this;\n\n    return getUnderlyingDeclImpl();\n  }\n  const NamedDecl *getUnderlyingDecl() const {\n    return const_cast<NamedDecl*>(this)->getUnderlyingDecl();\n  }\n\n  NamedDecl *getMostRecentDecl() {\n    return cast<NamedDecl>(static_cast<Decl *>(this)->getMostRecentDecl());\n  }\n  const NamedDecl *getMostRecentDecl() const {\n    return const_cast<NamedDecl*>(this)->getMostRecentDecl();\n  }\n\n  ObjCStringFormatFamily getObjCFStringFormattingFamily() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstNamed && K <= lastNamed; }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const NamedDecl &ND) {\n  ND.printName(OS);\n  return OS;\n}\n\n/// Represents the declaration of a label.  Labels also have a\n/// corresponding LabelStmt, which indicates the position that the label was\n/// defined at.  For normal labels, the location of the decl is the same as the\n/// location of the statement.  For GNU local labels (__label__), the decl\n/// location is where the __label__ is.\nclass LabelDecl : public NamedDecl {\n  LabelStmt *TheStmt;\n  StringRef MSAsmName;\n  bool MSAsmNameResolved = false;\n\n  /// For normal labels, this is the same as the main declaration\n  /// label, i.e., the location of the identifier; for GNU local labels,\n  /// this is the location of the __label__ keyword.\n  SourceLocation LocStart;\n\n  LabelDecl(DeclContext *DC, SourceLocation IdentL, IdentifierInfo *II,\n            LabelStmt *S, SourceLocation StartL)\n      : NamedDecl(Label, DC, IdentL, II), TheStmt(S), LocStart(StartL) {}\n\n  void anchor() override;\n\npublic:\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II);\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II,\n                           SourceLocation GnuLabelL);\n  static LabelDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  LabelStmt *getStmt() const { return TheStmt; }\n  void setStmt(LabelStmt *T) { TheStmt = T; }\n\n  bool isGnuLocal() const { return LocStart != getLocation(); }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, getLocation());\n  }\n\n  bool isMSAsmLabel() const { return !MSAsmName.empty(); }\n  bool isResolvedMSAsmLabel() const { return isMSAsmLabel() && MSAsmNameResolved; }\n  void setMSAsmLabel(StringRef Name);\n  StringRef getMSAsmLabel() const { return MSAsmName; }\n  void setMSAsmLabelResolved() { MSAsmNameResolved = true; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Label; }\n};\n\n/// Represent a C++ namespace.\nclass NamespaceDecl : public NamedDecl, public DeclContext,\n                      public Redeclarable<NamespaceDecl>\n{\n  /// The starting location of the source range, pointing\n  /// to either the namespace or the inline keyword.\n  SourceLocation LocStart;\n\n  /// The ending location of the source range.\n  SourceLocation RBraceLoc;\n\n  /// A pointer to either the anonymous namespace that lives just inside\n  /// this namespace or to the first namespace in the chain (the latter case\n  /// only when this is not the first in the chain), along with a\n  /// boolean value indicating whether this is an inline namespace.\n  llvm::PointerIntPair<NamespaceDecl *, 1, bool> AnonOrFirstNamespaceAndInline;\n\n  NamespaceDecl(ASTContext &C, DeclContext *DC, bool Inline,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, NamespaceDecl *PrevDecl);\n\n  using redeclarable_base = Redeclarable<NamespaceDecl>;\n\n  NamespaceDecl *getNextRedeclarationImpl() override;\n  NamespaceDecl *getPreviousDeclImpl() override;\n  NamespaceDecl *getMostRecentDeclImpl() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static NamespaceDecl *Create(ASTContext &C, DeclContext *DC,\n                               bool Inline, SourceLocation StartLoc,\n                               SourceLocation IdLoc, IdentifierInfo *Id,\n                               NamespaceDecl *PrevDecl);\n\n  static NamespaceDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Returns true if this is an anonymous namespace declaration.\n  ///\n  /// For example:\n  /// \\code\n  ///   namespace {\n  ///     ...\n  ///   };\n  /// \\endcode\n  /// q.v. C++ [namespace.unnamed]\n  bool isAnonymousNamespace() const {\n    return !getIdentifier();\n  }\n\n  /// Returns true if this is an inline namespace declaration.\n  bool isInline() const {\n    return AnonOrFirstNamespaceAndInline.getInt();\n  }\n\n  /// Set whether this is an inline namespace declaration.\n  void setInline(bool Inline) {\n    AnonOrFirstNamespaceAndInline.setInt(Inline);\n  }\n\n  /// Get the original (first) namespace declaration.\n  NamespaceDecl *getOriginalNamespace();\n\n  /// Get the original (first) namespace declaration.\n  const NamespaceDecl *getOriginalNamespace() const;\n\n  /// Return true if this declaration is an original (first) declaration\n  /// of the namespace. This is false for non-original (subsequent) namespace\n  /// declarations and anonymous namespaces.\n  bool isOriginalNamespace() const;\n\n  /// Retrieve the anonymous namespace nested inside this namespace,\n  /// if any.\n  NamespaceDecl *getAnonymousNamespace() const {\n    return getOriginalNamespace()->AnonOrFirstNamespaceAndInline.getPointer();\n  }\n\n  void setAnonymousNamespace(NamespaceDecl *D) {\n    getOriginalNamespace()->AnonOrFirstNamespaceAndInline.setPointer(D);\n  }\n\n  /// Retrieves the canonical declaration of this namespace.\n  NamespaceDecl *getCanonicalDecl() override {\n    return getOriginalNamespace();\n  }\n  const NamespaceDecl *getCanonicalDecl() const {\n    return getOriginalNamespace();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, RBraceLoc);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Namespace; }\n  static DeclContext *castToDeclContext(const NamespaceDecl *D) {\n    return static_cast<DeclContext *>(const_cast<NamespaceDecl*>(D));\n  }\n  static NamespaceDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<NamespaceDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represent the declaration of a variable (in which case it is\n/// an lvalue) a function (in which case it is a function designator) or\n/// an enum constant.\nclass ValueDecl : public NamedDecl {\n  QualType DeclType;\n\n  void anchor() override;\n\nprotected:\n  ValueDecl(Kind DK, DeclContext *DC, SourceLocation L,\n            DeclarationName N, QualType T)\n    : NamedDecl(DK, DC, L, N), DeclType(T) {}\n\npublic:\n  QualType getType() const { return DeclType; }\n  void setType(QualType newType) { DeclType = newType; }\n\n  /// Determine whether this symbol is weakly-imported,\n  ///        or declared with the weak or weak-ref attr.\n  bool isWeak() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstValue && K <= lastValue; }\n};\n\n/// A struct with extended info about a syntactic\n/// name qualifier, to be used for the case of out-of-line declarations.\nstruct QualifierInfo {\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The number of \"outer\" template parameter lists.\n  /// The count includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  unsigned NumTemplParamLists = 0;\n\n  /// A new-allocated array of size NumTemplParamLists,\n  /// containing pointers to the \"outer\" template parameter lists.\n  /// It includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  TemplateParameterList** TemplParamLists = nullptr;\n\n  QualifierInfo() = default;\n  QualifierInfo(const QualifierInfo &) = delete;\n  QualifierInfo& operator=(const QualifierInfo &) = delete;\n\n  /// Sets info about \"outer\" template parameter lists.\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n};\n\n/// Represents a ValueDecl that came out of a declarator.\n/// Contains type source information through TypeSourceInfo.\nclass DeclaratorDecl : public ValueDecl {\n  // A struct representing a TInfo, a trailing requires-clause and a syntactic\n  // qualifier, to be used for the (uncommon) case of out-of-line declarations\n  // and constrained function decls.\n  struct ExtInfo : public QualifierInfo {\n    TypeSourceInfo *TInfo;\n    Expr *TrailingRequiresClause = nullptr;\n  };\n\n  llvm::PointerUnion<TypeSourceInfo *, ExtInfo *> DeclInfo;\n\n  /// The start of the source range for this declaration,\n  /// ignoring outer template declarations.\n  SourceLocation InnerLocStart;\n\n  bool hasExtInfo() const { return DeclInfo.is<ExtInfo*>(); }\n  ExtInfo *getExtInfo() { return DeclInfo.get<ExtInfo*>(); }\n  const ExtInfo *getExtInfo() const { return DeclInfo.get<ExtInfo*>(); }\n\nprotected:\n  DeclaratorDecl(Kind DK, DeclContext *DC, SourceLocation L,\n                 DeclarationName N, QualType T, TypeSourceInfo *TInfo,\n                 SourceLocation StartL)\n      : ValueDecl(DK, DC, L, N, T), DeclInfo(TInfo), InnerLocStart(StartL) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return hasExtInfo()\n      ? getExtInfo()->TInfo\n      : DeclInfo.get<TypeSourceInfo*>();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *TI) {\n    if (hasExtInfo())\n      getExtInfo()->TInfo = TI;\n    else\n      DeclInfo = TI;\n  }\n\n  /// Return start of source range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return InnerLocStart; }\n  void setInnerLocStart(SourceLocation L) { InnerLocStart = L; }\n\n  /// Return start of source range taking into account any outer template\n  /// declarations.\n  SourceLocation getOuterLocStart() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getOuterLocStart();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  /// \\brief Get the constraint-expression introduced by the trailing\n  /// requires-clause in the function/member declaration, or null if no\n  /// requires-clause was provided.\n  Expr *getTrailingRequiresClause() {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  const Expr *getTrailingRequiresClause() const {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  void setTrailingRequiresClause(Expr *TrailingRequiresClause);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned index) const {\n    assert(index < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[index];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  SourceLocation getTypeSpecStartLoc() const;\n  SourceLocation getTypeSpecEndLoc() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstDeclarator && K <= lastDeclarator;\n  }\n};\n\n/// Structure used to store a statement, the constant value to\n/// which it was evaluated (if any), and whether or not the statement\n/// is an integral constant expression (if known).\nstruct EvaluatedStmt {\n  /// Whether this statement was already evaluated.\n  bool WasEvaluated : 1;\n\n  /// Whether this statement is being evaluated.\n  bool IsEvaluating : 1;\n\n  /// Whether this variable is known to have constant initialization. This is\n  /// currently only computed in C++, for static / thread storage duration\n  /// variables that might have constant initialization and for variables that\n  /// are usable in constant expressions.\n  bool HasConstantInitialization : 1;\n\n  /// Whether this variable is known to have constant destruction. That is,\n  /// whether running the destructor on the initial value is a side-effect\n  /// (and doesn't inspect any state that might have changed during program\n  /// execution). This is currently only computed if the destructor is\n  /// non-trivial.\n  bool HasConstantDestruction : 1;\n\n  /// In C++98, whether the initializer is an ICE. This affects whether the\n  /// variable is usable in constant expressions.\n  bool HasICEInit : 1;\n  bool CheckedForICEInit : 1;\n\n  Stmt *Value;\n  APValue Evaluated;\n\n  EvaluatedStmt()\n      : WasEvaluated(false), IsEvaluating(false),\n        HasConstantInitialization(false), HasConstantDestruction(false),\n        HasICEInit(false), CheckedForICEInit(false) {}\n};\n\n/// Represents a variable declaration or definition.\nclass VarDecl : public DeclaratorDecl, public Redeclarable<VarDecl> {\npublic:\n  /// Initialization styles.\n  enum InitializationStyle {\n    /// C-style initialization with assignment\n    CInit,\n\n    /// Call-style initialization (C++98)\n    CallInit,\n\n    /// Direct list-initialization (C++11)\n    ListInit\n  };\n\n  /// Kinds of thread-local storage.\n  enum TLSKind {\n    /// Not a TLS variable.\n    TLS_None,\n\n    /// TLS with a known-constant initializer.\n    TLS_Static,\n\n    /// TLS with a dynamic initializer.\n    TLS_Dynamic\n  };\n\n  /// Return the string used to specify the storage class \\p SC.\n  ///\n  /// It is illegal to call this function with SC == None.\n  static const char *getStorageClassSpecifierString(StorageClass SC);\n\nprotected:\n  // A pointer union of Stmt * and EvaluatedStmt *. When an EvaluatedStmt, we\n  // have allocated the auxiliary struct of information there.\n  //\n  // TODO: It is a bit unfortunate to use a PointerUnion inside the VarDecl for\n  // this as *many* VarDecls are ParmVarDecls that don't have default\n  // arguments. We could save some space by moving this pointer union to be\n  // allocated in trailing space when necessary.\n  using InitType = llvm::PointerUnion<Stmt *, EvaluatedStmt *>;\n\n  /// The initializer for this variable or, for a ParmVarDecl, the\n  /// C++ default argument.\n  mutable InitType Init;\n\nprivate:\n  friend class ASTDeclReader;\n  friend class ASTNodeImporter;\n  friend class StmtIteratorBase;\n\n  class VarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class VarDecl;\n\n    unsigned SClass : 3;\n    unsigned TSCSpec : 2;\n    unsigned InitStyle : 2;\n\n    /// Whether this variable is an ARC pseudo-__strong variable; see\n    /// isARCPseudoStrong() for details.\n    unsigned ARCPseudoStrong : 1;\n  };\n  enum { NumVarDeclBits = 8 };\n\nprotected:\n  enum { NumParameterIndexBits = 8 };\n\n  enum DefaultArgKind {\n    DAK_None,\n    DAK_Unparsed,\n    DAK_Uninstantiated,\n    DAK_Normal\n  };\n\n  enum { NumScopeDepthOrObjCQualsBits = 7 };\n\n  class ParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ParmVarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    /// Whether this parameter inherits a default argument from a\n    /// prior declaration.\n    unsigned HasInheritedDefaultArg : 1;\n\n    /// Describes the kind of default argument for this parameter. By default\n    /// this is none. If this is normal, then the default argument is stored in\n    /// the \\c VarDecl initializer expression unless we were unable to parse\n    /// (even an invalid) expression for the default argument.\n    unsigned DefaultArgKind : 2;\n\n    /// Whether this parameter undergoes K&R argument promotion.\n    unsigned IsKNRPromoted : 1;\n\n    /// Whether this parameter is an ObjC method parameter or not.\n    unsigned IsObjCMethodParam : 1;\n\n    /// If IsObjCMethodParam, a Decl::ObjCDeclQualifier.\n    /// Otherwise, the number of function parameter scopes enclosing\n    /// the function parameter scope in which this parameter was\n    /// declared.\n    unsigned ScopeDepthOrObjCQuals : NumScopeDepthOrObjCQualsBits;\n\n    /// The number of parameters preceding this parameter in the\n    /// function parameter scope in which it was declared.\n    unsigned ParameterIndex : NumParameterIndexBits;\n  };\n\n  class NonParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ImplicitParamDecl;\n    friend class VarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    // FIXME: We need something similar to CXXRecordDecl::DefinitionData.\n    /// Whether this variable is a definition which was demoted due to\n    /// module merge.\n    unsigned IsThisDeclarationADemotedDefinition : 1;\n\n    /// Whether this variable is the exception variable in a C++ catch\n    /// or an Objective-C @catch statement.\n    unsigned ExceptionVar : 1;\n\n    /// Whether this local variable could be allocated in the return\n    /// slot of its function, enabling the named return value optimization\n    /// (NRVO).\n    unsigned NRVOVariable : 1;\n\n    /// Whether this variable is the for-range-declaration in a C++0x\n    /// for-range statement.\n    unsigned CXXForRangeDecl : 1;\n\n    /// Whether this variable is the for-in loop declaration in Objective-C.\n    unsigned ObjCForDecl : 1;\n\n    /// Whether this variable is (C++1z) inline.\n    unsigned IsInline : 1;\n\n    /// Whether this variable has (C++1z) inline explicitly specified.\n    unsigned IsInlineSpecified : 1;\n\n    /// Whether this variable is (C++0x) constexpr.\n    unsigned IsConstexpr : 1;\n\n    /// Whether this variable is the implicit variable for a lambda\n    /// init-capture.\n    unsigned IsInitCapture : 1;\n\n    /// Whether this local extern variable's previous declaration was\n    /// declared in the same block scope. This controls whether we should merge\n    /// the type of this declaration with its previous declaration.\n    unsigned PreviousDeclInSameBlockScope : 1;\n\n    /// Defines kind of the ImplicitParamDecl: 'this', 'self', 'vtt', '_cmd' or\n    /// something else.\n    unsigned ImplicitParamKind : 3;\n\n    unsigned EscapingByref : 1;\n  };\n\n  union {\n    unsigned AllBits;\n    VarDeclBitfields VarDeclBits;\n    ParmVarDeclBitfields ParmVarDeclBits;\n    NonParmVarDeclBitfields NonParmVarDeclBits;\n  };\n\n  VarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n          SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n          TypeSourceInfo *TInfo, StorageClass SC);\n\n  using redeclarable_base = Redeclarable<VarDecl>;\n\n  VarDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  VarDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  VarDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static VarDecl *Create(ASTContext &C, DeclContext *DC,\n                         SourceLocation StartLoc, SourceLocation IdLoc,\n                         IdentifierInfo *Id, QualType T, TypeSourceInfo *TInfo,\n                         StorageClass S);\n\n  static VarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return (StorageClass) VarDeclBits.SClass;\n  }\n  void setStorageClass(StorageClass SC);\n\n  void setTSCSpec(ThreadStorageClassSpecifier TSC) {\n    VarDeclBits.TSCSpec = TSC;\n    assert(VarDeclBits.TSCSpec == TSC && \"truncation\");\n  }\n  ThreadStorageClassSpecifier getTSCSpec() const {\n    return static_cast<ThreadStorageClassSpecifier>(VarDeclBits.TSCSpec);\n  }\n  TLSKind getTLSKind() const;\n\n  /// Returns true if a variable with function scope is a non-static local\n  /// variable.\n  bool hasLocalStorage() const {\n    if (getStorageClass() == SC_None) {\n      // OpenCL v1.2 s6.5.3: The __constant or constant address space name is\n      // used to describe variables allocated in global memory and which are\n      // accessed inside a kernel(s) as read-only variables. As such, variables\n      // in constant address space cannot have local storage.\n      if (getType().getAddressSpace() == LangAS::opencl_constant)\n        return false;\n      // Second check is for C++11 [dcl.stc]p4.\n      return !isFileVarDecl() && getTSCSpec() == TSCS_unspecified;\n    }\n\n    // Global Named Register (GNU extension)\n    if (getStorageClass() == SC_Register && !isLocalVarDeclOrParm())\n      return false;\n\n    // Return true for:  Auto, Register.\n    // Return false for: Extern, Static, PrivateExtern, OpenCLWorkGroupLocal.\n\n    return getStorageClass() >= SC_Auto;\n  }\n\n  /// Returns true if a variable with function scope is a static local\n  /// variable.\n  bool isStaticLocal() const {\n    return (getStorageClass() == SC_Static ||\n            // C++11 [dcl.stc]p4\n            (getStorageClass() == SC_None && getTSCSpec() == TSCS_thread_local))\n      && !isFileVarDecl();\n  }\n\n  /// Returns true if a variable has extern or __private_extern__\n  /// storage.\n  bool hasExternalStorage() const {\n    return getStorageClass() == SC_Extern ||\n           getStorageClass() == SC_PrivateExtern;\n  }\n\n  /// Returns true for all variables that do not have local storage.\n  ///\n  /// This includes all global variables as well as static variables declared\n  /// within a function.\n  bool hasGlobalStorage() const { return !hasLocalStorage(); }\n\n  /// Get the storage duration of this variable, per C++ [basic.stc].\n  StorageDuration getStorageDuration() const {\n    return hasLocalStorage() ? SD_Automatic :\n           getTSCSpec() ? SD_Thread : SD_Static;\n  }\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this variable is a variable with external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Returns true for local variable declarations other than parameters.\n  /// Note that this includes static variables inside of functions. It also\n  /// includes variables inside blocks.\n  ///\n  ///   void foo() { int x; static int y; extern int z; }\n  bool isLocalVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    if (const DeclContext *DC = getLexicalDeclContext())\n      return DC->getRedeclContext()->isFunctionOrMethod();\n    return false;\n  }\n\n  /// Similar to isLocalVarDecl but also includes parameters.\n  bool isLocalVarDeclOrParm() const {\n    return isLocalVarDecl() || getKind() == Decl::ParmVar;\n  }\n\n  /// Similar to isLocalVarDecl, but excludes variables declared in blocks.\n  bool isFunctionOrMethodVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    const DeclContext *DC = getLexicalDeclContext()->getRedeclContext();\n    return DC->isFunctionOrMethod() && DC->getDeclKind() != Decl::Block;\n  }\n\n  /// Determines whether this is a static data member.\n  ///\n  /// This will only be true in C++, and applies to, e.g., the\n  /// variable 'x' in:\n  /// \\code\n  /// struct S {\n  ///   static int x;\n  /// };\n  /// \\endcode\n  bool isStaticDataMember() const {\n    // If it wasn't static, it would be a FieldDecl.\n    return getKind() != Decl::ParmVar && getDeclContext()->isRecord();\n  }\n\n  VarDecl *getCanonicalDecl() override;\n  const VarDecl *getCanonicalDecl() const {\n    return const_cast<VarDecl*>(this)->getCanonicalDecl();\n  }\n\n  enum DefinitionKind {\n    /// This declaration is only a declaration.\n    DeclarationOnly,\n\n    /// This declaration is a tentative definition.\n    TentativeDefinition,\n\n    /// This declaration is definitely a definition.\n    Definition\n  };\n\n  /// Check whether this declaration is a definition. If this could be\n  /// a tentative definition (in C), don't check whether there's an overriding\n  /// definition.\n  DefinitionKind isThisDeclarationADefinition(ASTContext &) const;\n  DefinitionKind isThisDeclarationADefinition() const {\n    return isThisDeclarationADefinition(getASTContext());\n  }\n\n  /// Check whether this variable is defined in this translation unit.\n  DefinitionKind hasDefinition(ASTContext &) const;\n  DefinitionKind hasDefinition() const {\n    return hasDefinition(getASTContext());\n  }\n\n  /// Get the tentative definition that acts as the real definition in a TU.\n  /// Returns null if there is a proper definition available.\n  VarDecl *getActingDefinition();\n  const VarDecl *getActingDefinition() const {\n    return const_cast<VarDecl*>(this)->getActingDefinition();\n  }\n\n  /// Get the real (not just tentative) definition for this declaration.\n  VarDecl *getDefinition(ASTContext &);\n  const VarDecl *getDefinition(ASTContext &C) const {\n    return const_cast<VarDecl*>(this)->getDefinition(C);\n  }\n  VarDecl *getDefinition() {\n    return getDefinition(getASTContext());\n  }\n  const VarDecl *getDefinition() const {\n    return const_cast<VarDecl*>(this)->getDefinition();\n  }\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a static data member.\n  bool isOutOfLine() const override;\n\n  /// Returns true for file scoped variable declaration.\n  bool isFileVarDecl() const {\n    Kind K = getKind();\n    if (K == ParmVar || K == ImplicitParam)\n      return false;\n\n    if (getLexicalDeclContext()->getRedeclContext()->isFileContext())\n      return true;\n\n    if (isStaticDataMember())\n      return true;\n\n    return false;\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to.\n  const Expr *getAnyInitializer() const {\n    const VarDecl *D;\n    return getAnyInitializer(D);\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to. Also get that declaration.\n  const Expr *getAnyInitializer(const VarDecl *&D) const;\n\n  bool hasInit() const;\n  const Expr *getInit() const {\n    return const_cast<VarDecl *>(this)->getInit();\n  }\n  Expr *getInit();\n\n  /// Retrieve the address of the initializer expression.\n  Stmt **getInitAddress();\n\n  void setInit(Expr *I);\n\n  /// Get the initializing declaration of this variable, if any. This is\n  /// usually the definition, except that for a static data member it can be\n  /// the in-class declaration.\n  VarDecl *getInitializingDeclaration();\n  const VarDecl *getInitializingDeclaration() const {\n    return const_cast<VarDecl *>(this)->getInitializingDeclaration();\n  }\n\n  /// Determine whether this variable's value might be usable in a\n  /// constant expression, according to the relevant language standard.\n  /// This only checks properties of the declaration, and does not check\n  /// whether the initializer is in fact a constant expression.\n  ///\n  /// This corresponds to C++20 [expr.const]p3's notion of a\n  /// \"potentially-constant\" variable.\n  bool mightBeUsableInConstantExpressions(const ASTContext &C) const;\n\n  /// Determine whether this variable's value can be used in a\n  /// constant expression, according to the relevant language standard,\n  /// including checking whether it was initialized by a constant expression.\n  bool isUsableInConstantExpressions(const ASTContext &C) const;\n\n  EvaluatedStmt *ensureEvaluatedStmt() const;\n  EvaluatedStmt *getEvaluatedStmt() const;\n\n  /// Attempt to evaluate the value of the initializer attached to this\n  /// declaration, and produce notes explaining why it cannot be evaluated.\n  /// Returns a pointer to the value if evaluation succeeded, 0 otherwise.\n  APValue *evaluateValue() const;\n\nprivate:\n  APValue *evaluateValueImpl(SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitialization) const;\n\npublic:\n  /// Return the already-evaluated value of this variable's\n  /// initializer, or NULL if the value is not yet known. Returns pointer\n  /// to untyped APValue if the value could not be evaluated.\n  APValue *getEvaluatedValue() const;\n\n  /// Evaluate the destruction of this variable to determine if it constitutes\n  /// constant destruction.\n  ///\n  /// \\pre hasConstantInitialization()\n  /// \\return \\c true if this variable has constant destruction, \\c false if\n  ///         not.\n  bool evaluateDestruction(SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  /// Determine whether this variable has constant initialization.\n  ///\n  /// This is only set in two cases: when the language semantics require\n  /// constant initialization (globals in C and some globals in C++), and when\n  /// the variable is usable in constant expressions (constexpr, const int, and\n  /// reference variables in C++).\n  bool hasConstantInitialization() const;\n\n  /// Determine whether the initializer of this variable is an integer constant\n  /// expression. For use in C++98, where this affects whether the variable is\n  /// usable in constant expressions.\n  bool hasICEInitializer(const ASTContext &Context) const;\n\n  /// Evaluate the initializer of this variable to determine whether it's a\n  /// constant initializer. Should only be called once, after completing the\n  /// definition of the variable.\n  bool checkForConstantInitialization(\n      SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  void setInitStyle(InitializationStyle Style) {\n    VarDeclBits.InitStyle = Style;\n  }\n\n  /// The style of initialization for this declaration.\n  ///\n  /// C-style initialization is \"int x = 1;\". Call-style initialization is\n  /// a C++98 direct-initializer, e.g. \"int x(1);\". The Init expression will be\n  /// the expression inside the parens or a \"ClassType(a,b,c)\" class constructor\n  /// expression for class types. List-style initialization is C++11 syntax,\n  /// e.g. \"int x{1};\". Clients can distinguish between different forms of\n  /// initialization by checking this value. In particular, \"int x = {1};\" is\n  /// C-style, \"int x({1})\" is call-style, and \"int x{1};\" is list-style; the\n  /// Init expression in all three cases is an InitListExpr.\n  InitializationStyle getInitStyle() const {\n    return static_cast<InitializationStyle>(VarDeclBits.InitStyle);\n  }\n\n  /// Whether the initializer is a direct-initializer (list or call).\n  bool isDirectInit() const {\n    return getInitStyle() != CInit;\n  }\n\n  /// If this definition should pretend to be a declaration.\n  bool isThisDeclarationADemotedDefinition() const {\n    return isa<ParmVarDecl>(this) ? false :\n      NonParmVarDeclBits.IsThisDeclarationADemotedDefinition;\n  }\n\n  /// This is a definition which should be demoted to a declaration.\n  ///\n  /// In some cases (mostly module merging) we can end up with two visible\n  /// definitions one of which needs to be demoted to a declaration to keep\n  /// the AST invariants.\n  void demoteThisDefinitionToDeclaration() {\n    assert(isThisDeclarationADefinition() && \"Not a definition!\");\n    assert(!isa<ParmVarDecl>(this) && \"Cannot demote ParmVarDecls!\");\n    NonParmVarDeclBits.IsThisDeclarationADemotedDefinition = 1;\n  }\n\n  /// Determine whether this variable is the exception variable in a\n  /// C++ catch statememt or an Objective-C \\@catch statement.\n  bool isExceptionVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.ExceptionVar;\n  }\n  void setExceptionVariable(bool EV) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.ExceptionVar = EV;\n  }\n\n  /// Determine whether this local variable can be used with the named\n  /// return value optimization (NRVO).\n  ///\n  /// The named return value optimization (NRVO) works by marking certain\n  /// non-volatile local variables of class type as NRVO objects. These\n  /// locals can be allocated within the return slot of their containing\n  /// function, in which case there is no need to copy the object to the\n  /// return slot when returning from the function. Within the function body,\n  /// each return that returns the NRVO object will have this variable as its\n  /// NRVO candidate.\n  bool isNRVOVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.NRVOVariable;\n  }\n  void setNRVOVariable(bool NRVO) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.NRVOVariable = NRVO;\n  }\n\n  /// Determine whether this variable is the for-range-declaration in\n  /// a C++0x for-range statement.\n  bool isCXXForRangeDecl() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.CXXForRangeDecl;\n  }\n  void setCXXForRangeDecl(bool FRD) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.CXXForRangeDecl = FRD;\n  }\n\n  /// Determine whether this variable is a for-loop declaration for a\n  /// for-in statement in Objective-C.\n  bool isObjCForDecl() const {\n    return NonParmVarDeclBits.ObjCForDecl;\n  }\n\n  void setObjCForDecl(bool FRD) {\n    NonParmVarDeclBits.ObjCForDecl = FRD;\n  }\n\n  /// Determine whether this variable is an ARC pseudo-__strong variable. A\n  /// pseudo-__strong variable has a __strong-qualified type but does not\n  /// actually retain the object written into it. Generally such variables are\n  /// also 'const' for safety. There are 3 cases where this will be set, 1) if\n  /// the variable is annotated with the objc_externally_retained attribute, 2)\n  /// if its 'self' in a non-init method, or 3) if its the variable in an for-in\n  /// loop.\n  bool isARCPseudoStrong() const { return VarDeclBits.ARCPseudoStrong; }\n  void setARCPseudoStrong(bool PS) { VarDeclBits.ARCPseudoStrong = PS; }\n\n  /// Whether this variable is (C++1z) inline.\n  bool isInline() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInline;\n  }\n  bool isInlineSpecified() const {\n    return isa<ParmVarDecl>(this) ? false\n                                  : NonParmVarDeclBits.IsInlineSpecified;\n  }\n  void setInlineSpecified() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n    NonParmVarDeclBits.IsInlineSpecified = true;\n  }\n  void setImplicitlyInline() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n  }\n\n  /// Whether this variable is (C++11) constexpr.\n  bool isConstexpr() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsConstexpr;\n  }\n  void setConstexpr(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsConstexpr = IC;\n  }\n\n  /// Whether this variable is the implicit variable for a lambda init-capture.\n  bool isInitCapture() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInitCapture;\n  }\n  void setInitCapture(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInitCapture = IC;\n  }\n\n  /// Determine whether this variable is actually a function parameter pack or\n  /// init-capture pack.\n  bool isParameterPack() const;\n\n  /// Whether this local extern variable declaration's previous declaration\n  /// was declared in the same block scope. Only correct in C++.\n  bool isPreviousDeclInSameBlockScope() const {\n    return isa<ParmVarDecl>(this)\n               ? false\n               : NonParmVarDeclBits.PreviousDeclInSameBlockScope;\n  }\n  void setPreviousDeclInSameBlockScope(bool Same) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.PreviousDeclInSameBlockScope = Same;\n  }\n\n  /// Indicates the capture is a __block variable that is captured by a block\n  /// that can potentially escape (a block for which BlockDecl::doesNotEscape\n  /// returns false).\n  bool isEscapingByref() const;\n\n  /// Indicates the capture is a __block variable that is never captured by an\n  /// escaping block.\n  bool isNonEscapingByref() const;\n\n  void setEscapingByref() {\n    NonParmVarDeclBits.EscapingByref = true;\n  }\n\n  /// Retrieve the variable declaration from which this variable could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  VarDecl *getTemplateInstantiationPattern() const;\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  VarDecl *getInstantiatedFromStaticDataMember() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine what kind of\n  /// template specialization or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Get the template specialization kind of this variable for the purposes of\n  /// template instantiation. This differs from getTemplateSpecializationKind()\n  /// for an instantiation of a class-scope explicit specialization.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine its point of\n  /// instantiation.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// If this variable is an instantiation of a static data member of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// For a static data member that was instantiated from a static\n  /// data member of a class template, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Specify that this variable is an instantiation of the\n  /// static data member VD.\n  void setInstantiationOfStaticDataMember(VarDecl *VD,\n                                          TemplateSpecializationKind TSK);\n\n  /// Retrieves the variable template that is described by this\n  /// variable declaration.\n  ///\n  /// Every variable template is represented as a VarTemplateDecl and a\n  /// VarDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. VarTemplateDecl::getTemplatedDecl() retrieves the\n  /// VarDecl that from a VarTemplateDecl, while\n  /// getDescribedVarTemplate() retrieves the VarTemplateDecl from\n  /// a VarDecl.\n  VarTemplateDecl *getDescribedVarTemplate() const;\n\n  void setDescribedVarTemplate(VarTemplateDecl *Template);\n\n  // Is this variable known to have a definition somewhere in the complete\n  // program? This may be true even if the declaration has internal linkage and\n  // has no definition within this source file.\n  bool isKnownToBeDefined() const;\n\n  /// Is destruction of this variable entirely suppressed? If so, the variable\n  /// need not have a usable destructor at all.\n  bool isNoDestroy(const ASTContext &) const;\n\n  /// Would the destruction of this variable have any effect, and if so, what\n  /// kind?\n  QualType::DestructionKind needsDestruction(const ASTContext &Ctx) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstVar && K <= lastVar; }\n};\n\nclass ImplicitParamDecl : public VarDecl {\n  void anchor() override;\n\npublic:\n  /// Defines the kind of the implicit parameter: is this an implicit parameter\n  /// with pointer to 'this', 'self', '_cmd', virtual table pointers, captured\n  /// context or something else.\n  enum ImplicitParamKind : unsigned {\n    /// Parameter for Objective-C 'self' argument\n    ObjCSelf,\n\n    /// Parameter for Objective-C '_cmd' argument\n    ObjCCmd,\n\n    /// Parameter for C++ 'this' argument\n    CXXThis,\n\n    /// Parameter for C++ virtual table pointers\n    CXXVTT,\n\n    /// Parameter for captured context\n    CapturedContext,\n\n    /// Other implicit parameter\n    Other,\n  };\n\n  /// Create implicit parameter.\n  static ImplicitParamDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation IdLoc, IdentifierInfo *Id,\n                                   QualType T, ImplicitParamKind ParamKind);\n  static ImplicitParamDecl *Create(ASTContext &C, QualType T,\n                                   ImplicitParamKind ParamKind);\n\n  static ImplicitParamDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ImplicitParamDecl(ASTContext &C, DeclContext *DC, SourceLocation IdLoc,\n                    IdentifierInfo *Id, QualType Type,\n                    ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, DC, IdLoc, IdLoc, Id, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  ImplicitParamDecl(ASTContext &C, QualType Type, ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, /*DC=*/nullptr, SourceLocation(),\n                SourceLocation(), /*Id=*/nullptr, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  /// Returns the implicit parameter kind.\n  ImplicitParamKind getParameterKind() const {\n    return static_cast<ImplicitParamKind>(NonParmVarDeclBits.ImplicitParamKind);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ImplicitParam; }\n};\n\n/// Represents a parameter to a function.\nclass ParmVarDecl : public VarDecl {\npublic:\n  enum { MaxFunctionScopeDepth = 255 };\n  enum { MaxFunctionScopeIndex = 255 };\n\nprotected:\n  ParmVarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n              TypeSourceInfo *TInfo, StorageClass S, Expr *DefArg)\n      : VarDecl(DK, C, DC, StartLoc, IdLoc, Id, T, TInfo, S) {\n    assert(ParmVarDeclBits.HasInheritedDefaultArg == false);\n    assert(ParmVarDeclBits.DefaultArgKind == DAK_None);\n    assert(ParmVarDeclBits.IsKNRPromoted == false);\n    assert(ParmVarDeclBits.IsObjCMethodParam == false);\n    setDefaultArg(DefArg);\n  }\n\npublic:\n  static ParmVarDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc,\n                             SourceLocation IdLoc, IdentifierInfo *Id,\n                             QualType T, TypeSourceInfo *TInfo,\n                             StorageClass S, Expr *DefArg);\n\n  static ParmVarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void setObjCMethodScopeInfo(unsigned parameterIndex) {\n    ParmVarDeclBits.IsObjCMethodParam = true;\n    setParameterIndex(parameterIndex);\n  }\n\n  void setScopeInfo(unsigned scopeDepth, unsigned parameterIndex) {\n    assert(!ParmVarDeclBits.IsObjCMethodParam);\n\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = scopeDepth;\n    assert(ParmVarDeclBits.ScopeDepthOrObjCQuals == scopeDepth\n           && \"truncation!\");\n\n    setParameterIndex(parameterIndex);\n  }\n\n  bool isObjCMethodParameter() const {\n    return ParmVarDeclBits.IsObjCMethodParam;\n  }\n\n  /// Determines whether this parameter is destroyed in the callee function.\n  bool isDestroyedInCallee() const;\n\n  unsigned getFunctionScopeDepth() const {\n    if (ParmVarDeclBits.IsObjCMethodParam) return 0;\n    return ParmVarDeclBits.ScopeDepthOrObjCQuals;\n  }\n\n  static constexpr unsigned getMaxFunctionScopeDepth() {\n    return (1u << NumScopeDepthOrObjCQualsBits) - 1;\n  }\n\n  /// Returns the index of this parameter in its prototype or method scope.\n  unsigned getFunctionScopeIndex() const {\n    return getParameterIndex();\n  }\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    if (!ParmVarDeclBits.IsObjCMethodParam) return OBJC_TQ_None;\n    return ObjCDeclQualifier(ParmVarDeclBits.ScopeDepthOrObjCQuals);\n  }\n  void setObjCDeclQualifier(ObjCDeclQualifier QTVal) {\n    assert(ParmVarDeclBits.IsObjCMethodParam);\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = QTVal;\n  }\n\n  /// True if the value passed to this parameter must undergo\n  /// K&R-style default argument promotion:\n  ///\n  /// C99 6.5.2.2.\n  ///   If the expression that denotes the called function has a type\n  ///   that does not include a prototype, the integer promotions are\n  ///   performed on each argument, and arguments that have type float\n  ///   are promoted to double.\n  bool isKNRPromoted() const {\n    return ParmVarDeclBits.IsKNRPromoted;\n  }\n  void setKNRPromoted(bool promoted) {\n    ParmVarDeclBits.IsKNRPromoted = promoted;\n  }\n\n  Expr *getDefaultArg();\n  const Expr *getDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getDefaultArg();\n  }\n\n  void setDefaultArg(Expr *defarg);\n\n  /// Retrieve the source range that covers the entire default\n  /// argument.\n  SourceRange getDefaultArgRange() const;\n  void setUninstantiatedDefaultArg(Expr *arg);\n  Expr *getUninstantiatedDefaultArg();\n  const Expr *getUninstantiatedDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getUninstantiatedDefaultArg();\n  }\n\n  /// Determines whether this parameter has a default argument,\n  /// either parsed or not.\n  bool hasDefaultArg() const;\n\n  /// Determines whether this parameter has a default argument that has not\n  /// yet been parsed. This will occur during the processing of a C++ class\n  /// whose member functions have default arguments, e.g.,\n  /// @code\n  ///   class X {\n  ///   public:\n  ///     void f(int x = 17); // x has an unparsed default argument now\n  ///   }; // x has a regular default argument now\n  /// @endcode\n  bool hasUnparsedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Unparsed;\n  }\n\n  bool hasUninstantiatedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Uninstantiated;\n  }\n\n  /// Specify that this parameter has an unparsed default argument.\n  /// The argument will be replaced with a real default argument via\n  /// setDefaultArg when the class definition enclosing the function\n  /// declaration that owns this default argument is completed.\n  void setUnparsedDefaultArg() {\n    ParmVarDeclBits.DefaultArgKind = DAK_Unparsed;\n  }\n\n  bool hasInheritedDefaultArg() const {\n    return ParmVarDeclBits.HasInheritedDefaultArg;\n  }\n\n  void setHasInheritedDefaultArg(bool I = true) {\n    ParmVarDeclBits.HasInheritedDefaultArg = I;\n  }\n\n  QualType getOriginalType() const;\n\n  /// Sets the function declaration that owns this\n  /// ParmVarDecl. Since ParmVarDecls are often created before the\n  /// FunctionDecls that own them, this routine is required to update\n  /// the DeclContext appropriately.\n  void setOwningFunction(DeclContext *FD) { setDeclContext(FD); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ParmVar; }\n\nprivate:\n  enum { ParameterIndexSentinel = (1 << NumParameterIndexBits) - 1 };\n\n  void setParameterIndex(unsigned parameterIndex) {\n    if (parameterIndex >= ParameterIndexSentinel) {\n      setParameterIndexLarge(parameterIndex);\n      return;\n    }\n\n    ParmVarDeclBits.ParameterIndex = parameterIndex;\n    assert(ParmVarDeclBits.ParameterIndex == parameterIndex && \"truncation!\");\n  }\n  unsigned getParameterIndex() const {\n    unsigned d = ParmVarDeclBits.ParameterIndex;\n    return d == ParameterIndexSentinel ? getParameterIndexLarge() : d;\n  }\n\n  void setParameterIndexLarge(unsigned parameterIndex);\n  unsigned getParameterIndexLarge() const;\n};\n\nenum class MultiVersionKind {\n  None,\n  Target,\n  CPUSpecific,\n  CPUDispatch\n};\n\n/// Represents a function declaration or definition.\n///\n/// Since a given function can be declared several times in a program,\n/// there may be several FunctionDecls that correspond to that\n/// function. Only one of those FunctionDecls will be found when\n/// traversing the list of declarations in the context of the\n/// FunctionDecl (e.g., the translation unit); this FunctionDecl\n/// contains all of the information known about the function. Other,\n/// previous declarations of the function are available via the\n/// getPreviousDecl() chain.\nclass FunctionDecl : public DeclaratorDecl,\n                     public DeclContext,\n                     public Redeclarable<FunctionDecl> {\n  // This class stores some data in DeclContext::FunctionDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// The kind of templated function a FunctionDecl can be.\n  enum TemplatedKind {\n    // Not templated.\n    TK_NonTemplate,\n    // The pattern in a function template declaration.\n    TK_FunctionTemplate,\n    // A non-template function that is an instantiation or explicit\n    // specialization of a member of a templated class.\n    TK_MemberSpecialization,\n    // An instantiation or explicit specialization of a function template.\n    // Note: this might have been instantiated from a templated class if it\n    // is a class-scope explicit specialization.\n    TK_FunctionTemplateSpecialization,\n    // A function template specialization that hasn't yet been resolved to a\n    // particular specialized function template.\n    TK_DependentFunctionTemplateSpecialization\n  };\n\n  /// Stashed information about a defaulted function definition whose body has\n  /// not yet been lazily generated.\n  class DefaultedFunctionInfo final\n      : llvm::TrailingObjects<DefaultedFunctionInfo, DeclAccessPair> {\n    friend TrailingObjects;\n    unsigned NumLookups;\n\n  public:\n    static DefaultedFunctionInfo *Create(ASTContext &Context,\n                                         ArrayRef<DeclAccessPair> Lookups);\n    /// Get the unqualified lookup results that should be used in this\n    /// defaulted function definition.\n    ArrayRef<DeclAccessPair> getUnqualifiedLookups() const {\n      return {getTrailingObjects<DeclAccessPair>(), NumLookups};\n    }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to VarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n\n  /// The active member of this union is determined by\n  /// FunctionDeclBits.HasDefaultedFunctionInfo.\n  union {\n    /// The body of the function.\n    LazyDeclStmtPtr Body;\n    /// Information about a future defaulted function definition.\n    DefaultedFunctionInfo *DefaultedInfo;\n  };\n\n  unsigned ODRHash;\n\n  /// End part of this FunctionDecl's source range.\n  ///\n  /// We could compute the full range in getSourceRange(). However, when we're\n  /// dealing with a function definition deserialized from a PCH/AST file,\n  /// we can only compute the full range once the function body has been\n  /// de-serialized, so it's far better to have the (sometimes-redundant)\n  /// EndRangeLoc.\n  SourceLocation EndRangeLoc;\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be NULL. For function\n  /// declarations that describe a function template, this will be a\n  /// pointer to a FunctionTemplateDecl. For member functions\n  /// of class template specializations, this will be a MemberSpecializationInfo\n  /// pointer containing information about the specialization.\n  /// For function template specializations, this will be a\n  /// FunctionTemplateSpecializationInfo, which contains information about\n  /// the template being specialized and the template arguments involved in\n  /// that specialization.\n  llvm::PointerUnion<FunctionTemplateDecl *,\n                     MemberSpecializationInfo *,\n                     FunctionTemplateSpecializationInfo *,\n                     DependentFunctionTemplateSpecializationInfo *>\n    TemplateOrSpecialization;\n\n  /// Provides source/type location info for the declaration name embedded in\n  /// the DeclaratorDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param C the ASTContext.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(ASTContext &C,\n                                         FunctionTemplateDecl *Template,\n                                       const TemplateArgumentList *TemplateArgs,\n                                         void *InsertPos,\n                                         TemplateSpecializationKind TSK,\n                          const TemplateArgumentListInfo *TemplateArgsAsWritten,\n                                         SourceLocation PointOfInstantiation);\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(ASTContext &C, FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK);\n\n  void setParams(ASTContext &C, ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  // This is unfortunately needed because ASTDeclWriter::VisitFunctionDecl\n  // need to access this bit but we want to avoid making ASTDeclWriter\n  // a friend of FunctionDeclBitfields just for this.\n  bool isDeletedBit() const { return FunctionDeclBits.IsDeleted; }\n\n  /// Whether an ODRHash has been stored.\n  bool hasODRHash() const { return FunctionDeclBits.HasODRHash; }\n\n  /// State that an ODRHash has been stored.\n  void setHasODRHash(bool B = true) { FunctionDeclBits.HasODRHash = B; }\n\nprotected:\n  FunctionDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n               const DeclarationNameInfo &NameInfo, QualType T,\n               TypeSourceInfo *TInfo, StorageClass S, bool isInlineSpecified,\n               ConstexprSpecKind ConstexprKind,\n               Expr *TrailingRequiresClause = nullptr);\n\n  using redeclarable_base = Redeclarable<FunctionDecl>;\n\n  FunctionDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  FunctionDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  FunctionDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static FunctionDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation NLoc, DeclarationName N, QualType T,\n         TypeSourceInfo *TInfo, StorageClass SC, bool isInlineSpecified = false,\n         bool hasWrittenPrototype = true,\n         ConstexprSpecKind ConstexprKind = ConstexprSpecKind::Unspecified,\n         Expr *TrailingRequiresClause = nullptr) {\n    DeclarationNameInfo NameInfo(N, NLoc);\n    return FunctionDecl::Create(C, DC, StartLoc, NameInfo, T, TInfo, SC,\n                                isInlineSpecified, hasWrittenPrototype,\n                                ConstexprKind, TrailingRequiresClause);\n  }\n\n  static FunctionDecl *Create(ASTContext &C, DeclContext *DC,\n                              SourceLocation StartLoc,\n                              const DeclarationNameInfo &NameInfo, QualType T,\n                              TypeSourceInfo *TInfo, StorageClass SC,\n                              bool isInlineSpecified, bool hasWrittenPrototype,\n                              ConstexprSpecKind ConstexprKind,\n                              Expr *TrailingRequiresClause);\n\n  static FunctionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  void setRangeEnd(SourceLocation E) { EndRangeLoc = E; }\n\n  /// Returns the location of the ellipsis of a variadic function.\n  SourceLocation getEllipsisLoc() const {\n    const auto *FPT = getType()->getAs<FunctionProtoType>();\n    if (FPT && FPT->isVariadic())\n      return FPT->getEllipsisLoc();\n    return SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Function definitions.\n  //\n  // A function declaration may be:\n  // - a non defining declaration,\n  // - a definition. A function may be defined because:\n  //   - it has a body, or will have it in the case of late parsing.\n  //   - it has an uninstantiated body. The body does not exist because the\n  //     function is not used yet, but the declaration is considered a\n  //     definition and does not allow other definition of this function.\n  //   - it does not have a user specified body, but it does not allow\n  //     redefinition, because it is deleted/defaulted or is defined through\n  //     some other mechanism (alias, ifunc).\n\n  /// Returns true if the function has a body.\n  ///\n  /// The function body might be in any of the (re-)declarations of this\n  /// function. The variant that accepts a FunctionDecl pointer will set that\n  /// function declaration to the actual declaration containing the body (if\n  /// there is one).\n  bool hasBody(const FunctionDecl *&Definition) const;\n\n  bool hasBody() const override {\n    const FunctionDecl* Definition;\n    return hasBody(Definition);\n  }\n\n  /// Returns whether the function has a trivial body that does not require any\n  /// specific codegen.\n  bool hasTrivialBody() const;\n\n  /// Returns true if the function has a definition that does not need to be\n  /// instantiated.\n  ///\n  /// The variant that accepts a FunctionDecl pointer will set that function\n  /// declaration to the declaration that is a definition (if there is one).\n  ///\n  /// \\param CheckForPendingFriendDefinition If \\c true, also check for friend\n  ///        declarations that were instantiataed from function definitions.\n  ///        Such a declaration behaves as if it is a definition for the\n  ///        purpose of redefinition checking, but isn't actually a \"real\"\n  ///        definition until its body is instantiated.\n  bool isDefined(const FunctionDecl *&Definition,\n                 bool CheckForPendingFriendDefinition = false) const;\n\n  bool isDefined() const {\n    const FunctionDecl* Definition;\n    return isDefined(Definition);\n  }\n\n  /// Get the definition for this declaration.\n  FunctionDecl *getDefinition() {\n    const FunctionDecl *Definition;\n    if (isDefined(Definition))\n      return const_cast<FunctionDecl *>(Definition);\n    return nullptr;\n  }\n  const FunctionDecl *getDefinition() const {\n    return const_cast<FunctionDecl *>(this)->getDefinition();\n  }\n\n  /// Retrieve the body (definition) of the function. The function body might be\n  /// in any of the (re-)declarations of this function. The variant that accepts\n  /// a FunctionDecl pointer will set that function declaration to the actual\n  /// declaration containing the body (if there is one).\n  /// NOTE: For checking if there is a body, use hasBody() instead, to avoid\n  /// unnecessary AST de-serialization of the body.\n  Stmt *getBody(const FunctionDecl *&Definition) const;\n\n  Stmt *getBody() const override {\n    const FunctionDecl* Definition;\n    return getBody(Definition);\n  }\n\n  /// Returns whether this specific declaration of the function is also a\n  /// definition that does not contain uninstantiated body.\n  ///\n  /// This does not determine whether the function has been defined (e.g., in a\n  /// previous definition); for that information, use isDefined.\n  ///\n  /// Note: the function declaration does not become a definition until the\n  /// parser reaches the definition, if called before, this function will return\n  /// `false`.\n  bool isThisDeclarationADefinition() const {\n    return isDeletedAsWritten() || isDefaulted() ||\n           doesThisDeclarationHaveABody() || hasSkippedBody() ||\n           willHaveBody() || hasDefiningAttr();\n  }\n\n  /// Determine whether this specific declaration of the function is a friend\n  /// declaration that was instantiated from a function definition. Such\n  /// declarations behave like definitions in some contexts.\n  bool isThisDeclarationInstantiatedFromAFriendDefinition() const;\n\n  /// Returns whether this specific declaration of the function has a body.\n  bool doesThisDeclarationHaveABody() const {\n    return (!FunctionDeclBits.HasDefaultedFunctionInfo && Body) ||\n           isLateTemplateParsed();\n  }\n\n  void setBody(Stmt *B);\n  void setLazyBody(uint64_t Offset) {\n    FunctionDeclBits.HasDefaultedFunctionInfo = false;\n    Body = LazyDeclStmtPtr(Offset);\n  }\n\n  void setDefaultedFunctionInfo(DefaultedFunctionInfo *Info);\n  DefaultedFunctionInfo *getDefaultedFunctionInfo() const;\n\n  /// Whether this function is variadic.\n  bool isVariadic() const;\n\n  /// Whether this function is marked as virtual explicitly.\n  bool isVirtualAsWritten() const {\n    return FunctionDeclBits.IsVirtualAsWritten;\n  }\n\n  /// State that this function is marked as virtual explicitly.\n  void setVirtualAsWritten(bool V) { FunctionDeclBits.IsVirtualAsWritten = V; }\n\n  /// Whether this virtual function is pure, i.e. makes the containing class\n  /// abstract.\n  bool isPure() const { return FunctionDeclBits.IsPure; }\n  void setPure(bool P = true);\n\n  /// Whether this templated function will be late parsed.\n  bool isLateTemplateParsed() const {\n    return FunctionDeclBits.IsLateTemplateParsed;\n  }\n\n  /// State that this templated function will be late parsed.\n  void setLateTemplateParsed(bool ILT = true) {\n    FunctionDeclBits.IsLateTemplateParsed = ILT;\n  }\n\n  /// Whether this function is \"trivial\" in some specialized C++ senses.\n  /// Can only be true for default constructors, copy constructors,\n  /// copy assignment operators, and destructors.  Not meaningful until\n  /// the class has been fully built by Sema.\n  bool isTrivial() const { return FunctionDeclBits.IsTrivial; }\n  void setTrivial(bool IT) { FunctionDeclBits.IsTrivial = IT; }\n\n  bool isTrivialForCall() const { return FunctionDeclBits.IsTrivialForCall; }\n  void setTrivialForCall(bool IT) { FunctionDeclBits.IsTrivialForCall = IT; }\n\n  /// Whether this function is defaulted. Valid for e.g.\n  /// special member functions, defaulted comparisions (not methods!).\n  bool isDefaulted() const { return FunctionDeclBits.IsDefaulted; }\n  void setDefaulted(bool D = true) { FunctionDeclBits.IsDefaulted = D; }\n\n  /// Whether this function is explicitly defaulted.\n  bool isExplicitlyDefaulted() const {\n    return FunctionDeclBits.IsExplicitlyDefaulted;\n  }\n\n  /// State that this function is explicitly defaulted.\n  void setExplicitlyDefaulted(bool ED = true) {\n    FunctionDeclBits.IsExplicitlyDefaulted = ED;\n  }\n\n  /// True if this method is user-declared and was not\n  /// deleted or defaulted on its first declaration.\n  bool isUserProvided() const {\n    auto *DeclAsWritten = this;\n    if (FunctionDecl *Pattern = getTemplateInstantiationPattern())\n      DeclAsWritten = Pattern;\n    return !(DeclAsWritten->isDeleted() ||\n             DeclAsWritten->getCanonicalDecl()->isDefaulted());\n  }\n\n  /// Whether falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  bool hasImplicitReturnZero() const {\n    return FunctionDeclBits.HasImplicitReturnZero;\n  }\n\n  /// State that falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  void setHasImplicitReturnZero(bool IRZ) {\n    FunctionDeclBits.HasImplicitReturnZero = IRZ;\n  }\n\n  /// Whether this function has a prototype, either because one\n  /// was explicitly written or because it was \"inherited\" by merging\n  /// a declaration without a prototype with a declaration that has a\n  /// prototype.\n  bool hasPrototype() const {\n    return hasWrittenPrototype() || hasInheritedPrototype();\n  }\n\n  /// Whether this function has a written prototype.\n  bool hasWrittenPrototype() const {\n    return FunctionDeclBits.HasWrittenPrototype;\n  }\n\n  /// State that this function has a written prototype.\n  void setHasWrittenPrototype(bool P = true) {\n    FunctionDeclBits.HasWrittenPrototype = P;\n  }\n\n  /// Whether this function inherited its prototype from a\n  /// previous declaration.\n  bool hasInheritedPrototype() const {\n    return FunctionDeclBits.HasInheritedPrototype;\n  }\n\n  /// State that this function inherited its prototype from a\n  /// previous declaration.\n  void setHasInheritedPrototype(bool P = true) {\n    FunctionDeclBits.HasInheritedPrototype = P;\n  }\n\n  /// Whether this is a (C++11) constexpr function or constexpr constructor.\n  bool isConstexpr() const {\n    return getConstexprKind() != ConstexprSpecKind::Unspecified;\n  }\n  void setConstexprKind(ConstexprSpecKind CSK) {\n    FunctionDeclBits.ConstexprKind = static_cast<uint64_t>(CSK);\n  }\n  ConstexprSpecKind getConstexprKind() const {\n    return static_cast<ConstexprSpecKind>(FunctionDeclBits.ConstexprKind);\n  }\n  bool isConstexprSpecified() const {\n    return getConstexprKind() == ConstexprSpecKind::Constexpr;\n  }\n  bool isConsteval() const {\n    return getConstexprKind() == ConstexprSpecKind::Consteval;\n  }\n\n  /// Whether the instantiation of this function is pending.\n  /// This bit is set when the decision to instantiate this function is made\n  /// and unset if and when the function body is created. That leaves out\n  /// cases where instantiation did not happen because the template definition\n  /// was not seen in this TU. This bit remains set in those cases, under the\n  /// assumption that the instantiation will happen in some other TU.\n  bool instantiationIsPending() const {\n    return FunctionDeclBits.InstantiationIsPending;\n  }\n\n  /// State that the instantiation of this function is pending.\n  /// (see instantiationIsPending)\n  void setInstantiationIsPending(bool IC) {\n    FunctionDeclBits.InstantiationIsPending = IC;\n  }\n\n  /// Indicates the function uses __try.\n  bool usesSEHTry() const { return FunctionDeclBits.UsesSEHTry; }\n  void setUsesSEHTry(bool UST) { FunctionDeclBits.UsesSEHTry = UST; }\n\n  /// Whether this function has been deleted.\n  ///\n  /// A function that is \"deleted\" (via the C++0x \"= delete\" syntax)\n  /// acts like a normal function, except that it cannot actually be\n  /// called or have its address taken. Deleted functions are\n  /// typically used in C++ overload resolution to attract arguments\n  /// whose type or lvalue/rvalue-ness would permit the use of a\n  /// different overload that would behave incorrectly. For example,\n  /// one might use deleted functions to ban implicit conversion from\n  /// a floating-point number to an Integer type:\n  ///\n  /// @code\n  /// struct Integer {\n  ///   Integer(long); // construct from a long\n  ///   Integer(double) = delete; // no construction from float or double\n  ///   Integer(long double) = delete; // no construction from long double\n  /// };\n  /// @endcode\n  // If a function is deleted, its first declaration must be.\n  bool isDeleted() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsDeleted;\n  }\n\n  bool isDeletedAsWritten() const {\n    return FunctionDeclBits.IsDeleted && !isDefaulted();\n  }\n\n  void setDeletedAsWritten(bool D = true) { FunctionDeclBits.IsDeleted = D; }\n\n  /// Determines whether this function is \"main\", which is the\n  /// entry point into an executable program.\n  bool isMain() const;\n\n  /// Determines whether this function is a MSVCRT user defined entry\n  /// point.\n  bool isMSVCRTEntryPoint() const;\n\n  /// Determines whether this operator new or delete is one\n  /// of the reserved global placement operators:\n  ///    void *operator new(size_t, void *);\n  ///    void *operator new[](size_t, void *);\n  ///    void operator delete(void *, void *);\n  ///    void operator delete[](void *, void *);\n  /// These functions have special behavior under [new.delete.placement]:\n  ///    These functions are reserved, a C++ program may not define\n  ///    functions that displace the versions in the Standard C++ library.\n  ///    The provisions of [basic.stc.dynamic] do not apply to these\n  ///    reserved placement forms of operator new and operator delete.\n  ///\n  /// This function must be an allocation or deallocation function.\n  bool isReservedGlobalPlacementOperator() const;\n\n  /// Determines whether this function is one of the replaceable\n  /// global allocation functions:\n  ///    void *operator new(size_t);\n  ///    void *operator new(size_t, const std::nothrow_t &) noexcept;\n  ///    void *operator new[](size_t);\n  ///    void *operator new[](size_t, const std::nothrow_t &) noexcept;\n  ///    void operator delete(void *) noexcept;\n  ///    void operator delete(void *, std::size_t) noexcept;      [C++1y]\n  ///    void operator delete(void *, const std::nothrow_t &) noexcept;\n  ///    void operator delete[](void *) noexcept;\n  ///    void operator delete[](void *, std::size_t) noexcept;    [C++1y]\n  ///    void operator delete[](void *, const std::nothrow_t &) noexcept;\n  /// These functions have special behavior under C++1y [expr.new]:\n  ///    An implementation is allowed to omit a call to a replaceable global\n  ///    allocation function. [...]\n  ///\n  /// If this function is an aligned allocation/deallocation function, return\n  /// the parameter number of the requested alignment through AlignmentParam.\n  ///\n  /// If this function is an allocation/deallocation function that takes\n  /// the `std::nothrow_t` tag, return true through IsNothrow,\n  bool isReplaceableGlobalAllocationFunction(\n      Optional<unsigned> *AlignmentParam = nullptr,\n      bool *IsNothrow = nullptr) const;\n\n  /// Determine if this function provides an inline implementation of a builtin.\n  bool isInlineBuiltinDeclaration() const;\n\n  /// Determine whether this is a destroying operator delete.\n  bool isDestroyingOperatorDelete() const;\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this function is a function with\n  /// external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Determines whether this is a global function.\n  bool isGlobal() const;\n\n  /// Determines whether this function is known to be 'noreturn', through\n  /// an attribute on its declaration or its type.\n  bool isNoReturn() const;\n\n  /// True if the function was a definition but its body was skipped.\n  bool hasSkippedBody() const { return FunctionDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    FunctionDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if this function will eventually have a body, once it's fully parsed.\n  bool willHaveBody() const { return FunctionDeclBits.WillHaveBody; }\n  void setWillHaveBody(bool V = true) { FunctionDeclBits.WillHaveBody = V; }\n\n  /// True if this function is considered a multiversioned function.\n  bool isMultiVersion() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsMultiVersion;\n  }\n\n  /// Sets the multiversion state for this declaration and all of its\n  /// redeclarations.\n  void setIsMultiVersion(bool V = true) {\n    getCanonicalDecl()->FunctionDeclBits.IsMultiVersion = V;\n  }\n\n  /// Gets the kind of multiversioning attribute this declaration has. Note that\n  /// this can return a value even if the function is not multiversion, such as\n  /// the case of 'target'.\n  MultiVersionKind getMultiVersionKind() const;\n\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the cpu_specific/cpu_dispatch functionality.\n  bool isCPUDispatchMultiVersion() const;\n  /// True if this function is a multiversioned processor specific function as a\n  /// part of the cpu_specific/cpu_dispatch functionality.\n  bool isCPUSpecificMultiVersion() const;\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the target functionality.\n  bool isTargetMultiVersion() const;\n\n  /// \\brief Get the associated-constraints of this function declaration.\n  /// Currently, this will either be a vector of size 1 containing the\n  /// trailing-requires-clause or an empty vector.\n  ///\n  /// Use this instead of getTrailingRequiresClause for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(SmallVectorImpl<const Expr *> &AC) const {\n    if (auto *TRC = getTrailingRequiresClause())\n      AC.push_back(TRC);\n  }\n\n  void setPreviousDeclaration(FunctionDecl * PrevDecl);\n\n  FunctionDecl *getCanonicalDecl() override;\n  const FunctionDecl *getCanonicalDecl() const {\n    return const_cast<FunctionDecl*>(this)->getCanonicalDecl();\n  }\n\n  unsigned getBuiltinID(bool ConsiderWrapperFunctions = false) const;\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  /// Return the number of parameters this function must have based on its\n  /// FunctionType.  This is the length of the ParamInfo array after it has been\n  /// created.\n  unsigned getNumParams() const;\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo) {\n    setParams(getASTContext(), NewParamInfo);\n  }\n\n  /// Returns the minimum number of arguments needed to call this function. This\n  /// may be fewer than the number of function parameters, if some of the\n  /// parameters have default arguments (in C++).\n  unsigned getMinRequiredArguments() const;\n\n  /// Determine whether this function has a single parameter, or multiple\n  /// parameters where all but the first have default arguments.\n  ///\n  /// This notion is used in the definition of copy/move constructors and\n  /// initializer list constructors. Note that, unlike getMinRequiredArguments,\n  /// parameter packs are not treated specially here.\n  bool hasOneParamOrDefaultArgs() const;\n\n  /// Find the source location information for how the type of this function\n  /// was written. May be absent (for example if the function was declared via\n  /// a typedef) and may contain a different type from that of the function\n  /// (for example if the function type was adjusted by an attribute).\n  FunctionTypeLoc getFunctionTypeLoc() const;\n\n  QualType getReturnType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function return type. This may omit qualifiers and other information with\n  /// limited representation in the AST.\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Attempt to compute an informative source range covering the\n  /// function parameters, including the ellipsis of a variadic function.\n  /// The source range excludes the parentheses, and is invalid if there are\n  /// no parameters and no ellipsis.\n  SourceRange getParametersSourceRange() const;\n\n  /// Get the declared return type, which may differ from the actual return\n  /// type if the return type is deduced.\n  QualType getDeclaredReturnType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    return T->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Gets the ExceptionSpecificationType as declared.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    const auto *FPT = T->getAs<FunctionProtoType>();\n    return FPT ? FPT->getExceptionSpecType() : EST_None;\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function exception specification, if any.\n  SourceRange getExceptionSpecSourceRange() const;\n\n  /// Determine the type of an expression that calls this function.\n  QualType getCallResultType() const {\n    return getType()->castAs<FunctionType>()->getCallResultType(\n        getASTContext());\n  }\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return static_cast<StorageClass>(FunctionDeclBits.SClass);\n  }\n\n  /// Sets the storage class as written in the source.\n  void setStorageClass(StorageClass SClass) {\n    FunctionDeclBits.SClass = SClass;\n  }\n\n  /// Determine whether the \"inline\" keyword was specified for this\n  /// function.\n  bool isInlineSpecified() const { return FunctionDeclBits.IsInlineSpecified; }\n\n  /// Set whether the \"inline\" keyword was specified for this function.\n  void setInlineSpecified(bool I) {\n    FunctionDeclBits.IsInlineSpecified = I;\n    FunctionDeclBits.IsInline = I;\n  }\n\n  /// Flag that this function is implicitly inline.\n  void setImplicitlyInline(bool I = true) { FunctionDeclBits.IsInline = I; }\n\n  /// Determine whether this function should be inlined, because it is\n  /// either marked \"inline\" or \"constexpr\" or is a member function of a class\n  /// that was defined in the class body.\n  bool isInlined() const { return FunctionDeclBits.IsInline; }\n\n  bool isInlineDefinitionExternallyVisible() const;\n\n  bool isMSExternInline() const;\n\n  bool doesDeclarationForceExternallyVisibleDefinition() const;\n\n  bool isStatic() const { return getStorageClass() == SC_Static; }\n\n  /// Whether this function declaration represents an C++ overloaded\n  /// operator, e.g., \"operator+\".\n  bool isOverloadedOperator() const {\n    return getOverloadedOperator() != OO_None;\n  }\n\n  OverloadedOperatorKind getOverloadedOperator() const;\n\n  const IdentifierInfo *getLiteralIdentifier() const;\n\n  /// If this function is an instantiation of a member function\n  /// of a class template specialization, retrieves the function from\n  /// which it was instantiated.\n  ///\n  /// This routine will return non-NULL for (non-templated) member\n  /// functions of class templates and for instantiations of function\n  /// templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   void f(T);\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::f is a (non-templated) FunctionDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromFunction() will return\n  /// the FunctionDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberFunction().\n  FunctionDecl *getInstantiatedFromMemberFunction() const;\n\n  /// What kind of templated function this is.\n  TemplatedKind getTemplatedKind() const;\n\n  /// If this function is an instantiation of a member function of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberFunction(getASTContext(), FD, TSK);\n  }\n\n  /// Retrieves the function template that is described by this\n  /// function declaration.\n  ///\n  /// Every function template is represented as a FunctionTemplateDecl\n  /// and a FunctionDecl (or something derived from FunctionDecl). The\n  /// former contains template properties (such as the template\n  /// parameter lists) while the latter contains the actual\n  /// description of the template's\n  /// contents. FunctionTemplateDecl::getTemplatedDecl() retrieves the\n  /// FunctionDecl that describes the function template,\n  /// getDescribedFunctionTemplate() retrieves the\n  /// FunctionTemplateDecl from a FunctionDecl.\n  FunctionTemplateDecl *getDescribedFunctionTemplate() const;\n\n  void setDescribedFunctionTemplate(FunctionTemplateDecl *Template);\n\n  /// Determine whether this function is a function template\n  /// specialization.\n  bool isFunctionTemplateSpecialization() const {\n    return getPrimaryTemplate() != nullptr;\n  }\n\n  /// If this function is actually a function template specialization,\n  /// retrieve information about this function template specialization.\n  /// Otherwise, returns NULL.\n  FunctionTemplateSpecializationInfo *getTemplateSpecializationInfo() const;\n\n  /// Determines whether this function is a function template\n  /// specialization or a member of a class template specialization that can\n  /// be implicitly instantiated.\n  bool isImplicitlyInstantiable() const;\n\n  /// Determines if the given function was instantiated from a\n  /// function template.\n  bool isTemplateInstantiation() const;\n\n  /// Retrieve the function declaration from which this function could\n  /// be instantiated, if it is an instantiation (rather than a non-template\n  /// or a specialization, for example).\n  ///\n  /// If \\p ForDefinition is \\c false, explicit specializations will be treated\n  /// as if they were implicit instantiations. This will then find the pattern\n  /// corresponding to non-definition portions of the declaration, such as\n  /// default arguments and the exception specification.\n  FunctionDecl *\n  getTemplateInstantiationPattern(bool ForDefinition = true) const;\n\n  /// Retrieve the primary template that this function template\n  /// specialization either specializes or was instantiated from.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  FunctionTemplateDecl *getPrimaryTemplate() const;\n\n  /// Retrieve the template arguments used to produce this function\n  /// template specialization from the primary template.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  const TemplateArgumentList *getTemplateSpecializationArgs() const;\n\n  /// Retrieve the template argument list as written in the sources,\n  /// if any.\n  ///\n  /// If this function declaration is not a function template specialization\n  /// or if it had no explicit template argument list, returns NULL.\n  /// Note that it an explicit template argument list may be written empty,\n  /// e.g., template<> void foo<>(char* s);\n  const ASTTemplateArgumentListInfo*\n  getTemplateSpecializationArgsAsWritten() const;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(FunctionTemplateDecl *Template,\n                const TemplateArgumentList *TemplateArgs,\n                void *InsertPos,\n                TemplateSpecializationKind TSK = TSK_ImplicitInstantiation,\n                const TemplateArgumentListInfo *TemplateArgsAsWritten = nullptr,\n                SourceLocation PointOfInstantiation = SourceLocation()) {\n    setFunctionTemplateSpecialization(getASTContext(), Template, TemplateArgs,\n                                      InsertPos, TSK, TemplateArgsAsWritten,\n                                      PointOfInstantiation);\n  }\n\n  /// Specifies that this function declaration is actually a\n  /// dependent function template specialization.\n  void setDependentTemplateSpecialization(ASTContext &Context,\n                             const UnresolvedSetImpl &Templates,\n                      const TemplateArgumentListInfo &TemplateArgs);\n\n  DependentFunctionTemplateSpecializationInfo *\n  getDependentSpecializationInfo() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Determine the kind of template specialization this function represents\n  /// for the purpose of template instantiation.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Retrieve the (first) point of instantiation of a function template\n  /// specialization or a member of a class template specialization.\n  ///\n  /// \\returns the first point of instantiation, if this function was\n  /// instantiated from a template; otherwise, returns an invalid source\n  /// location.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a member function.\n  bool isOutOfLine() const override;\n\n  /// Identify a memory copying or setting function.\n  /// If the given function is a memory copy or setting function, returns\n  /// the corresponding Builtin ID. If the function is not a memory function,\n  /// returns 0.\n  unsigned getMemoryFunctionKind() const;\n\n  /// Returns ODRHash of the function.  This value is calculated and\n  /// stored on first call, then the stored value returned on the other calls.\n  unsigned getODRHash();\n\n  /// Returns cached ODRHash of the function.  This must have been previously\n  /// computed and stored.\n  unsigned getODRHash() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstFunction && K <= lastFunction;\n  }\n  static DeclContext *castToDeclContext(const FunctionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<FunctionDecl*>(D));\n  }\n  static FunctionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<FunctionDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a member of a struct/union/class.\nclass FieldDecl : public DeclaratorDecl, public Mergeable<FieldDecl> {\n  unsigned BitField : 1;\n  unsigned Mutable : 1;\n  mutable unsigned CachedFieldIndex : 30;\n\n  /// The kinds of value we can store in InitializerOrBitWidth.\n  ///\n  /// Note that this is compatible with InClassInitStyle except for\n  /// ISK_CapturedVLAType.\n  enum InitStorageKind {\n    /// If the pointer is null, there's nothing special.  Otherwise,\n    /// this is a bitfield and the pointer is the Expr* storing the\n    /// bit-width.\n    ISK_NoInit = (unsigned) ICIS_NoInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the copy-initializer.\n    ISK_InClassCopyInit = (unsigned) ICIS_CopyInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the list-initializer.\n    ISK_InClassListInit = (unsigned) ICIS_ListInit,\n\n    /// The pointer is a VariableArrayType* that's been captured;\n    /// the enclosing context is a lambda or captured statement.\n    ISK_CapturedVLAType,\n  };\n\n  /// If this is a bitfield with a default member initializer, this\n  /// structure is used to represent the two expressions.\n  struct InitAndBitWidth {\n    Expr *Init;\n    Expr *BitWidth;\n  };\n\n  /// Storage for either the bit-width, the in-class initializer, or\n  /// both (via InitAndBitWidth), or the captured variable length array bound.\n  ///\n  /// If the storage kind is ISK_InClassCopyInit or\n  /// ISK_InClassListInit, but the initializer is null, then this\n  /// field has an in-class initializer that has not yet been parsed\n  /// and attached.\n  // FIXME: Tail-allocate this to reduce the size of FieldDecl in the\n  // overwhelmingly common case that we have none of these things.\n  llvm::PointerIntPair<void *, 2, InitStorageKind> InitStorage;\n\nprotected:\n  FieldDecl(Kind DK, DeclContext *DC, SourceLocation StartLoc,\n            SourceLocation IdLoc, IdentifierInfo *Id,\n            QualType T, TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n            InClassInitStyle InitStyle)\n    : DeclaratorDecl(DK, DC, IdLoc, Id, T, TInfo, StartLoc),\n      BitField(false), Mutable(Mutable), CachedFieldIndex(0),\n      InitStorage(nullptr, (InitStorageKind) InitStyle) {\n    if (BW)\n      setBitWidth(BW);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static FieldDecl *Create(const ASTContext &C, DeclContext *DC,\n                           SourceLocation StartLoc, SourceLocation IdLoc,\n                           IdentifierInfo *Id, QualType T,\n                           TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n                           InClassInitStyle InitStyle);\n\n  static FieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Returns the index of this field within its record,\n  /// as appropriate for passing to ASTRecordLayout::getFieldOffset.\n  unsigned getFieldIndex() const;\n\n  /// Determines whether this field is mutable (C++ only).\n  bool isMutable() const { return Mutable; }\n\n  /// Determines whether this field is a bitfield.\n  bool isBitField() const { return BitField; }\n\n  /// Determines whether this is an unnamed bitfield.\n  bool isUnnamedBitfield() const { return isBitField() && !getDeclName(); }\n\n  /// Determines whether this field is a\n  /// representative for an anonymous struct or union. Such fields are\n  /// unnamed and are implicitly generated by the implementation to\n  /// store the data for the anonymous union or struct.\n  bool isAnonymousStructOrUnion() const;\n\n  Expr *getBitWidth() const {\n    if (!BitField)\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (getInClassInitStyle())\n      return static_cast<InitAndBitWidth*>(Ptr)->BitWidth;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  unsigned getBitWidthValue(const ASTContext &Ctx) const;\n\n  /// Set the bit-field width for this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void setBitWidth(Expr *Width) {\n    assert(!hasCapturedVLAType() && !BitField &&\n           \"bit width or captured type already set\");\n    assert(Width && \"no bit width specified\");\n    InitStorage.setPointer(\n        InitStorage.getInt()\n            ? new (getASTContext())\n                  InitAndBitWidth{getInClassInitializer(), Width}\n            : static_cast<void*>(Width));\n    BitField = true;\n  }\n\n  /// Remove the bit-field width from this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void removeBitWidth() {\n    assert(isBitField() && \"no bitfield width to remove\");\n    InitStorage.setPointer(getInClassInitializer());\n    BitField = false;\n  }\n\n  /// Is this a zero-length bit-field? Such bit-fields aren't really bit-fields\n  /// at all and instead act as a separator between contiguous runs of other\n  /// bit-fields.\n  bool isZeroLengthBitField(const ASTContext &Ctx) const;\n\n  /// Determine if this field is a subobject of zero size, that is, either a\n  /// zero-length bit-field or a field of empty class type with the\n  /// [[no_unique_address]] attribute.\n  bool isZeroSize(const ASTContext &Ctx) const;\n\n  /// Get the kind of (C++11) default member initializer that this field has.\n  InClassInitStyle getInClassInitStyle() const {\n    InitStorageKind storageKind = InitStorage.getInt();\n    return (storageKind == ISK_CapturedVLAType\n              ? ICIS_NoInit : (InClassInitStyle) storageKind);\n  }\n\n  /// Determine whether this member has a C++11 default member initializer.\n  bool hasInClassInitializer() const {\n    return getInClassInitStyle() != ICIS_NoInit;\n  }\n\n  /// Get the C++11 default member initializer for this member, or null if one\n  /// has not been set. If a valid declaration has a default member initializer,\n  /// but this returns null, then we have not parsed and attached it yet.\n  Expr *getInClassInitializer() const {\n    if (!hasInClassInitializer())\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (BitField)\n      return static_cast<InitAndBitWidth*>(Ptr)->Init;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  /// Set the C++11 in-class initializer for this member.\n  void setInClassInitializer(Expr *Init) {\n    assert(hasInClassInitializer() && !getInClassInitializer());\n    if (BitField)\n      static_cast<InitAndBitWidth*>(InitStorage.getPointer())->Init = Init;\n    else\n      InitStorage.setPointer(Init);\n  }\n\n  /// Remove the C++11 in-class initializer from this member.\n  void removeInClassInitializer() {\n    assert(hasInClassInitializer() && \"no initializer to remove\");\n    InitStorage.setPointerAndInt(getBitWidth(), ISK_NoInit);\n  }\n\n  /// Determine whether this member captures the variable length array\n  /// type.\n  bool hasCapturedVLAType() const {\n    return InitStorage.getInt() == ISK_CapturedVLAType;\n  }\n\n  /// Get the captured variable length array type.\n  const VariableArrayType *getCapturedVLAType() const {\n    return hasCapturedVLAType() ? static_cast<const VariableArrayType *>(\n                                      InitStorage.getPointer())\n                                : nullptr;\n  }\n\n  /// Set the captured variable length array type for this field.\n  void setCapturedVLAType(const VariableArrayType *VLAType);\n\n  /// Returns the parent of this field declaration, which\n  /// is the struct in which this field is defined.\n  ///\n  /// Returns null if this is not a normal class/struct field declaration, e.g.\n  /// ObjCAtDefsFieldDecl, ObjCIvarDecl.\n  const RecordDecl *getParent() const {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  RecordDecl *getParent() {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this field.\n  FieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const FieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstField && K <= lastField; }\n};\n\n/// An instance of this object exists for each enum constant\n/// that is defined.  For example, in \"enum X {a,b}\", each of a/b are\n/// EnumConstantDecl's, X is an instance of EnumDecl, and the type of a/b is a\n/// TagType for the X EnumDecl.\nclass EnumConstantDecl : public ValueDecl, public Mergeable<EnumConstantDecl> {\n  Stmt *Init; // an integer constant expression\n  llvm::APSInt Val; // The value.\n\nprotected:\n  EnumConstantDecl(DeclContext *DC, SourceLocation L,\n                   IdentifierInfo *Id, QualType T, Expr *E,\n                   const llvm::APSInt &V)\n    : ValueDecl(EnumConstant, DC, L, Id, T), Init((Stmt*)E), Val(V) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  static EnumConstantDecl *Create(ASTContext &C, EnumDecl *DC,\n                                  SourceLocation L, IdentifierInfo *Id,\n                                  QualType T, Expr *E,\n                                  const llvm::APSInt &V);\n  static EnumConstantDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  const Expr *getInitExpr() const { return (const Expr*) Init; }\n  Expr *getInitExpr() { return (Expr*) Init; }\n  const llvm::APSInt &getInitVal() const { return Val; }\n\n  void setInitExpr(Expr *E) { Init = (Stmt*) E; }\n  void setInitVal(const llvm::APSInt &V) { Val = V; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this enumerator.\n  EnumConstantDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const EnumConstantDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == EnumConstant; }\n};\n\n/// Represents a field injected from an anonymous union/struct into the parent\n/// scope. These are always implicit.\nclass IndirectFieldDecl : public ValueDecl,\n                          public Mergeable<IndirectFieldDecl> {\n  NamedDecl **Chaining;\n  unsigned ChainingSize;\n\n  IndirectFieldDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName N, QualType T,\n                    MutableArrayRef<NamedDecl *> CH);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static IndirectFieldDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L, IdentifierInfo *Id,\n                                   QualType T, llvm::MutableArrayRef<NamedDecl *> CH);\n\n  static IndirectFieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using chain_iterator = ArrayRef<NamedDecl *>::const_iterator;\n\n  ArrayRef<NamedDecl *> chain() const {\n    return llvm::makeArrayRef(Chaining, ChainingSize);\n  }\n  chain_iterator chain_begin() const { return chain().begin(); }\n  chain_iterator chain_end() const { return chain().end(); }\n\n  unsigned getChainingSize() const { return ChainingSize; }\n\n  FieldDecl *getAnonField() const {\n    assert(chain().size() >= 2);\n    return cast<FieldDecl>(chain().back());\n  }\n\n  VarDecl *getVarDecl() const {\n    assert(chain().size() >= 2);\n    return dyn_cast<VarDecl>(chain().front());\n  }\n\n  IndirectFieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const IndirectFieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == IndirectField; }\n};\n\n/// Represents a declaration of a type.\nclass TypeDecl : public NamedDecl {\n  friend class ASTContext;\n\n  /// This indicates the Type object that represents\n  /// this TypeDecl.  It is a cache maintained by\n  /// ASTContext::getTypedefType, ASTContext::getTagDeclType, and\n  /// ASTContext::getTemplateTypeParmType, and TemplateTypeParmDecl.\n  mutable const Type *TypeForDecl = nullptr;\n\n  /// The start of the source range for this declaration.\n  SourceLocation LocStart;\n\n  void anchor() override;\n\nprotected:\n  TypeDecl(Kind DK, DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n           SourceLocation StartL = SourceLocation())\n    : NamedDecl(DK, DC, L, Id), LocStart(StartL) {}\n\npublic:\n  // Low-level accessor. If you just want the type defined by this node,\n  // check out ASTContext::getTypeDeclType or one of\n  // ASTContext::getTypedefType, ASTContext::getRecordType, etc. if you\n  // already know the specific kind of node this is.\n  const Type *getTypeForDecl() const { return TypeForDecl; }\n  void setTypeForDecl(const Type *TD) { TypeForDecl = TD; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (LocStart.isValid())\n      return SourceRange(LocStart, getLocation());\n    else\n      return SourceRange(getLocation());\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstType && K <= lastType; }\n};\n\n/// Base class for declarations which introduce a typedef-name.\nclass TypedefNameDecl : public TypeDecl, public Redeclarable<TypedefNameDecl> {\n  struct alignas(8) ModedTInfo {\n    TypeSourceInfo *first;\n    QualType second;\n  };\n\n  /// If int part is 0, we have not computed IsTransparentTag.\n  /// Otherwise, IsTransparentTag is (getInt() >> 1).\n  mutable llvm::PointerIntPair<\n      llvm::PointerUnion<TypeSourceInfo *, ModedTInfo *>, 2>\n      MaybeModedTInfo;\n\n  void anchor() override;\n\nprotected:\n  TypedefNameDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                  SourceLocation StartLoc, SourceLocation IdLoc,\n                  IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypeDecl(DK, DC, IdLoc, Id, StartLoc), redeclarable_base(C),\n        MaybeModedTInfo(TInfo, 0) {}\n\n  using redeclarable_base = Redeclarable<TypedefNameDecl>;\n\n  TypedefNameDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TypedefNameDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TypedefNameDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  bool isModed() const {\n    return MaybeModedTInfo.getPointer().is<ModedTInfo *>();\n  }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->first\n                     : MaybeModedTInfo.getPointer().get<TypeSourceInfo *>();\n  }\n\n  QualType getUnderlyingType() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->second\n                     : MaybeModedTInfo.getPointer()\n                           .get<TypeSourceInfo *>()\n                           ->getType();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *newType) {\n    MaybeModedTInfo.setPointer(newType);\n  }\n\n  void setModedTypeSourceInfo(TypeSourceInfo *unmodedTSI, QualType modedTy) {\n    MaybeModedTInfo.setPointer(new (getASTContext(), 8)\n                                   ModedTInfo({unmodedTSI, modedTy}));\n  }\n\n  /// Retrieves the canonical declaration of this typedef-name.\n  TypedefNameDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const TypedefNameDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  /// Retrieves the tag declaration for which this is the typedef name for\n  /// linkage purposes, if any.\n  ///\n  /// \\param AnyRedecl Look for the tag declaration in any redeclaration of\n  /// this typedef declaration.\n  TagDecl *getAnonDeclWithTypedefName(bool AnyRedecl = false) const;\n\n  /// Determines if this typedef shares a name and spelling location with its\n  /// underlying tag type, as is the case with the NS_ENUM macro.\n  bool isTransparentTag() const {\n    if (MaybeModedTInfo.getInt())\n      return MaybeModedTInfo.getInt() & 0x2;\n    return isTransparentTagSlow();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstTypedefName && K <= lastTypedefName;\n  }\n\nprivate:\n  bool isTransparentTagSlow() const;\n};\n\n/// Represents the declaration of a typedef-name via the 'typedef'\n/// type specifier.\nclass TypedefDecl : public TypedefNameDecl {\n  TypedefDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(Typedef, C, DC, StartLoc, IdLoc, Id, TInfo) {}\n\npublic:\n  static TypedefDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc, SourceLocation IdLoc,\n                             IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypedefDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Typedef; }\n};\n\n/// Represents the declaration of a typedef-name via a C++11\n/// alias-declaration.\nclass TypeAliasDecl : public TypedefNameDecl {\n  /// The template for which this is the pattern, if any.\n  TypeAliasTemplateDecl *Template;\n\n  TypeAliasDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(TypeAlias, C, DC, StartLoc, IdLoc, Id, TInfo),\n        Template(nullptr) {}\n\npublic:\n  static TypeAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypeAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TypeAliasTemplateDecl *getDescribedAliasTemplate() const { return Template; }\n  void setDescribedAliasTemplate(TypeAliasTemplateDecl *TAT) { Template = TAT; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAlias; }\n};\n\n/// Represents the declaration of a struct/union/class/enum.\nclass TagDecl : public TypeDecl,\n                public DeclContext,\n                public Redeclarable<TagDecl> {\n  // This class stores some data in DeclContext::TagDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  // This is really ugly.\n  using TagKind = TagTypeKind;\n\nprivate:\n  SourceRange BraceRange;\n\n  // A struct representing syntactic qualifier info,\n  // to be used for the (uncommon) case of out-of-line declarations.\n  using ExtInfo = QualifierInfo;\n\n  /// If the (out-of-line) tag declaration name\n  /// is qualified, it points to the qualifier info (nns and range);\n  /// otherwise, if the tag declaration is anonymous and it is part of\n  /// a typedef or alias, it points to the TypedefNameDecl (used for mangling);\n  /// otherwise, if the tag declaration is anonymous and it is used as a\n  /// declaration specifier for variables, it points to the first VarDecl (used\n  /// for mangling);\n  /// otherwise, it is a null (TypedefNameDecl) pointer.\n  llvm::PointerUnion<TypedefNameDecl *, ExtInfo *> TypedefNameDeclOrQualifier;\n\n  bool hasExtInfo() const { return TypedefNameDeclOrQualifier.is<ExtInfo *>(); }\n  ExtInfo *getExtInfo() { return TypedefNameDeclOrQualifier.get<ExtInfo *>(); }\n  const ExtInfo *getExtInfo() const {\n    return TypedefNameDeclOrQualifier.get<ExtInfo *>();\n  }\n\nprotected:\n  TagDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n          SourceLocation L, IdentifierInfo *Id, TagDecl *PrevDecl,\n          SourceLocation StartL);\n\n  using redeclarable_base = Redeclarable<TagDecl>;\n\n  TagDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TagDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TagDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  /// Completes the definition of this tag declaration.\n  ///\n  /// This is a helper function for derived classes.\n  void completeDefinition();\n\n  /// True if this decl is currently being defined.\n  void setBeingDefined(bool V = true) { TagDeclBits.IsBeingDefined = V; }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  void setMayHaveOutOfDateDef(bool V = true) {\n    TagDeclBits.MayHaveOutOfDateDef = V;\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  SourceRange getBraceRange() const { return BraceRange; }\n  void setBraceRange(SourceRange R) { BraceRange = R; }\n\n  /// Return SourceLocation representing start of source\n  /// range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return getBeginLoc(); }\n\n  /// Return SourceLocation representing start of source\n  /// range taking into account any outer template declarations.\n  SourceLocation getOuterLocStart() const;\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TagDecl *getCanonicalDecl() override;\n  const TagDecl *getCanonicalDecl() const {\n    return const_cast<TagDecl*>(this)->getCanonicalDecl();\n  }\n\n  /// Return true if this declaration is a completion definition of the type.\n  /// Provided for consistency.\n  bool isThisDeclarationADefinition() const {\n    return isCompleteDefinition();\n  }\n\n  /// Return true if this decl has its body fully specified.\n  bool isCompleteDefinition() const { return TagDeclBits.IsCompleteDefinition; }\n\n  /// True if this decl has its body fully specified.\n  void setCompleteDefinition(bool V = true) {\n    TagDeclBits.IsCompleteDefinition = V;\n  }\n\n  /// Return true if this complete decl is\n  /// required to be complete for some existing use.\n  bool isCompleteDefinitionRequired() const {\n    return TagDeclBits.IsCompleteDefinitionRequired;\n  }\n\n  /// True if this complete decl is\n  /// required to be complete for some existing use.\n  void setCompleteDefinitionRequired(bool V = true) {\n    TagDeclBits.IsCompleteDefinitionRequired = V;\n  }\n\n  /// Return true if this decl is currently being defined.\n  bool isBeingDefined() const { return TagDeclBits.IsBeingDefined; }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  bool isEmbeddedInDeclarator() const {\n    return TagDeclBits.IsEmbeddedInDeclarator;\n  }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  void setEmbeddedInDeclarator(bool isInDeclarator) {\n    TagDeclBits.IsEmbeddedInDeclarator = isInDeclarator;\n  }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  bool isFreeStanding() const { return TagDeclBits.IsFreeStanding; }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  void setFreeStanding(bool isFreeStanding = true) {\n    TagDeclBits.IsFreeStanding = isFreeStanding;\n  }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  bool mayHaveOutOfDateDef() const { return TagDeclBits.MayHaveOutOfDateDef; }\n\n  /// Whether this declaration declares a type that is\n  /// dependent, i.e., a type that somehow depends on template\n  /// parameters.\n  bool isDependentType() const { return isDependentContext(); }\n\n  /// Starts the definition of this tag declaration.\n  ///\n  /// This method should be invoked at the beginning of the definition\n  /// of this tag declaration. It will set the tag type into a state\n  /// where it is in the process of being defined.\n  void startDefinition();\n\n  /// Returns the TagDecl that actually defines this\n  ///  struct/union/class/enum.  When determining whether or not a\n  ///  struct/union/class/enum has a definition, one should use this\n  ///  method as opposed to 'isDefinition'.  'isDefinition' indicates\n  ///  whether or not a specific TagDecl is defining declaration, not\n  ///  whether or not the struct/union/class/enum type is defined.\n  ///  This method returns NULL if there is no TagDecl that defines\n  ///  the struct/union/class/enum.\n  TagDecl *getDefinition() const;\n\n  StringRef getKindName() const {\n    return TypeWithKeyword::getTagTypeKindName(getTagKind());\n  }\n\n  TagKind getTagKind() const {\n    return static_cast<TagKind>(TagDeclBits.TagDeclKind);\n  }\n\n  void setTagKind(TagKind TK) { TagDeclBits.TagDeclKind = TK; }\n\n  bool isStruct() const { return getTagKind() == TTK_Struct; }\n  bool isInterface() const { return getTagKind() == TTK_Interface; }\n  bool isClass()  const { return getTagKind() == TTK_Class; }\n  bool isUnion()  const { return getTagKind() == TTK_Union; }\n  bool isEnum()   const { return getTagKind() == TTK_Enum; }\n\n  /// Is this tag type named, either directly or via being defined in\n  /// a typedef of this type?\n  ///\n  /// C++11 [basic.link]p8:\n  ///   A type is said to have linkage if and only if:\n  ///     - it is a class or enumeration type that is named (or has a\n  ///       name for linkage purposes) and the name has linkage; ...\n  /// C++11 [dcl.typedef]p9:\n  ///   If the typedef declaration defines an unnamed class (or enum),\n  ///   the first typedef-name declared by the declaration to be that\n  ///   class type (or enum type) is used to denote the class type (or\n  ///   enum type) for linkage purposes only.\n  ///\n  /// C does not have an analogous rule, but the same concept is\n  /// nonetheless useful in some places.\n  bool hasNameForLinkage() const {\n    return (getDeclName() || getTypedefNameForAnonDecl());\n  }\n\n  TypedefNameDecl *getTypedefNameForAnonDecl() const {\n    return hasExtInfo() ? nullptr\n                        : TypedefNameDeclOrQualifier.get<TypedefNameDecl *>();\n  }\n\n  void setTypedefNameForAnonDecl(TypedefNameDecl *TDD);\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[i];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstTag && K <= lastTag; }\n\n  static DeclContext *castToDeclContext(const TagDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TagDecl*>(D));\n  }\n\n  static TagDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TagDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an enum.  In C++11, enums can be forward-declared\n/// with a fixed underlying type, and in C we allow them to be forward-declared\n/// with no underlying type as an extension.\nclass EnumDecl : public TagDecl {\n  // This class stores some data in DeclContext::EnumDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// This represent the integer type that the enum corresponds\n  /// to for code generation purposes.  Note that the enumerator constants may\n  /// have a different type than this does.\n  ///\n  /// If the underlying integer type was explicitly stated in the source\n  /// code, this is a TypeSourceInfo* for that type. Otherwise this type\n  /// was automatically deduced somehow, and this is a Type*.\n  ///\n  /// Normally if IsFixed(), this would contain a TypeSourceInfo*, but in\n  /// some cases it won't.\n  ///\n  /// The underlying type of an enumeration never has any qualifiers, so\n  /// we can get away with just storing a raw Type*, and thus save an\n  /// extra pointer when TypeSourceInfo is needed.\n  llvm::PointerUnion<const Type *, TypeSourceInfo *> IntegerType;\n\n  /// The integer type that values of this type should\n  /// promote to.  In C, enumerators are generally of an integer type\n  /// directly, but gcc-style large enumerators (and all enumerators\n  /// in C++) are of the enum type instead.\n  QualType PromotionType;\n\n  /// If this enumeration is an instantiation of a member enumeration\n  /// of a class template specialization, this is the member specialization\n  /// information.\n  MemberSpecializationInfo *SpecializationInfo = nullptr;\n\n  /// Store the ODRHash after first calculation.\n  /// The corresponding flag HasODRHash is in EnumDeclBits\n  /// and can be accessed with the provided accessors.\n  unsigned ODRHash;\n\n  EnumDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n           SourceLocation IdLoc, IdentifierInfo *Id, EnumDecl *PrevDecl,\n           bool Scoped, bool ScopedUsingClassTag, bool Fixed);\n\n  void anchor() override;\n\n  void setInstantiationOfMemberEnum(ASTContext &C, EnumDecl *ED,\n                                    TemplateSpecializationKind TSK);\n\n  /// Sets the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  void setNumPositiveBits(unsigned Num) {\n    EnumDeclBits.NumPositiveBits = Num;\n    assert(EnumDeclBits.NumPositiveBits == Num && \"can't store this bitcount\");\n  }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum. (see getNumNegativeBits)\n  void setNumNegativeBits(unsigned Num) { EnumDeclBits.NumNegativeBits = Num; }\n\npublic:\n  /// True if this tag declaration is a scoped enumeration. Only\n  /// possible in C++11 mode.\n  void setScoped(bool Scoped = true) { EnumDeclBits.IsScoped = Scoped; }\n\n  /// If this tag declaration is a scoped enum,\n  /// then this is true if the scoped enum was declared using the class\n  /// tag, false if it was declared with the struct tag. No meaning is\n  /// associated if this tag declaration is not a scoped enum.\n  void setScopedUsingClassTag(bool ScopedUCT = true) {\n    EnumDeclBits.IsScopedUsingClassTag = ScopedUCT;\n  }\n\n  /// True if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  void setFixed(bool Fixed = true) { EnumDeclBits.IsFixed = Fixed; }\n\nprivate:\n  /// True if a valid hash is stored in ODRHash.\n  bool hasODRHash() const { return EnumDeclBits.HasODRHash; }\n  void setHasODRHash(bool Hash = true) { EnumDeclBits.HasODRHash = Hash; }\n\npublic:\n  friend class ASTDeclReader;\n\n  EnumDecl *getCanonicalDecl() override {\n    return cast<EnumDecl>(TagDecl::getCanonicalDecl());\n  }\n  const EnumDecl *getCanonicalDecl() const {\n    return const_cast<EnumDecl*>(this)->getCanonicalDecl();\n  }\n\n  EnumDecl *getPreviousDecl() {\n    return cast_or_null<EnumDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const EnumDecl *getPreviousDecl() const {\n    return const_cast<EnumDecl*>(this)->getPreviousDecl();\n  }\n\n  EnumDecl *getMostRecentDecl() {\n    return cast<EnumDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const EnumDecl *getMostRecentDecl() const {\n    return const_cast<EnumDecl*>(this)->getMostRecentDecl();\n  }\n\n  EnumDecl *getDefinition() const {\n    return cast_or_null<EnumDecl>(TagDecl::getDefinition());\n  }\n\n  static EnumDecl *Create(ASTContext &C, DeclContext *DC,\n                          SourceLocation StartLoc, SourceLocation IdLoc,\n                          IdentifierInfo *Id, EnumDecl *PrevDecl,\n                          bool IsScoped, bool IsScopedUsingClassTag,\n                          bool IsFixed);\n  static EnumDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// When created, the EnumDecl corresponds to a\n  /// forward-declared enum. This method is used to mark the\n  /// declaration as being defined; its enumerators have already been\n  /// added (via DeclContext::addDecl). NewType is the new underlying\n  /// type of the enumeration type.\n  void completeDefinition(QualType NewType,\n                          QualType PromotionType,\n                          unsigned NumPositiveBits,\n                          unsigned NumNegativeBits);\n\n  // Iterates through the enumerators of this enumeration.\n  using enumerator_iterator = specific_decl_iterator<EnumConstantDecl>;\n  using enumerator_range =\n      llvm::iterator_range<specific_decl_iterator<EnumConstantDecl>>;\n\n  enumerator_range enumerators() const {\n    return enumerator_range(enumerator_begin(), enumerator_end());\n  }\n\n  enumerator_iterator enumerator_begin() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_begin());\n  }\n\n  enumerator_iterator enumerator_end() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_end());\n  }\n\n  /// Return the integer type that enumerators should promote to.\n  QualType getPromotionType() const { return PromotionType; }\n\n  /// Set the promotion type.\n  void setPromotionType(QualType T) { PromotionType = T; }\n\n  /// Return the integer type this enum decl corresponds to.\n  /// This returns a null QualType for an enum forward definition with no fixed\n  /// underlying type.\n  QualType getIntegerType() const {\n    if (!IntegerType)\n      return QualType();\n    if (const Type *T = IntegerType.dyn_cast<const Type*>())\n      return QualType(T, 0);\n    return IntegerType.get<TypeSourceInfo*>()->getType().getUnqualifiedType();\n  }\n\n  /// Set the underlying integer type.\n  void setIntegerType(QualType T) { IntegerType = T.getTypePtrOrNull(); }\n\n  /// Set the underlying integer type source info.\n  void setIntegerTypeSourceInfo(TypeSourceInfo *TInfo) { IntegerType = TInfo; }\n\n  /// Return the type source info for the underlying integer type,\n  /// if no type source info exists, return 0.\n  TypeSourceInfo *getIntegerTypeSourceInfo() const {\n    return IntegerType.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// Retrieve the source range that covers the underlying type if\n  /// specified.\n  SourceRange getIntegerTypeRange() const LLVM_READONLY;\n\n  /// Returns the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  unsigned getNumPositiveBits() const { return EnumDeclBits.NumPositiveBits; }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum.  These widths include\n  /// the rightmost leading 1;  that is:\n  ///\n  /// MOST NEGATIVE ENUMERATOR     PATTERN     NUM NEGATIVE BITS\n  /// ------------------------     -------     -----------------\n  ///                       -1     1111111                     1\n  ///                      -10     1110110                     5\n  ///                     -101     1001011                     8\n  unsigned getNumNegativeBits() const { return EnumDeclBits.NumNegativeBits; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScoped() const { return EnumDeclBits.IsScoped; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScopedUsingClassTag() const {\n    return EnumDeclBits.IsScopedUsingClassTag;\n  }\n\n  /// Returns true if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  bool isFixed() const { return EnumDeclBits.IsFixed; }\n\n  unsigned getODRHash();\n\n  /// Returns true if this can be considered a complete type.\n  bool isComplete() const {\n    // IntegerType is set for fixed type enums and non-fixed but implicitly\n    // int-sized Microsoft enums.\n    return isCompleteDefinition() || IntegerType;\n  }\n\n  /// Returns true if this enum is either annotated with\n  /// enum_extensibility(closed) or isn't annotated with enum_extensibility.\n  bool isClosed() const;\n\n  /// Returns true if this enum is annotated with flag_enum and isn't annotated\n  /// with enum_extensibility(open).\n  bool isClosedFlag() const;\n\n  /// Returns true if this enum is annotated with neither flag_enum nor\n  /// enum_extensibility(open).\n  bool isClosedNonFlag() const;\n\n  /// Retrieve the enum definition from which this enumeration could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  EnumDecl *getTemplateInstantiationPattern() const;\n\n  /// Returns the enumeration (declared within the template)\n  /// from which this enumeration type was instantiated, or NULL if\n  /// this enumeration was not instantiated from any template.\n  EnumDecl *getInstantiatedFromMemberEnum() const;\n\n  /// If this enumeration is a member of a specialization of a\n  /// templated class, determine what kind of template specialization\n  /// or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// For an enumeration member that was instantiated from a member\n  /// enumeration of a templated class, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// If this enumeration is an instantiation of a member enumeration of\n  /// a class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const {\n    return SpecializationInfo;\n  }\n\n  /// Specify that this enumeration is an instantiation of the\n  /// member enumeration ED.\n  void setInstantiationOfMemberEnum(EnumDecl *ED,\n                                    TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberEnum(getASTContext(), ED, TSK);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Enum; }\n};\n\n/// Represents a struct/union/class.  For example:\n///   struct X;                  // Forward declaration, no \"body\".\n///   union Y { int A, B; };     // Has body with members A and B (FieldDecls).\n/// This decl will be marked invalid if *any* members are invalid.\nclass RecordDecl : public TagDecl {\n  // This class stores some data in DeclContext::RecordDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  friend class DeclContext;\n  /// Enum that represents the different ways arguments are passed to and\n  /// returned from function calls. This takes into account the target-specific\n  /// and version-specific rules along with the rules determined by the\n  /// language.\n  enum ArgPassingKind : unsigned {\n    /// The argument of this type can be passed directly in registers.\n    APK_CanPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are not forced to be passed\n    /// indirectly. This value is used only in C++. This value is required by\n    /// C++ because, in uncommon situations, it is possible for a class to have\n    /// only trivial copy/move constructors even when one of its subobjects has\n    /// a non-trivial copy/move constructor (if e.g. the corresponding copy/move\n    /// constructor in the derived class is deleted).\n    APK_CannotPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are forced to be passed\n    /// indirectly.\n    APK_CanNeverPassInRegs\n  };\n\nprotected:\n  RecordDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n             SourceLocation StartLoc, SourceLocation IdLoc,\n             IdentifierInfo *Id, RecordDecl *PrevDecl);\n\npublic:\n  static RecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                            SourceLocation StartLoc, SourceLocation IdLoc,\n                            IdentifierInfo *Id, RecordDecl* PrevDecl = nullptr);\n  static RecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  RecordDecl *getPreviousDecl() {\n    return cast_or_null<RecordDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const RecordDecl *getPreviousDecl() const {\n    return const_cast<RecordDecl*>(this)->getPreviousDecl();\n  }\n\n  RecordDecl *getMostRecentDecl() {\n    return cast<RecordDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const RecordDecl *getMostRecentDecl() const {\n    return const_cast<RecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  bool hasFlexibleArrayMember() const {\n    return RecordDeclBits.HasFlexibleArrayMember;\n  }\n\n  void setHasFlexibleArrayMember(bool V) {\n    RecordDeclBits.HasFlexibleArrayMember = V;\n  }\n\n  /// Whether this is an anonymous struct or union. To be an anonymous\n  /// struct or union, it must have been declared without a name and\n  /// there must be no objects of this type declared, e.g.,\n  /// @code\n  ///   union { int i; float f; };\n  /// @endcode\n  /// is an anonymous union but neither of the following are:\n  /// @code\n  ///  union X { int i; float f; };\n  ///  union { int i; float f; } obj;\n  /// @endcode\n  bool isAnonymousStructOrUnion() const {\n    return RecordDeclBits.AnonymousStructOrUnion;\n  }\n\n  void setAnonymousStructOrUnion(bool Anon) {\n    RecordDeclBits.AnonymousStructOrUnion = Anon;\n  }\n\n  bool hasObjectMember() const { return RecordDeclBits.HasObjectMember; }\n  void setHasObjectMember(bool val) { RecordDeclBits.HasObjectMember = val; }\n\n  bool hasVolatileMember() const { return RecordDeclBits.HasVolatileMember; }\n\n  void setHasVolatileMember(bool val) {\n    RecordDeclBits.HasVolatileMember = val;\n  }\n\n  bool hasLoadedFieldsFromExternalStorage() const {\n    return RecordDeclBits.LoadedFieldsFromExternalStorage;\n  }\n\n  void setHasLoadedFieldsFromExternalStorage(bool val) const {\n    RecordDeclBits.LoadedFieldsFromExternalStorage = val;\n  }\n\n  /// Functions to query basic properties of non-trivial C structs.\n  bool isNonTrivialToPrimitiveDefaultInitialize() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize;\n  }\n\n  void setNonTrivialToPrimitiveDefaultInitialize(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize = V;\n  }\n\n  bool isNonTrivialToPrimitiveCopy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveCopy;\n  }\n\n  void setNonTrivialToPrimitiveCopy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveCopy = V;\n  }\n\n  bool isNonTrivialToPrimitiveDestroy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDestroy;\n  }\n\n  void setNonTrivialToPrimitiveDestroy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDestroy = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDefaultInitializeCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDestructCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDestructCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveCopyCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveCopyCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion = V;\n  }\n\n  /// Determine whether this class can be passed in registers. In C++ mode,\n  /// it must have at least one trivial, non-deleted copy or move constructor.\n  /// FIXME: This should be set as part of completeDefinition.\n  bool canPassInRegisters() const {\n    return getArgPassingRestrictions() == APK_CanPassInRegs;\n  }\n\n  ArgPassingKind getArgPassingRestrictions() const {\n    return static_cast<ArgPassingKind>(RecordDeclBits.ArgPassingRestrictions);\n  }\n\n  void setArgPassingRestrictions(ArgPassingKind Kind) {\n    RecordDeclBits.ArgPassingRestrictions = Kind;\n  }\n\n  bool isParamDestroyedInCallee() const {\n    return RecordDeclBits.ParamDestroyedInCallee;\n  }\n\n  void setParamDestroyedInCallee(bool V) {\n    RecordDeclBits.ParamDestroyedInCallee = V;\n  }\n\n  /// Determines whether this declaration represents the\n  /// injected class name.\n  ///\n  /// The injected class name in C++ is the name of the class that\n  /// appears inside the class itself. For example:\n  ///\n  /// \\code\n  /// struct C {\n  ///   // C is implicitly declared here as a synonym for the class name.\n  /// };\n  ///\n  /// C::C c; // same as \"C c;\"\n  /// \\endcode\n  bool isInjectedClassName() const;\n\n  /// Determine whether this record is a class describing a lambda\n  /// function object.\n  bool isLambda() const;\n\n  /// Determine whether this record is a record for captured variables in\n  /// CapturedStmt construct.\n  bool isCapturedRecord() const;\n\n  /// Mark the record as a record for captured variables in CapturedStmt\n  /// construct.\n  void setCapturedRecord();\n\n  /// Returns the RecordDecl that actually defines\n  ///  this struct/union/class.  When determining whether or not a\n  ///  struct/union/class is completely defined, one should use this\n  ///  method as opposed to 'isCompleteDefinition'.\n  ///  'isCompleteDefinition' indicates whether or not a specific\n  ///  RecordDecl is a completed definition, not whether or not the\n  ///  record type is defined.  This method returns NULL if there is\n  ///  no RecordDecl that defines the struct/union/tag.\n  RecordDecl *getDefinition() const {\n    return cast_or_null<RecordDecl>(TagDecl::getDefinition());\n  }\n\n  /// Returns whether this record is a union, or contains (at any nesting level)\n  /// a union member. This is used by CMSE to warn about possible information\n  /// leaks.\n  bool isOrContainsUnion() const;\n\n  // Iterator access to field members. The field iterator only visits\n  // the non-static data members of this class, ignoring any static\n  // data members, functions, constructors, destructors, etc.\n  using field_iterator = specific_decl_iterator<FieldDecl>;\n  using field_range = llvm::iterator_range<specific_decl_iterator<FieldDecl>>;\n\n  field_range fields() const { return field_range(field_begin(), field_end()); }\n  field_iterator field_begin() const;\n\n  field_iterator field_end() const {\n    return field_iterator(decl_iterator());\n  }\n\n  // Whether there are any fields (non-static data members) in this record.\n  bool field_empty() const {\n    return field_begin() == field_end();\n  }\n\n  /// Note that the definition of this type is now complete.\n  virtual void completeDefinition();\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstRecord && K <= lastRecord;\n  }\n\n  /// Get whether or not this is an ms_struct which can\n  /// be turned on with an attribute, pragma, or -mms-bitfields\n  /// commandline option.\n  bool isMsStruct(const ASTContext &C) const;\n\n  /// Whether we are allowed to insert extra padding between fields.\n  /// These padding are added to help AddressSanitizer detect\n  /// intra-object-overflow bugs.\n  bool mayInsertExtraPadding(bool EmitRemark = false) const;\n\n  /// Finds the first data member which has a name.\n  /// nullptr is returned if no named data member exists.\n  const FieldDecl *findFirstNamedDataMember() const;\n\nprivate:\n  /// Deserialize just the fields.\n  void LoadFieldsFromExternalStorage() const;\n};\n\nclass FileScopeAsmDecl : public Decl {\n  StringLiteral *AsmString;\n  SourceLocation RParenLoc;\n\n  FileScopeAsmDecl(DeclContext *DC, StringLiteral *asmstring,\n                   SourceLocation StartL, SourceLocation EndL)\n    : Decl(FileScopeAsm, DC, StartL), AsmString(asmstring), RParenLoc(EndL) {}\n\n  virtual void anchor();\n\npublic:\n  static FileScopeAsmDecl *Create(ASTContext &C, DeclContext *DC,\n                                  StringLiteral *Str, SourceLocation AsmLoc,\n                                  SourceLocation RParenLoc);\n\n  static FileScopeAsmDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAsmLoc() const { return getLocation(); }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAsmLoc(), getRParenLoc());\n  }\n\n  const StringLiteral *getAsmString() const { return AsmString; }\n  StringLiteral *getAsmString() { return AsmString; }\n  void setAsmString(StringLiteral *Asm) { AsmString = Asm; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FileScopeAsm; }\n};\n\n/// Represents a block literal declaration, which is like an\n/// unnamed FunctionDecl.  For example:\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockDecl : public Decl, public DeclContext {\n  // This class stores some data in DeclContext::BlockDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// A class which contains all the information about a particular\n  /// captured value.\n  class Capture {\n    enum {\n      flag_isByRef = 0x1,\n      flag_isNested = 0x2\n    };\n\n    /// The variable being captured.\n    llvm::PointerIntPair<VarDecl*, 2> VariableAndFlags;\n\n    /// The copy expression, expressed in terms of a DeclRef (or\n    /// BlockDeclRef) to the captured variable.  Only required if the\n    /// variable has a C++ class type.\n    Expr *CopyExpr;\n\n  public:\n    Capture(VarDecl *variable, bool byRef, bool nested, Expr *copy)\n      : VariableAndFlags(variable,\n                  (byRef ? flag_isByRef : 0) | (nested ? flag_isNested : 0)),\n        CopyExpr(copy) {}\n\n    /// The variable being captured.\n    VarDecl *getVariable() const { return VariableAndFlags.getPointer(); }\n\n    /// Whether this is a \"by ref\" capture, i.e. a capture of a __block\n    /// variable.\n    bool isByRef() const { return VariableAndFlags.getInt() & flag_isByRef; }\n\n    bool isEscapingByref() const {\n      return getVariable()->isEscapingByref();\n    }\n\n    bool isNonEscapingByref() const {\n      return getVariable()->isNonEscapingByref();\n    }\n\n    /// Whether this is a nested capture, i.e. the variable captured\n    /// is not from outside the immediately enclosing function/block.\n    bool isNested() const { return VariableAndFlags.getInt() & flag_isNested; }\n\n    bool hasCopyExpr() const { return CopyExpr != nullptr; }\n    Expr *getCopyExpr() const { return CopyExpr; }\n    void setCopyExpr(Expr *e) { CopyExpr = e; }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to ParmVarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n  unsigned NumParams = 0;\n\n  Stmt *Body = nullptr;\n  TypeSourceInfo *SignatureAsWritten = nullptr;\n\n  const Capture *Captures = nullptr;\n  unsigned NumCaptures = 0;\n\n  unsigned ManglingNumber = 0;\n  Decl *ManglingContextDecl = nullptr;\n\nprotected:\n  BlockDecl(DeclContext *DC, SourceLocation CaretLoc);\n\npublic:\n  static BlockDecl *Create(ASTContext &C, DeclContext *DC, SourceLocation L);\n  static BlockDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getCaretLocation() const { return getLocation(); }\n\n  bool isVariadic() const { return BlockDeclBits.IsVariadic; }\n  void setIsVariadic(bool value) { BlockDeclBits.IsVariadic = value; }\n\n  CompoundStmt *getCompoundBody() const { return (CompoundStmt*) Body; }\n  Stmt *getBody() const override { return (Stmt*) Body; }\n  void setBody(CompoundStmt *B) { Body = (Stmt*) B; }\n\n  void setSignatureAsWritten(TypeSourceInfo *Sig) { SignatureAsWritten = Sig; }\n  TypeSourceInfo *getSignatureAsWritten() const { return SignatureAsWritten; }\n\n  // ArrayRef access to formal parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  unsigned getNumParams() const { return NumParams; }\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  /// True if this block (or its nested blocks) captures\n  /// anything of local storage from its enclosing scopes.\n  bool hasCaptures() const { return NumCaptures || capturesCXXThis(); }\n\n  /// Returns the number of captured variables.\n  /// Does not include an entry for 'this'.\n  unsigned getNumCaptures() const { return NumCaptures; }\n\n  using capture_const_iterator = ArrayRef<Capture>::const_iterator;\n\n  ArrayRef<Capture> captures() const { return {Captures, NumCaptures}; }\n\n  capture_const_iterator capture_begin() const { return captures().begin(); }\n  capture_const_iterator capture_end() const { return captures().end(); }\n\n  bool capturesCXXThis() const { return BlockDeclBits.CapturesCXXThis; }\n  void setCapturesCXXThis(bool B = true) { BlockDeclBits.CapturesCXXThis = B; }\n\n  bool blockMissingReturnType() const {\n    return BlockDeclBits.BlockMissingReturnType;\n  }\n\n  void setBlockMissingReturnType(bool val = true) {\n    BlockDeclBits.BlockMissingReturnType = val;\n  }\n\n  bool isConversionFromLambda() const {\n    return BlockDeclBits.IsConversionFromLambda;\n  }\n\n  void setIsConversionFromLambda(bool val = true) {\n    BlockDeclBits.IsConversionFromLambda = val;\n  }\n\n  bool doesNotEscape() const { return BlockDeclBits.DoesNotEscape; }\n  void setDoesNotEscape(bool B = true) { BlockDeclBits.DoesNotEscape = B; }\n\n  bool canAvoidCopyToHeap() const {\n    return BlockDeclBits.CanAvoidCopyToHeap;\n  }\n  void setCanAvoidCopyToHeap(bool B = true) {\n    BlockDeclBits.CanAvoidCopyToHeap = B;\n  }\n\n  bool capturesVariable(const VarDecl *var) const;\n\n  void setCaptures(ASTContext &Context, ArrayRef<Capture> Captures,\n                   bool CapturesCXXThis);\n\n  unsigned getBlockManglingNumber() const { return ManglingNumber; }\n\n  Decl *getBlockManglingContextDecl() const { return ManglingContextDecl; }\n\n  void setBlockMangling(unsigned Number, Decl *Ctx) {\n    ManglingNumber = Number;\n    ManglingContextDecl = Ctx;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Block; }\n  static DeclContext *castToDeclContext(const BlockDecl *D) {\n    return static_cast<DeclContext *>(const_cast<BlockDecl*>(D));\n  }\n  static BlockDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<BlockDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents the body of a CapturedStmt, and serves as its DeclContext.\nclass CapturedDecl final\n    : public Decl,\n      public DeclContext,\n      private llvm::TrailingObjects<CapturedDecl, ImplicitParamDecl *> {\nprotected:\n  size_t numTrailingObjects(OverloadToken<ImplicitParamDecl>) {\n    return NumParams;\n  }\n\nprivate:\n  /// The number of parameters to the outlined function.\n  unsigned NumParams;\n\n  /// The position of context parameter in list of parameters.\n  unsigned ContextParam;\n\n  /// The body of the outlined function.\n  llvm::PointerIntPair<Stmt *, 1, bool> BodyAndNothrow;\n\n  explicit CapturedDecl(DeclContext *DC, unsigned NumParams);\n\n  ImplicitParamDecl *const *getParams() const {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\n  ImplicitParamDecl **getParams() {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CapturedDecl *Create(ASTContext &C, DeclContext *DC,\n                              unsigned NumParams);\n  static CapturedDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                          unsigned NumParams);\n\n  Stmt *getBody() const override;\n  void setBody(Stmt *B);\n\n  bool isNothrow() const;\n  void setNothrow(bool Nothrow = true);\n\n  unsigned getNumParams() const { return NumParams; }\n\n  ImplicitParamDecl *getParam(unsigned i) const {\n    assert(i < NumParams);\n    return getParams()[i];\n  }\n  void setParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    getParams()[i] = P;\n  }\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ImplicitParamDecl *> parameters() const {\n    return {getParams(), getNumParams()};\n  }\n  MutableArrayRef<ImplicitParamDecl *> parameters() {\n    return {getParams(), getNumParams()};\n  }\n\n  /// Retrieve the parameter containing captured variables.\n  ImplicitParamDecl *getContextParam() const {\n    assert(ContextParam < NumParams);\n    return getParam(ContextParam);\n  }\n  void setContextParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    ContextParam = i;\n    setParam(i, P);\n  }\n  unsigned getContextParamPosition() const { return ContextParam; }\n\n  using param_iterator = ImplicitParamDecl *const *;\n  using param_range = llvm::iterator_range<param_iterator>;\n\n  /// Retrieve an iterator pointing to the first parameter decl.\n  param_iterator param_begin() const { return getParams(); }\n  /// Retrieve an iterator one past the last parameter decl.\n  param_iterator param_end() const { return getParams() + NumParams; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Captured; }\n  static DeclContext *castToDeclContext(const CapturedDecl *D) {\n    return static_cast<DeclContext *>(const_cast<CapturedDecl *>(D));\n  }\n  static CapturedDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<CapturedDecl *>(const_cast<DeclContext *>(DC));\n  }\n};\n\n/// Describes a module import declaration, which makes the contents\n/// of the named module visible in the current translation unit.\n///\n/// An import declaration imports the named module (or submodule). For example:\n/// \\code\n///   @import std.vector;\n/// \\endcode\n///\n/// Import declarations can also be implicitly generated from\n/// \\#include/\\#import directives.\nclass ImportDecl final : public Decl,\n                         llvm::TrailingObjects<ImportDecl, SourceLocation> {\n  friend class ASTContext;\n  friend class ASTDeclReader;\n  friend class ASTReader;\n  friend TrailingObjects;\n\n  /// The imported module.\n  Module *ImportedModule = nullptr;\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ///\n  /// Includes a bit that indicates whether we have source-location information\n  /// for each identifier in the module name.\n  ///\n  /// When the bit is false, we only have a single source location for the\n  /// end of the import declaration.\n  llvm::PointerIntPair<ImportDecl *, 1, bool> NextLocalImportAndComplete;\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             ArrayRef<SourceLocation> IdentifierLocs);\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             SourceLocation EndLoc);\n\n  ImportDecl(EmptyShell Empty) : Decl(Import, Empty) {}\n\n  bool isImportComplete() const { return NextLocalImportAndComplete.getInt(); }\n\n  void setImportComplete(bool C) { NextLocalImportAndComplete.setInt(C); }\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ImportDecl *getNextLocalImport() const {\n    return NextLocalImportAndComplete.getPointer();\n  }\n\n  void setNextLocalImport(ImportDecl *Import) {\n    NextLocalImportAndComplete.setPointer(Import);\n  }\n\npublic:\n  /// Create a new module import declaration.\n  static ImportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation StartLoc, Module *Imported,\n                            ArrayRef<SourceLocation> IdentifierLocs);\n\n  /// Create a new module import declaration for an implicitly-generated\n  /// import.\n  static ImportDecl *CreateImplicit(ASTContext &C, DeclContext *DC,\n                                    SourceLocation StartLoc, Module *Imported,\n                                    SourceLocation EndLoc);\n\n  /// Create a new, deserialized module import declaration.\n  static ImportDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                        unsigned NumLocations);\n\n  /// Retrieve the module that was imported by the import declaration.\n  Module *getImportedModule() const { return ImportedModule; }\n\n  /// Retrieves the locations of each of the identifiers that make up\n  /// the complete module name in the import declaration.\n  ///\n  /// This will return an empty array if the locations of the individual\n  /// identifiers aren't available.\n  ArrayRef<SourceLocation> getIdentifierLocs() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Import; }\n};\n\n/// Represents a C++ Modules TS module export declaration.\n///\n/// For example:\n/// \\code\n///   export void foo();\n/// \\endcode\nclass ExportDecl final : public Decl, public DeclContext {\n  virtual void anchor();\n\nprivate:\n  friend class ASTDeclReader;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  ExportDecl(DeclContext *DC, SourceLocation ExportLoc)\n      : Decl(Export, DC, ExportLoc), DeclContext(Export),\n        RBraceLoc(SourceLocation()) {}\n\npublic:\n  static ExportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation ExportLoc);\n  static ExportDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getExportLoc() const { return getLocation(); }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  bool hasBraces() const { return RBraceLoc.isValid(); }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return RBraceLoc;\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Export; }\n  static DeclContext *castToDeclContext(const ExportDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExportDecl*>(D));\n  }\n  static ExportDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExportDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an empty-declaration.\nclass EmptyDecl : public Decl {\n  EmptyDecl(DeclContext *DC, SourceLocation L) : Decl(Empty, DC, L) {}\n\n  virtual void anchor();\n\npublic:\n  static EmptyDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation L);\n  static EmptyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Empty; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending NamedDecl's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             const NamedDecl *ND) {\n  PD.AddTaggedVal(reinterpret_cast<intptr_t>(ND),\n                  DiagnosticsEngine::ak_nameddecl);\n  return PD;\n}\n\ntemplate<typename decl_type>\nvoid Redeclarable<decl_type>::setPreviousDecl(decl_type *PrevDecl) {\n  // Note: This routine is implemented here because we need both NamedDecl\n  // and Redeclarable to be defined.\n  assert(RedeclLink.isFirst() &&\n         \"setPreviousDecl on a decl already in a redeclaration chain\");\n\n  if (PrevDecl) {\n    // Point to previous. Make sure that this is actually the most recent\n    // redeclaration, or we can build invalid chains. If the most recent\n    // redeclaration is invalid, it won't be PrevDecl, but we want it anyway.\n    First = PrevDecl->getFirstDecl();\n    assert(First->RedeclLink.isFirst() && \"Expected first\");\n    decl_type *MostRecent = First->getNextRedeclaration();\n    RedeclLink = PreviousDeclLink(cast<decl_type>(MostRecent));\n\n    // If the declaration was previously visible, a redeclaration of it remains\n    // visible even if it wouldn't be visible by itself.\n    static_cast<decl_type*>(this)->IdentifierNamespace |=\n      MostRecent->getIdentifierNamespace() &\n      (Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Type);\n  } else {\n    // Make this first.\n    First = static_cast<decl_type*>(this);\n  }\n\n  // First one will point to this one as latest.\n  First->RedeclLink.setLatest(static_cast<decl_type*>(this));\n\n  assert(!isa<NamedDecl>(static_cast<decl_type*>(this)) ||\n         cast<NamedDecl>(static_cast<decl_type*>(this))->isLinkageValid());\n}\n\n// Inline function definitions.\n\n/// Check if the given decl is complete.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclComplete(EnumDecl *ED) {\n  return ED->isComplete();\n}\n\n/// Check if the given decl is scoped.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclScoped(EnumDecl *ED) {\n  return ED->isScoped();\n}\n\n/// OpenMP variants are mangled early based on their OpenMP context selector.\n/// The new name looks likes this:\n///  <name> + OpenMPVariantManglingSeparatorStr + <mangled OpenMP context>\nstatic constexpr StringRef getOpenMPVariantManglingSeparatorStr() {\n  return \"$ompvariant\";\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECL_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "content": "//===- DeclBase.h - Base Classes for representing declarations --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl and DeclContext interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLBASE_H\n#define LLVM_CLANG_AST_DECLBASE_H\n\n#include \"clang/AST/ASTDumperUtils.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PrettyStackTrace.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTMutationListener;\nclass Attr;\nclass BlockDecl;\nclass DeclContext;\nclass ExternalSourceSymbolAttr;\nclass FunctionDecl;\nclass FunctionType;\nclass IdentifierInfo;\nenum Linkage : unsigned char;\nclass LinkageSpecDecl;\nclass Module;\nclass NamedDecl;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCContainerDecl;\nclass ObjCImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCMethodDecl;\nclass ObjCProtocolDecl;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass SourceManager;\nclass Stmt;\nclass StoredDeclsMap;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass TranslationUnitDecl;\nclass UsingDirectiveDecl;\n\n/// Captures the result of checking the availability of a\n/// declaration.\nenum AvailabilityResult {\n  AR_Available = 0,\n  AR_NotYetIntroduced,\n  AR_Deprecated,\n  AR_Unavailable\n};\n\n/// Decl - This represents one declaration (or definition), e.g. a variable,\n/// typedef, function, struct, etc.\n///\n/// Note: There are objects tacked on before the *beginning* of Decl\n/// (and its subclasses) in its Decl::operator new(). Proper alignment\n/// of all subclasses (not requiring more than the alignment of Decl) is\n/// asserted in DeclBase.cpp.\nclass alignas(8) Decl {\npublic:\n  /// Lists the kind of concrete classes of Decl.\n  enum Kind {\n#define DECL(DERIVED, BASE) DERIVED,\n#define ABSTRACT_DECL(DECL)\n#define DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END,\n#define LAST_DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END\n#include \"clang/AST/DeclNodes.inc\"\n  };\n\n  /// A placeholder type used to construct an empty shell of a\n  /// decl-derived type that will be filled in later (e.g., by some\n  /// deserialization method).\n  struct EmptyShell {};\n\n  /// IdentifierNamespace - The different namespaces in which\n  /// declarations may appear.  According to C99 6.2.3, there are\n  /// four namespaces, labels, tags, members and ordinary\n  /// identifiers.  C++ describes lookup completely differently:\n  /// certain lookups merely \"ignore\" certain kinds of declarations,\n  /// usually based on whether the declaration is of a type, etc.\n  ///\n  /// These are meant as bitmasks, so that searches in\n  /// C++ can look into the \"tag\" namespace during ordinary lookup.\n  ///\n  /// Decl currently provides 15 bits of IDNS bits.\n  enum IdentifierNamespace {\n    /// Labels, declared with 'x:' and referenced with 'goto x'.\n    IDNS_Label               = 0x0001,\n\n    /// Tags, declared with 'struct foo;' and referenced with\n    /// 'struct foo'.  All tags are also types.  This is what\n    /// elaborated-type-specifiers look for in C.\n    /// This also contains names that conflict with tags in the\n    /// same scope but that are otherwise ordinary names (non-type\n    /// template parameters and indirect field declarations).\n    IDNS_Tag                 = 0x0002,\n\n    /// Types, declared with 'struct foo', typedefs, etc.\n    /// This is what elaborated-type-specifiers look for in C++,\n    /// but note that it's ill-formed to find a non-tag.\n    IDNS_Type                = 0x0004,\n\n    /// Members, declared with object declarations within tag\n    /// definitions.  In C, these can only be found by \"qualified\"\n    /// lookup in member expressions.  In C++, they're found by\n    /// normal lookup.\n    IDNS_Member              = 0x0008,\n\n    /// Namespaces, declared with 'namespace foo {}'.\n    /// Lookup for nested-name-specifiers find these.\n    IDNS_Namespace           = 0x0010,\n\n    /// Ordinary names.  In C, everything that's not a label, tag,\n    /// member, or function-local extern ends up here.\n    IDNS_Ordinary            = 0x0020,\n\n    /// Objective C \\@protocol.\n    IDNS_ObjCProtocol        = 0x0040,\n\n    /// This declaration is a friend function.  A friend function\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Ordinary if it was previously declared.\n    IDNS_OrdinaryFriend      = 0x0080,\n\n    /// This declaration is a friend class.  A friend class\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Tag|IDNS_Type if it was previously declared.\n    IDNS_TagFriend           = 0x0100,\n\n    /// This declaration is a using declaration.  A using declaration\n    /// *introduces* a number of other declarations into the current\n    /// scope, and those declarations use the IDNS of their targets,\n    /// but the actual using declarations go in this namespace.\n    IDNS_Using               = 0x0200,\n\n    /// This declaration is a C++ operator declared in a non-class\n    /// context.  All such operators are also in IDNS_Ordinary.\n    /// C++ lexical operator lookup looks for these.\n    IDNS_NonMemberOperator   = 0x0400,\n\n    /// This declaration is a function-local extern declaration of a\n    /// variable or function. This may also be IDNS_Ordinary if it\n    /// has been declared outside any function. These act mostly like\n    /// invisible friend declarations, but are also visible to unqualified\n    /// lookup within the scope of the declaring function.\n    IDNS_LocalExtern         = 0x0800,\n\n    /// This declaration is an OpenMP user defined reduction construction.\n    IDNS_OMPReduction        = 0x1000,\n\n    /// This declaration is an OpenMP user defined mapper.\n    IDNS_OMPMapper           = 0x2000,\n  };\n\n  /// ObjCDeclQualifier - 'Qualifiers' written next to the return and\n  /// parameter types in method declarations.  Other than remembering\n  /// them and mangling them into the method's signature string, these\n  /// are ignored by the compiler; they are consumed by certain\n  /// remote-messaging frameworks.\n  ///\n  /// in, inout, and out are mutually exclusive and apply only to\n  /// method parameters.  bycopy and byref are mutually exclusive and\n  /// apply only to method parameters (?).  oneway applies only to\n  /// results.  All of these expect their corresponding parameter to\n  /// have a particular type.  None of this is currently enforced by\n  /// clang.\n  ///\n  /// This should be kept in sync with ObjCDeclSpec::ObjCDeclQualifier.\n  enum ObjCDeclQualifier {\n    OBJC_TQ_None = 0x0,\n    OBJC_TQ_In = 0x1,\n    OBJC_TQ_Inout = 0x2,\n    OBJC_TQ_Out = 0x4,\n    OBJC_TQ_Bycopy = 0x8,\n    OBJC_TQ_Byref = 0x10,\n    OBJC_TQ_Oneway = 0x20,\n\n    /// The nullability qualifier is set when the nullability of the\n    /// result or parameter was expressed via a context-sensitive\n    /// keyword.\n    OBJC_TQ_CSNullability = 0x40\n  };\n\n  /// The kind of ownership a declaration has, for visibility purposes.\n  /// This enumeration is designed such that higher values represent higher\n  /// levels of name hiding.\n  enum class ModuleOwnershipKind : unsigned {\n    /// This declaration is not owned by a module.\n    Unowned,\n\n    /// This declaration has an owning module, but is globally visible\n    /// (typically because its owning module is visible and we know that\n    /// modules cannot later become hidden in this compilation).\n    /// After serialization and deserialization, this will be converted\n    /// to VisibleWhenImported.\n    Visible,\n\n    /// This declaration has an owning module, and is visible when that\n    /// module is imported.\n    VisibleWhenImported,\n\n    /// This declaration has an owning module, but is only visible to\n    /// lookups that occur within that module.\n    ModulePrivate\n  };\n\nprotected:\n  /// The next declaration within the same lexical\n  /// DeclContext. These pointers form the linked list that is\n  /// traversed via DeclContext's decls_begin()/decls_end().\n  ///\n  /// The extra two bits are used for the ModuleOwnershipKind.\n  llvm::PointerIntPair<Decl *, 2, ModuleOwnershipKind> NextInContextAndBits;\n\nprivate:\n  friend class DeclContext;\n\n  struct MultipleDC {\n    DeclContext *SemanticDC;\n    DeclContext *LexicalDC;\n  };\n\n  /// DeclCtx - Holds either a DeclContext* or a MultipleDC*.\n  /// For declarations that don't contain C++ scope specifiers, it contains\n  /// the DeclContext where the Decl was declared.\n  /// For declarations with C++ scope specifiers, it contains a MultipleDC*\n  /// with the context where it semantically belongs (SemanticDC) and the\n  /// context where it was lexically declared (LexicalDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  llvm::PointerUnion<DeclContext*, MultipleDC*> DeclCtx;\n\n  bool isInSemaDC() const { return DeclCtx.is<DeclContext*>(); }\n  bool isOutOfSemaDC() const { return DeclCtx.is<MultipleDC*>(); }\n\n  MultipleDC *getMultipleDC() const {\n    return DeclCtx.get<MultipleDC*>();\n  }\n\n  DeclContext *getSemanticDC() const {\n    return DeclCtx.get<DeclContext*>();\n  }\n\n  /// Loc - The location of this decl.\n  SourceLocation Loc;\n\n  /// DeclKind - This indicates which class this is.\n  unsigned DeclKind : 7;\n\n  /// InvalidDecl - This indicates a semantic error occurred.\n  unsigned InvalidDecl :  1;\n\n  /// HasAttrs - This indicates whether the decl has attributes or not.\n  unsigned HasAttrs : 1;\n\n  /// Implicit - Whether this declaration was implicitly generated by\n  /// the implementation rather than explicitly written by the user.\n  unsigned Implicit : 1;\n\n  /// Whether this declaration was \"used\", meaning that a definition is\n  /// required.\n  unsigned Used : 1;\n\n  /// Whether this declaration was \"referenced\".\n  /// The difference with 'Used' is whether the reference appears in a\n  /// evaluated context or not, e.g. functions used in uninstantiated templates\n  /// are regarded as \"referenced\" but not \"used\".\n  unsigned Referenced : 1;\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  unsigned TopLevelDeclInObjCContainer : 1;\n\n  /// Whether statistic collection is enabled.\n  static bool StatisticsEnabled;\n\nprotected:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class CXXClassMemberWrapper;\n  friend class LinkageComputer;\n  template<typename decl_type> friend class Redeclarable;\n\n  /// Access - Used by C++ decls for the access specifier.\n  // NOTE: VC++ treats enums as signed, avoid using the AccessSpecifier enum\n  unsigned Access : 2;\n\n  /// Whether this declaration was loaded from an AST file.\n  unsigned FromASTFile : 1;\n\n  /// IdentifierNamespace - This specifies what IDNS_* namespace this lives in.\n  unsigned IdentifierNamespace : 14;\n\n  /// If 0, we have not computed the linkage of this declaration.\n  /// Otherwise, it is the linkage + 1.\n  mutable unsigned CacheValidAndLinkage : 3;\n\n  /// Allocate memory for a deserialized declaration.\n  ///\n  /// This routine must be used to allocate memory for any declaration that is\n  /// deserialized from a module file.\n  ///\n  /// \\param Size The size of the allocated object.\n  /// \\param Ctx The context in which we will allocate memory.\n  /// \\param ID The global ID of the deserialized declaration.\n  /// \\param Extra The amount of extra space to allocate after the object.\n  void *operator new(std::size_t Size, const ASTContext &Ctx, unsigned ID,\n                     std::size_t Extra = 0);\n\n  /// Allocate memory for a non-deserialized declaration.\n  void *operator new(std::size_t Size, const ASTContext &Ctx,\n                     DeclContext *Parent, std::size_t Extra = 0);\n\nprivate:\n  bool AccessDeclContextSanity() const;\n\n  /// Get the module ownership kind to use for a local lexical child of \\p DC,\n  /// which may be either a local or (rarely) an imported declaration.\n  static ModuleOwnershipKind getModuleOwnershipKindForChildOf(DeclContext *DC) {\n    if (DC) {\n      auto *D = cast<Decl>(DC);\n      auto MOK = D->getModuleOwnershipKind();\n      if (MOK != ModuleOwnershipKind::Unowned &&\n          (!D->isFromASTFile() || D->hasLocalOwningModuleStorage()))\n        return MOK;\n      // If D is not local and we have no local module storage, then we don't\n      // need to track module ownership at all.\n    }\n    return ModuleOwnershipKind::Unowned;\n  }\n\npublic:\n  Decl() = delete;\n  Decl(const Decl&) = delete;\n  Decl(Decl &&) = delete;\n  Decl &operator=(const Decl&) = delete;\n  Decl &operator=(Decl&&) = delete;\n\nprotected:\n  Decl(Kind DK, DeclContext *DC, SourceLocation L)\n      : NextInContextAndBits(nullptr, getModuleOwnershipKindForChildOf(DC)),\n        DeclCtx(DC), Loc(L), DeclKind(DK), InvalidDecl(false), HasAttrs(false),\n        Implicit(false), Used(false), Referenced(false),\n        TopLevelDeclInObjCContainer(false), Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  Decl(Kind DK, EmptyShell Empty)\n      : DeclKind(DK), InvalidDecl(false), HasAttrs(false), Implicit(false),\n        Used(false), Referenced(false), TopLevelDeclInObjCContainer(false),\n        Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  virtual ~Decl();\n\n  /// Update a potentially out-of-date declaration.\n  void updateOutOfDate(IdentifierInfo &II) const;\n\n  Linkage getCachedLinkage() const {\n    return Linkage(CacheValidAndLinkage - 1);\n  }\n\n  void setCachedLinkage(Linkage L) const {\n    CacheValidAndLinkage = L + 1;\n  }\n\n  bool hasCachedLinkage() const {\n    return CacheValidAndLinkage;\n  }\n\npublic:\n  /// Source range that this declaration covers.\n  virtual SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getLocation(), getLocation());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSourceRange().getBegin();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSourceRange().getEnd();\n  }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  Kind getKind() const { return static_cast<Kind>(DeclKind); }\n  const char *getDeclKindName() const;\n\n  Decl *getNextDeclInContext() { return NextInContextAndBits.getPointer(); }\n  const Decl *getNextDeclInContext() const {return NextInContextAndBits.getPointer();}\n\n  DeclContext *getDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->SemanticDC;\n  }\n  const DeclContext *getDeclContext() const {\n    return const_cast<Decl*>(this)->getDeclContext();\n  }\n\n  /// Find the innermost non-closure ancestor of this declaration,\n  /// walking up through blocks, lambdas, etc.  If that ancestor is\n  /// not a code context (!isFunctionOrMethod()), returns null.\n  ///\n  /// A declaration may be its own non-closure context.\n  Decl *getNonClosureContext();\n  const Decl *getNonClosureContext() const {\n    return const_cast<Decl*>(this)->getNonClosureContext();\n  }\n\n  TranslationUnitDecl *getTranslationUnitDecl();\n  const TranslationUnitDecl *getTranslationUnitDecl() const {\n    return const_cast<Decl*>(this)->getTranslationUnitDecl();\n  }\n\n  bool isInAnonymousNamespace() const;\n\n  bool isInStdNamespace() const;\n\n  ASTContext &getASTContext() const LLVM_READONLY;\n\n  /// Helper to get the language options from the ASTContext.\n  /// Defined out of line to avoid depending on ASTContext.h.\n  const LangOptions &getLangOpts() const LLVM_READONLY;\n\n  void setAccess(AccessSpecifier AS) {\n    Access = AS;\n    assert(AccessDeclContextSanity());\n  }\n\n  AccessSpecifier getAccess() const {\n    assert(AccessDeclContextSanity());\n    return AccessSpecifier(Access);\n  }\n\n  /// Retrieve the access specifier for this declaration, even though\n  /// it may not yet have been properly set.\n  AccessSpecifier getAccessUnsafe() const {\n    return AccessSpecifier(Access);\n  }\n\n  bool hasAttrs() const { return HasAttrs; }\n\n  void setAttrs(const AttrVec& Attrs) {\n    return setAttrsImpl(Attrs, getASTContext());\n  }\n\n  AttrVec &getAttrs() {\n    return const_cast<AttrVec&>(const_cast<const Decl*>(this)->getAttrs());\n  }\n\n  const AttrVec &getAttrs() const;\n  void dropAttrs();\n  void addAttr(Attr *A);\n\n  using attr_iterator = AttrVec::const_iterator;\n  using attr_range = llvm::iterator_range<attr_iterator>;\n\n  attr_range attrs() const {\n    return attr_range(attr_begin(), attr_end());\n  }\n\n  attr_iterator attr_begin() const {\n    return hasAttrs() ? getAttrs().begin() : nullptr;\n  }\n  attr_iterator attr_end() const {\n    return hasAttrs() ? getAttrs().end() : nullptr;\n  }\n\n  template <typename T>\n  void dropAttr() {\n    if (!HasAttrs) return;\n\n    AttrVec &Vec = getAttrs();\n    llvm::erase_if(Vec, [](Attr *A) { return isa<T>(A); });\n\n    if (Vec.empty())\n      HasAttrs = false;\n  }\n\n  template <typename T>\n  llvm::iterator_range<specific_attr_iterator<T>> specific_attrs() const {\n    return llvm::make_range(specific_attr_begin<T>(), specific_attr_end<T>());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_begin() const {\n    return specific_attr_iterator<T>(attr_begin());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_end() const {\n    return specific_attr_iterator<T>(attr_end());\n  }\n\n  template<typename T> T *getAttr() const {\n    return hasAttrs() ? getSpecificAttr<T>(getAttrs()) : nullptr;\n  }\n\n  template<typename T> bool hasAttr() const {\n    return hasAttrs() && hasSpecificAttr<T>(getAttrs());\n  }\n\n  /// getMaxAlignment - return the maximum alignment specified by attributes\n  /// on this decl, 0 if there are none.\n  unsigned getMaxAlignment() const;\n\n  /// setInvalidDecl - Indicates the Decl had a semantic error. This\n  /// allows for graceful error recovery.\n  void setInvalidDecl(bool Invalid = true);\n  bool isInvalidDecl() const { return (bool) InvalidDecl; }\n\n  /// isImplicit - Indicates whether the declaration was implicitly\n  /// generated by the implementation. If false, this declaration\n  /// was written explicitly in the source code.\n  bool isImplicit() const { return Implicit; }\n  void setImplicit(bool I = true) { Implicit = I; }\n\n  /// Whether *any* (re-)declaration of the entity was used, meaning that\n  /// a definition is required.\n  ///\n  /// \\param CheckUsedAttr When true, also consider the \"used\" attribute\n  /// (in addition to the \"used\" bit set by \\c setUsed()) when determining\n  /// whether the function is used.\n  bool isUsed(bool CheckUsedAttr = true) const;\n\n  /// Set whether the declaration is used, in the sense of odr-use.\n  ///\n  /// This should only be used immediately after creating a declaration.\n  /// It intentionally doesn't notify any listeners.\n  void setIsUsed() { getCanonicalDecl()->Used = true; }\n\n  /// Mark the declaration used, in the sense of odr-use.\n  ///\n  /// This notifies any mutation listeners in addition to setting a bit\n  /// indicating the declaration is used.\n  void markUsed(ASTContext &C);\n\n  /// Whether any declaration of this entity was referenced.\n  bool isReferenced() const;\n\n  /// Whether this declaration was referenced. This should not be relied\n  /// upon for anything other than debugging.\n  bool isThisDeclarationReferenced() const { return Referenced; }\n\n  void setReferenced(bool R = true) { Referenced = R; }\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  bool isTopLevelDeclInObjCContainer() const {\n    return TopLevelDeclInObjCContainer;\n  }\n\n  void setTopLevelDeclInObjCContainer(bool V = true) {\n    TopLevelDeclInObjCContainer = V;\n  }\n\n  /// Looks on this and related declarations for an applicable\n  /// external source symbol attribute.\n  ExternalSourceSymbolAttr *getExternalSourceSymbolAttr() const;\n\n  /// Whether this declaration was marked as being private to the\n  /// module in which it was defined.\n  bool isModulePrivate() const {\n    return getModuleOwnershipKind() == ModuleOwnershipKind::ModulePrivate;\n  }\n\n  /// Return true if this declaration has an attribute which acts as\n  /// definition of the entity, such as 'alias' or 'ifunc'.\n  bool hasDefiningAttr() const;\n\n  /// Return this declaration's defining attribute if it has one.\n  const Attr *getDefiningAttr() const;\n\nprotected:\n  /// Specify that this declaration was marked as being private\n  /// to the module in which it was defined.\n  void setModulePrivate() {\n    // The module-private specifier has no effect on unowned declarations.\n    // FIXME: We should track this in some way for source fidelity.\n    if (getModuleOwnershipKind() == ModuleOwnershipKind::Unowned)\n      return;\n    setModuleOwnershipKind(ModuleOwnershipKind::ModulePrivate);\n  }\n\npublic:\n  /// Set the FromASTFile flag. This indicates that this declaration\n  /// was deserialized and not parsed from source code and enables\n  /// features such as module ownership information.\n  void setFromASTFile() {\n    FromASTFile = true;\n  }\n\n  /// Set the owning module ID.  This may only be called for\n  /// deserialized Decls.\n  void setOwningModuleID(unsigned ID) {\n    assert(isFromASTFile() && \"Only works on a deserialized declaration\");\n    *((unsigned*)this - 2) = ID;\n  }\n\npublic:\n  /// Determine the availability of the given declaration.\n  ///\n  /// This routine will determine the most restrictive availability of\n  /// the given declaration (e.g., preferring 'unavailable' to\n  /// 'deprecated').\n  ///\n  /// \\param Message If non-NULL and the result is not \\c\n  /// AR_Available, will be set to a (possibly empty) message\n  /// describing why the declaration has not been introduced, is\n  /// deprecated, or is unavailable.\n  ///\n  /// \\param EnclosingVersion The version to compare with. If empty, assume the\n  /// deployment target version.\n  ///\n  /// \\param RealizedPlatform If non-NULL and the availability result is found\n  /// in an available attribute it will set to the platform which is written in\n  /// the available attribute.\n  AvailabilityResult\n  getAvailability(std::string *Message = nullptr,\n                  VersionTuple EnclosingVersion = VersionTuple(),\n                  StringRef *RealizedPlatform = nullptr) const;\n\n  /// Retrieve the version of the target platform in which this\n  /// declaration was introduced.\n  ///\n  /// \\returns An empty version tuple if this declaration has no 'introduced'\n  /// availability attributes, or the version tuple that's specified in the\n  /// attribute otherwise.\n  VersionTuple getVersionIntroduced() const;\n\n  /// Determine whether this declaration is marked 'deprecated'.\n  ///\n  /// \\param Message If non-NULL and the declaration is deprecated,\n  /// this will be set to the message describing why the declaration\n  /// was deprecated (which may be empty).\n  bool isDeprecated(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Deprecated;\n  }\n\n  /// Determine whether this declaration is marked 'unavailable'.\n  ///\n  /// \\param Message If non-NULL and the declaration is unavailable,\n  /// this will be set to the message describing why the declaration\n  /// was made unavailable (which may be empty).\n  bool isUnavailable(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Unavailable;\n  }\n\n  /// Determine whether this is a weak-imported symbol.\n  ///\n  /// Weak-imported symbols are typically marked with the\n  /// 'weak_import' attribute, but may also be marked with an\n  /// 'availability' attribute where we're targing a platform prior to\n  /// the introduction of this feature.\n  bool isWeakImported() const;\n\n  /// Determines whether this symbol can be weak-imported,\n  /// e.g., whether it would be well-formed to add the weak_import\n  /// attribute.\n  ///\n  /// \\param IsDefinition Set to \\c true to indicate that this\n  /// declaration cannot be weak-imported because it has a definition.\n  bool canBeWeakImported(bool &IsDefinition) const;\n\n  /// Determine whether this declaration came from an AST file (such as\n  /// a precompiled header or module) rather than having been parsed.\n  bool isFromASTFile() const { return FromASTFile; }\n\n  /// Retrieve the global declaration ID associated with this\n  /// declaration, which specifies where this Decl was loaded from.\n  unsigned getGlobalID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 1);\n    return 0;\n  }\n\n  /// Retrieve the global ID of the module that owns this particular\n  /// declaration.\n  unsigned getOwningModuleID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 2);\n    return 0;\n  }\n\nprivate:\n  Module *getOwningModuleSlow() const;\n\nprotected:\n  bool hasLocalOwningModuleStorage() const;\n\npublic:\n  /// Get the imported owning module, if this decl is from an imported\n  /// (non-local) module.\n  Module *getImportedOwningModule() const {\n    if (!isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    return getOwningModuleSlow();\n  }\n\n  /// Get the local owning module, if known. Returns nullptr if owner is\n  /// not yet known or declaration is not from a module.\n  Module *getLocalOwningModule() const {\n    if (isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    assert(hasLocalOwningModuleStorage() &&\n           \"owned local decl but no local module storage\");\n    return reinterpret_cast<Module *const *>(this)[-1];\n  }\n  void setLocalOwningModule(Module *M) {\n    assert(!isFromASTFile() && hasOwningModule() &&\n           hasLocalOwningModuleStorage() &&\n           \"should not have a cached owning module\");\n    reinterpret_cast<Module **>(this)[-1] = M;\n  }\n\n  /// Is this declaration owned by some module?\n  bool hasOwningModule() const {\n    return getModuleOwnershipKind() != ModuleOwnershipKind::Unowned;\n  }\n\n  /// Get the module that owns this declaration (for visibility purposes).\n  Module *getOwningModule() const {\n    return isFromASTFile() ? getImportedOwningModule() : getLocalOwningModule();\n  }\n\n  /// Get the module that owns this declaration for linkage purposes.\n  /// There only ever is such a module under the C++ Modules TS.\n  ///\n  /// \\param IgnoreLinkage Ignore the linkage of the entity; assume that\n  /// all declarations in a global module fragment are unowned.\n  Module *getOwningModuleForLinkage(bool IgnoreLinkage = false) const;\n\n  /// Determine whether this declaration is definitely visible to name lookup,\n  /// independent of whether the owning module is visible.\n  /// Note: The declaration may be visible even if this returns \\c false if the\n  /// owning module is visible within the query context. This is a low-level\n  /// helper function; most code should be calling Sema::isVisible() instead.\n  bool isUnconditionallyVisible() const {\n    return (int)getModuleOwnershipKind() <= (int)ModuleOwnershipKind::Visible;\n  }\n\n  /// Set that this declaration is globally visible, even if it came from a\n  /// module that is not visible.\n  void setVisibleDespiteOwningModule() {\n    if (!isUnconditionallyVisible())\n      setModuleOwnershipKind(ModuleOwnershipKind::Visible);\n  }\n\n  /// Get the kind of module ownership for this declaration.\n  ModuleOwnershipKind getModuleOwnershipKind() const {\n    return NextInContextAndBits.getInt();\n  }\n\n  /// Set whether this declaration is hidden from name lookup.\n  void setModuleOwnershipKind(ModuleOwnershipKind MOK) {\n    assert(!(getModuleOwnershipKind() == ModuleOwnershipKind::Unowned &&\n             MOK != ModuleOwnershipKind::Unowned && !isFromASTFile() &&\n             !hasLocalOwningModuleStorage()) &&\n           \"no storage available for owning module for this declaration\");\n    NextInContextAndBits.setInt(MOK);\n  }\n\n  unsigned getIdentifierNamespace() const {\n    return IdentifierNamespace;\n  }\n\n  bool isInIdentifierNamespace(unsigned NS) const {\n    return getIdentifierNamespace() & NS;\n  }\n\n  static unsigned getIdentifierNamespaceForKind(Kind DK);\n\n  bool hasTagIdentifierNamespace() const {\n    return isTagIdentifierNamespace(getIdentifierNamespace());\n  }\n\n  static bool isTagIdentifierNamespace(unsigned NS) {\n    // TagDecls have Tag and Type set and may also have TagFriend.\n    return (NS & ~IDNS_TagFriend) == (IDNS_Tag | IDNS_Type);\n  }\n\n  /// getLexicalDeclContext - The declaration context where this Decl was\n  /// lexically declared (LexicalDC). May be different from\n  /// getDeclContext() (SemanticDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  DeclContext *getLexicalDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->LexicalDC;\n  }\n  const DeclContext *getLexicalDeclContext() const {\n    return const_cast<Decl*>(this)->getLexicalDeclContext();\n  }\n\n  /// Determine whether this declaration is declared out of line (outside its\n  /// semantic context).\n  virtual bool isOutOfLine() const;\n\n  /// setDeclContext - Set both the semantic and lexical DeclContext\n  /// to DC.\n  void setDeclContext(DeclContext *DC);\n\n  void setLexicalDeclContext(DeclContext *DC);\n\n  /// Determine whether this declaration is a templated entity (whether it is\n  // within the scope of a template parameter).\n  bool isTemplated() const;\n\n  /// Determine the number of levels of template parameter surrounding this\n  /// declaration.\n  unsigned getTemplateDepth() const;\n\n  /// isDefinedOutsideFunctionOrMethod - This predicate returns true if this\n  /// scoped decl is defined outside the current function or method.  This is\n  /// roughly global variables and functions, but also handles enums (which\n  /// could be defined inside or outside a function etc).\n  bool isDefinedOutsideFunctionOrMethod() const {\n    return getParentFunctionOrMethod() == nullptr;\n  }\n\n  /// Determine whether a substitution into this declaration would occur as\n  /// part of a substitution into a dependent local scope. Such a substitution\n  /// transitively substitutes into all constructs nested within this\n  /// declaration.\n  ///\n  /// This recognizes non-defining declarations as well as members of local\n  /// classes and lambdas:\n  /// \\code\n  ///     template<typename T> void foo() { void bar(); }\n  ///     template<typename T> void foo2() { class ABC { void bar(); }; }\n  ///     template<typename T> inline int x = [](){ return 0; }();\n  /// \\endcode\n  bool isInLocalScopeForInstantiation() const;\n\n  /// If this decl is defined inside a function/method/block it returns\n  /// the corresponding DeclContext, otherwise it returns null.\n  const DeclContext *getParentFunctionOrMethod() const;\n  DeclContext *getParentFunctionOrMethod() {\n    return const_cast<DeclContext*>(\n                    const_cast<const Decl*>(this)->getParentFunctionOrMethod());\n  }\n\n  /// Retrieves the \"canonical\" declaration of the given declaration.\n  virtual Decl *getCanonicalDecl() { return this; }\n  const Decl *getCanonicalDecl() const {\n    return const_cast<Decl*>(this)->getCanonicalDecl();\n  }\n\n  /// Whether this particular Decl is a canonical one.\n  bool isCanonicalDecl() const { return getCanonicalDecl() == this; }\n\nprotected:\n  /// Returns the next redeclaration or itself if this is the only decl.\n  ///\n  /// Decl subclasses that can be redeclared should override this method so that\n  /// Decl::redecl_iterator can iterate over them.\n  virtual Decl *getNextRedeclarationImpl() { return this; }\n\n  /// Implementation of getPreviousDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getPreviousDeclImpl() { return nullptr; }\n\n  /// Implementation of getMostRecentDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getMostRecentDeclImpl() { return this; }\n\npublic:\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n    Decl *Starter;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(Decl *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    value_type operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Get either previous decl or latest decl.\n      Decl *Next = Current->getNextRedeclarationImpl();\n      assert(Next && \"Should return next redeclaration or itself, never null!\");\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecls_begin(), redecls_end());\n  }\n\n  redecl_iterator redecls_begin() const {\n    return redecl_iterator(const_cast<Decl *>(this));\n  }\n\n  redecl_iterator redecls_end() const { return redecl_iterator(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  Decl *getPreviousDecl() { return getPreviousDeclImpl(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  const Decl *getPreviousDecl() const {\n    return const_cast<Decl *>(this)->getPreviousDeclImpl();\n  }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const {\n    return getPreviousDecl() == nullptr;\n  }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  Decl *getMostRecentDecl() { return getMostRecentDeclImpl(); }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  const Decl *getMostRecentDecl() const {\n    return const_cast<Decl *>(this)->getMostRecentDeclImpl();\n  }\n\n  /// getBody - If this Decl represents a declaration for a body of code,\n  ///  such as a function or method definition, this method returns the\n  ///  top-level Stmt* of that body.  Otherwise this method returns null.\n  virtual Stmt* getBody() const { return nullptr; }\n\n  /// Returns true if this \\c Decl represents a declaration for a body of\n  /// code, such as a function or method definition.\n  /// Note that \\c hasBody can also return true if any redeclaration of this\n  /// \\c Decl represents a declaration for a body of code.\n  virtual bool hasBody() const { return getBody() != nullptr; }\n\n  /// getBodyRBrace - Gets the right brace of the body, if a body exists.\n  /// This works whether the body is a CompoundStmt or a CXXTryStmt.\n  SourceLocation getBodyRBrace() const;\n\n  // global temp stats (until we have a per-module visitor)\n  static void add(Kind k);\n  static void EnableStatistics();\n  static void PrintStats();\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter.\n  bool isTemplateParameter() const;\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter pack.\n  bool isTemplateParameterPack() const;\n\n  /// Whether this declaration is a parameter pack.\n  bool isParameterPack() const;\n\n  /// returns true if this declaration is a template\n  bool isTemplateDecl() const;\n\n  /// Whether this declaration is a function or function template.\n  bool isFunctionOrFunctionTemplate() const {\n    return (DeclKind >= Decl::firstFunction &&\n            DeclKind <= Decl::lastFunction) ||\n           DeclKind == FunctionTemplate;\n  }\n\n  /// If this is a declaration that describes some template, this\n  /// method returns that template declaration.\n  ///\n  /// Note that this returns nullptr for partial specializations, because they\n  /// are not modeled as TemplateDecls. Use getDescribedTemplateParams to handle\n  /// those cases.\n  TemplateDecl *getDescribedTemplate() const;\n\n  /// If this is a declaration that describes some template or partial\n  /// specialization, this returns the corresponding template parameter list.\n  const TemplateParameterList *getDescribedTemplateParams() const;\n\n  /// Returns the function itself, or the templated function if this is a\n  /// function template.\n  FunctionDecl *getAsFunction() LLVM_READONLY;\n\n  const FunctionDecl *getAsFunction() const {\n    return const_cast<Decl *>(this)->getAsFunction();\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// a function-local extern declaration.\n  ///\n  /// These declarations appear in the lexical context of the extern\n  /// declaration, but in the semantic context of the enclosing namespace\n  /// scope.\n  void setLocalExternDecl() {\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~IDNS_Ordinary;\n\n    // It's OK for the declaration to still have the \"invisible friend\" flag or\n    // the \"conflicts with tag declarations in this scope\" flag for the outer\n    // scope.\n    assert((IdentifierNamespace & ~(IDNS_OrdinaryFriend | IDNS_Tag)) == 0 &&\n           \"namespace is not ordinary\");\n\n    IdentifierNamespace |= IDNS_LocalExtern;\n    if (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary)\n      IdentifierNamespace |= IDNS_Ordinary;\n  }\n\n  /// Determine whether this is a block-scope declaration with linkage.\n  /// This will either be a local variable declaration declared 'extern', or a\n  /// local function declaration.\n  bool isLocalExternDecl() {\n    return IdentifierNamespace & IDNS_LocalExtern;\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// the object of a friend declaration.\n  ///\n  /// These declarations appear in the lexical context of the friending\n  /// class, but in the semantic context of the actual entity.  This property\n  /// applies only to a specific decl object;  other redeclarations of the\n  /// same entity may not (and probably don't) share this property.\n  void setObjectOfFriendDecl(bool PerformFriendInjection = false) {\n    unsigned OldNS = IdentifierNamespace;\n    assert((OldNS & (IDNS_Tag | IDNS_Ordinary |\n                     IDNS_TagFriend | IDNS_OrdinaryFriend |\n                     IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes neither ordinary nor tag\");\n    assert(!(OldNS & ~(IDNS_Tag | IDNS_Ordinary | IDNS_Type |\n                       IDNS_TagFriend | IDNS_OrdinaryFriend |\n                       IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes other than ordinary or tag\");\n\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~(IDNS_Ordinary | IDNS_Tag | IDNS_Type);\n\n    if (OldNS & (IDNS_Tag | IDNS_TagFriend)) {\n      IdentifierNamespace |= IDNS_TagFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Tag))\n        IdentifierNamespace |= IDNS_Tag | IDNS_Type;\n    }\n\n    if (OldNS & (IDNS_Ordinary | IDNS_OrdinaryFriend |\n                 IDNS_LocalExtern | IDNS_NonMemberOperator)) {\n      IdentifierNamespace |= IDNS_OrdinaryFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary))\n        IdentifierNamespace |= IDNS_Ordinary;\n    }\n  }\n\n  enum FriendObjectKind {\n    FOK_None,      ///< Not a friend object.\n    FOK_Declared,  ///< A friend of a previously-declared entity.\n    FOK_Undeclared ///< A friend of a previously-undeclared entity.\n  };\n\n  /// Determines whether this declaration is the object of a\n  /// friend declaration and, if so, what kind.\n  ///\n  /// There is currently no direct way to find the associated FriendDecl.\n  FriendObjectKind getFriendObjectKind() const {\n    unsigned mask =\n        (IdentifierNamespace & (IDNS_TagFriend | IDNS_OrdinaryFriend));\n    if (!mask) return FOK_None;\n    return (IdentifierNamespace & (IDNS_Tag | IDNS_Ordinary) ? FOK_Declared\n                                                             : FOK_Undeclared);\n  }\n\n  /// Specifies that this declaration is a C++ overloaded non-member.\n  void setNonMemberOperator() {\n    assert(getKind() == Function || getKind() == FunctionTemplate);\n    assert((IdentifierNamespace & IDNS_Ordinary) &&\n           \"visible non-member operators should be in ordinary namespace\");\n    IdentifierNamespace |= IDNS_NonMemberOperator;\n  }\n\n  static bool classofKind(Kind K) { return true; }\n  static DeclContext *castToDeclContext(const Decl *);\n  static Decl *castFromDeclContext(const DeclContext *);\n\n  void print(raw_ostream &Out, unsigned Indentation = 0,\n             bool PrintInstantiation = false) const;\n  void print(raw_ostream &Out, const PrintingPolicy &Policy,\n             unsigned Indentation = 0, bool PrintInstantiation = false) const;\n  static void printGroup(Decl** Begin, unsigned NumDecls,\n                         raw_ostream &Out, const PrintingPolicy &Policy,\n                         unsigned Indentation = 0);\n\n  // Debuggers don't usually respect default arguments.\n  void dump() const;\n\n  // Same as dump(), but forces color printing.\n  void dumpColor() const;\n\n  void dump(raw_ostream &Out, bool Deserialize = false,\n            ASTDumpOutputFormat OutputFormat = ADOF_Default) const;\n\n  /// \\return Unique reproducible object identifier\n  int64_t getID() const;\n\n  /// Looks through the Decl's underlying type to extract a FunctionType\n  /// when possible. Will return null if the type underlying the Decl does not\n  /// have a FunctionType.\n  const FunctionType *getFunctionType(bool BlocksToo = true) const;\n\nprivate:\n  void setAttrsImpl(const AttrVec& Attrs, ASTContext &Ctx);\n  void setDeclContextsImpl(DeclContext *SemaDC, DeclContext *LexicalDC,\n                           ASTContext &Ctx);\n\nprotected:\n  ASTMutationListener *getASTMutationListener() const;\n};\n\n/// Determine whether two declarations declare the same entity.\ninline bool declaresSameEntity(const Decl *D1, const Decl *D2) {\n  if (!D1 || !D2)\n    return false;\n\n  if (D1 == D2)\n    return true;\n\n  return D1->getCanonicalDecl() == D2->getCanonicalDecl();\n}\n\n/// PrettyStackTraceDecl - If a crash occurs, indicate that it happened when\n/// doing something to a specific decl.\nclass PrettyStackTraceDecl : public llvm::PrettyStackTraceEntry {\n  const Decl *TheDecl;\n  SourceLocation Loc;\n  SourceManager &SM;\n  const char *Message;\n\npublic:\n  PrettyStackTraceDecl(const Decl *theDecl, SourceLocation L,\n                       SourceManager &sm, const char *Msg)\n      : TheDecl(theDecl), Loc(L), SM(sm), Message(Msg) {}\n\n  void print(raw_ostream &OS) const override;\n};\n\n/// The results of name lookup within a DeclContext. This is either a\n/// single result (with no stable storage) or a collection of results (with\n/// stable storage provided by the lookup table).\nclass DeclContextLookupResult {\n  using ResultTy = ArrayRef<NamedDecl *>;\n\n  ResultTy Result;\n\n  // If there is only one lookup result, it would be invalidated by\n  // reallocations of the name table, so store it separately.\n  NamedDecl *Single = nullptr;\n\n  static NamedDecl *const SingleElementDummyList;\n\npublic:\n  DeclContextLookupResult() = default;\n  DeclContextLookupResult(ArrayRef<NamedDecl *> Result)\n      : Result(Result) {}\n  DeclContextLookupResult(NamedDecl *Single)\n      : Result(SingleElementDummyList), Single(Single) {}\n\n  class iterator;\n\n  using IteratorBase =\n      llvm::iterator_adaptor_base<iterator, ResultTy::iterator,\n                                  std::random_access_iterator_tag, NamedDecl *>;\n\n  class iterator : public IteratorBase {\n    value_type SingleElement;\n\n  public:\n    explicit iterator(pointer Pos, value_type Single = nullptr)\n        : IteratorBase(Pos), SingleElement(Single) {}\n\n    reference operator*() const {\n      return SingleElement ? SingleElement : IteratorBase::operator*();\n    }\n  };\n\n  using const_iterator = iterator;\n  using pointer = iterator::pointer;\n  using reference = iterator::reference;\n\n  iterator begin() const { return iterator(Result.begin(), Single); }\n  iterator end() const { return iterator(Result.end(), Single); }\n\n  bool empty() const { return Result.empty(); }\n  pointer data() const { return Single ? &Single : Result.data(); }\n  size_t size() const { return Single ? 1 : Result.size(); }\n  reference front() const { return Single ? Single : Result.front(); }\n  reference back() const { return Single ? Single : Result.back(); }\n  reference operator[](size_t N) const { return Single ? Single : Result[N]; }\n\n  // FIXME: Remove this from the interface\n  DeclContextLookupResult slice(size_t N) const {\n    DeclContextLookupResult Sliced = Result.slice(N);\n    Sliced.Single = Single;\n    return Sliced;\n  }\n};\n\n/// DeclContext - This is used only as base class of specific decl types that\n/// can act as declaration contexts. These decls are (only the top classes\n/// that directly derive from DeclContext are mentioned, not their subclasses):\n///\n///   TranslationUnitDecl\n///   ExternCContext\n///   NamespaceDecl\n///   TagDecl\n///   OMPDeclareReductionDecl\n///   OMPDeclareMapperDecl\n///   FunctionDecl\n///   ObjCMethodDecl\n///   ObjCContainerDecl\n///   LinkageSpecDecl\n///   ExportDecl\n///   BlockDecl\n///   CapturedDecl\nclass DeclContext {\n  /// For makeDeclVisibleInContextImpl\n  friend class ASTDeclReader;\n  /// For reconcileExternalVisibleStorage, CreateStoredDeclsMap,\n  /// hasNeedToReconcileExternalVisibleStorage\n  friend class ExternalASTSource;\n  /// For CreateStoredDeclsMap\n  friend class DependentDiagnostic;\n  /// For hasNeedToReconcileExternalVisibleStorage,\n  /// hasLazyLocalLexicalLookups, hasLazyExternalLexicalLookups\n  friend class ASTWriter;\n\n  // We use uint64_t in the bit-fields below since some bit-fields\n  // cross the unsigned boundary and this breaks the packing.\n\n  /// Stores the bits used by DeclContext.\n  /// If modified NumDeclContextBit, the ctor of DeclContext and the accessor\n  /// methods in DeclContext should be updated appropriately.\n  class DeclContextBitfields {\n    friend class DeclContext;\n    /// DeclKind - This indicates which class this is.\n    uint64_t DeclKind : 7;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are lexically\n    /// part of this context.\n    mutable uint64_t ExternalLexicalStorage : 1;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are visible\n    /// in this context.\n    mutable uint64_t ExternalVisibleStorage : 1;\n\n    /// Whether this declaration context has had externally visible\n    /// storage added since the last lookup. In this case, \\c LookupPtr's\n    /// invariant may not hold and needs to be fixed before we perform\n    /// another lookup.\n    mutable uint64_t NeedToReconcileExternalVisibleStorage : 1;\n\n    /// If \\c true, this context may have local lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyLocalLexicalLookups : 1;\n\n    /// If \\c true, the external source may have lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyExternalLexicalLookups : 1;\n\n    /// If \\c true, lookups should only return identifier from\n    /// DeclContext scope (for example TranslationUnit). Used in\n    /// LookupQualifiedName()\n    mutable uint64_t UseQualifiedLookup : 1;\n  };\n\n  /// Number of bits in DeclContextBitfields.\n  enum { NumDeclContextBits = 13 };\n\n  /// Stores the bits used by TagDecl.\n  /// If modified NumTagDeclBits and the accessor\n  /// methods in TagDecl should be updated appropriately.\n  class TagDeclBitfields {\n    friend class TagDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// The TagKind enum.\n    uint64_t TagDeclKind : 3;\n\n    /// True if this is a definition (\"struct foo {};\"), false if it is a\n    /// declaration (\"struct foo;\").  It is not considered a definition\n    /// until the definition has been fully processed.\n    uint64_t IsCompleteDefinition : 1;\n\n    /// True if this is currently being defined.\n    uint64_t IsBeingDefined : 1;\n\n    /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n    /// for the very first time) in the syntax of a declarator.\n    uint64_t IsEmbeddedInDeclarator : 1;\n\n    /// True if this tag is free standing, e.g. \"struct foo;\".\n    uint64_t IsFreeStanding : 1;\n\n    /// Indicates whether it is possible for declarations of this kind\n    /// to have an out-of-date definition.\n    ///\n    /// This option is only enabled when modules are enabled.\n    uint64_t MayHaveOutOfDateDef : 1;\n\n    /// Has the full definition of this type been required by a use somewhere in\n    /// the TU.\n    uint64_t IsCompleteDefinitionRequired : 1;\n  };\n\n  /// Number of non-inherited bits in TagDeclBitfields.\n  enum { NumTagDeclBits = 9 };\n\n  /// Stores the bits used by EnumDecl.\n  /// If modified NumEnumDeclBit and the accessor\n  /// methods in EnumDecl should be updated appropriately.\n  class EnumDeclBitfields {\n    friend class EnumDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// Width in bits required to store all the non-negative\n    /// enumerators of this enum.\n    uint64_t NumPositiveBits : 8;\n\n    /// Width in bits required to store all the negative\n    /// enumerators of this enum.\n    uint64_t NumNegativeBits : 8;\n\n    /// True if this tag declaration is a scoped enumeration. Only\n    /// possible in C++11 mode.\n    uint64_t IsScoped : 1;\n\n    /// If this tag declaration is a scoped enum,\n    /// then this is true if the scoped enum was declared using the class\n    /// tag, false if it was declared with the struct tag. No meaning is\n    /// associated if this tag declaration is not a scoped enum.\n    uint64_t IsScopedUsingClassTag : 1;\n\n    /// True if this is an enumeration with fixed underlying type. Only\n    /// possible in C++11, Microsoft extensions, or Objective C mode.\n    uint64_t IsFixed : 1;\n\n    /// True if a valid hash is stored in ODRHash.\n    uint64_t HasODRHash : 1;\n  };\n\n  /// Number of non-inherited bits in EnumDeclBitfields.\n  enum { NumEnumDeclBits = 20 };\n\n  /// Stores the bits used by RecordDecl.\n  /// If modified NumRecordDeclBits and the accessor\n  /// methods in RecordDecl should be updated appropriately.\n  class RecordDeclBitfields {\n    friend class RecordDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// This is true if this struct ends with a flexible\n    /// array member (e.g. int X[]) or if this union contains a struct that does.\n    /// If so, this cannot be contained in arrays or other structs as a member.\n    uint64_t HasFlexibleArrayMember : 1;\n\n    /// Whether this is the type of an anonymous struct or union.\n    uint64_t AnonymousStructOrUnion : 1;\n\n    /// This is true if this struct has at least one member\n    /// containing an Objective-C object pointer type.\n    uint64_t HasObjectMember : 1;\n\n    /// This is true if struct has at least one member of\n    /// 'volatile' type.\n    uint64_t HasVolatileMember : 1;\n\n    /// Whether the field declarations of this record have been loaded\n    /// from external storage. To avoid unnecessary deserialization of\n    /// methods/nested types we allow deserialization of just the fields\n    /// when needed.\n    mutable uint64_t LoadedFieldsFromExternalStorage : 1;\n\n    /// Basic properties of non-trivial C structs.\n    uint64_t NonTrivialToPrimitiveDefaultInitialize : 1;\n    uint64_t NonTrivialToPrimitiveCopy : 1;\n    uint64_t NonTrivialToPrimitiveDestroy : 1;\n\n    /// The following bits indicate whether this is or contains a C union that\n    /// is non-trivial to default-initialize, destruct, or copy. These bits\n    /// imply the associated basic non-triviality predicates declared above.\n    uint64_t HasNonTrivialToPrimitiveDefaultInitializeCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveDestructCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveCopyCUnion : 1;\n\n    /// Indicates whether this struct is destroyed in the callee.\n    uint64_t ParamDestroyedInCallee : 1;\n\n    /// Represents the way this type is passed to a function.\n    uint64_t ArgPassingRestrictions : 2;\n  };\n\n  /// Number of non-inherited bits in RecordDeclBitfields.\n  enum { NumRecordDeclBits = 14 };\n\n  /// Stores the bits used by OMPDeclareReductionDecl.\n  /// If modified NumOMPDeclareReductionDeclBits and the accessor\n  /// methods in OMPDeclareReductionDecl should be updated appropriately.\n  class OMPDeclareReductionDeclBitfields {\n    friend class OMPDeclareReductionDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// Kind of initializer,\n    /// function call or omp_priv<init_expr> initializtion.\n    uint64_t InitializerKind : 2;\n  };\n\n  /// Number of non-inherited bits in OMPDeclareReductionDeclBitfields.\n  enum { NumOMPDeclareReductionDeclBits = 2 };\n\n  /// Stores the bits used by FunctionDecl.\n  /// If modified NumFunctionDeclBits and the accessor\n  /// methods in FunctionDecl and CXXDeductionGuideDecl\n  /// (for IsCopyDeductionCandidate) should be updated appropriately.\n  class FunctionDeclBitfields {\n    friend class FunctionDecl;\n    /// For IsCopyDeductionCandidate\n    friend class CXXDeductionGuideDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t SClass : 3;\n    uint64_t IsInline : 1;\n    uint64_t IsInlineSpecified : 1;\n\n    uint64_t IsVirtualAsWritten : 1;\n    uint64_t IsPure : 1;\n    uint64_t HasInheritedPrototype : 1;\n    uint64_t HasWrittenPrototype : 1;\n    uint64_t IsDeleted : 1;\n    /// Used by CXXMethodDecl\n    uint64_t IsTrivial : 1;\n\n    /// This flag indicates whether this function is trivial for the purpose of\n    /// calls. This is meaningful only when this function is a copy/move\n    /// constructor or a destructor.\n    uint64_t IsTrivialForCall : 1;\n\n    uint64_t IsDefaulted : 1;\n    uint64_t IsExplicitlyDefaulted : 1;\n    uint64_t HasDefaultedFunctionInfo : 1;\n    uint64_t HasImplicitReturnZero : 1;\n    uint64_t IsLateTemplateParsed : 1;\n\n    /// Kind of contexpr specifier as defined by ConstexprSpecKind.\n    uint64_t ConstexprKind : 2;\n    uint64_t InstantiationIsPending : 1;\n\n    /// Indicates if the function uses __try.\n    uint64_t UsesSEHTry : 1;\n\n    /// Indicates if the function was a definition\n    /// but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n\n    /// Indicates if the function declaration will\n    /// have a body, once we're done parsing it.\n    uint64_t WillHaveBody : 1;\n\n    /// Indicates that this function is a multiversioned\n    /// function using attribute 'target'.\n    uint64_t IsMultiVersion : 1;\n\n    /// [C++17] Only used by CXXDeductionGuideDecl. Indicates that\n    /// the Deduction Guide is the implicitly generated 'copy\n    /// deduction candidate' (is used during overload resolution).\n    uint64_t IsCopyDeductionCandidate : 1;\n\n    /// Store the ODRHash after first calculation.\n    uint64_t HasODRHash : 1;\n\n    /// Indicates if the function uses Floating Point Constrained Intrinsics\n    uint64_t UsesFPIntrin : 1;\n  };\n\n  /// Number of non-inherited bits in FunctionDeclBitfields.\n  enum { NumFunctionDeclBits = 27 };\n\n  /// Stores the bits used by CXXConstructorDecl. If modified\n  /// NumCXXConstructorDeclBits and the accessor\n  /// methods in CXXConstructorDecl should be updated appropriately.\n  class CXXConstructorDeclBitfields {\n    friend class CXXConstructorDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in FunctionDeclBitfields.\n    uint64_t : NumFunctionDeclBits;\n\n    /// 24 bits to fit in the remaining available space.\n    /// Note that this makes CXXConstructorDeclBitfields take\n    /// exactly 64 bits and thus the width of NumCtorInitializers\n    /// will need to be shrunk if some bit is added to NumDeclContextBitfields,\n    /// NumFunctionDeclBitfields or CXXConstructorDeclBitfields.\n    uint64_t NumCtorInitializers : 21;\n    uint64_t IsInheritingConstructor : 1;\n\n    /// Whether this constructor has a trail-allocated explicit specifier.\n    uint64_t HasTrailingExplicitSpecifier : 1;\n    /// If this constructor does't have a trail-allocated explicit specifier.\n    /// Whether this constructor is explicit specified.\n    uint64_t IsSimpleExplicit : 1;\n  };\n\n  /// Number of non-inherited bits in CXXConstructorDeclBitfields.\n  enum {\n    NumCXXConstructorDeclBits = 64 - NumDeclContextBits - NumFunctionDeclBits\n  };\n\n  /// Stores the bits used by ObjCMethodDecl.\n  /// If modified NumObjCMethodDeclBits and the accessor\n  /// methods in ObjCMethodDecl should be updated appropriately.\n  class ObjCMethodDeclBitfields {\n    friend class ObjCMethodDecl;\n\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The conventional meaning of this method; an ObjCMethodFamily.\n    /// This is not serialized; instead, it is computed on demand and\n    /// cached.\n    mutable uint64_t Family : ObjCMethodFamilyBitWidth;\n\n    /// instance (true) or class (false) method.\n    uint64_t IsInstance : 1;\n    uint64_t IsVariadic : 1;\n\n    /// True if this method is the getter or setter for an explicit property.\n    uint64_t IsPropertyAccessor : 1;\n\n    /// True if this method is a synthesized property accessor stub.\n    uint64_t IsSynthesizedAccessorStub : 1;\n\n    /// Method has a definition.\n    uint64_t IsDefined : 1;\n\n    /// Method redeclaration in the same interface.\n    uint64_t IsRedeclaration : 1;\n\n    /// Is redeclared in the same interface.\n    mutable uint64_t HasRedeclaration : 1;\n\n    /// \\@required/\\@optional\n    uint64_t DeclImplementation : 2;\n\n    /// in, inout, etc.\n    uint64_t objcDeclQualifier : 7;\n\n    /// Indicates whether this method has a related result type.\n    uint64_t RelatedResultType : 1;\n\n    /// Whether the locations of the selector identifiers are in a\n    /// \"standard\" position, a enum SelectorLocationsKind.\n    uint64_t SelLocsKind : 2;\n\n    /// Whether this method overrides any other in the class hierarchy.\n    ///\n    /// A method is said to override any method in the class's\n    /// base classes, its protocols, or its categories' protocols, that has\n    /// the same selector and is of the same kind (class or instance).\n    /// A method in an implementation is not considered as overriding the same\n    /// method in the interface or its categories.\n    uint64_t IsOverriding : 1;\n\n    /// Indicates if the method was a definition but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n  };\n\n  /// Number of non-inherited bits in ObjCMethodDeclBitfields.\n  enum { NumObjCMethodDeclBits = 24 };\n\n  /// Stores the bits used by ObjCContainerDecl.\n  /// If modified NumObjCContainerDeclBits and the accessor\n  /// methods in ObjCContainerDecl should be updated appropriately.\n  class ObjCContainerDeclBitfields {\n    friend class ObjCContainerDecl;\n    /// For the bits in DeclContextBitfields\n    uint32_t : NumDeclContextBits;\n\n    // Not a bitfield but this saves space.\n    // Note that ObjCContainerDeclBitfields is full.\n    SourceLocation AtStart;\n  };\n\n  /// Number of non-inherited bits in ObjCContainerDeclBitfields.\n  /// Note that here we rely on the fact that SourceLocation is 32 bits\n  /// wide. We check this with the static_assert in the ctor of DeclContext.\n  enum { NumObjCContainerDeclBits = 64 - NumDeclContextBits };\n\n  /// Stores the bits used by LinkageSpecDecl.\n  /// If modified NumLinkageSpecDeclBits and the accessor\n  /// methods in LinkageSpecDecl should be updated appropriately.\n  class LinkageSpecDeclBitfields {\n    friend class LinkageSpecDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The language for this linkage specification with values\n    /// in the enum LinkageSpecDecl::LanguageIDs.\n    uint64_t Language : 3;\n\n    /// True if this linkage spec has braces.\n    /// This is needed so that hasBraces() returns the correct result while the\n    /// linkage spec body is being parsed.  Once RBraceLoc has been set this is\n    /// not used, so it doesn't need to be serialized.\n    uint64_t HasBraces : 1;\n  };\n\n  /// Number of non-inherited bits in LinkageSpecDeclBitfields.\n  enum { NumLinkageSpecDeclBits = 4 };\n\n  /// Stores the bits used by BlockDecl.\n  /// If modified NumBlockDeclBits and the accessor\n  /// methods in BlockDecl should be updated appropriately.\n  class BlockDeclBitfields {\n    friend class BlockDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t IsVariadic : 1;\n    uint64_t CapturesCXXThis : 1;\n    uint64_t BlockMissingReturnType : 1;\n    uint64_t IsConversionFromLambda : 1;\n\n    /// A bit that indicates this block is passed directly to a function as a\n    /// non-escaping parameter.\n    uint64_t DoesNotEscape : 1;\n\n    /// A bit that indicates whether it's possible to avoid coying this block to\n    /// the heap when it initializes or is assigned to a local variable with\n    /// automatic storage.\n    uint64_t CanAvoidCopyToHeap : 1;\n  };\n\n  /// Number of non-inherited bits in BlockDeclBitfields.\n  enum { NumBlockDeclBits = 5 };\n\n  /// Pointer to the data structure used to lookup declarations\n  /// within this context (or a DependentStoredDeclsMap if this is a\n  /// dependent context). We maintain the invariant that, if the map\n  /// contains an entry for a DeclarationName (and we haven't lazily\n  /// omitted anything), then it contains all relevant entries for that\n  /// name (modulo the hasExternalDecls() flag).\n  mutable StoredDeclsMap *LookupPtr = nullptr;\n\nprotected:\n  /// This anonymous union stores the bits belonging to DeclContext and classes\n  /// deriving from it. The goal is to use otherwise wasted\n  /// space in DeclContext to store data belonging to derived classes.\n  /// The space saved is especially significient when pointers are aligned\n  /// to 8 bytes. In this case due to alignment requirements we have a\n  /// little less than 8 bytes free in DeclContext which we can use.\n  /// We check that none of the classes in this union is larger than\n  /// 8 bytes with static_asserts in the ctor of DeclContext.\n  union {\n    DeclContextBitfields DeclContextBits;\n    TagDeclBitfields TagDeclBits;\n    EnumDeclBitfields EnumDeclBits;\n    RecordDeclBitfields RecordDeclBits;\n    OMPDeclareReductionDeclBitfields OMPDeclareReductionDeclBits;\n    FunctionDeclBitfields FunctionDeclBits;\n    CXXConstructorDeclBitfields CXXConstructorDeclBits;\n    ObjCMethodDeclBitfields ObjCMethodDeclBits;\n    ObjCContainerDeclBitfields ObjCContainerDeclBits;\n    LinkageSpecDeclBitfields LinkageSpecDeclBits;\n    BlockDeclBitfields BlockDeclBits;\n\n    static_assert(sizeof(DeclContextBitfields) <= 8,\n                  \"DeclContextBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(TagDeclBitfields) <= 8,\n                  \"TagDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(EnumDeclBitfields) <= 8,\n                  \"EnumDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(RecordDeclBitfields) <= 8,\n                  \"RecordDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(OMPDeclareReductionDeclBitfields) <= 8,\n                  \"OMPDeclareReductionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(FunctionDeclBitfields) <= 8,\n                  \"FunctionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(CXXConstructorDeclBitfields) <= 8,\n                  \"CXXConstructorDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCMethodDeclBitfields) <= 8,\n                  \"ObjCMethodDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCContainerDeclBitfields) <= 8,\n                  \"ObjCContainerDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(LinkageSpecDeclBitfields) <= 8,\n                  \"LinkageSpecDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(BlockDeclBitfields) <= 8,\n                  \"BlockDeclBitfields is larger than 8 bytes!\");\n  };\n\n  /// FirstDecl - The first declaration stored within this declaration\n  /// context.\n  mutable Decl *FirstDecl = nullptr;\n\n  /// LastDecl - The last declaration stored within this declaration\n  /// context. FIXME: We could probably cache this value somewhere\n  /// outside of the DeclContext, to reduce the size of DeclContext by\n  /// another pointer.\n  mutable Decl *LastDecl = nullptr;\n\n  /// Build up a chain of declarations.\n  ///\n  /// \\returns the first/last pair of declarations.\n  static std::pair<Decl *, Decl *>\n  BuildDeclChain(ArrayRef<Decl*> Decls, bool FieldsAlreadyLoaded);\n\n  DeclContext(Decl::Kind K);\n\npublic:\n  ~DeclContext();\n\n  Decl::Kind getDeclKind() const {\n    return static_cast<Decl::Kind>(DeclContextBits.DeclKind);\n  }\n\n  const char *getDeclKindName() const;\n\n  /// getParent - Returns the containing DeclContext.\n  DeclContext *getParent() {\n    return cast<Decl>(this)->getDeclContext();\n  }\n  const DeclContext *getParent() const {\n    return const_cast<DeclContext*>(this)->getParent();\n  }\n\n  /// getLexicalParent - Returns the containing lexical DeclContext. May be\n  /// different from getParent, e.g.:\n  ///\n  ///   namespace A {\n  ///      struct S;\n  ///   }\n  ///   struct A::S {}; // getParent() == namespace 'A'\n  ///                   // getLexicalParent() == translation unit\n  ///\n  DeclContext *getLexicalParent() {\n    return cast<Decl>(this)->getLexicalDeclContext();\n  }\n  const DeclContext *getLexicalParent() const {\n    return const_cast<DeclContext*>(this)->getLexicalParent();\n  }\n\n  DeclContext *getLookupParent();\n\n  const DeclContext *getLookupParent() const {\n    return const_cast<DeclContext*>(this)->getLookupParent();\n  }\n\n  ASTContext &getParentASTContext() const {\n    return cast<Decl>(this)->getASTContext();\n  }\n\n  bool isClosure() const { return getDeclKind() == Decl::Block; }\n\n  /// Return this DeclContext if it is a BlockDecl. Otherwise, return the\n  /// innermost enclosing BlockDecl or null if there are no enclosing blocks.\n  const BlockDecl *getInnermostBlockDecl() const;\n\n  bool isObjCContainer() const {\n    switch (getDeclKind()) {\n    case Decl::ObjCCategory:\n    case Decl::ObjCCategoryImpl:\n    case Decl::ObjCImplementation:\n    case Decl::ObjCInterface:\n    case Decl::ObjCProtocol:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  bool isFunctionOrMethod() const {\n    switch (getDeclKind()) {\n    case Decl::Block:\n    case Decl::Captured:\n    case Decl::ObjCMethod:\n      return true;\n    default:\n      return getDeclKind() >= Decl::firstFunction &&\n             getDeclKind() <= Decl::lastFunction;\n    }\n  }\n\n  /// Test whether the context supports looking up names.\n  bool isLookupContext() const {\n    return !isFunctionOrMethod() && getDeclKind() != Decl::LinkageSpec &&\n           getDeclKind() != Decl::Export;\n  }\n\n  bool isFileContext() const {\n    return getDeclKind() == Decl::TranslationUnit ||\n           getDeclKind() == Decl::Namespace;\n  }\n\n  bool isTranslationUnit() const {\n    return getDeclKind() == Decl::TranslationUnit;\n  }\n\n  bool isRecord() const {\n    return getDeclKind() >= Decl::firstRecord &&\n           getDeclKind() <= Decl::lastRecord;\n  }\n\n  bool isNamespace() const { return getDeclKind() == Decl::Namespace; }\n\n  bool isStdNamespace() const;\n\n  bool isInlineNamespace() const;\n\n  /// Determines whether this context is dependent on a\n  /// template parameter.\n  bool isDependentContext() const;\n\n  /// isTransparentContext - Determines whether this context is a\n  /// \"transparent\" context, meaning that the members declared in this\n  /// context are semantically declared in the nearest enclosing\n  /// non-transparent (opaque) context but are lexically declared in\n  /// this context. For example, consider the enumerators of an\n  /// enumeration type:\n  /// @code\n  /// enum E {\n  ///   Val1\n  /// };\n  /// @endcode\n  /// Here, E is a transparent context, so its enumerator (Val1) will\n  /// appear (semantically) that it is in the same context of E.\n  /// Examples of transparent contexts include: enumerations (except for\n  /// C++0x scoped enums), and C++ linkage specifications.\n  bool isTransparentContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C linkage.\n  bool isExternCContext() const;\n\n  /// Retrieve the nearest enclosing C linkage specification context.\n  const LinkageSpecDecl *getExternCContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C++ linkage.\n  bool isExternCXXContext() const;\n\n  /// Determine whether this declaration context is equivalent\n  /// to the declaration context DC.\n  bool Equals(const DeclContext *DC) const {\n    return DC && this->getPrimaryContext() == DC->getPrimaryContext();\n  }\n\n  /// Determine whether this declaration context encloses the\n  /// declaration context DC.\n  bool Encloses(const DeclContext *DC) const;\n\n  /// Find the nearest non-closure ancestor of this context,\n  /// i.e. the innermost semantic parent of this context which is not\n  /// a closure.  A context may be its own non-closure ancestor.\n  Decl *getNonClosureAncestor();\n  const Decl *getNonClosureAncestor() const {\n    return const_cast<DeclContext*>(this)->getNonClosureAncestor();\n  }\n\n  /// getPrimaryContext - There may be many different\n  /// declarations of the same entity (including forward declarations\n  /// of classes, multiple definitions of namespaces, etc.), each with\n  /// a different set of declarations. This routine returns the\n  /// \"primary\" DeclContext structure, which will contain the\n  /// information needed to perform name lookup into this context.\n  DeclContext *getPrimaryContext();\n  const DeclContext *getPrimaryContext() const {\n    return const_cast<DeclContext*>(this)->getPrimaryContext();\n  }\n\n  /// getRedeclContext - Retrieve the context in which an entity conflicts with\n  /// other entities of the same name, or where it is a redeclaration if the\n  /// two entities are compatible. This skips through transparent contexts.\n  DeclContext *getRedeclContext();\n  const DeclContext *getRedeclContext() const {\n    return const_cast<DeclContext *>(this)->getRedeclContext();\n  }\n\n  /// Retrieve the nearest enclosing namespace context.\n  DeclContext *getEnclosingNamespaceContext();\n  const DeclContext *getEnclosingNamespaceContext() const {\n    return const_cast<DeclContext *>(this)->getEnclosingNamespaceContext();\n  }\n\n  /// Retrieve the outermost lexically enclosing record context.\n  RecordDecl *getOuterLexicalRecordContext();\n  const RecordDecl *getOuterLexicalRecordContext() const {\n    return const_cast<DeclContext *>(this)->getOuterLexicalRecordContext();\n  }\n\n  /// Test if this context is part of the enclosing namespace set of\n  /// the context NS, as defined in C++0x [namespace.def]p9. If either context\n  /// isn't a namespace, this is equivalent to Equals().\n  ///\n  /// The enclosing namespace set of a namespace is the namespace and, if it is\n  /// inline, its enclosing namespace, recursively.\n  bool InEnclosingNamespaceSetOf(const DeclContext *NS) const;\n\n  /// Collects all of the declaration contexts that are semantically\n  /// connected to this declaration context.\n  ///\n  /// For declaration contexts that have multiple semantically connected but\n  /// syntactically distinct contexts, such as C++ namespaces, this routine\n  /// retrieves the complete set of such declaration contexts in source order.\n  /// For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   int x;\n  /// }\n  /// namespace N {\n  ///   int y;\n  /// }\n  /// \\endcode\n  ///\n  /// The \\c Contexts parameter will contain both definitions of N.\n  ///\n  /// \\param Contexts Will be cleared and set to the set of declaration\n  /// contexts that are semanticaly connected to this declaration context,\n  /// in source order, including this context (which may be the only result,\n  /// for non-namespace contexts).\n  void collectAllContexts(SmallVectorImpl<DeclContext *> &Contexts);\n\n  /// decl_iterator - Iterates through the declarations stored\n  /// within this context.\n  class decl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    decl_iterator() = default;\n    explicit decl_iterator(Decl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return Current; }\n\n    decl_iterator& operator++() {\n      Current = Current->getNextDeclInContext();\n      return *this;\n    }\n\n    decl_iterator operator++(int) {\n      decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(decl_iterator x, decl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(decl_iterator x, decl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using decl_range = llvm::iterator_range<decl_iterator>;\n\n  /// decls_begin/decls_end - Iterate over the declarations stored in\n  /// this context.\n  decl_range decls() const { return decl_range(decls_begin(), decls_end()); }\n  decl_iterator decls_begin() const;\n  decl_iterator decls_end() const { return decl_iterator(); }\n  bool decls_empty() const;\n\n  /// noload_decls_begin/end - Iterate over the declarations stored in this\n  /// context that are currently loaded; don't attempt to retrieve anything\n  /// from an external source.\n  decl_range noload_decls() const {\n    return decl_range(noload_decls_begin(), noload_decls_end());\n  }\n  decl_iterator noload_decls_begin() const { return decl_iterator(FirstDecl); }\n  decl_iterator noload_decls_end() const { return decl_iterator(); }\n\n  /// specific_decl_iterator - Iterates over a subrange of\n  /// declarations stored in a DeclContext, providing only those that\n  /// are of type SpecificDecl (or a class derived from it). This\n  /// iterator is used, for example, to provide iteration over just\n  /// the fields within a RecordDecl (with SpecificDecl = FieldDecl).\n  template<typename SpecificDecl>\n  class specific_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current && !isa<SpecificDecl>(*Current))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    specific_decl_iterator() = default;\n\n    /// specific_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit specific_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return **this; }\n\n    specific_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    specific_decl_iterator operator++(int) {\n      specific_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Iterates over a filtered subrange of declarations stored\n  /// in a DeclContext.\n  ///\n  /// This iterator visits only those declarations that are of type\n  /// SpecificDecl (or a class derived from it) and that meet some\n  /// additional run-time criteria. This iterator is used, for\n  /// example, to provide access to the instance methods within an\n  /// Objective-C interface (with SpecificDecl = ObjCMethodDecl and\n  /// Acceptable = ObjCMethodDecl::isInstanceMethod).\n  template<typename SpecificDecl, bool (SpecificDecl::*Acceptable)() const>\n  class filtered_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current &&\n             (!isa<SpecificDecl>(*Current) ||\n              (Acceptable && !(cast<SpecificDecl>(*Current)->*Acceptable)())))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    filtered_decl_iterator() = default;\n\n    /// filtered_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit filtered_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n    value_type operator->() const { return cast<SpecificDecl>(*Current); }\n\n    filtered_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    filtered_decl_iterator operator++(int) {\n      filtered_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Add the declaration D into this context.\n  ///\n  /// This routine should be invoked when the declaration D has first\n  /// been declared, to place D into the context where it was\n  /// (lexically) defined. Every declaration must be added to one\n  /// (and only one!) context, where it can be visited via\n  /// [decls_begin(), decls_end()). Once a declaration has been added\n  /// to its lexical context, the corresponding DeclContext owns the\n  /// declaration.\n  ///\n  /// If D is also a NamedDecl, it will be made visible within its\n  /// semantic context via makeDeclVisibleInContext.\n  void addDecl(Decl *D);\n\n  /// Add the declaration D into this context, but suppress\n  /// searches for external declarations with the same name.\n  ///\n  /// Although analogous in function to addDecl, this removes an\n  /// important check.  This is only useful if the Decl is being\n  /// added in response to an external search; in all other cases,\n  /// addDecl() is the right function to use.\n  /// See the ASTImporter for use cases.\n  void addDeclInternal(Decl *D);\n\n  /// Add the declaration D to this context without modifying\n  /// any lookup tables.\n  ///\n  /// This is useful for some operations in dependent contexts where\n  /// the semantic context might not be dependent;  this basically\n  /// only happens with friends.\n  void addHiddenDecl(Decl *D);\n\n  /// Removes a declaration from this context.\n  void removeDecl(Decl *D);\n\n  /// Checks whether a declaration is in this context.\n  bool containsDecl(Decl *D) const;\n\n  /// Checks whether a declaration is in this context.\n  /// This also loads the Decls from the external source before the check.\n  bool containsDeclAndLoad(Decl *D) const;\n\n  using lookup_result = DeclContextLookupResult;\n  using lookup_iterator = lookup_result::iterator;\n\n  /// lookup - Find the declarations (if any) with the given Name in\n  /// this context. Returns a range of iterators that contains all of\n  /// the declarations with this name, with object, function, member,\n  /// and enumerator names preceding any tag name. Note that this\n  /// routine will not look into parent contexts.\n  lookup_result lookup(DeclarationName Name) const;\n\n  /// Find the declarations with the given name that are visible\n  /// within this context; don't attempt to retrieve anything from an\n  /// external source.\n  lookup_result noload_lookup(DeclarationName Name);\n\n  /// A simplistic name lookup mechanism that performs name lookup\n  /// into this declaration context without consulting the external source.\n  ///\n  /// This function should almost never be used, because it subverts the\n  /// usual relationship between a DeclContext and the external source.\n  /// See the ASTImporter for the (few, but important) use cases.\n  ///\n  /// FIXME: This is very inefficient; replace uses of it with uses of\n  /// noload_lookup.\n  void localUncachedLookup(DeclarationName Name,\n                           SmallVectorImpl<NamedDecl *> &Results);\n\n  /// Makes a declaration visible within this context.\n  ///\n  /// This routine makes the declaration D visible to name lookup\n  /// within this context and, if this is a transparent context,\n  /// within its parent contexts up to the first enclosing\n  /// non-transparent context. Making a declaration visible within a\n  /// context does not transfer ownership of a declaration, and a\n  /// declaration can be visible in many contexts that aren't its\n  /// lexical context.\n  ///\n  /// If D is a redeclaration of an existing declaration that is\n  /// visible from this context, as determined by\n  /// NamedDecl::declarationReplaces, the previous declaration will be\n  /// replaced with D.\n  void makeDeclVisibleInContext(NamedDecl *D);\n\n  /// all_lookups_iterator - An iterator that provides a view over the results\n  /// of looking up every possible name.\n  class all_lookups_iterator;\n\n  using lookups_range = llvm::iterator_range<all_lookups_iterator>;\n\n  lookups_range lookups() const;\n  // Like lookups(), but avoids loading external declarations.\n  // If PreserveInternalState, avoids building lookup data structures too.\n  lookups_range noload_lookups(bool PreserveInternalState) const;\n\n  /// Iterators over all possible lookups within this context.\n  all_lookups_iterator lookups_begin() const;\n  all_lookups_iterator lookups_end() const;\n\n  /// Iterators over all possible lookups within this context that are\n  /// currently loaded; don't attempt to retrieve anything from an external\n  /// source.\n  all_lookups_iterator noload_lookups_begin() const;\n  all_lookups_iterator noload_lookups_end() const;\n\n  struct udir_iterator;\n\n  using udir_iterator_base =\n      llvm::iterator_adaptor_base<udir_iterator, lookup_iterator,\n                                  std::random_access_iterator_tag,\n                                  UsingDirectiveDecl *>;\n\n  struct udir_iterator : udir_iterator_base {\n    udir_iterator(lookup_iterator I) : udir_iterator_base(I) {}\n\n    UsingDirectiveDecl *operator*() const;\n  };\n\n  using udir_range = llvm::iterator_range<udir_iterator>;\n\n  udir_range using_directives() const;\n\n  // These are all defined in DependentDiagnostic.h.\n  class ddiag_iterator;\n\n  using ddiag_range = llvm::iterator_range<DeclContext::ddiag_iterator>;\n\n  inline ddiag_range ddiags() const;\n\n  // Low-level accessors\n\n  /// Mark that there are external lexical declarations that we need\n  /// to include in our lookup table (and that are not available as external\n  /// visible lookups). These extra lookup results will be found by walking\n  /// the lexical declarations of this context. This should be used only if\n  /// setHasExternalLexicalStorage() has been called on any decl context for\n  /// which this is the primary context.\n  void setMustBuildLookupTable() {\n    assert(this == getPrimaryContext() &&\n           \"should only be called on primary context\");\n    DeclContextBits.HasLazyExternalLexicalLookups = true;\n  }\n\n  /// Retrieve the internal representation of the lookup structure.\n  /// This may omit some names if we are lazily building the structure.\n  StoredDeclsMap *getLookupPtr() const { return LookupPtr; }\n\n  /// Ensure the lookup structure is fully-built and return it.\n  StoredDeclsMap *buildLookup();\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are lexically in this context.\n  bool hasExternalLexicalStorage() const {\n    return DeclContextBits.ExternalLexicalStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations lexically in this context.\n  void setHasExternalLexicalStorage(bool ES = true) const {\n    DeclContextBits.ExternalLexicalStorage = ES;\n  }\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are visible in this context.\n  bool hasExternalVisibleStorage() const {\n    return DeclContextBits.ExternalVisibleStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations visible in this context.\n  void setHasExternalVisibleStorage(bool ES = true) const {\n    DeclContextBits.ExternalVisibleStorage = ES;\n    if (ES && LookupPtr)\n      DeclContextBits.NeedToReconcileExternalVisibleStorage = true;\n  }\n\n  /// Determine whether the given declaration is stored in the list of\n  /// declarations lexically within this context.\n  bool isDeclInLexicalTraversal(const Decl *D) const {\n    return D && (D->NextInContextAndBits.getPointer() || D == FirstDecl ||\n                 D == LastDecl);\n  }\n\n  bool setUseQualifiedLookup(bool use = true) const {\n    bool old_value = DeclContextBits.UseQualifiedLookup;\n    DeclContextBits.UseQualifiedLookup = use;\n    return old_value;\n  }\n\n  bool shouldUseQualifiedLookup() const {\n    return DeclContextBits.UseQualifiedLookup;\n  }\n\n  static bool classof(const Decl *D);\n  static bool classof(const DeclContext *D) { return true; }\n\n  void dumpDeclContext() const;\n  void dumpLookups() const;\n  void dumpLookups(llvm::raw_ostream &OS, bool DumpDecls = false,\n                   bool Deserialize = false) const;\n\nprivate:\n  /// Whether this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  bool hasNeedToReconcileExternalVisibleStorage() const {\n    return DeclContextBits.NeedToReconcileExternalVisibleStorage;\n  }\n\n  /// State that this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  void setNeedToReconcileExternalVisibleStorage(bool Need = true) const {\n    DeclContextBits.NeedToReconcileExternalVisibleStorage = Need;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyLocalLexicalLookups() const {\n    return DeclContextBits.HasLazyLocalLexicalLookups;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyLocalLexicalLookups(bool HasLLLL = true) const {\n    DeclContextBits.HasLazyLocalLexicalLookups = HasLLLL;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyExternalLexicalLookups() const {\n    return DeclContextBits.HasLazyExternalLexicalLookups;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyExternalLexicalLookups(bool HasLELL = true) const {\n    DeclContextBits.HasLazyExternalLexicalLookups = HasLELL;\n  }\n\n  void reconcileExternalVisibleStorage() const;\n  bool LoadLexicalDeclsFromExternalStorage() const;\n\n  /// Makes a declaration visible within this context, but\n  /// suppresses searches for external declarations with the same\n  /// name.\n  ///\n  /// Analogous to makeDeclVisibleInContext, but for the exclusive\n  /// use of addDeclInternal().\n  void makeDeclVisibleInContextInternal(NamedDecl *D);\n\n  StoredDeclsMap *CreateStoredDeclsMap(ASTContext &C) const;\n\n  void loadLazyLocalLexicalLookups();\n  void buildLookupImpl(DeclContext *DCtx, bool Internal);\n  void makeDeclVisibleInContextWithFlags(NamedDecl *D, bool Internal,\n                                         bool Rediscoverable);\n  void makeDeclVisibleInContextImpl(NamedDecl *D, bool Internal);\n};\n\ninline bool Decl::isTemplateParameter() const {\n  return getKind() == TemplateTypeParm || getKind() == NonTypeTemplateParm ||\n         getKind() == TemplateTemplateParm;\n}\n\n// Specialization selected when ToTy is not a known subclass of DeclContext.\ntemplate <class ToTy,\n          bool IsKnownSubtype = ::std::is_base_of<DeclContext, ToTy>::value>\nstruct cast_convert_decl_context {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Decl::castFromDeclContext(Val));\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Decl::castFromDeclContext(Val));\n  }\n};\n\n// Specialization selected when ToTy is a known subclass of DeclContext.\ntemplate <class ToTy>\nstruct cast_convert_decl_context<ToTy, true> {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Val);\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Val);\n  }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// isa<T>(DeclContext*)\ntemplate <typename To>\nstruct isa_impl<To, ::clang::DeclContext> {\n  static bool doit(const ::clang::DeclContext &Val) {\n    return To::classofKind(Val.getDeclKind());\n  }\n};\n\n/// cast<T>(DeclContext*)\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                        const ::clang::DeclContext,const ::clang::DeclContext> {\n  static const ToTy &doit(const ::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext, ::clang::DeclContext> {\n  static ToTy &doit(::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                     const ::clang::DeclContext*, const ::clang::DeclContext*> {\n  static const ToTy *doit(const ::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext*, ::clang::DeclContext*> {\n  static ToTy *doit(::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\n/// Implement cast_convert_val for Decl -> DeclContext conversions.\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy, FromTy> {\n  static ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy*, FromTy*> {\n  static ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy, FromTy> {\n  static const ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy*, FromTy*> {\n  static const ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_DECLBASE_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "content": "//===- DeclObjC.h - Classes for representing declarations -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the DeclObjC interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLOBJC_H\n#define LLVM_CLANG_AST_DECLOBJC_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/SelectorLocationsKind.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass CompoundStmt;\nclass CXXCtorInitializer;\nclass Expr;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCPropertyDecl;\nclass ObjCPropertyImplDecl;\nclass ObjCProtocolDecl;\nclass Stmt;\n\nclass ObjCListBase {\nprotected:\n  /// List is an array of pointers to objects that are not owned by this object.\n  void **List = nullptr;\n  unsigned NumElts = 0;\n\npublic:\n  ObjCListBase() = default;\n  ObjCListBase(const ObjCListBase &) = delete;\n  ObjCListBase &operator=(const ObjCListBase &) = delete;\n\n  unsigned size() const { return NumElts; }\n  bool empty() const { return NumElts == 0; }\n\nprotected:\n  void set(void *const* InList, unsigned Elts, ASTContext &Ctx);\n};\n\n/// ObjCList - This is a simple template class used to hold various lists of\n/// decls etc, which is heavily used by the ObjC front-end.  This only use case\n/// this supports is setting the list all at once and then reading elements out\n/// of it.\ntemplate <typename T>\nclass ObjCList : public ObjCListBase {\npublic:\n  void set(T* const* InList, unsigned Elts, ASTContext &Ctx) {\n    ObjCListBase::set(reinterpret_cast<void*const*>(InList), Elts, Ctx);\n  }\n\n  using iterator = T* const *;\n\n  iterator begin() const { return (iterator)List; }\n  iterator end() const { return (iterator)List+NumElts; }\n\n  T* operator[](unsigned Idx) const {\n    assert(Idx < NumElts && \"Invalid access\");\n    return (T*)List[Idx];\n  }\n};\n\n/// A list of Objective-C protocols, along with the source\n/// locations at which they were referenced.\nclass ObjCProtocolList : public ObjCList<ObjCProtocolDecl> {\n  SourceLocation *Locations = nullptr;\n\n  using ObjCList<ObjCProtocolDecl>::set;\n\npublic:\n  ObjCProtocolList() = default;\n\n  using loc_iterator = const SourceLocation *;\n\n  loc_iterator loc_begin() const { return Locations; }\n  loc_iterator loc_end() const { return Locations + size(); }\n\n  void set(ObjCProtocolDecl* const* InList, unsigned Elts,\n           const SourceLocation *Locs, ASTContext &Ctx);\n};\n\n/// ObjCMethodDecl - Represents an instance or class method declaration.\n/// ObjC methods can be declared within 4 contexts: class interfaces,\n/// categories, protocols, and class implementations. While C++ member\n/// functions leverage C syntax, Objective-C method syntax is modeled after\n/// Smalltalk (using colons to specify argument types/expressions).\n/// Here are some brief examples:\n///\n/// Setter/getter instance methods:\n/// - (void)setMenu:(NSMenu *)menu;\n/// - (NSMenu *)menu;\n///\n/// Instance method that takes 2 NSView arguments:\n/// - (void)replaceSubview:(NSView *)oldView with:(NSView *)newView;\n///\n/// Getter class method:\n/// + (NSMenu *)defaultMenu;\n///\n/// A selector represents a unique name for a method. The selector names for\n/// the above methods are setMenu:, menu, replaceSubview:with:, and defaultMenu.\n///\nclass ObjCMethodDecl : public NamedDecl, public DeclContext {\n  // This class stores some data in DeclContext::ObjCMethodDeclBits\n  // to save some space. Use the provided accessors to access it.\n\npublic:\n  enum ImplementationControl { None, Required, Optional };\n\nprivate:\n  /// Return type of this method.\n  QualType MethodDeclType;\n\n  /// Type source information for the return type.\n  TypeSourceInfo *ReturnTInfo;\n\n  /// Array of ParmVarDecls for the formal parameters of this method\n  /// and optionally followed by selector locations.\n  void *ParamsAndSelLocs = nullptr;\n  unsigned NumParams = 0;\n\n  /// List of attributes for this method declaration.\n  SourceLocation DeclEndLoc; // the location of the ';' or '{'.\n\n  /// The following are only used for method definitions, null otherwise.\n  LazyDeclStmtPtr Body;\n\n  /// SelfDecl - Decl for the implicit self parameter. This is lazily\n  /// constructed by createImplicitParams.\n  ImplicitParamDecl *SelfDecl = nullptr;\n\n  /// CmdDecl - Decl for the implicit _cmd parameter. This is lazily\n  /// constructed by createImplicitParams.\n  ImplicitParamDecl *CmdDecl = nullptr;\n\n  ObjCMethodDecl(SourceLocation beginLoc, SourceLocation endLoc,\n                 Selector SelInfo, QualType T, TypeSourceInfo *ReturnTInfo,\n                 DeclContext *contextDecl, bool isInstance = true,\n                 bool isVariadic = false, bool isPropertyAccessor = false,\n                 bool isSynthesizedAccessorStub = false, \n                 bool isImplicitlyDeclared = false, bool isDefined = false,\n                 ImplementationControl impControl = None,\n                 bool HasRelatedResultType = false);\n\n  SelectorLocationsKind getSelLocsKind() const {\n    return static_cast<SelectorLocationsKind>(ObjCMethodDeclBits.SelLocsKind);\n  }\n\n  void setSelLocsKind(SelectorLocationsKind Kind) {\n    ObjCMethodDeclBits.SelLocsKind = Kind;\n  }\n\n  bool hasStandardSelLocs() const {\n    return getSelLocsKind() != SelLoc_NonStandard;\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  SourceLocation *getStoredSelLocs() {\n    return reinterpret_cast<SourceLocation *>(getParams() + NumParams);\n  }\n  const SourceLocation *getStoredSelLocs() const {\n    return reinterpret_cast<const SourceLocation *>(getParams() + NumParams);\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  ParmVarDecl **getParams() {\n    return reinterpret_cast<ParmVarDecl **>(ParamsAndSelLocs);\n  }\n  const ParmVarDecl *const *getParams() const {\n    return reinterpret_cast<const ParmVarDecl *const *>(ParamsAndSelLocs);\n  }\n\n  /// Get the number of stored selector identifiers locations.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  unsigned getNumStoredSelLocs() const {\n    if (hasStandardSelLocs())\n      return 0;\n    return getNumSelectorLocs();\n  }\n\n  void setParamsAndSelLocs(ASTContext &C,\n                           ArrayRef<ParmVarDecl*> Params,\n                           ArrayRef<SourceLocation> SelLocs);\n\n  /// A definition will return its interface declaration.\n  /// An interface declaration will return its definition.\n  /// Otherwise it will return itself.\n  ObjCMethodDecl *getNextRedeclarationImpl() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCMethodDecl *\n  Create(ASTContext &C, SourceLocation beginLoc, SourceLocation endLoc,\n         Selector SelInfo, QualType T, TypeSourceInfo *ReturnTInfo,\n         DeclContext *contextDecl, bool isInstance = true,\n         bool isVariadic = false, bool isPropertyAccessor = false,\n         bool isSynthesizedAccessorStub = false,\n         bool isImplicitlyDeclared = false, bool isDefined = false,\n         ImplementationControl impControl = None,\n         bool HasRelatedResultType = false);\n\n  static ObjCMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCMethodDecl *getCanonicalDecl() override;\n  const ObjCMethodDecl *getCanonicalDecl() const {\n    return const_cast<ObjCMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    return static_cast<ObjCDeclQualifier>(ObjCMethodDeclBits.objcDeclQualifier);\n  }\n\n  void setObjCDeclQualifier(ObjCDeclQualifier QV) {\n    ObjCMethodDeclBits.objcDeclQualifier = QV;\n  }\n\n  /// Determine whether this method has a result type that is related\n  /// to the message receiver's type.\n  bool hasRelatedResultType() const {\n    return ObjCMethodDeclBits.RelatedResultType;\n  }\n\n  /// Note whether this method has a related result type.\n  void setRelatedResultType(bool RRT = true) {\n    ObjCMethodDeclBits.RelatedResultType = RRT;\n  }\n\n  /// True if this is a method redeclaration in the same interface.\n  bool isRedeclaration() const { return ObjCMethodDeclBits.IsRedeclaration; }\n  void setIsRedeclaration(bool RD) { ObjCMethodDeclBits.IsRedeclaration = RD; }\n  void setAsRedeclaration(const ObjCMethodDecl *PrevMethod);\n\n  /// True if redeclared in the same interface.\n  bool hasRedeclaration() const { return ObjCMethodDeclBits.HasRedeclaration; }\n  void setHasRedeclaration(bool HRD) const {\n    ObjCMethodDeclBits.HasRedeclaration = HRD;\n  }\n\n  /// Returns the location where the declarator ends. It will be\n  /// the location of ';' for a method declaration and the location of '{'\n  /// for a method definition.\n  SourceLocation getDeclaratorEndLoc() const { return DeclEndLoc; }\n\n  // Location information, modeled after the Stmt API.\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getEndLoc());\n  }\n\n  SourceLocation getSelectorStartLoc() const {\n    if (isImplicit())\n      return getBeginLoc();\n    return getSelectorLoc(0);\n  }\n\n  SourceLocation getSelectorLoc(unsigned Index) const {\n    assert(Index < getNumSelectorLocs() && \"Index out of range!\");\n    if (hasStandardSelLocs())\n      return getStandardSelectorLoc(Index, getSelector(),\n                                   getSelLocsKind() == SelLoc_StandardWithSpace,\n                                    parameters(),\n                                   DeclEndLoc);\n    return getStoredSelLocs()[Index];\n  }\n\n  void getSelectorLocs(SmallVectorImpl<SourceLocation> &SelLocs) const;\n\n  unsigned getNumSelectorLocs() const {\n    if (isImplicit())\n      return 0;\n    Selector Sel = getSelector();\n    if (Sel.isUnarySelector())\n      return 1;\n    return Sel.getNumArgs();\n  }\n\n  ObjCInterfaceDecl *getClassInterface();\n  const ObjCInterfaceDecl *getClassInterface() const {\n    return const_cast<ObjCMethodDecl*>(this)->getClassInterface();\n  }\n\n  /// If this method is declared or implemented in a category, return\n  /// that category.\n  ObjCCategoryDecl *getCategory();\n  const ObjCCategoryDecl *getCategory() const {\n    return const_cast<ObjCMethodDecl*>(this)->getCategory();\n  }\n\n  Selector getSelector() const { return getDeclName().getObjCSelector(); }\n\n  QualType getReturnType() const { return MethodDeclType; }\n  void setReturnType(QualType T) { MethodDeclType = T; }\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Determine the type of an expression that sends a message to this\n  /// function. This replaces the type parameters with the types they would\n  /// get if the receiver was parameterless (e.g. it may replace the type\n  /// parameter with 'id').\n  QualType getSendResultType() const;\n\n  /// Determine the type of an expression that sends a message to this\n  /// function with the given receiver type.\n  QualType getSendResultType(QualType receiverType) const;\n\n  TypeSourceInfo *getReturnTypeSourceInfo() const { return ReturnTInfo; }\n  void setReturnTypeSourceInfo(TypeSourceInfo *TInfo) { ReturnTInfo = TInfo; }\n\n  // Iterator access to formal parameters.\n  unsigned param_size() const { return NumParams; }\n\n  using param_const_iterator = const ParmVarDecl *const *;\n  using param_iterator = ParmVarDecl *const *;\n  using param_range = llvm::iterator_range<param_iterator>;\n  using param_const_range = llvm::iterator_range<param_const_iterator>;\n\n  param_const_iterator param_begin() const {\n    return param_const_iterator(getParams());\n  }\n\n  param_const_iterator param_end() const {\n    return param_const_iterator(getParams() + NumParams);\n  }\n\n  param_iterator param_begin() { return param_iterator(getParams()); }\n  param_iterator param_end() { return param_iterator(getParams() + NumParams); }\n\n  // This method returns and of the parameters which are part of the selector\n  // name mangling requirements.\n  param_const_iterator sel_param_end() const {\n    return param_begin() + getSelector().getNumArgs();\n  }\n\n  // ArrayRef access to formal parameters.  This should eventually\n  // replace the iterator interface above.\n  ArrayRef<ParmVarDecl*> parameters() const {\n    return llvm::makeArrayRef(const_cast<ParmVarDecl**>(getParams()),\n                              NumParams);\n  }\n\n  ParmVarDecl *getParamDecl(unsigned Idx) {\n    assert(Idx < NumParams && \"Index out of bounds!\");\n    return getParams()[Idx];\n  }\n  const ParmVarDecl *getParamDecl(unsigned Idx) const {\n    return const_cast<ObjCMethodDecl *>(this)->getParamDecl(Idx);\n  }\n\n  /// Sets the method's parameters and selector source locations.\n  /// If the method is implicit (not coming from source) \\p SelLocs is\n  /// ignored.\n  void setMethodParams(ASTContext &C,\n                       ArrayRef<ParmVarDecl*> Params,\n                       ArrayRef<SourceLocation> SelLocs = llvm::None);\n\n  // Iterator access to parameter types.\n  struct GetTypeFn {\n    QualType operator()(const ParmVarDecl *PD) const { return PD->getType(); }\n  };\n\n  using param_type_iterator =\n      llvm::mapped_iterator<param_const_iterator, GetTypeFn>;\n\n  param_type_iterator param_type_begin() const {\n    return llvm::map_iterator(param_begin(), GetTypeFn());\n  }\n\n  param_type_iterator param_type_end() const {\n    return llvm::map_iterator(param_end(), GetTypeFn());\n  }\n\n  /// createImplicitParams - Used to lazily create the self and cmd\n  /// implicit parameters. This must be called prior to using getSelfDecl()\n  /// or getCmdDecl(). The call is ignored if the implicit parameters\n  /// have already been created.\n  void createImplicitParams(ASTContext &Context, const ObjCInterfaceDecl *ID);\n\n  /// \\return the type for \\c self and set \\arg selfIsPseudoStrong and\n  /// \\arg selfIsConsumed accordingly.\n  QualType getSelfType(ASTContext &Context, const ObjCInterfaceDecl *OID,\n                       bool &selfIsPseudoStrong, bool &selfIsConsumed) const;\n\n  ImplicitParamDecl * getSelfDecl() const { return SelfDecl; }\n  void setSelfDecl(ImplicitParamDecl *SD) { SelfDecl = SD; }\n  ImplicitParamDecl * getCmdDecl() const { return CmdDecl; }\n  void setCmdDecl(ImplicitParamDecl *CD) { CmdDecl = CD; }\n\n  /// Determines the family of this method.\n  ObjCMethodFamily getMethodFamily() const;\n\n  bool isInstanceMethod() const { return ObjCMethodDeclBits.IsInstance; }\n  void setInstanceMethod(bool isInst) {\n    ObjCMethodDeclBits.IsInstance = isInst;\n  }\n\n  bool isVariadic() const { return ObjCMethodDeclBits.IsVariadic; }\n  void setVariadic(bool isVar) { ObjCMethodDeclBits.IsVariadic = isVar; }\n\n  bool isClassMethod() const { return !isInstanceMethod(); }\n\n  bool isPropertyAccessor() const {\n    return ObjCMethodDeclBits.IsPropertyAccessor;\n  }\n\n  void setPropertyAccessor(bool isAccessor) {\n    ObjCMethodDeclBits.IsPropertyAccessor = isAccessor;\n  }\n\n  bool isSynthesizedAccessorStub() const {\n    return ObjCMethodDeclBits.IsSynthesizedAccessorStub;\n  }\n\n  void setSynthesizedAccessorStub(bool isSynthesizedAccessorStub) {\n    ObjCMethodDeclBits.IsSynthesizedAccessorStub = isSynthesizedAccessorStub;\n  }\n\n  bool isDefined() const { return ObjCMethodDeclBits.IsDefined; }\n  void setDefined(bool isDefined) { ObjCMethodDeclBits.IsDefined = isDefined; }\n\n  /// Whether this method overrides any other in the class hierarchy.\n  ///\n  /// A method is said to override any method in the class's\n  /// base classes, its protocols, or its categories' protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  bool isOverriding() const { return ObjCMethodDeclBits.IsOverriding; }\n  void setOverriding(bool IsOver) { ObjCMethodDeclBits.IsOverriding = IsOver; }\n\n  /// Return overridden methods for the given \\p Method.\n  ///\n  /// An ObjC method is considered to override any method in the class's\n  /// base classes (and base's categories), its protocols, or its categories'\n  /// protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  void getOverriddenMethods(\n                     SmallVectorImpl<const ObjCMethodDecl *> &Overridden) const;\n\n  /// True if the method was a definition but its body was skipped.\n  bool hasSkippedBody() const { return ObjCMethodDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    ObjCMethodDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if the method is tagged as objc_direct\n  bool isDirectMethod() const;\n\n  /// Returns the property associated with this method's selector.\n  ///\n  /// Note that even if this particular method is not marked as a property\n  /// accessor, it is still possible for it to match a property declared in a\n  /// superclass. Pass \\c false if you only want to check the current class.\n  const ObjCPropertyDecl *findPropertyDecl(bool CheckOverrides = true) const;\n\n  // Related to protocols declared in  \\@protocol\n  void setDeclImplementation(ImplementationControl ic) {\n    ObjCMethodDeclBits.DeclImplementation = ic;\n  }\n\n  ImplementationControl getImplementationControl() const {\n    return ImplementationControl(ObjCMethodDeclBits.DeclImplementation);\n  }\n\n  bool isOptional() const {\n    return getImplementationControl() == Optional;\n  }\n\n  /// Returns true if this specific method declaration is marked with the\n  /// designated initializer attribute.\n  bool isThisDeclarationADesignatedInitializer() const;\n\n  /// Returns true if the method selector resolves to a designated initializer\n  /// in the class's interface.\n  ///\n  /// \\param InitMethod if non-null and the function returns true, it receives\n  /// the method declaration that was marked with the designated initializer\n  /// attribute.\n  bool isDesignatedInitializerForTheInterface(\n      const ObjCMethodDecl **InitMethod = nullptr) const;\n\n  /// Determine whether this method has a body.\n  bool hasBody() const override { return Body.isValid(); }\n\n  /// Retrieve the body of this method, if it has one.\n  Stmt *getBody() const override;\n\n  void setLazyBody(uint64_t Offset) { Body = Offset; }\n\n  CompoundStmt *getCompoundBody() { return (CompoundStmt*)getBody(); }\n  void setBody(Stmt *B) { Body = B; }\n\n  /// Returns whether this specific method is a definition.\n  bool isThisDeclarationADefinition() const { return hasBody(); }\n\n  /// Is this method defined in the NSObject base class?\n  bool definedInNSObject(const ASTContext &) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCMethod; }\n\n  static DeclContext *castToDeclContext(const ObjCMethodDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ObjCMethodDecl*>(D));\n  }\n\n  static ObjCMethodDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ObjCMethodDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Describes the variance of a given generic parameter.\nenum class ObjCTypeParamVariance : uint8_t {\n  /// The parameter is invariant: must match exactly.\n  Invariant,\n\n  /// The parameter is covariant, e.g., X<T> is a subtype of X<U> when\n  /// the type parameter is covariant and T is a subtype of U.\n  Covariant,\n\n  /// The parameter is contravariant, e.g., X<T> is a subtype of X<U>\n  /// when the type parameter is covariant and U is a subtype of T.\n  Contravariant,\n};\n\n/// Represents the declaration of an Objective-C type parameter.\n///\n/// \\code\n/// @interface NSDictionary<Key : id<NSCopying>, Value>\n/// @end\n/// \\endcode\n///\n/// In the example above, both \\c Key and \\c Value are represented by\n/// \\c ObjCTypeParamDecl. \\c Key has an explicit bound of \\c id<NSCopying>,\n/// while \\c Value gets an implicit bound of \\c id.\n///\n/// Objective-C type parameters are typedef-names in the grammar,\nclass ObjCTypeParamDecl : public TypedefNameDecl {\n  /// Index of this type parameter in the type parameter list.\n  unsigned Index : 14;\n\n  /// The variance of the type parameter.\n  unsigned Variance : 2;\n\n  /// The location of the variance, if any.\n  SourceLocation VarianceLoc;\n\n  /// The location of the ':', which will be valid when the bound was\n  /// explicitly specified.\n  SourceLocation ColonLoc;\n\n  ObjCTypeParamDecl(ASTContext &ctx, DeclContext *dc,\n                    ObjCTypeParamVariance variance, SourceLocation varianceLoc,\n                    unsigned index,\n                    SourceLocation nameLoc, IdentifierInfo *name,\n                    SourceLocation colonLoc, TypeSourceInfo *boundInfo)\n      : TypedefNameDecl(ObjCTypeParam, ctx, dc, nameLoc, nameLoc, name,\n                        boundInfo),\n        Index(index), Variance(static_cast<unsigned>(variance)),\n        VarianceLoc(varianceLoc), ColonLoc(colonLoc) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCTypeParamDecl *Create(ASTContext &ctx, DeclContext *dc,\n                                   ObjCTypeParamVariance variance,\n                                   SourceLocation varianceLoc,\n                                   unsigned index,\n                                   SourceLocation nameLoc,\n                                   IdentifierInfo *name,\n                                   SourceLocation colonLoc,\n                                   TypeSourceInfo *boundInfo);\n  static ObjCTypeParamDecl *CreateDeserialized(ASTContext &ctx, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Determine the variance of this type parameter.\n  ObjCTypeParamVariance getVariance() const {\n    return static_cast<ObjCTypeParamVariance>(Variance);\n  }\n\n  /// Set the variance of this type parameter.\n  void setVariance(ObjCTypeParamVariance variance) {\n    Variance = static_cast<unsigned>(variance);\n  }\n\n  /// Retrieve the location of the variance keyword.\n  SourceLocation getVarianceLoc() const { return VarianceLoc; }\n\n  /// Retrieve the index into its type parameter list.\n  unsigned getIndex() const { return Index; }\n\n  /// Whether this type parameter has an explicitly-written type bound, e.g.,\n  /// \"T : NSView\".\n  bool hasExplicitBound() const { return ColonLoc.isValid(); }\n\n  /// Retrieve the location of the ':' separating the type parameter name\n  /// from the explicitly-specified bound.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCTypeParam; }\n};\n\n/// Stores a list of Objective-C type parameters for a parameterized class\n/// or a category/extension thereof.\n///\n/// \\code\n/// @interface NSArray<T> // stores the <T>\n/// @end\n/// \\endcode\nclass ObjCTypeParamList final\n    : private llvm::TrailingObjects<ObjCTypeParamList, ObjCTypeParamDecl *> {\n  /// Location of the left and right angle brackets.\n  SourceRange Brackets;\n  /// The number of parameters in the list, which are tail-allocated.\n  unsigned NumParams;\n\n  ObjCTypeParamList(SourceLocation lAngleLoc,\n                    ArrayRef<ObjCTypeParamDecl *> typeParams,\n                    SourceLocation rAngleLoc);\n\npublic:\n  friend TrailingObjects;\n\n  /// Create a new Objective-C type parameter list.\n  static ObjCTypeParamList *create(ASTContext &ctx,\n                                   SourceLocation lAngleLoc,\n                                   ArrayRef<ObjCTypeParamDecl *> typeParams,\n                                   SourceLocation rAngleLoc);\n\n  /// Iterate through the type parameters in the list.\n  using iterator = ObjCTypeParamDecl **;\n\n  iterator begin() { return getTrailingObjects<ObjCTypeParamDecl *>(); }\n\n  iterator end() { return begin() + size(); }\n\n  /// Determine the number of type parameters in this list.\n  unsigned size() const { return NumParams; }\n\n  // Iterate through the type parameters in the list.\n  using const_iterator = ObjCTypeParamDecl * const *;\n\n  const_iterator begin() const {\n    return getTrailingObjects<ObjCTypeParamDecl *>();\n  }\n\n  const_iterator end() const {\n    return begin() + size();\n  }\n\n  ObjCTypeParamDecl *front() const {\n    assert(size() > 0 && \"empty Objective-C type parameter list\");\n    return *begin();\n  }\n\n  ObjCTypeParamDecl *back() const {\n    assert(size() > 0 && \"empty Objective-C type parameter list\");\n    return *(end() - 1);\n  }\n\n  SourceLocation getLAngleLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRAngleLoc() const { return Brackets.getEnd(); }\n  SourceRange getSourceRange() const { return Brackets; }\n\n  /// Gather the default set of type arguments to be substituted for\n  /// these type parameters when dealing with an unspecialized type.\n  void gatherDefaultTypeArgs(SmallVectorImpl<QualType> &typeArgs) const;\n};\n\nenum class ObjCPropertyQueryKind : uint8_t {\n  OBJC_PR_query_unknown = 0x00,\n  OBJC_PR_query_instance,\n  OBJC_PR_query_class\n};\n\n/// Represents one property declaration in an Objective-C interface.\n///\n/// For example:\n/// \\code{.mm}\n/// \\@property (assign, readwrite) int MyProperty;\n/// \\endcode\nclass ObjCPropertyDecl : public NamedDecl {\n  void anchor() override;\n\npublic:\n  enum SetterKind { Assign, Retain, Copy, Weak };\n  enum PropertyControl { None, Required, Optional };\n\nprivate:\n  // location of \\@property\n  SourceLocation AtLoc;\n\n  // location of '(' starting attribute list or null.\n  SourceLocation LParenLoc;\n\n  QualType DeclType;\n  TypeSourceInfo *DeclTypeSourceInfo;\n  unsigned PropertyAttributes : NumObjCPropertyAttrsBits;\n  unsigned PropertyAttributesAsWritten : NumObjCPropertyAttrsBits;\n\n  // \\@required/\\@optional\n  unsigned PropertyImplementation : 2;\n\n  // getter name of NULL if no getter\n  Selector GetterName;\n\n  // setter name of NULL if no setter\n  Selector SetterName;\n\n  // location of the getter attribute's value\n  SourceLocation GetterNameLoc;\n\n  // location of the setter attribute's value\n  SourceLocation SetterNameLoc;\n\n  // Declaration of getter instance method\n  ObjCMethodDecl *GetterMethodDecl = nullptr;\n\n  // Declaration of setter instance method\n  ObjCMethodDecl *SetterMethodDecl = nullptr;\n\n  // Synthesize ivar for this property\n  ObjCIvarDecl *PropertyIvarDecl = nullptr;\n\n  ObjCPropertyDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n                   SourceLocation AtLocation, SourceLocation LParenLocation,\n                   QualType T, TypeSourceInfo *TSI, PropertyControl propControl)\n      : NamedDecl(ObjCProperty, DC, L, Id), AtLoc(AtLocation),\n        LParenLoc(LParenLocation), DeclType(T), DeclTypeSourceInfo(TSI),\n        PropertyAttributes(ObjCPropertyAttribute::kind_noattr),\n        PropertyAttributesAsWritten(ObjCPropertyAttribute::kind_noattr),\n        PropertyImplementation(propControl), GetterName(Selector()),\n        SetterName(Selector()) {}\n\npublic:\n  static ObjCPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation L,\n                                  IdentifierInfo *Id, SourceLocation AtLocation,\n                                  SourceLocation LParenLocation,\n                                  QualType T,\n                                  TypeSourceInfo *TSI,\n                                  PropertyControl propControl = None);\n\n  static ObjCPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const { return DeclTypeSourceInfo; }\n\n  QualType getType() const { return DeclType; }\n\n  void setType(QualType T, TypeSourceInfo *TSI) {\n    DeclType = T;\n    DeclTypeSourceInfo = TSI;\n  }\n\n  /// Retrieve the type when this property is used with a specific base object\n  /// type.\n  QualType getUsageType(QualType objectType) const;\n\n  ObjCPropertyAttribute::Kind getPropertyAttributes() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributes);\n  }\n\n  void setPropertyAttributes(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributes |= PRVal;\n  }\n\n  void overwritePropertyAttributes(unsigned PRVal) {\n    PropertyAttributes = PRVal;\n  }\n\n  ObjCPropertyAttribute::Kind getPropertyAttributesAsWritten() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributesAsWritten);\n  }\n\n  void setPropertyAttributesAsWritten(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributesAsWritten = PRVal;\n  }\n\n  // Helper methods for accessing attributes.\n\n  /// isReadOnly - Return true iff the property has a setter.\n  bool isReadOnly() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_readonly);\n  }\n\n  /// isAtomic - Return true if the property is atomic.\n  bool isAtomic() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_atomic);\n  }\n\n  /// isRetaining - Return true if the property retains its value.\n  bool isRetaining() const {\n    return (PropertyAttributes & (ObjCPropertyAttribute::kind_retain |\n                                  ObjCPropertyAttribute::kind_strong |\n                                  ObjCPropertyAttribute::kind_copy));\n  }\n\n  bool isInstanceProperty() const { return !isClassProperty(); }\n  bool isClassProperty() const {\n    return PropertyAttributes & ObjCPropertyAttribute::kind_class;\n  }\n  bool isDirectProperty() const {\n    return PropertyAttributes & ObjCPropertyAttribute::kind_direct;\n  }\n\n  ObjCPropertyQueryKind getQueryKind() const {\n    return isClassProperty() ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                               ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  static ObjCPropertyQueryKind getQueryKind(bool isClassProperty) {\n    return isClassProperty ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                             ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  /// getSetterKind - Return the method used for doing assignment in\n  /// the property setter. This is only valid if the property has been\n  /// defined to have a setter.\n  SetterKind getSetterKind() const {\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_strong)\n      return getType()->isBlockPointerType() ? Copy : Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_retain)\n      return Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_copy)\n      return Copy;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_weak)\n      return Weak;\n    return Assign;\n  }\n\n  Selector getGetterName() const { return GetterName; }\n  SourceLocation getGetterNameLoc() const { return GetterNameLoc; }\n\n  void setGetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    GetterName = Sel;\n    GetterNameLoc = Loc;\n  }\n\n  Selector getSetterName() const { return SetterName; }\n  SourceLocation getSetterNameLoc() const { return SetterNameLoc; }\n\n  void setSetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    SetterName = Sel;\n    SetterNameLoc = Loc;\n  }\n\n  ObjCMethodDecl *getGetterMethodDecl() const { return GetterMethodDecl; }\n  void setGetterMethodDecl(ObjCMethodDecl *gDecl) { GetterMethodDecl = gDecl; }\n\n  ObjCMethodDecl *getSetterMethodDecl() const { return SetterMethodDecl; }\n  void setSetterMethodDecl(ObjCMethodDecl *gDecl) { SetterMethodDecl = gDecl; }\n\n  // Related to \\@optional/\\@required declared in \\@protocol\n  void setPropertyImplementation(PropertyControl pc) {\n    PropertyImplementation = pc;\n  }\n\n  PropertyControl getPropertyImplementation() const {\n    return PropertyControl(PropertyImplementation);\n  }\n\n  bool isOptional() const {\n    return getPropertyImplementation() == PropertyControl::Optional;\n  }\n\n  void setPropertyIvarDecl(ObjCIvarDecl *Ivar) {\n    PropertyIvarDecl = Ivar;\n  }\n\n  ObjCIvarDecl *getPropertyIvarDecl() const {\n    return PropertyIvarDecl;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(AtLoc, getLocation());\n  }\n\n  /// Get the default name of the synthesized ivar.\n  IdentifierInfo *getDefaultSynthIvarName(ASTContext &Ctx) const;\n\n  /// Lookup a property by name in the specified DeclContext.\n  static ObjCPropertyDecl *findPropertyDecl(const DeclContext *DC,\n                                            const IdentifierInfo *propertyID,\n                                            ObjCPropertyQueryKind queryKind);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCProperty; }\n};\n\n/// ObjCContainerDecl - Represents a container for method declarations.\n/// Current sub-classes are ObjCInterfaceDecl, ObjCCategoryDecl,\n/// ObjCProtocolDecl, and ObjCImplDecl.\n///\nclass ObjCContainerDecl : public NamedDecl, public DeclContext {\n  // This class stores some data in DeclContext::ObjCContainerDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  // These two locations in the range mark the end of the method container.\n  // The first points to the '@' token, and the second to the 'end' token.\n  SourceRange AtEnd;\n\n  void anchor() override;\n\npublic:\n  ObjCContainerDecl(Kind DK, DeclContext *DC, IdentifierInfo *Id,\n                    SourceLocation nameLoc, SourceLocation atStartLoc);\n\n  // Iterator access to instance/class properties.\n  using prop_iterator = specific_decl_iterator<ObjCPropertyDecl>;\n  using prop_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCPropertyDecl>>;\n\n  prop_range properties() const { return prop_range(prop_begin(), prop_end()); }\n\n  prop_iterator prop_begin() const {\n    return prop_iterator(decls_begin());\n  }\n\n  prop_iterator prop_end() const {\n    return prop_iterator(decls_end());\n  }\n\n  using instprop_iterator =\n      filtered_decl_iterator<ObjCPropertyDecl,\n                             &ObjCPropertyDecl::isInstanceProperty>;\n  using instprop_range = llvm::iterator_range<instprop_iterator>;\n\n  instprop_range instance_properties() const {\n    return instprop_range(instprop_begin(), instprop_end());\n  }\n\n  instprop_iterator instprop_begin() const {\n    return instprop_iterator(decls_begin());\n  }\n\n  instprop_iterator instprop_end() const {\n    return instprop_iterator(decls_end());\n  }\n\n  using classprop_iterator =\n      filtered_decl_iterator<ObjCPropertyDecl,\n                             &ObjCPropertyDecl::isClassProperty>;\n  using classprop_range = llvm::iterator_range<classprop_iterator>;\n\n  classprop_range class_properties() const {\n    return classprop_range(classprop_begin(), classprop_end());\n  }\n\n  classprop_iterator classprop_begin() const {\n    return classprop_iterator(decls_begin());\n  }\n\n  classprop_iterator classprop_end() const {\n    return classprop_iterator(decls_end());\n  }\n\n  // Iterator access to instance/class methods.\n  using method_iterator = specific_decl_iterator<ObjCMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(meth_begin(), meth_end());\n  }\n\n  method_iterator meth_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  method_iterator meth_end() const {\n    return method_iterator(decls_end());\n  }\n\n  using instmeth_iterator =\n      filtered_decl_iterator<ObjCMethodDecl,\n                             &ObjCMethodDecl::isInstanceMethod>;\n  using instmeth_range = llvm::iterator_range<instmeth_iterator>;\n\n  instmeth_range instance_methods() const {\n    return instmeth_range(instmeth_begin(), instmeth_end());\n  }\n\n  instmeth_iterator instmeth_begin() const {\n    return instmeth_iterator(decls_begin());\n  }\n\n  instmeth_iterator instmeth_end() const {\n    return instmeth_iterator(decls_end());\n  }\n\n  using classmeth_iterator =\n      filtered_decl_iterator<ObjCMethodDecl,\n                             &ObjCMethodDecl::isClassMethod>;\n  using classmeth_range = llvm::iterator_range<classmeth_iterator>;\n\n  classmeth_range class_methods() const {\n    return classmeth_range(classmeth_begin(), classmeth_end());\n  }\n\n  classmeth_iterator classmeth_begin() const {\n    return classmeth_iterator(decls_begin());\n  }\n\n  classmeth_iterator classmeth_end() const {\n    return classmeth_iterator(decls_end());\n  }\n\n  // Get the local instance/class method declared in this interface.\n  ObjCMethodDecl *getMethod(Selector Sel, bool isInstance,\n                            bool AllowHidden = false) const;\n\n  ObjCMethodDecl *getInstanceMethod(Selector Sel,\n                                    bool AllowHidden = false) const {\n    return getMethod(Sel, true/*isInstance*/, AllowHidden);\n  }\n\n  ObjCMethodDecl *getClassMethod(Selector Sel, bool AllowHidden = false) const {\n    return getMethod(Sel, false/*isInstance*/, AllowHidden);\n  }\n\n  bool HasUserDeclaredSetterMethod(const ObjCPropertyDecl *P) const;\n  ObjCIvarDecl *getIvarDecl(IdentifierInfo *Id) const;\n\n  ObjCPropertyDecl *\n  FindPropertyDeclaration(const IdentifierInfo *PropertyId,\n                          ObjCPropertyQueryKind QueryKind) const;\n\n  using PropertyMap =\n      llvm::DenseMap<std::pair<IdentifierInfo *, unsigned/*isClassProperty*/>,\n                     ObjCPropertyDecl *>;\n  using ProtocolPropertySet = llvm::SmallDenseSet<const ObjCProtocolDecl *, 8>;\n  using PropertyDeclOrder = llvm::SmallVector<ObjCPropertyDecl *, 8>;\n\n  /// This routine collects list of properties to be implemented in the class.\n  /// This includes, class's and its conforming protocols' properties.\n  /// Note, the superclass's properties are not included in the list.\n  virtual void collectPropertiesToImplement(PropertyMap &PM,\n                                            PropertyDeclOrder &PO) const {}\n\n  SourceLocation getAtStartLoc() const { return ObjCContainerDeclBits.AtStart; }\n\n  void setAtStartLoc(SourceLocation Loc) {\n    ObjCContainerDeclBits.AtStart = Loc;\n  }\n\n  // Marks the end of the container.\n  SourceRange getAtEndRange() const { return AtEnd; }\n\n  void setAtEndRange(SourceRange atEnd) { AtEnd = atEnd; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAtStartLoc(), getAtEndRange().getEnd());\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstObjCContainer &&\n           K <= lastObjCContainer;\n  }\n\n  static DeclContext *castToDeclContext(const ObjCContainerDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ObjCContainerDecl*>(D));\n  }\n\n  static ObjCContainerDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ObjCContainerDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an ObjC class declaration.\n///\n/// For example:\n///\n/// \\code\n///   // MostPrimitive declares no super class (not particularly useful).\n///   \\@interface MostPrimitive\n///     // no instance variables or methods.\n///   \\@end\n///\n///   // NSResponder inherits from NSObject & implements NSCoding (a protocol).\n///   \\@interface NSResponder : NSObject \\<NSCoding>\n///   { // instance variables are represented by ObjCIvarDecl.\n///     id nextResponder; // nextResponder instance variable.\n///   }\n///   - (NSResponder *)nextResponder; // return a pointer to NSResponder.\n///   - (void)mouseMoved:(NSEvent *)theEvent; // return void, takes a pointer\n///   \\@end                                    // to an NSEvent.\n/// \\endcode\n///\n///   Unlike C/C++, forward class declarations are accomplished with \\@class.\n///   Unlike C/C++, \\@class allows for a list of classes to be forward declared.\n///   Unlike C++, ObjC is a single-rooted class model. In Cocoa, classes\n///   typically inherit from NSObject (an exception is NSProxy).\n///\nclass ObjCInterfaceDecl : public ObjCContainerDecl\n                        , public Redeclarable<ObjCInterfaceDecl> {\n  friend class ASTContext;\n\n  /// TypeForDecl - This indicates the Type object that represents this\n  /// TypeDecl.  It is a cache maintained by ASTContext::getObjCInterfaceType\n  mutable const Type *TypeForDecl = nullptr;\n\n  struct DefinitionData {\n    /// The definition of this class, for quick access from any\n    /// declaration.\n    ObjCInterfaceDecl *Definition = nullptr;\n\n    /// When non-null, this is always an ObjCObjectType.\n    TypeSourceInfo *SuperClassTInfo = nullptr;\n\n    /// Protocols referenced in the \\@interface  declaration\n    ObjCProtocolList ReferencedProtocols;\n\n    /// Protocols reference in both the \\@interface and class extensions.\n    ObjCList<ObjCProtocolDecl> AllReferencedProtocols;\n\n    /// List of categories and class extensions defined for this class.\n    ///\n    /// Categories are stored as a linked list in the AST, since the categories\n    /// and class extensions come long after the initial interface declaration,\n    /// and we avoid dynamically-resized arrays in the AST wherever possible.\n    ObjCCategoryDecl *CategoryList = nullptr;\n\n    /// IvarList - List of all ivars defined by this class; including class\n    /// extensions and implementation. This list is built lazily.\n    ObjCIvarDecl *IvarList = nullptr;\n\n    /// Indicates that the contents of this Objective-C class will be\n    /// completed by the external AST source when required.\n    mutable unsigned ExternallyCompleted : 1;\n\n    /// Indicates that the ivar cache does not yet include ivars\n    /// declared in the implementation.\n    mutable unsigned IvarListMissingImplementation : 1;\n\n    /// Indicates that this interface decl contains at least one initializer\n    /// marked with the 'objc_designated_initializer' attribute.\n    unsigned HasDesignatedInitializers : 1;\n\n    enum InheritedDesignatedInitializersState {\n      /// We didn't calculate whether the designated initializers should be\n      /// inherited or not.\n      IDI_Unknown = 0,\n\n      /// Designated initializers are inherited for the super class.\n      IDI_Inherited = 1,\n\n      /// The class does not inherit designated initializers.\n      IDI_NotInherited = 2\n    };\n\n    /// One of the \\c InheritedDesignatedInitializersState enumeratos.\n    mutable unsigned InheritedDesignatedInitializers : 2;\n\n    /// The location of the last location in this declaration, before\n    /// the properties/methods. For example, this will be the '>', '}', or\n    /// identifier,\n    SourceLocation EndLoc;\n\n    DefinitionData()\n        : ExternallyCompleted(false), IvarListMissingImplementation(true),\n          HasDesignatedInitializers(false),\n          InheritedDesignatedInitializers(IDI_Unknown) {}\n  };\n\n  /// The type parameters associated with this class, if any.\n  ObjCTypeParamList *TypeParamList = nullptr;\n\n  /// Contains a pointer to the data associated with this class,\n  /// which will be NULL if this class has not yet been defined.\n  ///\n  /// The bit indicates when we don't need to check for out-of-date\n  /// declarations. It will be set unless modules are enabled.\n  llvm::PointerIntPair<DefinitionData *, 1, bool> Data;\n\n  ObjCInterfaceDecl(const ASTContext &C, DeclContext *DC, SourceLocation AtLoc,\n                    IdentifierInfo *Id, ObjCTypeParamList *typeParamList,\n                    SourceLocation CLoc, ObjCInterfaceDecl *PrevDecl,\n                    bool IsInternal);\n\n  void anchor() override;\n\n  void LoadExternalDefinition() const;\n\n  DefinitionData &data() const {\n    assert(Data.getPointer() && \"Declaration has no definition!\");\n    return *Data.getPointer();\n  }\n\n  /// Allocate the definition data for this class.\n  void allocateDefinitionData();\n\n  using redeclarable_base = Redeclarable<ObjCInterfaceDecl>;\n\n  ObjCInterfaceDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  ObjCInterfaceDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  ObjCInterfaceDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  static ObjCInterfaceDecl *Create(const ASTContext &C, DeclContext *DC,\n                                   SourceLocation atLoc,\n                                   IdentifierInfo *Id,\n                                   ObjCTypeParamList *typeParamList,\n                                   ObjCInterfaceDecl *PrevDecl,\n                                   SourceLocation ClassLoc = SourceLocation(),\n                                   bool isInternal = false);\n\n  static ObjCInterfaceDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  /// Retrieve the type parameters of this class.\n  ///\n  /// This function looks for a type parameter list for the given\n  /// class; if the class has been declared (with \\c \\@class) but not\n  /// defined (with \\c \\@interface), it will search for a declaration that\n  /// has type parameters, skipping any declarations that do not.\n  ObjCTypeParamList *getTypeParamList() const;\n\n  /// Set the type parameters of this class.\n  ///\n  /// This function is used by the AST importer, which must import the type\n  /// parameters after creating their DeclContext to avoid loops.\n  void setTypeParamList(ObjCTypeParamList *TPL);\n\n  /// Retrieve the type parameters written on this particular declaration of\n  /// the class.\n  ObjCTypeParamList *getTypeParamListAsWritten() const {\n    return TypeParamList;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (isThisDeclarationADefinition())\n      return ObjCContainerDecl::getSourceRange();\n\n    return SourceRange(getAtStartLoc(), getLocation());\n  }\n\n  /// Indicate that this Objective-C class is complete, but that\n  /// the external AST source will be responsible for filling in its contents\n  /// when a complete class is required.\n  void setExternallyCompleted();\n\n  /// Indicate that this interface decl contains at least one initializer\n  /// marked with the 'objc_designated_initializer' attribute.\n  void setHasDesignatedInitializers();\n\n  /// Returns true if this interface decl contains at least one initializer\n  /// marked with the 'objc_designated_initializer' attribute.\n  bool hasDesignatedInitializers() const;\n\n  /// Returns true if this interface decl declares a designated initializer\n  /// or it inherites one from its super class.\n  bool declaresOrInheritsDesignatedInitializers() const {\n    return hasDesignatedInitializers() || inheritsDesignatedInitializers();\n  }\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    assert(hasDefinition() && \"Caller did not check for forward reference!\");\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols;\n  }\n\n  ObjCImplementationDecl *getImplementation() const;\n  void setImplementation(ObjCImplementationDecl *ImplD);\n\n  ObjCCategoryDecl *FindCategoryDeclaration(IdentifierInfo *CategoryId) const;\n\n  // Get the local instance/class method declared in a category.\n  ObjCMethodDecl *getCategoryInstanceMethod(Selector Sel) const;\n  ObjCMethodDecl *getCategoryClassMethod(Selector Sel) const;\n\n  ObjCMethodDecl *getCategoryMethod(Selector Sel, bool isInstance) const {\n    return isInstance ? getCategoryInstanceMethod(Sel)\n                      : getCategoryClassMethod(Sel);\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.end();\n  }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.loc_end();\n  }\n\n  using all_protocol_iterator = ObjCList<ObjCProtocolDecl>::iterator;\n  using all_protocol_range = llvm::iterator_range<all_protocol_iterator>;\n\n  all_protocol_range all_referenced_protocols() const {\n    return all_protocol_range(all_referenced_protocol_begin(),\n                              all_referenced_protocol_end());\n  }\n\n  all_protocol_iterator all_referenced_protocol_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return all_protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().AllReferencedProtocols.empty()\n             ? protocol_begin()\n             : data().AllReferencedProtocols.begin();\n  }\n\n  all_protocol_iterator all_referenced_protocol_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return all_protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().AllReferencedProtocols.empty()\n             ? protocol_end()\n             : data().AllReferencedProtocols.end();\n  }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    if (const ObjCInterfaceDecl *Def = getDefinition())\n      return ivar_iterator(Def->decls_begin());\n\n    // FIXME: Should make sure no callers ever do this.\n    return ivar_iterator();\n  }\n\n  ivar_iterator ivar_end() const {\n    if (const ObjCInterfaceDecl *Def = getDefinition())\n      return ivar_iterator(Def->decls_end());\n\n    // FIXME: Should make sure no callers ever do this.\n    return ivar_iterator();\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const { return ivar_begin() == ivar_end(); }\n\n  ObjCIvarDecl *all_declared_ivar_begin();\n  const ObjCIvarDecl *all_declared_ivar_begin() const {\n    // Even though this modifies IvarList, it's conceptually const:\n    // the ivar chain is essentially a cached property of ObjCInterfaceDecl.\n    return const_cast<ObjCInterfaceDecl *>(this)->all_declared_ivar_begin();\n  }\n  void setIvarList(ObjCIvarDecl *ivar) { data().IvarList = ivar; }\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const* List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    data().ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  /// mergeClassExtensionProtocolList - Merge class extension's protocol list\n  /// into the protocol list for this class.\n  void mergeClassExtensionProtocolList(ObjCProtocolDecl *const* List,\n                                       unsigned Num,\n                                       ASTContext &C);\n\n  /// Produce a name to be used for class's metadata. It comes either via\n  /// objc_runtime_name attribute or class name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  /// Returns the designated initializers for the interface.\n  ///\n  /// If this declaration does not have methods marked as designated\n  /// initializers then the interface inherits the designated initializers of\n  /// its super class.\n  void getDesignatedInitializers(\n                  llvm::SmallVectorImpl<const ObjCMethodDecl *> &Methods) const;\n\n  /// Returns true if the given selector is a designated initializer for the\n  /// interface.\n  ///\n  /// If this declaration does not have methods marked as designated\n  /// initializers then the interface inherits the designated initializers of\n  /// its super class.\n  ///\n  /// \\param InitMethod if non-null and the function returns true, it receives\n  /// the method that was marked as a designated initializer.\n  bool\n  isDesignatedInitializer(Selector Sel,\n                          const ObjCMethodDecl **InitMethod = nullptr) const;\n\n  /// Determine whether this particular declaration of this class is\n  /// actually also a definition.\n  bool isThisDeclarationADefinition() const {\n    return getDefinition() == this;\n  }\n\n  /// Determine whether this class has been defined.\n  bool hasDefinition() const {\n    // If the name of this class is out-of-date, bring it up-to-date, which\n    // might bring in a definition.\n    // Note: a null value indicates that we don't have a definition and that\n    // modules are enabled.\n    if (!Data.getOpaqueValue())\n      getMostRecentDecl();\n\n    return Data.getPointer();\n  }\n\n  /// Retrieve the definition of this class, or NULL if this class\n  /// has been forward-declared (with \\@class) but not yet defined (with\n  /// \\@interface).\n  ObjCInterfaceDecl *getDefinition() {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Retrieve the definition of this class, or NULL if this class\n  /// has been forward-declared (with \\@class) but not yet defined (with\n  /// \\@interface).\n  const ObjCInterfaceDecl *getDefinition() const {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Starts the definition of this Objective-C class, taking it from\n  /// a forward declaration (\\@class) to a definition (\\@interface).\n  void startDefinition();\n\n  /// Retrieve the superclass type.\n  const ObjCObjectType *getSuperClassType() const {\n    if (TypeSourceInfo *TInfo = getSuperClassTInfo())\n      return TInfo->getType()->castAs<ObjCObjectType>();\n\n    return nullptr;\n  }\n\n  // Retrieve the type source information for the superclass.\n  TypeSourceInfo *getSuperClassTInfo() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return nullptr;\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().SuperClassTInfo;\n  }\n\n  // Retrieve the declaration for the superclass of this class, which\n  // does not include any type arguments that apply to the superclass.\n  ObjCInterfaceDecl *getSuperClass() const;\n\n  void setSuperClass(TypeSourceInfo *superClass) {\n    data().SuperClassTInfo = superClass;\n  }\n\n  /// Iterator that walks over the list of categories, filtering out\n  /// those that do not meet specific criteria.\n  ///\n  /// This class template is used for the various permutations of category\n  /// and extension iterators.\n  template<bool (*Filter)(ObjCCategoryDecl *)>\n  class filtered_category_iterator {\n    ObjCCategoryDecl *Current = nullptr;\n\n    void findAcceptableCategory();\n\n  public:\n    using value_type = ObjCCategoryDecl *;\n    using reference = value_type;\n    using pointer = value_type;\n    using difference_type = std::ptrdiff_t;\n    using iterator_category = std::input_iterator_tag;\n\n    filtered_category_iterator() = default;\n    explicit filtered_category_iterator(ObjCCategoryDecl *Current)\n        : Current(Current) {\n      findAcceptableCategory();\n    }\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    filtered_category_iterator &operator++();\n\n    filtered_category_iterator operator++(int) {\n      filtered_category_iterator Tmp = *this;\n      ++(*this);\n      return Tmp;\n    }\n\n    friend bool operator==(filtered_category_iterator X,\n                           filtered_category_iterator Y) {\n      return X.Current == Y.Current;\n    }\n\n    friend bool operator!=(filtered_category_iterator X,\n                           filtered_category_iterator Y) {\n      return X.Current != Y.Current;\n    }\n  };\n\nprivate:\n  /// Test whether the given category is visible.\n  ///\n  /// Used in the \\c visible_categories_iterator.\n  static bool isVisibleCategory(ObjCCategoryDecl *Cat);\n\npublic:\n  /// Iterator that walks over the list of categories and extensions\n  /// that are visible, i.e., not hidden in a non-imported submodule.\n  using visible_categories_iterator =\n      filtered_category_iterator<isVisibleCategory>;\n\n  using visible_categories_range =\n      llvm::iterator_range<visible_categories_iterator>;\n\n  visible_categories_range visible_categories() const {\n    return visible_categories_range(visible_categories_begin(),\n                                    visible_categories_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the visible-categories\n  /// list.\n  visible_categories_iterator visible_categories_begin() const {\n    return visible_categories_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the visible-categories list.\n  visible_categories_iterator visible_categories_end() const {\n    return visible_categories_iterator();\n  }\n\n  /// Determine whether the visible-categories list is empty.\n  bool visible_categories_empty() const {\n    return visible_categories_begin() == visible_categories_end();\n  }\n\nprivate:\n  /// Test whether the given category... is a category.\n  ///\n  /// Used in the \\c known_categories_iterator.\n  static bool isKnownCategory(ObjCCategoryDecl *) { return true; }\n\npublic:\n  /// Iterator that walks over all of the known categories and\n  /// extensions, including those that are hidden.\n  using known_categories_iterator = filtered_category_iterator<isKnownCategory>;\n  using known_categories_range =\n     llvm::iterator_range<known_categories_iterator>;\n\n  known_categories_range known_categories() const {\n    return known_categories_range(known_categories_begin(),\n                                  known_categories_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the known-categories\n  /// list.\n  known_categories_iterator known_categories_begin() const {\n    return known_categories_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the known-categories list.\n  known_categories_iterator known_categories_end() const {\n    return known_categories_iterator();\n  }\n\n  /// Determine whether the known-categories list is empty.\n  bool known_categories_empty() const {\n    return known_categories_begin() == known_categories_end();\n  }\n\nprivate:\n  /// Test whether the given category is a visible extension.\n  ///\n  /// Used in the \\c visible_extensions_iterator.\n  static bool isVisibleExtension(ObjCCategoryDecl *Cat);\n\npublic:\n  /// Iterator that walks over all of the visible extensions, skipping\n  /// any that are known but hidden.\n  using visible_extensions_iterator =\n      filtered_category_iterator<isVisibleExtension>;\n\n  using visible_extensions_range =\n      llvm::iterator_range<visible_extensions_iterator>;\n\n  visible_extensions_range visible_extensions() const {\n    return visible_extensions_range(visible_extensions_begin(),\n                                    visible_extensions_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the visible-extensions\n  /// list.\n  visible_extensions_iterator visible_extensions_begin() const {\n    return visible_extensions_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the visible-extensions list.\n  visible_extensions_iterator visible_extensions_end() const {\n    return visible_extensions_iterator();\n  }\n\n  /// Determine whether the visible-extensions list is empty.\n  bool visible_extensions_empty() const {\n    return visible_extensions_begin() == visible_extensions_end();\n  }\n\nprivate:\n  /// Test whether the given category is an extension.\n  ///\n  /// Used in the \\c known_extensions_iterator.\n  static bool isKnownExtension(ObjCCategoryDecl *Cat);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n\n  /// Iterator that walks over all of the known extensions.\n  using known_extensions_iterator =\n      filtered_category_iterator<isKnownExtension>;\n  using known_extensions_range =\n      llvm::iterator_range<known_extensions_iterator>;\n\n  known_extensions_range known_extensions() const {\n    return known_extensions_range(known_extensions_begin(),\n                                  known_extensions_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the known-extensions\n  /// list.\n  known_extensions_iterator known_extensions_begin() const {\n    return known_extensions_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the known-extensions list.\n  known_extensions_iterator known_extensions_end() const {\n    return known_extensions_iterator();\n  }\n\n  /// Determine whether the known-extensions list is empty.\n  bool known_extensions_empty() const {\n    return known_extensions_begin() == known_extensions_end();\n  }\n\n  /// Retrieve the raw pointer to the start of the category/extension\n  /// list.\n  ObjCCategoryDecl* getCategoryListRaw() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return nullptr;\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().CategoryList;\n  }\n\n  /// Set the raw pointer to the start of the category/extension\n  /// list.\n  void setCategoryListRaw(ObjCCategoryDecl *category) {\n    data().CategoryList = category;\n  }\n\n  ObjCPropertyDecl\n    *FindPropertyVisibleInPrimaryClass(IdentifierInfo *PropertyId,\n                                       ObjCPropertyQueryKind QueryKind) const;\n\n  void collectPropertiesToImplement(PropertyMap &PM,\n                                    PropertyDeclOrder &PO) const override;\n\n  /// isSuperClassOf - Return true if this class is the specified class or is a\n  /// super class of the specified interface class.\n  bool isSuperClassOf(const ObjCInterfaceDecl *I) const {\n    // If RHS is derived from LHS it is OK; else it is not OK.\n    while (I != nullptr) {\n      if (declaresSameEntity(this, I))\n        return true;\n\n      I = I->getSuperClass();\n    }\n    return false;\n  }\n\n  /// isArcWeakrefUnavailable - Checks for a class or one of its super classes\n  /// to be incompatible with __weak references. Returns true if it is.\n  bool isArcWeakrefUnavailable() const;\n\n  /// isObjCRequiresPropertyDefs - Checks that a class or one of its super\n  /// classes must not be auto-synthesized. Returns class decl. if it must not\n  /// be; 0, otherwise.\n  const ObjCInterfaceDecl *isObjCRequiresPropertyDefs() const;\n\n  ObjCIvarDecl *lookupInstanceVariable(IdentifierInfo *IVarName,\n                                       ObjCInterfaceDecl *&ClassDeclared);\n  ObjCIvarDecl *lookupInstanceVariable(IdentifierInfo *IVarName) {\n    ObjCInterfaceDecl *ClassDeclared;\n    return lookupInstanceVariable(IVarName, ClassDeclared);\n  }\n\n  ObjCProtocolDecl *lookupNestedProtocol(IdentifierInfo *Name);\n\n  // Lookup a method. First, we search locally. If a method isn't\n  // found, we search referenced protocols and class categories.\n  ObjCMethodDecl *lookupMethod(Selector Sel, bool isInstance,\n                               bool shallowCategoryLookup = false,\n                               bool followSuper = true,\n                               const ObjCCategoryDecl *C = nullptr) const;\n\n  /// Lookup an instance method for a given selector.\n  ObjCMethodDecl *lookupInstanceMethod(Selector Sel) const {\n    return lookupMethod(Sel, true/*isInstance*/);\n  }\n\n  /// Lookup a class method for a given selector.\n  ObjCMethodDecl *lookupClassMethod(Selector Sel) const {\n    return lookupMethod(Sel, false/*isInstance*/);\n  }\n\n  ObjCInterfaceDecl *lookupInheritedClass(const IdentifierInfo *ICName);\n\n  /// Lookup a method in the classes implementation hierarchy.\n  ObjCMethodDecl *lookupPrivateMethod(const Selector &Sel,\n                                      bool Instance=true) const;\n\n  ObjCMethodDecl *lookupPrivateClassMethod(const Selector &Sel) {\n    return lookupPrivateMethod(Sel, false);\n  }\n\n  /// Lookup a setter or getter in the class hierarchy,\n  /// including in all categories except for category passed\n  /// as argument.\n  ObjCMethodDecl *lookupPropertyAccessor(const Selector Sel,\n                                         const ObjCCategoryDecl *Cat,\n                                         bool IsClassProperty) const {\n    return lookupMethod(Sel, !IsClassProperty/*isInstance*/,\n                        false/*shallowCategoryLookup*/,\n                        true /* followsSuper */,\n                        Cat);\n  }\n\n  SourceLocation getEndOfDefinitionLoc() const {\n    if (!hasDefinition())\n      return getLocation();\n\n    return data().EndLoc;\n  }\n\n  void setEndOfDefinitionLoc(SourceLocation LE) { data().EndLoc = LE; }\n\n  /// Retrieve the starting location of the superclass.\n  SourceLocation getSuperClassLoc() const;\n\n  /// isImplicitInterfaceDecl - check that this is an implicitly declared\n  /// ObjCInterfaceDecl node. This is for legacy objective-c \\@implementation\n  /// declaration without an \\@interface declaration.\n  bool isImplicitInterfaceDecl() const {\n    return hasDefinition() ? data().Definition->isImplicit() : isImplicit();\n  }\n\n  /// ClassImplementsProtocol - Checks that 'lProto' protocol\n  /// has been implemented in IDecl class, its super class or categories (if\n  /// lookupCategory is true).\n  bool ClassImplementsProtocol(ObjCProtocolDecl *lProto,\n                               bool lookupCategory,\n                               bool RHSIsQualifiedID = false);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Retrieves the canonical declaration of this Objective-C class.\n  ObjCInterfaceDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ObjCInterfaceDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Low-level accessor\n  const Type *getTypeForDecl() const { return TypeForDecl; }\n  void setTypeForDecl(const Type *TD) const { TypeForDecl = TD; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCInterface; }\n\nprivate:\n  const ObjCInterfaceDecl *findInterfaceWithDesignatedInitializers() const;\n  bool inheritsDesignatedInitializers() const;\n};\n\n/// ObjCIvarDecl - Represents an ObjC instance variable. In general, ObjC\n/// instance variables are identical to C. The only exception is Objective-C\n/// supports C++ style access control. For example:\n///\n///   \\@interface IvarExample : NSObject\n///   {\n///     id defaultToProtected;\n///   \\@public:\n///     id canBePublic; // same as C++.\n///   \\@protected:\n///     id canBeProtected; // same as C++.\n///   \\@package:\n///     id canBePackage; // framework visibility (not available in C++).\n///   }\n///\nclass ObjCIvarDecl : public FieldDecl {\n  void anchor() override;\n\npublic:\n  enum AccessControl {\n    None, Private, Protected, Public, Package\n  };\n\nprivate:\n  ObjCIvarDecl(ObjCContainerDecl *DC, SourceLocation StartLoc,\n               SourceLocation IdLoc, IdentifierInfo *Id,\n               QualType T, TypeSourceInfo *TInfo, AccessControl ac, Expr *BW,\n               bool synthesized)\n      : FieldDecl(ObjCIvar, DC, StartLoc, IdLoc, Id, T, TInfo, BW,\n                  /*Mutable=*/false, /*HasInit=*/ICIS_NoInit),\n        DeclAccess(ac), Synthesized(synthesized) {}\n\npublic:\n  static ObjCIvarDecl *Create(ASTContext &C, ObjCContainerDecl *DC,\n                              SourceLocation StartLoc, SourceLocation IdLoc,\n                              IdentifierInfo *Id, QualType T,\n                              TypeSourceInfo *TInfo,\n                              AccessControl ac, Expr *BW = nullptr,\n                              bool synthesized=false);\n\n  static ObjCIvarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the class interface that this ivar is logically contained\n  /// in; this is either the interface where the ivar was declared, or the\n  /// interface the ivar is conceptually a part of in the case of synthesized\n  /// ivars.\n  const ObjCInterfaceDecl *getContainingInterface() const;\n\n  ObjCIvarDecl *getNextIvar() { return NextIvar; }\n  const ObjCIvarDecl *getNextIvar() const { return NextIvar; }\n  void setNextIvar(ObjCIvarDecl *ivar) { NextIvar = ivar; }\n\n  void setAccessControl(AccessControl ac) { DeclAccess = ac; }\n\n  AccessControl getAccessControl() const { return AccessControl(DeclAccess); }\n\n  AccessControl getCanonicalAccessControl() const {\n    return DeclAccess == None ? Protected : AccessControl(DeclAccess);\n  }\n\n  void setSynthesize(bool synth) { Synthesized = synth; }\n  bool getSynthesize() const { return Synthesized; }\n\n  /// Retrieve the type of this instance variable when viewed as a member of a\n  /// specific object type.\n  QualType getUsageType(QualType objectType) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCIvar; }\n\nprivate:\n  /// NextIvar - Next Ivar in the list of ivars declared in class; class's\n  /// extensions and class's implementation\n  ObjCIvarDecl *NextIvar = nullptr;\n\n  // NOTE: VC++ treats enums as signed, avoid using the AccessControl enum\n  unsigned DeclAccess : 3;\n  unsigned Synthesized : 1;\n};\n\n/// Represents a field declaration created by an \\@defs(...).\nclass ObjCAtDefsFieldDecl : public FieldDecl {\n  ObjCAtDefsFieldDecl(DeclContext *DC, SourceLocation StartLoc,\n                      SourceLocation IdLoc, IdentifierInfo *Id,\n                      QualType T, Expr *BW)\n      : FieldDecl(ObjCAtDefsField, DC, StartLoc, IdLoc, Id, T,\n                  /*TInfo=*/nullptr, // FIXME: Do ObjCAtDefs have declarators ?\n                  BW, /*Mutable=*/false, /*HasInit=*/ICIS_NoInit) {}\n\n  void anchor() override;\n\npublic:\n  static ObjCAtDefsFieldDecl *Create(ASTContext &C, DeclContext *DC,\n                                     SourceLocation StartLoc,\n                                     SourceLocation IdLoc, IdentifierInfo *Id,\n                                     QualType T, Expr *BW);\n\n  static ObjCAtDefsFieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCAtDefsField; }\n};\n\n/// Represents an Objective-C protocol declaration.\n///\n/// Objective-C protocols declare a pure abstract type (i.e., no instance\n/// variables are permitted).  Protocols originally drew inspiration from\n/// C++ pure virtual functions (a C++ feature with nice semantics and lousy\n/// syntax:-). Here is an example:\n///\n/// \\code\n/// \\@protocol NSDraggingInfo <refproto1, refproto2>\n/// - (NSWindow *)draggingDestinationWindow;\n/// - (NSImage *)draggedImage;\n/// \\@end\n/// \\endcode\n///\n/// This says that NSDraggingInfo requires two methods and requires everything\n/// that the two \"referenced protocols\" 'refproto1' and 'refproto2' require as\n/// well.\n///\n/// \\code\n/// \\@interface ImplementsNSDraggingInfo : NSObject \\<NSDraggingInfo>\n/// \\@end\n/// \\endcode\n///\n/// ObjC protocols inspired Java interfaces. Unlike Java, ObjC classes and\n/// protocols are in distinct namespaces. For example, Cocoa defines both\n/// an NSObject protocol and class (which isn't allowed in Java). As a result,\n/// protocols are referenced using angle brackets as follows:\n///\n/// id \\<NSDraggingInfo> anyObjectThatImplementsNSDraggingInfo;\nclass ObjCProtocolDecl : public ObjCContainerDecl,\n                         public Redeclarable<ObjCProtocolDecl> {\n  struct DefinitionData {\n    // The declaration that defines this protocol.\n    ObjCProtocolDecl *Definition;\n\n    /// Referenced protocols\n    ObjCProtocolList ReferencedProtocols;\n  };\n\n  /// Contains a pointer to the data associated with this class,\n  /// which will be NULL if this class has not yet been defined.\n  ///\n  /// The bit indicates when we don't need to check for out-of-date\n  /// declarations. It will be set unless modules are enabled.\n  llvm::PointerIntPair<DefinitionData *, 1, bool> Data;\n\n  ObjCProtocolDecl(ASTContext &C, DeclContext *DC, IdentifierInfo *Id,\n                   SourceLocation nameLoc, SourceLocation atStartLoc,\n                   ObjCProtocolDecl *PrevDecl);\n\n  void anchor() override;\n\n  DefinitionData &data() const {\n    assert(Data.getPointer() && \"Objective-C protocol has no definition!\");\n    return *Data.getPointer();\n  }\n\n  void allocateDefinitionData();\n\n  using redeclarable_base = Redeclarable<ObjCProtocolDecl>;\n\n  ObjCProtocolDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  ObjCProtocolDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  ObjCProtocolDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n\n  static ObjCProtocolDecl *Create(ASTContext &C, DeclContext *DC,\n                                  IdentifierInfo *Id,\n                                  SourceLocation nameLoc,\n                                  SourceLocation atStartLoc,\n                                  ObjCProtocolDecl *PrevDecl);\n\n  static ObjCProtocolDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    assert(hasDefinition() && \"No definition available!\");\n    return data().ReferencedProtocols;\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    return data().ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const {\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    return data().ReferencedProtocols.end();\n  }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    return data().ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    return data().ReferencedProtocols.loc_end();\n  }\n\n  unsigned protocol_size() const {\n    if (!hasDefinition())\n      return 0;\n\n    return data().ReferencedProtocols.size();\n  }\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const*List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    assert(hasDefinition() && \"Protocol is not defined\");\n    data().ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  /// This is true iff the protocol is tagged with the\n  /// `objc_non_runtime_protocol` attribute.\n  bool isNonRuntimeProtocol() const;\n\n  /// Get the set of all protocols implied by this protocols inheritance\n  /// hierarchy.\n  void getImpliedProtocols(llvm::DenseSet<const ObjCProtocolDecl *> &IPs) const;\n\n  ObjCProtocolDecl *lookupProtocolNamed(IdentifierInfo *PName);\n\n  // Lookup a method. First, we search locally. If a method isn't\n  // found, we search referenced protocols and class categories.\n  ObjCMethodDecl *lookupMethod(Selector Sel, bool isInstance) const;\n\n  ObjCMethodDecl *lookupInstanceMethod(Selector Sel) const {\n    return lookupMethod(Sel, true/*isInstance*/);\n  }\n\n  ObjCMethodDecl *lookupClassMethod(Selector Sel) const {\n    return lookupMethod(Sel, false/*isInstance*/);\n  }\n\n  /// Determine whether this protocol has a definition.\n  bool hasDefinition() const {\n    // If the name of this protocol is out-of-date, bring it up-to-date, which\n    // might bring in a definition.\n    // Note: a null value indicates that we don't have a definition and that\n    // modules are enabled.\n    if (!Data.getOpaqueValue())\n      getMostRecentDecl();\n\n    return Data.getPointer();\n  }\n\n  /// Retrieve the definition of this protocol, if any.\n  ObjCProtocolDecl *getDefinition() {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Retrieve the definition of this protocol, if any.\n  const ObjCProtocolDecl *getDefinition() const {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Determine whether this particular declaration is also the\n  /// definition.\n  bool isThisDeclarationADefinition() const {\n    return getDefinition() == this;\n  }\n\n  /// Starts the definition of this Objective-C protocol.\n  void startDefinition();\n\n  /// Produce a name to be used for protocol's metadata. It comes either via\n  /// objc_runtime_name attribute or protocol name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (isThisDeclarationADefinition())\n      return ObjCContainerDecl::getSourceRange();\n\n    return SourceRange(getAtStartLoc(), getLocation());\n  }\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Retrieves the canonical declaration of this Objective-C protocol.\n  ObjCProtocolDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ObjCProtocolDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  void collectPropertiesToImplement(PropertyMap &PM,\n                                    PropertyDeclOrder &PO) const override;\n\n  void collectInheritedProtocolProperties(const ObjCPropertyDecl *Property,\n                                          ProtocolPropertySet &PS,\n                                          PropertyDeclOrder &PO) const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCProtocol; }\n};\n\n/// ObjCCategoryDecl - Represents a category declaration. A category allows\n/// you to add methods to an existing class (without subclassing or modifying\n/// the original class interface or implementation:-). Categories don't allow\n/// you to add instance data. The following example adds \"myMethod\" to all\n/// NSView's within a process:\n///\n/// \\@interface NSView (MyViewMethods)\n/// - myMethod;\n/// \\@end\n///\n/// Categories also allow you to split the implementation of a class across\n/// several files (a feature more naturally supported in C++).\n///\n/// Categories were originally inspired by dynamic languages such as Common\n/// Lisp and Smalltalk.  More traditional class-based languages (C++, Java)\n/// don't support this level of dynamism, which is both powerful and dangerous.\nclass ObjCCategoryDecl : public ObjCContainerDecl {\n  /// Interface belonging to this category\n  ObjCInterfaceDecl *ClassInterface;\n\n  /// The type parameters associated with this category, if any.\n  ObjCTypeParamList *TypeParamList = nullptr;\n\n  /// referenced protocols in this category.\n  ObjCProtocolList ReferencedProtocols;\n\n  /// Next category belonging to this class.\n  /// FIXME: this should not be a singly-linked list.  Move storage elsewhere.\n  ObjCCategoryDecl *NextClassCategory = nullptr;\n\n  /// The location of the category name in this declaration.\n  SourceLocation CategoryNameLoc;\n\n  /// class extension may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  ObjCCategoryDecl(DeclContext *DC, SourceLocation AtLoc,\n                   SourceLocation ClassNameLoc, SourceLocation CategoryNameLoc,\n                   IdentifierInfo *Id, ObjCInterfaceDecl *IDecl,\n                   ObjCTypeParamList *typeParamList,\n                   SourceLocation IvarLBraceLoc = SourceLocation(),\n                   SourceLocation IvarRBraceLoc = SourceLocation());\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCCategoryDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation AtLoc,\n                                  SourceLocation ClassNameLoc,\n                                  SourceLocation CategoryNameLoc,\n                                  IdentifierInfo *Id,\n                                  ObjCInterfaceDecl *IDecl,\n                                  ObjCTypeParamList *typeParamList,\n                                  SourceLocation IvarLBraceLoc=SourceLocation(),\n                                  SourceLocation IvarRBraceLoc=SourceLocation());\n  static ObjCCategoryDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCInterfaceDecl *getClassInterface() { return ClassInterface; }\n  const ObjCInterfaceDecl *getClassInterface() const { return ClassInterface; }\n\n  /// Retrieve the type parameter list associated with this category or\n  /// extension.\n  ObjCTypeParamList *getTypeParamList() const { return TypeParamList; }\n\n  /// Set the type parameters of this category.\n  ///\n  /// This function is used by the AST importer, which must import the type\n  /// parameters after creating their DeclContext to avoid loops.\n  void setTypeParamList(ObjCTypeParamList *TPL);\n\n\n  ObjCCategoryImplDecl *getImplementation() const;\n  void setImplementation(ObjCCategoryImplDecl *ImplD);\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const*List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    return ReferencedProtocols;\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    return ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const { return ReferencedProtocols.end(); }\n  unsigned protocol_size() const { return ReferencedProtocols.size(); }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    return ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    return ReferencedProtocols.loc_end();\n  }\n\n  ObjCCategoryDecl *getNextClassCategory() const { return NextClassCategory; }\n\n  /// Retrieve the pointer to the next stored category (or extension),\n  /// which may be hidden.\n  ObjCCategoryDecl *getNextClassCategoryRaw() const {\n    return NextClassCategory;\n  }\n\n  bool IsClassExtension() const { return getIdentifier() == nullptr; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  SourceLocation getCategoryNameLoc() const { return CategoryNameLoc; }\n  void setCategoryNameLoc(SourceLocation Loc) { CategoryNameLoc = Loc; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCategory; }\n};\n\nclass ObjCImplDecl : public ObjCContainerDecl {\n  /// Class interface for this class/category implementation\n  ObjCInterfaceDecl *ClassInterface;\n\n  void anchor() override;\n\nprotected:\n  ObjCImplDecl(Kind DK, DeclContext *DC,\n               ObjCInterfaceDecl *classInterface,\n               IdentifierInfo *Id,\n               SourceLocation nameLoc, SourceLocation atStartLoc)\n      : ObjCContainerDecl(DK, DC, Id, nameLoc, atStartLoc),\n        ClassInterface(classInterface) {}\n\npublic:\n  const ObjCInterfaceDecl *getClassInterface() const { return ClassInterface; }\n  ObjCInterfaceDecl *getClassInterface() { return ClassInterface; }\n  void setClassInterface(ObjCInterfaceDecl *IFace);\n\n  void addInstanceMethod(ObjCMethodDecl *method) {\n    // FIXME: Context should be set correctly before we get here.\n    method->setLexicalDeclContext(this);\n    addDecl(method);\n  }\n\n  void addClassMethod(ObjCMethodDecl *method) {\n    // FIXME: Context should be set correctly before we get here.\n    method->setLexicalDeclContext(this);\n    addDecl(method);\n  }\n\n  void addPropertyImplementation(ObjCPropertyImplDecl *property);\n\n  ObjCPropertyImplDecl *FindPropertyImplDecl(IdentifierInfo *propertyId,\n                            ObjCPropertyQueryKind queryKind) const;\n  ObjCPropertyImplDecl *FindPropertyImplIvarDecl(IdentifierInfo *ivarId) const;\n\n  // Iterator access to properties.\n  using propimpl_iterator = specific_decl_iterator<ObjCPropertyImplDecl>;\n  using propimpl_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCPropertyImplDecl>>;\n\n  propimpl_range property_impls() const {\n    return propimpl_range(propimpl_begin(), propimpl_end());\n  }\n\n  propimpl_iterator propimpl_begin() const {\n    return propimpl_iterator(decls_begin());\n  }\n\n  propimpl_iterator propimpl_end() const {\n    return propimpl_iterator(decls_end());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstObjCImpl && K <= lastObjCImpl;\n  }\n};\n\n/// ObjCCategoryImplDecl - An object of this class encapsulates a category\n/// \\@implementation declaration. If a category class has declaration of a\n/// property, its implementation must be specified in the category's\n/// \\@implementation declaration. Example:\n/// \\@interface I \\@end\n/// \\@interface I(CATEGORY)\n///    \\@property int p1, d1;\n/// \\@end\n/// \\@implementation I(CATEGORY)\n///  \\@dynamic p1,d1;\n/// \\@end\n///\n/// ObjCCategoryImplDecl\nclass ObjCCategoryImplDecl : public ObjCImplDecl {\n  // Category name location\n  SourceLocation CategoryNameLoc;\n\n  ObjCCategoryImplDecl(DeclContext *DC, IdentifierInfo *Id,\n                       ObjCInterfaceDecl *classInterface,\n                       SourceLocation nameLoc, SourceLocation atStartLoc,\n                       SourceLocation CategoryNameLoc)\n      : ObjCImplDecl(ObjCCategoryImpl, DC, classInterface, Id,\n                     nameLoc, atStartLoc),\n        CategoryNameLoc(CategoryNameLoc) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCCategoryImplDecl *Create(ASTContext &C, DeclContext *DC,\n                                      IdentifierInfo *Id,\n                                      ObjCInterfaceDecl *classInterface,\n                                      SourceLocation nameLoc,\n                                      SourceLocation atStartLoc,\n                                      SourceLocation CategoryNameLoc);\n  static ObjCCategoryImplDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCCategoryDecl *getCategoryDecl() const;\n\n  SourceLocation getCategoryNameLoc() const { return CategoryNameLoc; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCategoryImpl;}\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const ObjCCategoryImplDecl &CID);\n\n/// ObjCImplementationDecl - Represents a class definition - this is where\n/// method definitions are specified. For example:\n///\n/// @code\n/// \\@implementation MyClass\n/// - (void)myMethod { /* do something */ }\n/// \\@end\n/// @endcode\n///\n/// In a non-fragile runtime, instance variables can appear in the class\n/// interface, class extensions (nameless categories), and in the implementation\n/// itself, as well as being synthesized as backing storage for properties.\n///\n/// In a fragile runtime, instance variables are specified in the class\n/// interface, \\em not in the implementation. Nevertheless (for legacy reasons),\n/// we allow instance variables to be specified in the implementation. When\n/// specified, they need to be \\em identical to the interface.\nclass ObjCImplementationDecl : public ObjCImplDecl {\n  /// Implementation Class's super class.\n  ObjCInterfaceDecl *SuperClass;\n  SourceLocation SuperLoc;\n\n  /// \\@implementation may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  /// Support for ivar initialization.\n  /// The arguments used to initialize the ivars\n  LazyCXXCtorInitializersPtr IvarInitializers;\n  unsigned NumIvarInitializers = 0;\n\n  /// Do the ivars of this class require initialization other than\n  /// zero-initialization?\n  bool HasNonZeroConstructors : 1;\n\n  /// Do the ivars of this class require non-trivial destruction?\n  bool HasDestructors : 1;\n\n  ObjCImplementationDecl(DeclContext *DC,\n                         ObjCInterfaceDecl *classInterface,\n                         ObjCInterfaceDecl *superDecl,\n                         SourceLocation nameLoc, SourceLocation atStartLoc,\n                         SourceLocation superLoc = SourceLocation(),\n                         SourceLocation IvarLBraceLoc=SourceLocation(),\n                         SourceLocation IvarRBraceLoc=SourceLocation())\n      : ObjCImplDecl(ObjCImplementation, DC, classInterface,\n                     classInterface ? classInterface->getIdentifier()\n                                    : nullptr,\n                     nameLoc, atStartLoc),\n         SuperClass(superDecl), SuperLoc(superLoc),\n         IvarLBraceLoc(IvarLBraceLoc), IvarRBraceLoc(IvarRBraceLoc),\n         HasNonZeroConstructors(false), HasDestructors(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCImplementationDecl *Create(ASTContext &C, DeclContext *DC,\n                                        ObjCInterfaceDecl *classInterface,\n                                        ObjCInterfaceDecl *superDecl,\n                                        SourceLocation nameLoc,\n                                        SourceLocation atStartLoc,\n                                     SourceLocation superLoc = SourceLocation(),\n                                        SourceLocation IvarLBraceLoc=SourceLocation(),\n                                        SourceLocation IvarRBraceLoc=SourceLocation());\n\n  static ObjCImplementationDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// init_iterator - Iterates through the ivar initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// init_const_iterator - Iterates through the ivar initializer list.\n  using init_const_iterator = CXXCtorInitializer * const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// init_begin() - Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// begin() - Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// init_end() - Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// end() - Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// getNumArgs - Number of ivars which must be initialized.\n  unsigned getNumIvarInitializers() const {\n    return NumIvarInitializers;\n  }\n\n  void setNumIvarInitializers(unsigned numNumIvarInitializers) {\n    NumIvarInitializers = numNumIvarInitializers;\n  }\n\n  void setIvarInitializers(ASTContext &C,\n                           CXXCtorInitializer ** initializers,\n                           unsigned numInitializers);\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require construction other than zero-initialization?\n  bool hasNonZeroConstructors() const { return HasNonZeroConstructors; }\n  void setHasNonZeroConstructors(bool val) { HasNonZeroConstructors = val; }\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require non-trivial destruction?\n  bool hasDestructors() const { return HasDestructors; }\n  void setHasDestructors(bool val) { HasDestructors = val; }\n\n  /// getIdentifier - Get the identifier that names the class\n  /// interface associated with this implementation.\n  IdentifierInfo *getIdentifier() const {\n    return getClassInterface()->getIdentifier();\n  }\n\n  /// getName - Get the name of identifier for the class interface associated\n  /// with this implementation as a StringRef.\n  //\n  // FIXME: This is a bad API, we are hiding NamedDecl::getName with a different\n  // meaning.\n  StringRef getName() const {\n    assert(getIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier()->getName();\n  }\n\n  /// Get the name of the class associated with this interface.\n  //\n  // FIXME: Move to StringRef API.\n  std::string getNameAsString() const { return std::string(getName()); }\n\n  /// Produce a name to be used for class's metadata. It comes either via\n  /// class's objc_runtime_name attribute or class name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  const ObjCInterfaceDecl *getSuperClass() const { return SuperClass; }\n  ObjCInterfaceDecl *getSuperClass() { return SuperClass; }\n  SourceLocation getSuperClassLoc() const { return SuperLoc; }\n\n  void setSuperClass(ObjCInterfaceDecl * superCls) { SuperClass = superCls; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCImplementation; }\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const ObjCImplementationDecl &ID);\n\n/// ObjCCompatibleAliasDecl - Represents alias of a class. This alias is\n/// declared as \\@compatibility_alias alias class.\nclass ObjCCompatibleAliasDecl : public NamedDecl {\n  /// Class that this is an alias of.\n  ObjCInterfaceDecl *AliasedClass;\n\n  ObjCCompatibleAliasDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n                          ObjCInterfaceDecl* aliasedClass)\n      : NamedDecl(ObjCCompatibleAlias, DC, L, Id), AliasedClass(aliasedClass) {}\n\n  void anchor() override;\n\npublic:\n  static ObjCCompatibleAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                         SourceLocation L, IdentifierInfo *Id,\n                                         ObjCInterfaceDecl* aliasedClass);\n\n  static ObjCCompatibleAliasDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  const ObjCInterfaceDecl *getClassInterface() const { return AliasedClass; }\n  ObjCInterfaceDecl *getClassInterface() { return AliasedClass; }\n  void setClassInterface(ObjCInterfaceDecl *D) { AliasedClass = D; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCompatibleAlias; }\n};\n\n/// ObjCPropertyImplDecl - Represents implementation declaration of a property\n/// in a class or category implementation block. For example:\n/// \\@synthesize prop1 = ivar1;\n///\nclass ObjCPropertyImplDecl : public Decl {\npublic:\n  enum Kind {\n    Synthesize,\n    Dynamic\n  };\n\nprivate:\n  SourceLocation AtLoc;   // location of \\@synthesize or \\@dynamic\n\n  /// For \\@synthesize, the location of the ivar, if it was written in\n  /// the source code.\n  ///\n  /// \\code\n  /// \\@synthesize int a = b\n  /// \\endcode\n  SourceLocation IvarLoc;\n\n  /// Property declaration being implemented\n  ObjCPropertyDecl *PropertyDecl;\n\n  /// Null for \\@dynamic. Required for \\@synthesize.\n  ObjCIvarDecl *PropertyIvarDecl;\n\n  /// The getter's definition, which has an empty body if synthesized.\n  ObjCMethodDecl *GetterMethodDecl = nullptr;\n  /// The getter's definition, which has an empty body if synthesized.\n  ObjCMethodDecl *SetterMethodDecl = nullptr;\n\n  /// Null for \\@dynamic. Non-null if property must be copy-constructed in\n  /// getter.\n  Expr *GetterCXXConstructor = nullptr;\n\n  /// Null for \\@dynamic. Non-null if property has assignment operator to call\n  /// in Setter synthesis.\n  Expr *SetterCXXAssignment = nullptr;\n\n  ObjCPropertyImplDecl(DeclContext *DC, SourceLocation atLoc, SourceLocation L,\n                       ObjCPropertyDecl *property,\n                       Kind PK,\n                       ObjCIvarDecl *ivarDecl,\n                       SourceLocation ivarLoc)\n      : Decl(ObjCPropertyImpl, DC, L), AtLoc(atLoc),\n        IvarLoc(ivarLoc), PropertyDecl(property), PropertyIvarDecl(ivarDecl) {\n    assert(PK == Dynamic || PropertyIvarDecl);\n  }\n\npublic:\n  friend class ASTDeclReader;\n\n  static ObjCPropertyImplDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation atLoc, SourceLocation L,\n                                      ObjCPropertyDecl *property,\n                                      Kind PK,\n                                      ObjCIvarDecl *ivarDecl,\n                                      SourceLocation ivarLoc);\n\n  static ObjCPropertyImplDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  void setAtLoc(SourceLocation Loc) { AtLoc = Loc; }\n\n  ObjCPropertyDecl *getPropertyDecl() const {\n    return PropertyDecl;\n  }\n  void setPropertyDecl(ObjCPropertyDecl *Prop) { PropertyDecl = Prop; }\n\n  Kind getPropertyImplementation() const {\n    return PropertyIvarDecl ? Synthesize : Dynamic;\n  }\n\n  ObjCIvarDecl *getPropertyIvarDecl() const {\n    return PropertyIvarDecl;\n  }\n  SourceLocation getPropertyIvarDeclLoc() const { return IvarLoc; }\n\n  void setPropertyIvarDecl(ObjCIvarDecl *Ivar,\n                           SourceLocation IvarLoc) {\n    PropertyIvarDecl = Ivar;\n    this->IvarLoc = IvarLoc;\n  }\n\n  /// For \\@synthesize, returns true if an ivar name was explicitly\n  /// specified.\n  ///\n  /// \\code\n  /// \\@synthesize int a = b; // true\n  /// \\@synthesize int a; // false\n  /// \\endcode\n  bool isIvarNameSpecified() const {\n    return IvarLoc.isValid() && IvarLoc != getLocation();\n  }\n\n  ObjCMethodDecl *getGetterMethodDecl() const { return GetterMethodDecl; }\n  void setGetterMethodDecl(ObjCMethodDecl *MD) { GetterMethodDecl = MD; }\n\n  ObjCMethodDecl *getSetterMethodDecl() const { return SetterMethodDecl; }\n  void setSetterMethodDecl(ObjCMethodDecl *MD) { SetterMethodDecl = MD; }\n\n  Expr *getGetterCXXConstructor() const {\n    return GetterCXXConstructor;\n  }\n\n  void setGetterCXXConstructor(Expr *getterCXXConstructor) {\n    GetterCXXConstructor = getterCXXConstructor;\n  }\n\n  Expr *getSetterCXXAssignment() const {\n    return SetterCXXAssignment;\n  }\n\n  void setSetterCXXAssignment(Expr *setterCXXAssignment) {\n    SetterCXXAssignment = setterCXXAssignment;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Decl::Kind K) { return K == ObjCPropertyImpl; }\n};\n\ntemplate<bool (*Filter)(ObjCCategoryDecl *)>\nvoid\nObjCInterfaceDecl::filtered_category_iterator<Filter>::\nfindAcceptableCategory() {\n  while (Current && !Filter(Current))\n    Current = Current->getNextClassCategoryRaw();\n}\n\ntemplate<bool (*Filter)(ObjCCategoryDecl *)>\ninline ObjCInterfaceDecl::filtered_category_iterator<Filter> &\nObjCInterfaceDecl::filtered_category_iterator<Filter>::operator++() {\n  Current = Current->getNextClassCategoryRaw();\n  findAcceptableCategory();\n  return *this;\n}\n\ninline bool ObjCInterfaceDecl::isVisibleCategory(ObjCCategoryDecl *Cat) {\n  return Cat->isUnconditionallyVisible();\n}\n\ninline bool ObjCInterfaceDecl::isVisibleExtension(ObjCCategoryDecl *Cat) {\n  return Cat->IsClassExtension() && Cat->isUnconditionallyVisible();\n}\n\ninline bool ObjCInterfaceDecl::isKnownExtension(ObjCCategoryDecl *Cat) {\n  return Cat->IsClassExtension();\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLOBJC_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "content": "//===- DeclTemplate.h - Classes for representing C++ templates --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the C++ template declaration subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLTEMPLATE_H\n#define LLVM_CLANG_AST_DECLTEMPLATE_H\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nnamespace clang {\n\nenum BuiltinTemplateKind : int;\nclass ClassTemplateDecl;\nclass ClassTemplatePartialSpecializationDecl;\nclass Expr;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass NonTypeTemplateParmDecl;\nclass TemplateDecl;\nclass TemplateTemplateParmDecl;\nclass TemplateTypeParmDecl;\nclass ConceptDecl;\nclass UnresolvedSetImpl;\nclass VarTemplateDecl;\nclass VarTemplatePartialSpecializationDecl;\n\n/// Stores a template parameter of any kind.\nusing TemplateParameter =\n    llvm::PointerUnion<TemplateTypeParmDecl *, NonTypeTemplateParmDecl *,\n                       TemplateTemplateParmDecl *>;\n\nNamedDecl *getAsNamedDecl(TemplateParameter P);\n\n/// Stores a list of template parameters for a TemplateDecl and its\n/// derived classes.\nclass TemplateParameterList final\n    : private llvm::TrailingObjects<TemplateParameterList, NamedDecl *,\n                                    Expr *> {\n  /// The location of the 'template' keyword.\n  SourceLocation TemplateLoc;\n\n  /// The locations of the '<' and '>' angle brackets.\n  SourceLocation LAngleLoc, RAngleLoc;\n\n  /// The number of template parameters in this template\n  /// parameter list.\n  unsigned NumParams : 29;\n\n  /// Whether this template parameter list contains an unexpanded parameter\n  /// pack.\n  unsigned ContainsUnexpandedParameterPack : 1;\n\n  /// Whether this template parameter list has a requires clause.\n  unsigned HasRequiresClause : 1;\n\n  /// Whether any of the template parameters has constrained-parameter\n  /// constraint-expression.\n  unsigned HasConstrainedParameters : 1;\n\nprotected:\n  TemplateParameterList(const ASTContext& C, SourceLocation TemplateLoc,\n                        SourceLocation LAngleLoc, ArrayRef<NamedDecl *> Params,\n                        SourceLocation RAngleLoc, Expr *RequiresClause);\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return NumParams;\n  }\n\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return HasRequiresClause ? 1 : 0;\n  }\n\npublic:\n  template <size_t N, bool HasRequiresClause>\n  friend class FixedSizeTemplateParameterListStorage;\n  friend TrailingObjects;\n\n  static TemplateParameterList *Create(const ASTContext &C,\n                                       SourceLocation TemplateLoc,\n                                       SourceLocation LAngleLoc,\n                                       ArrayRef<NamedDecl *> Params,\n                                       SourceLocation RAngleLoc,\n                                       Expr *RequiresClause);\n\n  /// Iterates through the template parameters in this list.\n  using iterator = NamedDecl **;\n\n  /// Iterates through the template parameters in this list.\n  using const_iterator = NamedDecl * const *;\n\n  iterator begin() { return getTrailingObjects<NamedDecl *>(); }\n  const_iterator begin() const { return getTrailingObjects<NamedDecl *>(); }\n  iterator end() { return begin() + NumParams; }\n  const_iterator end() const { return begin() + NumParams; }\n\n  unsigned size() const { return NumParams; }\n\n  ArrayRef<NamedDecl*> asArray() {\n    return llvm::makeArrayRef(begin(), end());\n  }\n  ArrayRef<const NamedDecl*> asArray() const {\n    return llvm::makeArrayRef(begin(), size());\n  }\n\n  NamedDecl* getParam(unsigned Idx) {\n    assert(Idx < size() && \"Template parameter index out-of-range\");\n    return begin()[Idx];\n  }\n  const NamedDecl* getParam(unsigned Idx) const {\n    assert(Idx < size() && \"Template parameter index out-of-range\");\n    return begin()[Idx];\n  }\n\n  /// Returns the minimum number of arguments needed to form a\n  /// template specialization.\n  ///\n  /// This may be fewer than the number of template parameters, if some of\n  /// the parameters have default arguments or if there is a parameter pack.\n  unsigned getMinRequiredArguments() const;\n\n  /// Get the depth of this template parameter list in the set of\n  /// template parameter lists.\n  ///\n  /// The first template parameter list in a declaration will have depth 0,\n  /// the second template parameter list will have depth 1, etc.\n  unsigned getDepth() const;\n\n  /// Determine whether this template parameter list contains an\n  /// unexpanded parameter pack.\n  bool containsUnexpandedParameterPack() const {\n    return ContainsUnexpandedParameterPack;\n  }\n\n  /// Determine whether this template parameter list contains a parameter pack.\n  bool hasParameterPack() const {\n    for (const NamedDecl *P : asArray())\n      if (P->isParameterPack())\n        return true;\n    return false;\n  }\n\n  /// The constraint-expression of the associated requires-clause.\n  Expr *getRequiresClause() {\n    return HasRequiresClause ? getTrailingObjects<Expr *>()[0] : nullptr;\n  }\n\n  /// The constraint-expression of the associated requires-clause.\n  const Expr *getRequiresClause() const {\n    return HasRequiresClause ? getTrailingObjects<Expr *>()[0] : nullptr;\n  }\n\n  /// \\brief All associated constraints derived from this template parameter\n  /// list, including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const;\n\n  bool hasAssociatedConstraints() const;\n\n  SourceLocation getTemplateLoc() const { return TemplateLoc; }\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(TemplateLoc, RAngleLoc);\n  }\n\n  void print(raw_ostream &Out, const ASTContext &Context,\n             bool OmitTemplateKW = false) const;\n  void print(raw_ostream &Out, const ASTContext &Context,\n             const PrintingPolicy &Policy, bool OmitTemplateKW = false) const;\n};\n\n/// Stores a list of template parameters and the associated\n/// requires-clause (if any) for a TemplateDecl and its derived classes.\n/// Suitable for creating on the stack.\ntemplate <size_t N, bool HasRequiresClause>\nclass FixedSizeTemplateParameterListStorage\n    : public TemplateParameterList::FixedSizeStorageOwner {\n  typename TemplateParameterList::FixedSizeStorage<\n      NamedDecl *, Expr *>::with_counts<\n      N, HasRequiresClause ? 1u : 0u\n      >::type storage;\n\npublic:\n  FixedSizeTemplateParameterListStorage(const ASTContext &C,\n                                        SourceLocation TemplateLoc,\n                                        SourceLocation LAngleLoc,\n                                        ArrayRef<NamedDecl *> Params,\n                                        SourceLocation RAngleLoc,\n                                        Expr *RequiresClause)\n      : FixedSizeStorageOwner(\n            (assert(N == Params.size()),\n             assert(HasRequiresClause == (RequiresClause != nullptr)),\n             new (static_cast<void *>(&storage)) TemplateParameterList(C,\n                 TemplateLoc, LAngleLoc, Params, RAngleLoc, RequiresClause))) {}\n};\n\n/// A template argument list.\nclass TemplateArgumentList final\n    : private llvm::TrailingObjects<TemplateArgumentList, TemplateArgument> {\n  /// The template argument list.\n  const TemplateArgument *Arguments;\n\n  /// The number of template arguments in this template\n  /// argument list.\n  unsigned NumArguments;\n\n  // Constructs an instance with an internal Argument list, containing\n  // a copy of the Args array. (Called by CreateCopy)\n  TemplateArgumentList(ArrayRef<TemplateArgument> Args);\n\npublic:\n  friend TrailingObjects;\n\n  TemplateArgumentList(const TemplateArgumentList &) = delete;\n  TemplateArgumentList &operator=(const TemplateArgumentList &) = delete;\n\n  /// Type used to indicate that the template argument list itself is a\n  /// stack object. It does not own its template arguments.\n  enum OnStackType { OnStack };\n\n  /// Create a new template argument list that copies the given set of\n  /// template arguments.\n  static TemplateArgumentList *CreateCopy(ASTContext &Context,\n                                          ArrayRef<TemplateArgument> Args);\n\n  /// Construct a new, temporary template argument list on the stack.\n  ///\n  /// The template argument list does not own the template arguments\n  /// provided.\n  explicit TemplateArgumentList(OnStackType, ArrayRef<TemplateArgument> Args)\n      : Arguments(Args.data()), NumArguments(Args.size()) {}\n\n  /// Produces a shallow copy of the given template argument list.\n  ///\n  /// This operation assumes that the input argument list outlives it.\n  /// This takes the list as a pointer to avoid looking like a copy\n  /// constructor, since this really really isn't safe to use that\n  /// way.\n  explicit TemplateArgumentList(const TemplateArgumentList *Other)\n      : Arguments(Other->data()), NumArguments(Other->size()) {}\n\n  /// Retrieve the template argument at a given index.\n  const TemplateArgument &get(unsigned Idx) const {\n    assert(Idx < NumArguments && \"Invalid template argument index\");\n    return data()[Idx];\n  }\n\n  /// Retrieve the template argument at a given index.\n  const TemplateArgument &operator[](unsigned Idx) const { return get(Idx); }\n\n  /// Produce this as an array ref.\n  ArrayRef<TemplateArgument> asArray() const {\n    return llvm::makeArrayRef(data(), size());\n  }\n\n  /// Retrieve the number of template arguments in this\n  /// template argument list.\n  unsigned size() const { return NumArguments; }\n\n  /// Retrieve a pointer to the template argument list.\n  const TemplateArgument *data() const { return Arguments; }\n};\n\nvoid *allocateDefaultArgStorageChain(const ASTContext &C);\n\n/// Storage for a default argument. This is conceptually either empty, or an\n/// argument value, or a pointer to a previous declaration that had a default\n/// argument.\n///\n/// However, this is complicated by modules: while we require all the default\n/// arguments for a template to be equivalent, there may be more than one, and\n/// we need to track all the originating parameters to determine if the default\n/// argument is visible.\ntemplate<typename ParmDecl, typename ArgType>\nclass DefaultArgStorage {\n  /// Storage for both the value *and* another parameter from which we inherit\n  /// the default argument. This is used when multiple default arguments for a\n  /// parameter are merged together from different modules.\n  struct Chain {\n    ParmDecl *PrevDeclWithDefaultArg;\n    ArgType Value;\n  };\n  static_assert(sizeof(Chain) == sizeof(void *) * 2,\n                \"non-pointer argument type?\");\n\n  llvm::PointerUnion<ArgType, ParmDecl*, Chain*> ValueOrInherited;\n\n  static ParmDecl *getParmOwningDefaultArg(ParmDecl *Parm) {\n    const DefaultArgStorage &Storage = Parm->getDefaultArgStorage();\n    if (auto *Prev = Storage.ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Parm = Prev;\n    assert(!Parm->getDefaultArgStorage()\n                .ValueOrInherited.template is<ParmDecl *>() &&\n           \"should only be one level of indirection\");\n    return Parm;\n  }\n\npublic:\n  DefaultArgStorage() : ValueOrInherited(ArgType()) {}\n\n  /// Determine whether there is a default argument for this parameter.\n  bool isSet() const { return !ValueOrInherited.isNull(); }\n\n  /// Determine whether the default argument for this parameter was inherited\n  /// from a previous declaration of the same entity.\n  bool isInherited() const { return ValueOrInherited.template is<ParmDecl*>(); }\n\n  /// Get the default argument's value. This does not consider whether the\n  /// default argument is visible.\n  ArgType get() const {\n    const DefaultArgStorage *Storage = this;\n    if (const auto *Prev = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Storage = &Prev->getDefaultArgStorage();\n    if (const auto *C = Storage->ValueOrInherited.template dyn_cast<Chain *>())\n      return C->Value;\n    return Storage->ValueOrInherited.template get<ArgType>();\n  }\n\n  /// Get the parameter from which we inherit the default argument, if any.\n  /// This is the parameter on which the default argument was actually written.\n  const ParmDecl *getInheritedFrom() const {\n    if (const auto *D = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      return D;\n    if (const auto *C = ValueOrInherited.template dyn_cast<Chain *>())\n      return C->PrevDeclWithDefaultArg;\n    return nullptr;\n  }\n\n  /// Set the default argument.\n  void set(ArgType Arg) {\n    assert(!isSet() && \"default argument already set\");\n    ValueOrInherited = Arg;\n  }\n\n  /// Set that the default argument was inherited from another parameter.\n  void setInherited(const ASTContext &C, ParmDecl *InheritedFrom) {\n    assert(!isInherited() && \"default argument already inherited\");\n    InheritedFrom = getParmOwningDefaultArg(InheritedFrom);\n    if (!isSet())\n      ValueOrInherited = InheritedFrom;\n    else\n      ValueOrInherited = new (allocateDefaultArgStorageChain(C))\n          Chain{InheritedFrom, ValueOrInherited.template get<ArgType>()};\n  }\n\n  /// Remove the default argument, even if it was inherited.\n  void clear() {\n    ValueOrInherited = ArgType();\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Kinds of Templates\n//===----------------------------------------------------------------------===//\n\n/// \\brief The base class of all kinds of template declarations (e.g.,\n/// class, function, etc.).\n///\n/// The TemplateDecl class stores the list of template parameters and a\n/// reference to the templated scoped declaration: the underlying AST node.\nclass TemplateDecl : public NamedDecl {\n  void anchor() override;\n\nprotected:\n  // Construct a template decl with name, parameters, and templated element.\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params, NamedDecl *Decl);\n\n  // Construct a template decl with the given name and parameters.\n  // Used when there is no templated element (e.g., for tt-params).\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params)\n      : TemplateDecl(DK, DC, L, Name, Params, nullptr) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief Get the total constraint-expression associated with this template,\n  /// including constraint-expressions derived from the requires-clause,\n  /// trailing requires-clause (for functions and methods) and constrained\n  /// template parameters.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const;\n\n  bool hasAssociatedConstraints() const;\n\n  /// Get the underlying, templated declaration.\n  NamedDecl *getTemplatedDecl() const { return TemplatedDecl; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstTemplate && K <= lastTemplate;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       TemplatedDecl->getSourceRange().getEnd());\n  }\n\nprotected:\n  NamedDecl *TemplatedDecl;\n  TemplateParameterList *TemplateParams;\n\n  void setTemplateParameters(TemplateParameterList *TParams) {\n    TemplateParams = TParams;\n  }\n\npublic:\n  /// Initialize the underlying templated declaration and\n  /// template parameters.\n  void init(NamedDecl *templatedDecl, TemplateParameterList* templateParams) {\n    assert(!TemplatedDecl && \"TemplatedDecl already set!\");\n    assert(!TemplateParams && \"TemplateParams already set!\");\n    TemplatedDecl = templatedDecl;\n    TemplateParams = templateParams;\n  }\n};\n\n/// Provides information about a function template specialization,\n/// which is a FunctionDecl that has been explicitly specialization or\n/// instantiated from a function template.\nclass FunctionTemplateSpecializationInfo final\n    : public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<FunctionTemplateSpecializationInfo,\n                                    MemberSpecializationInfo *> {\n  /// The function template specialization that this structure describes and a\n  /// flag indicating if the function is a member specialization.\n  llvm::PointerIntPair<FunctionDecl *, 1, bool> Function;\n\n  /// The function template from which this function template\n  /// specialization was generated.\n  ///\n  /// The two bits contain the top 4 values of TemplateSpecializationKind.\n  llvm::PointerIntPair<FunctionTemplateDecl *, 2> Template;\n\npublic:\n  /// The template arguments used to produce the function template\n  /// specialization from the function template.\n  const TemplateArgumentList *TemplateArguments;\n\n  /// The template arguments as written in the sources, if provided.\n  /// FIXME: Normally null; tail-allocate this.\n  const ASTTemplateArgumentListInfo *TemplateArgumentsAsWritten;\n\n  /// The point at which this function template specialization was\n  /// first instantiated.\n  SourceLocation PointOfInstantiation;\n\nprivate:\n  FunctionTemplateSpecializationInfo(\n      FunctionDecl *FD, FunctionTemplateDecl *Template,\n      TemplateSpecializationKind TSK, const TemplateArgumentList *TemplateArgs,\n      const ASTTemplateArgumentListInfo *TemplateArgsAsWritten,\n      SourceLocation POI, MemberSpecializationInfo *MSInfo)\n      : Function(FD, MSInfo ? 1 : 0), Template(Template, TSK - 1),\n        TemplateArguments(TemplateArgs),\n        TemplateArgumentsAsWritten(TemplateArgsAsWritten),\n        PointOfInstantiation(POI) {\n    if (MSInfo)\n      getTrailingObjects<MemberSpecializationInfo *>()[0] = MSInfo;\n  }\n\n  size_t numTrailingObjects(OverloadToken<MemberSpecializationInfo*>) const {\n    return Function.getInt();\n  }\n\npublic:\n  friend TrailingObjects;\n\n  static FunctionTemplateSpecializationInfo *\n  Create(ASTContext &C, FunctionDecl *FD, FunctionTemplateDecl *Template,\n         TemplateSpecializationKind TSK,\n         const TemplateArgumentList *TemplateArgs,\n         const TemplateArgumentListInfo *TemplateArgsAsWritten,\n         SourceLocation POI, MemberSpecializationInfo *MSInfo);\n\n  /// Retrieve the declaration of the function template specialization.\n  FunctionDecl *getFunction() const { return Function.getPointer(); }\n\n  /// Retrieve the template from which this function was specialized.\n  FunctionTemplateDecl *getTemplate() const { return Template.getPointer(); }\n\n  /// Determine what kind of template specialization this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const {\n    return (TemplateSpecializationKind)(Template.getInt() + 1);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  /// Set the template specialization kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK) {\n    assert(TSK != TSK_Undeclared &&\n         \"Cannot encode TSK_Undeclared for a function template specialization\");\n    Template.setInt(TSK - 1);\n  }\n\n  /// Retrieve the first point of instantiation of this function\n  /// template specialization.\n  ///\n  /// The point of instantiation may be an invalid source location if this\n  /// function has yet to be instantiated.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  /// Set the (first) point of instantiation of this function template\n  /// specialization.\n  void setPointOfInstantiation(SourceLocation POI) {\n    PointOfInstantiation = POI;\n  }\n\n  /// Get the specialization info if this function template specialization is\n  /// also a member specialization:\n  ///\n  /// \\code\n  /// template<typename> struct A {\n  ///   template<typename> void f();\n  ///   template<> void f<int>(); // ClassScopeFunctionSpecializationDecl\n  /// };\n  /// \\endcode\n  ///\n  /// Here, A<int>::f<int> is a function template specialization that is\n  /// an explicit specialization of A<int>::f, but it's also a member\n  /// specialization (an implicit instantiation in this case) of A::f<int>.\n  /// Further:\n  ///\n  /// \\code\n  /// template<> template<> void A<int>::f<int>() {}\n  /// \\endcode\n  ///\n  /// ... declares a function template specialization that is an explicit\n  /// specialization of A<int>::f, and is also an explicit member\n  /// specialization of A::f<int>.\n  ///\n  /// Note that the TemplateSpecializationKind of the MemberSpecializationInfo\n  /// need not be the same as that returned by getTemplateSpecializationKind(),\n  /// and represents the relationship between the function and the class-scope\n  /// explicit specialization in the original templated class -- whereas our\n  /// TemplateSpecializationKind represents the relationship between the\n  /// function and the function template, and should always be\n  /// TSK_ExplicitSpecialization whenever we have MemberSpecializationInfo.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const {\n    return numTrailingObjects(OverloadToken<MemberSpecializationInfo *>())\n               ? getTrailingObjects<MemberSpecializationInfo *>()[0]\n               : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, TemplateArguments->asArray(), getFunction()->getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n};\n\n/// Provides information a specialization of a member of a class\n/// template, which may be a member function, static data member,\n/// member class or member enumeration.\nclass MemberSpecializationInfo {\n  // The member declaration from which this member was instantiated, and the\n  // manner in which the instantiation occurred (in the lower two bits).\n  llvm::PointerIntPair<NamedDecl *, 2> MemberAndTSK;\n\n  // The point at which this member was first instantiated.\n  SourceLocation PointOfInstantiation;\n\npublic:\n  explicit\n  MemberSpecializationInfo(NamedDecl *IF, TemplateSpecializationKind TSK,\n                           SourceLocation POI = SourceLocation())\n      : MemberAndTSK(IF, TSK - 1), PointOfInstantiation(POI) {\n    assert(TSK != TSK_Undeclared &&\n           \"Cannot encode undeclared template specializations for members\");\n  }\n\n  /// Retrieve the member declaration from which this member was\n  /// instantiated.\n  NamedDecl *getInstantiatedFrom() const { return MemberAndTSK.getPointer(); }\n\n  /// Determine what kind of template specialization this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const {\n    return (TemplateSpecializationKind)(MemberAndTSK.getInt() + 1);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// Set the template specialization kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK) {\n    assert(TSK != TSK_Undeclared &&\n           \"Cannot encode undeclared template specializations for members\");\n    MemberAndTSK.setInt(TSK - 1);\n  }\n\n  /// Retrieve the first point of instantiation of this member.\n  /// If the point of instantiation is an invalid location, then this member\n  /// has not yet been instantiated.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  /// Set the first point of instantiation.\n  void setPointOfInstantiation(SourceLocation POI) {\n    PointOfInstantiation = POI;\n  }\n};\n\n/// Provides information about a dependent function-template\n/// specialization declaration.\n///\n/// Since explicit function template specialization and instantiation\n/// declarations can only appear in namespace scope, and you can only\n/// specialize a member of a fully-specialized class, the only way to\n/// get one of these is in a friend declaration like the following:\n///\n/// \\code\n///   template \\<class T> void foo(T);\n///   template \\<class T> class A {\n///     friend void foo<>(T);\n///   };\n/// \\endcode\nclass DependentFunctionTemplateSpecializationInfo final\n    : private llvm::TrailingObjects<DependentFunctionTemplateSpecializationInfo,\n                                    TemplateArgumentLoc,\n                                    FunctionTemplateDecl *> {\n  /// The number of potential template candidates.\n  unsigned NumTemplates;\n\n  /// The number of template arguments.\n  unsigned NumArgs;\n\n  /// The locations of the left and right angle brackets.\n  SourceRange AngleLocs;\n\n  size_t numTrailingObjects(OverloadToken<TemplateArgumentLoc>) const {\n    return NumArgs;\n  }\n  size_t numTrailingObjects(OverloadToken<FunctionTemplateDecl *>) const {\n    return NumTemplates;\n  }\n\n  DependentFunctionTemplateSpecializationInfo(\n                                 const UnresolvedSetImpl &Templates,\n                                 const TemplateArgumentListInfo &TemplateArgs);\n\npublic:\n  friend TrailingObjects;\n\n  static DependentFunctionTemplateSpecializationInfo *\n  Create(ASTContext &Context, const UnresolvedSetImpl &Templates,\n         const TemplateArgumentListInfo &TemplateArgs);\n\n  /// Returns the number of function templates that this might\n  /// be a specialization of.\n  unsigned getNumTemplates() const { return NumTemplates; }\n\n  /// Returns the i'th template candidate.\n  FunctionTemplateDecl *getTemplate(unsigned I) const {\n    assert(I < getNumTemplates() && \"template index out of range\");\n    return getTrailingObjects<FunctionTemplateDecl *>()[I];\n  }\n\n  /// Returns the explicit template arguments that were given.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Returns the number of explicit template arguments that were given.\n  unsigned getNumTemplateArgs() const { return NumArgs; }\n\n  /// Returns the nth template argument.\n  const TemplateArgumentLoc &getTemplateArg(unsigned I) const {\n    assert(I < getNumTemplateArgs() && \"template arg index out of range\");\n    return getTemplateArgs()[I];\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return AngleLocs.getBegin();\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return AngleLocs.getEnd();\n  }\n};\n\n/// Declaration of a redeclarable template.\nclass RedeclarableTemplateDecl : public TemplateDecl,\n                                 public Redeclarable<RedeclarableTemplateDecl>\n{\n  using redeclarable_base = Redeclarable<RedeclarableTemplateDecl>;\n\n  RedeclarableTemplateDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  RedeclarableTemplateDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  RedeclarableTemplateDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  void anchor() override;\nprotected:\n  template <typename EntryType> struct SpecEntryTraits {\n    using DeclType = EntryType;\n\n    static DeclType *getDecl(EntryType *D) {\n      return D;\n    }\n\n    static ArrayRef<TemplateArgument> getTemplateArgs(EntryType *D) {\n      return D->getTemplateArgs().asArray();\n    }\n  };\n\n  template <typename EntryType, typename SETraits = SpecEntryTraits<EntryType>,\n            typename DeclType = typename SETraits::DeclType>\n  struct SpecIterator\n      : llvm::iterator_adaptor_base<\n            SpecIterator<EntryType, SETraits, DeclType>,\n            typename llvm::FoldingSetVector<EntryType>::iterator,\n            typename std::iterator_traits<typename llvm::FoldingSetVector<\n                EntryType>::iterator>::iterator_category,\n            DeclType *, ptrdiff_t, DeclType *, DeclType *> {\n    SpecIterator() = default;\n    explicit SpecIterator(\n        typename llvm::FoldingSetVector<EntryType>::iterator SetIter)\n        : SpecIterator::iterator_adaptor_base(std::move(SetIter)) {}\n\n    DeclType *operator*() const {\n      return SETraits::getDecl(&*this->I)->getMostRecentDecl();\n    }\n\n    DeclType *operator->() const { return **this; }\n  };\n\n  template <typename EntryType>\n  static SpecIterator<EntryType>\n  makeSpecIterator(llvm::FoldingSetVector<EntryType> &Specs, bool isEnd) {\n    return SpecIterator<EntryType>(isEnd ? Specs.end() : Specs.begin());\n  }\n\n  void loadLazySpecializationsImpl() const;\n\n  template <class EntryType, typename ...ProfileArguments>\n  typename SpecEntryTraits<EntryType>::DeclType*\n  findSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                         void *&InsertPos, ProfileArguments &&...ProfileArgs);\n\n  template <class Derived, class EntryType>\n  void addSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                             EntryType *Entry, void *InsertPos);\n\n  struct CommonBase {\n    CommonBase() : InstantiatedFromMember(nullptr, false) {}\n\n    /// The template from which this was most\n    /// directly instantiated (or null).\n    ///\n    /// The boolean value indicates whether this template\n    /// was explicitly specialized.\n    llvm::PointerIntPair<RedeclarableTemplateDecl*, 1, bool>\n      InstantiatedFromMember;\n\n    /// If non-null, points to an array of specializations (including\n    /// partial specializations) known only by their external declaration IDs.\n    ///\n    /// The first value in the array is the number of specializations/partial\n    /// specializations that follow.\n    uint32_t *LazySpecializations = nullptr;\n  };\n\n  /// Pointer to the common data shared by all declarations of this\n  /// template.\n  mutable CommonBase *Common = nullptr;\n\n  /// Retrieves the \"common\" pointer shared by all (re-)declarations of\n  /// the same template. Calling this routine may implicitly allocate memory\n  /// for the common pointer.\n  CommonBase *getCommonPtr() const;\n\n  virtual CommonBase *newCommon(ASTContext &C) const = 0;\n\n  // Construct a template decl with name, parameters, and templated element.\n  RedeclarableTemplateDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                           SourceLocation L, DeclarationName Name,\n                           TemplateParameterList *Params, NamedDecl *Decl)\n      : TemplateDecl(DK, DC, L, Name, Params, Decl), redeclarable_base(C) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n  template <class decl_type> friend class RedeclarableTemplate;\n\n  /// Retrieves the canonical declaration of this template.\n  RedeclarableTemplateDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const RedeclarableTemplateDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Determines whether this template was a specialization of a\n  /// member template.\n  ///\n  /// In the following example, the function template \\c X<int>::f and the\n  /// member template \\c X<int>::Inner are member specializations.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  ///   template<typename U> struct Inner;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// void X<int>::f(int, T);\n  /// template<> template<typename T>\n  /// struct X<int>::Inner { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() const {\n    return getCommonPtr()->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    assert(getCommonPtr()->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    getCommonPtr()->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieve the member template from which this template was\n  /// instantiated, or nullptr if this template was not instantiated from a\n  /// member template.\n  ///\n  /// A template is instantiated from a member template when the member\n  /// template itself is part of a class template (or member thereof). For\n  /// example, given\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  /// };\n  ///\n  /// void test(X<int> x) {\n  ///   x.f(1, 'a');\n  /// };\n  /// \\endcode\n  ///\n  /// \\c X<int>::f is a FunctionTemplateDecl that describes the function\n  /// template\n  ///\n  /// \\code\n  /// template<typename U> void X<int>::f(int, U);\n  /// \\endcode\n  ///\n  /// which was itself created during the instantiation of \\c X<int>. Calling\n  /// getInstantiatedFromMemberTemplate() on this FunctionTemplateDecl will\n  /// retrieve the FunctionTemplateDecl for the original template \\c f within\n  /// the class template \\c X<T>, i.e.,\n  ///\n  /// \\code\n  /// template<typename T>\n  /// template<typename U>\n  /// void X<T>::f(T, U);\n  /// \\endcode\n  RedeclarableTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return getCommonPtr()->InstantiatedFromMember.getPointer();\n  }\n\n  void setInstantiatedFromMemberTemplate(RedeclarableTemplateDecl *TD) {\n    assert(!getCommonPtr()->InstantiatedFromMember.getPointer());\n    getCommonPtr()->InstantiatedFromMember.setPointer(TD);\n  }\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstRedeclarableTemplate && K <= lastRedeclarableTemplate;\n  }\n};\n\ntemplate <> struct RedeclarableTemplateDecl::\nSpecEntryTraits<FunctionTemplateSpecializationInfo> {\n  using DeclType = FunctionDecl;\n\n  static DeclType *getDecl(FunctionTemplateSpecializationInfo *I) {\n    return I->getFunction();\n  }\n\n  static ArrayRef<TemplateArgument>\n  getTemplateArgs(FunctionTemplateSpecializationInfo *I) {\n    return I->TemplateArguments->asArray();\n  }\n};\n\n/// Declaration of a template function.\nclass FunctionTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  friend class FunctionDecl;\n\n  /// Data that is common to all of the declarations of a given\n  /// function template.\n  struct Common : CommonBase {\n    /// The function template specializations for this function\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> Specializations;\n\n    /// The set of \"injected\" template arguments used within this\n    /// function template.\n    ///\n    /// This pointer refers to the template arguments (there are as\n    /// many template arguments as template parameaters) for the function\n    /// template, and is allocated lazily, since most function templates do not\n    /// require the use of this information.\n    TemplateArgument *InjectedArgs = nullptr;\n\n    Common() = default;\n  };\n\n  FunctionTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                       DeclarationName Name, TemplateParameterList *Params,\n                       NamedDecl *Decl)\n      : RedeclarableTemplateDecl(FunctionTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\n  /// Retrieve the set of function template specializations of this\n  /// function template.\n  llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> &\n  getSpecializations() const;\n\n  /// Add a specialization of this function template.\n  ///\n  /// \\param InsertPos Insert position in the FoldingSetVector, must have been\n  ///        retrieved by an earlier call to findSpecialization().\n  void addSpecialization(FunctionTemplateSpecializationInfo* Info,\n                         void *InsertPos);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying function declaration of the template.\n  FunctionDecl *getTemplatedDecl() const {\n    return static_cast<FunctionDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  FunctionDecl *findSpecialization(ArrayRef<TemplateArgument> Args,\n                                   void *&InsertPos);\n\n  FunctionTemplateDecl *getCanonicalDecl() override {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const FunctionTemplateDecl *getCanonicalDecl() const {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  FunctionTemplateDecl *getPreviousDecl() {\n    return cast_or_null<FunctionTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const FunctionTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<FunctionTemplateDecl>(\n       static_cast<const RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n\n  FunctionTemplateDecl *getMostRecentDecl() {\n    return cast<FunctionTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)\n            ->getMostRecentDecl());\n  }\n  const FunctionTemplateDecl *getMostRecentDecl() const {\n    return const_cast<FunctionTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  FunctionTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  using spec_iterator = SpecIterator<FunctionTemplateSpecializationInfo>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  /// Retrieve the \"injected\" template arguments that correspond to the\n  /// template parameters of this function template.\n  ///\n  /// Although the C++ standard has no notion of the \"injected\" template\n  /// arguments for a function template, the notion is convenient when\n  /// we need to perform substitutions inside the definition of a function\n  /// template.\n  ArrayRef<TemplateArgument> getInjectedTemplateArgs();\n\n  /// Return whether this function template is an abbreviated function template,\n  /// e.g. `void foo(auto x)` or `template<typename T> void foo(auto x)`\n  bool isAbbreviated() const {\n    // Since the invented template parameters generated from 'auto' parameters\n    // are either appended to the end of the explicit template parameter list or\n    // form a new template paramter list, we can simply observe the last\n    // parameter to determine if such a thing happened.\n    const TemplateParameterList *TPL = getTemplateParameters();\n    return TPL->getParam(TPL->size() - 1)->isImplicit();\n  }\n\n  /// Merge \\p Prev with our RedeclarableTemplateDecl::Common.\n  void mergePrevDecl(FunctionTemplateDecl *Prev);\n\n  /// Create a function template node.\n  static FunctionTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      DeclarationName Name,\n                                      TemplateParameterList *Params,\n                                      NamedDecl *Decl);\n\n  /// Create an empty function template node.\n  static FunctionTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FunctionTemplate; }\n};\n\n//===----------------------------------------------------------------------===//\n// Kinds of Template Parameters\n//===----------------------------------------------------------------------===//\n\n/// Defines the position of a template parameter within a template\n/// parameter list.\n///\n/// Because template parameter can be listed\n/// sequentially for out-of-line template members, each template parameter is\n/// given a Depth - the nesting of template parameter scopes - and a Position -\n/// the occurrence within the parameter list.\n/// This class is inheritedly privately by different kinds of template\n/// parameters and is not part of the Decl hierarchy. Just a facility.\nclass TemplateParmPosition {\nprotected:\n  // FIXME: These probably don't need to be ints. int:5 for depth, int:8 for\n  // position? Maybe?\n  unsigned Depth;\n  unsigned Position;\n\n  TemplateParmPosition(unsigned D, unsigned P) : Depth(D), Position(P) {}\n\npublic:\n  TemplateParmPosition() = delete;\n\n  /// Get the nesting depth of the template parameter.\n  unsigned getDepth() const { return Depth; }\n  void setDepth(unsigned D) { Depth = D; }\n\n  /// Get the position of the template parameter within its parameter list.\n  unsigned getPosition() const { return Position; }\n  void setPosition(unsigned P) { Position = P; }\n\n  /// Get the index of the template parameter within its parameter list.\n  unsigned getIndex() const { return Position; }\n};\n\n/// Declaration of a template type parameter.\n///\n/// For example, \"T\" in\n/// \\code\n/// template<typename T> class vector;\n/// \\endcode\nclass TemplateTypeParmDecl final : public TypeDecl,\n    private llvm::TrailingObjects<TemplateTypeParmDecl, TypeConstraint> {\n  /// Sema creates these on the stack during auto type deduction.\n  friend class Sema;\n  friend TrailingObjects;\n  friend class ASTDeclReader;\n\n  /// Whether this template type parameter was declaration with\n  /// the 'typename' keyword.\n  ///\n  /// If false, it was declared with the 'class' keyword.\n  bool Typename : 1;\n\n  /// Whether this template type parameter has a type-constraint construct.\n  bool HasTypeConstraint : 1;\n\n  /// Whether the type constraint has been initialized. This can be false if the\n  /// constraint was not initialized yet or if there was an error forming the\n  /// type constriant.\n  bool TypeConstraintInitialized : 1;\n\n  /// Whether this non-type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack : 1;\n\n  /// The number of type parameters in an expanded parameter pack.\n  unsigned NumExpanded = 0;\n\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTypeParmDecl, TypeSourceInfo *>;\n  DefArgStorage DefaultArgument;\n\n  TemplateTypeParmDecl(DeclContext *DC, SourceLocation KeyLoc,\n                       SourceLocation IdLoc, IdentifierInfo *Id,\n                       bool Typename, bool HasTypeConstraint,\n                       Optional<unsigned> NumExpanded)\n      : TypeDecl(TemplateTypeParm, DC, IdLoc, Id, KeyLoc), Typename(Typename),\n      HasTypeConstraint(HasTypeConstraint), TypeConstraintInitialized(false),\n      ExpandedParameterPack(NumExpanded),\n      NumExpanded(NumExpanded ? *NumExpanded : 0) {}\n\npublic:\n  static TemplateTypeParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                      SourceLocation KeyLoc,\n                                      SourceLocation NameLoc,\n                                      unsigned D, unsigned P,\n                                      IdentifierInfo *Id, bool Typename,\n                                      bool ParameterPack,\n                                      bool HasTypeConstraint = false,\n                                      Optional<unsigned> NumExpanded = None);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID,\n                                                  bool HasTypeConstraint);\n\n  /// Whether this template type parameter was declared with\n  /// the 'typename' keyword.\n  ///\n  /// If not, it was either declared with the 'class' keyword or with a\n  /// type-constraint (see hasTypeConstraint()).\n  bool wasDeclaredWithTypename() const {\n    return Typename && !HasTypeConstraint;\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  QualType getDefaultArgument() const {\n    return DefaultArgument.get()->getType();\n  }\n\n  /// Retrieves the default argument's source information, if any.\n  TypeSourceInfo *getDefaultArgumentInfo() const {\n    return DefaultArgument.get();\n  }\n\n  /// Retrieves the location of the default argument declaration.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter.\n  void setDefaultArgument(TypeSourceInfo *DefArg) {\n    DefaultArgument.set(DefArg);\n  }\n\n  /// Set that this default argument was inherited from another\n  /// parameter.\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTypeParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() {\n    DefaultArgument.clear();\n  }\n\n  /// Set whether this template type parameter was declared with\n  /// the 'typename' or 'class' keyword.\n  void setDeclaredWithTypename(bool withTypename) { Typename = withTypename; }\n\n  /// Retrieve the depth of the template parameter.\n  unsigned getDepth() const;\n\n  /// Retrieve the index of the template parameter.\n  unsigned getIndex() const;\n\n  /// Returns whether this is a parameter pack.\n  bool isParameterPack() const;\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template type template parameter pack can be a pack expansion if its\n  /// type-constraint contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    if (!isParameterPack())\n      return false;\n    if (const TypeConstraint *TC = getTypeConstraint())\n      if (TC->hasExplicitTemplateArgs())\n        for (const auto &ArgLoc : TC->getTemplateArgsAsWritten()->arguments())\n          if (ArgLoc.getArgument().containsUnexpandedParameterPack())\n            return true;\n    return false;\n  }\n\n  /// Whether this parameter is a template type parameter pack that has a known\n  /// list of different type-constraints at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type-constraint was itself a pack expansion, and that\n  /// expansion has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<convertible_to<Types> ...Convertibles>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Convertibles has (convertible_to<Types> && ...) as\n  /// its type-constraint. When \\c Types is supplied with template arguments by\n  /// instantiating \\c X, the instantiation of \\c Convertibles becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Convertibles being an expanded\n  /// parameter pack of size 2 (use getNumExpansionTypes() to get this number).\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of parameters in an expanded parameter pack.\n  unsigned getNumExpansionParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpanded;\n  }\n\n  /// Returns the type constraint associated with this template parameter (if\n  /// any).\n  const TypeConstraint *getTypeConstraint() const {\n    return TypeConstraintInitialized ? getTrailingObjects<TypeConstraint>() :\n         nullptr;\n  }\n\n  void setTypeConstraint(NestedNameSpecifierLoc NNS,\n                         DeclarationNameInfo NameInfo, NamedDecl *FoundDecl,\n                         ConceptDecl *CD,\n                         const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                         Expr *ImmediatelyDeclaredConstraint);\n\n  /// Determine whether this template parameter has a type-constraint.\n  bool hasTypeConstraint() const {\n    return HasTypeConstraint;\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be the immediately-introduced constraint or empty.\n  ///\n  /// Use this instead of getConstraintExpression for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (HasTypeConstraint)\n      AC.push_back(getTypeConstraint()->getImmediatelyDeclaredConstraint());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTypeParm; }\n};\n\n/// NonTypeTemplateParmDecl - Declares a non-type template parameter,\n/// e.g., \"Size\" in\n/// @code\n/// template<int Size> class array { };\n/// @endcode\nclass NonTypeTemplateParmDecl final\n    : public DeclaratorDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<NonTypeTemplateParmDecl,\n                                    std::pair<QualType, TypeSourceInfo *>,\n                                    Expr *> {\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  /// The default template argument, if any, and whether or not\n  /// it was inherited.\n  using DefArgStorage = DefaultArgStorage<NonTypeTemplateParmDecl, Expr *>;\n  DefArgStorage DefaultArgument;\n\n  // FIXME: Collapse this into TemplateParamPosition; or, just move depth/index\n  // down here to save memory.\n\n  /// Whether this non-type template parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this non-type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of types in an expanded parameter pack.\n  unsigned NumExpandedTypes = 0;\n\n  size_t numTrailingObjects(\n      OverloadToken<std::pair<QualType, TypeSourceInfo *>>) const {\n    return NumExpandedTypes;\n  }\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          bool ParameterPack, TypeSourceInfo *TInfo)\n      : DeclaratorDecl(NonTypeTemplateParm, DC, IdLoc, Id, T, TInfo, StartLoc),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          TypeSourceInfo *TInfo,\n                          ArrayRef<QualType> ExpandedTypes,\n                          ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\npublic:\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, bool ParameterPack, TypeSourceInfo *TInfo);\n\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, TypeSourceInfo *TInfo, ArrayRef<QualType> ExpandedTypes,\n         ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     bool HasTypeConstraint);\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     unsigned NumExpandedTypes,\n                                                     bool HasTypeConstraint);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  Expr *getDefaultArgument() const { return DefaultArgument.get(); }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(Expr *DefArg) { DefaultArgument.set(DefArg); }\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   NonTypeTemplateParmDecl *Parm) {\n    DefaultArgument.setInherited(C, Parm);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  /// Whether this parameter is a non-type template parameter pack.\n  ///\n  /// If the parameter is a parameter pack, the type may be a\n  /// \\c PackExpansionType. In the following example, the \\c Dims parameter\n  /// is a parameter pack (whose type is 'unsigned').\n  ///\n  /// \\code\n  /// template<typename T, unsigned ...Dims> struct multi_array;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A non-type template parameter pack is a pack expansion if its type\n  /// contains an unexpanded parameter pack. In this case, we will have\n  /// built a PackExpansionType wrapping the type.\n  bool isPackExpansion() const {\n    return ParameterPack && getType()->getAs<PackExpansionType>();\n  }\n\n  /// Whether this parameter is a non-type template parameter pack\n  /// that has a known list of different types at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type was itself a pack expansion, and that expansion\n  /// has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<Types ...Values>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Values has a \\c PackExpansionType as its type,\n  /// which expands \\c Types. When \\c Types is supplied with template arguments\n  /// by instantiating \\c X, the instantiation of \\c Values becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Values being an expanded parameter\n  /// pack with expansion types \\c int and \\c unsigned int.\n  ///\n  /// The \\c getExpansionType() and \\c getExpansionTypeSourceInfo() functions\n  /// return the expansion types.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion types in an expanded parameter\n  /// pack.\n  unsigned getNumExpansionTypes() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedTypes;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  QualType getExpansionType(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].first;\n  }\n\n  /// Retrieve a particular expansion type source info within an\n  /// expanded parameter pack.\n  TypeSourceInfo *getExpansionTypeSourceInfo(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].second;\n  }\n\n  /// Return the constraint introduced by the placeholder type of this non-type\n  /// template parameter (if any).\n  Expr *getPlaceholderTypeConstraint() const {\n    return hasPlaceholderTypeConstraint() ? *getTrailingObjects<Expr *>() :\n        nullptr;\n  }\n\n  void setPlaceholderTypeConstraint(Expr *E) {\n    *getTrailingObjects<Expr *>() = E;\n  }\n\n  /// Determine whether this non-type template parameter's type has a\n  /// placeholder with a type-constraint.\n  bool hasPlaceholderTypeConstraint() const {\n    auto *AT = getType()->getContainedAutoType();\n    return AT && AT->isConstrained();\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be a vector of size 1 containing the immediately-declared\n  /// constraint introduced by the placeholder type, or an empty vector.\n  ///\n  /// Use this instead of getPlaceholderImmediatelyDeclaredConstraint for\n  /// concepts APIs that accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (Expr *E = getPlaceholderTypeConstraint())\n      AC.push_back(E);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NonTypeTemplateParm; }\n};\n\n/// TemplateTemplateParmDecl - Declares a template template parameter,\n/// e.g., \"T\" in\n/// @code\n/// template <template <typename> class T> class container { };\n/// @endcode\n/// A template template parameter is a TemplateDecl because it defines the\n/// name of a template and the template parameters allowable for substitution.\nclass TemplateTemplateParmDecl final\n    : public TemplateDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<TemplateTemplateParmDecl,\n                                    TemplateParameterList *> {\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTemplateParmDecl, TemplateArgumentLoc *>;\n  DefArgStorage DefaultArgument;\n\n  /// Whether this parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this template template parameter is an \"expanded\"\n  /// parameter pack, meaning that it is a pack expansion and we\n  /// already know the set of template parameters that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of parameters in an expanded parameter pack.\n  unsigned NumExpandedParams = 0;\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P, bool ParameterPack,\n                           IdentifierInfo *Id, TemplateParameterList *Params)\n      : TemplateDecl(TemplateTemplateParm, DC, L, Id, Params),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P,\n                           IdentifierInfo *Id, TemplateParameterList *Params,\n                           ArrayRef<TemplateParameterList *> Expansions);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P, bool ParameterPack,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params);\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params,\n                                 ArrayRef<TemplateParameterList *> Expansions);\n\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID);\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID,\n                                                      unsigned NumExpansions);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  /// Whether this template template parameter is a template\n  /// parameter pack.\n  ///\n  /// \\code\n  /// template<template <class T> ...MetaFunctions> struct Apply;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template template parameter pack is a pack expansion if its template\n  /// parameter list contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    return ParameterPack &&\n           getTemplateParameters()->containsUnexpandedParameterPack();\n  }\n\n  /// Whether this parameter is a template template parameter pack that\n  /// has a known list of different template parameter lists at different\n  /// positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original parameter\n  /// pack's template parameter list was itself a pack expansion, and that\n  /// expansion has already been expanded. For exampe, given:\n  ///\n  /// \\code\n  /// template<typename...Types> struct Outer {\n  ///   template<template<Types> class...Templates> struct Inner;\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Templates is a pack expansion, which expands the\n  /// pack \\c Types. When \\c Types is supplied with template arguments by\n  /// instantiating \\c Outer, the instantiation of \\c Templates is an expanded\n  /// parameter pack.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion template parameters in\n  /// an expanded parameter pack.\n  unsigned getNumExpansionTemplateParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedParams;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  TemplateParameterList *getExpansionTemplateParameters(unsigned I) const {\n    assert(I < NumExpandedParams && \"Out-of-range expansion type index\");\n    return getTrailingObjects<TemplateParameterList *>()[I];\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  const TemplateArgumentLoc &getDefaultArgument() const {\n    static const TemplateArgumentLoc NoneLoc;\n    return DefaultArgument.isSet() ? *DefaultArgument.get() : NoneLoc;\n  }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(const ASTContext &C,\n                          const TemplateArgumentLoc &DefArg);\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTemplateParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    SourceLocation End = getLocation();\n    if (hasDefaultArgument() && !defaultArgumentWasInherited())\n      End = getDefaultArgument().getSourceRange().getEnd();\n    return SourceRange(getTemplateParameters()->getTemplateLoc(), End);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTemplateParm; }\n};\n\n/// Represents the builtin template declaration which is used to\n/// implement __make_integer_seq and other builtin templates.  It serves\n/// no real purpose beyond existing as a place to hold template parameters.\nclass BuiltinTemplateDecl : public TemplateDecl {\n  BuiltinTemplateKind BTK;\n\n  BuiltinTemplateDecl(const ASTContext &C, DeclContext *DC,\n                      DeclarationName Name, BuiltinTemplateKind BTK);\n\n  void anchor() override;\n\npublic:\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == BuiltinTemplate; }\n\n  static BuiltinTemplateDecl *Create(const ASTContext &C, DeclContext *DC,\n                                     DeclarationName Name,\n                                     BuiltinTemplateKind BTK) {\n    return new (C, DC) BuiltinTemplateDecl(C, DC, Name, BTK);\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return {};\n  }\n\n  BuiltinTemplateKind getBuiltinTemplateKind() const { return BTK; }\n};\n\n/// Represents a class template specialization, which refers to\n/// a class template with a given set of template arguments.\n///\n/// Class template specializations represent both explicit\n/// specialization of class templates, as in the example below, and\n/// implicit instantiations of class templates.\n///\n/// \\code\n/// template<typename T> class array;\n///\n/// template<>\n/// class array<bool> { }; // class template specialization array<bool>\n/// \\endcode\nclass ClassTemplateSpecializationDecl\n  : public CXXRecordDecl, public llvm::FoldingSetNode {\n  /// Structure that stores information about a class template\n  /// specialization that was instantiated from a class template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The class template partial specialization from which this\n    /// class template specialization was instantiated.\n    ClassTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the class template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes\n  llvm::PointerUnion<ClassTemplateDecl *, SpecializedPartialSpecialization *>\n    SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n\n  /// The point where this template was instantiated (if any)\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\nprotected:\n  ClassTemplateSpecializationDecl(ASTContext &Context, Kind DK, TagKind TK,\n                                  DeclContext *DC, SourceLocation StartLoc,\n                                  SourceLocation IdLoc,\n                                  ClassTemplateDecl *SpecializedTemplate,\n                                  ArrayRef<TemplateArgument> Args,\n                                  ClassTemplateSpecializationDecl *PrevDecl);\n\n  explicit ClassTemplateSpecializationDecl(ASTContext &C, Kind DK);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplateSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         ClassTemplateSpecializationDecl *PrevDecl);\n  static ClassTemplateSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  // FIXME: This is broken. CXXRecordDecl::getMostRecentDecl() returns a\n  // different \"most recent\" declaration from this function for the same\n  // declaration, because we don't override getMostRecentDeclImpl(). But\n  // it's not clear that we should override that, because the most recent\n  // declaration as a CXXRecordDecl sometimes is the injected-class-name.\n  ClassTemplateSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplateSpecializationDecl>(\n        getMostRecentNonInjectedDecl());\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  ClassTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the class template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const {\n    return *TemplateArgs;\n  }\n\n  void setTemplateArgs(TemplateArgumentList *Args) {\n    TemplateArgs = Args;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// Is this an explicit specialization at class scope (within the class that\n  /// owns the primary template)? For example:\n  ///\n  /// \\code\n  /// template<typename T> struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<> struct Inner; // class-scope explicit specialization\n  /// };\n  /// \\endcode\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializedTemplate(ClassTemplateDecl *Specialized) {\n    SpecializedTemplate = Specialized;\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  /// If this class template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// class template or class template partial specialization from which it\n  /// was instantiated.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the class template or class template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<ClassTemplateDecl*>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate members of the class template or class template partial\n  /// specialization from which this class template specialization was\n  /// instantiated.\n  ///\n  /// \\returns For a class template specialization instantiated from the primary\n  /// template, this function will return the same template arguments as\n  /// getTemplateArgs(). For a class template specialization instantiated from\n  /// a class template partial specialization, this function will return the\n  /// deduced template arguments for the class template partial specialization\n  /// itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this class template specialization is actually an\n  /// instantiation of the given class template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Already set to a class template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this class template specialization is an instantiation\n  /// of the given class template.\n  void setInstantiationOf(ClassTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Previously set to a class template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user. This will be a class template specialization type.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstClassTemplateSpecialization &&\n           K <= lastClassTemplateSpecialization;\n  }\n};\n\nclass ClassTemplatePartialSpecializationDecl\n  : public ClassTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList* TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The class template partial specialization from which this\n  /// class template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this class template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<ClassTemplatePartialSpecializationDecl *, 1, bool>\n      InstantiatedFromMember;\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &Context, TagKind TK,\n                                         DeclContext *DC,\n                                         SourceLocation StartLoc,\n                                         SourceLocation IdLoc,\n                                         TemplateParameterList *Params,\n                                         ClassTemplateDecl *SpecializedTemplate,\n                                         ArrayRef<TemplateArgument> Args,\n                               const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                               ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &C)\n    : ClassTemplateSpecializationDecl(C, ClassTemplatePartialSpecialization),\n      InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         TemplateParameterList *Params,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos,\n         QualType CanonInjectedType,\n         ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  static ClassTemplatePartialSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ClassTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplatePartialSpecializationDecl>(\n             static_cast<ClassTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// Retrieve the member class template partial specialization from\n  /// which this particular class template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*> { }; // #1\n  /// };\n  ///\n  /// Outer<float>::Inner<int*> ii;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the class\n  /// template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  ClassTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n  ClassTemplatePartialSpecializationDecl *\n  getInstantiatedFromMemberTemplate() const {\n    return getInstantiatedFromMember();\n  }\n\n  void setInstantiatedFromMember(\n                          ClassTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this class template partial specialization\n  /// template was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*>;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// struct X<int>::Inner<T*> { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieves the injected specialization type for this partial\n  /// specialization.  This is not the same as the type-decl-type for\n  /// this partial specialization, which is an InjectedClassNameType.\n  QualType getInjectedSpecializationType() const {\n    assert(getTypeForDecl() && \"partial specialization has no type set!\");\n    return cast<InjectedClassNameType>(getTypeForDecl())\n             ->getInjectedSpecializationType();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == ClassTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a class template.\nclass ClassTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// class template.\n  struct Common : CommonBase {\n    /// The class template specializations for this class\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<ClassTemplateSpecializationDecl> Specializations;\n\n    /// The class template partial specializations for this class\n    /// template.\n    llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl>\n      PartialSpecializations;\n\n    /// The injected-class-name type for this class template.\n    QualType InjectedClassNameType;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this class template.\n  llvm::FoldingSetVector<ClassTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  ClassTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName Name, TemplateParameterList *Params,\n                    NamedDecl *Decl)\n      : RedeclarableTemplateDecl(ClassTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying class declarations of the template.\n  CXXRecordDecl *getTemplatedDecl() const {\n    return static_cast<CXXRecordDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// class pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// \\brief Create a class template node.\n  static ClassTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L,\n                                   DeclarationName Name,\n                                   TemplateParameterList *Params,\n                                   NamedDecl *Decl);\n\n  /// Create an empty class template node.\n  static ClassTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  ClassTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(ClassTemplateSpecializationDecl *D, void *InsertPos);\n\n  ClassTemplateDecl *getCanonicalDecl() override {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const ClassTemplateDecl *getCanonicalDecl() const {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this class template, or\n  /// nullptr if no such declaration exists.\n  ClassTemplateDecl *getPreviousDecl() {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const ClassTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  ClassTemplateDecl *getMostRecentDecl() {\n    return cast<ClassTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const ClassTemplateDecl *getMostRecentDecl() const {\n    return const_cast<ClassTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  ClassTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(ClassTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<ClassTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a class template partial specialization with the given\n  /// type T.\n  ///\n  /// \\param T a dependent type that names a specialization of this class\n  /// template.\n  ///\n  /// \\returns the class template partial specialization that exactly matches\n  /// the type \\p T, or nullptr if no such partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *findPartialSpecialization(QualType T);\n\n  /// Find a class template partial specialization which was instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member class template partial specialization.\n  ///\n  /// \\returns the class template partial specialization which was instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecInstantiatedFromMember(\n                                     ClassTemplatePartialSpecializationDecl *D);\n\n  /// Retrieve the template specialization type of the\n  /// injected-class-name for this class template.\n  ///\n  /// The injected-class-name for a class template \\c X is \\c\n  /// X<template-args>, where \\c template-args is formed from the\n  /// template arguments that correspond to the template parameters of\n  /// \\c X. For example:\n  ///\n  /// \\code\n  /// template<typename T, int N>\n  /// struct array {\n  ///   typedef array this_type; // \"array\" is equivalent to \"array<T, N>\"\n  /// };\n  /// \\endcode\n  QualType getInjectedClassNameSpecialization();\n\n  using spec_iterator = SpecIterator<ClassTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ClassTemplate; }\n};\n\n/// Declaration of a friend template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> class A {\n///   friend class MyVector<T>; // not a friend template\n///   template \\<typename U> friend class B; // not a friend template\n///   template \\<typename U> friend class Foo<T>::Nested; // friend template\n/// };\n/// \\endcode\n///\n/// \\note This class is not currently in use.  All of the above\n/// will yield a FriendDecl, not a FriendTemplateDecl.\nclass FriendTemplateDecl : public Decl {\n  virtual void anchor();\n\npublic:\n  using FriendUnion = llvm::PointerUnion<NamedDecl *,TypeSourceInfo *>;\n\nprivate:\n  // The number of template parameters;  always non-zero.\n  unsigned NumParams = 0;\n\n  // The parameter list.\n  TemplateParameterList **Params = nullptr;\n\n  // The declaration that's a friend of this class.\n  FriendUnion Friend;\n\n  // Location of the 'friend' specifier.\n  SourceLocation FriendLoc;\n\n  FriendTemplateDecl(DeclContext *DC, SourceLocation Loc,\n                     MutableArrayRef<TemplateParameterList *> Params,\n                     FriendUnion Friend, SourceLocation FriendLoc)\n      : Decl(Decl::FriendTemplate, DC, Loc), NumParams(Params.size()),\n        Params(Params.data()), Friend(Friend), FriendLoc(FriendLoc) {}\n\n  FriendTemplateDecl(EmptyShell Empty) : Decl(Decl::FriendTemplate, Empty) {}\n\npublic:\n  friend class ASTDeclReader;\n\n  static FriendTemplateDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation Loc,\n         MutableArrayRef<TemplateParameterList *> Params, FriendUnion Friend,\n         SourceLocation FriendLoc);\n\n  static FriendTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// If this friend declaration names a templated type (or\n  /// a dependent member type of a templated type), return that\n  /// type;  otherwise return null.\n  TypeSourceInfo *getFriendType() const {\n    return Friend.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// If this friend declaration names a templated function (or\n  /// a member function of a templated type), return that type;\n  /// otherwise return null.\n  NamedDecl *getFriendDecl() const {\n    return Friend.dyn_cast<NamedDecl*>();\n  }\n\n  /// Retrieves the location of the 'friend' keyword.\n  SourceLocation getFriendLoc() const {\n    return FriendLoc;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i <= NumParams);\n    return Params[i];\n  }\n\n  unsigned getNumTemplateParameters() const {\n    return NumParams;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::FriendTemplate; }\n};\n\n/// Declaration of an alias template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> using V = std::map<T*, int, MyCompare<T>>;\n/// \\endcode\nclass TypeAliasTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  using Common = CommonBase;\n\n  TypeAliasTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                        DeclarationName Name, TemplateParameterList *Params,\n                        NamedDecl *Decl)\n      : RedeclarableTemplateDecl(TypeAliasTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the underlying function declaration of the template.\n  TypeAliasDecl *getTemplatedDecl() const {\n    return static_cast<TypeAliasDecl *>(TemplatedDecl);\n  }\n\n\n  TypeAliasTemplateDecl *getCanonicalDecl() override {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const TypeAliasTemplateDecl *getCanonicalDecl() const {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  TypeAliasTemplateDecl *getPreviousDecl() {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const TypeAliasTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  TypeAliasTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Create a function template node.\n  static TypeAliasTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                       SourceLocation L,\n                                       DeclarationName Name,\n                                       TemplateParameterList *Params,\n                                       NamedDecl *Decl);\n\n  /// Create an empty alias template node.\n  static TypeAliasTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAliasTemplate; }\n};\n\n/// Declaration of a function specialization at template class scope.\n///\n/// For example:\n/// \\code\n/// template <class T>\n/// class A {\n///    template <class U> void foo(U a) { }\n///    template<> void foo(int a) { }\n/// }\n/// \\endcode\n///\n/// \"template<> foo(int a)\" will be saved in Specialization as a normal\n/// CXXMethodDecl. Then during an instantiation of class A, it will be\n/// transformed into an actual function specialization.\n///\n/// FIXME: This is redundant; we could store the same information directly on\n/// the CXXMethodDecl as a DependentFunctionTemplateSpecializationInfo.\nclass ClassScopeFunctionSpecializationDecl : public Decl {\n  CXXMethodDecl *Specialization;\n  const ASTTemplateArgumentListInfo *TemplateArgs;\n\n  ClassScopeFunctionSpecializationDecl(\n      DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n      const ASTTemplateArgumentListInfo *TemplArgs)\n      : Decl(Decl::ClassScopeFunctionSpecialization, DC, Loc),\n        Specialization(FD), TemplateArgs(TemplArgs) {}\n\n  ClassScopeFunctionSpecializationDecl(EmptyShell Empty)\n      : Decl(Decl::ClassScopeFunctionSpecialization, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  CXXMethodDecl *getSpecialization() const { return Specialization; }\n  bool hasExplicitTemplateArgs() const { return TemplateArgs; }\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return TemplateArgs;\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n         bool HasExplicitTemplateArgs,\n         const TemplateArgumentListInfo &TemplateArgs) {\n    return new (C, DC) ClassScopeFunctionSpecializationDecl(\n        DC, Loc, FD,\n        HasExplicitTemplateArgs\n            ? ASTTemplateArgumentListInfo::Create(C, TemplateArgs)\n            : nullptr);\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  CreateDeserialized(ASTContext &Context, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == Decl::ClassScopeFunctionSpecialization;\n  }\n};\n\n/// Represents a variable template specialization, which refers to\n/// a variable template with a given set of template arguments.\n///\n/// Variable template specializations represent both explicit\n/// specializations of variable templates, as in the example below, and\n/// implicit instantiations of variable templates.\n///\n/// \\code\n/// template<typename T> constexpr T pi = T(3.1415926535897932385);\n///\n/// template<>\n/// constexpr float pi<float>; // variable template specialization pi<float>\n/// \\endcode\nclass VarTemplateSpecializationDecl : public VarDecl,\n                                      public llvm::FoldingSetNode {\n\n  /// Structure that stores information about a variable template\n  /// specialization that was instantiated from a variable template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The variable template partial specialization from which this\n    /// variable template specialization was instantiated.\n    VarTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the variable template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes.\n  llvm::PointerUnion<VarTemplateDecl *, SpecializedPartialSpecialization *>\n  SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n  TemplateArgumentListInfo TemplateArgsInfo;\n\n  /// The point where this template was instantiated (if any).\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\n  /// Whether this declaration is a complete definition of the\n  /// variable template specialization. We can't otherwise tell apart\n  /// an instantiated declaration from an instantiated definition with\n  /// no initializer.\n  unsigned IsCompleteDefinition : 1;\n\nprotected:\n  VarTemplateSpecializationDecl(Kind DK, ASTContext &Context, DeclContext *DC,\n                                SourceLocation StartLoc, SourceLocation IdLoc,\n                                VarTemplateDecl *SpecializedTemplate,\n                                QualType T, TypeSourceInfo *TInfo,\n                                StorageClass S,\n                                ArrayRef<TemplateArgument> Args);\n\n  explicit VarTemplateSpecializationDecl(Kind DK, ASTContext &Context);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class VarDecl;\n\n  static VarTemplateSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S,\n         ArrayRef<TemplateArgument> Args);\n  static VarTemplateSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  VarTemplateSpecializationDecl *getMostRecentDecl() {\n    VarDecl *Recent = static_cast<VarDecl *>(this)->getMostRecentDecl();\n    return cast<VarTemplateSpecializationDecl>(Recent);\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  VarTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the variable template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const { return *TemplateArgs; }\n\n  // TODO: Always set this when creating the new specialization?\n  void setTemplateArgsInfo(const TemplateArgumentListInfo &ArgsInfo);\n\n  const TemplateArgumentListInfo &getTemplateArgsInfo() const {\n    return TemplateArgsInfo;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  void setCompleteDefinition() { IsCompleteDefinition = true; }\n\n  /// If this variable template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// variable template or variable template partial specialization from which\n  /// it was instantiated.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<VarTemplateDecl *,\n                                VarTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the variable template or variable template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<VarTemplateDecl *>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate the initializer of the variable template or variable\n  /// template partial specialization from which this variable template\n  /// specialization was instantiated.\n  ///\n  /// \\returns For a variable template specialization instantiated from the\n  /// primary template, this function will return the same template arguments\n  /// as getTemplateArgs(). For a variable template specialization instantiated\n  /// from a variable template partial specialization, this function will the\n  /// return deduced template arguments for the variable template partial\n  /// specialization itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this variable template specialization is actually an\n  /// instantiation of the given variable template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(VarTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Already set to a variable template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this variable template specialization is an instantiation\n  /// of the given variable template.\n  void setInstantiationOf(VarTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Previously set to a variable template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      ArrayRef<TemplateArgument> TemplateArgs,\n                      ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstVarTemplateSpecialization &&\n           K <= lastVarTemplateSpecialization;\n  }\n};\n\nclass VarTemplatePartialSpecializationDecl\n    : public VarTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList *TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The variable template partial specialization from which this\n  /// variable template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this variable template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<VarTemplatePartialSpecializationDecl *, 1, bool>\n  InstantiatedFromMember;\n\n  VarTemplatePartialSpecializationDecl(\n      ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n      SourceLocation IdLoc, TemplateParameterList *Params,\n      VarTemplateDecl *SpecializedTemplate, QualType T, TypeSourceInfo *TInfo,\n      StorageClass S, ArrayRef<TemplateArgument> Args,\n      const ASTTemplateArgumentListInfo *ArgInfos);\n\n  VarTemplatePartialSpecializationDecl(ASTContext &Context)\n      : VarTemplateSpecializationDecl(VarTemplatePartialSpecialization,\n                                      Context),\n        InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static VarTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, TemplateParameterList *Params,\n         VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S, ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos);\n\n  static VarTemplatePartialSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                                  unsigned ID);\n\n  VarTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<VarTemplatePartialSpecializationDecl>(\n             static_cast<VarTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// \\brief Retrieve the member variable template partial specialization from\n  /// which this particular variable template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0); // #1\n  /// };\n  ///\n  /// template int* Outer<float>::Inner<int*>;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the\n  /// variable template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  VarTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n\n  void\n  setInstantiatedFromMember(VarTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this variable template partial specialization\n  /// was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0);\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// U* X<int>::Inner<T*> = (T*)(0) + 1;\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == VarTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a variable template.\nclass VarTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// variable template.\n  struct Common : CommonBase {\n    /// The variable template specializations for this variable\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<VarTemplateSpecializationDecl> Specializations;\n\n    /// The variable template partial specializations for this variable\n    /// template.\n    llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl>\n    PartialSpecializations;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this variable template.\n  llvm::FoldingSetVector<VarTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  VarTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                  DeclarationName Name, TemplateParameterList *Params,\n                  NamedDecl *Decl)\n      : RedeclarableTemplateDecl(VarTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying variable declarations of the template.\n  VarDecl *getTemplatedDecl() const {\n    return static_cast<VarDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// variable pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  VarTemplateDecl *getDefinition();\n\n  /// Create a variable template node.\n  static VarTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, DeclarationName Name,\n                                 TemplateParameterList *Params,\n                                 VarDecl *Decl);\n\n  /// Create an empty variable template node.\n  static VarTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  VarTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(VarTemplateSpecializationDecl *D, void *InsertPos);\n\n  VarTemplateDecl *getCanonicalDecl() override {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const VarTemplateDecl *getCanonicalDecl() const {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this variable template, or\n  /// nullptr if no such declaration exists.\n  VarTemplateDecl *getPreviousDecl() {\n    return cast_or_null<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const VarTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<VarTemplateDecl>(\n            static_cast<const RedeclarableTemplateDecl *>(\n              this)->getPreviousDecl());\n  }\n\n  VarTemplateDecl *getMostRecentDecl() {\n    return cast<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const VarTemplateDecl *getMostRecentDecl() const {\n    return const_cast<VarTemplateDecl *>(this)->getMostRecentDecl();\n  }\n\n  VarTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<VarTemplateDecl>(\n        RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  VarTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(VarTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<VarTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member variable template partial specialization.\n  ///\n  /// \\returns the variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  VarTemplatePartialSpecializationDecl *findPartialSpecInstantiatedFromMember(\n      VarTemplatePartialSpecializationDecl *D);\n\n  using spec_iterator = SpecIterator<VarTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == VarTemplate; }\n};\n\n/// Declaration of a C++2a concept.\nclass ConceptDecl : public TemplateDecl, public Mergeable<ConceptDecl> {\nprotected:\n  Expr *ConstraintExpr;\n\n  ConceptDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n              TemplateParameterList *Params, Expr *ConstraintExpr)\n      : TemplateDecl(Concept, DC, L, Name, Params),\n        ConstraintExpr(ConstraintExpr) {};\npublic:\n  static ConceptDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation L, DeclarationName Name,\n                             TemplateParameterList *Params,\n                             Expr *ConstraintExpr);\n  static ConceptDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getConstraintExpr() const {\n    return ConstraintExpr;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       ConstraintExpr->getEndLoc());\n  }\n\n  bool isTypeConcept() const {\n    return isa<TemplateTypeParmDecl>(getTemplateParameters()->getParam(0));\n  }\n\n  ConceptDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ConceptDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Concept; }\n\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n};\n\n/// A template parameter object.\n///\n/// Template parameter objects represent values of class type used as template\n/// arguments. There is one template parameter object for each such distinct\n/// value used as a template argument across the program.\n///\n/// \\code\n/// struct A { int x, y; };\n/// template<A> struct S;\n/// S<A{1, 2}> s1;\n/// S<A{1, 2}> s2; // same type, argument is same TemplateParamObjectDecl.\n/// \\endcode\nclass TemplateParamObjectDecl : public ValueDecl,\n                                public Mergeable<TemplateParamObjectDecl>,\n                                public llvm::FoldingSetNode {\nprivate:\n  /// The value of this template parameter object.\n  APValue Value;\n\n  TemplateParamObjectDecl(DeclContext *DC, QualType T, const APValue &V)\n      : ValueDecl(TemplateParamObject, DC, SourceLocation(), DeclarationName(),\n                  T),\n        Value(V) {}\n\n  static TemplateParamObjectDecl *Create(const ASTContext &C, QualType T,\n                                         const APValue &V);\n  static TemplateParamObjectDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Only ASTContext::getTemplateParamObjectDecl and deserialization\n  /// create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this template parameter object in a human-readable format.\n  void printName(llvm::raw_ostream &OS) const override;\n\n  /// Print this object as an equivalent expression.\n  void printAsExpr(llvm::raw_ostream &OS) const;\n\n  /// Print this object as an initializer suitable for a variable of the\n  /// object's type.\n  void printAsInit(llvm::raw_ostream &OS) const;\n\n  const APValue &getValue() const { return Value; }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T,\n                      const APValue &V) {\n    ID.AddPointer(T.getCanonicalType().getAsOpaquePtr());\n    V.Profile(ID);\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getType(), getValue());\n  }\n\n  TemplateParamObjectDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const TemplateParamObjectDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateParamObject; }\n};\n\ninline NamedDecl *getAsNamedDecl(TemplateParameter P) {\n  if (auto *PD = P.dyn_cast<TemplateTypeParmDecl *>())\n    return PD;\n  if (auto *PD = P.dyn_cast<NonTypeTemplateParmDecl *>())\n    return PD;\n  return P.get<TemplateTemplateParmDecl *>();\n}\n\ninline TemplateDecl *getAsTypeTemplateDecl(Decl *D) {\n  auto *TD = dyn_cast<TemplateDecl>(D);\n  return TD && (isa<ClassTemplateDecl>(TD) ||\n                isa<ClassTemplatePartialSpecializationDecl>(TD) ||\n                isa<TypeAliasTemplateDecl>(TD) ||\n                isa<TemplateTemplateParmDecl>(TD))\n             ? TD\n             : nullptr;\n}\n\n/// Check whether the template parameter is a pack expansion, and if so,\n/// determine the number of parameters produced by that expansion. For instance:\n///\n/// \\code\n/// template<typename ...Ts> struct A {\n///   template<Ts ...NTs, template<Ts> class ...TTs, typename ...Us> struct B;\n/// };\n/// \\endcode\n///\n/// In \\c A<int,int>::B, \\c NTs and \\c TTs have expanded pack size 2, and \\c Us\n/// is not a pack expansion, so returns an empty Optional.\ninline Optional<unsigned> getExpandedPackSize(const NamedDecl *Param) {\n  if (const auto *TTP = dyn_cast<TemplateTypeParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionParameters();\n  }\n\n  if (const auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n    if (NTTP->isExpandedParameterPack())\n      return NTTP->getNumExpansionTypes();\n  }\n\n  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionTemplateParameters();\n  }\n\n  return None;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLTEMPLATE_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "content": "//===- DeclarationName.h - Representation of declaration names --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the DeclarationName and DeclarationNameTable classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLARATIONNAME_H\n#define LLVM_CLANG_AST_DECLARATIONNAME_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <string>\n\nnamespace clang {\n\nclass ASTContext;\ntemplate <typename> class CanQual;\nclass DeclarationName;\nclass DeclarationNameTable;\nclass MultiKeywordSelector;\nstruct PrintingPolicy;\nclass TemplateDecl;\nclass TypeSourceInfo;\nclass UsingDirectiveDecl;\n\nusing CanQualType = CanQual<Type>;\n\nnamespace detail {\n\n/// CXXSpecialNameExtra records the type associated with one of the \"special\"\n/// kinds of declaration names in C++, e.g., constructors, destructors, and\n/// conversion functions. Note that CXXSpecialName is used for C++ constructor,\n/// destructor and conversion functions, but the actual kind is not stored in\n/// CXXSpecialName. Instead we use three different FoldingSet<CXXSpecialName>\n/// in DeclarationNameTable.\nclass alignas(IdentifierInfoAlignment) CXXSpecialNameExtra\n    : public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The type associated with this declaration name.\n  QualType Type;\n\n  /// Extra information associated with this declaration name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXSpecialNameExtra(QualType QT) : Type(QT), FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    ID.AddPointer(Type.getAsOpaquePtr());\n  }\n};\n\n/// Contains extra information for the name of a C++ deduction guide.\nclass alignas(IdentifierInfoAlignment) CXXDeductionGuideNameExtra\n    : public detail::DeclarationNameExtra,\n      public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The template named by the deduction guide.\n  TemplateDecl *Template;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXDeductionGuideNameExtra(TemplateDecl *TD)\n      : DeclarationNameExtra(CXXDeductionGuideName), Template(TD),\n        FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) { ID.AddPointer(Template); }\n};\n\n/// Contains extra information for the name of an overloaded operator\n/// in C++, such as \"operator+. This do not includes literal or conversion\n/// operators. For literal operators see CXXLiteralOperatorIdName and for\n/// conversion operators see CXXSpecialNameExtra.\nclass alignas(IdentifierInfoAlignment) CXXOperatorIdName {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The kind of this operator.\n  OverloadedOperatorKind Kind = OO_None;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo = nullptr;\n};\n\n/// Contains the actual identifier that makes up the\n/// name of a C++ literal operator.\nclass alignas(IdentifierInfoAlignment) CXXLiteralOperatorIdName\n    : public detail::DeclarationNameExtra,\n      public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  IdentifierInfo *ID;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXLiteralOperatorIdName(IdentifierInfo *II)\n      : DeclarationNameExtra(CXXLiteralOperatorName), ID(II),\n        FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &FSID) { FSID.AddPointer(ID); }\n};\n\n} // namespace detail\n\n/// The name of a declaration. In the common case, this just stores\n/// an IdentifierInfo pointer to a normal name. However, it also provides\n/// encodings for Objective-C selectors (optimizing zero- and one-argument\n/// selectors, which make up 78% percent of all selectors in Cocoa.h),\n/// special C++ names for constructors, destructors, and conversion functions,\n/// and C++ overloaded operators.\nclass DeclarationName {\n  friend class DeclarationNameTable;\n  friend class NamedDecl;\n\n  /// StoredNameKind represent the kind of name that is actually stored in the\n  /// upper bits of the Ptr field. This is only used internally.\n  ///\n  /// NameKind, StoredNameKind, and DeclarationNameExtra::ExtraKind\n  /// must satisfy the following properties. These properties enable\n  /// efficient conversion between the various kinds.\n  ///\n  /// * The first seven enumerators of StoredNameKind must have the same\n  ///   numerical value as the first seven enumerators of NameKind.\n  ///   This enable efficient conversion between the two enumerations\n  ///   in the usual case.\n  ///\n  /// * The enumerations values of DeclarationNameExtra::ExtraKind must start\n  ///   at zero, and correspond to the numerical value of the first non-inline\n  ///   enumeration values of NameKind minus an offset. This makes conversion\n  ///   between DeclarationNameExtra::ExtraKind and NameKind possible with\n  ///   a single addition/substraction.\n  ///\n  /// * The enumeration values of Selector::IdentifierInfoFlag must correspond\n  ///   to the relevant enumeration values of StoredNameKind.\n  ///   More specifically:\n  ///    * ZeroArg == StoredObjCZeroArgSelector,\n  ///    * OneArg == StoredObjCOneArgSelector,\n  ///    * MultiArg == StoredDeclarationNameExtra\n  ///\n  /// * PtrMask must mask the low 3 bits of Ptr.\n  enum StoredNameKind {\n    StoredIdentifier = 0,\n    StoredObjCZeroArgSelector = Selector::ZeroArg,\n    StoredObjCOneArgSelector = Selector::OneArg,\n    StoredCXXConstructorName = 3,\n    StoredCXXDestructorName = 4,\n    StoredCXXConversionFunctionName = 5,\n    StoredCXXOperatorName = 6,\n    StoredDeclarationNameExtra = Selector::MultiArg,\n    PtrMask = 7,\n    UncommonNameKindOffset = 8\n  };\n\n  static_assert(alignof(IdentifierInfo) >= 8 &&\n                    alignof(detail::DeclarationNameExtra) >= 8 &&\n                    alignof(detail::CXXSpecialNameExtra) >= 8 &&\n                    alignof(detail::CXXOperatorIdName) >= 8 &&\n                    alignof(detail::CXXDeductionGuideNameExtra) >= 8 &&\n                    alignof(detail::CXXLiteralOperatorIdName) >= 8,\n                \"The various classes that DeclarationName::Ptr can point to\"\n                \" must be at least aligned to 8 bytes!\");\n\npublic:\n  /// The kind of the name stored in this DeclarationName.\n  /// The first 7 enumeration values are stored inline and correspond\n  /// to frequently used kinds. The rest is stored in DeclarationNameExtra\n  /// and correspond to infrequently used kinds.\n  enum NameKind {\n    Identifier = StoredIdentifier,\n    ObjCZeroArgSelector = StoredObjCZeroArgSelector,\n    ObjCOneArgSelector = StoredObjCOneArgSelector,\n    CXXConstructorName = StoredCXXConstructorName,\n    CXXDestructorName = StoredCXXDestructorName,\n    CXXConversionFunctionName = StoredCXXConversionFunctionName,\n    CXXOperatorName = StoredCXXOperatorName,\n    CXXDeductionGuideName = UncommonNameKindOffset +\n                            detail::DeclarationNameExtra::CXXDeductionGuideName,\n    CXXLiteralOperatorName =\n        UncommonNameKindOffset +\n        detail::DeclarationNameExtra::CXXLiteralOperatorName,\n    CXXUsingDirective = UncommonNameKindOffset +\n                        detail::DeclarationNameExtra::CXXUsingDirective,\n    ObjCMultiArgSelector = UncommonNameKindOffset +\n                           detail::DeclarationNameExtra::ObjCMultiArgSelector\n  };\n\nprivate:\n  /// The lowest three bits of Ptr are used to express what kind of name\n  /// we're actually storing, using the values of StoredNameKind. Depending\n  /// on the kind of name this is, the upper bits of Ptr may have one\n  /// of several different meanings:\n  ///\n  ///   StoredIdentifier - The name is a normal identifier, and Ptr is\n  ///   a normal IdentifierInfo pointer.\n  ///\n  ///   StoredObjCZeroArgSelector - The name is an Objective-C\n  ///   selector with zero arguments, and Ptr is an IdentifierInfo\n  ///   pointer pointing to the selector name.\n  ///\n  ///   StoredObjCOneArgSelector - The name is an Objective-C selector\n  ///   with one argument, and Ptr is an IdentifierInfo pointer\n  ///   pointing to the selector name.\n  ///\n  ///   StoredCXXConstructorName - The name of a C++ constructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXDestructorName - The name of a C++ destructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXConversionFunctionName - The name of a C++ conversion function,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXOperatorName - The name of an overloaded C++ operator,\n  ///   Ptr points to a CXXOperatorIdName.\n  ///\n  ///   StoredDeclarationNameExtra - Ptr is actually a pointer to a\n  ///   DeclarationNameExtra structure, whose first value will tell us\n  ///   whether this is an Objective-C selector, C++ deduction guide,\n  ///   C++ literal operator, or C++ using directive.\n  uintptr_t Ptr = 0;\n\n  StoredNameKind getStoredNameKind() const {\n    return static_cast<StoredNameKind>(Ptr & PtrMask);\n  }\n\n  void *getPtr() const { return reinterpret_cast<void *>(Ptr & ~PtrMask); }\n\n  void setPtrAndKind(const void *P, StoredNameKind Kind) {\n    uintptr_t PAsInteger = reinterpret_cast<uintptr_t>(P);\n    assert((Kind & ~PtrMask) == 0 &&\n           \"Invalid StoredNameKind in setPtrAndKind!\");\n    assert((PAsInteger & PtrMask) == 0 &&\n           \"Improperly aligned pointer in setPtrAndKind!\");\n    Ptr = PAsInteger | Kind;\n  }\n\n  /// Construct a declaration name from a DeclarationNameExtra.\n  DeclarationName(detail::DeclarationNameExtra *Name) {\n    setPtrAndKind(Name, StoredDeclarationNameExtra);\n  }\n\n  /// Construct a declaration name from a CXXSpecialNameExtra.\n  DeclarationName(detail::CXXSpecialNameExtra *Name,\n                  StoredNameKind StoredKind) {\n    assert((StoredKind == StoredCXXConstructorName ||\n           StoredKind == StoredCXXDestructorName ||\n           StoredKind == StoredCXXConversionFunctionName) &&\n               \"Invalid StoredNameKind when constructing a DeclarationName\"\n               \" from a CXXSpecialNameExtra!\");\n    setPtrAndKind(Name, StoredKind);\n  }\n\n  /// Construct a DeclarationName from a CXXOperatorIdName.\n  DeclarationName(detail::CXXOperatorIdName *Name) {\n    setPtrAndKind(Name, StoredCXXOperatorName);\n  }\n\n  /// Assert that the stored pointer points to an IdentifierInfo and return it.\n  IdentifierInfo *castAsIdentifierInfo() const {\n    assert((getStoredNameKind() == StoredIdentifier) &&\n           \"DeclarationName does not store an IdentifierInfo!\");\n    return static_cast<IdentifierInfo *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a DeclarationNameExtra\n  /// and return it.\n  detail::DeclarationNameExtra *castAsExtra() const {\n    assert((getStoredNameKind() == StoredDeclarationNameExtra) &&\n           \"DeclarationName does not store an Extra structure!\");\n    return static_cast<detail::DeclarationNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXSpecialNameExtra\n  /// and return it.\n  detail::CXXSpecialNameExtra *castAsCXXSpecialNameExtra() const {\n    assert((getStoredNameKind() == StoredCXXConstructorName ||\n           getStoredNameKind() == StoredCXXDestructorName ||\n           getStoredNameKind() == StoredCXXConversionFunctionName) &&\n               \"DeclarationName does not store a CXXSpecialNameExtra!\");\n    return static_cast<detail::CXXSpecialNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXOperatorIdName\n  /// and return it.\n  detail::CXXOperatorIdName *castAsCXXOperatorIdName() const {\n    assert((getStoredNameKind() == StoredCXXOperatorName) &&\n           \"DeclarationName does not store a CXXOperatorIdName!\");\n    return static_cast<detail::CXXOperatorIdName *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXDeductionGuideNameExtra\n  /// and return it.\n  detail::CXXDeductionGuideNameExtra *castAsCXXDeductionGuideNameExtra() const {\n    assert(getNameKind() == CXXDeductionGuideName &&\n           \"DeclarationName does not store a CXXDeductionGuideNameExtra!\");\n    return static_cast<detail::CXXDeductionGuideNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXLiteralOperatorIdName\n  /// and return it.\n  detail::CXXLiteralOperatorIdName *castAsCXXLiteralOperatorIdName() const {\n    assert(getNameKind() == CXXLiteralOperatorName &&\n           \"DeclarationName does not store a CXXLiteralOperatorIdName!\");\n    return static_cast<detail::CXXLiteralOperatorIdName *>(getPtr());\n  }\n\n  /// Get and set the FETokenInfo in the less common cases where the\n  /// declaration name do not point to an identifier.\n  void *getFETokenInfoSlow() const;\n  void setFETokenInfoSlow(void *T);\n\npublic:\n  /// Construct an empty declaration name.\n  DeclarationName() { setPtrAndKind(nullptr, StoredIdentifier); }\n\n  /// Construct a declaration name from an IdentifierInfo *.\n  DeclarationName(const IdentifierInfo *II) {\n    setPtrAndKind(II, StoredIdentifier);\n  }\n\n  /// Construct a declaration name from an Objective-C selector.\n  DeclarationName(Selector Sel) : Ptr(Sel.InfoPtr) {}\n\n  /// Returns the name for all C++ using-directives.\n  static DeclarationName getUsingDirectiveName() {\n    // Single instance of DeclarationNameExtra for using-directive\n    static detail::DeclarationNameExtra UDirExtra(\n        detail::DeclarationNameExtra::CXXUsingDirective);\n    return DeclarationName(&UDirExtra);\n  }\n\n  /// Evaluates true when this declaration name is non-empty.\n  explicit operator bool() const {\n    return getPtr() || (getStoredNameKind() != StoredIdentifier);\n  }\n\n  /// Evaluates true when this declaration name is empty.\n  bool isEmpty() const { return !*this; }\n\n  /// Predicate functions for querying what type of name this is.\n  bool isIdentifier() const { return getStoredNameKind() == StoredIdentifier; }\n  bool isObjCZeroArgSelector() const {\n    return getStoredNameKind() == StoredObjCZeroArgSelector;\n  }\n  bool isObjCOneArgSelector() const {\n    return getStoredNameKind() == StoredObjCOneArgSelector;\n  }\n\n  /// Determine what kind of name this is.\n  NameKind getNameKind() const {\n    // We rely on the fact that the first 7 NameKind and StoredNameKind\n    // have the same numerical value. This makes the usual case efficient.\n    StoredNameKind StoredKind = getStoredNameKind();\n    if (StoredKind != StoredDeclarationNameExtra)\n      return static_cast<NameKind>(StoredKind);\n    // We have to consult DeclarationNameExtra. We rely on the fact that the\n    // enumeration values of ExtraKind correspond to the enumeration values of\n    // NameKind minus an offset of UncommonNameKindOffset.\n    unsigned ExtraKind = castAsExtra()->getKind();\n    return static_cast<NameKind>(UncommonNameKindOffset + ExtraKind);\n  }\n\n  /// Determines whether the name itself is dependent, e.g., because it\n  /// involves a C++ type that is itself dependent.\n  ///\n  /// Note that this does not capture all of the notions of \"dependent name\",\n  /// because an identifier can be a dependent name if it is used as the\n  /// callee in a call expression with dependent arguments.\n  bool isDependentName() const;\n\n  /// Retrieve the human-readable string for this name.\n  std::string getAsString() const;\n\n  /// Retrieve the IdentifierInfo * stored in this declaration name,\n  /// or null if this declaration name isn't a simple identifier.\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (isIdentifier())\n      return castAsIdentifierInfo();\n    return nullptr;\n  }\n\n  /// Get the representation of this declaration name as an opaque integer.\n  uintptr_t getAsOpaqueInteger() const { return Ptr; }\n\n  /// Get the representation of this declaration name as an opaque pointer.\n  void *getAsOpaquePtr() const { return reinterpret_cast<void *>(Ptr); }\n\n  /// Get a declaration name from an opaque pointer returned by getAsOpaquePtr.\n  static DeclarationName getFromOpaquePtr(void *P) {\n    DeclarationName N;\n    N.Ptr = reinterpret_cast<uintptr_t>(P);\n    return N;\n  }\n\n  /// Get a declaration name from an opaque integer\n  /// returned by getAsOpaqueInteger.\n  static DeclarationName getFromOpaqueInteger(uintptr_t P) {\n    DeclarationName N;\n    N.Ptr = P;\n    return N;\n  }\n\n  /// If this name is one of the C++ names (of a constructor, destructor,\n  /// or conversion function), return the type associated with that name.\n  QualType getCXXNameType() const {\n    if (getStoredNameKind() == StoredCXXConstructorName ||\n        getStoredNameKind() == StoredCXXDestructorName ||\n        getStoredNameKind() == StoredCXXConversionFunctionName) {\n      assert(getPtr() && \"getCXXNameType on a null DeclarationName!\");\n      return castAsCXXSpecialNameExtra()->Type;\n    }\n    return QualType();\n  }\n\n  /// If this name is the name of a C++ deduction guide, return the\n  /// template associated with that name.\n  TemplateDecl *getCXXDeductionGuideTemplate() const {\n    if (getNameKind() == CXXDeductionGuideName) {\n      assert(getPtr() &&\n             \"getCXXDeductionGuideTemplate on a null DeclarationName!\");\n      return castAsCXXDeductionGuideNameExtra()->Template;\n    }\n    return nullptr;\n  }\n\n  /// If this name is the name of an overloadable operator in C++\n  /// (e.g., @c operator+), retrieve the kind of overloaded operator.\n  OverloadedOperatorKind getCXXOverloadedOperator() const {\n    if (getStoredNameKind() == StoredCXXOperatorName) {\n      assert(getPtr() && \"getCXXOverloadedOperator on a null DeclarationName!\");\n      return castAsCXXOperatorIdName()->Kind;\n    }\n    return OO_None;\n  }\n\n  /// If this name is the name of a literal operator,\n  /// retrieve the identifier associated with it.\n  IdentifierInfo *getCXXLiteralIdentifier() const {\n    if (getNameKind() == CXXLiteralOperatorName) {\n      assert(getPtr() && \"getCXXLiteralIdentifier on a null DeclarationName!\");\n      return castAsCXXLiteralOperatorIdName()->ID;\n    }\n    return nullptr;\n  }\n\n  /// Get the Objective-C selector stored in this declaration name.\n  Selector getObjCSelector() const {\n    assert((getNameKind() == ObjCZeroArgSelector ||\n            getNameKind() == ObjCOneArgSelector ||\n            getNameKind() == ObjCMultiArgSelector || !getPtr()) &&\n           \"Not a selector!\");\n    return Selector(Ptr);\n  }\n\n  /// Get and set FETokenInfo. The language front-end is allowed to associate\n  /// arbitrary metadata with some kinds of declaration names, including normal\n  /// identifiers and C++ constructors, destructors, and conversion functions.\n  void *getFETokenInfo() const {\n    assert(getPtr() && \"getFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      return castAsIdentifierInfo()->getFETokenInfo();\n    return getFETokenInfoSlow();\n  }\n\n  void setFETokenInfo(void *T) {\n    assert(getPtr() && \"setFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      castAsIdentifierInfo()->setFETokenInfo(T);\n    else\n      setFETokenInfoSlow(T);\n  }\n\n  /// Determine whether the specified names are identical.\n  friend bool operator==(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  /// Determine whether the specified names are different.\n  friend bool operator!=(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr != RHS.Ptr;\n  }\n\n  static DeclarationName getEmptyMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-1);\n    return Name;\n  }\n\n  static DeclarationName getTombstoneMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-2);\n    return Name;\n  }\n\n  static int compare(DeclarationName LHS, DeclarationName RHS);\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  void dump() const;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, DeclarationName N);\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator<(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) < 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator>(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) > 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator<=(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) <= 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator>=(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) >= 0;\n}\n\n/// DeclarationNameTable is used to store and retrieve DeclarationName\n/// instances for the various kinds of declaration names, e.g., normal\n/// identifiers, C++ constructor names, etc. This class contains\n/// uniqued versions of each of the C++ special names, which can be\n/// retrieved using its member functions (e.g., getCXXConstructorName).\nclass DeclarationNameTable {\n  /// Used to allocate elements in the FoldingSets below.\n  const ASTContext &Ctx;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ constructors.\n  /// getCXXConstructorName and getCXXSpecialName can be used to obtain\n  /// a DeclarationName from the corresponding type of the constructor.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXConstructorNames;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ destructors.\n  /// getCXXDestructorName and getCXXSpecialName can be used to obtain\n  /// a DeclarationName from the corresponding type of the destructor.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXDestructorNames;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ conversion\n  /// functions. getCXXConversionFunctionName and getCXXSpecialName can be\n  /// used to obtain a DeclarationName from the corresponding type of the\n  /// conversion function.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXConversionFunctionNames;\n\n  /// Manage the uniqued CXXOperatorIdName, which contain extra information\n  /// for the name of overloaded C++ operators. getCXXOperatorName\n  /// can be used to obtain a DeclarationName from the operator kind.\n  detail::CXXOperatorIdName CXXOperatorNames[NUM_OVERLOADED_OPERATORS];\n\n  /// Manage the uniqued CXXLiteralOperatorIdName, which contain extra\n  /// information for the name of C++ literal operators.\n  /// getCXXLiteralOperatorName can be used to obtain a DeclarationName\n  /// from the corresponding IdentifierInfo.\n  llvm::FoldingSet<detail::CXXLiteralOperatorIdName> CXXLiteralOperatorNames;\n\n  /// Manage the uniqued CXXDeductionGuideNameExtra, which contain\n  /// extra information for the name of a C++ deduction guide.\n  /// getCXXDeductionGuideName can be used to obtain a DeclarationName\n  /// from the corresponding template declaration.\n  llvm::FoldingSet<detail::CXXDeductionGuideNameExtra> CXXDeductionGuideNames;\n\npublic:\n  DeclarationNameTable(const ASTContext &C);\n  DeclarationNameTable(const DeclarationNameTable &) = delete;\n  DeclarationNameTable &operator=(const DeclarationNameTable &) = delete;\n  DeclarationNameTable(DeclarationNameTable &&) = delete;\n  DeclarationNameTable &operator=(DeclarationNameTable &&) = delete;\n  ~DeclarationNameTable() = default;\n\n  /// Create a declaration name that is a simple identifier.\n  DeclarationName getIdentifier(const IdentifierInfo *ID) {\n    return DeclarationName(ID);\n  }\n\n  /// Returns the name of a C++ constructor for the given Type.\n  DeclarationName getCXXConstructorName(CanQualType Ty);\n\n  /// Returns the name of a C++ destructor for the given Type.\n  DeclarationName getCXXDestructorName(CanQualType Ty);\n\n  /// Returns the name of a C++ deduction guide for the given template.\n  DeclarationName getCXXDeductionGuideName(TemplateDecl *TD);\n\n  /// Returns the name of a C++ conversion function for the given Type.\n  DeclarationName getCXXConversionFunctionName(CanQualType Ty);\n\n  /// Returns a declaration name for special kind of C++ name,\n  /// e.g., for a constructor, destructor, or conversion function.\n  /// Kind must be one of:\n  ///   * DeclarationName::CXXConstructorName,\n  ///   * DeclarationName::CXXDestructorName or\n  ///   * DeclarationName::CXXConversionFunctionName\n  DeclarationName getCXXSpecialName(DeclarationName::NameKind Kind,\n                                    CanQualType Ty);\n\n  /// Get the name of the overloadable C++ operator corresponding to Op.\n  DeclarationName getCXXOperatorName(OverloadedOperatorKind Op) {\n    return DeclarationName(&CXXOperatorNames[Op]);\n  }\n\n  /// Get the name of the literal operator function with II as the identifier.\n  DeclarationName getCXXLiteralOperatorName(IdentifierInfo *II);\n};\n\n/// DeclarationNameLoc - Additional source/type location info\n/// for a declaration name. Needs a DeclarationName in order\n/// to be interpreted correctly.\nclass DeclarationNameLoc {\n  // The source location for identifier stored elsewhere.\n  // struct {} Identifier;\n\n  // Type info for constructors, destructors and conversion functions.\n  // Locations (if any) for the tilde (destructor) or operator keyword\n  // (conversion) are stored elsewhere.\n  struct NT {\n    TypeSourceInfo *TInfo;\n  };\n\n  // The location (if any) of the operator keyword is stored elsewhere.\n  struct CXXOpName {\n    unsigned BeginOpNameLoc;\n    unsigned EndOpNameLoc;\n  };\n\n  // The location (if any) of the operator keyword is stored elsewhere.\n  struct CXXLitOpName {\n    unsigned OpNameLoc;\n  };\n\n  // struct {} CXXUsingDirective;\n  // struct {} ObjCZeroArgSelector;\n  // struct {} ObjCOneArgSelector;\n  // struct {} ObjCMultiArgSelector;\n  union {\n    struct NT NamedType;\n    struct CXXOpName CXXOperatorName;\n    struct CXXLitOpName CXXLiteralOperatorName;\n  };\n\n  void setNamedTypeLoc(TypeSourceInfo *TInfo) { NamedType.TInfo = TInfo; }\n\n  void setCXXOperatorNameRange(SourceRange Range) {\n    CXXOperatorName.BeginOpNameLoc = Range.getBegin().getRawEncoding();\n    CXXOperatorName.EndOpNameLoc = Range.getEnd().getRawEncoding();\n  }\n\n  void setCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    CXXLiteralOperatorName.OpNameLoc = Loc.getRawEncoding();\n  }\n\npublic:\n  DeclarationNameLoc(DeclarationName Name);\n  // FIXME: this should go away once all DNLocs are properly initialized.\n  DeclarationNameLoc() { memset((void*) this, 0, sizeof(*this)); }\n\n  /// Returns the source type info. Assumes that the object stores location\n  /// information of a constructor, destructor or conversion operator.\n  TypeSourceInfo *getNamedTypeInfo() const { return NamedType.TInfo; }\n\n  /// Return the beginning location of the getCXXOperatorNameRange() range.\n  SourceLocation getCXXOperatorNameBeginLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXOperatorName.BeginOpNameLoc);\n  }\n\n  /// Return the end location of the getCXXOperatorNameRange() range.\n  SourceLocation getCXXOperatorNameEndLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXOperatorName.EndOpNameLoc);\n  }\n\n  /// Return the range of the operator name (without the operator keyword).\n  /// Assumes that the object stores location information of a (non-literal)\n  /// operator.\n  SourceRange getCXXOperatorNameRange() const {\n    return SourceRange(getCXXOperatorNameBeginLoc(),\n                       getCXXOperatorNameEndLoc());\n  }\n\n  /// Return the location of the literal operator name (without the operator\n  /// keyword). Assumes that the object stores location information of a literal\n  /// operator.\n  SourceLocation getCXXLiteralOperatorNameLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXLiteralOperatorName.OpNameLoc);\n  }\n\n  /// Construct location information for a constructor, destructor or conversion\n  /// operator.\n  static DeclarationNameLoc makeNamedTypeLoc(TypeSourceInfo *TInfo) {\n    DeclarationNameLoc DNL;\n    DNL.setNamedTypeLoc(TInfo);\n    return DNL;\n  }\n\n  /// Construct location information for a non-literal C++ operator.\n  static DeclarationNameLoc makeCXXOperatorNameLoc(SourceLocation BeginLoc,\n                                                   SourceLocation EndLoc) {\n    return makeCXXOperatorNameLoc(SourceRange(BeginLoc, EndLoc));\n  }\n\n  /// Construct location information for a non-literal C++ operator.\n  static DeclarationNameLoc makeCXXOperatorNameLoc(SourceRange Range) {\n    DeclarationNameLoc DNL;\n    DNL.setCXXOperatorNameRange(Range);\n    return DNL;\n  }\n\n  /// Construct location information for a literal C++ operator.\n  static DeclarationNameLoc makeCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    DeclarationNameLoc DNL;\n    DNL.setCXXLiteralOperatorNameLoc(Loc);\n    return DNL;\n  }\n};\n\n/// DeclarationNameInfo - A collector data type for bundling together\n/// a DeclarationName and the correspnding source/type location info.\nstruct DeclarationNameInfo {\nprivate:\n  /// Name - The declaration name, also encoding name kind.\n  DeclarationName Name;\n\n  /// Loc - The main source location for the declaration name.\n  SourceLocation NameLoc;\n\n  /// Info - Further source/type location info for special kinds of names.\n  DeclarationNameLoc LocInfo;\n\npublic:\n  // FIXME: remove it.\n  DeclarationNameInfo() = default;\n\n  DeclarationNameInfo(DeclarationName Name, SourceLocation NameLoc)\n      : Name(Name), NameLoc(NameLoc), LocInfo(Name) {}\n\n  DeclarationNameInfo(DeclarationName Name, SourceLocation NameLoc,\n                      DeclarationNameLoc LocInfo)\n      : Name(Name), NameLoc(NameLoc), LocInfo(LocInfo) {}\n\n  /// getName - Returns the embedded declaration name.\n  DeclarationName getName() const { return Name; }\n\n  /// setName - Sets the embedded declaration name.\n  void setName(DeclarationName N) { Name = N; }\n\n  /// getLoc - Returns the main location of the declaration name.\n  SourceLocation getLoc() const { return NameLoc; }\n\n  /// setLoc - Sets the main location of the declaration name.\n  void setLoc(SourceLocation L) { NameLoc = L; }\n\n  const DeclarationNameLoc &getInfo() const { return LocInfo; }\n  void setInfo(const DeclarationNameLoc &Info) { LocInfo = Info; }\n\n  /// getNamedTypeInfo - Returns the source type info associated to\n  /// the name. Assumes it is a constructor, destructor or conversion.\n  TypeSourceInfo *getNamedTypeInfo() const {\n    if (Name.getNameKind() != DeclarationName::CXXConstructorName &&\n        Name.getNameKind() != DeclarationName::CXXDestructorName &&\n        Name.getNameKind() != DeclarationName::CXXConversionFunctionName)\n      return nullptr;\n    return LocInfo.getNamedTypeInfo();\n  }\n\n  /// setNamedTypeInfo - Sets the source type info associated to\n  /// the name. Assumes it is a constructor, destructor or conversion.\n  void setNamedTypeInfo(TypeSourceInfo *TInfo) {\n    assert(Name.getNameKind() == DeclarationName::CXXConstructorName ||\n           Name.getNameKind() == DeclarationName::CXXDestructorName ||\n           Name.getNameKind() == DeclarationName::CXXConversionFunctionName);\n    LocInfo = DeclarationNameLoc::makeNamedTypeLoc(TInfo);\n  }\n\n  /// getCXXOperatorNameRange - Gets the range of the operator name\n  /// (without the operator keyword). Assumes it is a (non-literal) operator.\n  SourceRange getCXXOperatorNameRange() const {\n    if (Name.getNameKind() != DeclarationName::CXXOperatorName)\n      return SourceRange();\n    return LocInfo.getCXXOperatorNameRange();\n  }\n\n  /// setCXXOperatorNameRange - Sets the range of the operator name\n  /// (without the operator keyword). Assumes it is a C++ operator.\n  void setCXXOperatorNameRange(SourceRange R) {\n    assert(Name.getNameKind() == DeclarationName::CXXOperatorName);\n    LocInfo = DeclarationNameLoc::makeCXXOperatorNameLoc(R);\n  }\n\n  /// getCXXLiteralOperatorNameLoc - Returns the location of the literal\n  /// operator name (not the operator keyword).\n  /// Assumes it is a literal operator.\n  SourceLocation getCXXLiteralOperatorNameLoc() const {\n    if (Name.getNameKind() != DeclarationName::CXXLiteralOperatorName)\n      return SourceLocation();\n    return LocInfo.getCXXLiteralOperatorNameLoc();\n  }\n\n  /// setCXXLiteralOperatorNameLoc - Sets the location of the literal\n  /// operator name (not the operator keyword).\n  /// Assumes it is a literal operator.\n  void setCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    assert(Name.getNameKind() == DeclarationName::CXXLiteralOperatorName);\n    LocInfo = DeclarationNameLoc::makeCXXLiteralOperatorNameLoc(Loc);\n  }\n\n  /// Determine whether this name involves a template parameter.\n  bool isInstantiationDependent() const;\n\n  /// Determine whether this name contains an unexpanded\n  /// parameter pack.\n  bool containsUnexpandedParameterPack() const;\n\n  /// getAsString - Retrieve the human-readable string for this name.\n  std::string getAsString() const;\n\n  /// printName - Print the human-readable name to a stream.\n  void printName(raw_ostream &OS, PrintingPolicy Policy) const;\n\n  /// getBeginLoc - Retrieve the location of the first token.\n  SourceLocation getBeginLoc() const { return NameLoc; }\n\n  /// getSourceRange - The range of the declaration name.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    SourceLocation EndLoc = getEndLocPrivate();\n    return EndLoc.isValid() ? EndLoc : getBeginLoc();\n  }\n\nprivate:\n  SourceLocation getEndLocPrivate() const;\n};\n\n/// Insertion operator for partial diagnostics.  This allows binding\n/// DeclarationName's into a partial diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             DeclarationName N) {\n  PD.AddTaggedVal(N.getAsOpaqueInteger(),\n                  DiagnosticsEngine::ak_declarationname);\n  return PD;\n}\n\nraw_ostream &operator<<(raw_ostream &OS, DeclarationNameInfo DNInfo);\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Define DenseMapInfo so that DeclarationNames can be used as keys\n/// in DenseMap and DenseSets.\ntemplate<>\nstruct DenseMapInfo<clang::DeclarationName> {\n  static inline clang::DeclarationName getEmptyKey() {\n    return clang::DeclarationName::getEmptyMarker();\n  }\n\n  static inline clang::DeclarationName getTombstoneKey() {\n    return clang::DeclarationName::getTombstoneMarker();\n  }\n\n  static unsigned getHashValue(clang::DeclarationName Name) {\n    return DenseMapInfo<void*>::getHashValue(Name.getAsOpaquePtr());\n  }\n\n  static inline bool\n  isEqual(clang::DeclarationName LHS, clang::DeclarationName RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate <> struct PointerLikeTypeTraits<clang::DeclarationName> {\n  static inline void *getAsVoidPointer(clang::DeclarationName P) {\n    return P.getAsOpaquePtr();\n  }\n  static inline clang::DeclarationName getFromVoidPointer(void *P) {\n    return clang::DeclarationName::getFromOpaquePtr(P);\n  }\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\n// The definition of AssumedTemplateStorage is factored out of TemplateName to\n// resolve a cyclic dependency between it and DeclarationName (via Type).\nnamespace clang {\n\n/// A structure for storing the information associated with a name that has\n/// been assumed to be a template name (despite finding no TemplateDecls).\nclass AssumedTemplateStorage : public UncommonTemplateNameStorage {\n  friend class ASTContext;\n\n  AssumedTemplateStorage(DeclarationName Name)\n      : UncommonTemplateNameStorage(Assumed, 0), Name(Name) {}\n  DeclarationName Name;\n\npublic:\n  /// Get the name of the template.\n  DeclarationName getDeclName() const { return Name; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLARATIONNAME_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DependenceFlags.h", "content": "//===--- DependenceFlags.h ------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_AST_DEPENDENCEFLAGS_H\n#define LLVM_CLANG_AST_DEPENDENCEFLAGS_H\n\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include <cstdint>\n\nnamespace clang {\nstruct ExprDependenceScope {\n  enum ExprDependence : uint8_t {\n    UnexpandedPack = 1,\n    // This expr depends in any way on\n    //   - a template parameter, it implies that the resolution of this expr may\n    //     cause instantiation to fail\n    //   - or an error (often in a non-template context)\n    //\n    // Note that C++ standard doesn't define the instantiation-dependent term,\n    // we follow the formal definition coming from the Itanium C++ ABI, and\n    // extend it to errors.\n    Instantiation = 2,\n    // The type of this expr depends on a template parameter, or an error.\n    Type = 4,\n    // The value of this expr depends on a template parameter, or an error.\n    Value = 8,\n\n    // clang extension: this expr contains or references an error, and is\n    // considered dependent on how that error is resolved.\n    Error = 16,\n\n    None = 0,\n    All = 31,\n\n    TypeValue = Type | Value,\n    TypeInstantiation = Type | Instantiation,\n    ValueInstantiation = Value | Instantiation,\n    TypeValueInstantiation = Type | Value | Instantiation,\n    ErrorDependent = Error | ValueInstantiation,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/Error)\n  };\n};\nusing ExprDependence = ExprDependenceScope::ExprDependence;\n\nstruct TypeDependenceScope {\n  enum TypeDependence : uint8_t {\n    /// Whether this type contains an unexpanded parameter pack\n    /// (for C++11 variadic templates)\n    UnexpandedPack = 1,\n    /// Whether this type somehow involves\n    ///   - a template parameter, even if the resolution of the type does not\n    ///     depend on a template parameter.\n    ///   - or an error.\n    Instantiation = 2,\n    /// Whether this type\n    ///   - is a dependent type (C++ [temp.dep.type])\n    ///   - or it somehow involves an error, e.g. decltype(recovery-expr)\n    Dependent = 4,\n    /// Whether this type is a variably-modified type (C99 6.7.5).\n    VariablyModified = 8,\n\n    /// Whether this type references an error, e.g. decltype(err-expression)\n    /// yields an error type.\n    Error = 16,\n\n    None = 0,\n    All = 31,\n\n    DependentInstantiation = Dependent | Instantiation,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/Error)\n  };\n};\nusing TypeDependence = TypeDependenceScope::TypeDependence;\n\n#define LLVM_COMMON_DEPENDENCE(NAME)                                           \\\n  struct NAME##Scope {                                                         \\\n    enum NAME : uint8_t {                                                      \\\n      UnexpandedPack = 1,                                                      \\\n      Instantiation = 2,                                                       \\\n      Dependent = 4,                                                           \\\n      Error = 8,                                                               \\\n                                                                               \\\n      None = 0,                                                                \\\n      DependentInstantiation = Dependent | Instantiation,                      \\\n      All = 15,                                                                \\\n                                                                               \\\n      LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/Error)                        \\\n    };                                                                         \\\n  };                                                                           \\\n  using NAME = NAME##Scope::NAME;\n\nLLVM_COMMON_DEPENDENCE(NestedNameSpecifierDependence)\nLLVM_COMMON_DEPENDENCE(TemplateNameDependence)\nLLVM_COMMON_DEPENDENCE(TemplateArgumentDependence)\n#undef LLVM_COMMON_DEPENDENCE\n\n// A combined space of all dependence concepts for all node types.\n// Used when aggregating dependence of nodes of different types.\nclass Dependence {\npublic:\n  enum Bits : uint8_t {\n    None = 0,\n\n    // Contains a template parameter pack that wasn't expanded.\n    UnexpandedPack = 1,\n    // Depends on a template parameter or an error in some way.\n    // Validity depends on how the template is instantiated or the error is\n    // resolved.\n    Instantiation = 2,\n    // Expression type depends on template context, or an error.\n    // Value and Instantiation should also be set.\n    Type = 4,\n    // Expression value depends on template context, or an error.\n    // Instantiation should also be set.\n    Value = 8,\n    // Depends on template context, or an error.\n    // The type/value distinction is only meaningful for expressions.\n    Dependent = Type | Value,\n    // Includes an error, and depends on how it is resolved.\n    Error = 16,\n    // Type depends on a runtime value (variable-length array).\n    VariablyModified = 32,\n\n    // Dependence that is propagated syntactically, regardless of semantics.\n    Syntactic = UnexpandedPack | Instantiation | Error,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/VariablyModified)\n  };\n\n  Dependence() : V(None) {}\n\n  Dependence(TypeDependence D)\n      : V(translate(D, TypeDependence::UnexpandedPack, UnexpandedPack) |\n          translate(D, TypeDependence::Instantiation, Instantiation) |\n          translate(D, TypeDependence::Dependent, Dependent) |\n          translate(D, TypeDependence::Error, Error) |\n          translate(D, TypeDependence::VariablyModified, VariablyModified)) {}\n\n  Dependence(ExprDependence D)\n      : V(translate(D, ExprDependence::UnexpandedPack, UnexpandedPack) |\n             translate(D, ExprDependence::Instantiation, Instantiation) |\n             translate(D, ExprDependence::Type, Type) |\n             translate(D, ExprDependence::Value, Value) |\n             translate(D, ExprDependence::Error, Error)) {}\n\n  Dependence(NestedNameSpecifierDependence D) :\n    V ( translate(D, NNSDependence::UnexpandedPack, UnexpandedPack) |\n            translate(D, NNSDependence::Instantiation, Instantiation) |\n            translate(D, NNSDependence::Dependent, Dependent) |\n            translate(D, NNSDependence::Error, Error)) {}\n\n  Dependence(TemplateArgumentDependence D)\n      : V(translate(D, TADependence::UnexpandedPack, UnexpandedPack) |\n          translate(D, TADependence::Instantiation, Instantiation) |\n          translate(D, TADependence::Dependent, Dependent) |\n          translate(D, TADependence::Error, Error)) {}\n\n  Dependence(TemplateNameDependence D)\n      : V(translate(D, TNDependence::UnexpandedPack, UnexpandedPack) |\n             translate(D, TNDependence::Instantiation, Instantiation) |\n             translate(D, TNDependence::Dependent, Dependent) |\n             translate(D, TNDependence::Error, Error)) {}\n\n  /// Extract only the syntactic portions of this type's dependence.\n  Dependence syntactic() {\n    Dependence Result = *this;\n    Result.V &= Syntactic;\n    return Result;\n  }\n\n  TypeDependence type() const {\n    return translate(V, UnexpandedPack, TypeDependence::UnexpandedPack) |\n           translate(V, Instantiation, TypeDependence::Instantiation) |\n           translate(V, Dependent, TypeDependence::Dependent) |\n           translate(V, Error, TypeDependence::Error) |\n           translate(V, VariablyModified, TypeDependence::VariablyModified);\n  }\n\n  ExprDependence expr() const {\n    return translate(V, UnexpandedPack, ExprDependence::UnexpandedPack) |\n           translate(V, Instantiation, ExprDependence::Instantiation) |\n           translate(V, Type, ExprDependence::Type) |\n           translate(V, Value, ExprDependence::Value) |\n           translate(V, Error, ExprDependence::Error);\n  }\n\n  NestedNameSpecifierDependence nestedNameSpecifier() const {\n    return translate(V, UnexpandedPack, NNSDependence::UnexpandedPack) |\n           translate(V, Instantiation, NNSDependence::Instantiation) |\n           translate(V, Dependent, NNSDependence::Dependent) |\n           translate(V, Error, NNSDependence::Error);\n  }\n\n  TemplateArgumentDependence templateArgument() const {\n    return translate(V, UnexpandedPack, TADependence::UnexpandedPack) |\n           translate(V, Instantiation, TADependence::Instantiation) |\n           translate(V, Dependent, TADependence::Dependent) |\n           translate(V, Error, TADependence::Error);\n  }\n\n  TemplateNameDependence templateName() const {\n    return translate(V, UnexpandedPack, TNDependence::UnexpandedPack) |\n           translate(V, Instantiation, TNDependence::Instantiation) |\n           translate(V, Dependent, TNDependence::Dependent) |\n           translate(V, Error, TNDependence::Error);\n  }\n\nprivate:\n  Bits V;\n\n  template <typename T, typename U>\n  static U translate(T Bits, T FromBit, U ToBit) {\n    return (Bits & FromBit) ? ToBit : static_cast<U>(0);\n  }\n\n  // Abbreviations to make conversions more readable.\n  using NNSDependence = NestedNameSpecifierDependence;\n  using TADependence = TemplateArgumentDependence;\n  using TNDependence = TemplateNameDependence;\n};\n\n/// Computes dependencies of a reference with the name having template arguments\n/// with \\p TA dependencies.\ninline ExprDependence toExprDependence(TemplateArgumentDependence TA) {\n  return Dependence(TA).expr();\n}\ninline ExprDependence toExprDependence(TypeDependence D) {\n  return Dependence(D).expr();\n}\n// Note: it's often necessary to strip `Dependent` from qualifiers.\n// If V<T>:: refers to the current instantiation, NNS is considered dependent\n// but the containing V<T>::foo likely isn't.\ninline ExprDependence toExprDependence(NestedNameSpecifierDependence D) {\n  return Dependence(D).expr();\n}\ninline ExprDependence turnTypeToValueDependence(ExprDependence D) {\n  // Type-dependent expressions are always be value-dependent, so we simply drop\n  // type dependency.\n  return D & ~ExprDependence::Type;\n}\ninline ExprDependence turnValueToTypeDependence(ExprDependence D) {\n  // Type-dependent expressions are always be value-dependent.\n  if (D & ExprDependence::Value)\n    D |= ExprDependence::Type;\n  return D;\n}\n\n// Returned type-dependence will never have VariablyModified set.\ninline TypeDependence toTypeDependence(ExprDependence D) {\n  return Dependence(D).type();\n}\ninline TypeDependence toTypeDependence(NestedNameSpecifierDependence D) {\n  return Dependence(D).type();\n}\ninline TypeDependence toTypeDependence(TemplateNameDependence D) {\n  return Dependence(D).type();\n}\ninline TypeDependence toTypeDependence(TemplateArgumentDependence D) {\n  return Dependence(D).type();\n}\n\ninline TypeDependence toSyntacticDependence(TypeDependence D) {\n  return Dependence(D).syntactic().type();\n}\n\ninline NestedNameSpecifierDependence\ntoNestedNameSpecifierDependendence(TypeDependence D) {\n  return Dependence(D).nestedNameSpecifier();\n}\n\ninline TemplateArgumentDependence\ntoTemplateArgumentDependence(TypeDependence D) {\n  return Dependence(D).templateArgument();\n}\ninline TemplateArgumentDependence\ntoTemplateArgumentDependence(TemplateNameDependence D) {\n  return Dependence(D).templateArgument();\n}\ninline TemplateArgumentDependence\ntoTemplateArgumentDependence(ExprDependence D) {\n  return Dependence(D).templateArgument();\n}\n\ninline TemplateNameDependence\ntoTemplateNameDependence(NestedNameSpecifierDependence D) {\n  return Dependence(D).templateName();\n}\n\nLLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE();\n\n} // namespace clang\n#endif\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "content": "//===--- Expr.h - Classes for representing expressions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Expr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPR_H\n#define LLVM_CLANG_AST_EXPR_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTVector.h\"\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SyncScope.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n  class APValue;\n  class ASTContext;\n  class BlockDecl;\n  class CXXBaseSpecifier;\n  class CXXMemberCallExpr;\n  class CXXOperatorCallExpr;\n  class CastExpr;\n  class Decl;\n  class IdentifierInfo;\n  class MaterializeTemporaryExpr;\n  class NamedDecl;\n  class ObjCPropertyRefExpr;\n  class OpaqueValueExpr;\n  class ParmVarDecl;\n  class StringLiteral;\n  class TargetInfo;\n  class ValueDecl;\n\n/// A simple array of base specifiers.\ntypedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n\n/// An adjustment to be made to the temporary created when emitting a\n/// reference binding, which accesses a particular subobject of that temporary.\nstruct SubobjectAdjustment {\n  enum {\n    DerivedToBaseAdjustment,\n    FieldAdjustment,\n    MemberPointerAdjustment\n  } Kind;\n\n  struct DTB {\n    const CastExpr *BasePath;\n    const CXXRecordDecl *DerivedClass;\n  };\n\n  struct P {\n    const MemberPointerType *MPT;\n    Expr *RHS;\n  };\n\n  union {\n    struct DTB DerivedToBase;\n    FieldDecl *Field;\n    struct P Ptr;\n  };\n\n  SubobjectAdjustment(const CastExpr *BasePath,\n                      const CXXRecordDecl *DerivedClass)\n    : Kind(DerivedToBaseAdjustment) {\n    DerivedToBase.BasePath = BasePath;\n    DerivedToBase.DerivedClass = DerivedClass;\n  }\n\n  SubobjectAdjustment(FieldDecl *Field)\n    : Kind(FieldAdjustment) {\n    this->Field = Field;\n  }\n\n  SubobjectAdjustment(const MemberPointerType *MPT, Expr *RHS)\n    : Kind(MemberPointerAdjustment) {\n    this->Ptr.MPT = MPT;\n    this->Ptr.RHS = RHS;\n  }\n};\n\n/// This represents one expression.  Note that Expr's are subclasses of Stmt.\n/// This allows an expression to be transparently used any place a Stmt is\n/// required.\nclass Expr : public ValueStmt {\n  QualType TR;\n\npublic:\n  Expr() = delete;\n  Expr(const Expr&) = delete;\n  Expr(Expr &&) = delete;\n  Expr &operator=(const Expr&) = delete;\n  Expr &operator=(Expr&&) = delete;\n\nprotected:\n  Expr(StmtClass SC, QualType T, ExprValueKind VK, ExprObjectKind OK)\n      : ValueStmt(SC) {\n    ExprBits.Dependent = 0;\n    ExprBits.ValueKind = VK;\n    ExprBits.ObjectKind = OK;\n    assert(ExprBits.ObjectKind == OK && \"truncated kind\");\n    setType(T);\n  }\n\n  /// Construct an empty expression.\n  explicit Expr(StmtClass SC, EmptyShell) : ValueStmt(SC) { }\n\n  /// Each concrete expr subclass is expected to compute its dependence and call\n  /// this in the constructor.\n  void setDependence(ExprDependence Deps) {\n    ExprBits.Dependent = static_cast<unsigned>(Deps);\n  }\n  friend class ASTImporter; // Sets dependence dircetly.\n  friend class ASTStmtReader; // Sets dependence dircetly.\n\npublic:\n  QualType getType() const { return TR; }\n  void setType(QualType t) {\n    // In C++, the type of an expression is always adjusted so that it\n    // will not have reference type (C++ [expr]p6). Use\n    // QualType::getNonReferenceType() to retrieve the non-reference\n    // type. Additionally, inspect Expr::isLvalue to determine whether\n    // an expression that is adjusted in this manner should be\n    // considered an lvalue.\n    assert((t.isNull() || !t->isReferenceType()) &&\n           \"Expressions can't have reference type\");\n\n    TR = t;\n  }\n\n  ExprDependence getDependence() const {\n    return static_cast<ExprDependence>(ExprBits.Dependent);\n  }\n\n  /// Determines whether the value of this expression depends on\n  ///   - a template parameter (C++ [temp.dep.constexpr])\n  ///   - or an error, whose resolution is unknown\n  ///\n  /// For example, the array bound of \"Chars\" in the following example is\n  /// value-dependent.\n  /// @code\n  /// template<int Size, char (&Chars)[Size]> struct meta_string;\n  /// @endcode\n  bool isValueDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Value);\n  }\n\n  /// Determines whether the type of this expression depends on\n  ///   - a template paramter (C++ [temp.dep.expr], which means that its type\n  ///     could change from one template instantiation to the next)\n  ///   - or an error\n  ///\n  /// For example, the expressions \"x\" and \"x + y\" are type-dependent in\n  /// the following code, but \"y\" is not type-dependent:\n  /// @code\n  /// template<typename T>\n  /// void add(T x, int y) {\n  ///   x + y;\n  /// }\n  /// @endcode\n  bool isTypeDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Type);\n  }\n\n  /// Whether this expression is instantiation-dependent, meaning that\n  /// it depends in some way on\n  ///    - a template parameter (even if neither its type nor (constant) value\n  ///      can change due to the template instantiation)\n  ///    - or an error\n  ///\n  /// In the following example, the expression \\c sizeof(sizeof(T() + T())) is\n  /// instantiation-dependent (since it involves a template parameter \\c T), but\n  /// is neither type- nor value-dependent, since the type of the inner\n  /// \\c sizeof is known (\\c std::size_t) and therefore the size of the outer\n  /// \\c sizeof is known.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// void f(T x, T y) {\n  ///   sizeof(sizeof(T() + T());\n  /// }\n  /// \\endcode\n  ///\n  /// \\code\n  /// void func(int) {\n  ///   func(); // the expression is instantiation-dependent, because it depends\n  ///           // on an error.\n  /// }\n  /// \\endcode\n  bool isInstantiationDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Instantiation);\n  }\n\n  /// Whether this expression contains an unexpanded parameter\n  /// pack (for C++11 variadic templates).\n  ///\n  /// Given the following function template:\n  ///\n  /// \\code\n  /// template<typename F, typename ...Types>\n  /// void forward(const F &f, Types &&...args) {\n  ///   f(static_cast<Types&&>(args)...);\n  /// }\n  /// \\endcode\n  ///\n  /// The expressions \\c args and \\c static_cast<Types&&>(args) both\n  /// contain parameter packs.\n  bool containsUnexpandedParameterPack() const {\n    return static_cast<bool>(getDependence() & ExprDependence::UnexpandedPack);\n  }\n\n  /// Whether this expression contains subexpressions which had errors, e.g. a\n  /// TypoExpr.\n  bool containsErrors() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Error);\n  }\n\n  /// getExprLoc - Return the preferred location for the arrow when diagnosing\n  /// a problem with a generic expression.\n  SourceLocation getExprLoc() const LLVM_READONLY;\n\n  /// Determine whether an lvalue-to-rvalue conversion should implicitly be\n  /// applied to this expression if it appears as a discarded-value expression\n  /// in C++11 onwards. This applies to certain forms of volatile glvalues.\n  bool isReadIfDiscardedInCPlusPlus11() const;\n\n  /// isUnusedResultAWarning - Return true if this immediate expression should\n  /// be warned about if the result is unused.  If so, fill in expr, location,\n  /// and ranges with expr to warn on and source locations/ranges appropriate\n  /// for a warning.\n  bool isUnusedResultAWarning(const Expr *&WarnExpr, SourceLocation &Loc,\n                              SourceRange &R1, SourceRange &R2,\n                              ASTContext &Ctx) const;\n\n  /// isLValue - True if this expression is an \"l-value\" according to\n  /// the rules of the current language.  C and C++ give somewhat\n  /// different rules for this concept, but in general, the result of\n  /// an l-value expression identifies a specific object whereas the\n  /// result of an r-value expression is a value detached from any\n  /// specific storage.\n  ///\n  /// C++11 divides the concept of \"r-value\" into pure r-values\n  /// (\"pr-values\") and so-called expiring values (\"x-values\"), which\n  /// identify specific objects that can be safely cannibalized for\n  /// their resources.  This is an unfortunate abuse of terminology on\n  /// the part of the C++ committee.  In Clang, when we say \"r-value\",\n  /// we generally mean a pr-value.\n  bool isLValue() const { return getValueKind() == VK_LValue; }\n  bool isRValue() const { return getValueKind() == VK_RValue; }\n  bool isXValue() const { return getValueKind() == VK_XValue; }\n  bool isGLValue() const { return getValueKind() != VK_RValue; }\n\n  enum LValueClassification {\n    LV_Valid,\n    LV_NotObjectType,\n    LV_IncompleteVoidType,\n    LV_DuplicateVectorComponents,\n    LV_InvalidExpression,\n    LV_InvalidMessageExpression,\n    LV_MemberFunction,\n    LV_SubObjCPropertySetting,\n    LV_ClassTemporary,\n    LV_ArrayTemporary\n  };\n  /// Reasons why an expression might not be an l-value.\n  LValueClassification ClassifyLValue(ASTContext &Ctx) const;\n\n  enum isModifiableLvalueResult {\n    MLV_Valid,\n    MLV_NotObjectType,\n    MLV_IncompleteVoidType,\n    MLV_DuplicateVectorComponents,\n    MLV_InvalidExpression,\n    MLV_LValueCast,           // Specialized form of MLV_InvalidExpression.\n    MLV_IncompleteType,\n    MLV_ConstQualified,\n    MLV_ConstQualifiedField,\n    MLV_ConstAddrSpace,\n    MLV_ArrayType,\n    MLV_NoSetterProperty,\n    MLV_MemberFunction,\n    MLV_SubObjCPropertySetting,\n    MLV_InvalidMessageExpression,\n    MLV_ClassTemporary,\n    MLV_ArrayTemporary\n  };\n  /// isModifiableLvalue - C99 6.3.2.1: an lvalue that does not have array type,\n  /// does not have an incomplete type, does not have a const-qualified type,\n  /// and if it is a structure or union, does not have any member (including,\n  /// recursively, any member or element of all contained aggregates or unions)\n  /// with a const-qualified type.\n  ///\n  /// \\param Loc [in,out] - A source location which *may* be filled\n  /// in with the location of the expression making this a\n  /// non-modifiable lvalue, if specified.\n  isModifiableLvalueResult\n  isModifiableLvalue(ASTContext &Ctx, SourceLocation *Loc = nullptr) const;\n\n  /// The return type of classify(). Represents the C++11 expression\n  ///        taxonomy.\n  class Classification {\n  public:\n    /// The various classification results. Most of these mean prvalue.\n    enum Kinds {\n      CL_LValue,\n      CL_XValue,\n      CL_Function, // Functions cannot be lvalues in C.\n      CL_Void, // Void cannot be an lvalue in C.\n      CL_AddressableVoid, // Void expression whose address can be taken in C.\n      CL_DuplicateVectorComponents, // A vector shuffle with dupes.\n      CL_MemberFunction, // An expression referring to a member function\n      CL_SubObjCPropertySetting,\n      CL_ClassTemporary, // A temporary of class type, or subobject thereof.\n      CL_ArrayTemporary, // A temporary of array type.\n      CL_ObjCMessageRValue, // ObjC message is an rvalue\n      CL_PRValue // A prvalue for any other reason, of any other type\n    };\n    /// The results of modification testing.\n    enum ModifiableType {\n      CM_Untested, // testModifiable was false.\n      CM_Modifiable,\n      CM_RValue, // Not modifiable because it's an rvalue\n      CM_Function, // Not modifiable because it's a function; C++ only\n      CM_LValueCast, // Same as CM_RValue, but indicates GCC cast-as-lvalue ext\n      CM_NoSetterProperty,// Implicit assignment to ObjC property without setter\n      CM_ConstQualified,\n      CM_ConstQualifiedField,\n      CM_ConstAddrSpace,\n      CM_ArrayType,\n      CM_IncompleteType\n    };\n\n  private:\n    friend class Expr;\n\n    unsigned short Kind;\n    unsigned short Modifiable;\n\n    explicit Classification(Kinds k, ModifiableType m)\n      : Kind(k), Modifiable(m)\n    {}\n\n  public:\n    Classification() {}\n\n    Kinds getKind() const { return static_cast<Kinds>(Kind); }\n    ModifiableType getModifiable() const {\n      assert(Modifiable != CM_Untested && \"Did not test for modifiability.\");\n      return static_cast<ModifiableType>(Modifiable);\n    }\n    bool isLValue() const { return Kind == CL_LValue; }\n    bool isXValue() const { return Kind == CL_XValue; }\n    bool isGLValue() const { return Kind <= CL_XValue; }\n    bool isPRValue() const { return Kind >= CL_Function; }\n    bool isRValue() const { return Kind >= CL_XValue; }\n    bool isModifiable() const { return getModifiable() == CM_Modifiable; }\n\n    /// Create a simple, modifiably lvalue\n    static Classification makeSimpleLValue() {\n      return Classification(CL_LValue, CM_Modifiable);\n    }\n\n  };\n  /// Classify - Classify this expression according to the C++11\n  ///        expression taxonomy.\n  ///\n  /// C++11 defines ([basic.lval]) a new taxonomy of expressions to replace the\n  /// old lvalue vs rvalue. This function determines the type of expression this\n  /// is. There are three expression types:\n  /// - lvalues are classical lvalues as in C++03.\n  /// - prvalues are equivalent to rvalues in C++03.\n  /// - xvalues are expressions yielding unnamed rvalue references, e.g. a\n  ///   function returning an rvalue reference.\n  /// lvalues and xvalues are collectively referred to as glvalues, while\n  /// prvalues and xvalues together form rvalues.\n  Classification Classify(ASTContext &Ctx) const {\n    return ClassifyImpl(Ctx, nullptr);\n  }\n\n  /// ClassifyModifiable - Classify this expression according to the\n  ///        C++11 expression taxonomy, and see if it is valid on the left side\n  ///        of an assignment.\n  ///\n  /// This function extends classify in that it also tests whether the\n  /// expression is modifiable (C99 6.3.2.1p1).\n  /// \\param Loc A source location that might be filled with a relevant location\n  ///            if the expression is not modifiable.\n  Classification ClassifyModifiable(ASTContext &Ctx, SourceLocation &Loc) const{\n    return ClassifyImpl(Ctx, &Loc);\n  }\n\n  /// Returns the set of floating point options that apply to this expression.\n  /// Only meaningful for operations on floating point values.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const;\n\n  /// getValueKindForType - Given a formal return or parameter type,\n  /// give its value kind.\n  static ExprValueKind getValueKindForType(QualType T) {\n    if (const ReferenceType *RT = T->getAs<ReferenceType>())\n      return (isa<LValueReferenceType>(RT)\n                ? VK_LValue\n                : (RT->getPointeeType()->isFunctionType()\n                     ? VK_LValue : VK_XValue));\n    return VK_RValue;\n  }\n\n  /// getValueKind - The value kind that this expression produces.\n  ExprValueKind getValueKind() const {\n    return static_cast<ExprValueKind>(ExprBits.ValueKind);\n  }\n\n  /// getObjectKind - The object kind that this expression produces.\n  /// Object kinds are meaningful only for expressions that yield an\n  /// l-value or x-value.\n  ExprObjectKind getObjectKind() const {\n    return static_cast<ExprObjectKind>(ExprBits.ObjectKind);\n  }\n\n  bool isOrdinaryOrBitFieldObject() const {\n    ExprObjectKind OK = getObjectKind();\n    return (OK == OK_Ordinary || OK == OK_BitField);\n  }\n\n  /// setValueKind - Set the value kind produced by this expression.\n  void setValueKind(ExprValueKind Cat) { ExprBits.ValueKind = Cat; }\n\n  /// setObjectKind - Set the object kind produced by this expression.\n  void setObjectKind(ExprObjectKind Cat) { ExprBits.ObjectKind = Cat; }\n\nprivate:\n  Classification ClassifyImpl(ASTContext &Ctx, SourceLocation *Loc) const;\n\npublic:\n\n  /// Returns true if this expression is a gl-value that\n  /// potentially refers to a bit-field.\n  ///\n  /// In C++, whether a gl-value refers to a bitfield is essentially\n  /// an aspect of the value-kind type system.\n  bool refersToBitField() const { return getObjectKind() == OK_BitField; }\n\n  /// If this expression refers to a bit-field, retrieve the\n  /// declaration of that bit-field.\n  ///\n  /// Note that this returns a non-null pointer in subtly different\n  /// places than refersToBitField returns true.  In particular, this can\n  /// return a non-null pointer even for r-values loaded from\n  /// bit-fields, but it will return null for a conditional bit-field.\n  FieldDecl *getSourceBitField();\n\n  const FieldDecl *getSourceBitField() const {\n    return const_cast<Expr*>(this)->getSourceBitField();\n  }\n\n  Decl *getReferencedDeclOfCallee();\n  const Decl *getReferencedDeclOfCallee() const {\n    return const_cast<Expr*>(this)->getReferencedDeclOfCallee();\n  }\n\n  /// If this expression is an l-value for an Objective C\n  /// property, find the underlying property reference expression.\n  const ObjCPropertyRefExpr *getObjCProperty() const;\n\n  /// Check if this expression is the ObjC 'self' implicit parameter.\n  bool isObjCSelfExpr() const;\n\n  /// Returns whether this expression refers to a vector element.\n  bool refersToVectorElement() const;\n\n  /// Returns whether this expression refers to a matrix element.\n  bool refersToMatrixElement() const {\n    return getObjectKind() == OK_MatrixComponent;\n  }\n\n  /// Returns whether this expression refers to a global register\n  /// variable.\n  bool refersToGlobalRegisterVar() const;\n\n  /// Returns whether this expression has a placeholder type.\n  bool hasPlaceholderType() const {\n    return getType()->isPlaceholderType();\n  }\n\n  /// Returns whether this expression has a specific placeholder type.\n  bool hasPlaceholderType(BuiltinType::Kind K) const {\n    assert(BuiltinType::isPlaceholderTypeKind(K));\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(getType()))\n      return BT->getKind() == K;\n    return false;\n  }\n\n  /// isKnownToHaveBooleanValue - Return true if this is an integer expression\n  /// that is known to return 0 or 1.  This happens for _Bool/bool expressions\n  /// but also int expressions which are produced by things like comparisons in\n  /// C.\n  ///\n  /// \\param Semantic If true, only return true for expressions that are known\n  /// to be semantically boolean, which might not be true even for expressions\n  /// that are known to evaluate to 0/1. For instance, reading an unsigned\n  /// bit-field with width '1' will evaluate to 0/1, but doesn't necessarily\n  /// semantically correspond to a bool.\n  bool isKnownToHaveBooleanValue(bool Semantic = true) const;\n\n  /// isIntegerConstantExpr - Return the value if this expression is a valid\n  /// integer constant expression.  If not a valid i-c-e, return None and fill\n  /// in Loc (if specified) with the location of the invalid expression.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  Optional<llvm::APSInt> getIntegerConstantExpr(const ASTContext &Ctx,\n                                                SourceLocation *Loc = nullptr,\n                                                bool isEvaluated = true) const;\n  bool isIntegerConstantExpr(const ASTContext &Ctx,\n                             SourceLocation *Loc = nullptr) const;\n\n  /// isCXX98IntegralConstantExpr - Return true if this expression is an\n  /// integral constant expression in C++98. Can only be used in C++.\n  bool isCXX98IntegralConstantExpr(const ASTContext &Ctx) const;\n\n  /// isCXX11ConstantExpr - Return true if this expression is a constant\n  /// expression in C++11. Can only be used in C++.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  bool isCXX11ConstantExpr(const ASTContext &Ctx, APValue *Result = nullptr,\n                           SourceLocation *Loc = nullptr) const;\n\n  /// isPotentialConstantExpr - Return true if this function's definition\n  /// might be usable in a constant expression in C++11, if it were marked\n  /// constexpr. Return false if the function can never produce a constant\n  /// expression, along with diagnostics describing why not.\n  static bool isPotentialConstantExpr(const FunctionDecl *FD,\n                                      SmallVectorImpl<\n                                        PartialDiagnosticAt> &Diags);\n\n  /// isPotentialConstantExprUnevaluted - Return true if this expression might\n  /// be usable in a constant expression in C++11 in an unevaluated context, if\n  /// it were in function FD marked constexpr. Return false if the function can\n  /// never produce a constant expression, along with diagnostics describing\n  /// why not.\n  static bool isPotentialConstantExprUnevaluated(Expr *E,\n                                                 const FunctionDecl *FD,\n                                                 SmallVectorImpl<\n                                                   PartialDiagnosticAt> &Diags);\n\n  /// isConstantInitializer - Returns true if this expression can be emitted to\n  /// IR as a constant, and thus can be used as a constant initializer in C.\n  /// If this expression is not constant and Culprit is non-null,\n  /// it is used to store the address of first non constant expr.\n  bool isConstantInitializer(ASTContext &Ctx, bool ForRef,\n                             const Expr **Culprit = nullptr) const;\n\n  /// EvalStatus is a struct with detailed info about an evaluation in progress.\n  struct EvalStatus {\n    /// Whether the evaluated expression has side effects.\n    /// For example, (f() && 0) can be folded, but it still has side effects.\n    bool HasSideEffects;\n\n    /// Whether the evaluation hit undefined behavior.\n    /// For example, 1.0 / 0.0 can be folded to Inf, but has undefined behavior.\n    /// Likewise, INT_MAX + 1 can be folded to INT_MIN, but has UB.\n    bool HasUndefinedBehavior;\n\n    /// Diag - If this is non-null, it will be filled in with a stack of notes\n    /// indicating why evaluation failed (or why it failed to produce a constant\n    /// expression).\n    /// If the expression is unfoldable, the notes will indicate why it's not\n    /// foldable. If the expression is foldable, but not a constant expression,\n    /// the notes will describes why it isn't a constant expression. If the\n    /// expression *is* a constant expression, no notes will be produced.\n    SmallVectorImpl<PartialDiagnosticAt> *Diag;\n\n    EvalStatus()\n        : HasSideEffects(false), HasUndefinedBehavior(false), Diag(nullptr) {}\n\n    // hasSideEffects - Return true if the evaluated expression has\n    // side effects.\n    bool hasSideEffects() const {\n      return HasSideEffects;\n    }\n  };\n\n  /// EvalResult is a struct with detailed info about an evaluated expression.\n  struct EvalResult : EvalStatus {\n    /// Val - This is the value the expression can be folded to.\n    APValue Val;\n\n    // isGlobalLValue - Return true if the evaluated lvalue expression\n    // is global.\n    bool isGlobalLValue() const;\n  };\n\n  /// EvaluateAsRValue - Return true if this is a constant which we can fold to\n  /// an rvalue using any crazy technique (that has nothing to do with language\n  /// standards) that we want to, even if the expression has side-effects. If\n  /// this function returns true, it returns the folded constant in Result. If\n  /// the expression is a glvalue, an lvalue-to-rvalue conversion will be\n  /// applied.\n  bool EvaluateAsRValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsBooleanCondition - Return true if this is a constant\n  /// which we can fold and convert to a boolean condition using\n  /// any crazy technique that we want to, even if the expression has\n  /// side-effects.\n  bool EvaluateAsBooleanCondition(bool &Result, const ASTContext &Ctx,\n                                  bool InConstantContext = false) const;\n\n  enum SideEffectsKind {\n    SE_NoSideEffects,          ///< Strictly evaluate the expression.\n    SE_AllowUndefinedBehavior, ///< Allow UB that we can give a value, but not\n                               ///< arbitrary unmodeled side effects.\n    SE_AllowSideEffects        ///< Allow any unmodeled side effect.\n  };\n\n  /// EvaluateAsInt - Return true if this is a constant which we can fold and\n  /// convert to an integer, using any crazy technique that we want to.\n  bool EvaluateAsInt(EvalResult &Result, const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                     bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a floating point value, using any crazy technique that we\n  /// want to.\n  bool EvaluateAsFloat(llvm::APFloat &Result, const ASTContext &Ctx,\n                       SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                       bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a fixed point value.\n  bool EvaluateAsFixedPoint(EvalResult &Result, const ASTContext &Ctx,\n                            SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                            bool InConstantContext = false) const;\n\n  /// isEvaluatable - Call EvaluateAsRValue to see if this expression can be\n  /// constant folded without side-effects, but discard the result.\n  bool isEvaluatable(const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects) const;\n\n  /// HasSideEffects - This routine returns true for all those expressions\n  /// which have any effect other than producing a value. Example is a function\n  /// call, volatile variable read, or throwing an exception. If\n  /// IncludePossibleEffects is false, this call treats certain expressions with\n  /// potential side effects (such as function call-like expressions,\n  /// instantiation-dependent expressions, or invocations from a macro) as not\n  /// having side effects.\n  bool HasSideEffects(const ASTContext &Ctx,\n                      bool IncludePossibleEffects = true) const;\n\n  /// Determine whether this expression involves a call to any function\n  /// that is not trivial.\n  bool hasNonTrivialCall(const ASTContext &Ctx) const;\n\n  /// EvaluateKnownConstInt - Call EvaluateAsRValue and return the folded\n  /// integer. This must be called on an expression that constant folds to an\n  /// integer.\n  llvm::APSInt EvaluateKnownConstInt(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  llvm::APSInt EvaluateKnownConstIntCheckOverflow(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  void EvaluateForOverflow(const ASTContext &Ctx) const;\n\n  /// EvaluateAsLValue - Evaluate an expression to see if we can fold it to an\n  /// lvalue with link time known address, with no side-effects.\n  bool EvaluateAsLValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsInitializer - Evaluate an expression as if it were the\n  /// initializer of the given declaration. Returns true if the initializer\n  /// can be folded to a constant, and produces any relevant notes. In C++11,\n  /// notes will be produced if the expression is not a constant expression.\n  bool EvaluateAsInitializer(APValue &Result, const ASTContext &Ctx,\n                             const VarDecl *VD,\n                             SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitializer) const;\n\n  /// EvaluateWithSubstitution - Evaluate an expression as if from the context\n  /// of a call to the given function with the given arguments, inside an\n  /// unevaluated context. Returns true if the expression could be folded to a\n  /// constant.\n  bool EvaluateWithSubstitution(APValue &Value, ASTContext &Ctx,\n                                const FunctionDecl *Callee,\n                                ArrayRef<const Expr*> Args,\n                                const Expr *This = nullptr) const;\n\n  enum class ConstantExprKind {\n    /// An integer constant expression (an array bound, enumerator, case value,\n    /// bit-field width, or similar) or similar.\n    Normal,\n    /// A non-class template argument. Such a value is only used for mangling,\n    /// not for code generation, so can refer to dllimported functions.\n    NonClassTemplateArgument,\n    /// A class template argument. Such a value is used for code generation.\n    ClassTemplateArgument,\n    /// An immediate invocation. The destruction of the end result of this\n    /// evaluation is not part of the evaluation, but all other temporaries\n    /// are destroyed.\n    ImmediateInvocation,\n  };\n\n  /// Evaluate an expression that is required to be a constant expression. Does\n  /// not check the syntactic constraints for C and C++98 constant expressions.\n  bool EvaluateAsConstantExpr(\n      EvalResult &Result, const ASTContext &Ctx,\n      ConstantExprKind Kind = ConstantExprKind::Normal) const;\n\n  /// If the current Expr is a pointer, this will try to statically\n  /// determine the number of bytes available where the pointer is pointing.\n  /// Returns true if all of the above holds and we were able to figure out the\n  /// size, false otherwise.\n  ///\n  /// \\param Type - How to evaluate the size of the Expr, as defined by the\n  /// \"type\" parameter of __builtin_object_size\n  bool tryEvaluateObjectSize(uint64_t &Result, ASTContext &Ctx,\n                             unsigned Type) const;\n\n  /// Enumeration used to describe the kind of Null pointer constant\n  /// returned from \\c isNullPointerConstant().\n  enum NullPointerConstantKind {\n    /// Expression is not a Null pointer constant.\n    NPCK_NotNull = 0,\n\n    /// Expression is a Null pointer constant built from a zero integer\n    /// expression that is not a simple, possibly parenthesized, zero literal.\n    /// C++ Core Issue 903 will classify these expressions as \"not pointers\"\n    /// once it is adopted.\n    /// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\n    NPCK_ZeroExpression,\n\n    /// Expression is a Null pointer constant built from a literal zero.\n    NPCK_ZeroLiteral,\n\n    /// Expression is a C++11 nullptr.\n    NPCK_CXX11_nullptr,\n\n    /// Expression is a GNU-style __null constant.\n    NPCK_GNUNull\n  };\n\n  /// Enumeration used to describe how \\c isNullPointerConstant()\n  /// should cope with value-dependent expressions.\n  enum NullPointerConstantValueDependence {\n    /// Specifies that the expression should never be value-dependent.\n    NPC_NeverValueDependent = 0,\n\n    /// Specifies that a value-dependent expression of integral or\n    /// dependent type should be considered a null pointer constant.\n    NPC_ValueDependentIsNull,\n\n    /// Specifies that a value-dependent expression should be considered\n    /// to never be a null pointer constant.\n    NPC_ValueDependentIsNotNull\n  };\n\n  /// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to\n  /// a Null pointer constant. The return value can further distinguish the\n  /// kind of NULL pointer constant that was detected.\n  NullPointerConstantKind isNullPointerConstant(\n      ASTContext &Ctx,\n      NullPointerConstantValueDependence NPC) const;\n\n  /// isOBJCGCCandidate - Return true if this expression may be used in a read/\n  /// write barrier.\n  bool isOBJCGCCandidate(ASTContext &Ctx) const;\n\n  /// Returns true if this expression is a bound member function.\n  bool isBoundMemberFunction(ASTContext &Ctx) const;\n\n  /// Given an expression of bound-member type, find the type\n  /// of the member.  Returns null if this is an *overloaded* bound\n  /// member expression.\n  static QualType findBoundMemberType(const Expr *expr);\n\n  /// Skip past any invisble AST nodes which might surround this\n  /// statement, such as ExprWithCleanups or ImplicitCastExpr nodes,\n  /// but also injected CXXMemberExpr and CXXConstructExpr which represent\n  /// implicit conversions.\n  Expr *IgnoreUnlessSpelledInSource();\n  const Expr *IgnoreUnlessSpelledInSource() const {\n    return const_cast<Expr *>(this)->IgnoreUnlessSpelledInSource();\n  }\n\n  /// Skip past any implicit casts which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ImplicitCastExpr\n  /// * FullExpr\n  Expr *IgnoreImpCasts() LLVM_READONLY;\n  const Expr *IgnoreImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreImpCasts();\n  }\n\n  /// Skip past any casts which might surround this expression until reaching\n  /// a fixed point. Skips:\n  /// * CastExpr\n  /// * FullExpr\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreCasts() LLVM_READONLY;\n  const Expr *IgnoreCasts() const {\n    return const_cast<Expr *>(this)->IgnoreCasts();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * CXXBindTemporaryExpr\n  Expr *IgnoreImplicit() LLVM_READONLY;\n  const Expr *IgnoreImplicit() const {\n    return const_cast<Expr *>(this)->IgnoreImplicit();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Same as IgnoreImplicit, except that it\n  /// also skips over implicit calls to constructors and conversion functions.\n  ///\n  /// FIXME: Should IgnoreImplicit do this?\n  Expr *IgnoreImplicitAsWritten() LLVM_READONLY;\n  const Expr *IgnoreImplicitAsWritten() const {\n    return const_cast<Expr *>(this)->IgnoreImplicitAsWritten();\n  }\n\n  /// Skip past any parentheses which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ParenExpr\n  /// * UnaryOperator if `UO_Extension`\n  /// * GenericSelectionExpr if `!isResultDependent()`\n  /// * ChooseExpr if `!isConditionDependent()`\n  /// * ConstantExpr\n  Expr *IgnoreParens() LLVM_READONLY;\n  const Expr *IgnoreParens() const {\n    return const_cast<Expr *>(this)->IgnoreParens();\n  }\n\n  /// Skip past any parentheses and implicit casts which might surround this\n  /// expression until reaching a fixed point.\n  /// FIXME: IgnoreParenImpCasts really ought to be equivalent to\n  /// IgnoreParens() + IgnoreImpCasts() until reaching a fixed point. However\n  /// this is currently not the case. Instead IgnoreParenImpCasts() skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenImpCasts() LLVM_READONLY;\n  const Expr *IgnoreParenImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenImpCasts();\n  }\n\n  /// Skip past any parentheses and casts which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips\n  Expr *IgnoreParenCasts() LLVM_READONLY;\n  const Expr *IgnoreParenCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenCasts();\n  }\n\n  /// Skip conversion operators. If this Expr is a call to a conversion\n  /// operator, return the argument.\n  Expr *IgnoreConversionOperatorSingleStep() LLVM_READONLY;\n  const Expr *IgnoreConversionOperatorSingleStep() const {\n    return const_cast<Expr *>(this)->IgnoreConversionOperatorSingleStep();\n  }\n\n  /// Skip past any parentheses and lvalue casts which might surround this\n  /// expression until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips, except that only lvalue-to-rvalue\n  ///   casts are skipped\n  /// FIXME: This is intended purely as a temporary workaround for code\n  /// that hasn't yet been rewritten to do the right thing about those\n  /// casts, and may disappear along with the last internal use.\n  Expr *IgnoreParenLValueCasts() LLVM_READONLY;\n  const Expr *IgnoreParenLValueCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenLValueCasts();\n  }\n\n  /// Skip past any parenthese and casts which do not change the value\n  /// (including ptr->int casts of the same size) until reaching a fixed point.\n  /// Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which do not change the value\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) LLVM_READONLY;\n  const Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) const {\n    return const_cast<Expr *>(this)->IgnoreParenNoopCasts(Ctx);\n  }\n\n  /// Skip past any parentheses and derived-to-base casts until reaching a\n  /// fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which represent a derived-to-base cast (CK_DerivedToBase,\n  ///   CK_UncheckedDerivedToBase and CK_NoOp)\n  Expr *IgnoreParenBaseCasts() LLVM_READONLY;\n  const Expr *IgnoreParenBaseCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenBaseCasts();\n  }\n\n  /// Determine whether this expression is a default function argument.\n  ///\n  /// Default arguments are implicitly generated in the abstract syntax tree\n  /// by semantic analysis for function calls, object constructions, etc. in\n  /// C++. Default arguments are represented by \\c CXXDefaultArgExpr nodes;\n  /// this routine also looks through any implicit casts to determine whether\n  /// the expression is a default argument.\n  bool isDefaultArgument() const;\n\n  /// Determine whether the result of this expression is a\n  /// temporary object of the given class type.\n  bool isTemporaryObject(ASTContext &Ctx, const CXXRecordDecl *TempTy) const;\n\n  /// Whether this expression is an implicit reference to 'this' in C++.\n  bool isImplicitCXXThis() const;\n\n  static bool hasAnyTypeDependentArguments(ArrayRef<Expr *> Exprs);\n\n  /// For an expression of class type or pointer to class type,\n  /// return the most derived class decl the expression is known to refer to.\n  ///\n  /// If this expression is a cast, this method looks through it to find the\n  /// most derived decl that can be inferred from the expression.\n  /// This is valid because derived-to-base conversions have undefined\n  /// behavior if the object isn't dynamically of the derived type.\n  const CXXRecordDecl *getBestDynamicClassType() const;\n\n  /// Get the inner expression that determines the best dynamic class.\n  /// If this is a prvalue, we guarantee that it is of the most-derived type\n  /// for the object itself.\n  const Expr *getBestDynamicClassTypeExpr() const;\n\n  /// Walk outwards from an expression we want to bind a reference to and\n  /// find the expression whose lifetime needs to be extended. Record\n  /// the LHSs of comma expressions and adjustments needed along the path.\n  const Expr *skipRValueSubobjectAdjustments(\n      SmallVectorImpl<const Expr *> &CommaLHS,\n      SmallVectorImpl<SubobjectAdjustment> &Adjustments) const;\n  const Expr *skipRValueSubobjectAdjustments() const {\n    SmallVector<const Expr *, 8> CommaLHSs;\n    SmallVector<SubobjectAdjustment, 8> Adjustments;\n    return skipRValueSubobjectAdjustments(CommaLHSs, Adjustments);\n  }\n\n  /// Checks that the two Expr's will refer to the same value as a comparison\n  /// operand.  The caller must ensure that the values referenced by the Expr's\n  /// are not modified between E1 and E2 or the result my be invalid.\n  static bool isSameComparisonOperand(const Expr* E1, const Expr* E2);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstExprConstant &&\n           T->getStmtClass() <= lastExprConstant;\n  }\n};\n// PointerLikeTypeTraits is specialized so it can be used with a forward-decl of\n// Expr. Verify that we got it right.\nstatic_assert(llvm::PointerLikeTypeTraits<Expr *>::NumLowBitsAvailable <=\n                  llvm::detail::ConstantLog2<alignof(Expr)>::value,\n              \"PointerLikeTypeTraits<Expr*> assumes too much alignment.\");\n\nusing ConstantExprKind = Expr::ConstantExprKind;\n\n//===----------------------------------------------------------------------===//\n// Wrapper Expressions.\n//===----------------------------------------------------------------------===//\n\n/// FullExpr - Represents a \"full-expression\" node.\nclass FullExpr : public Expr {\nprotected:\n Stmt *SubExpr;\n\n FullExpr(StmtClass SC, Expr *subexpr)\n     : Expr(SC, subexpr->getType(), subexpr->getValueKind(),\n            subexpr->getObjectKind()),\n       SubExpr(subexpr) {\n   setDependence(computeDependence(this));\n }\n  FullExpr(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) {}\npublic:\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n\n  /// As with any mutator of the AST, be very careful when modifying an\n  /// existing AST to preserve its invariants.\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstFullExprConstant &&\n           T->getStmtClass() <= lastFullExprConstant;\n  }\n};\n\n/// ConstantExpr - An expression that occurs in a constant context and\n/// optionally the result of evaluating the expression.\nclass ConstantExpr final\n    : public FullExpr,\n      private llvm::TrailingObjects<ConstantExpr, APValue, uint64_t> {\n  static_assert(std::is_same<uint64_t, llvm::APInt::WordType>::value,\n                \"ConstantExpr assumes that llvm::APInt::WordType is uint64_t \"\n                \"for tail-allocated storage\");\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\npublic:\n  /// Describes the kind of result that can be tail-allocated.\n  enum ResultStorageKind { RSK_None, RSK_Int64, RSK_APValue };\n\nprivate:\n  size_t numTrailingObjects(OverloadToken<APValue>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue;\n  }\n  size_t numTrailingObjects(OverloadToken<uint64_t>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64;\n  }\n\n  uint64_t &Int64Result() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64 &&\n           \"invalid accessor\");\n    return *getTrailingObjects<uint64_t>();\n  }\n  const uint64_t &Int64Result() const {\n    return const_cast<ConstantExpr *>(this)->Int64Result();\n  }\n  APValue &APValueResult() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue &&\n           \"invalid accessor\");\n    return *getTrailingObjects<APValue>();\n  }\n  APValue &APValueResult() const {\n    return const_cast<ConstantExpr *>(this)->APValueResult();\n  }\n\n  ConstantExpr(Expr *SubExpr, ResultStorageKind StorageKind,\n               bool IsImmediateInvocation);\n  ConstantExpr(EmptyShell Empty, ResultStorageKind StorageKind);\n\npublic:\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              const APValue &Result);\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              ResultStorageKind Storage = RSK_None,\n                              bool IsImmediateInvocation = false);\n  static ConstantExpr *CreateEmpty(const ASTContext &Context,\n                                   ResultStorageKind StorageKind);\n\n  static ResultStorageKind getStorageKind(const APValue &Value);\n  static ResultStorageKind getStorageKind(const Type *T,\n                                          const ASTContext &Context);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConstantExprClass;\n  }\n\n  void SetResult(APValue Value, const ASTContext &Context) {\n    MoveIntoResult(Value, Context);\n  }\n  void MoveIntoResult(APValue &Value, const ASTContext &Context);\n\n  APValue::ValueKind getResultAPValueKind() const {\n    return static_cast<APValue::ValueKind>(ConstantExprBits.APValueKind);\n  }\n  ResultStorageKind getResultStorageKind() const {\n    return static_cast<ResultStorageKind>(ConstantExprBits.ResultKind);\n  }\n  bool isImmediateInvocation() const {\n    return ConstantExprBits.IsImmediateInvocation;\n  }\n  bool hasAPValueResult() const {\n    return ConstantExprBits.APValueKind != APValue::None;\n  }\n  APValue getAPValueResult() const;\n  APValue &getResultAsAPValue() const { return APValueResult(); }\n  llvm::APSInt getResultAsAPSInt() const;\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Primary Expressions.\n//===----------------------------------------------------------------------===//\n\n/// OpaqueValueExpr - An expression referring to an opaque object of a\n/// fixed type and value class.  These don't correspond to concrete\n/// syntax; instead they're used to express operations (usually copy\n/// operations) on values whose source is generally obvious from\n/// context.\nclass OpaqueValueExpr : public Expr {\n  friend class ASTStmtReader;\n  Expr *SourceExpr;\n\npublic:\n  OpaqueValueExpr(SourceLocation Loc, QualType T, ExprValueKind VK,\n                  ExprObjectKind OK = OK_Ordinary, Expr *SourceExpr = nullptr)\n      : Expr(OpaqueValueExprClass, T, VK, OK), SourceExpr(SourceExpr) {\n    setIsUnique(false);\n    OpaqueValueExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Given an expression which invokes a copy constructor --- i.e.  a\n  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups ---\n  /// find the OpaqueValueExpr that's the source of the construction.\n  static const OpaqueValueExpr *findInCopyConstruct(const Expr *expr);\n\n  explicit OpaqueValueExpr(EmptyShell Empty)\n    : Expr(OpaqueValueExprClass, Empty) {}\n\n  /// Retrieve the location of this expression.\n  SourceLocation getLocation() const { return OpaqueValueExprBits.Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getBeginLoc() : getLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getEndLoc() : getLocation();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getExprLoc() : getLocation();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// The source expression of an opaque value expression is the\n  /// expression which originally generated the value.  This is\n  /// provided as a convenience for analyses that don't wish to\n  /// precisely model the execution behavior of the program.\n  ///\n  /// The source expression is typically set when building the\n  /// expression which binds the opaque value expression in the first\n  /// place.\n  Expr *getSourceExpr() const { return SourceExpr; }\n\n  void setIsUnique(bool V) {\n    assert((!V || SourceExpr) &&\n           \"unique OVEs are expected to have source expressions\");\n    OpaqueValueExprBits.IsUnique = V;\n  }\n\n  bool isUnique() const { return OpaqueValueExprBits.IsUnique; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OpaqueValueExprClass;\n  }\n};\n\n/// A reference to a declared variable, function, enum, etc.\n/// [C99 6.5.1p2]\n///\n/// This encodes all the information about how a declaration is referenced\n/// within an expression.\n///\n/// There are several optional constructs attached to DeclRefExprs only when\n/// they apply in order to conserve memory. These are laid out past the end of\n/// the object, and flags in the DeclRefExprBitfield track whether they exist:\n///\n///   DeclRefExprBits.HasQualifier:\n///       Specifies when this declaration reference expression has a C++\n///       nested-name-specifier.\n///   DeclRefExprBits.HasFoundDecl:\n///       Specifies when this declaration reference expression has a record of\n///       a NamedDecl (different from the referenced ValueDecl) which was found\n///       during name lookup and/or overload resolution.\n///   DeclRefExprBits.HasTemplateKWAndArgsInfo:\n///       Specifies when this declaration reference expression has an explicit\n///       C++ template keyword and/or template argument list.\n///   DeclRefExprBits.RefersToEnclosingVariableOrCapture\n///       Specifies when this declaration reference expression (validly)\n///       refers to an enclosed local or a captured variable.\nclass DeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DeclRefExpr, NestedNameSpecifierLoc,\n                                    NamedDecl *, ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The declaration that we are referencing.\n  ValueDecl *D;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in D.\n  DeclarationNameLoc DNLoc;\n\n  size_t numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {\n    return hasQualifier();\n  }\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  /// Test whether there is a distinct FoundDecl attached to the end of\n  /// this DRE.\n  bool hasFoundDecl() const { return DeclRefExprBits.HasFoundDecl; }\n\n  DeclRefExpr(const ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n              SourceLocation TemplateKWLoc, ValueDecl *D,\n              bool RefersToEnlosingVariableOrCapture,\n              const DeclarationNameInfo &NameInfo, NamedDecl *FoundD,\n              const TemplateArgumentListInfo *TemplateArgs, QualType T,\n              ExprValueKind VK, NonOdrUseReason NOUR);\n\n  /// Construct an empty declaration reference expression.\n  explicit DeclRefExpr(EmptyShell Empty) : Expr(DeclRefExprClass, Empty) {}\n\npublic:\n  DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,\n              bool RefersToEnclosingVariableOrCapture, QualType T,\n              ExprValueKind VK, SourceLocation L,\n              const DeclarationNameLoc &LocInfo = DeclarationNameLoc(),\n              NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture, SourceLocation NameLoc,\n         QualType T, ExprValueKind VK, NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture,\n         const DeclarationNameInfo &NameInfo, QualType T, ExprValueKind VK,\n         NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  /// Construct an empty declaration reference expression.\n  static DeclRefExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                  bool HasFoundDecl,\n                                  bool HasTemplateKWAndArgsInfo,\n                                  unsigned NumTemplateArgs);\n\n  ValueDecl *getDecl() { return D; }\n  const ValueDecl *getDecl() const { return D; }\n  void setDecl(ValueDecl *NewD);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDecl()->getDeclName(), getLocation(), DNLoc);\n  }\n\n  SourceLocation getLocation() const { return DeclRefExprBits.Loc; }\n  void setLocation(SourceLocation L) { DeclRefExprBits.Loc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Determine whether this declaration reference was preceded by a\n  /// C++ nested-name-specifier, e.g., \\c N::foo.\n  bool hasQualifier() const { return DeclRefExprBits.HasQualifier; }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifier())\n      return NestedNameSpecifierLoc();\n    return *getTrailingObjects<NestedNameSpecifierLoc>();\n  }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name. Otherwise, returns NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  ///\n  /// This Decl may be different from the ValueDecl actually referred to in the\n  /// presence of using declarations, etc. It always returns non-NULL, and may\n  /// simple return the ValueDecl when appropriate.\n\n  NamedDecl *getFoundDecl() {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  /// See non-const variant.\n  const NamedDecl *getFoundDecl() const {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name in this declaration reference\n  /// was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this declaration reference was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Returns true if this expression refers to a function that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return DeclRefExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a function that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    DeclRefExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(DeclRefExprBits.NonOdrUseReason);\n  }\n\n  /// Does this DeclRefExpr refer to an enclosing local or a captured\n  /// variable?\n  bool refersToEnclosingVariableOrCapture() const {\n    return DeclRefExprBits.RefersToEnclosingVariableOrCapture;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclRefExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Used by IntegerLiteral/FloatingLiteral to store the numeric without\n/// leaking memory.\n///\n/// For large floats/integers, APFloat/APInt will allocate memory from the heap\n/// to represent these numbers.  Unfortunately, when we use a BumpPtrAllocator\n/// to allocate IntegerLiteral/FloatingLiteral nodes the memory associated with\n/// the APFloat/APInt values will never get freed. APNumericStorage uses\n/// ASTContext's allocator for memory allocation.\nclass APNumericStorage {\n  union {\n    uint64_t VAL;    ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal;  ///< Used to store the >64 bits integer value.\n  };\n  unsigned BitWidth;\n\n  bool hasAllocation() const { return llvm::APInt::getNumWords(BitWidth) > 1; }\n\n  APNumericStorage(const APNumericStorage &) = delete;\n  void operator=(const APNumericStorage &) = delete;\n\nprotected:\n  APNumericStorage() : VAL(0), BitWidth(0) { }\n\n  llvm::APInt getIntValue() const {\n    unsigned NumWords = llvm::APInt::getNumWords(BitWidth);\n    if (NumWords > 1)\n      return llvm::APInt(BitWidth, NumWords, pVal);\n    else\n      return llvm::APInt(BitWidth, VAL);\n  }\n  void setIntValue(const ASTContext &C, const llvm::APInt &Val);\n};\n\nclass APIntStorage : private APNumericStorage {\npublic:\n  llvm::APInt getValue() const { return getIntValue(); }\n  void setValue(const ASTContext &C, const llvm::APInt &Val) {\n    setIntValue(C, Val);\n  }\n};\n\nclass APFloatStorage : private APNumericStorage {\npublic:\n  llvm::APFloat getValue(const llvm::fltSemantics &Semantics) const {\n    return llvm::APFloat(Semantics, getIntValue());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    setIntValue(C, Val.bitcastToAPInt());\n  }\n};\n\nclass IntegerLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n\n  /// Construct an empty integer literal.\n  explicit IntegerLiteral(EmptyShell Empty)\n    : Expr(IntegerLiteralClass, Empty) { }\n\npublic:\n  // type should be IntTy, LongTy, LongLongTy, UnsignedIntTy, UnsignedLongTy,\n  // or UnsignedLongLongTy\n  IntegerLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                 SourceLocation l);\n\n  /// Returns a new integer literal with value 'V' and type 'type'.\n  /// \\param type - either IntTy, LongTy, LongLongTy, UnsignedIntTy,\n  /// UnsignedLongTy, or UnsignedLongLongTy which should match the size of V\n  /// \\param V - the value that the returned integer literal contains.\n  static IntegerLiteral *Create(const ASTContext &C, const llvm::APInt &V,\n                                QualType type, SourceLocation l);\n  /// Returns a new empty integer literal.\n  static IntegerLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IntegerLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FixedPointLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n  unsigned Scale;\n\n  /// \\brief Construct an empty fixed-point literal.\n  explicit FixedPointLiteral(EmptyShell Empty)\n      : Expr(FixedPointLiteralClass, Empty) {}\n\n public:\n  FixedPointLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                    SourceLocation l, unsigned Scale);\n\n  // Store the int as is without any bit shifting.\n  static FixedPointLiteral *CreateFromRawInt(const ASTContext &C,\n                                             const llvm::APInt &V,\n                                             QualType type, SourceLocation l,\n                                             unsigned Scale);\n\n  /// Returns an empty fixed-point literal.\n  static FixedPointLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// \\brief Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  unsigned getScale() const { return Scale; }\n  void setScale(unsigned S) { Scale = S; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FixedPointLiteralClass;\n  }\n\n  std::string getValueAsString(unsigned Radix) const;\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass CharacterLiteral : public Expr {\npublic:\n  enum CharacterKind {\n    Ascii,\n    Wide,\n    UTF8,\n    UTF16,\n    UTF32\n  };\n\nprivate:\n  unsigned Value;\n  SourceLocation Loc;\npublic:\n  // type should be IntTy\n  CharacterLiteral(unsigned value, CharacterKind kind, QualType type,\n                   SourceLocation l)\n      : Expr(CharacterLiteralClass, type, VK_RValue, OK_Ordinary), Value(value),\n        Loc(l) {\n    CharacterLiteralBits.Kind = kind;\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty character literal.\n  CharacterLiteral(EmptyShell Empty) : Expr(CharacterLiteralClass, Empty) { }\n\n  SourceLocation getLocation() const { return Loc; }\n  CharacterKind getKind() const {\n    return static_cast<CharacterKind>(CharacterLiteralBits.Kind);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  unsigned getValue() const { return Value; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n  void setKind(CharacterKind kind) { CharacterLiteralBits.Kind = kind; }\n  void setValue(unsigned Val) { Value = Val; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CharacterLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FloatingLiteral : public Expr, private APFloatStorage {\n  SourceLocation Loc;\n\n  FloatingLiteral(const ASTContext &C, const llvm::APFloat &V, bool isexact,\n                  QualType Type, SourceLocation L);\n\n  /// Construct an empty floating-point literal.\n  explicit FloatingLiteral(const ASTContext &C, EmptyShell Empty);\n\npublic:\n  static FloatingLiteral *Create(const ASTContext &C, const llvm::APFloat &V,\n                                 bool isexact, QualType Type, SourceLocation L);\n  static FloatingLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  llvm::APFloat getValue() const {\n    return APFloatStorage::getValue(getSemantics());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    assert(&getSemantics() == &Val.getSemantics() && \"Inconsistent semantics\");\n    APFloatStorage::setValue(C, Val);\n  }\n\n  /// Get a raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  llvm::APFloatBase::Semantics getRawSemantics() const {\n    return static_cast<llvm::APFloatBase::Semantics>(\n        FloatingLiteralBits.Semantics);\n  }\n\n  /// Set the raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  void setRawSemantics(llvm::APFloatBase::Semantics Sem) {\n    FloatingLiteralBits.Semantics = Sem;\n  }\n\n  /// Return the APFloat semantics this literal uses.\n  const llvm::fltSemantics &getSemantics() const {\n    return llvm::APFloatBase::EnumToSemantics(\n        static_cast<llvm::APFloatBase::Semantics>(\n            FloatingLiteralBits.Semantics));\n  }\n\n  /// Set the APFloat semantics this literal uses.\n  void setSemantics(const llvm::fltSemantics &Sem) {\n    FloatingLiteralBits.Semantics = llvm::APFloatBase::SemanticsToEnum(Sem);\n  }\n\n  bool isExact() const { return FloatingLiteralBits.IsExact; }\n  void setExact(bool E) { FloatingLiteralBits.IsExact = E; }\n\n  /// getValueAsApproximateDouble - This returns the value as an inaccurate\n  /// double.  Note that this may cause loss of precision, but is useful for\n  /// debugging dumps, etc.\n  double getValueAsApproximateDouble() const;\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FloatingLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ImaginaryLiteral - We support imaginary integer and floating point literals,\n/// like \"1.0i\".  We represent these as a wrapper around FloatingLiteral and\n/// IntegerLiteral classes.  Instances of this class always have a Complex type\n/// whose element type matches the subexpression.\n///\nclass ImaginaryLiteral : public Expr {\n  Stmt *Val;\npublic:\n  ImaginaryLiteral(Expr *val, QualType Ty)\n      : Expr(ImaginaryLiteralClass, Ty, VK_RValue, OK_Ordinary), Val(val) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty imaginary literal.\n  explicit ImaginaryLiteral(EmptyShell Empty)\n    : Expr(ImaginaryLiteralClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Val->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Val->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImaginaryLiteralClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// StringLiteral - This represents a string literal expression, e.g. \"foo\"\n/// or L\"bar\" (wide strings). The actual string data can be obtained with\n/// getBytes() and is NOT null-terminated. The length of the string data is\n/// determined by calling getByteLength().\n///\n/// The C type for a string is always a ConstantArrayType. In C++, the char\n/// type is const qualified, in C it is not.\n///\n/// Note that strings in C can be formed by concatenation of multiple string\n/// literal pptokens in translation phase #6. This keeps track of the locations\n/// of each of these pieces.\n///\n/// Strings in C can also be truncated and extended by assigning into arrays,\n/// e.g. with constructs like:\n///   char X[2] = \"foobar\";\n/// In this case, getByteLength() will return 6, but the string literal will\n/// have type \"char[2]\".\nclass StringLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<StringLiteral, unsigned, SourceLocation,\n                                    char> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// StringLiteral is followed by several trailing objects. They are in order:\n  ///\n  /// * A single unsigned storing the length in characters of this string. The\n  ///   length in bytes is this length times the width of a single character.\n  ///   Always present and stored as a trailing objects because storing it in\n  ///   StringLiteral would increase the size of StringLiteral by sizeof(void *)\n  ///   due to alignment requirements. If you add some data to StringLiteral,\n  ///   consider moving it inside StringLiteral.\n  ///\n  /// * An array of getNumConcatenated() SourceLocation, one for each of the\n  ///   token this string is made of.\n  ///\n  /// * An array of getByteLength() char used to store the string data.\n\npublic:\n  enum StringKind { Ascii, Wide, UTF8, UTF16, UTF32 };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<unsigned>) const { return 1; }\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return getNumConcatenated();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<char>) const {\n    return getByteLength();\n  }\n\n  char *getStrDataAsChar() { return getTrailingObjects<char>(); }\n  const char *getStrDataAsChar() const { return getTrailingObjects<char>(); }\n\n  const uint16_t *getStrDataAsUInt16() const {\n    return reinterpret_cast<const uint16_t *>(getTrailingObjects<char>());\n  }\n\n  const uint32_t *getStrDataAsUInt32() const {\n    return reinterpret_cast<const uint32_t *>(getTrailingObjects<char>());\n  }\n\n  /// Build a string literal.\n  StringLiteral(const ASTContext &Ctx, StringRef Str, StringKind Kind,\n                bool Pascal, QualType Ty, const SourceLocation *Loc,\n                unsigned NumConcatenated);\n\n  /// Build an empty string literal.\n  StringLiteral(EmptyShell Empty, unsigned NumConcatenated, unsigned Length,\n                unsigned CharByteWidth);\n\n  /// Map a target and string kind to the appropriate character width.\n  static unsigned mapCharByteWidth(TargetInfo const &Target, StringKind SK);\n\n  /// Set one of the string literal token.\n  void setStrTokenLoc(unsigned TokNum, SourceLocation L) {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    getTrailingObjects<SourceLocation>()[TokNum] = L;\n  }\n\npublic:\n  /// This is the \"fully general\" constructor that allows representation of\n  /// strings formed from multiple concatenated tokens.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               const SourceLocation *Loc,\n                               unsigned NumConcatenated);\n\n  /// Simple constructor for string literals made from one token.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               SourceLocation Loc) {\n    return Create(Ctx, Str, Kind, Pascal, Ty, &Loc, 1);\n  }\n\n  /// Construct an empty string literal.\n  static StringLiteral *CreateEmpty(const ASTContext &Ctx,\n                                    unsigned NumConcatenated, unsigned Length,\n                                    unsigned CharByteWidth);\n\n  StringRef getString() const {\n    assert(getCharByteWidth() == 1 &&\n           \"This function is used in places that assume strings use char\");\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  /// Allow access to clients that need the byte representation, such as\n  /// ASTWriterStmt::VisitStringLiteral().\n  StringRef getBytes() const {\n    // FIXME: StringRef may not be the right type to use as a result for this.\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  void outputString(raw_ostream &OS) const;\n\n  uint32_t getCodeUnit(size_t i) const {\n    assert(i < getLength() && \"out of bounds access\");\n    switch (getCharByteWidth()) {\n    case 1:\n      return static_cast<unsigned char>(getStrDataAsChar()[i]);\n    case 2:\n      return getStrDataAsUInt16()[i];\n    case 4:\n      return getStrDataAsUInt32()[i];\n    }\n    llvm_unreachable(\"Unsupported character width!\");\n  }\n\n  unsigned getByteLength() const { return getCharByteWidth() * getLength(); }\n  unsigned getLength() const { return *getTrailingObjects<unsigned>(); }\n  unsigned getCharByteWidth() const { return StringLiteralBits.CharByteWidth; }\n\n  StringKind getKind() const {\n    return static_cast<StringKind>(StringLiteralBits.Kind);\n  }\n\n  bool isAscii() const { return getKind() == Ascii; }\n  bool isWide() const { return getKind() == Wide; }\n  bool isUTF8() const { return getKind() == UTF8; }\n  bool isUTF16() const { return getKind() == UTF16; }\n  bool isUTF32() const { return getKind() == UTF32; }\n  bool isPascal() const { return StringLiteralBits.IsPascal; }\n\n  bool containsNonAscii() const {\n    for (auto c : getString())\n      if (!isASCII(c))\n        return true;\n    return false;\n  }\n\n  bool containsNonAsciiOrNull() const {\n    for (auto c : getString())\n      if (!isASCII(c) || !c)\n        return true;\n    return false;\n  }\n\n  /// getNumConcatenated - Get the number of string literal tokens that were\n  /// concatenated in translation phase #6 to form this string literal.\n  unsigned getNumConcatenated() const {\n    return StringLiteralBits.NumConcatenated;\n  }\n\n  /// Get one of the string literal token.\n  SourceLocation getStrTokenLoc(unsigned TokNum) const {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    return getTrailingObjects<SourceLocation>()[TokNum];\n  }\n\n  /// getLocationOfByte - Return a source location that points to the specified\n  /// byte of this string literal.\n  ///\n  /// Strings are amazingly complex.  They can be formed from multiple tokens\n  /// and can have escape sequences in them in addition to the usual trigraph\n  /// and escaped newline business.  This routine handles this complexity.\n  ///\n  SourceLocation\n  getLocationOfByte(unsigned ByteNo, const SourceManager &SM,\n                    const LangOptions &Features, const TargetInfo &Target,\n                    unsigned *StartToken = nullptr,\n                    unsigned *StartTokenByteOffset = nullptr) const;\n\n  typedef const SourceLocation *tokloc_iterator;\n\n  tokloc_iterator tokloc_begin() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  tokloc_iterator tokloc_end() const {\n    return getTrailingObjects<SourceLocation>() + getNumConcatenated();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return *tokloc_begin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return *(tokloc_end() - 1); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StringLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// [C99 6.4.2.2] - A predefined identifier such as __func__.\nclass PredefinedExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PredefinedExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  // PredefinedExpr is optionally followed by a single trailing\n  // \"Stmt *\" for the predefined identifier. It is present if and only if\n  // hasFunctionName() is true and is always a \"StringLiteral *\".\n\npublic:\n  enum IdentKind {\n    Func,\n    Function,\n    LFunction, // Same as Function, but as wide string.\n    FuncDName,\n    FuncSig,\n    LFuncSig, // Same as FuncSig, but as as wide string\n    PrettyFunction,\n    /// The same as PrettyFunction, except that the\n    /// 'virtual' keyword is omitted for virtual member functions.\n    PrettyFunctionNoVirtual\n  };\n\nprivate:\n  PredefinedExpr(SourceLocation L, QualType FNTy, IdentKind IK,\n                 StringLiteral *SL);\n\n  explicit PredefinedExpr(EmptyShell Empty, bool HasFunctionName);\n\n  /// True if this PredefinedExpr has storage for a function name.\n  bool hasFunctionName() const { return PredefinedExprBits.HasFunctionName; }\n\n  void setFunctionName(StringLiteral *SL) {\n    assert(hasFunctionName() &&\n           \"This PredefinedExpr has no storage for a function name!\");\n    *getTrailingObjects<Stmt *>() = SL;\n  }\n\npublic:\n  /// Create a PredefinedExpr.\n  static PredefinedExpr *Create(const ASTContext &Ctx, SourceLocation L,\n                                QualType FNTy, IdentKind IK, StringLiteral *SL);\n\n  /// Create an empty PredefinedExpr.\n  static PredefinedExpr *CreateEmpty(const ASTContext &Ctx,\n                                     bool HasFunctionName);\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(PredefinedExprBits.Kind);\n  }\n\n  SourceLocation getLocation() const { return PredefinedExprBits.Loc; }\n  void setLocation(SourceLocation L) { PredefinedExprBits.Loc = L; }\n\n  StringLiteral *getFunctionName() {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  const StringLiteral *getFunctionName() const {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  static StringRef getIdentKindName(IdentKind IK);\n  StringRef getIdentKindName() const {\n    return getIdentKindName(getIdentKind());\n  }\n\n  static std::string ComputeName(IdentKind IK, const Decl *CurrentDecl);\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PredefinedExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n};\n\n/// ParenExpr - This represents a parethesized expression, e.g. \"(1)\".  This\n/// AST node is only formed if full location information is requested.\nclass ParenExpr : public Expr {\n  SourceLocation L, R;\n  Stmt *Val;\npublic:\n  ParenExpr(SourceLocation l, SourceLocation r, Expr *val)\n      : Expr(ParenExprClass, val->getType(), val->getValueKind(),\n             val->getObjectKind()),\n        L(l), R(r), Val(val) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty parenthesized expression.\n  explicit ParenExpr(EmptyShell Empty)\n    : Expr(ParenExprClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return L; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return R; }\n\n  /// Get the location of the left parentheses '('.\n  SourceLocation getLParen() const { return L; }\n  void setLParen(SourceLocation Loc) { L = Loc; }\n\n  /// Get the location of the right parentheses ')'.\n  SourceLocation getRParen() const { return R; }\n  void setRParen(SourceLocation Loc) { R = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// UnaryOperator - This represents the unary-expression's (except sizeof and\n/// alignof), the postinc/postdec operators from postfix-expression, and various\n/// extensions.\n///\n/// Notes on various nodes:\n///\n/// Real/Imag - These return the real/imag part of a complex operand.  If\n///   applied to a non-complex value, the former returns its operand and the\n///   later returns zero in the type of the operand.\n///\nclass UnaryOperator final\n    : public Expr,\n      private llvm::TrailingObjects<UnaryOperator, FPOptionsOverride> {\n  Stmt *Val;\n\n  size_t numTrailingObjects(OverloadToken<FPOptionsOverride>) const {\n    return UnaryOperatorBits.HasFPFeatures ? 1 : 0;\n  }\n\n  FPOptionsOverride &getTrailingFPFeatures() {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\n  const FPOptionsOverride &getTrailingFPFeatures() const {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\npublic:\n  typedef UnaryOperatorKind Opcode;\n\nprotected:\n  UnaryOperator(const ASTContext &Ctx, Expr *input, Opcode opc, QualType type,\n                ExprValueKind VK, ExprObjectKind OK, SourceLocation l,\n                bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  /// Build an empty unary operator.\n  explicit UnaryOperator(bool HasFPFeatures, EmptyShell Empty)\n      : Expr(UnaryOperatorClass, Empty) {\n    UnaryOperatorBits.Opc = UO_AddrOf;\n    UnaryOperatorBits.HasFPFeatures = HasFPFeatures;\n  }\n\npublic:\n  static UnaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static UnaryOperator *Create(const ASTContext &C, Expr *input, Opcode opc,\n                               QualType type, ExprValueKind VK,\n                               ExprObjectKind OK, SourceLocation l,\n                               bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(UnaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { UnaryOperatorBits.Opc = Opc; }\n\n  Expr *getSubExpr() const { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return UnaryOperatorBits.Loc; }\n  void setOperatorLoc(SourceLocation L) { UnaryOperatorBits.Loc = L; }\n\n  /// Returns true if the unary operator can cause an overflow. For instance,\n  ///   signed int i = INT_MAX; i++;\n  ///   signed char c = CHAR_MAX; c++;\n  /// Due to integer promotions, c++ is promoted to an int before the postfix\n  /// increment, and the result is an int that cannot overflow. However, i++\n  /// can overflow.\n  bool canOverflow() const { return UnaryOperatorBits.CanOverflow; }\n  void setCanOverflow(bool C) { UnaryOperatorBits.CanOverflow = C; }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\n  /// isPostfix - Return true if this is a postfix operation, like x++.\n  static bool isPostfix(Opcode Op) {\n    return Op == UO_PostInc || Op == UO_PostDec;\n  }\n\n  /// isPrefix - Return true if this is a prefix operation, like --x.\n  static bool isPrefix(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PreDec;\n  }\n\n  bool isPrefix() const { return isPrefix(getOpcode()); }\n  bool isPostfix() const { return isPostfix(getOpcode()); }\n\n  static bool isIncrementOp(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PostInc;\n  }\n  bool isIncrementOp() const {\n    return isIncrementOp(getOpcode());\n  }\n\n  static bool isDecrementOp(Opcode Op) {\n    return Op == UO_PreDec || Op == UO_PostDec;\n  }\n  bool isDecrementOp() const {\n    return isDecrementOp(getOpcode());\n  }\n\n  static bool isIncrementDecrementOp(Opcode Op) { return Op <= UO_PreDec; }\n  bool isIncrementDecrementOp() const {\n    return isIncrementDecrementOp(getOpcode());\n  }\n\n  static bool isArithmeticOp(Opcode Op) {\n    return Op >= UO_Plus && Op <= UO_LNot;\n  }\n  bool isArithmeticOp() const { return isArithmeticOp(getOpcode()); }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"sizeof\" or \"[pre]++\"\n  static StringRef getOpcodeStr(Opcode Op);\n\n  /// Retrieve the unary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO, bool Postfix);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given unary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isPostfix() ? Val->getBeginLoc() : getOperatorLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return isPostfix() ? getOperatorLoc() : Val->getEndLoc();\n  }\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryOperatorClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n\n  /// Is FPFeatures in Trailing Storage?\n  bool hasStoredFPFeatures() const { return UnaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    return getTrailingFPFeatures();\n  }\n\nprotected:\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) { getTrailingFPFeatures() = F; }\n\npublic:\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n  FPOptionsOverride getFPOptionsOverride() const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  friend TrailingObjects;\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Helper class for OffsetOfExpr.\n\n// __builtin_offsetof(type, identifier(.identifier|[expr])*)\nclass OffsetOfNode {\npublic:\n  /// The kind of offsetof node we have.\n  enum Kind {\n    /// An index into an array.\n    Array = 0x00,\n    /// A field.\n    Field = 0x01,\n    /// A field in a dependent type, known only by its name.\n    Identifier = 0x02,\n    /// An implicit indirection through a C++ base class, when the\n    /// field found is in a base class.\n    Base = 0x03\n  };\n\nprivate:\n  enum { MaskBits = 2, Mask = 0x03 };\n\n  /// The source range that covers this part of the designator.\n  SourceRange Range;\n\n  /// The data describing the designator, which comes in three\n  /// different forms, depending on the lower two bits.\n  ///   - An unsigned index into the array of Expr*'s stored after this node\n  ///     in memory, for [constant-expression] designators.\n  ///   - A FieldDecl*, for references to a known field.\n  ///   - An IdentifierInfo*, for references to a field with a given name\n  ///     when the class type is dependent.\n  ///   - A CXXBaseSpecifier*, for references that look at a field in a\n  ///     base class.\n  uintptr_t Data;\n\npublic:\n  /// Create an offsetof node that refers to an array element.\n  OffsetOfNode(SourceLocation LBracketLoc, unsigned Index,\n               SourceLocation RBracketLoc)\n      : Range(LBracketLoc, RBracketLoc), Data((Index << 2) | Array) {}\n\n  /// Create an offsetof node that refers to a field.\n  OffsetOfNode(SourceLocation DotLoc, FieldDecl *Field, SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Field) | OffsetOfNode::Field) {}\n\n  /// Create an offsetof node that refers to an identifier.\n  OffsetOfNode(SourceLocation DotLoc, IdentifierInfo *Name,\n               SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Name) | Identifier) {}\n\n  /// Create an offsetof node that refers into a C++ base class.\n  explicit OffsetOfNode(const CXXBaseSpecifier *Base)\n      : Range(), Data(reinterpret_cast<uintptr_t>(Base) | OffsetOfNode::Base) {}\n\n  /// Determine what kind of offsetof node this is.\n  Kind getKind() const { return static_cast<Kind>(Data & Mask); }\n\n  /// For an array element node, returns the index into the array\n  /// of expressions.\n  unsigned getArrayExprIndex() const {\n    assert(getKind() == Array);\n    return Data >> 2;\n  }\n\n  /// For a field offsetof node, returns the field.\n  FieldDecl *getField() const {\n    assert(getKind() == Field);\n    return reinterpret_cast<FieldDecl *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// For a field or identifier offsetof node, returns the name of\n  /// the field.\n  IdentifierInfo *getFieldName() const;\n\n  /// For a base class node, returns the base specifier.\n  CXXBaseSpecifier *getBase() const {\n    assert(getKind() == Base);\n    return reinterpret_cast<CXXBaseSpecifier *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// Retrieve the source range that covers this offsetof node.\n  ///\n  /// For an array element node, the source range contains the locations of\n  /// the square brackets. For a field or identifier node, the source range\n  /// contains the location of the period (if there is one) and the\n  /// identifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n};\n\n/// OffsetOfExpr - [C99 7.17] - This represents an expression of the form\n/// offsetof(record-type, member-designator). For example, given:\n/// @code\n/// struct S {\n///   float f;\n///   double d;\n/// };\n/// struct T {\n///   int i;\n///   struct S s[10];\n/// };\n/// @endcode\n/// we can represent and evaluate the expression @c offsetof(struct T, s[2].d).\n\nclass OffsetOfExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OffsetOfExpr, OffsetOfNode, Expr *> {\n  SourceLocation OperatorLoc, RParenLoc;\n  // Base type;\n  TypeSourceInfo *TSInfo;\n  // Number of sub-components (i.e. instances of OffsetOfNode).\n  unsigned NumComps;\n  // Number of sub-expressions (i.e. array subscript expressions).\n  unsigned NumExprs;\n\n  size_t numTrailingObjects(OverloadToken<OffsetOfNode>) const {\n    return NumComps;\n  }\n\n  OffsetOfExpr(const ASTContext &C, QualType type,\n               SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n               ArrayRef<OffsetOfNode> comps, ArrayRef<Expr*> exprs,\n               SourceLocation RParenLoc);\n\n  explicit OffsetOfExpr(unsigned numComps, unsigned numExprs)\n    : Expr(OffsetOfExprClass, EmptyShell()),\n      TSInfo(nullptr), NumComps(numComps), NumExprs(numExprs) {}\n\npublic:\n\n  static OffsetOfExpr *Create(const ASTContext &C, QualType type,\n                              SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n                              ArrayRef<OffsetOfNode> comps,\n                              ArrayRef<Expr*> exprs, SourceLocation RParenLoc);\n\n  static OffsetOfExpr *CreateEmpty(const ASTContext &C,\n                                   unsigned NumComps, unsigned NumExprs);\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n  void setOperatorLoc(SourceLocation L) { OperatorLoc = L; }\n\n  /// Return the location of the right parentheses.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation R) { RParenLoc = R; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TSInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tsi) {\n    TSInfo = tsi;\n  }\n\n  const OffsetOfNode &getComponent(unsigned Idx) const {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    return getTrailingObjects<OffsetOfNode>()[Idx];\n  }\n\n  void setComponent(unsigned Idx, OffsetOfNode ON) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<OffsetOfNode>()[Idx] = ON;\n  }\n\n  unsigned getNumComponents() const {\n    return NumComps;\n  }\n\n  Expr* getIndexExpr(unsigned Idx) {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  const Expr *getIndexExpr(unsigned Idx) const {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  void setIndexExpr(unsigned Idx, Expr* E) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<Expr *>()[Idx] = E;\n  }\n\n  unsigned getNumExpressions() const {\n    return NumExprs;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OffsetOfExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(begin, begin + NumExprs);\n  }\n  const_child_range children() const {\n    Stmt *const *begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(begin, begin + NumExprs);\n  }\n  friend TrailingObjects;\n};\n\n/// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)\n/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and\n/// vec_step (OpenCL 1.1 6.11.12).\nclass UnaryExprOrTypeTraitExpr : public Expr {\n  union {\n    TypeSourceInfo *Ty;\n    Stmt *Ex;\n  } Argument;\n  SourceLocation OpLoc, RParenLoc;\n\npublic:\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, TypeSourceInfo *TInfo,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp)\n      : Expr(UnaryExprOrTypeTraitExprClass, resultType, VK_RValue, OK_Ordinary),\n        OpLoc(op), RParenLoc(rp) {\n    assert(ExprKind <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = ExprKind;\n    assert(static_cast<unsigned>(ExprKind) ==\n               UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n    Argument.Ty = TInfo;\n    setDependence(computeDependence(this));\n  }\n\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, Expr *E,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp);\n\n  /// Construct an empty sizeof/alignof expression.\n  explicit UnaryExprOrTypeTraitExpr(EmptyShell Empty)\n    : Expr(UnaryExprOrTypeTraitExprClass, Empty) { }\n\n  UnaryExprOrTypeTrait getKind() const {\n    return static_cast<UnaryExprOrTypeTrait>(UnaryExprOrTypeTraitExprBits.Kind);\n  }\n  void setKind(UnaryExprOrTypeTrait K) {\n    assert(K <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = K;\n    assert(static_cast<unsigned>(K) == UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n  }\n\n  bool isArgumentType() const { return UnaryExprOrTypeTraitExprBits.IsType; }\n  QualType getArgumentType() const {\n    return getArgumentTypeInfo()->getType();\n  }\n  TypeSourceInfo *getArgumentTypeInfo() const {\n    assert(isArgumentType() && \"calling getArgumentType() when arg is expr\");\n    return Argument.Ty;\n  }\n  Expr *getArgumentExpr() {\n    assert(!isArgumentType() && \"calling getArgumentExpr() when arg is type\");\n    return static_cast<Expr*>(Argument.Ex);\n  }\n  const Expr *getArgumentExpr() const {\n    return const_cast<UnaryExprOrTypeTraitExpr*>(this)->getArgumentExpr();\n  }\n\n  void setArgument(Expr *E) {\n    Argument.Ex = E;\n    UnaryExprOrTypeTraitExprBits.IsType = false;\n  }\n  void setArgument(TypeSourceInfo *TInfo) {\n    Argument.Ty = TInfo;\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n  }\n\n  /// Gets the argument type, or the type of the argument expression, whichever\n  /// is appropriate.\n  QualType getTypeOfArgument() const {\n    return isArgumentType() ? getArgumentType() : getArgumentExpr()->getType();\n  }\n\n  SourceLocation getOperatorLoc() const { return OpLoc; }\n  void setOperatorLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryExprOrTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children();\n  const_child_range children() const;\n};\n\n//===----------------------------------------------------------------------===//\n// Postfix Operators.\n//===----------------------------------------------------------------------===//\n\n/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.\nclass ArraySubscriptExpr : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\n  bool lhsIsBase() const { return getRHS()->getType()->isIntegerType(); }\n\npublic:\n  ArraySubscriptExpr(Expr *lhs, Expr *rhs, QualType t, ExprValueKind VK,\n                     ExprObjectKind OK, SourceLocation rbracketloc)\n      : Expr(ArraySubscriptExprClass, t, VK, OK) {\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = rbracketloc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array subscript expression.\n  explicit ArraySubscriptExpr(EmptyShell Shell)\n    : Expr(ArraySubscriptExprClass, Shell) { }\n\n  /// An array access can be written A[4] or 4[A] (both are equivalent).\n  /// - getBase() and getIdx() always present the normalized view: A[4].\n  ///    In this case getBase() returns \"A\" and getIdx() returns \"4\".\n  /// - getLHS() and getRHS() present the syntactic view. e.g. for\n  ///    4[A] getLHS() returns \"4\".\n  /// Note: Because vector element access is also written A[4] we must\n  /// predicate the format conversion in getBase and getIdx only on the\n  /// the type of the RHS, as it is possible for the LHS to be a vector of\n  /// integer type\n  Expr *getLHS() { return cast<Expr>(SubExprs[LHS]); }\n  const Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n\n  Expr *getRHS() { return cast<Expr>(SubExprs[RHS]); }\n  const Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  Expr *getBase() { return lhsIsBase() ? getLHS() : getRHS(); }\n  const Expr *getBase() const { return lhsIsBase() ? getLHS() : getRHS(); }\n\n  Expr *getIdx() { return lhsIsBase() ? getRHS() : getLHS(); }\n  const Expr *getIdx() const { return lhsIsBase() ? getRHS() : getLHS(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArraySubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// MatrixSubscriptExpr - Matrix subscript expression for the MatrixType\n/// extension.\n/// MatrixSubscriptExpr can be either incomplete (only Base and RowIdx are set\n/// so far, the type is IncompleteMatrixIdx) or complete (Base, RowIdx and\n/// ColumnIdx refer to valid expressions). Incomplete matrix expressions only\n/// exist during the initial construction of the AST.\nclass MatrixSubscriptExpr : public Expr {\n  enum { BASE, ROW_IDX, COLUMN_IDX, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  MatrixSubscriptExpr(Expr *Base, Expr *RowIdx, Expr *ColumnIdx, QualType T,\n                      SourceLocation RBracketLoc)\n      : Expr(MatrixSubscriptExprClass, T, Base->getValueKind(),\n             OK_MatrixComponent) {\n    SubExprs[BASE] = Base;\n    SubExprs[ROW_IDX] = RowIdx;\n    SubExprs[COLUMN_IDX] = ColumnIdx;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = RBracketLoc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty matrix subscript expression.\n  explicit MatrixSubscriptExpr(EmptyShell Shell)\n      : Expr(MatrixSubscriptExprClass, Shell) {}\n\n  bool isIncomplete() const {\n    bool IsIncomplete = hasPlaceholderType(BuiltinType::IncompleteMatrixIdx);\n    assert((SubExprs[COLUMN_IDX] || IsIncomplete) &&\n           \"expressions without column index must be marked as incomplete\");\n    return IsIncomplete;\n  }\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  Expr *getRowIdx() { return cast<Expr>(SubExprs[ROW_IDX]); }\n  const Expr *getRowIdx() const { return cast<Expr>(SubExprs[ROW_IDX]); }\n  void setRowIdx(Expr *E) { SubExprs[ROW_IDX] = E; }\n\n  Expr *getColumnIdx() { return cast_or_null<Expr>(SubExprs[COLUMN_IDX]); }\n  const Expr *getColumnIdx() const {\n    assert(!isIncomplete() &&\n           \"cannot get the column index of an incomplete expression\");\n    return cast<Expr>(SubExprs[COLUMN_IDX]);\n  }\n  void setColumnIdx(Expr *E) { SubExprs[COLUMN_IDX] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MatrixSubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).\n/// CallExpr itself represents a normal function call, e.g., \"f(x, 2)\",\n/// while its subclasses may represent alternative syntax that (semantically)\n/// results in a function call. For example, CXXOperatorCallExpr is\n/// a subclass for overloaded operator calls that use operator syntax, e.g.,\n/// \"str1 + str2\" to resolve to a function call.\nclass CallExpr : public Expr {\n  enum { FN = 0, PREARGS_START = 1 };\n\n  /// The number of arguments in the call expression.\n  unsigned NumArgs;\n\n  /// The location of the right parenthese. This has a different meaning for\n  /// the derived classes of CallExpr.\n  SourceLocation RParenLoc;\n\n  // CallExpr store some data in trailing objects. However since CallExpr\n  // is used a base of other expression classes we cannot use\n  // llvm::TrailingObjects. Instead we manually perform the pointer arithmetic\n  // and casts.\n  //\n  // The trailing objects are in order:\n  //\n  // * A single \"Stmt *\" for the callee expression.\n  //\n  // * An array of getNumPreArgs() \"Stmt *\" for the pre-argument expressions.\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the argument expressions.\n  //\n  // * An optional of type FPOptionsOverride.\n  //\n  // Note that we store the offset in bytes from the this pointer to the start\n  // of the trailing objects. It would be perfectly possible to compute it\n  // based on the dynamic kind of the CallExpr. However 1.) we have plenty of\n  // space in the bit-fields of Stmt. 2.) It was benchmarked to be faster to\n  // compute this once and then load the offset from the bit-fields of Stmt,\n  // instead of re-computing the offset each time the trailing objects are\n  // accessed.\n\n  /// Return a pointer to the start of the trailing array of \"Stmt *\".\n  Stmt **getTrailingStmts() {\n    return reinterpret_cast<Stmt **>(reinterpret_cast<char *>(this) +\n                                     CallExprBits.OffsetToTrailingObjects);\n  }\n  Stmt *const *getTrailingStmts() const {\n    return const_cast<CallExpr *>(this)->getTrailingStmts();\n  }\n\n  /// Map a statement class to the appropriate offset in bytes from the\n  /// this pointer to the trailing objects.\n  static unsigned offsetToTrailingObjects(StmtClass SC);\n\n  unsigned getSizeOfTrailingStmts() const {\n    return (1 + getNumPreArgs() + getNumArgs()) * sizeof(Stmt *);\n  }\n\n  size_t getOffsetOfTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts();\n  }\n\npublic:\n  enum class ADLCallKind : bool { NotADL, UsesADL };\n  static constexpr ADLCallKind NotADL = ADLCallKind::NotADL;\n  static constexpr ADLCallKind UsesADL = ADLCallKind::UsesADL;\n\nprotected:\n  /// Build a call expression, assuming that appropriate storage has been\n  /// allocated for the trailing objects.\n  CallExpr(StmtClass SC, Expr *Fn, ArrayRef<Expr *> PreArgs,\n           ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n           SourceLocation RParenLoc, FPOptionsOverride FPFeatures,\n           unsigned MinNumArgs, ADLCallKind UsesADL);\n\n  /// Build an empty call expression, for deserialization.\n  CallExpr(StmtClass SC, unsigned NumPreArgs, unsigned NumArgs,\n           bool hasFPFeatures, EmptyShell Empty);\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used by the derived classes to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumPreArgs, unsigned NumArgs,\n                                        bool HasFPFeatures) {\n    return (1 + NumPreArgs + NumArgs) * sizeof(Stmt *) +\n           HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n\n  Stmt *getPreArg(unsigned I) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  const Stmt *getPreArg(unsigned I) const {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  void setPreArg(unsigned I, Stmt *PreArg) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    getTrailingStmts()[PREARGS_START + I] = PreArg;\n  }\n\n  unsigned getNumPreArgs() const { return CallExprBits.NumPreArgs; }\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + CallExprBits.OffsetToTrailingObjects +\n        getSizeOfTrailingStmts());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) +\n        CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts());\n  }\n\npublic:\n  /// Create a call expression.\n  /// \\param Fn     The callee expression,\n  /// \\param Args   The argument array,\n  /// \\param Ty     The type of the call expression (which is *not* the return\n  ///               type in general),\n  /// \\param VK     The value kind of the call expression (lvalue, rvalue, ...),\n  /// \\param RParenLoc  The location of the right parenthesis in the call\n  ///                   expression.\n  /// \\param FPFeatures Floating-point features associated with the call,\n  /// \\param MinNumArgs Specifies the minimum number of arguments. The actual\n  ///                   number of arguments will be the greater of Args.size()\n  ///                   and MinNumArgs. This is used in a few places to allocate\n  ///                   enough storage for the default arguments.\n  /// \\param UsesADL    Specifies whether the callee was found through\n  ///                   argument-dependent lookup.\n  ///\n  /// Note that you can use CreateTemporary if you need a temporary call\n  /// expression on the stack.\n  static CallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                          ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n                          SourceLocation RParenLoc,\n                          FPOptionsOverride FPFeatures, unsigned MinNumArgs = 0,\n                          ADLCallKind UsesADL = NotADL);\n\n  /// Create a temporary call expression with no arguments in the memory\n  /// pointed to by Mem. Mem must points to at least sizeof(CallExpr)\n  /// + sizeof(Stmt *) bytes of storage, aligned to alignof(CallExpr):\n  ///\n  /// \\code{.cpp}\n  ///   alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];\n  ///   CallExpr *TheCall = CallExpr::CreateTemporary(Buffer, etc);\n  /// \\endcode\n  static CallExpr *CreateTemporary(void *Mem, Expr *Fn, QualType Ty,\n                                   ExprValueKind VK, SourceLocation RParenLoc,\n                                   ADLCallKind UsesADL = NotADL);\n\n  /// Create an empty call expression, for deserialization.\n  static CallExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs,\n                               bool HasFPFeatures, EmptyShell Empty);\n\n  Expr *getCallee() { return cast<Expr>(getTrailingStmts()[FN]); }\n  const Expr *getCallee() const { return cast<Expr>(getTrailingStmts()[FN]); }\n  void setCallee(Expr *F) { getTrailingStmts()[FN] = F; }\n\n  ADLCallKind getADLCallKind() const {\n    return static_cast<ADLCallKind>(CallExprBits.UsesADL);\n  }\n  void setADLCallKind(ADLCallKind V = UsesADL) {\n    CallExprBits.UsesADL = static_cast<bool>(V);\n  }\n  bool usesADL() const { return getADLCallKind() == UsesADL; }\n\n  bool hasStoredFPFeatures() const { return CallExprBits.HasFPFeatures; }\n\n  Decl *getCalleeDecl() { return getCallee()->getReferencedDeclOfCallee(); }\n  const Decl *getCalleeDecl() const {\n    return getCallee()->getReferencedDeclOfCallee();\n  }\n\n  /// If the callee is a FunctionDecl, return it. Otherwise return null.\n  FunctionDecl *getDirectCallee() {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n  const FunctionDecl *getDirectCallee() const {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the call arguments.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingStmts() + PREARGS_START +\n                                     getNumPreArgs());\n  }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(\n        getTrailingStmts() + PREARGS_START + getNumPreArgs());\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// Reduce the number of arguments in this call expression. This is used for\n  /// example during error recovery to drop extra arguments. There is no way\n  /// to perform the opposite because: 1.) We don't track how much storage\n  /// we have for the argument array 2.) This would potentially require growing\n  /// the argument array, something we cannot support since the arguments are\n  /// stored in a trailing array.\n  void shrinkNumArgs(unsigned NewNumArgs) {\n    assert((NewNumArgs <= getNumArgs()) &&\n           \"shrinkNumArgs cannot increase the number of arguments!\");\n    NumArgs = NewNumArgs;\n  }\n\n  /// Bluntly set a new number of arguments without doing any checks whatsoever.\n  /// Only used during construction of a CallExpr in a few places in Sema.\n  /// FIXME: Find a way to remove it.\n  void setNumArgsUnsafe(unsigned NewNumArgs) { NumArgs = NewNumArgs; }\n\n  typedef ExprIterator arg_iterator;\n  typedef ConstExprIterator const_arg_iterator;\n  typedef llvm::iterator_range<arg_iterator> arg_range;\n  typedef llvm::iterator_range<const_arg_iterator> const_arg_range;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n\n  const_arg_iterator arg_begin() const {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  /// This method provides fast access to all the subexpressions of\n  /// a CallExpr without going through the slower virtual child_iterator\n  /// interface.  This provides efficient reverse iteration of the\n  /// subexpressions.  This is currently used for CFG construction.\n  ArrayRef<Stmt *> getRawSubExprs() {\n    return llvm::makeArrayRef(getTrailingStmts(),\n                              PREARGS_START + getNumPreArgs() + getNumArgs());\n  }\n\n  /// getNumCommas - Return the number of commas that must have been present in\n  /// this function call.\n  unsigned getNumCommas() const { return getNumArgs() ? getNumArgs() - 1 : 0; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPOptionsOverride in trailing storage. Used only by Serialization.\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(hasStoredFPFeatures());\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  /// getBuiltinCallee - If this is a call to a builtin, return the builtin ID\n  /// of the callee. If not, return 0.\n  unsigned getBuiltinCallee() const;\n\n  /// Returns \\c true if this is a call to a builtin which does not\n  /// evaluate side-effects within its arguments.\n  bool isUnevaluatedBuiltinCall(const ASTContext &Ctx) const;\n\n  /// getCallReturnType - Get the return type of the call expr. This is not\n  /// always the type of the expr itself, if the return type is a reference\n  /// type.\n  QualType getCallReturnType(const ASTContext &Ctx) const;\n\n  /// Returns the WarnUnusedResultAttr that is either declared on the called\n  /// function, or its return type declaration.\n  const Attr *getUnusedResultAttr(const ASTContext &Ctx) const;\n\n  /// Returns true if this call expression should warn on unused results.\n  bool hasUnusedResultAttr(const ASTContext &Ctx) const {\n    return getUnusedResultAttr(Ctx) != nullptr;\n  }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Return true if this is a call to __assume() or __builtin_assume() with\n  /// a non-value-dependent constant parameter evaluating as false.\n  bool isBuiltinAssumeFalse(const ASTContext &Ctx) const;\n\n  /// Used by Sema to implement MSVC-compatible delayed name lookup.\n  /// (Usually Exprs themselves should set dependence).\n  void markDependentForPostponedNameLookup() {\n    setDependence(getDependence() | ExprDependence::TypeValueInstantiation);\n  }\n\n  bool isCallToStdMove() const {\n    const FunctionDecl *FD = getDirectCallee();\n    return getNumArgs() == 1 && FD && FD->isInStdNamespace() &&\n           FD->getIdentifier() && FD->getIdentifier()->isStr(\"move\");\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCallExprConstant &&\n           T->getStmtClass() <= lastCallExprConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingStmts(), getTrailingStmts() + PREARGS_START +\n                                               getNumPreArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingStmts(),\n                             getTrailingStmts() + PREARGS_START +\n                                 getNumPreArgs() + getNumArgs());\n  }\n};\n\n/// Extra data stored in some MemberExpr objects.\nstruct MemberExprNameQualifier {\n  /// The nested-name-specifier that qualifies the name, including\n  /// source-location information.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The DeclAccessPair through which the MemberDecl was found due to\n  /// name qualifiers.\n  DeclAccessPair FoundDecl;\n};\n\n/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.\n///\nclass MemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<MemberExpr, MemberExprNameQualifier,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Base - the expression for the base pointer or structure references.  In\n  /// X.F, this is \"X\".\n  Stmt *Base;\n\n  /// MemberDecl - This is the decl being referenced by the field/member name.\n  /// In X.F, this is the decl referenced by F.\n  ValueDecl *MemberDecl;\n\n  /// MemberDNLoc - Provides source/type location info for the\n  /// declaration name embedded in MemberDecl.\n  DeclarationNameLoc MemberDNLoc;\n\n  /// MemberLoc - This is the location of the member name.\n  SourceLocation MemberLoc;\n\n  size_t numTrailingObjects(OverloadToken<MemberExprNameQualifier>) const {\n    return hasQualifierOrFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasQualifierOrFoundDecl() const {\n    return MemberExprBits.HasQualifierOrFoundDecl;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return MemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  MemberExpr(Expr *Base, bool IsArrow, SourceLocation OperatorLoc,\n             ValueDecl *MemberDecl, const DeclarationNameInfo &NameInfo,\n             QualType T, ExprValueKind VK, ExprObjectKind OK,\n             NonOdrUseReason NOUR);\n  MemberExpr(EmptyShell Empty)\n      : Expr(MemberExprClass, Empty), Base(), MemberDecl() {}\n\npublic:\n  static MemberExpr *Create(const ASTContext &C, Expr *Base, bool IsArrow,\n                            SourceLocation OperatorLoc,\n                            NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc, ValueDecl *MemberDecl,\n                            DeclAccessPair FoundDecl,\n                            DeclarationNameInfo MemberNameInfo,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            QualType T, ExprValueKind VK, ExprObjectKind OK,\n                            NonOdrUseReason NOUR);\n\n  /// Create an implicit MemberExpr, with no location, qualifier, template\n  /// arguments, and so on. Suitable only for non-static member access.\n  static MemberExpr *CreateImplicit(const ASTContext &C, Expr *Base,\n                                    bool IsArrow, ValueDecl *MemberDecl,\n                                    QualType T, ExprValueKind VK,\n                                    ExprObjectKind OK) {\n    return Create(C, Base, IsArrow, SourceLocation(), NestedNameSpecifierLoc(),\n                  SourceLocation(), MemberDecl,\n                  DeclAccessPair::make(MemberDecl, MemberDecl->getAccess()),\n                  DeclarationNameInfo(), nullptr, T, VK, OK, NOUR_None);\n  }\n\n  static MemberExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                 bool HasFoundDecl,\n                                 bool HasTemplateKWAndArgsInfo,\n                                 unsigned NumTemplateArgs);\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Retrieve the member declaration to which this expression refers.\n  ///\n  /// The returned declaration will be a FieldDecl or (in C++) a VarDecl (for\n  /// static data members), a CXXMethodDecl, or an EnumConstantDecl.\n  ValueDecl *getMemberDecl() const { return MemberDecl; }\n  void setMemberDecl(ValueDecl *D);\n\n  /// Retrieves the declaration found by lookup.\n  DeclAccessPair getFoundDecl() const {\n    if (!hasQualifierOrFoundDecl())\n      return DeclAccessPair::make(getMemberDecl(),\n                                  getMemberDecl()->getAccess());\n    return getTrailingObjects<MemberExprNameQualifier>()->FoundDecl;\n  }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return getQualifier() != nullptr; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name, with source-location\n  /// information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifierOrFoundDecl())\n      return NestedNameSpecifierLoc();\n    return getTrailingObjects<MemberExprNameQualifier>()->QualifierLoc;\n  }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// the member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether the member name was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Retrieve the member declaration name info.\n  DeclarationNameInfo getMemberNameInfo() const {\n    return DeclarationNameInfo(MemberDecl->getDeclName(),\n                               MemberLoc, MemberDNLoc);\n  }\n\n  SourceLocation getOperatorLoc() const { return MemberExprBits.OperatorLoc; }\n\n  bool isArrow() const { return MemberExprBits.IsArrow; }\n  void setArrow(bool A) { MemberExprBits.IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getMemberLoc() const { return MemberLoc; }\n  void setMemberLoc(SourceLocation L) { MemberLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return MemberLoc; }\n\n  /// Determine whether the base of this explicit is implicit.\n  bool isImplicitAccess() const {\n    return getBase() && getBase()->isImplicitCXXThis();\n  }\n\n  /// Returns true if this member expression refers to a method that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return MemberExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a method that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    MemberExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Returns true if virtual dispatch is performed.\n  /// If the member access is fully qualified, (i.e. X::f()), virtual\n  /// dispatching is not performed. In -fapple-kext mode qualified\n  /// calls to virtual method will still go through the vtable.\n  bool performsVirtualDispatch(const LangOptions &LO) const {\n    return LO.AppleKext || !hasQualifier();\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  /// This is only meaningful if the named member is a static member.\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(MemberExprBits.NonOdrUseReason);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MemberExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// CompoundLiteralExpr - [C99 6.5.2.5]\n///\nclass CompoundLiteralExpr : public Expr {\n  /// LParenLoc - If non-null, this is the location of the left paren in a\n  /// compound literal like \"(int){4}\".  This can be null if this is a\n  /// synthesized compound expression.\n  SourceLocation LParenLoc;\n\n  /// The type as written.  This can be an incomplete array type, in\n  /// which case the actual expression type will be different.\n  /// The int part of the pair stores whether this expr is file scope.\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfoAndScope;\n  Stmt *Init;\npublic:\n  CompoundLiteralExpr(SourceLocation lparenloc, TypeSourceInfo *tinfo,\n                      QualType T, ExprValueKind VK, Expr *init, bool fileScope)\n      : Expr(CompoundLiteralExprClass, T, VK, OK_Ordinary),\n        LParenLoc(lparenloc), TInfoAndScope(tinfo, fileScope), Init(init) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty compound literal.\n  explicit CompoundLiteralExpr(EmptyShell Empty)\n    : Expr(CompoundLiteralExprClass, Empty) { }\n\n  const Expr *getInitializer() const { return cast<Expr>(Init); }\n  Expr *getInitializer() { return cast<Expr>(Init); }\n  void setInitializer(Expr *E) { Init = E; }\n\n  bool isFileScope() const { return TInfoAndScope.getInt(); }\n  void setFileScope(bool FS) { TInfoAndScope.setInt(FS); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfoAndScope.getPointer();\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tinfo) {\n    TInfoAndScope.setPointer(tinfo);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    if (LParenLoc.isInvalid())\n      return Init->getBeginLoc();\n    return LParenLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    return Init->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundLiteralExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Init, &Init+1); }\n  const_child_range children() const {\n    return const_child_range(&Init, &Init + 1);\n  }\n};\n\n/// CastExpr - Base class for type casts, including both implicit\n/// casts (ImplicitCastExpr) and explicit casts that have some\n/// representation in the source code (ExplicitCastExpr's derived\n/// classes).\nclass CastExpr : public Expr {\n  Stmt *Op;\n\n  bool CastConsistency() const;\n\n  const CXXBaseSpecifier * const *path_buffer() const {\n    return const_cast<CastExpr*>(this)->path_buffer();\n  }\n  CXXBaseSpecifier **path_buffer();\n\n  friend class ASTStmtReader;\n\nprotected:\n  CastExpr(StmtClass SC, QualType ty, ExprValueKind VK, const CastKind kind,\n           Expr *op, unsigned BasePathSize, bool HasFPFeatures)\n      : Expr(SC, ty, VK, OK_Ordinary), Op(op) {\n    CastExprBits.Kind = kind;\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n    setDependence(computeDependence(this));\n    assert(CastConsistency());\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n  }\n\n  /// Construct an empty cast.\n  CastExpr(StmtClass SC, EmptyShell Empty, unsigned BasePathSize,\n           bool HasFPFeatures)\n      : Expr(SC, Empty) {\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n  }\n\n  /// Return a pointer to the trailing FPOptions.\n  /// \\pre hasStoredFPFeatures() == true\n  FPOptionsOverride *getTrailingFPFeatures();\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    return const_cast<CastExpr *>(this)->getTrailingFPFeatures();\n  }\n\npublic:\n  CastKind getCastKind() const { return (CastKind) CastExprBits.Kind; }\n  void setCastKind(CastKind K) { CastExprBits.Kind = K; }\n\n  static const char *getCastKindName(CastKind CK);\n  const char *getCastKindName() const { return getCastKindName(getCastKind()); }\n\n  Expr *getSubExpr() { return cast<Expr>(Op); }\n  const Expr *getSubExpr() const { return cast<Expr>(Op); }\n  void setSubExpr(Expr *E) { Op = E; }\n\n  /// Retrieve the cast subexpression as it was written in the source\n  /// code, looking through any implicit casts or other intermediate nodes\n  /// introduced by semantic analysis.\n  Expr *getSubExprAsWritten();\n  const Expr *getSubExprAsWritten() const {\n    return const_cast<CastExpr *>(this)->getSubExprAsWritten();\n  }\n\n  /// If this cast applies a user-defined conversion, retrieve the conversion\n  /// function that it invokes.\n  NamedDecl *getConversionFunction() const;\n\n  typedef CXXBaseSpecifier **path_iterator;\n  typedef const CXXBaseSpecifier *const *path_const_iterator;\n  bool path_empty() const { return path_size() == 0; }\n  unsigned path_size() const { return CastExprBits.BasePathSize; }\n  path_iterator path_begin() { return path_buffer(); }\n  path_iterator path_end() { return path_buffer() + path_size(); }\n  path_const_iterator path_begin() const { return path_buffer(); }\n  path_const_iterator path_end() const { return path_buffer() + path_size(); }\n\n  llvm::iterator_range<path_iterator> path() {\n    return llvm::make_range(path_begin(), path_end());\n  }\n  llvm::iterator_range<path_const_iterator> path() const {\n    return llvm::make_range(path_begin(), path_end());\n  }\n\n  const FieldDecl *getTargetUnionField() const {\n    assert(getCastKind() == CK_ToUnion);\n    return getTargetFieldForToUnionCast(getType(), getSubExpr()->getType());\n  }\n\n  bool hasStoredFPFeatures() const { return CastExprBits.HasFPFeatures; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n\n  // Get the FP features status of this operation. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  static const FieldDecl *getTargetFieldForToUnionCast(QualType unionType,\n                                                       QualType opType);\n  static const FieldDecl *getTargetFieldForToUnionCast(const RecordDecl *RD,\n                                                       QualType opType);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCastExprConstant &&\n           T->getStmtClass() <= lastCastExprConstant;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Op, &Op+1); }\n  const_child_range children() const { return const_child_range(&Op, &Op + 1); }\n};\n\n/// ImplicitCastExpr - Allows us to explicitly represent implicit type\n/// conversions, which have no direct representation in the original\n/// source code. For example: converting T[]->T*, void f()->void\n/// (*f)(), float->double, short->int, etc.\n///\n/// In C, implicit casts always produce rvalues. However, in C++, an\n/// implicit cast whose result is being bound to a reference will be\n/// an lvalue or xvalue. For example:\n///\n/// @code\n/// class Base { };\n/// class Derived : public Base { };\n/// Derived &&ref();\n/// void f(Derived d) {\n///   Base& b = d; // initializer is an ImplicitCastExpr\n///                // to an lvalue of type Base\n///   Base&& r = ref(); // initializer is an ImplicitCastExpr\n///                     // to an xvalue of type Base\n/// }\n/// @endcode\nclass ImplicitCastExpr final\n    : public CastExpr,\n      private llvm::TrailingObjects<ImplicitCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n\n  ImplicitCastExpr(QualType ty, CastKind kind, Expr *op,\n                   unsigned BasePathLength, FPOptionsOverride FPO,\n                   ExprValueKind VK)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, BasePathLength,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty implicit cast.\n  explicit ImplicitCastExpr(EmptyShell Shell, unsigned PathSize,\n                            bool HasFPFeatures)\n      : CastExpr(ImplicitCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  enum OnStack_t { OnStack };\n  ImplicitCastExpr(OnStack_t _, QualType ty, CastKind kind, Expr *op,\n                   ExprValueKind VK, FPOptionsOverride FPO)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, 0,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  bool isPartOfExplicitCast() const { return CastExprBits.PartOfExplicitCast; }\n  void setIsPartOfExplicitCast(bool PartOfExplicitCast) {\n    CastExprBits.PartOfExplicitCast = PartOfExplicitCast;\n  }\n\n  static ImplicitCastExpr *Create(const ASTContext &Context, QualType T,\n                                  CastKind Kind, Expr *Operand,\n                                  const CXXCastPath *BasePath,\n                                  ExprValueKind Cat, FPOptionsOverride FPO);\n\n  static ImplicitCastExpr *CreateEmpty(const ASTContext &Context,\n                                       unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// ExplicitCastExpr - An explicit cast written in the source\n/// code.\n///\n/// This class is effectively an abstract class, because it provides\n/// the basic representation of an explicitly-written cast without\n/// specifying which kind of cast (C cast, functional cast, static\n/// cast, etc.) was written; specific derived classes represent the\n/// particular style of cast and its location information.\n///\n/// Unlike implicit casts, explicit cast nodes have two different\n/// types: the type that was written into the source code, and the\n/// actual type of the expression as determined by semantic\n/// analysis. These types may differ slightly. For example, in C++ one\n/// can cast to a reference type, which indicates that the resulting\n/// expression will be an lvalue or xvalue. The reference type, however,\n/// will not be used as the type of the expression.\nclass ExplicitCastExpr : public CastExpr {\n  /// TInfo - Source type info for the (written) type\n  /// this expression is casting to.\n  TypeSourceInfo *TInfo;\n\nprotected:\n  ExplicitCastExpr(StmtClass SC, QualType exprTy, ExprValueKind VK,\n                   CastKind kind, Expr *op, unsigned PathSize,\n                   bool HasFPFeatures, TypeSourceInfo *writtenTy)\n      : CastExpr(SC, exprTy, VK, kind, op, PathSize, HasFPFeatures),\n        TInfo(writtenTy) {}\n\n  /// Construct an empty explicit cast.\n  ExplicitCastExpr(StmtClass SC, EmptyShell Shell, unsigned PathSize,\n                   bool HasFPFeatures)\n      : CastExpr(SC, Shell, PathSize, HasFPFeatures) {}\n\npublic:\n  /// getTypeInfoAsWritten - Returns the type source info for the type\n  /// that this expression is casting to.\n  TypeSourceInfo *getTypeInfoAsWritten() const { return TInfo; }\n  void setTypeInfoAsWritten(TypeSourceInfo *writtenTy) { TInfo = writtenTy; }\n\n  /// getTypeAsWritten - Returns the type that this expression is\n  /// casting to, as written in the source code.\n  QualType getTypeAsWritten() const { return TInfo->getType(); }\n\n  static bool classof(const Stmt *T) {\n     return T->getStmtClass() >= firstExplicitCastExprConstant &&\n            T->getStmtClass() <= lastExplicitCastExprConstant;\n  }\n};\n\n/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style\n/// cast in C++ (C++ [expr.cast]), which uses the syntax\n/// (Type)expr. For example: @c (int)f.\nclass CStyleCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CStyleCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LPLoc; // the location of the left paren\n  SourceLocation RPLoc; // the location of the right paren\n\n  CStyleCastExpr(QualType exprTy, ExprValueKind vk, CastKind kind, Expr *op,\n                 unsigned PathSize, FPOptionsOverride FPO,\n                 TypeSourceInfo *writtenTy, SourceLocation l, SourceLocation r)\n      : ExplicitCastExpr(CStyleCastExprClass, exprTy, vk, kind, op, PathSize,\n                         FPO.requiresTrailingStorage(), writtenTy),\n        LPLoc(l), RPLoc(r) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty C-style explicit cast.\n  explicit CStyleCastExpr(EmptyShell Shell, unsigned PathSize,\n                          bool HasFPFeatures)\n      : ExplicitCastExpr(CStyleCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  static CStyleCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind K,\n         Expr *Op, const CXXCastPath *BasePath, FPOptionsOverride FPO,\n         TypeSourceInfo *WrittenTy, SourceLocation L, SourceLocation R);\n\n  static CStyleCastExpr *CreateEmpty(const ASTContext &Context,\n                                     unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CStyleCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// A builtin binary operation expression such as \"x + y\" or \"x <= y\".\n///\n/// This expression node kind describes a builtin binary operation,\n/// such as \"x + y\" for integer values \"x\" and \"y\". The operands will\n/// already have been converted to appropriate types (e.g., by\n/// performing promotions or conversions).\n///\n/// In C++, where operators may be overloaded, a different kind of\n/// expression node (CXXOperatorCallExpr) is used to express the\n/// invocation of an overloaded operator with operator syntax. Within\n/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is\n/// used to store an expression \"x + y\" depends on the subexpressions\n/// for x and y. If neither x or y is type-dependent, and the \"+\"\n/// operator resolves to a built-in operation, BinaryOperator will be\n/// used to express the computation (x and y may still be\n/// value-dependent). If either x or y is type-dependent, or if the\n/// \"+\" resolves to an overloaded operator, CXXOperatorCallExpr will\n/// be used to express the computation.\nclass BinaryOperator : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  typedef BinaryOperatorKind Opcode;\n\nprotected:\n  size_t offsetOfTrailingStorage() const;\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + offsetOfTrailingStorage());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) + offsetOfTrailingStorage());\n  }\n\n  /// Build a binary operator, assuming that appropriate storage has been\n  /// allocated for the trailing objects when needed.\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures);\n\n  /// Construct an empty binary operator.\n  explicit BinaryOperator(EmptyShell Empty) : Expr(BinaryOperatorClass, Empty) {\n    BinaryOperatorBits.Opc = BO_Comma;\n  }\n\npublic:\n  static BinaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static BinaryOperator *Create(const ASTContext &C, Expr *lhs, Expr *rhs,\n                                Opcode opc, QualType ResTy, ExprValueKind VK,\n                                ExprObjectKind OK, SourceLocation opLoc,\n                                FPOptionsOverride FPFeatures);\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n  SourceLocation getOperatorLoc() const { return BinaryOperatorBits.OpLoc; }\n  void setOperatorLoc(SourceLocation L) { BinaryOperatorBits.OpLoc = L; }\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(BinaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { BinaryOperatorBits.Opc = Opc; }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"<<=\".\n  static StringRef getOpcodeStr(Opcode Op);\n\n  StringRef getOpcodeStr() const { return getOpcodeStr(getOpcode()); }\n\n  /// Retrieve the binary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given binary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  /// predicates to categorize the respective opcodes.\n  static bool isPtrMemOp(Opcode Opc) {\n    return Opc == BO_PtrMemD || Opc == BO_PtrMemI;\n  }\n  bool isPtrMemOp() const { return isPtrMemOp(getOpcode()); }\n\n  static bool isMultiplicativeOp(Opcode Opc) {\n    return Opc >= BO_Mul && Opc <= BO_Rem;\n  }\n  bool isMultiplicativeOp() const { return isMultiplicativeOp(getOpcode()); }\n  static bool isAdditiveOp(Opcode Opc) { return Opc == BO_Add || Opc==BO_Sub; }\n  bool isAdditiveOp() const { return isAdditiveOp(getOpcode()); }\n  static bool isShiftOp(Opcode Opc) { return Opc == BO_Shl || Opc == BO_Shr; }\n  bool isShiftOp() const { return isShiftOp(getOpcode()); }\n\n  static bool isBitwiseOp(Opcode Opc) { return Opc >= BO_And && Opc <= BO_Or; }\n  bool isBitwiseOp() const { return isBitwiseOp(getOpcode()); }\n\n  static bool isRelationalOp(Opcode Opc) { return Opc >= BO_LT && Opc<=BO_GE; }\n  bool isRelationalOp() const { return isRelationalOp(getOpcode()); }\n\n  static bool isEqualityOp(Opcode Opc) { return Opc == BO_EQ || Opc == BO_NE; }\n  bool isEqualityOp() const { return isEqualityOp(getOpcode()); }\n\n  static bool isComparisonOp(Opcode Opc) { return Opc >= BO_Cmp && Opc<=BO_NE; }\n  bool isComparisonOp() const { return isComparisonOp(getOpcode()); }\n\n  static bool isCommaOp(Opcode Opc) { return Opc == BO_Comma; }\n  bool isCommaOp() const { return isCommaOp(getOpcode()); }\n\n  static Opcode negateComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GE;\n    case BO_GT: return BO_LE;\n    case BO_LE: return BO_GT;\n    case BO_GE: return BO_LT;\n    case BO_EQ: return BO_NE;\n    case BO_NE: return BO_EQ;\n    }\n  }\n\n  static Opcode reverseComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GT;\n    case BO_GT: return BO_LT;\n    case BO_LE: return BO_GE;\n    case BO_GE: return BO_LE;\n    case BO_EQ:\n    case BO_NE:\n      return Opc;\n    }\n  }\n\n  static bool isLogicalOp(Opcode Opc) { return Opc == BO_LAnd || Opc==BO_LOr; }\n  bool isLogicalOp() const { return isLogicalOp(getOpcode()); }\n\n  static bool isAssignmentOp(Opcode Opc) {\n    return Opc >= BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isAssignmentOp() const { return isAssignmentOp(getOpcode()); }\n\n  static bool isCompoundAssignmentOp(Opcode Opc) {\n    return Opc > BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isCompoundAssignmentOp() const {\n    return isCompoundAssignmentOp(getOpcode());\n  }\n  static Opcode getOpForCompoundAssignment(Opcode Opc) {\n    assert(isCompoundAssignmentOp(Opc));\n    if (Opc >= BO_AndAssign)\n      return Opcode(unsigned(Opc) - BO_AndAssign + BO_And);\n    else\n      return Opcode(unsigned(Opc) - BO_MulAssign + BO_Mul);\n  }\n\n  static bool isShiftAssignOp(Opcode Opc) {\n    return Opc == BO_ShlAssign || Opc == BO_ShrAssign;\n  }\n  bool isShiftAssignOp() const {\n    return isShiftAssignOp(getOpcode());\n  }\n\n  // Return true if a binary operator using the specified opcode and operands\n  // would match the 'p = (i8*)nullptr + n' idiom for casting a pointer-sized\n  // integer to a pointer.\n  static bool isNullPointerArithmeticExtension(ASTContext &Ctx, Opcode Opc,\n                                               Expr *LHS, Expr *RHS);\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstBinaryOperatorConstant &&\n           S->getStmtClass() <= lastBinaryOperatorConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  /// Set and fetch the bit that shows whether FPFeatures needs to be\n  /// allocated in Trailing Storage\n  void setHasStoredFPFeatures(bool B) { BinaryOperatorBits.HasFPFeatures = B; }\n  bool hasStoredFPFeatures() const { return BinaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  // This is used in ASTImporter\n  FPOptionsOverride getFPFeatures(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\nprotected:\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures,\n                 bool dead2);\n\n  /// Construct an empty BinaryOperator, SC is CompoundAssignOperator.\n  BinaryOperator(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    BinaryOperatorBits.Opc = BO_MulAssign;\n  }\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(bool HasFPFeatures) {\n    return HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n};\n\n/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep\n/// track of the type the operation is performed in.  Due to the semantics of\n/// these operators, the operands are promoted, the arithmetic performed, an\n/// implicit conversion back to the result type done, then the assignment takes\n/// place.  This captures the intermediate type which the computation is done\n/// in.\nclass CompoundAssignOperator : public BinaryOperator {\n  QualType ComputationLHSType;\n  QualType ComputationResultType;\n\n  /// Construct an empty CompoundAssignOperator.\n  explicit CompoundAssignOperator(const ASTContext &C, EmptyShell Empty,\n                                  bool hasFPFeatures)\n      : BinaryOperator(CompoundAssignOperatorClass, Empty) {}\n\nprotected:\n  CompoundAssignOperator(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc,\n                         QualType ResType, ExprValueKind VK, ExprObjectKind OK,\n                         SourceLocation OpLoc, FPOptionsOverride FPFeatures,\n                         QualType CompLHSType, QualType CompResultType)\n      : BinaryOperator(C, lhs, rhs, opc, ResType, VK, OK, OpLoc, FPFeatures,\n                       true),\n        ComputationLHSType(CompLHSType), ComputationResultType(CompResultType) {\n    assert(isCompoundAssignmentOp() &&\n           \"Only should be used for compound assignments\");\n  }\n\npublic:\n  static CompoundAssignOperator *CreateEmpty(const ASTContext &C,\n                                             bool hasFPFeatures);\n\n  static CompoundAssignOperator *\n  Create(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc, QualType ResTy,\n         ExprValueKind VK, ExprObjectKind OK, SourceLocation opLoc,\n         FPOptionsOverride FPFeatures, QualType CompLHSType = QualType(),\n         QualType CompResultType = QualType());\n\n  // The two computation types are the type the LHS is converted\n  // to for the computation and the type of the result; the two are\n  // distinct in a few cases (specifically, int+=ptr and ptr-=ptr).\n  QualType getComputationLHSType() const { return ComputationLHSType; }\n  void setComputationLHSType(QualType T) { ComputationLHSType = T; }\n\n  QualType getComputationResultType() const { return ComputationResultType; }\n  void setComputationResultType(QualType T) { ComputationResultType = T; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == CompoundAssignOperatorClass;\n  }\n};\n\ninline size_t BinaryOperator::offsetOfTrailingStorage() const {\n  assert(BinaryOperatorBits.HasFPFeatures);\n  return isa<CompoundAssignOperator>(this) ? sizeof(CompoundAssignOperator)\n                                           : sizeof(BinaryOperator);\n}\n\n/// AbstractConditionalOperator - An abstract base class for\n/// ConditionalOperator and BinaryConditionalOperator.\nclass AbstractConditionalOperator : public Expr {\n  SourceLocation QuestionLoc, ColonLoc;\n  friend class ASTStmtReader;\n\nprotected:\n  AbstractConditionalOperator(StmtClass SC, QualType T, ExprValueKind VK,\n                              ExprObjectKind OK, SourceLocation qloc,\n                              SourceLocation cloc)\n      : Expr(SC, T, VK, OK), QuestionLoc(qloc), ColonLoc(cloc) {}\n\n  AbstractConditionalOperator(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) { }\n\npublic:\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const;\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const;\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const;\n\n  SourceLocation getQuestionLoc() const { return QuestionLoc; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass ||\n           T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n};\n\n/// ConditionalOperator - The ?: ternary operator.  The GNU \"missing\n/// middle\" extension is a BinaryConditionalOperator.\nclass ConditionalOperator : public AbstractConditionalOperator {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n\n  friend class ASTStmtReader;\npublic:\n  ConditionalOperator(Expr *cond, SourceLocation QLoc, Expr *lhs,\n                      SourceLocation CLoc, Expr *rhs, QualType t,\n                      ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(ConditionalOperatorClass, t, VK, OK, QLoc,\n                                    CLoc) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit ConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(ConditionalOperatorClass, Empty) { }\n\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const { return cast<Expr>(SubExprs[LHS]); }\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const { return cast<Expr>(SubExprs[RHS]); }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCond()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// BinaryConditionalOperator - The GNU extension to the conditional\n/// operator which allows the middle operand to be omitted.\n///\n/// This is a different expression kind on the assumption that almost\n/// every client ends up needing to know that these are different.\nclass BinaryConditionalOperator : public AbstractConditionalOperator {\n  enum { COMMON, COND, LHS, RHS, NUM_SUBEXPRS };\n\n  /// - the common condition/left-hand-side expression, which will be\n  ///   evaluated as the opaque value\n  /// - the condition, expressed in terms of the opaque value\n  /// - the left-hand-side, expressed in terms of the opaque value\n  /// - the right-hand-side\n  Stmt *SubExprs[NUM_SUBEXPRS];\n  OpaqueValueExpr *OpaqueValue;\n\n  friend class ASTStmtReader;\npublic:\n  BinaryConditionalOperator(Expr *common, OpaqueValueExpr *opaqueValue,\n                            Expr *cond, Expr *lhs, Expr *rhs,\n                            SourceLocation qloc, SourceLocation cloc,\n                            QualType t, ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(BinaryConditionalOperatorClass, t, VK, OK,\n                                    qloc, cloc),\n        OpaqueValue(opaqueValue) {\n    SubExprs[COMMON] = common;\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    assert(OpaqueValue->getSourceExpr() == common && \"Wrong opaque value\");\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit BinaryConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(BinaryConditionalOperatorClass, Empty) { }\n\n  /// getCommon - Return the common expression, written to the\n  ///   left of the condition.  The opaque value will be bound to the\n  ///   result of this expression.\n  Expr *getCommon() const { return cast<Expr>(SubExprs[COMMON]); }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  /// getCond - Return the condition expression; this is defined\n  ///   in terms of the opaque value.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  /// getTrueExpr - Return the subexpression which will be\n  ///   evaluated if the condition evaluates to true;  this is defined\n  ///   in terms of the opaque value.\n  Expr *getTrueExpr() const {\n    return cast<Expr>(SubExprs[LHS]);\n  }\n\n  /// getFalseExpr - Return the subexpression which will be\n  ///   evaluated if the condnition evaluates to false; this is\n  ///   defined in terms of the opaque value.\n  Expr *getFalseExpr() const {\n    return cast<Expr>(SubExprs[RHS]);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommon()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getFalseExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n};\n\ninline Expr *AbstractConditionalOperator::getCond() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getCond();\n  return cast<BinaryConditionalOperator>(this)->getCond();\n}\n\ninline Expr *AbstractConditionalOperator::getTrueExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getTrueExpr();\n  return cast<BinaryConditionalOperator>(this)->getTrueExpr();\n}\n\ninline Expr *AbstractConditionalOperator::getFalseExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getFalseExpr();\n  return cast<BinaryConditionalOperator>(this)->getFalseExpr();\n}\n\n/// AddrLabelExpr - The GNU address of label extension, representing &&label.\nclass AddrLabelExpr : public Expr {\n  SourceLocation AmpAmpLoc, LabelLoc;\n  LabelDecl *Label;\npublic:\n  AddrLabelExpr(SourceLocation AALoc, SourceLocation LLoc, LabelDecl *L,\n                QualType t)\n      : Expr(AddrLabelExprClass, t, VK_RValue, OK_Ordinary), AmpAmpLoc(AALoc),\n        LabelLoc(LLoc), Label(L) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty address of a label expression.\n  explicit AddrLabelExpr(EmptyShell Empty)\n    : Expr(AddrLabelExprClass, Empty) { }\n\n  SourceLocation getAmpAmpLoc() const { return AmpAmpLoc; }\n  void setAmpAmpLoc(SourceLocation L) { AmpAmpLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AmpAmpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LabelLoc; }\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *L) { Label = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AddrLabelExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// StmtExpr - This is the GNU Statement Expression extension: ({int X=4; X;}).\n/// The StmtExpr contains a single CompoundStmt node, which it evaluates and\n/// takes the value of the last subexpression.\n///\n/// A StmtExpr is always an r-value; values \"returned\" out of a\n/// StmtExpr will be copied.\nclass StmtExpr : public Expr {\n  Stmt *SubStmt;\n  SourceLocation LParenLoc, RParenLoc;\npublic:\n  StmtExpr(CompoundStmt *SubStmt, QualType T, SourceLocation LParenLoc,\n           SourceLocation RParenLoc, unsigned TemplateDepth)\n      : Expr(StmtExprClass, T, VK_RValue, OK_Ordinary), SubStmt(SubStmt),\n        LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this, TemplateDepth));\n    // FIXME: A templated statement expression should have an associated\n    // DeclContext so that nested declarations always have a dependent context.\n    StmtExprBits.TemplateDepth = TemplateDepth;\n  }\n\n  /// Build an empty statement expression.\n  explicit StmtExpr(EmptyShell Empty) : Expr(StmtExprClass, Empty) { }\n\n  CompoundStmt *getSubStmt() { return cast<CompoundStmt>(SubStmt); }\n  const CompoundStmt *getSubStmt() const { return cast<CompoundStmt>(SubStmt); }\n  void setSubStmt(CompoundStmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  unsigned getTemplateDepth() const { return StmtExprBits.TemplateDepth; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StmtExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt+1); }\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n/// ShuffleVectorExpr - clang-specific builtin-in function\n/// __builtin_shufflevector.\n/// This AST node represents a operator that does a constant\n/// shuffle, similar to LLVM's shufflevector instruction. It takes\n/// two vectors and a variable number of constant indices,\n/// and returns the appropriately shuffled vector.\nclass ShuffleVectorExpr : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  // SubExprs - the list of values passed to the __builtin_shufflevector\n  // function. The first two are vectors, and the rest are constant\n  // indices.  The number of values in this list is always\n  // 2+the number of indices in the vector type.\n  Stmt **SubExprs;\n  unsigned NumExprs;\n\npublic:\n  ShuffleVectorExpr(const ASTContext &C, ArrayRef<Expr*> args, QualType Type,\n                    SourceLocation BLoc, SourceLocation RP);\n\n  /// Build an empty vector-shuffle expression.\n  explicit ShuffleVectorExpr(EmptyShell Empty)\n    : Expr(ShuffleVectorExprClass, Empty), SubExprs(nullptr) { }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ShuffleVectorExprClass;\n  }\n\n  /// getNumSubExprs - Return the size of the SubExprs array.  This includes the\n  /// constant expression, the actual arguments passed in, and the function\n  /// pointers.\n  unsigned getNumSubExprs() const { return NumExprs; }\n\n  /// Retrieve the array of expressions.\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n\n  /// getExpr - Return the Expr at the specified index.\n  Expr *getExpr(unsigned Index) {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n  const Expr *getExpr(unsigned Index) const {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n\n  void setExprs(const ASTContext &C, ArrayRef<Expr *> Exprs);\n\n  llvm::APSInt getShuffleMaskIdx(const ASTContext &Ctx, unsigned N) const {\n    assert((N < NumExprs - 2) && \"Shuffle idx out of range!\");\n    return getExpr(N+2)->EvaluateKnownConstInt(Ctx);\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+NumExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + NumExprs);\n  }\n};\n\n/// ConvertVectorExpr - Clang builtin function __builtin_convertvector\n/// This AST node provides support for converting a vector type to another\n/// vector type of the same arity.\nclass ConvertVectorExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  TypeSourceInfo *TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit ConvertVectorExpr(EmptyShell Empty) : Expr(ConvertVectorExprClass, Empty) {}\n\npublic:\n  ConvertVectorExpr(Expr *SrcExpr, TypeSourceInfo *TI, QualType DstType,\n                    ExprValueKind VK, ExprObjectKind OK,\n                    SourceLocation BuiltinLoc, SourceLocation RParenLoc)\n      : Expr(ConvertVectorExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        TInfo(TI), BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getTypeSourceInfo - Return the destination type.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *ti) {\n    TInfo = ti;\n  }\n\n  /// getBuiltinLoc - Return the location of the __builtin_convertvector token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConvertVectorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// ChooseExpr - GNU builtin-in function __builtin_choose_expr.\n/// This AST node is similar to the conditional operator (?:) in C, with\n/// the following exceptions:\n/// - the test expression must be a integer constant expression.\n/// - the expression returned acts like the chosen subexpression in every\n///   visible way: the type is the same as that of the chosen subexpression,\n///   and all predicates (whether it's an l-value, whether it's an integer\n///   constant expression, etc.) return the same result as for the chosen\n///   sub-expression.\nclass ChooseExpr : public Expr {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n  SourceLocation BuiltinLoc, RParenLoc;\n  bool CondIsTrue;\npublic:\n  ChooseExpr(SourceLocation BLoc, Expr *cond, Expr *lhs, Expr *rhs, QualType t,\n             ExprValueKind VK, ExprObjectKind OK, SourceLocation RP,\n             bool condIsTrue)\n      : Expr(ChooseExprClass, t, VK, OK), BuiltinLoc(BLoc), RParenLoc(RP),\n        CondIsTrue(condIsTrue) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty __builtin_choose_expr.\n  explicit ChooseExpr(EmptyShell Empty) : Expr(ChooseExprClass, Empty) { }\n\n  /// isConditionTrue - Return whether the condition is true (i.e. not\n  /// equal to zero).\n  bool isConditionTrue() const {\n    assert(!isConditionDependent() &&\n           \"Dependent condition isn't true or false\");\n    return CondIsTrue;\n  }\n  void setIsConditionTrue(bool isTrue) { CondIsTrue = isTrue; }\n\n  bool isConditionDependent() const {\n    return getCond()->isTypeDependent() || getCond()->isValueDependent();\n  }\n\n  /// getChosenSubExpr - Return the subexpression chosen according to the\n  /// condition.\n  Expr *getChosenSubExpr() const {\n    return isConditionTrue() ? getLHS() : getRHS();\n  }\n\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n  void setCond(Expr *E) { SubExprs[COND] = E; }\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ChooseExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GNUNullExpr - Implements the GNU __null extension, which is a name\n/// for a null pointer constant that has integral type (e.g., int or\n/// long) and is the same size and alignment as a pointer. The __null\n/// extension is typically only used by system headers, which define\n/// NULL as __null in C++ rather than using 0 (which is an integer\n/// that may not match the size of a pointer).\nclass GNUNullExpr : public Expr {\n  /// TokenLoc - The location of the __null keyword.\n  SourceLocation TokenLoc;\n\npublic:\n  GNUNullExpr(QualType Ty, SourceLocation Loc)\n      : Expr(GNUNullExprClass, Ty, VK_RValue, OK_Ordinary), TokenLoc(Loc) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty GNU __null expression.\n  explicit GNUNullExpr(EmptyShell Empty) : Expr(GNUNullExprClass, Empty) { }\n\n  /// getTokenLocation - The location of the __null token.\n  SourceLocation getTokenLocation() const { return TokenLoc; }\n  void setTokenLocation(SourceLocation L) { TokenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TokenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TokenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GNUNullExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a call to the builtin function \\c __builtin_va_arg.\nclass VAArgExpr : public Expr {\n  Stmt *Val;\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\npublic:\n  VAArgExpr(SourceLocation BLoc, Expr *e, TypeSourceInfo *TInfo,\n            SourceLocation RPLoc, QualType t, bool IsMS)\n      : Expr(VAArgExprClass, t, VK_RValue, OK_Ordinary), Val(e),\n        TInfo(TInfo, IsMS), BuiltinLoc(BLoc), RParenLoc(RPLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty __builtin_va_arg expression.\n  explicit VAArgExpr(EmptyShell Empty)\n      : Expr(VAArgExprClass, Empty), Val(nullptr), TInfo(nullptr, false) {}\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// Returns whether this is really a Win64 ABI va_arg expression.\n  bool isMicrosoftABI() const { return TInfo.getInt(); }\n  void setIsMicrosoftABI(bool IsMS) { TInfo.setInt(IsMS); }\n\n  TypeSourceInfo *getWrittenTypeInfo() const { return TInfo.getPointer(); }\n  void setWrittenTypeInfo(TypeSourceInfo *TI) { TInfo.setPointer(TI); }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == VAArgExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// Represents a function call to one of __builtin_LINE(), __builtin_COLUMN(),\n/// __builtin_FUNCTION(), or __builtin_FILE().\nclass SourceLocExpr final : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n  DeclContext *ParentContext;\n\npublic:\n  enum IdentKind { Function, File, Line, Column };\n\n  SourceLocExpr(const ASTContext &Ctx, IdentKind Type, SourceLocation BLoc,\n                SourceLocation RParenLoc, DeclContext *Context);\n\n  /// Build an empty call expression.\n  explicit SourceLocExpr(EmptyShell Empty) : Expr(SourceLocExprClass, Empty) {}\n\n  /// Return the result of evaluating this SourceLocExpr in the specified\n  /// (and possibly null) default argument or initialization context.\n  APValue EvaluateInContext(const ASTContext &Ctx,\n                            const Expr *DefaultExpr) const;\n\n  /// Return a string representing the name of the specific builtin function.\n  StringRef getBuiltinStr() const;\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(SourceLocExprBits.Kind);\n  }\n\n  bool isStringType() const {\n    switch (getIdentKind()) {\n    case File:\n    case Function:\n      return true;\n    case Line:\n    case Column:\n      return false;\n    }\n    llvm_unreachable(\"unknown source location expression kind\");\n  }\n  bool isIntType() const LLVM_READONLY { return !isStringType(); }\n\n  /// If the SourceLocExpr has been resolved return the subexpression\n  /// representing the resolved value. Otherwise return null.\n  const DeclContext *getParentContext() const { return ParentContext; }\n  DeclContext *getParentContext() { return ParentContext; }\n\n  SourceLocation getLocation() const { return BuiltinLoc; }\n  SourceLocation getBeginLoc() const { return BuiltinLoc; }\n  SourceLocation getEndLoc() const { return RParenLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(child_iterator(), child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SourceLocExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// Describes an C or C++ initializer list.\n///\n/// InitListExpr describes an initializer list, which can be used to\n/// initialize objects of different types, including\n/// struct/class/union types, arrays, and vectors. For example:\n///\n/// @code\n/// struct foo x = { 1, { 2, 3 } };\n/// @endcode\n///\n/// Prior to semantic analysis, an initializer list will represent the\n/// initializer list as written by the user, but will have the\n/// placeholder type \"void\". This initializer list is called the\n/// syntactic form of the initializer, and may contain C99 designated\n/// initializers (represented as DesignatedInitExprs), initializations\n/// of subobject members without explicit braces, and so on. Clients\n/// interested in the original syntax of the initializer list should\n/// use the syntactic form of the initializer list.\n///\n/// After semantic analysis, the initializer list will represent the\n/// semantic form of the initializer, where the initializations of all\n/// subobjects are made explicit with nested InitListExpr nodes and\n/// C99 designators have been eliminated by placing the designated\n/// initializations into the subobject they initialize. Additionally,\n/// any \"holes\" in the initialization, where no initializer has been\n/// specified for a particular subobject, will be replaced with\n/// implicitly-generated ImplicitValueInitExpr expressions that\n/// value-initialize the subobjects. Note, however, that the\n/// initializer lists may still have fewer initializers than there are\n/// elements to initialize within the object.\n///\n/// After semantic analysis has completed, given an initializer list,\n/// method isSemanticForm() returns true if and only if this is the\n/// semantic form of the initializer list (note: the same AST node\n/// may at the same time be the syntactic form).\n/// Given the semantic form of the initializer list, one can retrieve\n/// the syntactic form of that initializer list (when different)\n/// using method getSyntacticForm(); the method returns null if applied\n/// to a initializer list which is already in syntactic form.\n/// Similarly, given the syntactic form (i.e., an initializer list such\n/// that isSemanticForm() returns false), one can retrieve the semantic\n/// form using method getSemanticForm().\n/// Since many initializer lists have the same syntactic and semantic forms,\n/// getSyntacticForm() may return NULL, indicating that the current\n/// semantic initializer list also serves as its syntactic form.\nclass InitListExpr : public Expr {\n  // FIXME: Eliminate this vector in favor of ASTContext allocation\n  typedef ASTVector<Stmt *> InitExprsTy;\n  InitExprsTy InitExprs;\n  SourceLocation LBraceLoc, RBraceLoc;\n\n  /// The alternative form of the initializer list (if it exists).\n  /// The int part of the pair stores whether this initializer list is\n  /// in semantic form. If not null, the pointer points to:\n  ///   - the syntactic form, if this is in semantic form;\n  ///   - the semantic form, if this is in syntactic form.\n  llvm::PointerIntPair<InitListExpr *, 1, bool> AltForm;\n\n  /// Either:\n  ///  If this initializer list initializes an array with more elements than\n  ///  there are initializers in the list, specifies an expression to be used\n  ///  for value initialization of the rest of the elements.\n  /// Or\n  ///  If this initializer list initializes a union, specifies which\n  ///  field within the union will be initialized.\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\npublic:\n  InitListExpr(const ASTContext &C, SourceLocation lbraceloc,\n               ArrayRef<Expr*> initExprs, SourceLocation rbraceloc);\n\n  /// Build an empty initializer list.\n  explicit InitListExpr(EmptyShell Empty)\n    : Expr(InitListExprClass, Empty), AltForm(nullptr, true) { }\n\n  unsigned getNumInits() const { return InitExprs.size(); }\n\n  /// Retrieve the set of initializers.\n  Expr **getInits() { return reinterpret_cast<Expr **>(InitExprs.data()); }\n\n  /// Retrieve the set of initializers.\n  Expr * const *getInits() const {\n    return reinterpret_cast<Expr * const *>(InitExprs.data());\n  }\n\n  ArrayRef<Expr *> inits() {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  ArrayRef<Expr *> inits() const {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  const Expr *getInit(unsigned Init) const {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  Expr *getInit(unsigned Init) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  void setInit(unsigned Init, Expr *expr) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    InitExprs[Init] = expr;\n\n    if (expr)\n      setDependence(getDependence() | expr->getDependence());\n  }\n\n  /// Mark the semantic form of the InitListExpr as error when the semantic\n  /// analysis fails.\n  void markError() {\n    assert(isSemanticForm());\n    setDependence(getDependence() | ExprDependence::ErrorDependent);\n  }\n\n  /// Reserve space for some number of initializers.\n  void reserveInits(const ASTContext &C, unsigned NumInits);\n\n  /// Specify the number of initializers\n  ///\n  /// If there are more than @p NumInits initializers, the remaining\n  /// initializers will be destroyed. If there are fewer than @p\n  /// NumInits initializers, NULL expressions will be added for the\n  /// unknown initializers.\n  void resizeInits(const ASTContext &Context, unsigned NumInits);\n\n  /// Updates the initializer at index @p Init with the new\n  /// expression @p expr, and returns the old expression at that\n  /// location.\n  ///\n  /// When @p Init is out of range for this initializer list, the\n  /// initializer list will be extended with NULL expressions to\n  /// accommodate the new entry.\n  Expr *updateInit(const ASTContext &C, unsigned Init, Expr *expr);\n\n  /// If this initializer list initializes an array with more elements\n  /// than there are initializers in the list, specifies an expression to be\n  /// used for value initialization of the rest of the elements.\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n  const Expr *getArrayFiller() const {\n    return const_cast<InitListExpr *>(this)->getArrayFiller();\n  }\n  void setArrayFiller(Expr *filler);\n\n  /// Return true if this is an array initializer and its array \"filler\"\n  /// has been set.\n  bool hasArrayFiller() const { return getArrayFiller(); }\n\n  /// If this initializes a union, specifies which field in the\n  /// union to initialize.\n  ///\n  /// Typically, this field is the first named field within the\n  /// union. However, a designated initializer can specify the\n  /// initialization of a different field within the union.\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return const_cast<InitListExpr *>(this)->getInitializedFieldInUnion();\n  }\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    assert((FD == nullptr\n            || getInitializedFieldInUnion() == nullptr\n            || getInitializedFieldInUnion() == FD)\n           && \"Only one field of a union may be initialized at a time!\");\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  // Explicit InitListExpr's originate from source code (and have valid source\n  // locations). Implicit InitListExpr's are created by the semantic analyzer.\n  // FIXME: This is wrong; InitListExprs created by semantic analysis have\n  // valid source locations too!\n  bool isExplicit() const {\n    return LBraceLoc.isValid() && RBraceLoc.isValid();\n  }\n\n  // Is this an initializer for an array of characters, initialized by a string\n  // literal or an @encode?\n  bool isStringLiteralInit() const;\n\n  /// Is this a transparent initializer list (that is, an InitListExpr that is\n  /// purely syntactic, and whose semantics are that of the sole contained\n  /// initializer)?\n  bool isTransparent() const;\n\n  /// Is this the zero initializer {0} in a language which considers it\n  /// idiomatic?\n  bool isIdiomaticZeroInitializer(const LangOptions &LangOpts) const;\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation Loc) { LBraceLoc = Loc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation Loc) { RBraceLoc = Loc; }\n\n  bool isSemanticForm() const { return AltForm.getInt(); }\n  InitListExpr *getSemanticForm() const {\n    return isSemanticForm() ? nullptr : AltForm.getPointer();\n  }\n  bool isSyntacticForm() const {\n    return !AltForm.getInt() || !AltForm.getPointer();\n  }\n  InitListExpr *getSyntacticForm() const {\n    return isSemanticForm() ? AltForm.getPointer() : nullptr;\n  }\n\n  void setSyntacticForm(InitListExpr *Init) {\n    AltForm.setPointer(Init);\n    AltForm.setInt(true);\n    Init->AltForm.setPointer(this);\n    Init->AltForm.setInt(false);\n  }\n\n  bool hadArrayRangeDesignator() const {\n    return InitListExprBits.HadArrayRangeDesignator != 0;\n  }\n  void sawArrayRangeDesignator(bool ARD = true) {\n    InitListExprBits.HadArrayRangeDesignator = ARD;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == InitListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    const_child_range CCR = const_cast<const InitListExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n\n  const_child_range children() const {\n    // FIXME: This does not include the array filler expression.\n    if (InitExprs.empty())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&InitExprs[0], &InitExprs[0] + InitExprs.size());\n  }\n\n  typedef InitExprsTy::iterator iterator;\n  typedef InitExprsTy::const_iterator const_iterator;\n  typedef InitExprsTy::reverse_iterator reverse_iterator;\n  typedef InitExprsTy::const_reverse_iterator const_reverse_iterator;\n\n  iterator begin() { return InitExprs.begin(); }\n  const_iterator begin() const { return InitExprs.begin(); }\n  iterator end() { return InitExprs.end(); }\n  const_iterator end() const { return InitExprs.end(); }\n  reverse_iterator rbegin() { return InitExprs.rbegin(); }\n  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }\n  reverse_iterator rend() { return InitExprs.rend(); }\n  const_reverse_iterator rend() const { return InitExprs.rend(); }\n\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents a C99 designated initializer expression.\n///\n/// A designated initializer expression (C99 6.7.8) contains one or\n/// more designators (which can be field designators, array\n/// designators, or GNU array-range designators) followed by an\n/// expression that initializes the field or element(s) that the\n/// designators refer to. For example, given:\n///\n/// @code\n/// struct point {\n///   double x;\n///   double y;\n/// };\n/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };\n/// @endcode\n///\n/// The InitListExpr contains three DesignatedInitExprs, the first of\n/// which covers @c [2].y=1.0. This DesignatedInitExpr will have two\n/// designators, one array designator for @c [2] followed by one field\n/// designator for @c .y. The initialization expression will be 1.0.\nclass DesignatedInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DesignatedInitExpr, Stmt *> {\npublic:\n  /// Forward declaration of the Designator class.\n  class Designator;\n\nprivate:\n  /// The location of the '=' or ':' prior to the actual initializer\n  /// expression.\n  SourceLocation EqualOrColonLoc;\n\n  /// Whether this designated initializer used the GNU deprecated\n  /// syntax rather than the C99 '=' syntax.\n  unsigned GNUSyntax : 1;\n\n  /// The number of designators in this initializer expression.\n  unsigned NumDesignators : 15;\n\n  /// The number of subexpressions of this initializer expression,\n  /// which contains both the initializer and any additional\n  /// expressions used by array and array-range designators.\n  unsigned NumSubExprs : 16;\n\n  /// The designators in this designated initialization\n  /// expression.\n  Designator *Designators;\n\n  DesignatedInitExpr(const ASTContext &C, QualType Ty,\n                     llvm::ArrayRef<Designator> Designators,\n                     SourceLocation EqualOrColonLoc, bool GNUSyntax,\n                     ArrayRef<Expr *> IndexExprs, Expr *Init);\n\n  explicit DesignatedInitExpr(unsigned NumSubExprs)\n    : Expr(DesignatedInitExprClass, EmptyShell()),\n      NumDesignators(0), NumSubExprs(NumSubExprs), Designators(nullptr) { }\n\npublic:\n  /// A field designator, e.g., \".x\".\n  struct FieldDesignator {\n    /// Refers to the field that is being initialized. The low bit\n    /// of this field determines whether this is actually a pointer\n    /// to an IdentifierInfo (if 1) or a FieldDecl (if 0). When\n    /// initially constructed, a field designator will store an\n    /// IdentifierInfo*. After semantic analysis has resolved that\n    /// name, the field designator will instead store a FieldDecl*.\n    uintptr_t NameOrField;\n\n    /// The location of the '.' in the designated initializer.\n    SourceLocation DotLoc;\n\n    /// The location of the field name in the designated initializer.\n    SourceLocation FieldLoc;\n  };\n\n  /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n  struct ArrayOrRangeDesignator {\n    /// Location of the first index expression within the designated\n    /// initializer expression's list of subexpressions.\n    unsigned Index;\n    /// The location of the '[' starting the array range designator.\n    SourceLocation LBracketLoc;\n    /// The location of the ellipsis separating the start and end\n    /// indices. Only valid for GNU array-range designators.\n    SourceLocation EllipsisLoc;\n    /// The location of the ']' terminating the array range designator.\n    SourceLocation RBracketLoc;\n  };\n\n  /// Represents a single C99 designator.\n  ///\n  /// @todo This class is infuriatingly similar to clang::Designator,\n  /// but minor differences (storing indices vs. storing pointers)\n  /// keep us from reusing it. Try harder, later, to rectify these\n  /// differences.\n  class Designator {\n    /// The kind of designator this describes.\n    enum {\n      FieldDesignator,\n      ArrayDesignator,\n      ArrayRangeDesignator\n    } Kind;\n\n    union {\n      /// A field designator, e.g., \".x\".\n      struct FieldDesignator Field;\n      /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n      struct ArrayOrRangeDesignator ArrayOrRange;\n    };\n    friend class DesignatedInitExpr;\n\n  public:\n    Designator() {}\n\n    /// Initializes a field designator.\n    Designator(const IdentifierInfo *FieldName, SourceLocation DotLoc,\n               SourceLocation FieldLoc)\n      : Kind(FieldDesignator) {\n      new (&Field) DesignatedInitExpr::FieldDesignator;\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FieldName) | 0x01;\n      Field.DotLoc = DotLoc;\n      Field.FieldLoc = FieldLoc;\n    }\n\n    /// Initializes an array designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation RBracketLoc)\n      : Kind(ArrayDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = SourceLocation();\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    /// Initializes a GNU array-range designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation EllipsisLoc, SourceLocation RBracketLoc)\n      : Kind(ArrayRangeDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = EllipsisLoc;\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    bool isFieldDesignator() const { return Kind == FieldDesignator; }\n    bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n    bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n    IdentifierInfo *getFieldName() const;\n\n    FieldDecl *getField() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      if (Field.NameOrField & 0x01)\n        return nullptr;\n      else\n        return reinterpret_cast<FieldDecl *>(Field.NameOrField);\n    }\n\n    void setField(FieldDecl *FD) {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FD);\n    }\n\n    SourceLocation getDotLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.DotLoc;\n    }\n\n    SourceLocation getFieldLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.FieldLoc;\n    }\n\n    SourceLocation getLBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.LBracketLoc;\n    }\n\n    SourceLocation getRBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.RBracketLoc;\n    }\n\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == ArrayRangeDesignator &&\n             \"Only valid on an array-range designator\");\n      return ArrayOrRange.EllipsisLoc;\n    }\n\n    unsigned getFirstExprIndex() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.Index;\n    }\n\n    SourceLocation getBeginLoc() const LLVM_READONLY {\n      if (Kind == FieldDesignator)\n        return getDotLoc().isInvalid()? getFieldLoc() : getDotLoc();\n      else\n        return getLBracketLoc();\n    }\n    SourceLocation getEndLoc() const LLVM_READONLY {\n      return Kind == FieldDesignator ? getFieldLoc() : getRBracketLoc();\n    }\n    SourceRange getSourceRange() const LLVM_READONLY {\n      return SourceRange(getBeginLoc(), getEndLoc());\n    }\n  };\n\n  static DesignatedInitExpr *Create(const ASTContext &C,\n                                    llvm::ArrayRef<Designator> Designators,\n                                    ArrayRef<Expr*> IndexExprs,\n                                    SourceLocation EqualOrColonLoc,\n                                    bool GNUSyntax, Expr *Init);\n\n  static DesignatedInitExpr *CreateEmpty(const ASTContext &C,\n                                         unsigned NumIndexExprs);\n\n  /// Returns the number of designators in this initializer.\n  unsigned size() const { return NumDesignators; }\n\n  // Iterator access to the designators.\n  llvm::MutableArrayRef<Designator> designators() {\n    return {Designators, NumDesignators};\n  }\n\n  llvm::ArrayRef<Designator> designators() const {\n    return {Designators, NumDesignators};\n  }\n\n  Designator *getDesignator(unsigned Idx) { return &designators()[Idx]; }\n  const Designator *getDesignator(unsigned Idx) const {\n    return &designators()[Idx];\n  }\n\n  void setDesignators(const ASTContext &C, const Designator *Desigs,\n                      unsigned NumDesigs);\n\n  Expr *getArrayIndex(const Designator &D) const;\n  Expr *getArrayRangeStart(const Designator &D) const;\n  Expr *getArrayRangeEnd(const Designator &D) const;\n\n  /// Retrieve the location of the '=' that precedes the\n  /// initializer value itself, if present.\n  SourceLocation getEqualOrColonLoc() const { return EqualOrColonLoc; }\n  void setEqualOrColonLoc(SourceLocation L) { EqualOrColonLoc = L; }\n\n  /// Whether this designated initializer should result in direct-initialization\n  /// of the designated subobject (eg, '{.foo{1, 2, 3}}').\n  bool isDirectInit() const { return EqualOrColonLoc.isInvalid(); }\n\n  /// Determines whether this designated initializer used the\n  /// deprecated GNU syntax for designated initializers.\n  bool usesGNUSyntax() const { return GNUSyntax; }\n  void setGNUSyntax(bool GNU) { GNUSyntax = GNU; }\n\n  /// Retrieve the initializer value.\n  Expr *getInit() const {\n    return cast<Expr>(*const_cast<DesignatedInitExpr*>(this)->child_begin());\n  }\n\n  void setInit(Expr *init) {\n    *child_begin() = init;\n  }\n\n  /// Retrieve the total number of subexpressions in this\n  /// designated initializer expression, including the actual\n  /// initialized value and any expressions that occur within array\n  /// and array-range designators.\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr *getSubExpr(unsigned Idx) const {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    return cast<Expr>(getTrailingObjects<Stmt *>()[Idx]);\n  }\n\n  void setSubExpr(unsigned Idx, Expr *E) {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    getTrailingObjects<Stmt *>()[Idx] = E;\n  }\n\n  /// Replaces the designator at index @p Idx with the series\n  /// of designators in [First, Last).\n  void ExpandDesignator(const ASTContext &C, unsigned Idx,\n                        const Designator *First, const Designator *Last);\n\n  SourceRange getDesignatorsSourceRange() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = getTrailingObjects<Stmt *>();\n    return child_range(begin, begin + NumSubExprs);\n  }\n  const_child_range children() const {\n    Stmt * const *begin = getTrailingObjects<Stmt *>();\n    return const_child_range(begin, begin + NumSubExprs);\n  }\n\n  friend TrailingObjects;\n};\n\n/// Represents a place-holder for an object not to be initialized by\n/// anything.\n///\n/// This only makes sense when it appears as part of an updater of a\n/// DesignatedInitUpdateExpr (see below). The base expression of a DIUE\n/// initializes a big object, and the NoInitExpr's mark the spots within the\n/// big object not to be overwritten by the updater.\n///\n/// \\see DesignatedInitUpdateExpr\nclass NoInitExpr : public Expr {\npublic:\n  explicit NoInitExpr(QualType ty)\n      : Expr(NoInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit NoInitExpr(EmptyShell Empty)\n    : Expr(NoInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NoInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n// In cases like:\n//   struct Q { int a, b, c; };\n//   Q *getQ();\n//   void foo() {\n//     struct A { Q q; } a = { *getQ(), .q.b = 3 };\n//   }\n//\n// We will have an InitListExpr for a, with type A, and then a\n// DesignatedInitUpdateExpr for \"a.q\" with type Q. The \"base\" for this DIUE\n// is the call expression *getQ(); the \"updater\" for the DIUE is \".q.b = 3\"\n//\nclass DesignatedInitUpdateExpr : public Expr {\n  // BaseAndUpdaterExprs[0] is the base expression;\n  // BaseAndUpdaterExprs[1] is an InitListExpr overwriting part of the base.\n  Stmt *BaseAndUpdaterExprs[2];\n\npublic:\n  DesignatedInitUpdateExpr(const ASTContext &C, SourceLocation lBraceLoc,\n                           Expr *baseExprs, SourceLocation rBraceLoc);\n\n  explicit DesignatedInitUpdateExpr(EmptyShell Empty)\n    : Expr(DesignatedInitUpdateExprClass, Empty) { }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitUpdateExprClass;\n  }\n\n  Expr *getBase() const { return cast<Expr>(BaseAndUpdaterExprs[0]); }\n  void setBase(Expr *Base) { BaseAndUpdaterExprs[0] = Base; }\n\n  InitListExpr *getUpdater() const {\n    return cast<InitListExpr>(BaseAndUpdaterExprs[1]);\n  }\n  void setUpdater(Expr *Updater) { BaseAndUpdaterExprs[1] = Updater; }\n\n  // Iterators\n  // children = the base and the updater\n  child_range children() {\n    return child_range(&BaseAndUpdaterExprs[0], &BaseAndUpdaterExprs[0] + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(&BaseAndUpdaterExprs[0],\n                             &BaseAndUpdaterExprs[0] + 2);\n  }\n};\n\n/// Represents a loop initializing the elements of an array.\n///\n/// The need to initialize the elements of an array occurs in a number of\n/// contexts:\n///\n///  * in the implicit copy/move constructor for a class with an array member\n///  * when a lambda-expression captures an array by value\n///  * when a decomposition declaration decomposes an array\n///\n/// There are two subexpressions: a common expression (the source array)\n/// that is evaluated once up-front, and a per-element initializer that\n/// runs once for each array element.\n///\n/// Within the per-element initializer, the common expression may be referenced\n/// via an OpaqueValueExpr, and the current index may be obtained via an\n/// ArrayInitIndexExpr.\nclass ArrayInitLoopExpr : public Expr {\n  Stmt *SubExprs[2];\n\n  explicit ArrayInitLoopExpr(EmptyShell Empty)\n      : Expr(ArrayInitLoopExprClass, Empty), SubExprs{} {}\n\npublic:\n  explicit ArrayInitLoopExpr(QualType T, Expr *CommonInit, Expr *ElementInit)\n      : Expr(ArrayInitLoopExprClass, T, VK_RValue, OK_Ordinary),\n        SubExprs{CommonInit, ElementInit} {\n    setDependence(computeDependence(this));\n  }\n\n  /// Get the common subexpression shared by all initializations (the source\n  /// array).\n  OpaqueValueExpr *getCommonExpr() const {\n    return cast<OpaqueValueExpr>(SubExprs[0]);\n  }\n\n  /// Get the initializer to use for each array element.\n  Expr *getSubExpr() const { return cast<Expr>(SubExprs[1]); }\n\n  llvm::APInt getArraySize() const {\n    return cast<ConstantArrayType>(getType()->castAsArrayTypeUnsafe())\n        ->getSize();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitLoopExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommonExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCommonExpr()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents the index of the current element of an array being\n/// initialized by an ArrayInitLoopExpr. This can only appear within the\n/// subexpression of an ArrayInitLoopExpr.\nclass ArrayInitIndexExpr : public Expr {\n  explicit ArrayInitIndexExpr(EmptyShell Empty)\n      : Expr(ArrayInitIndexExprClass, Empty) {}\n\npublic:\n  explicit ArrayInitIndexExpr(QualType T)\n      : Expr(ArrayInitIndexExprClass, T, VK_RValue, OK_Ordinary) {\n    setDependence(ExprDependence::None);\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitIndexExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n};\n\n/// Represents an implicitly-generated value initialization of\n/// an object of a given type.\n///\n/// Implicit value initializations occur within semantic initializer\n/// list expressions (InitListExpr) as placeholders for subobject\n/// initializations not explicitly specified by the user.\n///\n/// \\see InitListExpr\nclass ImplicitValueInitExpr : public Expr {\npublic:\n  explicit ImplicitValueInitExpr(QualType ty)\n      : Expr(ImplicitValueInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty implicit value initialization.\n  explicit ImplicitValueInitExpr(EmptyShell Empty)\n    : Expr(ImplicitValueInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitValueInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass ParenListExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ParenListExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the left and right parentheses.\n  SourceLocation LParenLoc, RParenLoc;\n\n  /// Build a paren list.\n  ParenListExpr(SourceLocation LParenLoc, ArrayRef<Expr *> Exprs,\n                SourceLocation RParenLoc);\n\n  /// Build an empty paren list.\n  ParenListExpr(EmptyShell Empty, unsigned NumExprs);\n\npublic:\n  /// Create a paren list.\n  static ParenListExpr *Create(const ASTContext &Ctx, SourceLocation LParenLoc,\n                               ArrayRef<Expr *> Exprs,\n                               SourceLocation RParenLoc);\n\n  /// Create an empty paren list.\n  static ParenListExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumExprs);\n\n  /// Return the number of expressions in this paren list.\n  unsigned getNumExprs() const { return ParenListExprBits.NumExprs; }\n\n  Expr *getExpr(unsigned Init) {\n    assert(Init < getNumExprs() && \"Initializer access out of range!\");\n    return getExprs()[Init];\n  }\n\n  const Expr *getExpr(unsigned Init) const {\n    return const_cast<ParenListExpr *>(this)->getExpr(Init);\n  }\n\n  Expr **getExprs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>());\n  }\n\n  ArrayRef<Expr *> exprs() {\n    return llvm::makeArrayRef(getExprs(), getNumExprs());\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getLParenLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n};\n\n/// Represents a C11 generic selection.\n///\n/// A generic selection (C11 6.5.1.1) contains an unevaluated controlling\n/// expression, followed by one or more generic associations.  Each generic\n/// association specifies a type name and an expression, or \"default\" and an\n/// expression (in which case it is known as a default generic association).\n/// The type and value of the generic selection are identical to those of its\n/// result expression, which is defined as the expression in the generic\n/// association with a type name that is compatible with the type of the\n/// controlling expression, or the expression in the default generic association\n/// if no types are compatible.  For example:\n///\n/// @code\n/// _Generic(X, double: 1, float: 2, default: 3)\n/// @endcode\n///\n/// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f\n/// or 3 if \"hello\".\n///\n/// As an extension, generic selections are allowed in C++, where the following\n/// additional semantics apply:\n///\n/// Any generic selection whose controlling expression is type-dependent or\n/// which names a dependent type in its association list is result-dependent,\n/// which means that the choice of result expression is dependent.\n/// Result-dependent generic associations are both type- and value-dependent.\nclass GenericSelectionExpr final\n    : public Expr,\n      private llvm::TrailingObjects<GenericSelectionExpr, Stmt *,\n                                    TypeSourceInfo *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The number of association expressions and the index of the result\n  /// expression in the case where the generic selection expression is not\n  /// result-dependent. The result index is equal to ResultDependentIndex\n  /// if and only if the generic selection expression is result-dependent.\n  unsigned NumAssocs, ResultIndex;\n  enum : unsigned {\n    ResultDependentIndex = std::numeric_limits<unsigned>::max(),\n    ControllingIndex = 0,\n    AssocExprStartIndex = 1\n  };\n\n  /// The location of the \"default\" and of the right parenthesis.\n  SourceLocation DefaultLoc, RParenLoc;\n\n  // GenericSelectionExpr is followed by several trailing objects.\n  // They are (in order):\n  //\n  // * A single Stmt * for the controlling expression.\n  // * An array of getNumAssocs() Stmt * for the association expressions.\n  // * An array of getNumAssocs() TypeSourceInfo *, one for each of the\n  //   association expressions.\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    // Add one to account for the controlling expression; the remainder\n    // are the associated expressions.\n    return 1 + getNumAssocs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumAssocs();\n  }\n\n  template <bool Const> class AssociationIteratorTy;\n  /// Bundle together an association expression and its TypeSourceInfo.\n  /// The Const template parameter is for the const and non-const versions\n  /// of AssociationTy.\n  template <bool Const> class AssociationTy {\n    friend class GenericSelectionExpr;\n    template <bool OtherConst> friend class AssociationIteratorTy;\n    using ExprPtrTy = std::conditional_t<Const, const Expr *, Expr *>;\n    using TSIPtrTy =\n        std::conditional_t<Const, const TypeSourceInfo *, TypeSourceInfo *>;\n    ExprPtrTy E;\n    TSIPtrTy TSI;\n    bool Selected;\n    AssociationTy(ExprPtrTy E, TSIPtrTy TSI, bool Selected)\n        : E(E), TSI(TSI), Selected(Selected) {}\n\n  public:\n    ExprPtrTy getAssociationExpr() const { return E; }\n    TSIPtrTy getTypeSourceInfo() const { return TSI; }\n    QualType getType() const { return TSI ? TSI->getType() : QualType(); }\n    bool isSelected() const { return Selected; }\n    AssociationTy *operator->() { return this; }\n    const AssociationTy *operator->() const { return this; }\n  }; // class AssociationTy\n\n  /// Iterator over const and non-const Association objects. The Association\n  /// objects are created on the fly when the iterator is dereferenced.\n  /// This abstract over how exactly the association expressions and the\n  /// corresponding TypeSourceInfo * are stored.\n  template <bool Const>\n  class AssociationIteratorTy\n      : public llvm::iterator_facade_base<\n            AssociationIteratorTy<Const>, std::input_iterator_tag,\n            AssociationTy<Const>, std::ptrdiff_t, AssociationTy<Const>,\n            AssociationTy<Const>> {\n    friend class GenericSelectionExpr;\n    // FIXME: This iterator could conceptually be a random access iterator, and\n    // it would be nice if we could strengthen the iterator category someday.\n    // However this iterator does not satisfy two requirements of forward\n    // iterators:\n    // a) reference = T& or reference = const T&\n    // b) If It1 and It2 are both dereferenceable, then It1 == It2 if and only\n    //    if *It1 and *It2 are bound to the same objects.\n    // An alternative design approach was discussed during review;\n    // store an Association object inside the iterator, and return a reference\n    // to it when dereferenced. This idea was discarded beacuse of nasty\n    // lifetime issues:\n    //    AssociationIterator It = ...;\n    //    const Association &Assoc = *It++; // Oops, Assoc is dangling.\n    using BaseTy = typename AssociationIteratorTy::iterator_facade_base;\n    using StmtPtrPtrTy =\n        std::conditional_t<Const, const Stmt *const *, Stmt **>;\n    using TSIPtrPtrTy = std::conditional_t<Const, const TypeSourceInfo *const *,\n                                           TypeSourceInfo **>;\n    StmtPtrPtrTy E; // = nullptr; FIXME: Once support for gcc 4.8 is dropped.\n    TSIPtrPtrTy TSI; // Kept in sync with E.\n    unsigned Offset = 0, SelectedOffset = 0;\n    AssociationIteratorTy(StmtPtrPtrTy E, TSIPtrPtrTy TSI, unsigned Offset,\n                          unsigned SelectedOffset)\n        : E(E), TSI(TSI), Offset(Offset), SelectedOffset(SelectedOffset) {}\n\n  public:\n    AssociationIteratorTy() : E(nullptr), TSI(nullptr) {}\n    typename BaseTy::reference operator*() const {\n      return AssociationTy<Const>(cast<Expr>(*E), *TSI,\n                                  Offset == SelectedOffset);\n    }\n    typename BaseTy::pointer operator->() const { return **this; }\n    using BaseTy::operator++;\n    AssociationIteratorTy &operator++() {\n      ++E;\n      ++TSI;\n      ++Offset;\n      return *this;\n    }\n    bool operator==(AssociationIteratorTy Other) const { return E == Other.E; }\n  }; // class AssociationIterator\n\n  /// Build a non-result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack,\n                       unsigned ResultIndex);\n\n  /// Build a result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack);\n\n  /// Build an empty generic selection expression for deserialization.\n  explicit GenericSelectionExpr(EmptyShell Empty, unsigned NumAssocs);\n\npublic:\n  /// Create a non-result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack,\n         unsigned ResultIndex);\n\n  /// Create a result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack);\n\n  /// Create an empty generic selection expression for deserialization.\n  static GenericSelectionExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumAssocs);\n\n  using Association = AssociationTy<false>;\n  using ConstAssociation = AssociationTy<true>;\n  using AssociationIterator = AssociationIteratorTy<false>;\n  using ConstAssociationIterator = AssociationIteratorTy<true>;\n  using association_range = llvm::iterator_range<AssociationIterator>;\n  using const_association_range =\n      llvm::iterator_range<ConstAssociationIterator>;\n\n  /// The number of association expressions.\n  unsigned getNumAssocs() const { return NumAssocs; }\n\n  /// The zero-based index of the result expression's generic association in\n  /// the generic selection's association list.  Defined only if the\n  /// generic selection is not result-dependent.\n  unsigned getResultIndex() const {\n    assert(!isResultDependent() &&\n           \"Generic selection is result-dependent but getResultIndex called!\");\n    return ResultIndex;\n  }\n\n  /// Whether this generic selection is result-dependent.\n  bool isResultDependent() const { return ResultIndex == ResultDependentIndex; }\n\n  /// Return the controlling expression of this generic selection expression.\n  Expr *getControllingExpr() {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n  const Expr *getControllingExpr() const {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n\n  /// Return the result expression of this controlling expression. Defined if\n  /// and only if the generic selection expression is not result-dependent.\n  Expr *getResultExpr() {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n  const Expr *getResultExpr() const {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n\n  ArrayRef<Expr *> getAssocExprs() const {\n    return {reinterpret_cast<Expr *const *>(getTrailingObjects<Stmt *>() +\n                                            AssocExprStartIndex),\n            NumAssocs};\n  }\n  ArrayRef<TypeSourceInfo *> getAssocTypeSourceInfos() const {\n    return {getTrailingObjects<TypeSourceInfo *>(), NumAssocs};\n  }\n\n  /// Return the Ith association expression with its TypeSourceInfo,\n  /// bundled together in GenericSelectionExpr::(Const)Association.\n  Association getAssociation(unsigned I) {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return Association(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n  ConstAssociation getAssociation(unsigned I) const {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return ConstAssociation(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n\n  association_range associations() {\n    AssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                  AssocExprStartIndex,\n                              getTrailingObjects<TypeSourceInfo *>(),\n                              /*Offset=*/0, ResultIndex);\n    AssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                            /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  const_association_range associations() const {\n    ConstAssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                       AssocExprStartIndex,\n                                   getTrailingObjects<TypeSourceInfo *>(),\n                                   /*Offset=*/0, ResultIndex);\n    ConstAssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                                 /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  SourceLocation getGenericLoc() const {\n    return GenericSelectionExprBits.GenericLoc;\n  }\n  SourceLocation getDefaultLoc() const { return DefaultLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getGenericLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GenericSelectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Clang Extensions\n//===----------------------------------------------------------------------===//\n\n/// ExtVectorElementExpr - This represents access to specific elements of a\n/// vector, and may occur on the left hand side or right hand side.  For example\n/// the following is legal:  \"V.xy = V.zw\" if V is a 4 element extended vector.\n///\n/// Note that the base may have either vector or pointer to vector type, just\n/// like a struct field reference.\n///\nclass ExtVectorElementExpr : public Expr {\n  Stmt *Base;\n  IdentifierInfo *Accessor;\n  SourceLocation AccessorLoc;\npublic:\n  ExtVectorElementExpr(QualType ty, ExprValueKind VK, Expr *base,\n                       IdentifierInfo &accessor, SourceLocation loc)\n      : Expr(ExtVectorElementExprClass, ty, VK,\n             (VK == VK_RValue ? OK_Ordinary : OK_VectorComponent)),\n        Base(base), Accessor(&accessor), AccessorLoc(loc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty vector element expression.\n  explicit ExtVectorElementExpr(EmptyShell Empty)\n    : Expr(ExtVectorElementExprClass, Empty) { }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr *E) { Base = E; }\n\n  IdentifierInfo &getAccessor() const { return *Accessor; }\n  void setAccessor(IdentifierInfo *II) { Accessor = II; }\n\n  SourceLocation getAccessorLoc() const { return AccessorLoc; }\n  void setAccessorLoc(SourceLocation L) { AccessorLoc = L; }\n\n  /// getNumElements - Get the number of components being selected.\n  unsigned getNumElements() const;\n\n  /// containsDuplicateElements - Return true if any element access is\n  /// repeated.\n  bool containsDuplicateElements() const;\n\n  /// getEncodedElementAccess - Encode the elements accessed into an llvm\n  /// aggregate Constant of ConstantInt(s).\n  void getEncodedElementAccess(SmallVectorImpl<uint32_t> &Elts) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return AccessorLoc; }\n\n  /// isArrow - Return true if the base expression is a pointer to vector,\n  /// return false if the base expression is a vector.\n  bool isArrow() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExtVectorElementExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockExpr : public Expr {\nprotected:\n  BlockDecl *TheBlock;\npublic:\n  BlockExpr(BlockDecl *BD, QualType ty)\n      : Expr(BlockExprClass, ty, VK_RValue, OK_Ordinary), TheBlock(BD) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty block expression.\n  explicit BlockExpr(EmptyShell Empty) : Expr(BlockExprClass, Empty) { }\n\n  const BlockDecl *getBlockDecl() const { return TheBlock; }\n  BlockDecl *getBlockDecl() { return TheBlock; }\n  void setBlockDecl(BlockDecl *BD) { TheBlock = BD; }\n\n  // Convenience functions for probing the underlying BlockDecl.\n  SourceLocation getCaretLocation() const;\n  const Stmt *getBody() const;\n  Stmt *getBody();\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCaretLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  /// getFunctionType - Return the underlying function type for this block.\n  const FunctionProtoType *getFunctionType() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BlockExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Copy initialization expr of a __block variable and a boolean flag that\n/// indicates whether the expression can throw.\nstruct BlockVarCopyInit {\n  BlockVarCopyInit() = default;\n  BlockVarCopyInit(Expr *CopyExpr, bool CanThrow)\n      : ExprAndFlag(CopyExpr, CanThrow) {}\n  void setExprAndFlag(Expr *CopyExpr, bool CanThrow) {\n    ExprAndFlag.setPointerAndInt(CopyExpr, CanThrow);\n  }\n  Expr *getCopyExpr() const { return ExprAndFlag.getPointer(); }\n  bool canThrow() const { return ExprAndFlag.getInt(); }\n  llvm::PointerIntPair<Expr *, 1, bool> ExprAndFlag;\n};\n\n/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL 6.2.4.2]\n/// This AST node provides support for reinterpreting a type to another\n/// type of the same size.\nclass AsTypeExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit AsTypeExpr(EmptyShell Empty) : Expr(AsTypeExprClass, Empty) {}\n\npublic:\n  AsTypeExpr(Expr *SrcExpr, QualType DstType, ExprValueKind VK,\n             ExprObjectKind OK, SourceLocation BuiltinLoc,\n             SourceLocation RParenLoc)\n      : Expr(AsTypeExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getBuiltinLoc - Return the location of the __builtin_astype token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AsTypeExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// PseudoObjectExpr - An expression which accesses a pseudo-object\n/// l-value.  A pseudo-object is an abstract object, accesses to which\n/// are translated to calls.  The pseudo-object expression has a\n/// syntactic form, which shows how the expression was actually\n/// written in the source code, and a semantic form, which is a series\n/// of expressions to be executed in order which detail how the\n/// operation is actually evaluated.  Optionally, one of the semantic\n/// forms may also provide a result value for the expression.\n///\n/// If any of the semantic-form expressions is an OpaqueValueExpr,\n/// that OVE is required to have a source expression, and it is bound\n/// to the result of that source expression.  Such OVEs may appear\n/// only in subsequent semantic-form expressions and as\n/// sub-expressions of the syntactic form.\n///\n/// PseudoObjectExpr should be used only when an operation can be\n/// usefully described in terms of fairly simple rewrite rules on\n/// objects and functions that are meant to be used by end-developers.\n/// For example, under the Itanium ABI, dynamic casts are implemented\n/// as a call to a runtime function called __dynamic_cast; using this\n/// class to describe that would be inappropriate because that call is\n/// not really part of the user-visible semantics, and instead the\n/// cast is properly reflected in the AST and IR-generation has been\n/// taught to generate the call as necessary.  In contrast, an\n/// Objective-C property access is semantically defined to be\n/// equivalent to a particular message send, and this is very much\n/// part of the user model.  The name of this class encourages this\n/// modelling design.\nclass PseudoObjectExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PseudoObjectExpr, Expr *> {\n  // PseudoObjectExprBits.NumSubExprs - The number of sub-expressions.\n  // Always at least two, because the first sub-expression is the\n  // syntactic form.\n\n  // PseudoObjectExprBits.ResultIndex - The index of the\n  // sub-expression holding the result.  0 means the result is void,\n  // which is unambiguous because it's the index of the syntactic\n  // form.  Note that this is therefore 1 higher than the value passed\n  // in to Create, which is an index within the semantic forms.\n  // Note also that ASTStmtWriter assumes this encoding.\n\n  Expr **getSubExprsBuffer() { return getTrailingObjects<Expr *>(); }\n  const Expr * const *getSubExprsBuffer() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  PseudoObjectExpr(QualType type, ExprValueKind VK,\n                   Expr *syntactic, ArrayRef<Expr*> semantic,\n                   unsigned resultIndex);\n\n  PseudoObjectExpr(EmptyShell shell, unsigned numSemanticExprs);\n\n  unsigned getNumSubExprs() const {\n    return PseudoObjectExprBits.NumSubExprs;\n  }\n\npublic:\n  /// NoResult - A value for the result index indicating that there is\n  /// no semantic result.\n  enum : unsigned { NoResult = ~0U };\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, Expr *syntactic,\n                                  ArrayRef<Expr*> semantic,\n                                  unsigned resultIndex);\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, EmptyShell shell,\n                                  unsigned numSemanticExprs);\n\n  /// Return the syntactic form of this expression, i.e. the\n  /// expression it actually looks like.  Likely to be expressed in\n  /// terms of OpaqueValueExprs bound in the semantic form.\n  Expr *getSyntacticForm() { return getSubExprsBuffer()[0]; }\n  const Expr *getSyntacticForm() const { return getSubExprsBuffer()[0]; }\n\n  /// Return the index of the result-bearing expression into the semantics\n  /// expressions, or PseudoObjectExpr::NoResult if there is none.\n  unsigned getResultExprIndex() const {\n    if (PseudoObjectExprBits.ResultIndex == 0) return NoResult;\n    return PseudoObjectExprBits.ResultIndex - 1;\n  }\n\n  /// Return the result-bearing expression, or null if there is none.\n  Expr *getResultExpr() {\n    if (PseudoObjectExprBits.ResultIndex == 0)\n      return nullptr;\n    return getSubExprsBuffer()[PseudoObjectExprBits.ResultIndex];\n  }\n  const Expr *getResultExpr() const {\n    return const_cast<PseudoObjectExpr*>(this)->getResultExpr();\n  }\n\n  unsigned getNumSemanticExprs() const { return getNumSubExprs() - 1; }\n\n  typedef Expr * const *semantics_iterator;\n  typedef const Expr * const *const_semantics_iterator;\n  semantics_iterator semantics_begin() {\n    return getSubExprsBuffer() + 1;\n  }\n  const_semantics_iterator semantics_begin() const {\n    return getSubExprsBuffer() + 1;\n  }\n  semantics_iterator semantics_end() {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n  const_semantics_iterator semantics_end() const {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n\n  llvm::iterator_range<semantics_iterator> semantics() {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n  llvm::iterator_range<const_semantics_iterator> semantics() const {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n\n  Expr *getSemanticExpr(unsigned index) {\n    assert(index + 1 < getNumSubExprs());\n    return getSubExprsBuffer()[index + 1];\n  }\n  const Expr *getSemanticExpr(unsigned index) const {\n    return const_cast<PseudoObjectExpr*>(this)->getSemanticExpr(index);\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getExprLoc();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getEndLoc();\n  }\n\n  child_range children() {\n    const_child_range CCR =\n        const_cast<const PseudoObjectExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n  const_child_range children() const {\n    Stmt *const *cs = const_cast<Stmt *const *>(\n        reinterpret_cast<const Stmt *const *>(getSubExprsBuffer()));\n    return const_child_range(cs, cs + getNumSubExprs());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PseudoObjectExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n};\n\n/// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,\n/// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the\n/// similarly-named C++11 instructions, and __c11 variants for <stdatomic.h>,\n/// and corresponding __opencl_atomic_* for OpenCL 2.0.\n/// All of these instructions take one primary pointer, at least one memory\n/// order. The instructions for which getScopeModel returns non-null value\n/// take one synch scope.\nclass AtomicExpr : public Expr {\npublic:\n  enum AtomicOp {\n#define BUILTIN(ID, TYPE, ATTRS)\n#define ATOMIC_BUILTIN(ID, TYPE, ATTRS) AO ## ID,\n#include \"clang/Basic/Builtins.def\"\n    // Avoid trailing comma\n    BI_First = 0\n  };\n\nprivate:\n  /// Location of sub-expressions.\n  /// The location of Scope sub-expression is NumSubExprs - 1, which is\n  /// not fixed, therefore is not defined in enum.\n  enum { PTR, ORDER, VAL1, ORDER_FAIL, VAL2, WEAK, END_EXPR };\n  Stmt *SubExprs[END_EXPR + 1];\n  unsigned NumSubExprs;\n  SourceLocation BuiltinLoc, RParenLoc;\n  AtomicOp Op;\n\n  friend class ASTStmtReader;\npublic:\n  AtomicExpr(SourceLocation BLoc, ArrayRef<Expr*> args, QualType t,\n             AtomicOp op, SourceLocation RP);\n\n  /// Determine the number of arguments the specified atomic builtin\n  /// should have.\n  static unsigned getNumSubExprs(AtomicOp Op);\n\n  /// Build an empty AtomicExpr.\n  explicit AtomicExpr(EmptyShell Empty) : Expr(AtomicExprClass, Empty) { }\n\n  Expr *getPtr() const {\n    return cast<Expr>(SubExprs[PTR]);\n  }\n  Expr *getOrder() const {\n    return cast<Expr>(SubExprs[ORDER]);\n  }\n  Expr *getScope() const {\n    assert(getScopeModel() && \"No scope\");\n    return cast<Expr>(SubExprs[NumSubExprs - 1]);\n  }\n  Expr *getVal1() const {\n    if (Op == AO__c11_atomic_init || Op == AO__opencl_atomic_init)\n      return cast<Expr>(SubExprs[ORDER]);\n    assert(NumSubExprs > VAL1);\n    return cast<Expr>(SubExprs[VAL1]);\n  }\n  Expr *getOrderFail() const {\n    assert(NumSubExprs > ORDER_FAIL);\n    return cast<Expr>(SubExprs[ORDER_FAIL]);\n  }\n  Expr *getVal2() const {\n    if (Op == AO__atomic_exchange)\n      return cast<Expr>(SubExprs[ORDER_FAIL]);\n    assert(NumSubExprs > VAL2);\n    return cast<Expr>(SubExprs[VAL2]);\n  }\n  Expr *getWeak() const {\n    assert(NumSubExprs > WEAK);\n    return cast<Expr>(SubExprs[WEAK]);\n  }\n  QualType getValueType() const;\n\n  AtomicOp getOp() const { return Op; }\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n  const Expr * const *getSubExprs() const {\n    return reinterpret_cast<Expr * const *>(SubExprs);\n  }\n\n  bool isVolatile() const {\n    return getPtr()->getType()->getPointeeType().isVolatileQualified();\n  }\n\n  bool isCmpXChg() const {\n    return getOp() == AO__c11_atomic_compare_exchange_strong ||\n           getOp() == AO__c11_atomic_compare_exchange_weak ||\n           getOp() == AO__opencl_atomic_compare_exchange_strong ||\n           getOp() == AO__opencl_atomic_compare_exchange_weak ||\n           getOp() == AO__atomic_compare_exchange ||\n           getOp() == AO__atomic_compare_exchange_n;\n  }\n\n  bool isOpenCL() const {\n    return getOp() >= AO__opencl_atomic_init &&\n           getOp() <= AO__opencl_atomic_fetch_max;\n  }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AtomicExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs+NumSubExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NumSubExprs);\n  }\n\n  /// Get atomic scope model for the atomic op code.\n  /// \\return empty atomic scope model if the atomic op code does not have\n  ///   scope operand.\n  static std::unique_ptr<AtomicScopeModel> getScopeModel(AtomicOp Op) {\n    auto Kind =\n        (Op >= AO__opencl_atomic_load && Op <= AO__opencl_atomic_fetch_max)\n            ? AtomicScopeModelKind::OpenCL\n            : AtomicScopeModelKind::None;\n    return AtomicScopeModel::create(Kind);\n  }\n\n  /// Get atomic scope model.\n  /// \\return empty atomic scope model if this atomic expression does not have\n  ///   scope operand.\n  std::unique_ptr<AtomicScopeModel> getScopeModel() const {\n    return getScopeModel(getOp());\n  }\n};\n\n/// TypoExpr - Internal placeholder for expressions where typo correction\n/// still needs to be performed and/or an error diagnostic emitted.\nclass TypoExpr : public Expr {\n  // The location for the typo name.\n  SourceLocation TypoLoc;\n\npublic:\n  TypoExpr(QualType T, SourceLocation TypoLoc)\n      : Expr(TypoExprClass, T, VK_LValue, OK_Ordinary), TypoLoc(TypoLoc) {\n    assert(T->isDependentType() && \"TypoExpr given a non-dependent type\");\n    setDependence(ExprDependence::TypeValueInstantiation |\n                  ExprDependence::Error);\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TypoLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TypoLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypoExprClass;\n  }\n\n};\n\n/// Frontend produces RecoveryExprs on semantic errors that prevent creating\n/// other well-formed expressions. E.g. when type-checking of a binary operator\n/// fails, we cannot produce a BinaryOperator expression. Instead, we can choose\n/// to produce a recovery expression storing left and right operands.\n///\n/// RecoveryExpr does not have any semantic meaning in C++, it is only useful to\n/// preserve expressions in AST that would otherwise be dropped. It captures\n/// subexpressions of some expression that we could not construct and source\n/// range covered by the expression.\n///\n/// By default, RecoveryExpr uses dependence-bits to take advantage of existing\n/// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved\n/// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In\n/// addition to that, clang does not report most errors on dependent\n/// expressions, so we get rid of bogus errors for free. However, note that\n/// unlike other dependent expressions, RecoveryExpr can be produced in\n/// non-template contexts.\n///\n/// We will preserve the type in RecoveryExpr when the type is known, e.g.\n/// preserving the return type for a broken non-overloaded function call, a\n/// overloaded call where all candidates have the same return type. In this\n/// case, the expression is not type-dependent (unless the known type is itself\n/// dependent)\n///\n/// One can also reliably suppress all bogus errors on expressions containing\n/// recovery expressions by examining results of Expr::containsErrors().\nclass RecoveryExpr final : public Expr,\n                           private llvm::TrailingObjects<RecoveryExpr, Expr *> {\npublic:\n  static RecoveryExpr *Create(ASTContext &Ctx, QualType T,\n                              SourceLocation BeginLoc, SourceLocation EndLoc,\n                              ArrayRef<Expr *> SubExprs);\n  static RecoveryExpr *CreateEmpty(ASTContext &Ctx, unsigned NumSubExprs);\n\n  ArrayRef<Expr *> subExpressions() {\n    auto *B = getTrailingObjects<Expr *>();\n    return llvm::makeArrayRef(B, B + NumExprs);\n  }\n\n  ArrayRef<const Expr *> subExpressions() const {\n    return const_cast<RecoveryExpr *>(this)->subExpressions();\n  }\n\n  child_range children() {\n    Stmt **B = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(B, B + NumExprs);\n  }\n\n  SourceLocation getBeginLoc() const { return BeginLoc; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RecoveryExprClass;\n  }\n\nprivate:\n  RecoveryExpr(ASTContext &Ctx, QualType T, SourceLocation BeginLoc,\n               SourceLocation EndLoc, ArrayRef<Expr *> SubExprs);\n  RecoveryExpr(EmptyShell Empty, unsigned NumSubExprs)\n      : Expr(RecoveryExprClass, Empty), NumExprs(NumSubExprs) {}\n\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const { return NumExprs; }\n\n  SourceLocation BeginLoc, EndLoc;\n  unsigned NumExprs;\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_AST_EXPR_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExternalASTSource.h", "content": "//===- ExternalASTSource.h - Abstract External AST Interface ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ExternalASTSource interface, which enables\n//  construction of AST nodes from some external source.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXTERNALASTSOURCE_H\n#define LLVM_CLANG_AST_EXTERNALASTSOURCE_H\n\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTConsumer;\nclass ASTContext;\nclass ASTSourceDescriptor;\nclass CXXBaseSpecifier;\nclass CXXCtorInitializer;\nclass CXXRecordDecl;\nclass DeclarationName;\nclass FieldDecl;\nclass IdentifierInfo;\nclass NamedDecl;\nclass ObjCInterfaceDecl;\nclass RecordDecl;\nclass Selector;\nclass Stmt;\nclass TagDecl;\n\n/// Abstract interface for external sources of AST nodes.\n///\n/// External AST sources provide AST nodes constructed from some\n/// external source, such as a precompiled header. External AST\n/// sources can resolve types and declarations from abstract IDs into\n/// actual type and declaration nodes, and read parts of declaration\n/// contexts.\nclass ExternalASTSource : public RefCountedBase<ExternalASTSource> {\n  friend class ExternalSemaSource;\n\n  /// Generation number for this external AST source. Must be increased\n  /// whenever we might have added new redeclarations for existing decls.\n  uint32_t CurrentGeneration = 0;\n\n  /// LLVM-style RTTI.\n  static char ID;\n\npublic:\n  ExternalASTSource() = default;\n  virtual ~ExternalASTSource();\n\n  /// RAII class for safely pairing a StartedDeserializing call\n  /// with FinishedDeserializing.\n  class Deserializing {\n    ExternalASTSource *Source;\n\n  public:\n    explicit Deserializing(ExternalASTSource *source) : Source(source) {\n      assert(Source);\n      Source->StartedDeserializing();\n    }\n\n    ~Deserializing() {\n      Source->FinishedDeserializing();\n    }\n  };\n\n  /// Get the current generation of this AST source. This number\n  /// is incremented each time the AST source lazily extends an existing\n  /// entity.\n  uint32_t getGeneration() const { return CurrentGeneration; }\n\n  /// Resolve a declaration ID into a declaration, potentially\n  /// building a new declaration.\n  ///\n  /// This method only needs to be implemented if the AST source ever\n  /// passes back decl sets as VisibleDeclaration objects.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual Decl *GetExternalDecl(uint32_t ID);\n\n  /// Resolve a selector ID into a selector.\n  ///\n  /// This operation only needs to be implemented if the AST source\n  /// returns non-zero for GetNumKnownSelectors().\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual Selector GetExternalSelector(uint32_t ID);\n\n  /// Returns the number of selectors known to the external AST\n  /// source.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual uint32_t GetNumExternalSelectors();\n\n  /// Resolve the offset of a statement in the decl stream into\n  /// a statement.\n  ///\n  /// This operation is meant to be used via a LazyOffsetPtr.  It only\n  /// needs to be implemented if the AST source uses methods like\n  /// FunctionDecl::setLazyBody when building decls.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual Stmt *GetExternalDeclStmt(uint64_t Offset);\n\n  /// Resolve the offset of a set of C++ constructor initializers in\n  /// the decl stream into an array of initializers.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual CXXCtorInitializer **GetExternalCXXCtorInitializers(uint64_t Offset);\n\n  /// Resolve the offset of a set of C++ base specifiers in the decl\n  /// stream into an array of specifiers.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual CXXBaseSpecifier *GetExternalCXXBaseSpecifiers(uint64_t Offset);\n\n  /// Update an out-of-date identifier.\n  virtual void updateOutOfDateIdentifier(IdentifierInfo &II) {}\n\n  /// Find all declarations with the given name in the given context,\n  /// and add them to the context by calling SetExternalVisibleDeclsForName\n  /// or SetNoExternalVisibleDeclsForName.\n  /// \\return \\c true if any declarations might have been found, \\c false if\n  /// we definitely have no declarations with tbis name.\n  ///\n  /// The default implementation of this method is a no-op returning \\c false.\n  virtual bool\n  FindExternalVisibleDeclsByName(const DeclContext *DC, DeclarationName Name);\n\n  /// Ensures that the table of all visible declarations inside this\n  /// context is up to date.\n  ///\n  /// The default implementation of this function is a no-op.\n  virtual void completeVisibleDeclsMap(const DeclContext *DC);\n\n  /// Retrieve the module that corresponds to the given module ID.\n  virtual Module *getModule(unsigned ID) { return nullptr; }\n\n  /// Return a descriptor for the corresponding module, if one exists.\n  virtual llvm::Optional<ASTSourceDescriptor> getSourceDescriptor(unsigned ID);\n\n  enum ExtKind { EK_Always, EK_Never, EK_ReplyHazy };\n\n  virtual ExtKind hasExternalDefinitions(const Decl *D);\n\n  /// Finds all declarations lexically contained within the given\n  /// DeclContext, after applying an optional filter predicate.\n  ///\n  /// \\param IsKindWeWant a predicate function that returns true if the passed\n  /// declaration kind is one we are looking for.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual void\n  FindExternalLexicalDecls(const DeclContext *DC,\n                           llvm::function_ref<bool(Decl::Kind)> IsKindWeWant,\n                           SmallVectorImpl<Decl *> &Result);\n\n  /// Finds all declarations lexically contained within the given\n  /// DeclContext.\n  void FindExternalLexicalDecls(const DeclContext *DC,\n                                SmallVectorImpl<Decl *> &Result) {\n    FindExternalLexicalDecls(DC, [](Decl::Kind) { return true; }, Result);\n  }\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  virtual void FindFileRegionDecls(FileID File, unsigned Offset,\n                                   unsigned Length,\n                                   SmallVectorImpl<Decl *> &Decls);\n\n  /// Gives the external AST source an opportunity to complete\n  /// the redeclaration chain for a declaration. Called each time we\n  /// need the most recent declaration of a declaration after the\n  /// generation count is incremented.\n  virtual void CompleteRedeclChain(const Decl *D);\n\n  /// Gives the external AST source an opportunity to complete\n  /// an incomplete type.\n  virtual void CompleteType(TagDecl *Tag);\n\n  /// Gives the external AST source an opportunity to complete an\n  /// incomplete Objective-C class.\n  ///\n  /// This routine will only be invoked if the \"externally completed\" bit is\n  /// set on the ObjCInterfaceDecl via the function\n  /// \\c ObjCInterfaceDecl::setExternallyCompleted().\n  virtual void CompleteType(ObjCInterfaceDecl *Class);\n\n  /// Loads comment ranges.\n  virtual void ReadComments();\n\n  /// Notify ExternalASTSource that we started deserialization of\n  /// a decl or type so until FinishedDeserializing is called there may be\n  /// decls that are initializing. Must be paired with FinishedDeserializing.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual void StartedDeserializing();\n\n  /// Notify ExternalASTSource that we finished the deserialization of\n  /// a decl or type. Must be paired with StartedDeserializing.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual void FinishedDeserializing();\n\n  /// Function that will be invoked when we begin parsing a new\n  /// translation unit involving this external AST source.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual void StartTranslationUnit(ASTConsumer *Consumer);\n\n  /// Print any statistics that have been gathered regarding\n  /// the external AST source.\n  ///\n  /// The default implementation of this method is a no-op.\n  virtual void PrintStats();\n\n  /// Perform layout on the given record.\n  ///\n  /// This routine allows the external AST source to provide an specific\n  /// layout for a record, overriding the layout that would normally be\n  /// constructed. It is intended for clients who receive specific layout\n  /// details rather than source code (such as LLDB). The client is expected\n  /// to fill in the field offsets, base offsets, virtual base offsets, and\n  /// complete object size.\n  ///\n  /// \\param Record The record whose layout is being requested.\n  ///\n  /// \\param Size The final size of the record, in bits.\n  ///\n  /// \\param Alignment The final alignment of the record, in bits.\n  ///\n  /// \\param FieldOffsets The offset of each of the fields within the record,\n  /// expressed in bits. All of the fields must be provided with offsets.\n  ///\n  /// \\param BaseOffsets The offset of each of the direct, non-virtual base\n  /// classes. If any bases are not given offsets, the bases will be laid\n  /// out according to the ABI.\n  ///\n  /// \\param VirtualBaseOffsets The offset of each of the virtual base classes\n  /// (either direct or not). If any bases are not given offsets, the bases will be laid\n  /// out according to the ABI.\n  ///\n  /// \\returns true if the record layout was provided, false otherwise.\n  virtual bool layoutRecordType(\n      const RecordDecl *Record, uint64_t &Size, uint64_t &Alignment,\n      llvm::DenseMap<const FieldDecl *, uint64_t> &FieldOffsets,\n      llvm::DenseMap<const CXXRecordDecl *, CharUnits> &BaseOffsets,\n      llvm::DenseMap<const CXXRecordDecl *, CharUnits> &VirtualBaseOffsets);\n\n  //===--------------------------------------------------------------------===//\n  // Queries for performance analysis.\n  //===--------------------------------------------------------------------===//\n\n  struct MemoryBufferSizes {\n    size_t malloc_bytes;\n    size_t mmap_bytes;\n\n    MemoryBufferSizes(size_t malloc_bytes, size_t mmap_bytes)\n        : malloc_bytes(malloc_bytes), mmap_bytes(mmap_bytes) {}\n  };\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  MemoryBufferSizes getMemoryBufferSizes() const {\n    MemoryBufferSizes sizes(0, 0);\n    getMemoryBufferSizes(sizes);\n    return sizes;\n  }\n\n  virtual void getMemoryBufferSizes(MemoryBufferSizes &sizes) const;\n\n  /// LLVM-style RTTI.\n  /// \\{\n  virtual bool isA(const void *ClassID) const { return ClassID == &ID; }\n  static bool classof(const ExternalASTSource *S) { return S->isA(&ID); }\n  /// \\}\n\nprotected:\n  static DeclContextLookupResult\n  SetExternalVisibleDeclsForName(const DeclContext *DC,\n                                 DeclarationName Name,\n                                 ArrayRef<NamedDecl*> Decls);\n\n  static DeclContextLookupResult\n  SetNoExternalVisibleDeclsForName(const DeclContext *DC,\n                                   DeclarationName Name);\n\n  /// Increment the current generation.\n  uint32_t incrementGeneration(ASTContext &C);\n};\n\n/// A lazy pointer to an AST node (of base type T) that resides\n/// within an external AST source.\n///\n/// The AST node is identified within the external AST source by a\n/// 63-bit offset, and can be retrieved via an operation on the\n/// external AST source itself.\ntemplate<typename T, typename OffsT, T* (ExternalASTSource::*Get)(OffsT Offset)>\nstruct LazyOffsetPtr {\n  /// Either a pointer to an AST node or the offset within the\n  /// external AST source where the AST node can be found.\n  ///\n  /// If the low bit is clear, a pointer to the AST node. If the low\n  /// bit is set, the upper 63 bits are the offset.\n  mutable uint64_t Ptr = 0;\n\npublic:\n  LazyOffsetPtr() = default;\n  explicit LazyOffsetPtr(T *Ptr) : Ptr(reinterpret_cast<uint64_t>(Ptr)) {}\n\n  explicit LazyOffsetPtr(uint64_t Offset) : Ptr((Offset << 1) | 0x01) {\n    assert((Offset << 1 >> 1) == Offset && \"Offsets must require < 63 bits\");\n    if (Offset == 0)\n      Ptr = 0;\n  }\n\n  LazyOffsetPtr &operator=(T *Ptr) {\n    this->Ptr = reinterpret_cast<uint64_t>(Ptr);\n    return *this;\n  }\n\n  LazyOffsetPtr &operator=(uint64_t Offset) {\n    assert((Offset << 1 >> 1) == Offset && \"Offsets must require < 63 bits\");\n    if (Offset == 0)\n      Ptr = 0;\n    else\n      Ptr = (Offset << 1) | 0x01;\n\n    return *this;\n  }\n\n  /// Whether this pointer is non-NULL.\n  ///\n  /// This operation does not require the AST node to be deserialized.\n  explicit operator bool() const { return Ptr != 0; }\n\n  /// Whether this pointer is non-NULL.\n  ///\n  /// This operation does not require the AST node to be deserialized.\n  bool isValid() const { return Ptr != 0; }\n\n  /// Whether this pointer is currently stored as an offset.\n  bool isOffset() const { return Ptr & 0x01; }\n\n  /// Retrieve the pointer to the AST node that this lazy pointer points to.\n  ///\n  /// \\param Source the external AST source.\n  ///\n  /// \\returns a pointer to the AST node.\n  T* get(ExternalASTSource *Source) const {\n    if (isOffset()) {\n      assert(Source &&\n             \"Cannot deserialize a lazy pointer without an AST source\");\n      Ptr = reinterpret_cast<uint64_t>((Source->*Get)(Ptr >> 1));\n    }\n    return reinterpret_cast<T*>(Ptr);\n  }\n};\n\n/// A lazy value (of type T) that is within an AST node of type Owner,\n/// where the value might change in later generations of the external AST\n/// source.\ntemplate<typename Owner, typename T, void (ExternalASTSource::*Update)(Owner)>\nstruct LazyGenerationalUpdatePtr {\n  /// A cache of the value of this pointer, in the most recent generation in\n  /// which we queried it.\n  struct LazyData {\n    ExternalASTSource *ExternalSource;\n    uint32_t LastGeneration = 0;\n    T LastValue;\n\n    LazyData(ExternalASTSource *Source, T Value)\n        : ExternalSource(Source), LastValue(Value) {}\n  };\n\n  // Our value is represented as simply T if there is no external AST source.\n  using ValueType = llvm::PointerUnion<T, LazyData*>;\n  ValueType Value;\n\n  LazyGenerationalUpdatePtr(ValueType V) : Value(V) {}\n\n  // Defined in ASTContext.h\n  static ValueType makeValue(const ASTContext &Ctx, T Value);\n\npublic:\n  explicit LazyGenerationalUpdatePtr(const ASTContext &Ctx, T Value = T())\n      : Value(makeValue(Ctx, Value)) {}\n\n  /// Create a pointer that is not potentially updated by later generations of\n  /// the external AST source.\n  enum NotUpdatedTag { NotUpdated };\n  LazyGenerationalUpdatePtr(NotUpdatedTag, T Value = T())\n      : Value(Value) {}\n\n  /// Forcibly set this pointer (which must be lazy) as needing updates.\n  void markIncomplete() {\n    Value.template get<LazyData *>()->LastGeneration = 0;\n  }\n\n  /// Set the value of this pointer, in the current generation.\n  void set(T NewValue) {\n    if (auto *LazyVal = Value.template dyn_cast<LazyData *>()) {\n      LazyVal->LastValue = NewValue;\n      return;\n    }\n    Value = NewValue;\n  }\n\n  /// Set the value of this pointer, for this and all future generations.\n  void setNotUpdated(T NewValue) { Value = NewValue; }\n\n  /// Get the value of this pointer, updating its owner if necessary.\n  T get(Owner O) {\n    if (auto *LazyVal = Value.template dyn_cast<LazyData *>()) {\n      if (LazyVal->LastGeneration != LazyVal->ExternalSource->getGeneration()) {\n        LazyVal->LastGeneration = LazyVal->ExternalSource->getGeneration();\n        (LazyVal->ExternalSource->*Update)(O);\n      }\n      return LazyVal->LastValue;\n    }\n    return Value.template get<T>();\n  }\n\n  /// Get the most recently computed value of this pointer without updating it.\n  T getNotUpdated() const {\n    if (auto *LazyVal = Value.template dyn_cast<LazyData *>())\n      return LazyVal->LastValue;\n    return Value.template get<T>();\n  }\n\n  void *getOpaqueValue() { return Value.getOpaqueValue(); }\n  static LazyGenerationalUpdatePtr getFromOpaqueValue(void *Ptr) {\n    return LazyGenerationalUpdatePtr(ValueType::getFromOpaqueValue(Ptr));\n  }\n};\n\n} // namespace clang\n\n/// Specialize PointerLikeTypeTraits to allow LazyGenerationalUpdatePtr to be\n/// placed into a PointerUnion.\nnamespace llvm {\n\ntemplate<typename Owner, typename T,\n         void (clang::ExternalASTSource::*Update)(Owner)>\nstruct PointerLikeTypeTraits<\n    clang::LazyGenerationalUpdatePtr<Owner, T, Update>> {\n  using Ptr = clang::LazyGenerationalUpdatePtr<Owner, T, Update>;\n\n  static void *getAsVoidPointer(Ptr P) { return P.getOpaqueValue(); }\n  static Ptr getFromVoidPointer(void *P) { return Ptr::getFromOpaqueValue(P); }\n\n  static constexpr int NumLowBitsAvailable =\n      PointerLikeTypeTraits<T>::NumLowBitsAvailable - 1;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\n/// Represents a lazily-loaded vector of data.\n///\n/// The lazily-loaded vector of data contains data that is partially loaded\n/// from an external source and partially added by local translation. The\n/// items loaded from the external source are loaded lazily, when needed for\n/// iteration over the complete vector.\ntemplate<typename T, typename Source,\n         void (Source::*Loader)(SmallVectorImpl<T>&),\n         unsigned LoadedStorage = 2, unsigned LocalStorage = 4>\nclass LazyVector {\n  SmallVector<T, LoadedStorage> Loaded;\n  SmallVector<T, LocalStorage> Local;\n\npublic:\n  /// Iteration over the elements in the vector.\n  ///\n  /// In a complete iteration, the iterator walks the range [-M, N),\n  /// where negative values are used to indicate elements\n  /// loaded from the external source while non-negative values are used to\n  /// indicate elements added via \\c push_back().\n  /// However, to provide iteration in source order (for, e.g., chained\n  /// precompiled headers), dereferencing the iterator flips the negative\n  /// values (corresponding to loaded entities), so that position -M\n  /// corresponds to element 0 in the loaded entities vector, position -M+1\n  /// corresponds to element 1 in the loaded entities vector, etc. This\n  /// gives us a reasonably efficient, source-order walk.\n  ///\n  /// We define this as a wrapping iterator around an int. The\n  /// iterator_adaptor_base class forwards the iterator methods to basic integer\n  /// arithmetic.\n  class iterator\n      : public llvm::iterator_adaptor_base<\n            iterator, int, std::random_access_iterator_tag, T, int, T *, T &> {\n    friend class LazyVector;\n\n    LazyVector *Self;\n\n    iterator(LazyVector *Self, int Position)\n        : iterator::iterator_adaptor_base(Position), Self(Self) {}\n\n    bool isLoaded() const { return this->I < 0; }\n\n  public:\n    iterator() : iterator(nullptr, 0) {}\n\n    typename iterator::reference operator*() const {\n      if (isLoaded())\n        return Self->Loaded.end()[this->I];\n      return Self->Local.begin()[this->I];\n    }\n  };\n\n  iterator begin(Source *source, bool LocalOnly = false) {\n    if (LocalOnly)\n      return iterator(this, 0);\n\n    if (source)\n      (source->*Loader)(Loaded);\n    return iterator(this, -(int)Loaded.size());\n  }\n\n  iterator end() {\n    return iterator(this, Local.size());\n  }\n\n  void push_back(const T& LocalValue) {\n    Local.push_back(LocalValue);\n  }\n\n  void erase(iterator From, iterator To) {\n    if (From.isLoaded() && To.isLoaded()) {\n      Loaded.erase(&*From, &*To);\n      return;\n    }\n\n    if (From.isLoaded()) {\n      Loaded.erase(&*From, Loaded.end());\n      From = begin(nullptr, true);\n    }\n\n    Local.erase(&*From, &*To);\n  }\n};\n\n/// A lazy pointer to a statement.\nusing LazyDeclStmtPtr =\n    LazyOffsetPtr<Stmt, uint64_t, &ExternalASTSource::GetExternalDeclStmt>;\n\n/// A lazy pointer to a declaration.\nusing LazyDeclPtr =\n    LazyOffsetPtr<Decl, uint32_t, &ExternalASTSource::GetExternalDecl>;\n\n/// A lazy pointer to a set of CXXCtorInitializers.\nusing LazyCXXCtorInitializersPtr =\n    LazyOffsetPtr<CXXCtorInitializer *, uint64_t,\n                  &ExternalASTSource::GetExternalCXXCtorInitializers>;\n\n/// A lazy pointer to a set of CXXBaseSpecifiers.\nusing LazyCXXBaseSpecifiersPtr =\n    LazyOffsetPtr<CXXBaseSpecifier, uint64_t,\n                  &ExternalASTSource::GetExternalCXXBaseSpecifiers>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_EXTERNALASTSOURCE_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h", "content": "//===- NestedNameSpecifier.h - C++ nested name specifiers -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the NestedNameSpecifier class, which represents\n//  a C++ nested-name-specifier.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n#define LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cstdint>\n#include <cstdlib>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass CXXRecordDecl;\nclass IdentifierInfo;\nclass LangOptions;\nclass NamespaceAliasDecl;\nclass NamespaceDecl;\nstruct PrintingPolicy;\nclass Type;\nclass TypeLoc;\n\n/// Represents a C++ nested name specifier, such as\n/// \"\\::std::vector<int>::\".\n///\n/// C++ nested name specifiers are the prefixes to qualified\n/// names. For example, \"foo::\" in \"foo::x\" is a nested name\n/// specifier. Nested name specifiers are made up of a sequence of\n/// specifiers, each of which can be a namespace, type, identifier\n/// (for dependent names), decltype specifier, or the global specifier ('::').\n/// The last two specifiers can only appear at the start of a\n/// nested-namespace-specifier.\nclass NestedNameSpecifier : public llvm::FoldingSetNode {\n  /// Enumeration describing\n  enum StoredSpecifierKind {\n    StoredIdentifier = 0,\n    StoredDecl = 1,\n    StoredTypeSpec = 2,\n    StoredTypeSpecWithTemplate = 3\n  };\n\n  /// The nested name specifier that precedes this nested name\n  /// specifier.\n  ///\n  /// The pointer is the nested-name-specifier that precedes this\n  /// one. The integer stores one of the first four values of type\n  /// SpecifierKind.\n  llvm::PointerIntPair<NestedNameSpecifier *, 2, StoredSpecifierKind> Prefix;\n\n  /// The last component in the nested name specifier, which\n  /// can be an identifier, a declaration, or a type.\n  ///\n  /// When the pointer is NULL, this specifier represents the global\n  /// specifier '::'. Otherwise, the pointer is one of\n  /// IdentifierInfo*, Namespace*, or Type*, depending on the kind of\n  /// specifier as encoded within the prefix.\n  void* Specifier = nullptr;\n\npublic:\n  /// The kind of specifier that completes this nested name\n  /// specifier.\n  enum SpecifierKind {\n    /// An identifier, stored as an IdentifierInfo*.\n    Identifier,\n\n    /// A namespace, stored as a NamespaceDecl*.\n    Namespace,\n\n    /// A namespace alias, stored as a NamespaceAliasDecl*.\n    NamespaceAlias,\n\n    /// A type, stored as a Type*.\n    TypeSpec,\n\n    /// A type that was preceded by the 'template' keyword,\n    /// stored as a Type*.\n    TypeSpecWithTemplate,\n\n    /// The global specifier '::'. There is no stored value.\n    Global,\n\n    /// Microsoft's '__super' specifier, stored as a CXXRecordDecl* of\n    /// the class it appeared in.\n    Super\n  };\n\nprivate:\n  /// Builds the global specifier.\n  NestedNameSpecifier() : Prefix(nullptr, StoredIdentifier) {}\n\n  /// Copy constructor used internally to clone nested name\n  /// specifiers.\n  NestedNameSpecifier(const NestedNameSpecifier &Other) = default;\n\n  /// Either find or insert the given nested name specifier\n  /// mockup in the given context.\n  static NestedNameSpecifier *FindOrInsert(const ASTContext &Context,\n                                           const NestedNameSpecifier &Mockup);\n\npublic:\n  NestedNameSpecifier &operator=(const NestedNameSpecifier &) = delete;\n\n  /// Builds a specifier combining a prefix and an identifier.\n  ///\n  /// The prefix must be dependent, since nested name specifiers\n  /// referencing an identifier are only permitted when the identifier\n  /// cannot be resolved.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     IdentifierInfo *II);\n\n  /// Builds a nested name specifier that names a namespace.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     const NamespaceDecl *NS);\n\n  /// Builds a nested name specifier that names a namespace alias.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     NamespaceAliasDecl *Alias);\n\n  /// Builds a nested name specifier that names a type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     bool Template, const Type *T);\n\n  /// Builds a specifier that consists of just an identifier.\n  ///\n  /// The nested-name-specifier is assumed to be dependent, but has no\n  /// prefix because the prefix is implied by something outside of the\n  /// nested name specifier, e.g., in \"x->Base::f\", the \"x\" has a dependent\n  /// type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     IdentifierInfo *II);\n\n  /// Returns the nested name specifier representing the global\n  /// scope.\n  static NestedNameSpecifier *GlobalSpecifier(const ASTContext &Context);\n\n  /// Returns the nested name specifier representing the __super scope\n  /// for the given CXXRecordDecl.\n  static NestedNameSpecifier *SuperSpecifier(const ASTContext &Context,\n                                             CXXRecordDecl *RD);\n\n  /// Return the prefix of this nested name specifier.\n  ///\n  /// The prefix contains all of the parts of the nested name\n  /// specifier that preced this current specifier. For example, for a\n  /// nested name specifier that represents \"foo::bar::\", the current\n  /// specifier will contain \"bar::\" and the prefix will contain\n  /// \"foo::\".\n  NestedNameSpecifier *getPrefix() const { return Prefix.getPointer(); }\n\n  /// Determine what kind of nested name specifier is stored.\n  SpecifierKind getKind() const;\n\n  /// Retrieve the identifier stored in this nested name\n  /// specifier.\n  IdentifierInfo *getAsIdentifier() const {\n    if (Prefix.getInt() == StoredIdentifier)\n      return (IdentifierInfo *)Specifier;\n\n    return nullptr;\n  }\n\n  /// Retrieve the namespace stored in this nested name\n  /// specifier.\n  NamespaceDecl *getAsNamespace() const;\n\n  /// Retrieve the namespace alias stored in this nested name\n  /// specifier.\n  NamespaceAliasDecl *getAsNamespaceAlias() const;\n\n  /// Retrieve the record declaration stored in this nested name\n  /// specifier.\n  CXXRecordDecl *getAsRecordDecl() const;\n\n  /// Retrieve the type stored in this nested name specifier.\n  const Type *getAsType() const {\n    if (Prefix.getInt() == StoredTypeSpec ||\n        Prefix.getInt() == StoredTypeSpecWithTemplate)\n      return (const Type *)Specifier;\n\n    return nullptr;\n  }\n\n  NestedNameSpecifierDependence getDependence() const;\n\n  /// Whether this nested name specifier refers to a dependent\n  /// type or not.\n  bool isDependent() const;\n\n  /// Whether this nested name specifier involves a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this nested-name-specifier contains an unexpanded\n  /// parameter pack (for C++11 variadic templates).\n  bool containsUnexpandedParameterPack() const;\n\n  /// Whether this nested name specifier contains an error.\n  bool containsErrors() const;\n\n  /// Print this nested name specifier to the given output stream. If\n  /// `ResolveTemplateArguments` is true, we'll print actual types, e.g.\n  /// `ns::SomeTemplate<int, MyClass>` instead of\n  /// `ns::SomeTemplate<Container::value_type, T>`.\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool ResolveTemplateArguments = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(Prefix.getOpaqueValue());\n    ID.AddPointer(Specifier);\n  }\n\n  /// Dump the nested name specifier to standard output to aid\n  /// in debugging.\n  void dump(const LangOptions &LO) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS) const;\n  void dump(llvm::raw_ostream &OS, const LangOptions &LO) const;\n};\n\n/// A C++ nested-name-specifier augmented with source location\n/// information.\nclass NestedNameSpecifierLoc {\n  NestedNameSpecifier *Qualifier = nullptr;\n  void *Data = nullptr;\n\n  /// Determines the data length for the last component in the\n  /// given nested-name-specifier.\n  static unsigned getLocalDataLength(NestedNameSpecifier *Qualifier);\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  static unsigned getDataLength(NestedNameSpecifier *Qualifier);\n\npublic:\n  /// Construct an empty nested-name-specifier.\n  NestedNameSpecifierLoc() = default;\n\n  /// Construct a nested-name-specifier with source location information\n  /// from\n  NestedNameSpecifierLoc(NestedNameSpecifier *Qualifier, void *Data)\n      : Qualifier(Qualifier), Data(Data) {}\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// non-empty.\n  explicit operator bool() const { return Qualifier; }\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// empty.\n  bool hasQualifier() const { return Qualifier; }\n\n  /// Retrieve the nested-name-specifier to which this instance\n  /// refers.\n  NestedNameSpecifier *getNestedNameSpecifier() const {\n    return Qualifier;\n  }\n\n  /// Retrieve the opaque pointer that refers to source-location data.\n  void *getOpaqueData() const { return Data; }\n\n  /// Retrieve the source range covering the entirety of this\n  /// nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from the initial '::' to the last '::'.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Retrieve the source range covering just the last part of\n  /// this nested-name-specifier, not including the prefix.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from \"vector\" to the last '::'.\n  SourceRange getLocalSourceRange() const;\n\n  /// Retrieve the location of the beginning of this\n  /// nested-name-specifier.\n  SourceLocation getBeginLoc() const {\n    return getSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this\n  /// nested-name-specifier.\n  SourceLocation getEndLoc() const {\n    return getSourceRange().getEnd();\n  }\n\n  /// Retrieve the location of the beginning of this\n  /// component of the nested-name-specifier.\n  SourceLocation getLocalBeginLoc() const {\n    return getLocalSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this component of the\n  /// nested-name-specifier.\n  SourceLocation getLocalEndLoc() const {\n    return getLocalSourceRange().getEnd();\n  }\n\n  /// Return the prefix of this nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the prefix is \\c \\::std::. Note that the\n  /// returned prefix may be empty, if this is the first component of\n  /// the nested-name-specifier.\n  NestedNameSpecifierLoc getPrefix() const {\n    if (!Qualifier)\n      return *this;\n\n    return NestedNameSpecifierLoc(Qualifier->getPrefix(), Data);\n  }\n\n  /// For a nested-name-specifier that refers to a type,\n  /// retrieve the type with source-location information.\n  TypeLoc getTypeLoc() const;\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  unsigned getDataLength() const { return getDataLength(Qualifier); }\n\n  friend bool operator==(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return X.Qualifier == Y.Qualifier && X.Data == Y.Data;\n  }\n\n  friend bool operator!=(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return !(X == Y);\n  }\n};\n\n/// Class that aids in the construction of nested-name-specifiers along\n/// with source-location information for all of the components of the\n/// nested-name-specifier.\nclass NestedNameSpecifierLocBuilder {\n  /// The current representation of the nested-name-specifier we're\n  /// building.\n  NestedNameSpecifier *Representation = nullptr;\n\n  /// Buffer used to store source-location information for the\n  /// nested-name-specifier.\n  ///\n  /// Note that we explicitly manage the buffer (rather than using a\n  /// SmallVector) because \\c Declarator expects it to be possible to memcpy()\n  /// a \\c CXXScopeSpec, and CXXScopeSpec uses a NestedNameSpecifierLocBuilder.\n  char *Buffer = nullptr;\n\n  /// The size of the buffer used to store source-location information\n  /// for the nested-name-specifier.\n  unsigned BufferSize = 0;\n\n  /// The capacity of the buffer used to store source-location\n  /// information for the nested-name-specifier.\n  unsigned BufferCapacity = 0;\n\npublic:\n  NestedNameSpecifierLocBuilder() = default;\n  NestedNameSpecifierLocBuilder(const NestedNameSpecifierLocBuilder &Other);\n\n  NestedNameSpecifierLocBuilder &\n  operator=(const NestedNameSpecifierLocBuilder &Other);\n\n  ~NestedNameSpecifierLocBuilder() {\n    if (BufferCapacity)\n      free(Buffer);\n  }\n\n  /// Retrieve the representation of the nested-name-specifier.\n  NestedNameSpecifier *getRepresentation() const { return Representation; }\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'type::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param TemplateKWLoc The location of the 'template' keyword, if present.\n  ///\n  /// \\param TL The TypeLoc that describes the type preceding the '::'.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, SourceLocation TemplateKWLoc, TypeLoc TL,\n              SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'identifier::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Identifier The identifier.\n  ///\n  /// \\param IdentifierLoc The location of the identifier.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, IdentifierInfo *Identifier,\n              SourceLocation IdentifierLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Namespace The namespace.\n  ///\n  /// \\param NamespaceLoc The location of the namespace name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceDecl *Namespace,\n              SourceLocation NamespaceLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace-alias::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Alias The namespace alias.\n  ///\n  /// \\param AliasLoc The location of the namespace alias\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceAliasDecl *Alias,\n              SourceLocation AliasLoc, SourceLocation ColonColonLoc);\n\n  /// Turn this (empty) nested-name-specifier into the global\n  /// nested-name-specifier '::'.\n  void MakeGlobal(ASTContext &Context, SourceLocation ColonColonLoc);\n\n  /// Turns this (empty) nested-name-specifier into '__super'\n  /// nested-name-specifier.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param RD The declaration of the class in which nested-name-specifier\n  /// appeared.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void MakeSuper(ASTContext &Context, CXXRecordDecl *RD,\n                 SourceLocation SuperLoc, SourceLocation ColonColonLoc);\n\n  /// Make a new nested-name-specifier from incomplete source-location\n  /// information.\n  ///\n  /// This routine should be used very, very rarely, in cases where we\n  /// need to synthesize a nested-name-specifier. Most code should instead use\n  /// \\c Adopt() with a proper \\c NestedNameSpecifierLoc.\n  void MakeTrivial(ASTContext &Context, NestedNameSpecifier *Qualifier,\n                   SourceRange R);\n\n  /// Adopt an existing nested-name-specifier (with source-range\n  /// information).\n  void Adopt(NestedNameSpecifierLoc Other);\n\n  /// Retrieve the source range covered by this nested-name-specifier.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return NestedNameSpecifierLoc(Representation, Buffer).getSourceRange();\n  }\n\n  /// Retrieve a nested-name-specifier with location information,\n  /// copied into the given AST context.\n  ///\n  /// \\param Context The context into which this nested-name-specifier will be\n  /// copied.\n  NestedNameSpecifierLoc getWithLocInContext(ASTContext &Context) const;\n\n  /// Retrieve a nested-name-specifier with location\n  /// information based on the information in this builder.\n  ///\n  /// This loc will contain references to the builder's internal data and may\n  /// be invalidated by any change to the builder.\n  NestedNameSpecifierLoc getTemporary() const {\n    return NestedNameSpecifierLoc(Representation, Buffer);\n  }\n\n  /// Clear out this builder, and prepare it to build another\n  /// nested-name-specifier with source-location information.\n  void Clear() {\n    Representation = nullptr;\n    BufferSize = 0;\n  }\n\n  /// Retrieve the underlying buffer.\n  ///\n  /// \\returns A pair containing a pointer to the buffer of source-location\n  /// data and the size of the source-location data that resides in that\n  /// buffer.\n  std::pair<char *, unsigned> getBuffer() const {\n    return std::make_pair(Buffer, BufferSize);\n  }\n};\n\n/// Insertion operator for diagnostics.  This allows sending\n/// NestedNameSpecifiers into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             NestedNameSpecifier *NNS) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(NNS),\n                  DiagnosticsEngine::ak_nestednamespec);\n  return DB;\n}\n\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <> struct DenseMapInfo<clang::NestedNameSpecifierLoc> {\n  using FirstInfo = DenseMapInfo<clang::NestedNameSpecifier *>;\n  using SecondInfo = DenseMapInfo<void *>;\n\n  static clang::NestedNameSpecifierLoc getEmptyKey() {\n    return clang::NestedNameSpecifierLoc(FirstInfo::getEmptyKey(),\n                                         SecondInfo::getEmptyKey());\n  }\n\n  static clang::NestedNameSpecifierLoc getTombstoneKey() {\n    return clang::NestedNameSpecifierLoc(FirstInfo::getTombstoneKey(),\n                                         SecondInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const clang::NestedNameSpecifierLoc &PairVal) {\n    return hash_combine(\n        FirstInfo::getHashValue(PairVal.getNestedNameSpecifier()),\n        SecondInfo::getHashValue(PairVal.getOpaqueData()));\n  }\n\n  static bool isEqual(const clang::NestedNameSpecifierLoc &LHS,\n                      const clang::NestedNameSpecifierLoc &RHS) {\n    return LHS == RHS;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/RawCommentList.h", "content": "//===--- RawCommentList.h - Classes for processing raw comments -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_RAWCOMMENTLIST_H\n#define LLVM_CLANG_AST_RAWCOMMENTLIST_H\n\n#include \"clang/Basic/CommentOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <map>\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTReader;\nclass Decl;\nclass DiagnosticsEngine;\nclass Preprocessor;\nclass SourceManager;\n\nnamespace comments {\n  class FullComment;\n} // end namespace comments\n\nclass RawComment {\npublic:\n  enum CommentKind {\n    RCK_Invalid,      ///< Invalid comment\n    RCK_OrdinaryBCPL, ///< Any normal BCPL comments\n    RCK_OrdinaryC,    ///< Any normal C comment\n    RCK_BCPLSlash,    ///< \\code /// stuff \\endcode\n    RCK_BCPLExcl,     ///< \\code //! stuff \\endcode\n    RCK_JavaDoc,      ///< \\code /** stuff */ \\endcode\n    RCK_Qt,           ///< \\code /*! stuff */ \\endcode, also used by HeaderDoc\n    RCK_Merged        ///< Two or more documentation comments merged together\n  };\n\n  RawComment() : Kind(RCK_Invalid), IsAlmostTrailingComment(false) { }\n\n  RawComment(const SourceManager &SourceMgr, SourceRange SR,\n             const CommentOptions &CommentOpts, bool Merged);\n\n  CommentKind getKind() const LLVM_READONLY {\n    return (CommentKind) Kind;\n  }\n\n  bool isInvalid() const LLVM_READONLY {\n    return Kind == RCK_Invalid;\n  }\n\n  bool isMerged() const LLVM_READONLY {\n    return Kind == RCK_Merged;\n  }\n\n  /// Is this comment attached to any declaration?\n  bool isAttached() const LLVM_READONLY {\n    return IsAttached;\n  }\n\n  void setAttached() {\n    IsAttached = true;\n  }\n\n  /// Returns true if it is a comment that should be put after a member:\n  /// \\code ///< stuff \\endcode\n  /// \\code //!< stuff \\endcode\n  /// \\code /**< stuff */ \\endcode\n  /// \\code /*!< stuff */ \\endcode\n  bool isTrailingComment() const LLVM_READONLY {\n    return IsTrailingComment;\n  }\n\n  /// Returns true if it is a probable typo:\n  /// \\code //< stuff \\endcode\n  /// \\code /*< stuff */ \\endcode\n  bool isAlmostTrailingComment() const LLVM_READONLY {\n    return IsAlmostTrailingComment;\n  }\n\n  /// Returns true if this comment is not a documentation comment.\n  bool isOrdinary() const LLVM_READONLY {\n    return ((Kind == RCK_OrdinaryBCPL) || (Kind == RCK_OrdinaryC));\n  }\n\n  /// Returns true if this comment any kind of a documentation comment.\n  bool isDocumentation() const LLVM_READONLY {\n    return !isInvalid() && !isOrdinary();\n  }\n\n  /// Returns raw comment text with comment markers.\n  StringRef getRawText(const SourceManager &SourceMgr) const {\n    if (RawTextValid)\n      return RawText;\n\n    RawText = getRawTextSlow(SourceMgr);\n    RawTextValid = true;\n    return RawText;\n  }\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  const char *getBriefText(const ASTContext &Context) const {\n    if (BriefTextValid)\n      return BriefText;\n\n    return extractBriefText(Context);\n  }\n\n  /// Returns sanitized comment text, suitable for presentation in editor UIs.\n  /// E.g. will transform:\n  ///     // This is a long multiline comment.\n  ///     //   Parts of it  might be indented.\n  ///     /* The comments styles might be mixed. */\n  ///  into\n  ///     \"This is a long multiline comment.\\n\"\n  ///     \"  Parts of it  might be indented.\\n\"\n  ///     \"The comments styles might be mixed.\"\n  /// Also removes leading indentation and sanitizes some common cases:\n  ///     /* This is a first line.\n  ///      *   This is a second line. It is indented.\n  ///      * This is a third line. */\n  /// and\n  ///     /* This is a first line.\n  ///          This is a second line. It is indented.\n  ///     This is a third line. */\n  /// will both turn into:\n  ///     \"This is a first line.\\n\"\n  ///     \"  This is a second line. It is indented.\\n\"\n  ///     \"This is a third line.\"\n  std::string getFormattedText(const SourceManager &SourceMgr,\n                               DiagnosticsEngine &Diags) const;\n\n  /// Parse the comment, assuming it is attached to decl \\c D.\n  comments::FullComment *parse(const ASTContext &Context,\n                               const Preprocessor *PP, const Decl *D) const;\n\nprivate:\n  SourceRange Range;\n\n  mutable StringRef RawText;\n  mutable const char *BriefText;\n\n  mutable bool RawTextValid : 1;   ///< True if RawText is valid\n  mutable bool BriefTextValid : 1; ///< True if BriefText is valid\n\n  unsigned Kind : 3;\n\n  /// True if comment is attached to a declaration in ASTContext.\n  bool IsAttached : 1;\n\n  bool IsTrailingComment : 1;\n  bool IsAlmostTrailingComment : 1;\n\n  /// Constructor for AST deserialization.\n  RawComment(SourceRange SR, CommentKind K, bool IsTrailingComment,\n             bool IsAlmostTrailingComment) :\n    Range(SR), RawTextValid(false), BriefTextValid(false), Kind(K),\n    IsAttached(false), IsTrailingComment(IsTrailingComment),\n    IsAlmostTrailingComment(IsAlmostTrailingComment)\n  { }\n\n  StringRef getRawTextSlow(const SourceManager &SourceMgr) const;\n\n  const char *extractBriefText(const ASTContext &Context) const;\n\n  friend class ASTReader;\n};\n\n/// This class represents all comments included in the translation unit,\n/// sorted in order of appearance in the translation unit.\nclass RawCommentList {\npublic:\n  RawCommentList(SourceManager &SourceMgr) : SourceMgr(SourceMgr) {}\n\n  void addComment(const RawComment &RC, const CommentOptions &CommentOpts,\n                  llvm::BumpPtrAllocator &Allocator);\n\n  /// \\returns A mapping from an offset of the start of the comment to the\n  /// comment itself, or nullptr in case there are no comments in \\p File.\n  const std::map<unsigned, RawComment *> *getCommentsInFile(FileID File) const;\n\n  bool empty() const;\n\n  unsigned getCommentBeginLine(RawComment *C, FileID File,\n                               unsigned Offset) const;\n  unsigned getCommentEndOffset(RawComment *C) const;\n\nprivate:\n  SourceManager &SourceMgr;\n  // mapping: FileId -> comment begin offset -> comment\n  llvm::DenseMap<FileID, std::map<unsigned, RawComment *>> OrderedComments;\n  mutable llvm::DenseMap<RawComment *, unsigned> CommentBeginLine;\n  mutable llvm::DenseMap<RawComment *, unsigned> CommentEndOffset;\n\n  friend class ASTReader;\n  friend class ASTWriter;\n};\n\n} // end namespace clang\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "content": "//===- Redeclarable.h - Base for Decls that can be redeclared --*- C++ -*-====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Redeclarable interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_REDECLARABLE_H\n#define LLVM_CLANG_AST_REDECLARABLE_H\n\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\n\n// Some notes on redeclarables:\n//\n//  - Every redeclarable is on a circular linked list.\n//\n//  - Every decl has a pointer to the first element of the chain _and_ a\n//    DeclLink that may point to one of 3 possible states:\n//      - the \"previous\" (temporal) element in the chain\n//      - the \"latest\" (temporal) element in the chain\n//      - the \"uninitialized-latest\" value (when newly-constructed)\n//\n//  - The first element is also often called the canonical element. Every\n//    element has a pointer to it so that \"getCanonical\" can be fast.\n//\n//  - Most links in the chain point to previous, except the link out of\n//    the first; it points to latest.\n//\n//  - Elements are called \"first\", \"previous\", \"latest\" or\n//    \"most-recent\" when referring to temporal order: order of addition\n//    to the chain.\n//\n//  - It's easiest to just ignore the implementation of DeclLink when making\n//    sense of the redeclaration chain.\n//\n//  - There's also a \"definition\" link for several types of\n//    redeclarable, where only one definition should exist at any given\n//    time (and the defn pointer is stored in the decl's \"data\" which\n//    is copied to every element on the chain when it's changed).\n//\n//    Here is some ASCII art:\n//\n//      \"first\"                                     \"latest\"\n//      \"canonical\"                                 \"most recent\"\n//      +------------+         first                +--------------+\n//      |            | <--------------------------- |              |\n//      |            |                              |              |\n//      |            |                              |              |\n//      |            |       +--------------+       |              |\n//      |            | first |              |       |              |\n//      |            | <---- |              |       |              |\n//      |            |       |              |       |              |\n//      | @class A   |  link | @interface A |  link | @class A     |\n//      | seen first | <---- | seen second  | <---- | seen third   |\n//      |            |       |              |       |              |\n//      +------------+       +--------------+       +--------------+\n//      | data       | defn  | data         |  defn | data         |\n//      |            | ----> |              | <---- |              |\n//      +------------+       +--------------+       +--------------+\n//        |                     |     ^                  ^\n//        |                     |defn |                  |\n//        | link                +-----+                  |\n//        +-->-------------------------------------------+\n\n/// Provides common interface for the Decls that can be redeclared.\ntemplate<typename decl_type>\nclass Redeclarable {\nprotected:\n  class DeclLink {\n    /// A pointer to a known latest declaration, either statically known or\n    /// generationally updated as decls are added by an external source.\n    using KnownLatest =\n        LazyGenerationalUpdatePtr<const Decl *, Decl *,\n                                  &ExternalASTSource::CompleteRedeclChain>;\n\n    /// We store a pointer to the ASTContext in the UninitializedLatest\n    /// pointer, but to avoid circular type dependencies when we steal the low\n    /// bits of this pointer, we use a raw void* here.\n    using UninitializedLatest = const void *;\n\n    using Previous = Decl *;\n\n    /// A pointer to either an uninitialized latest declaration (where either\n    /// we've not yet set the previous decl or there isn't one), or to a known\n    /// previous declaration.\n    using NotKnownLatest = llvm::PointerUnion<Previous, UninitializedLatest>;\n\n    mutable llvm::PointerUnion<NotKnownLatest, KnownLatest> Link;\n\n  public:\n    enum PreviousTag { PreviousLink };\n    enum LatestTag { LatestLink };\n\n    DeclLink(LatestTag, const ASTContext &Ctx)\n        : Link(NotKnownLatest(reinterpret_cast<UninitializedLatest>(&Ctx))) {}\n    DeclLink(PreviousTag, decl_type *D) : Link(NotKnownLatest(Previous(D))) {}\n\n    bool isFirst() const {\n      return Link.is<KnownLatest>() ||\n             // FIXME: 'template' is required on the next line due to an\n             // apparent clang bug.\n             Link.get<NotKnownLatest>().template is<UninitializedLatest>();\n    }\n\n    decl_type *getPrevious(const decl_type *D) const {\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        if (NKL.is<Previous>())\n          return static_cast<decl_type*>(NKL.get<Previous>());\n\n        // Allocate the generational 'most recent' cache now, if needed.\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           const_cast<decl_type *>(D));\n      }\n\n      return static_cast<decl_type*>(Link.get<KnownLatest>().get(D));\n    }\n\n    void setPrevious(decl_type *D) {\n      assert(!isFirst() && \"decl became non-canonical unexpectedly\");\n      Link = Previous(D);\n    }\n\n    void setLatest(decl_type *D) {\n      assert(isFirst() && \"decl became canonical unexpectedly\");\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           D);\n      } else {\n        auto Latest = Link.get<KnownLatest>();\n        Latest.set(D);\n        Link = Latest;\n      }\n    }\n\n    void markIncomplete() { Link.get<KnownLatest>().markIncomplete(); }\n\n    Decl *getLatestNotUpdated() const {\n      assert(isFirst() && \"expected a canonical decl\");\n      if (Link.is<NotKnownLatest>())\n        return nullptr;\n      return Link.get<KnownLatest>().getNotUpdated();\n    }\n  };\n\n  static DeclLink PreviousDeclLink(decl_type *D) {\n    return DeclLink(DeclLink::PreviousLink, D);\n  }\n\n  static DeclLink LatestDeclLink(const ASTContext &Ctx) {\n    return DeclLink(DeclLink::LatestLink, Ctx);\n  }\n\n  /// Points to the next redeclaration in the chain.\n  ///\n  /// If isFirst() is false, this is a link to the previous declaration\n  /// of this same Decl. If isFirst() is true, this is the first\n  /// declaration and Link points to the latest declaration. For example:\n  ///\n  ///  #1 int f(int x, int y = 1); // <pointer to #3, true>\n  ///  #2 int f(int x = 0, int y); // <pointer to #1, false>\n  ///  #3 int f(int x, int y) { return x + y; } // <pointer to #2, false>\n  ///\n  /// If there is only one declaration, it is <pointer to self, true>\n  DeclLink RedeclLink;\n\n  decl_type *First;\n\n  decl_type *getNextRedeclaration() const {\n    return RedeclLink.getPrevious(static_cast<const decl_type *>(this));\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  Redeclarable(const ASTContext &Ctx)\n      : RedeclLink(LatestDeclLink(Ctx)),\n        First(static_cast<decl_type *>(this)) {}\n\n  /// Return the previous declaration of this declaration or NULL if this\n  /// is the first declaration.\n  decl_type *getPreviousDecl() {\n    if (!RedeclLink.isFirst())\n      return getNextRedeclaration();\n    return nullptr;\n  }\n  const decl_type *getPreviousDecl() const {\n    return const_cast<decl_type *>(\n                 static_cast<const decl_type*>(this))->getPreviousDecl();\n  }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  decl_type *getFirstDecl() { return First; }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  const decl_type *getFirstDecl() const { return First; }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const { return RedeclLink.isFirst(); }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  decl_type *getMostRecentDecl() {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  const decl_type *getMostRecentDecl() const {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Set the previous declaration. If PrevDecl is NULL, set this as the\n  /// first and only declaration.\n  void setPreviousDecl(decl_type *PrevDecl);\n\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    decl_type *Current = nullptr;\n    decl_type *Starter;\n    bool PassedFirst = false;\n\n  public:\n    using value_type = decl_type *;\n    using reference = decl_type *;\n    using pointer = decl_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(decl_type *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Sanity check to avoid infinite loop on invalid redecl chain.\n      if (Current->isFirstDecl()) {\n        if (PassedFirst) {\n          assert(0 && \"Passed first decl twice, invalid redecl chain!\");\n          Current = nullptr;\n          return *this;\n        }\n        PassedFirst = true;\n      }\n\n      // Get either previous decl or latest decl.\n      decl_type *Next = Current->getNextRedeclaration();\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecl_iterator(const_cast<decl_type *>(\n                            static_cast<const decl_type *>(this))),\n                        redecl_iterator());\n  }\n\n  redecl_iterator redecls_begin() const { return redecls().begin(); }\n  redecl_iterator redecls_end() const { return redecls().end(); }\n};\n\n/// Get the primary declaration for a declaration from an AST file. That\n/// will be the first-loaded declaration.\nDecl *getPrimaryMergedDecl(Decl *D);\n\n/// Provides common interface for the Decls that cannot be redeclared,\n/// but can be merged if the same declaration is brought in from multiple\n/// modules.\ntemplate<typename decl_type>\nclass Mergeable {\npublic:\n  Mergeable() = default;\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  decl_type *getFirstDecl() {\n    auto *D = static_cast<decl_type *>(this);\n    if (!D->isFromASTFile())\n      return D;\n    return cast<decl_type>(getPrimaryMergedDecl(const_cast<decl_type*>(D)));\n  }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  const decl_type *getFirstDecl() const {\n    const auto *D = static_cast<const decl_type *>(this);\n    if (!D->isFromASTFile())\n      return D;\n    return cast<decl_type>(getPrimaryMergedDecl(const_cast<decl_type*>(D)));\n  }\n\n  /// Returns true if this is the first declaration.\n  bool isFirstDecl() const { return getFirstDecl() == this; }\n};\n\n/// A wrapper class around a pointer that always points to its canonical\n/// declaration.\n///\n/// CanonicalDeclPtr<decl_type> behaves just like decl_type*, except we call\n/// decl_type::getCanonicalDecl() on construction.\n///\n/// This is useful for hashtables that you want to be keyed on a declaration's\n/// canonical decl -- if you use CanonicalDeclPtr as the key, you don't need to\n/// remember to call getCanonicalDecl() everywhere.\ntemplate <typename decl_type> class CanonicalDeclPtr {\npublic:\n  CanonicalDeclPtr() = default;\n  CanonicalDeclPtr(decl_type *Ptr)\n      : Ptr(Ptr ? Ptr->getCanonicalDecl() : nullptr) {}\n  CanonicalDeclPtr(const CanonicalDeclPtr &) = default;\n  CanonicalDeclPtr &operator=(const CanonicalDeclPtr &) = default;\n\n  operator decl_type *() { return Ptr; }\n  operator const decl_type *() const { return Ptr; }\n\n  decl_type *operator->() { return Ptr; }\n  const decl_type *operator->() const { return Ptr; }\n\n  decl_type &operator*() { return *Ptr; }\n  const decl_type &operator*() const { return *Ptr; }\n\n  friend bool operator==(CanonicalDeclPtr LHS, CanonicalDeclPtr RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n  friend bool operator!=(CanonicalDeclPtr LHS, CanonicalDeclPtr RHS) {\n    return LHS.Ptr != RHS.Ptr;\n  }\n\nprivate:\n  friend struct llvm::DenseMapInfo<CanonicalDeclPtr<decl_type>>;\n  friend struct llvm::PointerLikeTypeTraits<CanonicalDeclPtr<decl_type>>;\n\n  decl_type *Ptr = nullptr;\n};\n\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <typename decl_type>\nstruct DenseMapInfo<clang::CanonicalDeclPtr<decl_type>> {\n  using CanonicalDeclPtr = clang::CanonicalDeclPtr<decl_type>;\n  using BaseInfo = DenseMapInfo<decl_type *>;\n\n  static CanonicalDeclPtr getEmptyKey() {\n    // Construct our CanonicalDeclPtr this way because the regular constructor\n    // would dereference P.Ptr, which is not allowed.\n    CanonicalDeclPtr P;\n    P.Ptr = BaseInfo::getEmptyKey();\n    return P;\n  }\n\n  static CanonicalDeclPtr getTombstoneKey() {\n    CanonicalDeclPtr P;\n    P.Ptr = BaseInfo::getTombstoneKey();\n    return P;\n  }\n\n  static unsigned getHashValue(const CanonicalDeclPtr &P) {\n    return BaseInfo::getHashValue(P);\n  }\n\n  static bool isEqual(const CanonicalDeclPtr &LHS,\n                      const CanonicalDeclPtr &RHS) {\n    return BaseInfo::isEqual(LHS, RHS);\n  }\n};\n\ntemplate <typename decl_type>\nstruct PointerLikeTypeTraits<clang::CanonicalDeclPtr<decl_type>> {\n  static inline void *getAsVoidPointer(clang::CanonicalDeclPtr<decl_type> P) {\n    return P.Ptr;\n  }\n  static inline clang::CanonicalDeclPtr<decl_type> getFromVoidPointer(void *P) {\n    clang::CanonicalDeclPtr<decl_type> C;\n    C.Ptr = PointerLikeTypeTraits<decl_type *>::getFromVoidPtr(P);\n    return C;\n  }\n  static constexpr int NumLowBitsAvailable =\n      PointerLikeTypeTraits<decl_type *>::NumLowBitsAvailable;\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_REDECLARABLE_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "content": "//===- Stmt.h - Classes for representing statements -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Stmt interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMT_H\n#define LLVM_CLANG_AST_STMT_H\n\n#include \"clang/AST/DeclGroup.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/StmtIterator.h\"\n#include \"clang/Basic/CapturedStmt.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <string>\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\nclass Attr;\nclass CapturedDecl;\nclass Decl;\nclass Expr;\nclass AddrLabelExpr;\nclass LabelDecl;\nclass ODRHash;\nclass PrinterHelper;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass SourceManager;\nclass StringLiteral;\nclass Token;\nclass VarDecl;\n\n//===----------------------------------------------------------------------===//\n// AST classes for statements.\n//===----------------------------------------------------------------------===//\n\n/// Stmt - This represents one statement.\n///\nclass alignas(void *) Stmt {\npublic:\n  enum StmtClass {\n    NoStmtClass = 0,\n#define STMT(CLASS, PARENT) CLASS##Class,\n#define STMT_RANGE(BASE, FIRST, LAST) \\\n        first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class,\n#define LAST_STMT_RANGE(BASE, FIRST, LAST) \\\n        first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class\n#define ABSTRACT_STMT(STMT)\n#include \"clang/AST/StmtNodes.inc\"\n  };\n\n  // Make vanilla 'new' and 'delete' illegal for Stmts.\nprotected:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  void *operator new(size_t bytes) noexcept {\n    llvm_unreachable(\"Stmts cannot be allocated with regular 'new'.\");\n  }\n\n  void operator delete(void *data) noexcept {\n    llvm_unreachable(\"Stmts cannot be released with regular 'delete'.\");\n  }\n\n  //===--- Statement bitfields classes ---===//\n\n  class StmtBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class Stmt;\n\n    /// The statement class.\n    unsigned sClass : 8;\n  };\n  enum { NumStmtBits = 8 };\n\n  class NullStmtBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class NullStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if the null statement was preceded by an empty macro, e.g:\n    /// @code\n    ///   #define CALL(x)\n    ///   CALL(0);\n    /// @endcode\n    unsigned HasLeadingEmptyMacro : 1;\n\n    /// The location of the semi-colon.\n    SourceLocation SemiLoc;\n  };\n\n  class CompoundStmtBitfields {\n    friend class ASTStmtReader;\n    friend class CompoundStmt;\n\n    unsigned : NumStmtBits;\n\n    unsigned NumStmts : 32 - NumStmtBits;\n\n    /// The location of the opening \"{\".\n    SourceLocation LBraceLoc;\n  };\n\n  class LabelStmtBitfields {\n    friend class LabelStmt;\n\n    unsigned : NumStmtBits;\n\n    SourceLocation IdentLoc;\n  };\n\n  class AttributedStmtBitfields {\n    friend class ASTStmtReader;\n    friend class AttributedStmt;\n\n    unsigned : NumStmtBits;\n\n    /// Number of attributes.\n    unsigned NumAttrs : 32 - NumStmtBits;\n\n    /// The location of the attribute.\n    SourceLocation AttrLoc;\n  };\n\n  class IfStmtBitfields {\n    friend class ASTStmtReader;\n    friend class IfStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if this if statement is a constexpr if.\n    unsigned IsConstexpr : 1;\n\n    /// True if this if statement has storage for an else statement.\n    unsigned HasElse : 1;\n\n    /// True if this if statement has storage for a variable declaration.\n    unsigned HasVar : 1;\n\n    /// True if this if statement has storage for an init statement.\n    unsigned HasInit : 1;\n\n    /// The location of the \"if\".\n    SourceLocation IfLoc;\n  };\n\n  class SwitchStmtBitfields {\n    friend class SwitchStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if the SwitchStmt has storage for an init statement.\n    unsigned HasInit : 1;\n\n    /// True if the SwitchStmt has storage for a condition variable.\n    unsigned HasVar : 1;\n\n    /// If the SwitchStmt is a switch on an enum value, records whether all\n    /// the enum values were covered by CaseStmts.  The coverage information\n    /// value is meant to be a hint for possible clients.\n    unsigned AllEnumCasesCovered : 1;\n\n    /// The location of the \"switch\".\n    SourceLocation SwitchLoc;\n  };\n\n  class WhileStmtBitfields {\n    friend class ASTStmtReader;\n    friend class WhileStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if the WhileStmt has storage for a condition variable.\n    unsigned HasVar : 1;\n\n    /// The location of the \"while\".\n    SourceLocation WhileLoc;\n  };\n\n  class DoStmtBitfields {\n    friend class DoStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"do\".\n    SourceLocation DoLoc;\n  };\n\n  class ForStmtBitfields {\n    friend class ForStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"for\".\n    SourceLocation ForLoc;\n  };\n\n  class GotoStmtBitfields {\n    friend class GotoStmt;\n    friend class IndirectGotoStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"goto\".\n    SourceLocation GotoLoc;\n  };\n\n  class ContinueStmtBitfields {\n    friend class ContinueStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"continue\".\n    SourceLocation ContinueLoc;\n  };\n\n  class BreakStmtBitfields {\n    friend class BreakStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"break\".\n    SourceLocation BreakLoc;\n  };\n\n  class ReturnStmtBitfields {\n    friend class ReturnStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if this ReturnStmt has storage for an NRVO candidate.\n    unsigned HasNRVOCandidate : 1;\n\n    /// The location of the \"return\".\n    SourceLocation RetLoc;\n  };\n\n  class SwitchCaseBitfields {\n    friend class SwitchCase;\n    friend class CaseStmt;\n\n    unsigned : NumStmtBits;\n\n    /// Used by CaseStmt to store whether it is a case statement\n    /// of the form case LHS ... RHS (a GNU extension).\n    unsigned CaseStmtIsGNURange : 1;\n\n    /// The location of the \"case\" or \"default\" keyword.\n    SourceLocation KeywordLoc;\n  };\n\n  //===--- Expression bitfields classes ---===//\n\n  class ExprBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class AtomicExpr; // ctor\n    friend class BlockDeclRefExpr; // ctor\n    friend class CallExpr; // ctor\n    friend class CXXConstructExpr; // ctor\n    friend class CXXDependentScopeMemberExpr; // ctor\n    friend class CXXNewExpr; // ctor\n    friend class CXXUnresolvedConstructExpr; // ctor\n    friend class DeclRefExpr; // computeDependence\n    friend class DependentScopeDeclRefExpr; // ctor\n    friend class DesignatedInitExpr; // ctor\n    friend class Expr;\n    friend class InitListExpr; // ctor\n    friend class ObjCArrayLiteral; // ctor\n    friend class ObjCDictionaryLiteral; // ctor\n    friend class ObjCMessageExpr; // ctor\n    friend class OffsetOfExpr; // ctor\n    friend class OpaqueValueExpr; // ctor\n    friend class OverloadExpr; // ctor\n    friend class ParenListExpr; // ctor\n    friend class PseudoObjectExpr; // ctor\n    friend class ShuffleVectorExpr; // ctor\n\n    unsigned : NumStmtBits;\n\n    unsigned ValueKind : 2;\n    unsigned ObjectKind : 3;\n    unsigned /*ExprDependence*/ Dependent : llvm::BitWidth<ExprDependence>;\n  };\n  enum { NumExprBits = NumStmtBits + 5 + llvm::BitWidth<ExprDependence> };\n\n  class ConstantExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class ConstantExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of result that is tail-allocated.\n    unsigned ResultKind : 2;\n\n    /// The kind of Result as defined by APValue::Kind.\n    unsigned APValueKind : 4;\n\n    /// When ResultKind == RSK_Int64, true if the tail-allocated integer is\n    /// unsigned.\n    unsigned IsUnsigned : 1;\n\n    /// When ResultKind == RSK_Int64. the BitWidth of the tail-allocated\n    /// integer. 7 bits because it is the minimal number of bits to represent a\n    /// value from 0 to 64 (the size of the tail-allocated integer).\n    unsigned BitWidth : 7;\n\n    /// When ResultKind == RSK_APValue, true if the ASTContext will cleanup the\n    /// tail-allocated APValue.\n    unsigned HasCleanup : 1;\n\n    /// True if this ConstantExpr was created for immediate invocation.\n    unsigned IsImmediateInvocation : 1;\n  };\n\n  class PredefinedExprBitfields {\n    friend class ASTStmtReader;\n    friend class PredefinedExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of this PredefinedExpr. One of the enumeration values\n    /// in PredefinedExpr::IdentKind.\n    unsigned Kind : 4;\n\n    /// True if this PredefinedExpr has a trailing \"StringLiteral *\"\n    /// for the predefined identifier.\n    unsigned HasFunctionName : 1;\n\n    /// The location of this PredefinedExpr.\n    SourceLocation Loc;\n  };\n\n  class DeclRefExprBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class DeclRefExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned HasQualifier : 1;\n    unsigned HasTemplateKWAndArgsInfo : 1;\n    unsigned HasFoundDecl : 1;\n    unsigned HadMultipleCandidates : 1;\n    unsigned RefersToEnclosingVariableOrCapture : 1;\n    unsigned NonOdrUseReason : 2;\n\n    /// The location of the declaration name itself.\n    SourceLocation Loc;\n  };\n\n\n  class FloatingLiteralBitfields {\n    friend class FloatingLiteral;\n\n    unsigned : NumExprBits;\n\n    unsigned Semantics : 3; // Provides semantics for APFloat construction\n    unsigned IsExact : 1;\n  };\n\n  class StringLiteralBitfields {\n    friend class ASTStmtReader;\n    friend class StringLiteral;\n\n    unsigned : NumExprBits;\n\n    /// The kind of this string literal.\n    /// One of the enumeration values of StringLiteral::StringKind.\n    unsigned Kind : 3;\n\n    /// The width of a single character in bytes. Only values of 1, 2,\n    /// and 4 bytes are supported. StringLiteral::mapCharByteWidth maps\n    /// the target + string kind to the appropriate CharByteWidth.\n    unsigned CharByteWidth : 3;\n\n    unsigned IsPascal : 1;\n\n    /// The number of concatenated token this string is made of.\n    /// This is the number of trailing SourceLocation.\n    unsigned NumConcatenated;\n  };\n\n  class CharacterLiteralBitfields {\n    friend class CharacterLiteral;\n\n    unsigned : NumExprBits;\n\n    unsigned Kind : 3;\n  };\n\n  class UnaryOperatorBitfields {\n    friend class UnaryOperator;\n\n    unsigned : NumExprBits;\n\n    unsigned Opc : 5;\n    unsigned CanOverflow : 1;\n    //\n    /// This is only meaningful for operations on floating point\n    /// types when additional values need to be in trailing storage.\n    /// It is 0 otherwise.\n    unsigned HasFPFeatures : 1;\n\n    SourceLocation Loc;\n  };\n\n  class UnaryExprOrTypeTraitExprBitfields {\n    friend class UnaryExprOrTypeTraitExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Kind : 3;\n    unsigned IsType : 1; // true if operand is a type, false if an expression.\n  };\n\n  class ArrayOrMatrixSubscriptExprBitfields {\n    friend class ArraySubscriptExpr;\n    friend class MatrixSubscriptExpr;\n\n    unsigned : NumExprBits;\n\n    SourceLocation RBracketLoc;\n  };\n\n  class CallExprBitfields {\n    friend class CallExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned NumPreArgs : 1;\n\n    /// True if the callee of the call expression was found using ADL.\n    unsigned UsesADL : 1;\n\n    /// True if the call expression has some floating-point features.\n    unsigned HasFPFeatures : 1;\n\n    /// Padding used to align OffsetToTrailingObjects to a byte multiple.\n    unsigned : 24 - 3 - NumExprBits;\n\n    /// The offset in bytes from the this pointer to the start of the\n    /// trailing objects belonging to CallExpr. Intentionally byte sized\n    /// for faster access.\n    unsigned OffsetToTrailingObjects : 8;\n  };\n  enum { NumCallExprBits = 32 };\n\n  class MemberExprBitfields {\n    friend class ASTStmtReader;\n    friend class MemberExpr;\n\n    unsigned : NumExprBits;\n\n    /// IsArrow - True if this is \"X->F\", false if this is \"X.F\".\n    unsigned IsArrow : 1;\n\n    /// True if this member expression used a nested-name-specifier to\n    /// refer to the member, e.g., \"x->Base::f\", or found its member via\n    /// a using declaration.  When true, a MemberExprNameQualifier\n    /// structure is allocated immediately after the MemberExpr.\n    unsigned HasQualifierOrFoundDecl : 1;\n\n    /// True if this member expression specified a template keyword\n    /// and/or a template argument list explicitly, e.g., x->f<int>,\n    /// x->template f, x->template f<int>.\n    /// When true, an ASTTemplateKWAndArgsInfo structure and its\n    /// TemplateArguments (if any) are present.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n\n    /// True if this member expression refers to a method that\n    /// was resolved from an overloaded set having size greater than 1.\n    unsigned HadMultipleCandidates : 1;\n\n    /// Value of type NonOdrUseReason indicating why this MemberExpr does\n    /// not constitute an odr-use of the named declaration. Meaningful only\n    /// when naming a static member.\n    unsigned NonOdrUseReason : 2;\n\n    /// This is the location of the -> or . in the expression.\n    SourceLocation OperatorLoc;\n  };\n\n  class CastExprBitfields {\n    friend class CastExpr;\n    friend class ImplicitCastExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Kind : 6;\n    unsigned PartOfExplicitCast : 1; // Only set for ImplicitCastExpr.\n\n    /// True if the call expression has some floating-point features.\n    unsigned HasFPFeatures : 1;\n\n    /// The number of CXXBaseSpecifiers in the cast. 14 bits would be enough\n    /// here. ([implimits] Direct and indirect base classes [16384]).\n    unsigned BasePathSize;\n  };\n\n  class BinaryOperatorBitfields {\n    friend class BinaryOperator;\n\n    unsigned : NumExprBits;\n\n    unsigned Opc : 6;\n\n    /// This is only meaningful for operations on floating point\n    /// types when additional values need to be in trailing storage.\n    /// It is 0 otherwise.\n    unsigned HasFPFeatures : 1;\n\n    SourceLocation OpLoc;\n  };\n\n  class InitListExprBitfields {\n    friend class InitListExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether this initializer list originally had a GNU array-range\n    /// designator in it. This is a temporary marker used by CodeGen.\n    unsigned HadArrayRangeDesignator : 1;\n  };\n\n  class ParenListExprBitfields {\n    friend class ASTStmtReader;\n    friend class ParenListExpr;\n\n    unsigned : NumExprBits;\n\n    /// The number of expressions in the paren list.\n    unsigned NumExprs;\n  };\n\n  class GenericSelectionExprBitfields {\n    friend class ASTStmtReader;\n    friend class GenericSelectionExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location of the \"_Generic\".\n    SourceLocation GenericLoc;\n  };\n\n  class PseudoObjectExprBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class PseudoObjectExpr;\n\n    unsigned : NumExprBits;\n\n    // These don't need to be particularly wide, because they're\n    // strictly limited by the forms of expressions we permit.\n    unsigned NumSubExprs : 8;\n    unsigned ResultIndex : 32 - 8 - NumExprBits;\n  };\n\n  class SourceLocExprBitfields {\n    friend class ASTStmtReader;\n    friend class SourceLocExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of source location builtin represented by the SourceLocExpr.\n    /// Ex. __builtin_LINE, __builtin_FUNCTION, ect.\n    unsigned Kind : 2;\n  };\n\n  class StmtExprBitfields {\n    friend class ASTStmtReader;\n    friend class StmtExpr;\n\n    unsigned : NumExprBits;\n\n    /// The number of levels of template parameters enclosing this statement\n    /// expression. Used to determine if a statement expression remains\n    /// dependent after instantiation.\n    unsigned TemplateDepth;\n  };\n\n  //===--- C++ Expression bitfields classes ---===//\n\n  class CXXOperatorCallExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXOperatorCallExpr;\n\n    unsigned : NumCallExprBits;\n\n    /// The kind of this overloaded operator. One of the enumerator\n    /// value of OverloadedOperatorKind.\n    unsigned OperatorKind : 6;\n  };\n\n  class CXXRewrittenBinaryOperatorBitfields {\n    friend class ASTStmtReader;\n    friend class CXXRewrittenBinaryOperator;\n\n    unsigned : NumCallExprBits;\n\n    unsigned IsReversed : 1;\n  };\n\n  class CXXBoolLiteralExprBitfields {\n    friend class CXXBoolLiteralExpr;\n\n    unsigned : NumExprBits;\n\n    /// The value of the boolean literal.\n    unsigned Value : 1;\n\n    /// The location of the boolean literal.\n    SourceLocation Loc;\n  };\n\n  class CXXNullPtrLiteralExprBitfields {\n    friend class CXXNullPtrLiteralExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location of the null pointer literal.\n    SourceLocation Loc;\n  };\n\n  class CXXThisExprBitfields {\n    friend class CXXThisExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether this is an implicit \"this\".\n    unsigned IsImplicit : 1;\n\n    /// The location of the \"this\".\n    SourceLocation Loc;\n  };\n\n  class CXXThrowExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXThrowExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether the thrown variable (if any) is in scope.\n    unsigned IsThrownVariableInScope : 1;\n\n    /// The location of the \"throw\".\n    SourceLocation ThrowLoc;\n  };\n\n  class CXXDefaultArgExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDefaultArgExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location where the default argument expression was used.\n    SourceLocation Loc;\n  };\n\n  class CXXDefaultInitExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDefaultInitExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location where the default initializer expression was used.\n    SourceLocation Loc;\n  };\n\n  class CXXScalarValueInitExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXScalarValueInitExpr;\n\n    unsigned : NumExprBits;\n\n    SourceLocation RParenLoc;\n  };\n\n  class CXXNewExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class CXXNewExpr;\n\n    unsigned : NumExprBits;\n\n    /// Was the usage ::new, i.e. is the global new to be used?\n    unsigned IsGlobalNew : 1;\n\n    /// Do we allocate an array? If so, the first trailing \"Stmt *\" is the\n    /// size expression.\n    unsigned IsArray : 1;\n\n    /// Should the alignment be passed to the allocation function?\n    unsigned ShouldPassAlignment : 1;\n\n    /// If this is an array allocation, does the usual deallocation\n    /// function for the allocated type want to know the allocated size?\n    unsigned UsualArrayDeleteWantsSize : 1;\n\n    /// What kind of initializer do we have? Could be none, parens, or braces.\n    /// In storage, we distinguish between \"none, and no initializer expr\", and\n    /// \"none, but an implicit initializer expr\".\n    unsigned StoredInitializationStyle : 2;\n\n    /// True if the allocated type was expressed as a parenthesized type-id.\n    unsigned IsParenTypeId : 1;\n\n    /// The number of placement new arguments.\n    unsigned NumPlacementArgs;\n  };\n\n  class CXXDeleteExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDeleteExpr;\n\n    unsigned : NumExprBits;\n\n    /// Is this a forced global delete, i.e. \"::delete\"?\n    unsigned GlobalDelete : 1;\n\n    /// Is this the array form of delete, i.e. \"delete[]\"?\n    unsigned ArrayForm : 1;\n\n    /// ArrayFormAsWritten can be different from ArrayForm if 'delete' is\n    /// applied to pointer-to-array type (ArrayFormAsWritten will be false\n    /// while ArrayForm will be true).\n    unsigned ArrayFormAsWritten : 1;\n\n    /// Does the usual deallocation function for the element type require\n    /// a size_t argument?\n    unsigned UsualArrayDeleteWantsSize : 1;\n\n    /// Location of the expression.\n    SourceLocation Loc;\n  };\n\n  class TypeTraitExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class TypeTraitExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of type trait, which is a value of a TypeTrait enumerator.\n    unsigned Kind : 8;\n\n    /// If this expression is not value-dependent, this indicates whether\n    /// the trait evaluated true or false.\n    unsigned Value : 1;\n\n    /// The number of arguments to this type trait. According to [implimits]\n    /// 8 bits would be enough, but we require (and test for) at least 16 bits\n    /// to mirror FunctionType.\n    unsigned NumArgs;\n  };\n\n  class DependentScopeDeclRefExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class DependentScopeDeclRefExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether the name includes info for explicit template\n    /// keyword and arguments.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n  };\n\n  class CXXConstructExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXConstructExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Elidable : 1;\n    unsigned HadMultipleCandidates : 1;\n    unsigned ListInitialization : 1;\n    unsigned StdInitListInitialization : 1;\n    unsigned ZeroInitialization : 1;\n    unsigned ConstructionKind : 3;\n\n    SourceLocation Loc;\n  };\n\n  class ExprWithCleanupsBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class ExprWithCleanups;\n\n    unsigned : NumExprBits;\n\n    // When false, it must not have side effects.\n    unsigned CleanupsHaveSideEffects : 1;\n\n    unsigned NumObjects : 32 - 1 - NumExprBits;\n  };\n\n  class CXXUnresolvedConstructExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXUnresolvedConstructExpr;\n\n    unsigned : NumExprBits;\n\n    /// The number of arguments used to construct the type.\n    unsigned NumArgs;\n  };\n\n  class CXXDependentScopeMemberExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDependentScopeMemberExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether this member expression used the '->' operator or\n    /// the '.' operator.\n    unsigned IsArrow : 1;\n\n    /// Whether this member expression has info for explicit template\n    /// keyword and arguments.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n\n    /// See getFirstQualifierFoundInScope() and the comment listing\n    /// the trailing objects.\n    unsigned HasFirstQualifierFoundInScope : 1;\n\n    /// The location of the '->' or '.' operator.\n    SourceLocation OperatorLoc;\n  };\n\n  class OverloadExprBitfields {\n    friend class ASTStmtReader;\n    friend class OverloadExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether the name includes info for explicit template\n    /// keyword and arguments.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n\n    /// Padding used by the derived classes to store various bits. If you\n    /// need to add some data here, shrink this padding and add your data\n    /// above. NumOverloadExprBits also needs to be updated.\n    unsigned : 32 - NumExprBits - 1;\n\n    /// The number of results.\n    unsigned NumResults;\n  };\n  enum { NumOverloadExprBits = NumExprBits + 1 };\n\n  class UnresolvedLookupExprBitfields {\n    friend class ASTStmtReader;\n    friend class UnresolvedLookupExpr;\n\n    unsigned : NumOverloadExprBits;\n\n    /// True if these lookup results should be extended by\n    /// argument-dependent lookup if this is the operand of a function call.\n    unsigned RequiresADL : 1;\n\n    /// True if these lookup results are overloaded.  This is pretty trivially\n    /// rederivable if we urgently need to kill this field.\n    unsigned Overloaded : 1;\n  };\n  static_assert(sizeof(UnresolvedLookupExprBitfields) <= 4,\n                \"UnresolvedLookupExprBitfields must be <= than 4 bytes to\"\n                \"avoid trashing OverloadExprBitfields::NumResults!\");\n\n  class UnresolvedMemberExprBitfields {\n    friend class ASTStmtReader;\n    friend class UnresolvedMemberExpr;\n\n    unsigned : NumOverloadExprBits;\n\n    /// Whether this member expression used the '->' operator or\n    /// the '.' operator.\n    unsigned IsArrow : 1;\n\n    /// Whether the lookup results contain an unresolved using declaration.\n    unsigned HasUnresolvedUsing : 1;\n  };\n  static_assert(sizeof(UnresolvedMemberExprBitfields) <= 4,\n                \"UnresolvedMemberExprBitfields must be <= than 4 bytes to\"\n                \"avoid trashing OverloadExprBitfields::NumResults!\");\n\n  class CXXNoexceptExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXNoexceptExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Value : 1;\n  };\n\n  class SubstNonTypeTemplateParmExprBitfields {\n    friend class ASTStmtReader;\n    friend class SubstNonTypeTemplateParmExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location of the non-type template parameter reference.\n    SourceLocation NameLoc;\n  };\n\n  class LambdaExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class LambdaExpr;\n\n    unsigned : NumExprBits;\n\n    /// The default capture kind, which is a value of type\n    /// LambdaCaptureDefault.\n    unsigned CaptureDefault : 2;\n\n    /// Whether this lambda had an explicit parameter list vs. an\n    /// implicit (and empty) parameter list.\n    unsigned ExplicitParams : 1;\n\n    /// Whether this lambda had the result type explicitly specified.\n    unsigned ExplicitResultType : 1;\n\n    /// The number of captures.\n    unsigned NumCaptures : 16;\n  };\n\n  class RequiresExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class RequiresExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned IsSatisfied : 1;\n    SourceLocation RequiresKWLoc;\n  };\n\n  //===--- C++ Coroutines TS bitfields classes ---===//\n\n  class CoawaitExprBitfields {\n    friend class CoawaitExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned IsImplicit : 1;\n  };\n\n  //===--- Obj-C Expression bitfields classes ---===//\n\n  class ObjCIndirectCopyRestoreExprBitfields {\n    friend class ObjCIndirectCopyRestoreExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned ShouldCopy : 1;\n  };\n\n  //===--- Clang Extensions bitfields classes ---===//\n\n  class OpaqueValueExprBitfields {\n    friend class ASTStmtReader;\n    friend class OpaqueValueExpr;\n\n    unsigned : NumExprBits;\n\n    /// The OVE is a unique semantic reference to its source expression if this\n    /// bit is set to true.\n    unsigned IsUnique : 1;\n\n    SourceLocation Loc;\n  };\n\n  union {\n    // Same order as in StmtNodes.td.\n    // Statements\n    StmtBitfields StmtBits;\n    NullStmtBitfields NullStmtBits;\n    CompoundStmtBitfields CompoundStmtBits;\n    LabelStmtBitfields LabelStmtBits;\n    AttributedStmtBitfields AttributedStmtBits;\n    IfStmtBitfields IfStmtBits;\n    SwitchStmtBitfields SwitchStmtBits;\n    WhileStmtBitfields WhileStmtBits;\n    DoStmtBitfields DoStmtBits;\n    ForStmtBitfields ForStmtBits;\n    GotoStmtBitfields GotoStmtBits;\n    ContinueStmtBitfields ContinueStmtBits;\n    BreakStmtBitfields BreakStmtBits;\n    ReturnStmtBitfields ReturnStmtBits;\n    SwitchCaseBitfields SwitchCaseBits;\n\n    // Expressions\n    ExprBitfields ExprBits;\n    ConstantExprBitfields ConstantExprBits;\n    PredefinedExprBitfields PredefinedExprBits;\n    DeclRefExprBitfields DeclRefExprBits;\n    FloatingLiteralBitfields FloatingLiteralBits;\n    StringLiteralBitfields StringLiteralBits;\n    CharacterLiteralBitfields CharacterLiteralBits;\n    UnaryOperatorBitfields UnaryOperatorBits;\n    UnaryExprOrTypeTraitExprBitfields UnaryExprOrTypeTraitExprBits;\n    ArrayOrMatrixSubscriptExprBitfields ArrayOrMatrixSubscriptExprBits;\n    CallExprBitfields CallExprBits;\n    MemberExprBitfields MemberExprBits;\n    CastExprBitfields CastExprBits;\n    BinaryOperatorBitfields BinaryOperatorBits;\n    InitListExprBitfields InitListExprBits;\n    ParenListExprBitfields ParenListExprBits;\n    GenericSelectionExprBitfields GenericSelectionExprBits;\n    PseudoObjectExprBitfields PseudoObjectExprBits;\n    SourceLocExprBitfields SourceLocExprBits;\n\n    // GNU Extensions.\n    StmtExprBitfields StmtExprBits;\n\n    // C++ Expressions\n    CXXOperatorCallExprBitfields CXXOperatorCallExprBits;\n    CXXRewrittenBinaryOperatorBitfields CXXRewrittenBinaryOperatorBits;\n    CXXBoolLiteralExprBitfields CXXBoolLiteralExprBits;\n    CXXNullPtrLiteralExprBitfields CXXNullPtrLiteralExprBits;\n    CXXThisExprBitfields CXXThisExprBits;\n    CXXThrowExprBitfields CXXThrowExprBits;\n    CXXDefaultArgExprBitfields CXXDefaultArgExprBits;\n    CXXDefaultInitExprBitfields CXXDefaultInitExprBits;\n    CXXScalarValueInitExprBitfields CXXScalarValueInitExprBits;\n    CXXNewExprBitfields CXXNewExprBits;\n    CXXDeleteExprBitfields CXXDeleteExprBits;\n    TypeTraitExprBitfields TypeTraitExprBits;\n    DependentScopeDeclRefExprBitfields DependentScopeDeclRefExprBits;\n    CXXConstructExprBitfields CXXConstructExprBits;\n    ExprWithCleanupsBitfields ExprWithCleanupsBits;\n    CXXUnresolvedConstructExprBitfields CXXUnresolvedConstructExprBits;\n    CXXDependentScopeMemberExprBitfields CXXDependentScopeMemberExprBits;\n    OverloadExprBitfields OverloadExprBits;\n    UnresolvedLookupExprBitfields UnresolvedLookupExprBits;\n    UnresolvedMemberExprBitfields UnresolvedMemberExprBits;\n    CXXNoexceptExprBitfields CXXNoexceptExprBits;\n    SubstNonTypeTemplateParmExprBitfields SubstNonTypeTemplateParmExprBits;\n    LambdaExprBitfields LambdaExprBits;\n    RequiresExprBitfields RequiresExprBits;\n\n    // C++ Coroutines TS expressions\n    CoawaitExprBitfields CoawaitBits;\n\n    // Obj-C Expressions\n    ObjCIndirectCopyRestoreExprBitfields ObjCIndirectCopyRestoreExprBits;\n\n    // Clang Extensions\n    OpaqueValueExprBitfields OpaqueValueExprBits;\n  };\n\npublic:\n  // Only allow allocation of Stmts using the allocator in ASTContext\n  // or by doing a placement new.\n  void* operator new(size_t bytes, const ASTContext& C,\n                     unsigned alignment = 8);\n\n  void* operator new(size_t bytes, const ASTContext* C,\n                     unsigned alignment = 8) {\n    return operator new(bytes, *C, alignment);\n  }\n\n  void *operator new(size_t bytes, void *mem) noexcept { return mem; }\n\n  void operator delete(void *, const ASTContext &, unsigned) noexcept {}\n  void operator delete(void *, const ASTContext *, unsigned) noexcept {}\n  void operator delete(void *, size_t) noexcept {}\n  void operator delete(void *, void *) noexcept {}\n\npublic:\n  /// A placeholder type used to construct an empty shell of a\n  /// type, that will be filled in later (e.g., by some\n  /// de-serialization).\n  struct EmptyShell {};\n\n  /// The likelihood of a branch being taken.\n  enum Likelihood {\n    LH_Unlikely = -1, ///< Branch has the [[unlikely]] attribute.\n    LH_None,          ///< No attribute set or branches of the IfStmt have\n                      ///< the same attribute.\n    LH_Likely         ///< Branch has the [[likely]] attribute.\n  };\n\nprotected:\n  /// Iterator for iterating over Stmt * arrays that contain only T *.\n  ///\n  /// This is needed because AST nodes use Stmt* arrays to store\n  /// references to children (to be compatible with StmtIterator).\n  template<typename T, typename TPtr = T *, typename StmtPtr = Stmt *>\n  struct CastIterator\n      : llvm::iterator_adaptor_base<CastIterator<T, TPtr, StmtPtr>, StmtPtr *,\n                                    std::random_access_iterator_tag, TPtr> {\n    using Base = typename CastIterator::iterator_adaptor_base;\n\n    CastIterator() : Base(nullptr) {}\n    CastIterator(StmtPtr *I) : Base(I) {}\n\n    typename Base::value_type operator*() const {\n      return cast_or_null<T>(*this->I);\n    }\n  };\n\n  /// Const iterator for iterating over Stmt * arrays that contain only T *.\n  template <typename T>\n  using ConstCastIterator = CastIterator<T, const T *const, const Stmt *const>;\n\n  using ExprIterator = CastIterator<Expr>;\n  using ConstExprIterator = ConstCastIterator<Expr>;\n\nprivate:\n  /// Whether statistic collection is enabled.\n  static bool StatisticsEnabled;\n\nprotected:\n  /// Construct an empty statement.\n  explicit Stmt(StmtClass SC, EmptyShell) : Stmt(SC) {}\n\npublic:\n  Stmt() = delete;\n  Stmt(const Stmt &) = delete;\n  Stmt(Stmt &&) = delete;\n  Stmt &operator=(const Stmt &) = delete;\n  Stmt &operator=(Stmt &&) = delete;\n\n  Stmt(StmtClass SC) {\n    static_assert(sizeof(*this) <= 8,\n                  \"changing bitfields changed sizeof(Stmt)\");\n    static_assert(sizeof(*this) % alignof(void *) == 0,\n                  \"Insufficient alignment!\");\n    StmtBits.sClass = SC;\n    if (StatisticsEnabled) Stmt::addStmtClass(SC);\n  }\n\n  StmtClass getStmtClass() const {\n    return static_cast<StmtClass>(StmtBits.sClass);\n  }\n\n  const char *getStmtClassName() const;\n\n  /// SourceLocation tokens are not useful in isolation - they are low level\n  /// value objects created/interpreted by SourceManager. We assume AST\n  /// clients will have a pointer to the respective SourceManager.\n  SourceRange getSourceRange() const LLVM_READONLY;\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  // global temp stats (until we have a per-module visitor)\n  static void addStmtClass(const StmtClass s);\n  static void EnableStatistics();\n  static void PrintStats();\n\n  /// \\returns the likelihood of a set of attributes.\n  static Likelihood getLikelihood(ArrayRef<const Attr *> Attrs);\n\n  /// \\returns the likelihood of a statement.\n  static Likelihood getLikelihood(const Stmt *S);\n\n  /// \\returns the likelihood attribute of a statement.\n  static const Attr *getLikelihoodAttr(const Stmt *S);\n\n  /// \\returns the likelihood of the 'then' branch of an 'if' statement. The\n  /// 'else' branch is required to determine whether both branches specify the\n  /// same likelihood, which affects the result.\n  static Likelihood getLikelihood(const Stmt *Then, const Stmt *Else);\n\n  /// \\returns whether the likelihood of the branches of an if statement are\n  /// conflicting. When the first element is \\c true there's a conflict and\n  /// the Attr's are the conflicting attributes of the Then and Else Stmt.\n  static std::tuple<bool, const Attr *, const Attr *>\n  determineLikelihoodConflict(const Stmt *Then, const Stmt *Else);\n\n  /// Dumps the specified AST fragment and all subtrees to\n  /// \\c llvm::errs().\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  /// \\return Unique reproducible object identifier\n  int64_t getID(const ASTContext &Context) const;\n\n  /// dumpColor - same as dump(), but forces color highlighting.\n  void dumpColor() const;\n\n  /// dumpPretty/printPretty - These two methods do a \"pretty print\" of the AST\n  /// back to its original source language syntax.\n  void dumpPretty(const ASTContext &Context) const;\n  void printPretty(raw_ostream &OS, PrinterHelper *Helper,\n                   const PrintingPolicy &Policy, unsigned Indentation = 0,\n                   StringRef NewlineSymbol = \"\\n\",\n                   const ASTContext *Context = nullptr) const;\n\n  /// Pretty-prints in JSON format.\n  void printJson(raw_ostream &Out, PrinterHelper *Helper,\n                 const PrintingPolicy &Policy, bool AddQuotes) const;\n\n  /// viewAST - Visualize an AST rooted at this Stmt* using GraphViz.  Only\n  ///   works on systems with GraphViz (Mac OS X) or dot+gv installed.\n  void viewAST() const;\n\n  /// Skip no-op (attributed, compound) container stmts and skip captured\n  /// stmt at the top, if \\a IgnoreCaptured is true.\n  Stmt *IgnoreContainers(bool IgnoreCaptured = false);\n  const Stmt *IgnoreContainers(bool IgnoreCaptured = false) const {\n    return const_cast<Stmt *>(this)->IgnoreContainers(IgnoreCaptured);\n  }\n\n  const Stmt *stripLabelLikeStatements() const;\n  Stmt *stripLabelLikeStatements() {\n    return const_cast<Stmt*>(\n      const_cast<const Stmt*>(this)->stripLabelLikeStatements());\n  }\n\n  /// Child Iterators: All subclasses must implement 'children'\n  /// to permit easy iteration over the substatements/subexpessions of an\n  /// AST node.  This permits easy iteration over all nodes in the AST.\n  using child_iterator = StmtIterator;\n  using const_child_iterator = ConstStmtIterator;\n\n  using child_range = llvm::iterator_range<child_iterator>;\n  using const_child_range = llvm::iterator_range<const_child_iterator>;\n\n  child_range children();\n\n  const_child_range children() const {\n    auto Children = const_cast<Stmt *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_iterator child_begin() { return children().begin(); }\n  child_iterator child_end() { return children().end(); }\n\n  const_child_iterator child_begin() const { return children().begin(); }\n  const_child_iterator child_end() const { return children().end(); }\n\n  /// Produce a unique representation of the given statement.\n  ///\n  /// \\param ID once the profiling operation is complete, will contain\n  /// the unique representation of the given statement.\n  ///\n  /// \\param Context the AST context in which the statement resides\n  ///\n  /// \\param Canonical whether the profile should be based on the canonical\n  /// representation of this statement (e.g., where non-type template\n  /// parameters are identified by index/level rather than their\n  /// declaration pointers) or the exact representation of the statement as\n  /// written in the source.\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n               bool Canonical) const;\n\n  /// Calculate a unique representation for a statement that is\n  /// stable across compiler invocations.\n  ///\n  /// \\param ID profile information will be stored in ID.\n  ///\n  /// \\param Hash an ODRHash object which will be called where pointers would\n  /// have been used in the Profile function.\n  void ProcessODRHash(llvm::FoldingSetNodeID &ID, ODRHash& Hash) const;\n};\n\n/// DeclStmt - Adaptor class for mixing declarations with statements and\n/// expressions. For example, CompoundStmt mixes statements, expressions\n/// and declarations (variables, types). Another example is ForStmt, where\n/// the first statement can be an expression or a declaration.\nclass DeclStmt : public Stmt {\n  DeclGroupRef DG;\n  SourceLocation StartLoc, EndLoc;\n\npublic:\n  DeclStmt(DeclGroupRef dg, SourceLocation startLoc, SourceLocation endLoc)\n      : Stmt(DeclStmtClass), DG(dg), StartLoc(startLoc), EndLoc(endLoc) {}\n\n  /// Build an empty declaration statement.\n  explicit DeclStmt(EmptyShell Empty) : Stmt(DeclStmtClass, Empty) {}\n\n  /// isSingleDecl - This method returns true if this DeclStmt refers\n  /// to a single Decl.\n  bool isSingleDecl() const { return DG.isSingleDecl(); }\n\n  const Decl *getSingleDecl() const { return DG.getSingleDecl(); }\n  Decl *getSingleDecl() { return DG.getSingleDecl(); }\n\n  const DeclGroupRef getDeclGroup() const { return DG; }\n  DeclGroupRef getDeclGroup() { return DG; }\n  void setDeclGroup(DeclGroupRef DGR) { DG = DGR; }\n\n  void setStartLoc(SourceLocation L) { StartLoc = L; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n  void setEndLoc(SourceLocation L) { EndLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return StartLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclStmtClass;\n  }\n\n  // Iterators over subexpressions.\n  child_range children() {\n    return child_range(child_iterator(DG.begin(), DG.end()),\n                       child_iterator(DG.end(), DG.end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<DeclStmt *>(this)->children();\n    return const_child_range(Children);\n  }\n\n  using decl_iterator = DeclGroupRef::iterator;\n  using const_decl_iterator = DeclGroupRef::const_iterator;\n  using decl_range = llvm::iterator_range<decl_iterator>;\n  using decl_const_range = llvm::iterator_range<const_decl_iterator>;\n\n  decl_range decls() { return decl_range(decl_begin(), decl_end()); }\n\n  decl_const_range decls() const {\n    return decl_const_range(decl_begin(), decl_end());\n  }\n\n  decl_iterator decl_begin() { return DG.begin(); }\n  decl_iterator decl_end() { return DG.end(); }\n  const_decl_iterator decl_begin() const { return DG.begin(); }\n  const_decl_iterator decl_end() const { return DG.end(); }\n\n  using reverse_decl_iterator = std::reverse_iterator<decl_iterator>;\n\n  reverse_decl_iterator decl_rbegin() {\n    return reverse_decl_iterator(decl_end());\n  }\n\n  reverse_decl_iterator decl_rend() {\n    return reverse_decl_iterator(decl_begin());\n  }\n};\n\n/// NullStmt - This is the null statement \";\": C99 6.8.3p3.\n///\nclass NullStmt : public Stmt {\npublic:\n  NullStmt(SourceLocation L, bool hasLeadingEmptyMacro = false)\n      : Stmt(NullStmtClass) {\n    NullStmtBits.HasLeadingEmptyMacro = hasLeadingEmptyMacro;\n    setSemiLoc(L);\n  }\n\n  /// Build an empty null statement.\n  explicit NullStmt(EmptyShell Empty) : Stmt(NullStmtClass, Empty) {}\n\n  SourceLocation getSemiLoc() const { return NullStmtBits.SemiLoc; }\n  void setSemiLoc(SourceLocation L) { NullStmtBits.SemiLoc = L; }\n\n  bool hasLeadingEmptyMacro() const {\n    return NullStmtBits.HasLeadingEmptyMacro;\n  }\n\n  SourceLocation getBeginLoc() const { return getSemiLoc(); }\n  SourceLocation getEndLoc() const { return getSemiLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NullStmtClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// CompoundStmt - This represents a group of statements like { stmt stmt }.\nclass CompoundStmt final : public Stmt,\n                           private llvm::TrailingObjects<CompoundStmt, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the closing \"}\". LBraceLoc is stored in CompoundStmtBits.\n  SourceLocation RBraceLoc;\n\n  CompoundStmt(ArrayRef<Stmt *> Stmts, SourceLocation LB, SourceLocation RB);\n  explicit CompoundStmt(EmptyShell Empty) : Stmt(CompoundStmtClass, Empty) {}\n\n  void setStmts(ArrayRef<Stmt *> Stmts);\n\npublic:\n  static CompoundStmt *Create(const ASTContext &C, ArrayRef<Stmt *> Stmts,\n                              SourceLocation LB, SourceLocation RB);\n\n  // Build an empty compound statement with a location.\n  explicit CompoundStmt(SourceLocation Loc)\n      : Stmt(CompoundStmtClass), RBraceLoc(Loc) {\n    CompoundStmtBits.NumStmts = 0;\n    CompoundStmtBits.LBraceLoc = Loc;\n  }\n\n  // Build an empty compound statement.\n  static CompoundStmt *CreateEmpty(const ASTContext &C, unsigned NumStmts);\n\n  bool body_empty() const { return CompoundStmtBits.NumStmts == 0; }\n  unsigned size() const { return CompoundStmtBits.NumStmts; }\n\n  using body_iterator = Stmt **;\n  using body_range = llvm::iterator_range<body_iterator>;\n\n  body_range body() { return body_range(body_begin(), body_end()); }\n  body_iterator body_begin() { return getTrailingObjects<Stmt *>(); }\n  body_iterator body_end() { return body_begin() + size(); }\n  Stmt *body_front() { return !body_empty() ? body_begin()[0] : nullptr; }\n\n  Stmt *body_back() {\n    return !body_empty() ? body_begin()[size() - 1] : nullptr;\n  }\n\n  using const_body_iterator = Stmt *const *;\n  using body_const_range = llvm::iterator_range<const_body_iterator>;\n\n  body_const_range body() const {\n    return body_const_range(body_begin(), body_end());\n  }\n\n  const_body_iterator body_begin() const {\n    return getTrailingObjects<Stmt *>();\n  }\n\n  const_body_iterator body_end() const { return body_begin() + size(); }\n\n  const Stmt *body_front() const {\n    return !body_empty() ? body_begin()[0] : nullptr;\n  }\n\n  const Stmt *body_back() const {\n    return !body_empty() ? body_begin()[size() - 1] : nullptr;\n  }\n\n  using reverse_body_iterator = std::reverse_iterator<body_iterator>;\n\n  reverse_body_iterator body_rbegin() {\n    return reverse_body_iterator(body_end());\n  }\n\n  reverse_body_iterator body_rend() {\n    return reverse_body_iterator(body_begin());\n  }\n\n  using const_reverse_body_iterator =\n      std::reverse_iterator<const_body_iterator>;\n\n  const_reverse_body_iterator body_rbegin() const {\n    return const_reverse_body_iterator(body_end());\n  }\n\n  const_reverse_body_iterator body_rend() const {\n    return const_reverse_body_iterator(body_begin());\n  }\n\n  // Get the Stmt that StmtExpr would consider to be the result of this\n  // compound statement. This is used by StmtExpr to properly emulate the GCC\n  // compound expression extension, which ignores trailing NullStmts when\n  // getting the result of the expression.\n  // i.e. ({ 5;;; })\n  //           ^^ ignored\n  // If we don't find something that isn't a NullStmt, just return the last\n  // Stmt.\n  Stmt *getStmtExprResult() {\n    for (auto *B : llvm::reverse(body())) {\n      if (!isa<NullStmt>(B))\n        return B;\n    }\n    return body_back();\n  }\n\n  const Stmt *getStmtExprResult() const {\n    return const_cast<CompoundStmt *>(this)->getStmtExprResult();\n  }\n\n  SourceLocation getBeginLoc() const { return CompoundStmtBits.LBraceLoc; }\n  SourceLocation getEndLoc() const { return RBraceLoc; }\n\n  SourceLocation getLBracLoc() const { return CompoundStmtBits.LBraceLoc; }\n  SourceLocation getRBracLoc() const { return RBraceLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundStmtClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(body_begin(), body_end()); }\n\n  const_child_range children() const {\n    return const_child_range(body_begin(), body_end());\n  }\n};\n\n// SwitchCase is the base class for CaseStmt and DefaultStmt,\nclass SwitchCase : public Stmt {\nprotected:\n  /// The location of the \":\".\n  SourceLocation ColonLoc;\n\n  // The location of the \"case\" or \"default\" keyword. Stored in SwitchCaseBits.\n  // SourceLocation KeywordLoc;\n\n  /// A pointer to the following CaseStmt or DefaultStmt class,\n  /// used by SwitchStmt.\n  SwitchCase *NextSwitchCase = nullptr;\n\n  SwitchCase(StmtClass SC, SourceLocation KWLoc, SourceLocation ColonLoc)\n      : Stmt(SC), ColonLoc(ColonLoc) {\n    setKeywordLoc(KWLoc);\n  }\n\n  SwitchCase(StmtClass SC, EmptyShell) : Stmt(SC) {}\n\npublic:\n  const SwitchCase *getNextSwitchCase() const { return NextSwitchCase; }\n  SwitchCase *getNextSwitchCase() { return NextSwitchCase; }\n  void setNextSwitchCase(SwitchCase *SC) { NextSwitchCase = SC; }\n\n  SourceLocation getKeywordLoc() const { return SwitchCaseBits.KeywordLoc; }\n  void setKeywordLoc(SourceLocation L) { SwitchCaseBits.KeywordLoc = L; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n  void setColonLoc(SourceLocation L) { ColonLoc = L; }\n\n  inline Stmt *getSubStmt();\n  const Stmt *getSubStmt() const {\n    return const_cast<SwitchCase *>(this)->getSubStmt();\n  }\n\n  SourceLocation getBeginLoc() const { return getKeywordLoc(); }\n  inline SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CaseStmtClass ||\n           T->getStmtClass() == DefaultStmtClass;\n  }\n};\n\n/// CaseStmt - Represent a case statement. It can optionally be a GNU case\n/// statement of the form LHS ... RHS representing a range of cases.\nclass CaseStmt final\n    : public SwitchCase,\n      private llvm::TrailingObjects<CaseStmt, Stmt *, SourceLocation> {\n  friend TrailingObjects;\n\n  // CaseStmt is followed by several trailing objects, some of which optional.\n  // Note that it would be more convenient to put the optional trailing objects\n  // at the end but this would impact children().\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the LHS of the case statement. Always present.\n  //\n  // * A \"Stmt *\" for the RHS of the case statement. This is a GNU extension\n  //   which allow ranges in cases statement of the form LHS ... RHS.\n  //   Present if and only if caseStmtIsGNURange() is true.\n  //\n  // * A \"Stmt *\" for the substatement of the case statement. Always present.\n  //\n  // * A SourceLocation for the location of the ... if this is a case statement\n  //   with a range. Present if and only if caseStmtIsGNURange() is true.\n  enum { LhsOffset = 0, SubStmtOffsetFromRhs = 1 };\n  enum { NumMandatoryStmtPtr = 2 };\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + caseStmtIsGNURange();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return caseStmtIsGNURange();\n  }\n\n  unsigned lhsOffset() const { return LhsOffset; }\n  unsigned rhsOffset() const { return LhsOffset + caseStmtIsGNURange(); }\n  unsigned subStmtOffset() const { return rhsOffset() + SubStmtOffsetFromRhs; }\n\n  /// Build a case statement assuming that the storage for the\n  /// trailing objects has been properly allocated.\n  CaseStmt(Expr *lhs, Expr *rhs, SourceLocation caseLoc,\n           SourceLocation ellipsisLoc, SourceLocation colonLoc)\n      : SwitchCase(CaseStmtClass, caseLoc, colonLoc) {\n    // Handle GNU case statements of the form LHS ... RHS.\n    bool IsGNURange = rhs != nullptr;\n    SwitchCaseBits.CaseStmtIsGNURange = IsGNURange;\n    setLHS(lhs);\n    setSubStmt(nullptr);\n    if (IsGNURange) {\n      setRHS(rhs);\n      setEllipsisLoc(ellipsisLoc);\n    }\n  }\n\n  /// Build an empty switch case statement.\n  explicit CaseStmt(EmptyShell Empty, bool CaseStmtIsGNURange)\n      : SwitchCase(CaseStmtClass, Empty) {\n    SwitchCaseBits.CaseStmtIsGNURange = CaseStmtIsGNURange;\n  }\n\npublic:\n  /// Build a case statement.\n  static CaseStmt *Create(const ASTContext &Ctx, Expr *lhs, Expr *rhs,\n                          SourceLocation caseLoc, SourceLocation ellipsisLoc,\n                          SourceLocation colonLoc);\n\n  /// Build an empty case statement.\n  static CaseStmt *CreateEmpty(const ASTContext &Ctx, bool CaseStmtIsGNURange);\n\n  /// True if this case statement is of the form case LHS ... RHS, which\n  /// is a GNU extension. In this case the RHS can be obtained with getRHS()\n  /// and the location of the ellipsis can be obtained with getEllipsisLoc().\n  bool caseStmtIsGNURange() const { return SwitchCaseBits.CaseStmtIsGNURange; }\n\n  SourceLocation getCaseLoc() const { return getKeywordLoc(); }\n  void setCaseLoc(SourceLocation L) { setKeywordLoc(L); }\n\n  /// Get the location of the ... in a case statement of the form LHS ... RHS.\n  SourceLocation getEllipsisLoc() const {\n    return caseStmtIsGNURange() ? *getTrailingObjects<SourceLocation>()\n                                : SourceLocation();\n  }\n\n  /// Set the location of the ... in a case statement of the form LHS ... RHS.\n  /// Assert that this case statement is of this form.\n  void setEllipsisLoc(SourceLocation L) {\n    assert(\n        caseStmtIsGNURange() &&\n        \"setEllipsisLoc but this is not a case stmt of the form LHS ... RHS!\");\n    *getTrailingObjects<SourceLocation>() = L;\n  }\n\n  Expr *getLHS() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[lhsOffset()]);\n  }\n\n  const Expr *getLHS() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[lhsOffset()]);\n  }\n\n  void setLHS(Expr *Val) {\n    getTrailingObjects<Stmt *>()[lhsOffset()] = reinterpret_cast<Stmt *>(Val);\n  }\n\n  Expr *getRHS() {\n    return caseStmtIsGNURange() ? reinterpret_cast<Expr *>(\n                                      getTrailingObjects<Stmt *>()[rhsOffset()])\n                                : nullptr;\n  }\n\n  const Expr *getRHS() const {\n    return caseStmtIsGNURange() ? reinterpret_cast<Expr *>(\n                                      getTrailingObjects<Stmt *>()[rhsOffset()])\n                                : nullptr;\n  }\n\n  void setRHS(Expr *Val) {\n    assert(caseStmtIsGNURange() &&\n           \"setRHS but this is not a case stmt of the form LHS ... RHS!\");\n    getTrailingObjects<Stmt *>()[rhsOffset()] = reinterpret_cast<Stmt *>(Val);\n  }\n\n  Stmt *getSubStmt() { return getTrailingObjects<Stmt *>()[subStmtOffset()]; }\n  const Stmt *getSubStmt() const {\n    return getTrailingObjects<Stmt *>()[subStmtOffset()];\n  }\n\n  void setSubStmt(Stmt *S) {\n    getTrailingObjects<Stmt *>()[subStmtOffset()] = S;\n  }\n\n  SourceLocation getBeginLoc() const { return getKeywordLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // Handle deeply nested case statements with iteration instead of recursion.\n    const CaseStmt *CS = this;\n    while (const auto *CS2 = dyn_cast<CaseStmt>(CS->getSubStmt()))\n      CS = CS2;\n\n    return CS->getSubStmt()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CaseStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\nclass DefaultStmt : public SwitchCase {\n  Stmt *SubStmt;\n\npublic:\n  DefaultStmt(SourceLocation DL, SourceLocation CL, Stmt *substmt)\n      : SwitchCase(DefaultStmtClass, DL, CL), SubStmt(substmt) {}\n\n  /// Build an empty default statement.\n  explicit DefaultStmt(EmptyShell Empty)\n      : SwitchCase(DefaultStmtClass, Empty) {}\n\n  Stmt *getSubStmt() { return SubStmt; }\n  const Stmt *getSubStmt() const { return SubStmt; }\n  void setSubStmt(Stmt *S) { SubStmt = S; }\n\n  SourceLocation getDefaultLoc() const { return getKeywordLoc(); }\n  void setDefaultLoc(SourceLocation L) { setKeywordLoc(L); }\n\n  SourceLocation getBeginLoc() const { return getKeywordLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubStmt->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DefaultStmtClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\nSourceLocation SwitchCase::getEndLoc() const {\n  if (const auto *CS = dyn_cast<CaseStmt>(this))\n    return CS->getEndLoc();\n  else if (const auto *DS = dyn_cast<DefaultStmt>(this))\n    return DS->getEndLoc();\n  llvm_unreachable(\"SwitchCase is neither a CaseStmt nor a DefaultStmt!\");\n}\n\nStmt *SwitchCase::getSubStmt() {\n  if (auto *CS = dyn_cast<CaseStmt>(this))\n    return CS->getSubStmt();\n  else if (auto *DS = dyn_cast<DefaultStmt>(this))\n    return DS->getSubStmt();\n  llvm_unreachable(\"SwitchCase is neither a CaseStmt nor a DefaultStmt!\");\n}\n\n/// Represents a statement that could possibly have a value and type. This\n/// covers expression-statements, as well as labels and attributed statements.\n///\n/// Value statements have a special meaning when they are the last non-null\n/// statement in a GNU statement expression, where they determine the value\n/// of the statement expression.\nclass ValueStmt : public Stmt {\nprotected:\n  using Stmt::Stmt;\n\npublic:\n  const Expr *getExprStmt() const;\n  Expr *getExprStmt() {\n    const ValueStmt *ConstThis = this;\n    return const_cast<Expr*>(ConstThis->getExprStmt());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstValueStmtConstant &&\n           T->getStmtClass() <= lastValueStmtConstant;\n  }\n};\n\n/// LabelStmt - Represents a label, which has a substatement.  For example:\n///    foo: return;\nclass LabelStmt : public ValueStmt {\n  LabelDecl *TheDecl;\n  Stmt *SubStmt;\n\npublic:\n  /// Build a label statement.\n  LabelStmt(SourceLocation IL, LabelDecl *D, Stmt *substmt)\n      : ValueStmt(LabelStmtClass), TheDecl(D), SubStmt(substmt) {\n    setIdentLoc(IL);\n  }\n\n  /// Build an empty label statement.\n  explicit LabelStmt(EmptyShell Empty) : ValueStmt(LabelStmtClass, Empty) {}\n\n  SourceLocation getIdentLoc() const { return LabelStmtBits.IdentLoc; }\n  void setIdentLoc(SourceLocation L) { LabelStmtBits.IdentLoc = L; }\n\n  LabelDecl *getDecl() const { return TheDecl; }\n  void setDecl(LabelDecl *D) { TheDecl = D; }\n\n  const char *getName() const;\n  Stmt *getSubStmt() { return SubStmt; }\n\n  const Stmt *getSubStmt() const { return SubStmt; }\n  void setSubStmt(Stmt *SS) { SubStmt = SS; }\n\n  SourceLocation getBeginLoc() const { return getIdentLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SubStmt->getEndLoc();}\n\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == LabelStmtClass;\n  }\n};\n\n/// Represents an attribute applied to a statement.\n///\n/// Represents an attribute applied to a statement. For example:\n///   [[omp::for(...)]] for (...) { ... }\nclass AttributedStmt final\n    : public ValueStmt,\n      private llvm::TrailingObjects<AttributedStmt, const Attr *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  Stmt *SubStmt;\n\n  AttributedStmt(SourceLocation Loc, ArrayRef<const Attr *> Attrs,\n                 Stmt *SubStmt)\n      : ValueStmt(AttributedStmtClass), SubStmt(SubStmt) {\n    AttributedStmtBits.NumAttrs = Attrs.size();\n    AttributedStmtBits.AttrLoc = Loc;\n    std::copy(Attrs.begin(), Attrs.end(), getAttrArrayPtr());\n  }\n\n  explicit AttributedStmt(EmptyShell Empty, unsigned NumAttrs)\n      : ValueStmt(AttributedStmtClass, Empty) {\n    AttributedStmtBits.NumAttrs = NumAttrs;\n    AttributedStmtBits.AttrLoc = SourceLocation{};\n    std::fill_n(getAttrArrayPtr(), NumAttrs, nullptr);\n  }\n\n  const Attr *const *getAttrArrayPtr() const {\n    return getTrailingObjects<const Attr *>();\n  }\n  const Attr **getAttrArrayPtr() { return getTrailingObjects<const Attr *>(); }\n\npublic:\n  static AttributedStmt *Create(const ASTContext &C, SourceLocation Loc,\n                                ArrayRef<const Attr *> Attrs, Stmt *SubStmt);\n\n  // Build an empty attributed statement.\n  static AttributedStmt *CreateEmpty(const ASTContext &C, unsigned NumAttrs);\n\n  SourceLocation getAttrLoc() const { return AttributedStmtBits.AttrLoc; }\n  ArrayRef<const Attr *> getAttrs() const {\n    return llvm::makeArrayRef(getAttrArrayPtr(), AttributedStmtBits.NumAttrs);\n  }\n\n  Stmt *getSubStmt() { return SubStmt; }\n  const Stmt *getSubStmt() const { return SubStmt; }\n\n  SourceLocation getBeginLoc() const { return getAttrLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SubStmt->getEndLoc();}\n\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AttributedStmtClass;\n  }\n};\n\n/// IfStmt - This represents an if/then/else.\nclass IfStmt final\n    : public Stmt,\n      private llvm::TrailingObjects<IfStmt, Stmt *, SourceLocation> {\n  friend TrailingObjects;\n\n  // IfStmt is followed by several trailing objects, some of which optional.\n  // Note that it would be more convenient to put the optional trailing\n  // objects at then end but this would change the order of the children.\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the init statement.\n  //    Present if and only if hasInitStorage().\n  //\n  // * A \"Stmt *\" for the condition variable.\n  //    Present if and only if hasVarStorage(). This is in fact a \"DeclStmt *\".\n  //\n  // * A \"Stmt *\" for the condition.\n  //    Always present. This is in fact a \"Expr *\".\n  //\n  // * A \"Stmt *\" for the then statement.\n  //    Always present.\n  //\n  // * A \"Stmt *\" for the else statement.\n  //    Present if and only if hasElseStorage().\n  //\n  // * A \"SourceLocation\" for the location of the \"else\".\n  //    Present if and only if hasElseStorage().\n  enum { InitOffset = 0, ThenOffsetFromCond = 1, ElseOffsetFromCond = 2 };\n  enum { NumMandatoryStmtPtr = 2 };\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + hasElseStorage() + hasVarStorage() +\n           hasInitStorage();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return hasElseStorage();\n  }\n\n  unsigned initOffset() const { return InitOffset; }\n  unsigned varOffset() const { return InitOffset + hasInitStorage(); }\n  unsigned condOffset() const {\n    return InitOffset + hasInitStorage() + hasVarStorage();\n  }\n  unsigned thenOffset() const { return condOffset() + ThenOffsetFromCond; }\n  unsigned elseOffset() const { return condOffset() + ElseOffsetFromCond; }\n\n  /// Build an if/then/else statement.\n  IfStmt(const ASTContext &Ctx, SourceLocation IL, bool IsConstexpr, Stmt *Init,\n         VarDecl *Var, Expr *Cond, SourceLocation LParenLoc,\n         SourceLocation RParenLoc, Stmt *Then, SourceLocation EL, Stmt *Else);\n\n  /// Build an empty if/then/else statement.\n  explicit IfStmt(EmptyShell Empty, bool HasElse, bool HasVar, bool HasInit);\n\npublic:\n  /// Create an IfStmt.\n  static IfStmt *Create(const ASTContext &Ctx, SourceLocation IL,\n                        bool IsConstexpr, Stmt *Init, VarDecl *Var, Expr *Cond,\n                        SourceLocation LPL, SourceLocation RPL, Stmt *Then,\n                        SourceLocation EL = SourceLocation(),\n                        Stmt *Else = nullptr);\n\n  /// Create an empty IfStmt optionally with storage for an else statement,\n  /// condition variable and init expression.\n  static IfStmt *CreateEmpty(const ASTContext &Ctx, bool HasElse, bool HasVar,\n                             bool HasInit);\n\n  /// True if this IfStmt has the storage for an init statement.\n  bool hasInitStorage() const { return IfStmtBits.HasInit; }\n\n  /// True if this IfStmt has storage for a variable declaration.\n  bool hasVarStorage() const { return IfStmtBits.HasVar; }\n\n  /// True if this IfStmt has storage for an else statement.\n  bool hasElseStorage() const { return IfStmtBits.HasElse; }\n\n  Expr *getCond() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  void setCond(Expr *Cond) {\n    getTrailingObjects<Stmt *>()[condOffset()] = reinterpret_cast<Stmt *>(Cond);\n  }\n\n  Stmt *getThen() { return getTrailingObjects<Stmt *>()[thenOffset()]; }\n  const Stmt *getThen() const {\n    return getTrailingObjects<Stmt *>()[thenOffset()];\n  }\n\n  void setThen(Stmt *Then) {\n    getTrailingObjects<Stmt *>()[thenOffset()] = Then;\n  }\n\n  Stmt *getElse() {\n    return hasElseStorage() ? getTrailingObjects<Stmt *>()[elseOffset()]\n                            : nullptr;\n  }\n\n  const Stmt *getElse() const {\n    return hasElseStorage() ? getTrailingObjects<Stmt *>()[elseOffset()]\n                            : nullptr;\n  }\n\n  void setElse(Stmt *Else) {\n    assert(hasElseStorage() &&\n           \"This if statement has no storage for an else statement!\");\n    getTrailingObjects<Stmt *>()[elseOffset()] = Else;\n  }\n\n  /// Retrieve the variable declared in this \"if\" statement, if any.\n  ///\n  /// In the following example, \"x\" is the condition variable.\n  /// \\code\n  /// if (int x = foo()) {\n  ///   printf(\"x is %d\", x);\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable();\n  const VarDecl *getConditionVariable() const {\n    return const_cast<IfStmt *>(this)->getConditionVariable();\n  }\n\n  /// Set the condition variable for this if statement.\n  /// The if statement must have storage for the condition variable.\n  void setConditionVariable(const ASTContext &Ctx, VarDecl *V);\n\n  /// If this IfStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  DeclStmt *getConditionVariableDeclStmt() {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  Stmt *getInit() {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  const Stmt *getInit() const {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  void setInit(Stmt *Init) {\n    assert(hasInitStorage() &&\n           \"This if statement has no storage for an init statement!\");\n    getTrailingObjects<Stmt *>()[initOffset()] = Init;\n  }\n\n  SourceLocation getIfLoc() const { return IfStmtBits.IfLoc; }\n  void setIfLoc(SourceLocation IfLoc) { IfStmtBits.IfLoc = IfLoc; }\n\n  SourceLocation getElseLoc() const {\n    return hasElseStorage() ? *getTrailingObjects<SourceLocation>()\n                            : SourceLocation();\n  }\n\n  void setElseLoc(SourceLocation ElseLoc) {\n    assert(hasElseStorage() &&\n           \"This if statement has no storage for an else statement!\");\n    *getTrailingObjects<SourceLocation>() = ElseLoc;\n  }\n\n  bool isConstexpr() const { return IfStmtBits.IsConstexpr; }\n  void setConstexpr(bool C) { IfStmtBits.IsConstexpr = C; }\n\n  /// If this is an 'if constexpr', determine which substatement will be taken.\n  /// Otherwise, or if the condition is value-dependent, returns None.\n  Optional<const Stmt*> getNondiscardedCase(const ASTContext &Ctx) const;\n\n  bool isObjCAvailabilityCheck() const;\n\n  SourceLocation getBeginLoc() const { return getIfLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (getElse())\n      return getElse()->getEndLoc();\n    return getThen()->getEndLoc();\n  }\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  // Iterators over subexpressions.  The iterators will include iterating\n  // over the initialization expression referenced by the condition variable.\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IfStmtClass;\n  }\n};\n\n/// SwitchStmt - This represents a 'switch' stmt.\nclass SwitchStmt final : public Stmt,\n                         private llvm::TrailingObjects<SwitchStmt, Stmt *> {\n  friend TrailingObjects;\n\n  /// Points to a linked list of case and default statements.\n  SwitchCase *FirstCase = nullptr;\n\n  // SwitchStmt is followed by several trailing objects,\n  // some of which optional. Note that it would be more convenient to\n  // put the optional trailing objects at the end but this would change\n  // the order in children().\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the init statement.\n  //    Present if and only if hasInitStorage().\n  //\n  // * A \"Stmt *\" for the condition variable.\n  //    Present if and only if hasVarStorage(). This is in fact a \"DeclStmt *\".\n  //\n  // * A \"Stmt *\" for the condition.\n  //    Always present. This is in fact an \"Expr *\".\n  //\n  // * A \"Stmt *\" for the body.\n  //    Always present.\n  enum { InitOffset = 0, BodyOffsetFromCond = 1 };\n  enum { NumMandatoryStmtPtr = 2 };\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + hasInitStorage() + hasVarStorage();\n  }\n\n  unsigned initOffset() const { return InitOffset; }\n  unsigned varOffset() const { return InitOffset + hasInitStorage(); }\n  unsigned condOffset() const {\n    return InitOffset + hasInitStorage() + hasVarStorage();\n  }\n  unsigned bodyOffset() const { return condOffset() + BodyOffsetFromCond; }\n\n  /// Build a switch statement.\n  SwitchStmt(const ASTContext &Ctx, Stmt *Init, VarDecl *Var, Expr *Cond,\n             SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  /// Build a empty switch statement.\n  explicit SwitchStmt(EmptyShell Empty, bool HasInit, bool HasVar);\n\npublic:\n  /// Create a switch statement.\n  static SwitchStmt *Create(const ASTContext &Ctx, Stmt *Init, VarDecl *Var,\n                            Expr *Cond, SourceLocation LParenLoc,\n                            SourceLocation RParenLoc);\n\n  /// Create an empty switch statement optionally with storage for\n  /// an init expression and a condition variable.\n  static SwitchStmt *CreateEmpty(const ASTContext &Ctx, bool HasInit,\n                                 bool HasVar);\n\n  /// True if this SwitchStmt has storage for an init statement.\n  bool hasInitStorage() const { return SwitchStmtBits.HasInit; }\n\n  /// True if this SwitchStmt has storage for a condition variable.\n  bool hasVarStorage() const { return SwitchStmtBits.HasVar; }\n\n  Expr *getCond() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  void setCond(Expr *Cond) {\n    getTrailingObjects<Stmt *>()[condOffset()] = reinterpret_cast<Stmt *>(Cond);\n  }\n\n  Stmt *getBody() { return getTrailingObjects<Stmt *>()[bodyOffset()]; }\n  const Stmt *getBody() const {\n    return getTrailingObjects<Stmt *>()[bodyOffset()];\n  }\n\n  void setBody(Stmt *Body) {\n    getTrailingObjects<Stmt *>()[bodyOffset()] = Body;\n  }\n\n  Stmt *getInit() {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  const Stmt *getInit() const {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  void setInit(Stmt *Init) {\n    assert(hasInitStorage() &&\n           \"This switch statement has no storage for an init statement!\");\n    getTrailingObjects<Stmt *>()[initOffset()] = Init;\n  }\n\n  /// Retrieve the variable declared in this \"switch\" statement, if any.\n  ///\n  /// In the following example, \"x\" is the condition variable.\n  /// \\code\n  /// switch (int x = foo()) {\n  ///   case 0: break;\n  ///   // ...\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable();\n  const VarDecl *getConditionVariable() const {\n    return const_cast<SwitchStmt *>(this)->getConditionVariable();\n  }\n\n  /// Set the condition variable in this switch statement.\n  /// The switch statement must have storage for it.\n  void setConditionVariable(const ASTContext &Ctx, VarDecl *VD);\n\n  /// If this SwitchStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  DeclStmt *getConditionVariableDeclStmt() {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  SwitchCase *getSwitchCaseList() { return FirstCase; }\n  const SwitchCase *getSwitchCaseList() const { return FirstCase; }\n  void setSwitchCaseList(SwitchCase *SC) { FirstCase = SC; }\n\n  SourceLocation getSwitchLoc() const { return SwitchStmtBits.SwitchLoc; }\n  void setSwitchLoc(SourceLocation L) { SwitchStmtBits.SwitchLoc = L; }\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  void setBody(Stmt *S, SourceLocation SL) {\n    setBody(S);\n    setSwitchLoc(SL);\n  }\n\n  void addSwitchCase(SwitchCase *SC) {\n    assert(!SC->getNextSwitchCase() &&\n           \"case/default already added to a switch\");\n    SC->setNextSwitchCase(FirstCase);\n    FirstCase = SC;\n  }\n\n  /// Set a flag in the SwitchStmt indicating that if the 'switch (X)' is a\n  /// switch over an enum value then all cases have been explicitly covered.\n  void setAllEnumCasesCovered() { SwitchStmtBits.AllEnumCasesCovered = true; }\n\n  /// Returns true if the SwitchStmt is a switch of an enum value and all cases\n  /// have been explicitly covered.\n  bool isAllEnumCasesCovered() const {\n    return SwitchStmtBits.AllEnumCasesCovered;\n  }\n\n  SourceLocation getBeginLoc() const { return getSwitchLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody() ? getBody()->getEndLoc()\n                     : reinterpret_cast<const Stmt *>(getCond())->getEndLoc();\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SwitchStmtClass;\n  }\n};\n\n/// WhileStmt - This represents a 'while' stmt.\nclass WhileStmt final : public Stmt,\n                        private llvm::TrailingObjects<WhileStmt, Stmt *> {\n  friend TrailingObjects;\n\n  // WhileStmt is followed by several trailing objects,\n  // some of which optional. Note that it would be more\n  // convenient to put the optional trailing object at the end\n  // but this would affect children().\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the condition variable.\n  //    Present if and only if hasVarStorage(). This is in fact a \"DeclStmt *\".\n  //\n  // * A \"Stmt *\" for the condition.\n  //    Always present. This is in fact an \"Expr *\".\n  //\n  // * A \"Stmt *\" for the body.\n  //    Always present.\n  //\n  enum { VarOffset = 0, BodyOffsetFromCond = 1 };\n  enum { NumMandatoryStmtPtr = 2 };\n\n  SourceLocation LParenLoc, RParenLoc;\n\n  unsigned varOffset() const { return VarOffset; }\n  unsigned condOffset() const { return VarOffset + hasVarStorage(); }\n  unsigned bodyOffset() const { return condOffset() + BodyOffsetFromCond; }\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + hasVarStorage();\n  }\n\n  /// Build a while statement.\n  WhileStmt(const ASTContext &Ctx, VarDecl *Var, Expr *Cond, Stmt *Body,\n            SourceLocation WL, SourceLocation LParenLoc,\n            SourceLocation RParenLoc);\n\n  /// Build an empty while statement.\n  explicit WhileStmt(EmptyShell Empty, bool HasVar);\n\npublic:\n  /// Create a while statement.\n  static WhileStmt *Create(const ASTContext &Ctx, VarDecl *Var, Expr *Cond,\n                           Stmt *Body, SourceLocation WL,\n                           SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  /// Create an empty while statement optionally with storage for\n  /// a condition variable.\n  static WhileStmt *CreateEmpty(const ASTContext &Ctx, bool HasVar);\n\n  /// True if this WhileStmt has storage for a condition variable.\n  bool hasVarStorage() const { return WhileStmtBits.HasVar; }\n\n  Expr *getCond() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  void setCond(Expr *Cond) {\n    getTrailingObjects<Stmt *>()[condOffset()] = reinterpret_cast<Stmt *>(Cond);\n  }\n\n  Stmt *getBody() { return getTrailingObjects<Stmt *>()[bodyOffset()]; }\n  const Stmt *getBody() const {\n    return getTrailingObjects<Stmt *>()[bodyOffset()];\n  }\n\n  void setBody(Stmt *Body) {\n    getTrailingObjects<Stmt *>()[bodyOffset()] = Body;\n  }\n\n  /// Retrieve the variable declared in this \"while\" statement, if any.\n  ///\n  /// In the following example, \"x\" is the condition variable.\n  /// \\code\n  /// while (int x = random()) {\n  ///   // ...\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable();\n  const VarDecl *getConditionVariable() const {\n    return const_cast<WhileStmt *>(this)->getConditionVariable();\n  }\n\n  /// Set the condition variable of this while statement.\n  /// The while statement must have storage for it.\n  void setConditionVariable(const ASTContext &Ctx, VarDecl *V);\n\n  /// If this WhileStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  DeclStmt *getConditionVariableDeclStmt() {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  SourceLocation getWhileLoc() const { return WhileStmtBits.WhileLoc; }\n  void setWhileLoc(SourceLocation L) { WhileStmtBits.WhileLoc = L; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getWhileLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == WhileStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n/// DoStmt - This represents a 'do/while' stmt.\nclass DoStmt : public Stmt {\n  enum { BODY, COND, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n  SourceLocation WhileLoc;\n  SourceLocation RParenLoc; // Location of final ')' in do stmt condition.\n\npublic:\n  DoStmt(Stmt *Body, Expr *Cond, SourceLocation DL, SourceLocation WL,\n         SourceLocation RP)\n      : Stmt(DoStmtClass), WhileLoc(WL), RParenLoc(RP) {\n    setCond(Cond);\n    setBody(Body);\n    setDoLoc(DL);\n  }\n\n  /// Build an empty do-while statement.\n  explicit DoStmt(EmptyShell Empty) : Stmt(DoStmtClass, Empty) {}\n\n  Expr *getCond() { return reinterpret_cast<Expr *>(SubExprs[COND]); }\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(SubExprs[COND]);\n  }\n\n  void setCond(Expr *Cond) { SubExprs[COND] = reinterpret_cast<Stmt *>(Cond); }\n\n  Stmt *getBody() { return SubExprs[BODY]; }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n  void setBody(Stmt *Body) { SubExprs[BODY] = Body; }\n\n  SourceLocation getDoLoc() const { return DoStmtBits.DoLoc; }\n  void setDoLoc(SourceLocation L) { DoStmtBits.DoLoc = L; }\n  SourceLocation getWhileLoc() const { return WhileLoc; }\n  void setWhileLoc(SourceLocation L) { WhileLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getDoLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DoStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note that any of\n/// the init/cond/inc parts of the ForStmt will be null if they were not\n/// specified in the source.\nclass ForStmt : public Stmt {\n  enum { INIT, CONDVAR, COND, INC, BODY, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // SubExprs[INIT] is an expression or declstmt.\n  SourceLocation LParenLoc, RParenLoc;\n\npublic:\n  ForStmt(const ASTContext &C, Stmt *Init, Expr *Cond, VarDecl *condVar,\n          Expr *Inc, Stmt *Body, SourceLocation FL, SourceLocation LP,\n          SourceLocation RP);\n\n  /// Build an empty for statement.\n  explicit ForStmt(EmptyShell Empty) : Stmt(ForStmtClass, Empty) {}\n\n  Stmt *getInit() { return SubExprs[INIT]; }\n\n  /// Retrieve the variable declared in this \"for\" statement, if any.\n  ///\n  /// In the following example, \"y\" is the condition variable.\n  /// \\code\n  /// for (int x = random(); int y = mangle(x); ++x) {\n  ///   // ...\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable() const;\n  void setConditionVariable(const ASTContext &C, VarDecl *V);\n\n  /// If this ForStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return reinterpret_cast<DeclStmt*>(SubExprs[CONDVAR]);\n  }\n\n  Expr *getCond() { return reinterpret_cast<Expr*>(SubExprs[COND]); }\n  Expr *getInc()  { return reinterpret_cast<Expr*>(SubExprs[INC]); }\n  Stmt *getBody() { return SubExprs[BODY]; }\n\n  const Stmt *getInit() const { return SubExprs[INIT]; }\n  const Expr *getCond() const { return reinterpret_cast<Expr*>(SubExprs[COND]);}\n  const Expr *getInc()  const { return reinterpret_cast<Expr*>(SubExprs[INC]); }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n\n  void setInit(Stmt *S) { SubExprs[INIT] = S; }\n  void setCond(Expr *E) { SubExprs[COND] = reinterpret_cast<Stmt*>(E); }\n  void setInc(Expr *E) { SubExprs[INC] = reinterpret_cast<Stmt*>(E); }\n  void setBody(Stmt *S) { SubExprs[BODY] = S; }\n\n  SourceLocation getForLoc() const { return ForStmtBits.ForLoc; }\n  void setForLoc(SourceLocation L) { ForStmtBits.ForLoc = L; }\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getForLoc(); }\n  SourceLocation getEndLoc() const { return getBody()->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ForStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GotoStmt - This represents a direct goto.\nclass GotoStmt : public Stmt {\n  LabelDecl *Label;\n  SourceLocation LabelLoc;\n\npublic:\n  GotoStmt(LabelDecl *label, SourceLocation GL, SourceLocation LL)\n      : Stmt(GotoStmtClass), Label(label), LabelLoc(LL) {\n    setGotoLoc(GL);\n  }\n\n  /// Build an empty goto statement.\n  explicit GotoStmt(EmptyShell Empty) : Stmt(GotoStmtClass, Empty) {}\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *D) { Label = D; }\n\n  SourceLocation getGotoLoc() const { return GotoStmtBits.GotoLoc; }\n  void setGotoLoc(SourceLocation L) { GotoStmtBits.GotoLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getGotoLoc(); }\n  SourceLocation getEndLoc() const { return getLabelLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GotoStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// IndirectGotoStmt - This represents an indirect goto.\nclass IndirectGotoStmt : public Stmt {\n  SourceLocation StarLoc;\n  Stmt *Target;\n\npublic:\n  IndirectGotoStmt(SourceLocation gotoLoc, SourceLocation starLoc, Expr *target)\n      : Stmt(IndirectGotoStmtClass), StarLoc(starLoc) {\n    setTarget(target);\n    setGotoLoc(gotoLoc);\n  }\n\n  /// Build an empty indirect goto statement.\n  explicit IndirectGotoStmt(EmptyShell Empty)\n      : Stmt(IndirectGotoStmtClass, Empty) {}\n\n  void setGotoLoc(SourceLocation L) { GotoStmtBits.GotoLoc = L; }\n  SourceLocation getGotoLoc() const { return GotoStmtBits.GotoLoc; }\n  void setStarLoc(SourceLocation L) { StarLoc = L; }\n  SourceLocation getStarLoc() const { return StarLoc; }\n\n  Expr *getTarget() { return reinterpret_cast<Expr *>(Target); }\n  const Expr *getTarget() const {\n    return reinterpret_cast<const Expr *>(Target);\n  }\n  void setTarget(Expr *E) { Target = reinterpret_cast<Stmt *>(E); }\n\n  /// getConstantTarget - Returns the fixed target of this indirect\n  /// goto, if one exists.\n  LabelDecl *getConstantTarget();\n  const LabelDecl *getConstantTarget() const {\n    return const_cast<IndirectGotoStmt *>(this)->getConstantTarget();\n  }\n\n  SourceLocation getBeginLoc() const { return getGotoLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Target->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IndirectGotoStmtClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Target, &Target + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Target, &Target + 1);\n  }\n};\n\n/// ContinueStmt - This represents a continue.\nclass ContinueStmt : public Stmt {\npublic:\n  ContinueStmt(SourceLocation CL) : Stmt(ContinueStmtClass) {\n    setContinueLoc(CL);\n  }\n\n  /// Build an empty continue statement.\n  explicit ContinueStmt(EmptyShell Empty) : Stmt(ContinueStmtClass, Empty) {}\n\n  SourceLocation getContinueLoc() const { return ContinueStmtBits.ContinueLoc; }\n  void setContinueLoc(SourceLocation L) { ContinueStmtBits.ContinueLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getContinueLoc(); }\n  SourceLocation getEndLoc() const { return getContinueLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ContinueStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// BreakStmt - This represents a break.\nclass BreakStmt : public Stmt {\npublic:\n  BreakStmt(SourceLocation BL) : Stmt(BreakStmtClass) {\n    setBreakLoc(BL);\n  }\n\n  /// Build an empty break statement.\n  explicit BreakStmt(EmptyShell Empty) : Stmt(BreakStmtClass, Empty) {}\n\n  SourceLocation getBreakLoc() const { return BreakStmtBits.BreakLoc; }\n  void setBreakLoc(SourceLocation L) { BreakStmtBits.BreakLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getBreakLoc(); }\n  SourceLocation getEndLoc() const { return getBreakLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BreakStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ReturnStmt - This represents a return, optionally of an expression:\n///   return;\n///   return 4;\n///\n/// Note that GCC allows return with no argument in a function declared to\n/// return a value, and it allows returning a value in functions declared to\n/// return void.  We explicitly model this in the AST, which means you can't\n/// depend on the return type of the function and the presence of an argument.\nclass ReturnStmt final\n    : public Stmt,\n      private llvm::TrailingObjects<ReturnStmt, const VarDecl *> {\n  friend TrailingObjects;\n\n  /// The return expression.\n  Stmt *RetExpr;\n\n  // ReturnStmt is followed optionally by a trailing \"const VarDecl *\"\n  // for the NRVO candidate. Present if and only if hasNRVOCandidate().\n\n  /// True if this ReturnStmt has storage for an NRVO candidate.\n  bool hasNRVOCandidate() const { return ReturnStmtBits.HasNRVOCandidate; }\n\n  unsigned numTrailingObjects(OverloadToken<const VarDecl *>) const {\n    return hasNRVOCandidate();\n  }\n\n  /// Build a return statement.\n  ReturnStmt(SourceLocation RL, Expr *E, const VarDecl *NRVOCandidate);\n\n  /// Build an empty return statement.\n  explicit ReturnStmt(EmptyShell Empty, bool HasNRVOCandidate);\n\npublic:\n  /// Create a return statement.\n  static ReturnStmt *Create(const ASTContext &Ctx, SourceLocation RL, Expr *E,\n                            const VarDecl *NRVOCandidate);\n\n  /// Create an empty return statement, optionally with\n  /// storage for an NRVO candidate.\n  static ReturnStmt *CreateEmpty(const ASTContext &Ctx, bool HasNRVOCandidate);\n\n  Expr *getRetValue() { return reinterpret_cast<Expr *>(RetExpr); }\n  const Expr *getRetValue() const { return reinterpret_cast<Expr *>(RetExpr); }\n  void setRetValue(Expr *E) { RetExpr = reinterpret_cast<Stmt *>(E); }\n\n  /// Retrieve the variable that might be used for the named return\n  /// value optimization.\n  ///\n  /// The optimization itself can only be performed if the variable is\n  /// also marked as an NRVO object.\n  const VarDecl *getNRVOCandidate() const {\n    return hasNRVOCandidate() ? *getTrailingObjects<const VarDecl *>()\n                              : nullptr;\n  }\n\n  /// Set the variable that might be used for the named return value\n  /// optimization. The return statement must have storage for it,\n  /// which is the case if and only if hasNRVOCandidate() is true.\n  void setNRVOCandidate(const VarDecl *Var) {\n    assert(hasNRVOCandidate() &&\n           \"This return statement has no storage for an NRVO candidate!\");\n    *getTrailingObjects<const VarDecl *>() = Var;\n  }\n\n  SourceLocation getReturnLoc() const { return ReturnStmtBits.RetLoc; }\n  void setReturnLoc(SourceLocation L) { ReturnStmtBits.RetLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getReturnLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return RetExpr ? RetExpr->getEndLoc() : getReturnLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ReturnStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (RetExpr)\n      return child_range(&RetExpr, &RetExpr + 1);\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    if (RetExpr)\n      return const_child_range(&RetExpr, &RetExpr + 1);\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// AsmStmt is the base class for GCCAsmStmt and MSAsmStmt.\nclass AsmStmt : public Stmt {\nprotected:\n  friend class ASTStmtReader;\n\n  SourceLocation AsmLoc;\n\n  /// True if the assembly statement does not have any input or output\n  /// operands.\n  bool IsSimple;\n\n  /// If true, treat this inline assembly as having side effects.\n  /// This assembly statement should not be optimized, deleted or moved.\n  bool IsVolatile;\n\n  unsigned NumOutputs;\n  unsigned NumInputs;\n  unsigned NumClobbers;\n\n  Stmt **Exprs = nullptr;\n\n  AsmStmt(StmtClass SC, SourceLocation asmloc, bool issimple, bool isvolatile,\n          unsigned numoutputs, unsigned numinputs, unsigned numclobbers)\n      : Stmt (SC), AsmLoc(asmloc), IsSimple(issimple), IsVolatile(isvolatile),\n        NumOutputs(numoutputs), NumInputs(numinputs),\n        NumClobbers(numclobbers) {}\n\npublic:\n  /// Build an empty inline-assembly statement.\n  explicit AsmStmt(StmtClass SC, EmptyShell Empty) : Stmt(SC, Empty) {}\n\n  SourceLocation getAsmLoc() const { return AsmLoc; }\n  void setAsmLoc(SourceLocation L) { AsmLoc = L; }\n\n  bool isSimple() const { return IsSimple; }\n  void setSimple(bool V) { IsSimple = V; }\n\n  bool isVolatile() const { return IsVolatile; }\n  void setVolatile(bool V) { IsVolatile = V; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return {}; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return {}; }\n\n  //===--- Asm String Analysis ---===//\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  unsigned getNumOutputs() const { return NumOutputs; }\n\n  /// getOutputConstraint - Return the constraint string for the specified\n  /// output operand.  All output constraints are known to be non-empty (either\n  /// '=' or '+').\n  StringRef getOutputConstraint(unsigned i) const;\n\n  /// isOutputPlusConstraint - Return true if the specified output constraint\n  /// is a \"+\" constraint (which is both an input and an output) or false if it\n  /// is an \"=\" constraint (just an output).\n  bool isOutputPlusConstraint(unsigned i) const {\n    return getOutputConstraint(i)[0] == '+';\n  }\n\n  const Expr *getOutputExpr(unsigned i) const;\n\n  /// getNumPlusOperands - Return the number of output operands that have a \"+\"\n  /// constraint.\n  unsigned getNumPlusOperands() const;\n\n  //===--- Input operands ---===//\n\n  unsigned getNumInputs() const { return NumInputs; }\n\n  /// getInputConstraint - Return the specified input constraint.  Unlike output\n  /// constraints, these can be empty.\n  StringRef getInputConstraint(unsigned i) const;\n\n  const Expr *getInputExpr(unsigned i) const;\n\n  //===--- Other ---===//\n\n  unsigned getNumClobbers() const { return NumClobbers; }\n  StringRef getClobber(unsigned i) const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GCCAsmStmtClass ||\n      T->getStmtClass() == MSAsmStmtClass;\n  }\n\n  // Input expr iterators.\n\n  using inputs_iterator = ExprIterator;\n  using const_inputs_iterator = ConstExprIterator;\n  using inputs_range = llvm::iterator_range<inputs_iterator>;\n  using inputs_const_range = llvm::iterator_range<const_inputs_iterator>;\n\n  inputs_iterator begin_inputs() {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  inputs_iterator end_inputs() {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  inputs_range inputs() { return inputs_range(begin_inputs(), end_inputs()); }\n\n  const_inputs_iterator begin_inputs() const {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  const_inputs_iterator end_inputs() const {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  inputs_const_range inputs() const {\n    return inputs_const_range(begin_inputs(), end_inputs());\n  }\n\n  // Output expr iterators.\n\n  using outputs_iterator = ExprIterator;\n  using const_outputs_iterator = ConstExprIterator;\n  using outputs_range = llvm::iterator_range<outputs_iterator>;\n  using outputs_const_range = llvm::iterator_range<const_outputs_iterator>;\n\n  outputs_iterator begin_outputs() {\n    return &Exprs[0];\n  }\n\n  outputs_iterator end_outputs() {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  outputs_range outputs() {\n    return outputs_range(begin_outputs(), end_outputs());\n  }\n\n  const_outputs_iterator begin_outputs() const {\n    return &Exprs[0];\n  }\n\n  const_outputs_iterator end_outputs() const {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  outputs_const_range outputs() const {\n    return outputs_const_range(begin_outputs(), end_outputs());\n  }\n\n  child_range children() {\n    return child_range(&Exprs[0], &Exprs[0] + NumOutputs + NumInputs);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Exprs[0], &Exprs[0] + NumOutputs + NumInputs);\n  }\n};\n\n/// This represents a GCC inline-assembly statement extension.\nclass GCCAsmStmt : public AsmStmt {\n  friend class ASTStmtReader;\n\n  SourceLocation RParenLoc;\n  StringLiteral *AsmStr;\n\n  // FIXME: If we wanted to, we could allocate all of these in one big array.\n  StringLiteral **Constraints = nullptr;\n  StringLiteral **Clobbers = nullptr;\n  IdentifierInfo **Names = nullptr;\n  unsigned NumLabels = 0;\n\npublic:\n  GCCAsmStmt(const ASTContext &C, SourceLocation asmloc, bool issimple,\n             bool isvolatile, unsigned numoutputs, unsigned numinputs,\n             IdentifierInfo **names, StringLiteral **constraints, Expr **exprs,\n             StringLiteral *asmstr, unsigned numclobbers,\n             StringLiteral **clobbers, unsigned numlabels,\n             SourceLocation rparenloc);\n\n  /// Build an empty inline-assembly statement.\n  explicit GCCAsmStmt(EmptyShell Empty) : AsmStmt(GCCAsmStmtClass, Empty) {}\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  //===--- Asm String Analysis ---===//\n\n  const StringLiteral *getAsmString() const { return AsmStr; }\n  StringLiteral *getAsmString() { return AsmStr; }\n  void setAsmString(StringLiteral *E) { AsmStr = E; }\n\n  /// AsmStringPiece - this is part of a decomposed asm string specification\n  /// (for use with the AnalyzeAsmString function below).  An asm string is\n  /// considered to be a concatenation of these parts.\n  class AsmStringPiece {\n  public:\n    enum Kind {\n      String,  // String in .ll asm string form, \"$\" -> \"$$\" and \"%%\" -> \"%\".\n      Operand  // Operand reference, with optional modifier %c4.\n    };\n\n  private:\n    Kind MyKind;\n    std::string Str;\n    unsigned OperandNo;\n\n    // Source range for operand references.\n    CharSourceRange Range;\n\n  public:\n    AsmStringPiece(const std::string &S) : MyKind(String), Str(S) {}\n    AsmStringPiece(unsigned OpNo, const std::string &S, SourceLocation Begin,\n                   SourceLocation End)\n        : MyKind(Operand), Str(S), OperandNo(OpNo),\n          Range(CharSourceRange::getCharRange(Begin, End)) {}\n\n    bool isString() const { return MyKind == String; }\n    bool isOperand() const { return MyKind == Operand; }\n\n    const std::string &getString() const { return Str; }\n\n    unsigned getOperandNo() const {\n      assert(isOperand());\n      return OperandNo;\n    }\n\n    CharSourceRange getRange() const {\n      assert(isOperand() && \"Range is currently used only for Operands.\");\n      return Range;\n    }\n\n    /// getModifier - Get the modifier for this operand, if present.  This\n    /// returns '\\0' if there was no modifier.\n    char getModifier() const;\n  };\n\n  /// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing\n  /// it into pieces.  If the asm string is erroneous, emit errors and return\n  /// true, otherwise return false.  This handles canonicalization and\n  /// translation of strings from GCC syntax to LLVM IR syntax, and handles\n  //// flattening of named references like %[foo] to Operand AsmStringPiece's.\n  unsigned AnalyzeAsmString(SmallVectorImpl<AsmStringPiece> &Pieces,\n                            const ASTContext &C, unsigned &DiagOffs) const;\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  IdentifierInfo *getOutputIdentifier(unsigned i) const { return Names[i]; }\n\n  StringRef getOutputName(unsigned i) const {\n    if (IdentifierInfo *II = getOutputIdentifier(i))\n      return II->getName();\n\n    return {};\n  }\n\n  StringRef getOutputConstraint(unsigned i) const;\n\n  const StringLiteral *getOutputConstraintLiteral(unsigned i) const {\n    return Constraints[i];\n  }\n  StringLiteral *getOutputConstraintLiteral(unsigned i) {\n    return Constraints[i];\n  }\n\n  Expr *getOutputExpr(unsigned i);\n\n  const Expr *getOutputExpr(unsigned i) const {\n    return const_cast<GCCAsmStmt*>(this)->getOutputExpr(i);\n  }\n\n  //===--- Input operands ---===//\n\n  IdentifierInfo *getInputIdentifier(unsigned i) const {\n    return Names[i + NumOutputs];\n  }\n\n  StringRef getInputName(unsigned i) const {\n    if (IdentifierInfo *II = getInputIdentifier(i))\n      return II->getName();\n\n    return {};\n  }\n\n  StringRef getInputConstraint(unsigned i) const;\n\n  const StringLiteral *getInputConstraintLiteral(unsigned i) const {\n    return Constraints[i + NumOutputs];\n  }\n  StringLiteral *getInputConstraintLiteral(unsigned i) {\n    return Constraints[i + NumOutputs];\n  }\n\n  Expr *getInputExpr(unsigned i);\n  void setInputExpr(unsigned i, Expr *E);\n\n  const Expr *getInputExpr(unsigned i) const {\n    return const_cast<GCCAsmStmt*>(this)->getInputExpr(i);\n  }\n\n  //===--- Labels ---===//\n\n  bool isAsmGoto() const {\n    return NumLabels > 0;\n  }\n\n  unsigned getNumLabels() const {\n    return NumLabels;\n  }\n\n  IdentifierInfo *getLabelIdentifier(unsigned i) const {\n    return Names[i + NumOutputs + NumInputs];\n  }\n\n  AddrLabelExpr *getLabelExpr(unsigned i) const;\n  StringRef getLabelName(unsigned i) const;\n  using labels_iterator = CastIterator<AddrLabelExpr>;\n  using const_labels_iterator = ConstCastIterator<AddrLabelExpr>;\n  using labels_range = llvm::iterator_range<labels_iterator>;\n  using labels_const_range = llvm::iterator_range<const_labels_iterator>;\n\n  labels_iterator begin_labels() {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  labels_iterator end_labels() {\n    return &Exprs[0] + NumOutputs + NumInputs + NumLabels;\n  }\n\n  labels_range labels() {\n    return labels_range(begin_labels(), end_labels());\n  }\n\n  const_labels_iterator begin_labels() const {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  const_labels_iterator end_labels() const {\n    return &Exprs[0] + NumOutputs + NumInputs + NumLabels;\n  }\n\n  labels_const_range labels() const {\n    return labels_const_range(begin_labels(), end_labels());\n  }\n\nprivate:\n  void setOutputsAndInputsAndClobbers(const ASTContext &C,\n                                      IdentifierInfo **Names,\n                                      StringLiteral **Constraints,\n                                      Stmt **Exprs,\n                                      unsigned NumOutputs,\n                                      unsigned NumInputs,\n                                      unsigned NumLabels,\n                                      StringLiteral **Clobbers,\n                                      unsigned NumClobbers);\n\npublic:\n  //===--- Other ---===//\n\n  /// getNamedOperand - Given a symbolic operand reference like %[foo],\n  /// translate this into a numeric value needed to reference the same operand.\n  /// This returns -1 if the operand name is invalid.\n  int getNamedOperand(StringRef SymbolicName) const;\n\n  StringRef getClobber(unsigned i) const;\n\n  StringLiteral *getClobberStringLiteral(unsigned i) { return Clobbers[i]; }\n  const StringLiteral *getClobberStringLiteral(unsigned i) const {\n    return Clobbers[i];\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AsmLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GCCAsmStmtClass;\n  }\n};\n\n/// This represents a Microsoft inline-assembly statement extension.\nclass MSAsmStmt : public AsmStmt {\n  friend class ASTStmtReader;\n\n  SourceLocation LBraceLoc, EndLoc;\n  StringRef AsmStr;\n\n  unsigned NumAsmToks = 0;\n\n  Token *AsmToks = nullptr;\n  StringRef *Constraints = nullptr;\n  StringRef *Clobbers = nullptr;\n\npublic:\n  MSAsmStmt(const ASTContext &C, SourceLocation asmloc,\n            SourceLocation lbraceloc, bool issimple, bool isvolatile,\n            ArrayRef<Token> asmtoks, unsigned numoutputs, unsigned numinputs,\n            ArrayRef<StringRef> constraints,\n            ArrayRef<Expr*> exprs, StringRef asmstr,\n            ArrayRef<StringRef> clobbers, SourceLocation endloc);\n\n  /// Build an empty MS-style inline-assembly statement.\n  explicit MSAsmStmt(EmptyShell Empty) : AsmStmt(MSAsmStmtClass, Empty) {}\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation L) { LBraceLoc = L; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n  void setEndLoc(SourceLocation L) { EndLoc = L; }\n\n  bool hasBraces() const { return LBraceLoc.isValid(); }\n\n  unsigned getNumAsmToks() { return NumAsmToks; }\n  Token *getAsmToks() { return AsmToks; }\n\n  //===--- Asm String Analysis ---===//\n  StringRef getAsmString() const { return AsmStr; }\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  StringRef getOutputConstraint(unsigned i) const {\n    assert(i < NumOutputs);\n    return Constraints[i];\n  }\n\n  Expr *getOutputExpr(unsigned i);\n\n  const Expr *getOutputExpr(unsigned i) const {\n    return const_cast<MSAsmStmt*>(this)->getOutputExpr(i);\n  }\n\n  //===--- Input operands ---===//\n\n  StringRef getInputConstraint(unsigned i) const {\n    assert(i < NumInputs);\n    return Constraints[i + NumOutputs];\n  }\n\n  Expr *getInputExpr(unsigned i);\n  void setInputExpr(unsigned i, Expr *E);\n\n  const Expr *getInputExpr(unsigned i) const {\n    return const_cast<MSAsmStmt*>(this)->getInputExpr(i);\n  }\n\n  //===--- Other ---===//\n\n  ArrayRef<StringRef> getAllConstraints() const {\n    return llvm::makeArrayRef(Constraints, NumInputs + NumOutputs);\n  }\n\n  ArrayRef<StringRef> getClobbers() const {\n    return llvm::makeArrayRef(Clobbers, NumClobbers);\n  }\n\n  ArrayRef<Expr*> getAllExprs() const {\n    return llvm::makeArrayRef(reinterpret_cast<Expr**>(Exprs),\n                              NumInputs + NumOutputs);\n  }\n\n  StringRef getClobber(unsigned i) const { return getClobbers()[i]; }\n\nprivate:\n  void initialize(const ASTContext &C, StringRef AsmString,\n                  ArrayRef<Token> AsmToks, ArrayRef<StringRef> Constraints,\n                  ArrayRef<Expr*> Exprs, ArrayRef<StringRef> Clobbers);\n\npublic:\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AsmLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MSAsmStmtClass;\n  }\n\n  child_range children() {\n    return child_range(&Exprs[0], &Exprs[NumInputs + NumOutputs]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Exprs[0], &Exprs[NumInputs + NumOutputs]);\n  }\n};\n\nclass SEHExceptStmt : public Stmt {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  SourceLocation  Loc;\n  Stmt *Children[2];\n\n  enum { FILTER_EXPR, BLOCK };\n\n  SEHExceptStmt(SourceLocation Loc, Expr *FilterExpr, Stmt *Block);\n  explicit SEHExceptStmt(EmptyShell E) : Stmt(SEHExceptStmtClass, E) {}\n\npublic:\n  static SEHExceptStmt* Create(const ASTContext &C,\n                               SourceLocation ExceptLoc,\n                               Expr *FilterExpr,\n                               Stmt *Block);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getExceptLoc(); }\n\n  SourceLocation getExceptLoc() const { return Loc; }\n  SourceLocation getEndLoc() const { return getBlock()->getEndLoc(); }\n\n  Expr *getFilterExpr() const {\n    return reinterpret_cast<Expr*>(Children[FILTER_EXPR]);\n  }\n\n  CompoundStmt *getBlock() const {\n    return cast<CompoundStmt>(Children[BLOCK]);\n  }\n\n  child_range children() {\n    return child_range(Children, Children+2);\n  }\n\n  const_child_range children() const {\n    return const_child_range(Children, Children + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHExceptStmtClass;\n  }\n};\n\nclass SEHFinallyStmt : public Stmt {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  SourceLocation  Loc;\n  Stmt *Block;\n\n  SEHFinallyStmt(SourceLocation Loc, Stmt *Block);\n  explicit SEHFinallyStmt(EmptyShell E) : Stmt(SEHFinallyStmtClass, E) {}\n\npublic:\n  static SEHFinallyStmt* Create(const ASTContext &C,\n                                SourceLocation FinallyLoc,\n                                Stmt *Block);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getFinallyLoc(); }\n\n  SourceLocation getFinallyLoc() const { return Loc; }\n  SourceLocation getEndLoc() const { return Block->getEndLoc(); }\n\n  CompoundStmt *getBlock() const { return cast<CompoundStmt>(Block); }\n\n  child_range children() {\n    return child_range(&Block,&Block+1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Block, &Block + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHFinallyStmtClass;\n  }\n};\n\nclass SEHTryStmt : public Stmt {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  bool IsCXXTry;\n  SourceLocation  TryLoc;\n  Stmt *Children[2];\n\n  enum { TRY = 0, HANDLER = 1 };\n\n  SEHTryStmt(bool isCXXTry, // true if 'try' otherwise '__try'\n             SourceLocation TryLoc,\n             Stmt *TryBlock,\n             Stmt *Handler);\n\n  explicit SEHTryStmt(EmptyShell E) : Stmt(SEHTryStmtClass, E) {}\n\npublic:\n  static SEHTryStmt* Create(const ASTContext &C, bool isCXXTry,\n                            SourceLocation TryLoc, Stmt *TryBlock,\n                            Stmt *Handler);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getTryLoc(); }\n\n  SourceLocation getTryLoc() const { return TryLoc; }\n  SourceLocation getEndLoc() const { return Children[HANDLER]->getEndLoc(); }\n\n  bool getIsCXXTry() const { return IsCXXTry; }\n\n  CompoundStmt* getTryBlock() const {\n    return cast<CompoundStmt>(Children[TRY]);\n  }\n\n  Stmt *getHandler() const { return Children[HANDLER]; }\n\n  /// Returns 0 if not defined\n  SEHExceptStmt  *getExceptHandler() const;\n  SEHFinallyStmt *getFinallyHandler() const;\n\n  child_range children() {\n    return child_range(Children, Children+2);\n  }\n\n  const_child_range children() const {\n    return const_child_range(Children, Children + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHTryStmtClass;\n  }\n};\n\n/// Represents a __leave statement.\nclass SEHLeaveStmt : public Stmt {\n  SourceLocation LeaveLoc;\n\npublic:\n  explicit SEHLeaveStmt(SourceLocation LL)\n      : Stmt(SEHLeaveStmtClass), LeaveLoc(LL) {}\n\n  /// Build an empty __leave statement.\n  explicit SEHLeaveStmt(EmptyShell Empty) : Stmt(SEHLeaveStmtClass, Empty) {}\n\n  SourceLocation getLeaveLoc() const { return LeaveLoc; }\n  void setLeaveLoc(SourceLocation L) { LeaveLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LeaveLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LeaveLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHLeaveStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// This captures a statement into a function. For example, the following\n/// pragma annotated compound statement can be represented as a CapturedStmt,\n/// and this compound statement is the body of an anonymous outlined function.\n/// @code\n/// #pragma omp parallel\n/// {\n///   compute();\n/// }\n/// @endcode\nclass CapturedStmt : public Stmt {\npublic:\n  /// The different capture forms: by 'this', by reference, capture for\n  /// variable-length array type etc.\n  enum VariableCaptureKind {\n    VCK_This,\n    VCK_ByRef,\n    VCK_ByCopy,\n    VCK_VLAType,\n  };\n\n  /// Describes the capture of either a variable, or 'this', or\n  /// variable-length array type.\n  class Capture {\n    llvm::PointerIntPair<VarDecl *, 2, VariableCaptureKind> VarAndKind;\n    SourceLocation Loc;\n\n  public:\n    friend class ASTStmtReader;\n\n    /// Create a new capture.\n    ///\n    /// \\param Loc The source location associated with this capture.\n    ///\n    /// \\param Kind The kind of capture (this, ByRef, ...).\n    ///\n    /// \\param Var The variable being captured, or null if capturing this.\n    Capture(SourceLocation Loc, VariableCaptureKind Kind,\n            VarDecl *Var = nullptr);\n\n    /// Determine the kind of capture.\n    VariableCaptureKind getCaptureKind() const;\n\n    /// Retrieve the source location at which the variable or 'this' was\n    /// first used.\n    SourceLocation getLocation() const { return Loc; }\n\n    /// Determine whether this capture handles the C++ 'this' pointer.\n    bool capturesThis() const { return getCaptureKind() == VCK_This; }\n\n    /// Determine whether this capture handles a variable (by reference).\n    bool capturesVariable() const { return getCaptureKind() == VCK_ByRef; }\n\n    /// Determine whether this capture handles a variable by copy.\n    bool capturesVariableByCopy() const {\n      return getCaptureKind() == VCK_ByCopy;\n    }\n\n    /// Determine whether this capture handles a variable-length array\n    /// type.\n    bool capturesVariableArrayType() const {\n      return getCaptureKind() == VCK_VLAType;\n    }\n\n    /// Retrieve the declaration of the variable being captured.\n    ///\n    /// This operation is only valid if this capture captures a variable.\n    VarDecl *getCapturedVar() const;\n  };\n\nprivate:\n  /// The number of variable captured, including 'this'.\n  unsigned NumCaptures;\n\n  /// The pointer part is the implicit the outlined function and the\n  /// int part is the captured region kind, 'CR_Default' etc.\n  llvm::PointerIntPair<CapturedDecl *, 2, CapturedRegionKind> CapDeclAndKind;\n\n  /// The record for captured variables, a RecordDecl or CXXRecordDecl.\n  RecordDecl *TheRecordDecl = nullptr;\n\n  /// Construct a captured statement.\n  CapturedStmt(Stmt *S, CapturedRegionKind Kind, ArrayRef<Capture> Captures,\n               ArrayRef<Expr *> CaptureInits, CapturedDecl *CD, RecordDecl *RD);\n\n  /// Construct an empty captured statement.\n  CapturedStmt(EmptyShell Empty, unsigned NumCaptures);\n\n  Stmt **getStoredStmts() { return reinterpret_cast<Stmt **>(this + 1); }\n\n  Stmt *const *getStoredStmts() const {\n    return reinterpret_cast<Stmt *const *>(this + 1);\n  }\n\n  Capture *getStoredCaptures() const;\n\n  void setCapturedStmt(Stmt *S) { getStoredStmts()[NumCaptures] = S; }\n\npublic:\n  friend class ASTStmtReader;\n\n  static CapturedStmt *Create(const ASTContext &Context, Stmt *S,\n                              CapturedRegionKind Kind,\n                              ArrayRef<Capture> Captures,\n                              ArrayRef<Expr *> CaptureInits,\n                              CapturedDecl *CD, RecordDecl *RD);\n\n  static CapturedStmt *CreateDeserialized(const ASTContext &Context,\n                                          unsigned NumCaptures);\n\n  /// Retrieve the statement being captured.\n  Stmt *getCapturedStmt() { return getStoredStmts()[NumCaptures]; }\n  const Stmt *getCapturedStmt() const { return getStoredStmts()[NumCaptures]; }\n\n  /// Retrieve the outlined function declaration.\n  CapturedDecl *getCapturedDecl();\n  const CapturedDecl *getCapturedDecl() const;\n\n  /// Set the outlined function declaration.\n  void setCapturedDecl(CapturedDecl *D);\n\n  /// Retrieve the captured region kind.\n  CapturedRegionKind getCapturedRegionKind() const;\n\n  /// Set the captured region kind.\n  void setCapturedRegionKind(CapturedRegionKind Kind);\n\n  /// Retrieve the record declaration for captured variables.\n  const RecordDecl *getCapturedRecordDecl() const { return TheRecordDecl; }\n\n  /// Set the record declaration for captured variables.\n  void setCapturedRecordDecl(RecordDecl *D) {\n    assert(D && \"null RecordDecl\");\n    TheRecordDecl = D;\n  }\n\n  /// True if this variable has been captured.\n  bool capturesVariable(const VarDecl *Var) const;\n\n  /// An iterator that walks over the captures.\n  using capture_iterator = Capture *;\n  using const_capture_iterator = const Capture *;\n  using capture_range = llvm::iterator_range<capture_iterator>;\n  using capture_const_range = llvm::iterator_range<const_capture_iterator>;\n\n  capture_range captures() {\n    return capture_range(capture_begin(), capture_end());\n  }\n  capture_const_range captures() const {\n    return capture_const_range(capture_begin(), capture_end());\n  }\n\n  /// Retrieve an iterator pointing to the first capture.\n  capture_iterator capture_begin() { return getStoredCaptures(); }\n  const_capture_iterator capture_begin() const { return getStoredCaptures(); }\n\n  /// Retrieve an iterator pointing past the end of the sequence of\n  /// captures.\n  capture_iterator capture_end() const {\n    return getStoredCaptures() + NumCaptures;\n  }\n\n  /// Retrieve the number of captures, including 'this'.\n  unsigned capture_size() const { return NumCaptures; }\n\n  /// Iterator that walks over the capture initialization arguments.\n  using capture_init_iterator = Expr **;\n  using capture_init_range = llvm::iterator_range<capture_init_iterator>;\n\n  /// Const iterator that walks over the capture initialization\n  /// arguments.\n  using const_capture_init_iterator = Expr *const *;\n  using const_capture_init_range =\n      llvm::iterator_range<const_capture_init_iterator>;\n\n  capture_init_range capture_inits() {\n    return capture_init_range(capture_init_begin(), capture_init_end());\n  }\n\n  const_capture_init_range capture_inits() const {\n    return const_capture_init_range(capture_init_begin(), capture_init_end());\n  }\n\n  /// Retrieve the first initialization argument.\n  capture_init_iterator capture_init_begin() {\n    return reinterpret_cast<Expr **>(getStoredStmts());\n  }\n\n  const_capture_init_iterator capture_init_begin() const {\n    return reinterpret_cast<Expr *const *>(getStoredStmts());\n  }\n\n  /// Retrieve the iterator pointing one past the last initialization\n  /// argument.\n  capture_init_iterator capture_init_end() {\n    return capture_init_begin() + NumCaptures;\n  }\n\n  const_capture_init_iterator capture_init_end() const {\n    return capture_init_begin() + NumCaptures;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCapturedStmt()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCapturedStmt()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return getCapturedStmt()->getSourceRange();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CapturedStmtClass;\n  }\n\n  child_range children();\n\n  const_child_range children() const;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_STMT_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "content": "//===- StmtIterator.h - Iterators for Statements ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StmtIterator and ConstStmtIterator classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMTITERATOR_H\n#define LLVM_CLANG_AST_STMTITERATOR_H\n\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n\nnamespace clang {\n\nclass Decl;\nclass Stmt;\nclass VariableArrayType;\n\nclass StmtIteratorBase {\nprotected:\n  enum {\n    StmtMode = 0x0,\n    SizeOfTypeVAMode = 0x1,\n    DeclGroupMode = 0x2,\n    Flags = 0x3\n  };\n\n  union {\n    Stmt **stmt;\n    Decl **DGI;\n  };\n  uintptr_t RawVAPtr = 0;\n  Decl **DGE;\n\n  StmtIteratorBase(Stmt **s) : stmt(s) {}\n  StmtIteratorBase(const VariableArrayType *t);\n  StmtIteratorBase(Decl **dgi, Decl **dge);\n  StmtIteratorBase() : stmt(nullptr) {}\n\n  bool inDeclGroup() const {\n    return (RawVAPtr & Flags) == DeclGroupMode;\n  }\n\n  bool inSizeOfTypeVA() const {\n    return (RawVAPtr & Flags) == SizeOfTypeVAMode;\n  }\n\n  bool inStmt() const {\n    return (RawVAPtr & Flags) == StmtMode;\n  }\n\n  const VariableArrayType *getVAPtr() const {\n    return reinterpret_cast<const VariableArrayType*>(RawVAPtr & ~Flags);\n  }\n\n  void setVAPtr(const VariableArrayType *P) {\n    assert(inDeclGroup() || inSizeOfTypeVA());\n    RawVAPtr = reinterpret_cast<uintptr_t>(P) | (RawVAPtr & Flags);\n  }\n\n  void NextDecl(bool ImmediateAdvance = true);\n  bool HandleDecl(Decl* D);\n  void NextVA();\n\n  Stmt*& GetDeclExpr() const;\n};\n\ntemplate <typename DERIVED, typename REFERENCE>\nclass StmtIteratorImpl : public StmtIteratorBase,\n                         public std::iterator<std::forward_iterator_tag,\n                                              REFERENCE, ptrdiff_t,\n                                              REFERENCE, REFERENCE> {\nprotected:\n  StmtIteratorImpl(const StmtIteratorBase& RHS) : StmtIteratorBase(RHS) {}\n\npublic:\n  StmtIteratorImpl() = default;\n  StmtIteratorImpl(Stmt **s) : StmtIteratorBase(s) {}\n  StmtIteratorImpl(Decl **dgi, Decl **dge) : StmtIteratorBase(dgi, dge) {}\n  StmtIteratorImpl(const VariableArrayType *t) : StmtIteratorBase(t) {}\n\n  DERIVED& operator++() {\n    if (inStmt())\n      ++stmt;\n    else if (getVAPtr())\n      NextVA();\n    else\n      NextDecl();\n\n    return static_cast<DERIVED&>(*this);\n  }\n\n  DERIVED operator++(int) {\n    DERIVED tmp = static_cast<DERIVED&>(*this);\n    operator++();\n    return tmp;\n  }\n\n  friend bool operator==(const DERIVED &LHS, const DERIVED &RHS) {\n    return LHS.stmt == RHS.stmt && LHS.DGI == RHS.DGI &&\n           LHS.RawVAPtr == RHS.RawVAPtr;\n  }\n\n  friend bool operator!=(const DERIVED &LHS, const DERIVED &RHS) {\n    return !(LHS == RHS);\n  }\n\n  REFERENCE operator*() const {\n    return inStmt() ? *stmt : GetDeclExpr();\n  }\n\n  REFERENCE operator->() const { return operator*(); }\n};\n\nstruct ConstStmtIterator;\n\nstruct StmtIterator : public StmtIteratorImpl<StmtIterator, Stmt*&> {\n  explicit StmtIterator() = default;\n  StmtIterator(Stmt** S) : StmtIteratorImpl<StmtIterator, Stmt*&>(S) {}\n  StmtIterator(Decl** dgi, Decl** dge)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(dgi, dge) {}\n  StmtIterator(const VariableArrayType *t)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(t) {}\n\nprivate:\n  StmtIterator(const StmtIteratorBase &RHS)\n      : StmtIteratorImpl<StmtIterator, Stmt *&>(RHS) {}\n\n  inline friend StmtIterator\n  cast_away_const(const ConstStmtIterator &RHS);\n};\n\nstruct ConstStmtIterator : public StmtIteratorImpl<ConstStmtIterator,\n                                                   const Stmt*> {\n  explicit ConstStmtIterator() = default;\n  ConstStmtIterator(const StmtIterator& RHS)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt*>(RHS) {}\n\n  ConstStmtIterator(Stmt * const *S)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt *>(\n            const_cast<Stmt **>(S)) {}\n};\n\ninline StmtIterator cast_away_const(const ConstStmtIterator &RHS) {\n  return RHS;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_STMTITERATOR_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "content": "//===- TemplateBase.h - Core classes for C++ templates ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides definitions which are common for all kinds of\n//  template representation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TEMPLATEBASE_H\n#define LLVM_CLANG_AST_TEMPLATEBASE_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\n\n// Provide PointerLikeTypeTraits for clang::Expr*, this default one requires a\n// full definition of Expr, but this file only sees a forward del because of\n// the dependency.\ntemplate <> struct PointerLikeTypeTraits<clang::Expr *> {\n  static inline void *getAsVoidPointer(clang::Expr *P) { return P; }\n  static inline clang::Expr *getFromVoidPointer(void *P) {\n    return static_cast<clang::Expr *>(P);\n  }\n  static constexpr int NumLowBitsAvailable = 2;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\nclass DiagnosticBuilder;\nclass Expr;\nstruct PrintingPolicy;\nclass TypeSourceInfo;\nclass ValueDecl;\n\n/// Represents a template argument.\nclass TemplateArgument {\npublic:\n  /// The kind of template argument we're storing.\n  enum ArgKind {\n    /// Represents an empty template argument, e.g., one that has not\n    /// been deduced.\n    Null = 0,\n\n    /// The template argument is a type.\n    Type,\n\n    /// The template argument is a declaration that was provided for a pointer,\n    /// reference, or pointer to member non-type template parameter.\n    Declaration,\n\n    /// The template argument is a null pointer or null pointer to member that\n    /// was provided for a non-type template parameter.\n    NullPtr,\n\n    /// The template argument is an integral value stored in an llvm::APSInt\n    /// that was provided for an integral non-type template parameter.\n    Integral,\n\n    /// The template argument is a template name that was provided for a\n    /// template template parameter.\n    Template,\n\n    /// The template argument is a pack expansion of a template name that was\n    /// provided for a template template parameter.\n    TemplateExpansion,\n\n    /// The template argument is an expression, and we've not resolved it to one\n    /// of the other forms yet, either because it's dependent or because we're\n    /// representing a non-canonical template argument (for instance, in a\n    /// TemplateSpecializationType).\n    Expression,\n\n    /// The template argument is actually a parameter pack. Arguments are stored\n    /// in the Args struct.\n    Pack\n  };\n\nprivate:\n  /// The kind of template argument we're storing.\n\n  struct DA {\n    unsigned Kind;\n    void *QT;\n    ValueDecl *D;\n  };\n  struct I {\n    unsigned Kind;\n    // We store a decomposed APSInt with the data allocated by ASTContext if\n    // BitWidth > 64. The memory may be shared between multiple\n    // TemplateArgument instances.\n    unsigned BitWidth : 31;\n    unsigned IsUnsigned : 1;\n    union {\n      /// Used to store the <= 64 bits integer value.\n      uint64_t VAL;\n\n      /// Used to store the >64 bits integer value.\n      const uint64_t *pVal;\n    };\n    void *Type;\n  };\n  struct A {\n    unsigned Kind;\n    unsigned NumArgs;\n    const TemplateArgument *Args;\n  };\n  struct TA {\n    unsigned Kind;\n    unsigned NumExpansions;\n    void *Name;\n  };\n  struct TV {\n    unsigned Kind;\n    uintptr_t V;\n  };\n  union {\n    struct DA DeclArg;\n    struct I Integer;\n    struct A Args;\n    struct TA TemplateArg;\n    struct TV TypeOrValue;\n  };\n\npublic:\n  /// Construct an empty, invalid template argument.\n  constexpr TemplateArgument() : TypeOrValue({Null, 0}) {}\n\n  /// Construct a template type argument.\n  TemplateArgument(QualType T, bool isNullPtr = false) {\n    TypeOrValue.Kind = isNullPtr ? NullPtr : Type;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n  }\n\n  /// Construct a template argument that refers to a\n  /// declaration, which is either an external declaration or a\n  /// template declaration.\n  TemplateArgument(ValueDecl *D, QualType QT) {\n    assert(D && \"Expected decl\");\n    DeclArg.Kind = Declaration;\n    DeclArg.QT = QT.getAsOpaquePtr();\n    DeclArg.D = D;\n  }\n\n  /// Construct an integral constant template argument. The memory to\n  /// store the value is allocated with Ctx.\n  TemplateArgument(ASTContext &Ctx, const llvm::APSInt &Value, QualType Type);\n\n  /// Construct an integral constant template argument with the same\n  /// value as Other but a different type.\n  TemplateArgument(const TemplateArgument &Other, QualType Type) {\n    Integer = Other.Integer;\n    Integer.Type = Type.getAsOpaquePtr();\n  }\n\n  /// Construct a template argument that is a template.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  TemplateArgument(TemplateName Name) {\n    TemplateArg.Kind = Template;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is a template pack expansion.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  ///\n  /// \\param NumExpansions The number of expansions that will be generated by\n  /// instantiating\n  TemplateArgument(TemplateName Name, Optional<unsigned> NumExpansions) {\n    TemplateArg.Kind = TemplateExpansion;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    if (NumExpansions)\n      TemplateArg.NumExpansions = *NumExpansions + 1;\n    else\n      TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is an expression.\n  ///\n  /// This form of template argument only occurs in template argument\n  /// lists used for dependent types and for expression; it will not\n  /// occur in a non-dependent, canonical template argument list.\n  TemplateArgument(Expr *E) {\n    TypeOrValue.Kind = Expression;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(E);\n  }\n\n  /// Construct a template argument that is a template argument pack.\n  ///\n  /// We assume that storage for the template arguments provided\n  /// outlives the TemplateArgument itself.\n  explicit TemplateArgument(ArrayRef<TemplateArgument> Args) {\n    this->Args.Kind = Pack;\n    this->Args.Args = Args.data();\n    this->Args.NumArgs = Args.size();\n  }\n\n  TemplateArgument(TemplateName, bool) = delete;\n\n  static TemplateArgument getEmptyPack() { return TemplateArgument(None); }\n\n  /// Create a new template argument pack by copying the given set of\n  /// template arguments.\n  static TemplateArgument CreatePackCopy(ASTContext &Context,\n                                         ArrayRef<TemplateArgument> Args);\n\n  /// Return the kind of stored template argument.\n  ArgKind getKind() const { return (ArgKind)TypeOrValue.Kind; }\n\n  /// Determine whether this template argument has no value.\n  bool isNull() const { return getKind() == Null; }\n\n  TemplateArgumentDependence getDependence() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter such that its result can change from one instantiation to\n  /// another.\n  bool isDependent() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this template argument contains an unexpanded\n  /// parameter pack.\n  bool containsUnexpandedParameterPack() const;\n\n  /// Determine whether this template argument is a pack expansion.\n  bool isPackExpansion() const;\n\n  /// Retrieve the type for a type template argument.\n  QualType getAsType() const {\n    assert(getKind() == Type && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the declaration for a declaration non-type\n  /// template argument.\n  ValueDecl *getAsDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return DeclArg.D;\n  }\n\n  QualType getParamTypeForDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(DeclArg.QT);\n  }\n\n  /// Retrieve the type for null non-type template argument.\n  QualType getNullPtrType() const {\n    assert(getKind() == NullPtr && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the template name for a template name argument.\n  TemplateName getAsTemplate() const {\n    assert(getKind() == Template && \"Unexpected kind\");\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the template argument as a template name; if the argument\n  /// is a pack expansion, return the pattern as a template name.\n  TemplateName getAsTemplateOrTemplatePattern() const {\n    assert((getKind() == Template || getKind() == TemplateExpansion) &&\n           \"Unexpected kind\");\n\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the number of expansions that a template template argument\n  /// expansion will produce, if known.\n  Optional<unsigned> getNumTemplateExpansions() const;\n\n  /// Retrieve the template argument as an integral value.\n  // FIXME: Provide a way to read the integral data without copying the value.\n  llvm::APSInt getAsIntegral() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n\n    using namespace llvm;\n\n    if (Integer.BitWidth <= 64)\n      return APSInt(APInt(Integer.BitWidth, Integer.VAL), Integer.IsUnsigned);\n\n    unsigned NumWords = APInt::getNumWords(Integer.BitWidth);\n    return APSInt(APInt(Integer.BitWidth, makeArrayRef(Integer.pVal, NumWords)),\n                  Integer.IsUnsigned);\n  }\n\n  /// Retrieve the type of the integral value.\n  QualType getIntegralType() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(Integer.Type);\n  }\n\n  void setIntegralType(QualType T) {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    Integer.Type = T.getAsOpaquePtr();\n  }\n\n  /// If this is a non-type template argument, get its type. Otherwise,\n  /// returns a null QualType.\n  QualType getNonTypeTemplateArgumentType() const;\n\n  /// Retrieve the template argument as an expression.\n  Expr *getAsExpr() const {\n    assert(getKind() == Expression && \"Unexpected kind\");\n    return reinterpret_cast<Expr *>(TypeOrValue.V);\n  }\n\n  /// Iterator that traverses the elements of a template argument pack.\n  using pack_iterator = const TemplateArgument *;\n\n  /// Iterator referencing the first argument of a template argument\n  /// pack.\n  pack_iterator pack_begin() const {\n    assert(getKind() == Pack);\n    return Args.Args;\n  }\n\n  /// Iterator referencing one past the last argument of a template\n  /// argument pack.\n  pack_iterator pack_end() const {\n    assert(getKind() == Pack);\n    return Args.Args + Args.NumArgs;\n  }\n\n  /// Iterator range referencing all of the elements of a template\n  /// argument pack.\n  ArrayRef<TemplateArgument> pack_elements() const {\n    return llvm::makeArrayRef(pack_begin(), pack_end());\n  }\n\n  /// The number of template arguments in the given template argument\n  /// pack.\n  unsigned pack_size() const {\n    assert(getKind() == Pack);\n    return Args.NumArgs;\n  }\n\n  /// Return the array of arguments in this template argument pack.\n  ArrayRef<TemplateArgument> getPackAsArray() const {\n    assert(getKind() == Pack);\n    return llvm::makeArrayRef(Args.Args, Args.NumArgs);\n  }\n\n  /// Determines whether two template arguments are superficially the\n  /// same.\n  bool structurallyEquals(const TemplateArgument &Other) const;\n\n  /// When the template argument is a pack expansion, returns\n  /// the pattern of the pack expansion.\n  TemplateArgument getPackExpansionPattern() const;\n\n  /// Print this template argument to the given output stream.\n  void print(const PrintingPolicy &Policy, raw_ostream &Out) const;\n\n  /// Debugging aid that dumps the template argument.\n  void dump(raw_ostream &Out) const;\n\n  /// Debugging aid that dumps the template argument to standard error.\n  void dump() const;\n\n  /// Used to insert TemplateArguments into FoldingSets.\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) const;\n};\n\n/// Location information for a TemplateArgument.\nstruct TemplateArgumentLocInfo {\nprivate:\n  struct TemplateTemplateArgLocInfo {\n    // FIXME: We'd like to just use the qualifier in the TemplateName,\n    // but template arguments get canonicalized too quickly.\n    NestedNameSpecifier *Qualifier;\n    void *QualifierLocData;\n    SourceLocation TemplateNameLoc;\n    SourceLocation EllipsisLoc;\n  };\n\n  llvm::PointerUnion<TemplateTemplateArgLocInfo *, Expr *, TypeSourceInfo *>\n      Pointer;\n\n  TemplateTemplateArgLocInfo *getTemplate() const {\n    return Pointer.get<TemplateTemplateArgLocInfo *>();\n  }\n\npublic:\n  TemplateArgumentLocInfo() {}\n  TemplateArgumentLocInfo(TypeSourceInfo *Declarator) { Pointer = Declarator; }\n\n  TemplateArgumentLocInfo(Expr *E) { Pointer = E; }\n  // Ctx is used for allocation -- this case is unusually large and also rare,\n  // so we store the payload out-of-line.\n  TemplateArgumentLocInfo(ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n                          SourceLocation TemplateNameLoc,\n                          SourceLocation EllipsisLoc);\n\n  TypeSourceInfo *getAsTypeSourceInfo() const {\n    return Pointer.get<TypeSourceInfo *>();\n  }\n\n  Expr *getAsExpr() const { return Pointer.get<Expr *>(); }\n\n  NestedNameSpecifierLoc getTemplateQualifierLoc() const {\n    const auto *Template = getTemplate();\n    return NestedNameSpecifierLoc(Template->Qualifier,\n                                  Template->QualifierLocData);\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return getTemplate()->TemplateNameLoc;\n  }\n\n  SourceLocation getTemplateEllipsisLoc() const {\n    return getTemplate()->EllipsisLoc;\n  }\n};\n\n/// Location wrapper for a TemplateArgument.  TemplateArgument is to\n/// TemplateArgumentLoc as Type is to TypeLoc.\nclass TemplateArgumentLoc {\n  TemplateArgument Argument;\n  TemplateArgumentLocInfo LocInfo;\n\npublic:\n  TemplateArgumentLoc() {}\n\n  TemplateArgumentLoc(const TemplateArgument &Argument,\n                      TemplateArgumentLocInfo Opaque)\n      : Argument(Argument), LocInfo(Opaque) {}\n\n  TemplateArgumentLoc(const TemplateArgument &Argument, TypeSourceInfo *TInfo)\n      : Argument(Argument), LocInfo(TInfo) {\n    assert(Argument.getKind() == TemplateArgument::Type);\n  }\n\n  TemplateArgumentLoc(const TemplateArgument &Argument, Expr *E)\n      : Argument(Argument), LocInfo(E) {\n\n    // Permit any kind of template argument that can be represented with an\n    // expression.\n    assert(Argument.getKind() == TemplateArgument::NullPtr ||\n           Argument.getKind() == TemplateArgument::Integral ||\n           Argument.getKind() == TemplateArgument::Declaration ||\n           Argument.getKind() == TemplateArgument::Expression);\n  }\n\n  TemplateArgumentLoc(ASTContext &Ctx, const TemplateArgument &Argument,\n                      NestedNameSpecifierLoc QualifierLoc,\n                      SourceLocation TemplateNameLoc,\n                      SourceLocation EllipsisLoc = SourceLocation())\n      : Argument(Argument),\n        LocInfo(Ctx, QualifierLoc, TemplateNameLoc, EllipsisLoc) {\n    assert(Argument.getKind() == TemplateArgument::Template ||\n           Argument.getKind() == TemplateArgument::TemplateExpansion);\n  }\n\n  /// - Fetches the primary location of the argument.\n  SourceLocation getLocation() const {\n    if (Argument.getKind() == TemplateArgument::Template ||\n        Argument.getKind() == TemplateArgument::TemplateExpansion)\n      return getTemplateNameLoc();\n\n    return getSourceRange().getBegin();\n  }\n\n  /// - Fetches the full source range of the argument.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  const TemplateArgument &getArgument() const {\n    return Argument;\n  }\n\n  TemplateArgumentLocInfo getLocInfo() const {\n    return LocInfo;\n  }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    assert(Argument.getKind() == TemplateArgument::Type);\n    return LocInfo.getAsTypeSourceInfo();\n  }\n\n  Expr *getSourceExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Expression);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceDeclExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Declaration);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceNullPtrExpression() const {\n    assert(Argument.getKind() == TemplateArgument::NullPtr);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceIntegralExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Integral);\n    return LocInfo.getAsExpr();\n  }\n\n  NestedNameSpecifierLoc getTemplateQualifierLoc() const {\n    if (Argument.getKind() != TemplateArgument::Template &&\n        Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return NestedNameSpecifierLoc();\n    return LocInfo.getTemplateQualifierLoc();\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    if (Argument.getKind() != TemplateArgument::Template &&\n        Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return SourceLocation();\n    return LocInfo.getTemplateNameLoc();\n  }\n\n  SourceLocation getTemplateEllipsisLoc() const {\n    if (Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return SourceLocation();\n    return LocInfo.getTemplateEllipsisLoc();\n  }\n};\n\n/// A convenient class for passing around template argument\n/// information.  Designed to be passed by reference.\nclass TemplateArgumentListInfo {\n  SmallVector<TemplateArgumentLoc, 8> Arguments;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n\npublic:\n  TemplateArgumentListInfo() = default;\n\n  TemplateArgumentListInfo(SourceLocation LAngleLoc,\n                           SourceLocation RAngleLoc)\n      : LAngleLoc(LAngleLoc), RAngleLoc(RAngleLoc) {}\n\n  // This can leak if used in an AST node, use ASTTemplateArgumentListInfo\n  // instead.\n  void *operator new(size_t bytes, ASTContext &C) = delete;\n\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  void setLAngleLoc(SourceLocation Loc) { LAngleLoc = Loc; }\n  void setRAngleLoc(SourceLocation Loc) { RAngleLoc = Loc; }\n\n  unsigned size() const { return Arguments.size(); }\n\n  const TemplateArgumentLoc *getArgumentArray() const {\n    return Arguments.data();\n  }\n\n  llvm::ArrayRef<TemplateArgumentLoc> arguments() const {\n    return Arguments;\n  }\n\n  const TemplateArgumentLoc &operator[](unsigned I) const {\n    return Arguments[I];\n  }\n\n  TemplateArgumentLoc &operator[](unsigned I) {\n    return Arguments[I];\n  }\n\n  void addArgument(const TemplateArgumentLoc &Loc) {\n    Arguments.push_back(Loc);\n  }\n};\n\n/// Represents an explicit template argument list in C++, e.g.,\n/// the \"<int>\" in \"sort<int>\".\n/// This is safe to be used inside an AST node, in contrast with\n/// TemplateArgumentListInfo.\nstruct ASTTemplateArgumentListInfo final\n    : private llvm::TrailingObjects<ASTTemplateArgumentListInfo,\n                                    TemplateArgumentLoc> {\nprivate:\n  friend class ASTNodeImporter;\n  friend TrailingObjects;\n\n  ASTTemplateArgumentListInfo(const TemplateArgumentListInfo &List);\n\npublic:\n  /// The source location of the left angle bracket ('<').\n  SourceLocation LAngleLoc;\n\n  /// The source location of the right angle bracket ('>').\n  SourceLocation RAngleLoc;\n\n  /// The number of template arguments in TemplateArgs.\n  unsigned NumTemplateArgs;\n\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  /// Retrieve the template arguments\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n  unsigned getNumTemplateArgs() const { return NumTemplateArgs; }\n\n  llvm::ArrayRef<TemplateArgumentLoc> arguments() const {\n    return llvm::makeArrayRef(getTemplateArgs(), getNumTemplateArgs());\n  }\n\n  const TemplateArgumentLoc &operator[](unsigned I) const {\n    return getTemplateArgs()[I];\n  }\n\n  static const ASTTemplateArgumentListInfo *\n  Create(const ASTContext &C, const TemplateArgumentListInfo &List);\n};\n\n/// Represents an explicit template argument list in C++, e.g.,\n/// the \"<int>\" in \"sort<int>\".\n///\n/// It is intended to be used as a trailing object on AST nodes, and\n/// as such, doesn't contain the array of TemplateArgumentLoc itself,\n/// but expects the containing object to also provide storage for\n/// that.\nstruct alignas(void *) ASTTemplateKWAndArgsInfo {\n  /// The source location of the left angle bracket ('<').\n  SourceLocation LAngleLoc;\n\n  /// The source location of the right angle bracket ('>').\n  SourceLocation RAngleLoc;\n\n  /// The source location of the template keyword; this is used\n  /// as part of the representation of qualified identifiers, such as\n  /// S<T>::template apply<T>.  Will be empty if this expression does\n  /// not have a template keyword.\n  SourceLocation TemplateKWLoc;\n\n  /// The number of template arguments in TemplateArgs.\n  unsigned NumTemplateArgs;\n\n  void initializeFrom(SourceLocation TemplateKWLoc,\n                      const TemplateArgumentListInfo &List,\n                      TemplateArgumentLoc *OutArgArray);\n  // FIXME: The parameter Deps is the result populated by this method, the\n  // caller doesn't need it since it is populated by computeDependence. remove\n  // it.\n  void initializeFrom(SourceLocation TemplateKWLoc,\n                      const TemplateArgumentListInfo &List,\n                      TemplateArgumentLoc *OutArgArray,\n                      TemplateArgumentDependence &Deps);\n  void initializeFrom(SourceLocation TemplateKWLoc);\n\n  void copyInto(const TemplateArgumentLoc *ArgArray,\n                TemplateArgumentListInfo &List) const;\n};\n\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      const TemplateArgument &Arg);\n\ninline TemplateSpecializationType::iterator\n    TemplateSpecializationType::end() const {\n  return getArgs() + getNumArgs();\n}\n\ninline DependentTemplateSpecializationType::iterator\n    DependentTemplateSpecializationType::end() const {\n  return getArgs() + getNumArgs();\n}\n\ninline const TemplateArgument &\n    TemplateSpecializationType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\ninline const TemplateArgument &\n    DependentTemplateSpecializationType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\ninline const TemplateArgument &AutoType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TEMPLATEBASE_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "content": "//===- Type.h - C Language Family Type Representation -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// C Language Family Type Representation\n///\n/// This file defines the clang::Type interface and subclasses, used to\n/// represent types for languages in the C family.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TYPE_H\n#define LLVM_CLANG_AST_TYPE_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ExtQuals;\nclass QualType;\nclass ConceptDecl;\nclass TagDecl;\nclass TemplateParameterList;\nclass Type;\n\nenum {\n  TypeAlignmentInBits = 4,\n  TypeAlignment = 1 << TypeAlignmentInBits\n};\n\nnamespace serialization {\n  template <class T> class AbstractTypeReader;\n  template <class T> class AbstractTypeWriter;\n}\n\n} // namespace clang\n\nnamespace llvm {\n\n  template <typename T>\n  struct PointerLikeTypeTraits;\n  template<>\n  struct PointerLikeTypeTraits< ::clang::Type*> {\n    static inline void *getAsVoidPointer(::clang::Type *P) { return P; }\n\n    static inline ::clang::Type *getFromVoidPointer(void *P) {\n      return static_cast< ::clang::Type*>(P);\n    }\n\n    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;\n  };\n\n  template<>\n  struct PointerLikeTypeTraits< ::clang::ExtQuals*> {\n    static inline void *getAsVoidPointer(::clang::ExtQuals *P) { return P; }\n\n    static inline ::clang::ExtQuals *getFromVoidPointer(void *P) {\n      return static_cast< ::clang::ExtQuals*>(P);\n    }\n\n    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;\n  };\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\ntemplate <typename> class CanQual;\nclass CXXRecordDecl;\nclass DeclContext;\nclass EnumDecl;\nclass Expr;\nclass ExtQualsTypeCommonBase;\nclass FunctionDecl;\nclass IdentifierInfo;\nclass NamedDecl;\nclass ObjCInterfaceDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass Stmt;\nclass TagDecl;\nclass TemplateArgument;\nclass TemplateArgumentListInfo;\nclass TemplateArgumentLoc;\nclass TemplateTypeParmDecl;\nclass TypedefNameDecl;\nclass UnresolvedUsingTypenameDecl;\n\nusing CanQualType = CanQual<Type>;\n\n// Provide forward declarations for all of the *Type classes.\n#define TYPE(Class, Base) class Class##Type;\n#include \"clang/AST/TypeNodes.inc\"\n\n/// The collection of all-type qualifiers we support.\n/// Clang supports five independent qualifiers:\n/// * C99: const, volatile, and restrict\n/// * MS: __unaligned\n/// * Embedded C (TR18037): address spaces\n/// * Objective C: the GC attributes (none, weak, or strong)\nclass Qualifiers {\npublic:\n  enum TQ { // NOTE: These flags must be kept in sync with DeclSpec::TQ.\n    Const    = 0x1,\n    Restrict = 0x2,\n    Volatile = 0x4,\n    CVRMask = Const | Volatile | Restrict\n  };\n\n  enum GC {\n    GCNone = 0,\n    Weak,\n    Strong\n  };\n\n  enum ObjCLifetime {\n    /// There is no lifetime qualification on this type.\n    OCL_None,\n\n    /// This object can be modified without requiring retains or\n    /// releases.\n    OCL_ExplicitNone,\n\n    /// Assigning into this object requires the old value to be\n    /// released and the new value to be retained.  The timing of the\n    /// release of the old value is inexact: it may be moved to\n    /// immediately after the last known point where the value is\n    /// live.\n    OCL_Strong,\n\n    /// Reading or writing from this object requires a barrier call.\n    OCL_Weak,\n\n    /// Assigning into this object requires a lifetime extension.\n    OCL_Autoreleasing\n  };\n\n  enum {\n    /// The maximum supported address space number.\n    /// 23 bits should be enough for anyone.\n    MaxAddressSpace = 0x7fffffu,\n\n    /// The width of the \"fast\" qualifier mask.\n    FastWidth = 3,\n\n    /// The fast qualifier mask.\n    FastMask = (1 << FastWidth) - 1\n  };\n\n  /// Returns the common set of qualifiers while removing them from\n  /// the given sets.\n  static Qualifiers removeCommonQualifiers(Qualifiers &L, Qualifiers &R) {\n    // If both are only CVR-qualified, bit operations are sufficient.\n    if (!(L.Mask & ~CVRMask) && !(R.Mask & ~CVRMask)) {\n      Qualifiers Q;\n      Q.Mask = L.Mask & R.Mask;\n      L.Mask &= ~Q.Mask;\n      R.Mask &= ~Q.Mask;\n      return Q;\n    }\n\n    Qualifiers Q;\n    unsigned CommonCRV = L.getCVRQualifiers() & R.getCVRQualifiers();\n    Q.addCVRQualifiers(CommonCRV);\n    L.removeCVRQualifiers(CommonCRV);\n    R.removeCVRQualifiers(CommonCRV);\n\n    if (L.getObjCGCAttr() == R.getObjCGCAttr()) {\n      Q.setObjCGCAttr(L.getObjCGCAttr());\n      L.removeObjCGCAttr();\n      R.removeObjCGCAttr();\n    }\n\n    if (L.getObjCLifetime() == R.getObjCLifetime()) {\n      Q.setObjCLifetime(L.getObjCLifetime());\n      L.removeObjCLifetime();\n      R.removeObjCLifetime();\n    }\n\n    if (L.getAddressSpace() == R.getAddressSpace()) {\n      Q.setAddressSpace(L.getAddressSpace());\n      L.removeAddressSpace();\n      R.removeAddressSpace();\n    }\n    return Q;\n  }\n\n  static Qualifiers fromFastMask(unsigned Mask) {\n    Qualifiers Qs;\n    Qs.addFastQualifiers(Mask);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRMask(unsigned CVR) {\n    Qualifiers Qs;\n    Qs.addCVRQualifiers(CVR);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRUMask(unsigned CVRU) {\n    Qualifiers Qs;\n    Qs.addCVRUQualifiers(CVRU);\n    return Qs;\n  }\n\n  // Deserialize qualifiers from an opaque representation.\n  static Qualifiers fromOpaqueValue(unsigned opaque) {\n    Qualifiers Qs;\n    Qs.Mask = opaque;\n    return Qs;\n  }\n\n  // Serialize these qualifiers into an opaque representation.\n  unsigned getAsOpaqueValue() const {\n    return Mask;\n  }\n\n  bool hasConst() const { return Mask & Const; }\n  bool hasOnlyConst() const { return Mask == Const; }\n  void removeConst() { Mask &= ~Const; }\n  void addConst() { Mask |= Const; }\n\n  bool hasVolatile() const { return Mask & Volatile; }\n  bool hasOnlyVolatile() const { return Mask == Volatile; }\n  void removeVolatile() { Mask &= ~Volatile; }\n  void addVolatile() { Mask |= Volatile; }\n\n  bool hasRestrict() const { return Mask & Restrict; }\n  bool hasOnlyRestrict() const { return Mask == Restrict; }\n  void removeRestrict() { Mask &= ~Restrict; }\n  void addRestrict() { Mask |= Restrict; }\n\n  bool hasCVRQualifiers() const { return getCVRQualifiers(); }\n  unsigned getCVRQualifiers() const { return Mask & CVRMask; }\n  unsigned getCVRUQualifiers() const { return Mask & (CVRMask | UMask); }\n\n  void setCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask = (Mask & ~CVRMask) | mask;\n  }\n  void removeCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask &= ~mask;\n  }\n  void removeCVRQualifiers() {\n    removeCVRQualifiers(CVRMask);\n  }\n  void addCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask |= mask;\n  }\n  void addCVRUQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask & ~UMask) && \"bitmask contains non-CVRU bits\");\n    Mask |= mask;\n  }\n\n  bool hasUnaligned() const { return Mask & UMask; }\n  void setUnaligned(bool flag) {\n    Mask = (Mask & ~UMask) | (flag ? UMask : 0);\n  }\n  void removeUnaligned() { Mask &= ~UMask; }\n  void addUnaligned() { Mask |= UMask; }\n\n  bool hasObjCGCAttr() const { return Mask & GCAttrMask; }\n  GC getObjCGCAttr() const { return GC((Mask & GCAttrMask) >> GCAttrShift); }\n  void setObjCGCAttr(GC type) {\n    Mask = (Mask & ~GCAttrMask) | (type << GCAttrShift);\n  }\n  void removeObjCGCAttr() { setObjCGCAttr(GCNone); }\n  void addObjCGCAttr(GC type) {\n    assert(type);\n    setObjCGCAttr(type);\n  }\n  Qualifiers withoutObjCGCAttr() const {\n    Qualifiers qs = *this;\n    qs.removeObjCGCAttr();\n    return qs;\n  }\n  Qualifiers withoutObjCLifetime() const {\n    Qualifiers qs = *this;\n    qs.removeObjCLifetime();\n    return qs;\n  }\n  Qualifiers withoutAddressSpace() const {\n    Qualifiers qs = *this;\n    qs.removeAddressSpace();\n    return qs;\n  }\n\n  bool hasObjCLifetime() const { return Mask & LifetimeMask; }\n  ObjCLifetime getObjCLifetime() const {\n    return ObjCLifetime((Mask & LifetimeMask) >> LifetimeShift);\n  }\n  void setObjCLifetime(ObjCLifetime type) {\n    Mask = (Mask & ~LifetimeMask) | (type << LifetimeShift);\n  }\n  void removeObjCLifetime() { setObjCLifetime(OCL_None); }\n  void addObjCLifetime(ObjCLifetime type) {\n    assert(type);\n    assert(!hasObjCLifetime());\n    Mask |= (type << LifetimeShift);\n  }\n\n  /// True if the lifetime is neither None or ExplicitNone.\n  bool hasNonTrivialObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime > OCL_ExplicitNone);\n  }\n\n  /// True if the lifetime is either strong or weak.\n  bool hasStrongOrWeakObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime == OCL_Strong || lifetime == OCL_Weak);\n  }\n\n  bool hasAddressSpace() const { return Mask & AddressSpaceMask; }\n  LangAS getAddressSpace() const {\n    return static_cast<LangAS>(Mask >> AddressSpaceShift);\n  }\n  bool hasTargetSpecificAddressSpace() const {\n    return isTargetAddressSpace(getAddressSpace());\n  }\n  /// Get the address space attribute value to be printed by diagnostics.\n  unsigned getAddressSpaceAttributePrintValue() const {\n    auto Addr = getAddressSpace();\n    // This function is not supposed to be used with language specific\n    // address spaces. If that happens, the diagnostic message should consider\n    // printing the QualType instead of the address space value.\n    assert(Addr == LangAS::Default || hasTargetSpecificAddressSpace());\n    if (Addr != LangAS::Default)\n      return toTargetAddressSpace(Addr);\n    // TODO: The diagnostic messages where Addr may be 0 should be fixed\n    // since it cannot differentiate the situation where 0 denotes the default\n    // address space or user specified __attribute__((address_space(0))).\n    return 0;\n  }\n  void setAddressSpace(LangAS space) {\n    assert((unsigned)space <= MaxAddressSpace);\n    Mask = (Mask & ~AddressSpaceMask)\n         | (((uint32_t) space) << AddressSpaceShift);\n  }\n  void removeAddressSpace() { setAddressSpace(LangAS::Default); }\n  void addAddressSpace(LangAS space) {\n    assert(space != LangAS::Default);\n    setAddressSpace(space);\n  }\n\n  // Fast qualifiers are those that can be allocated directly\n  // on a QualType object.\n  bool hasFastQualifiers() const { return getFastQualifiers(); }\n  unsigned getFastQualifiers() const { return Mask & FastMask; }\n  void setFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask = (Mask & ~FastMask) | mask;\n  }\n  void removeFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask &= ~mask;\n  }\n  void removeFastQualifiers() {\n    removeFastQualifiers(FastMask);\n  }\n  void addFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask |= mask;\n  }\n\n  /// Return true if the set contains any qualifiers which require an ExtQuals\n  /// node to be allocated.\n  bool hasNonFastQualifiers() const { return Mask & ~FastMask; }\n  Qualifiers getNonFastQualifiers() const {\n    Qualifiers Quals = *this;\n    Quals.setFastQualifiers(0);\n    return Quals;\n  }\n\n  /// Return true if the set contains any qualifiers.\n  bool hasQualifiers() const { return Mask; }\n  bool empty() const { return !Mask; }\n\n  /// Add the qualifiers from the given set to this set.\n  void addQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-or it in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask |= Q.Mask;\n    else {\n      Mask |= (Q.Mask & CVRMask);\n      if (Q.hasAddressSpace())\n        addAddressSpace(Q.getAddressSpace());\n      if (Q.hasObjCGCAttr())\n        addObjCGCAttr(Q.getObjCGCAttr());\n      if (Q.hasObjCLifetime())\n        addObjCLifetime(Q.getObjCLifetime());\n    }\n  }\n\n  /// Remove the qualifiers from the given set from this set.\n  void removeQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-and the inverse in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask &= ~Q.Mask;\n    else {\n      Mask &= ~(Q.Mask & CVRMask);\n      if (getObjCGCAttr() == Q.getObjCGCAttr())\n        removeObjCGCAttr();\n      if (getObjCLifetime() == Q.getObjCLifetime())\n        removeObjCLifetime();\n      if (getAddressSpace() == Q.getAddressSpace())\n        removeAddressSpace();\n    }\n  }\n\n  /// Add the qualifiers from the given set to this set, given that\n  /// they don't conflict.\n  void addConsistentQualifiers(Qualifiers qs) {\n    assert(getAddressSpace() == qs.getAddressSpace() ||\n           !hasAddressSpace() || !qs.hasAddressSpace());\n    assert(getObjCGCAttr() == qs.getObjCGCAttr() ||\n           !hasObjCGCAttr() || !qs.hasObjCGCAttr());\n    assert(getObjCLifetime() == qs.getObjCLifetime() ||\n           !hasObjCLifetime() || !qs.hasObjCLifetime());\n    Mask |= qs.Mask;\n  }\n\n  /// Returns true if address space A is equal to or a superset of B.\n  /// OpenCL v2.0 defines conversion rules (OpenCLC v2.0 s6.5.5) and notion of\n  /// overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   every address space is a superset of itself.\n  /// CL2.0 adds:\n  ///   __generic is a superset of any address space except for __constant.\n  static bool isAddressSpaceSupersetOf(LangAS A, LangAS B) {\n    // Address spaces must match exactly.\n    return A == B ||\n           // Otherwise in OpenCLC v2.0 s6.5.5: every address space except\n           // for __constant can be used as __generic.\n           (A == LangAS::opencl_generic && B != LangAS::opencl_constant) ||\n           // We also define global_device and global_host address spaces,\n           // to distinguish global pointers allocated on host from pointers\n           // allocated on device, which are a subset of __global.\n           (A == LangAS::opencl_global && (B == LangAS::opencl_global_device ||\n                                           B == LangAS::opencl_global_host)) ||\n           // Consider pointer size address spaces to be equivalent to default.\n           ((isPtrSizeAddressSpace(A) || A == LangAS::Default) &&\n            (isPtrSizeAddressSpace(B) || B == LangAS::Default));\n  }\n\n  /// Returns true if the address space in these qualifiers is equal to or\n  /// a superset of the address space in the argument qualifiers.\n  bool isAddressSpaceSupersetOf(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(getAddressSpace(), other.getAddressSpace());\n  }\n\n  /// Determines if these qualifiers compatibly include another set.\n  /// Generally this answers the question of whether an object with the other\n  /// qualifiers can be safely used as an object with these qualifiers.\n  bool compatiblyIncludes(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(other) &&\n           // ObjC GC qualifiers can match, be added, or be removed, but can't\n           // be changed.\n           (getObjCGCAttr() == other.getObjCGCAttr() || !hasObjCGCAttr() ||\n            !other.hasObjCGCAttr()) &&\n           // ObjC lifetime qualifiers must match exactly.\n           getObjCLifetime() == other.getObjCLifetime() &&\n           // CVR qualifiers may subset.\n           (((Mask & CVRMask) | (other.Mask & CVRMask)) == (Mask & CVRMask)) &&\n           // U qualifier may superset.\n           (!other.hasUnaligned() || hasUnaligned());\n  }\n\n  /// Determines if these qualifiers compatibly include another set of\n  /// qualifiers from the narrow perspective of Objective-C ARC lifetime.\n  ///\n  /// One set of Objective-C lifetime qualifiers compatibly includes the other\n  /// if the lifetime qualifiers match, or if both are non-__weak and the\n  /// including set also contains the 'const' qualifier, or both are non-__weak\n  /// and one is None (which can only happen in non-ARC modes).\n  bool compatiblyIncludesObjCLifetime(Qualifiers other) const {\n    if (getObjCLifetime() == other.getObjCLifetime())\n      return true;\n\n    if (getObjCLifetime() == OCL_Weak || other.getObjCLifetime() == OCL_Weak)\n      return false;\n\n    if (getObjCLifetime() == OCL_None || other.getObjCLifetime() == OCL_None)\n      return true;\n\n    return hasConst();\n  }\n\n  /// Determine whether this set of qualifiers is a strict superset of\n  /// another set of qualifiers, not considering qualifier compatibility.\n  bool isStrictSupersetOf(Qualifiers Other) const;\n\n  bool operator==(Qualifiers Other) const { return Mask == Other.Mask; }\n  bool operator!=(Qualifiers Other) const { return Mask != Other.Mask; }\n\n  explicit operator bool() const { return hasQualifiers(); }\n\n  Qualifiers &operator+=(Qualifiers R) {\n    addQualifiers(R);\n    return *this;\n  }\n\n  // Union two qualifier sets.  If an enumerated qualifier appears\n  // in both sets, use the one from the right.\n  friend Qualifiers operator+(Qualifiers L, Qualifiers R) {\n    L += R;\n    return L;\n  }\n\n  Qualifiers &operator-=(Qualifiers R) {\n    removeQualifiers(R);\n    return *this;\n  }\n\n  /// Compute the difference between two qualifier sets.\n  friend Qualifiers operator-(Qualifiers L, Qualifiers R) {\n    L -= R;\n    return L;\n  }\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  static std::string getAddrSpaceAsString(LangAS AS);\n\n  bool isEmptyWhenPrinted(const PrintingPolicy &Policy) const;\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool appendSpaceIfNonEmpty = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger(Mask);\n  }\n\nprivate:\n  // bits:     |0 1 2|3|4 .. 5|6  ..  8|9   ...   31|\n  //           |C R V|U|GCAttr|Lifetime|AddressSpace|\n  uint32_t Mask = 0;\n\n  static const uint32_t UMask = 0x8;\n  static const uint32_t UShift = 3;\n  static const uint32_t GCAttrMask = 0x30;\n  static const uint32_t GCAttrShift = 4;\n  static const uint32_t LifetimeMask = 0x1C0;\n  static const uint32_t LifetimeShift = 6;\n  static const uint32_t AddressSpaceMask =\n      ~(CVRMask | UMask | GCAttrMask | LifetimeMask);\n  static const uint32_t AddressSpaceShift = 9;\n};\n\n/// A std::pair-like structure for storing a qualified type split\n/// into its local qualifiers and its locally-unqualified type.\nstruct SplitQualType {\n  /// The locally-unqualified type.\n  const Type *Ty = nullptr;\n\n  /// The local qualifiers.\n  Qualifiers Quals;\n\n  SplitQualType() = default;\n  SplitQualType(const Type *ty, Qualifiers qs) : Ty(ty), Quals(qs) {}\n\n  SplitQualType getSingleStepDesugaredType() const; // end of this file\n\n  // Make std::tie work.\n  std::pair<const Type *,Qualifiers> asPair() const {\n    return std::pair<const Type *, Qualifiers>(Ty, Quals);\n  }\n\n  friend bool operator==(SplitQualType a, SplitQualType b) {\n    return a.Ty == b.Ty && a.Quals == b.Quals;\n  }\n  friend bool operator!=(SplitQualType a, SplitQualType b) {\n    return a.Ty != b.Ty || a.Quals != b.Quals;\n  }\n};\n\n/// The kind of type we are substituting Objective-C type arguments into.\n///\n/// The kind of substitution affects the replacement of type parameters when\n/// no concrete type information is provided, e.g., when dealing with an\n/// unspecialized type.\nenum class ObjCSubstitutionContext {\n  /// An ordinary type.\n  Ordinary,\n\n  /// The result type of a method or function.\n  Result,\n\n  /// The parameter type of a method or function.\n  Parameter,\n\n  /// The type of a property.\n  Property,\n\n  /// The superclass of a type.\n  Superclass,\n};\n\n/// A (possibly-)qualified type.\n///\n/// For efficiency, we don't store CV-qualified types as nodes on their\n/// own: instead each reference to a type stores the qualifiers.  This\n/// greatly reduces the number of nodes we need to allocate for types (for\n/// example we only need one for 'int', 'const int', 'volatile int',\n/// 'const volatile int', etc).\n///\n/// As an added efficiency bonus, instead of making this a pair, we\n/// just store the two bits we care about in the low bits of the\n/// pointer.  To handle the packing/unpacking, we make QualType be a\n/// simple wrapper class that acts like a smart pointer.  A third bit\n/// indicates whether there are extended qualifiers present, in which\n/// case the pointer points to a special structure.\nclass QualType {\n  friend class QualifierCollector;\n\n  // Thankfully, these are efficiently composable.\n  llvm::PointerIntPair<llvm::PointerUnion<const Type *, const ExtQuals *>,\n                       Qualifiers::FastWidth> Value;\n\n  const ExtQuals *getExtQualsUnsafe() const {\n    return Value.getPointer().get<const ExtQuals*>();\n  }\n\n  const Type *getTypePtrUnsafe() const {\n    return Value.getPointer().get<const Type*>();\n  }\n\n  const ExtQualsTypeCommonBase *getCommonPtr() const {\n    assert(!isNull() && \"Cannot retrieve a NULL type pointer\");\n    auto CommonPtrVal = reinterpret_cast<uintptr_t>(Value.getOpaqueValue());\n    CommonPtrVal &= ~(uintptr_t)((1 << TypeAlignmentInBits) - 1);\n    return reinterpret_cast<ExtQualsTypeCommonBase*>(CommonPtrVal);\n  }\n\npublic:\n  QualType() = default;\n  QualType(const Type *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n  QualType(const ExtQuals *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n\n  unsigned getLocalFastQualifiers() const { return Value.getInt(); }\n  void setLocalFastQualifiers(unsigned Quals) { Value.setInt(Quals); }\n\n  /// Retrieves a pointer to the underlying (unqualified) type.\n  ///\n  /// This function requires that the type not be NULL. If the type might be\n  /// NULL, use the (slightly less efficient) \\c getTypePtrOrNull().\n  const Type *getTypePtr() const;\n\n  const Type *getTypePtrOrNull() const;\n\n  /// Retrieves a pointer to the name of the base type.\n  const IdentifierInfo *getBaseTypeIdentifier() const;\n\n  /// Divides a QualType into its unqualified type and a set of local\n  /// qualifiers.\n  SplitQualType split() const;\n\n  void *getAsOpaquePtr() const { return Value.getOpaqueValue(); }\n\n  static QualType getFromOpaquePtr(const void *Ptr) {\n    QualType T;\n    T.Value.setFromOpaqueValue(const_cast<void*>(Ptr));\n    return T;\n  }\n\n  const Type &operator*() const {\n    return *getTypePtr();\n  }\n\n  const Type *operator->() const {\n    return getTypePtr();\n  }\n\n  bool isCanonical() const;\n  bool isCanonicalAsParam() const;\n\n  /// Return true if this QualType doesn't point to a type yet.\n  bool isNull() const {\n    return Value.getPointer().isNull();\n  }\n\n  /// Determine whether this particular QualType instance has the\n  /// \"const\" qualifier set, without looking through typedefs that may have\n  /// added \"const\" at a different level.\n  bool isLocalConstQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Const);\n  }\n\n  /// Determine whether this type is const-qualified.\n  bool isConstQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"restrict\" qualifier set, without looking through typedefs that may have\n  /// added \"restrict\" at a different level.\n  bool isLocalRestrictQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Restrict);\n  }\n\n  /// Determine whether this type is restrict-qualified.\n  bool isRestrictQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"volatile\" qualifier set, without looking through typedefs that may have\n  /// added \"volatile\" at a different level.\n  bool isLocalVolatileQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Volatile);\n  }\n\n  /// Determine whether this type is volatile-qualified.\n  bool isVolatileQualified() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// qualifiers, without looking through any typedefs that might add\n  /// qualifiers at a different level.\n  bool hasLocalQualifiers() const {\n    return getLocalFastQualifiers() || hasLocalNonFastQualifiers();\n  }\n\n  /// Determine whether this type has any qualifiers.\n  bool hasQualifiers() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// \"non-fast\" qualifiers, e.g., those that are stored in an ExtQualType\n  /// instance.\n  bool hasLocalNonFastQualifiers() const {\n    return Value.getPointer().is<const ExtQuals*>();\n  }\n\n  /// Retrieve the set of qualifiers local to this particular QualType\n  /// instance, not including any qualifiers acquired through typedefs or\n  /// other sugar.\n  Qualifiers getLocalQualifiers() const;\n\n  /// Retrieve the set of qualifiers applied to this type.\n  Qualifiers getQualifiers() const;\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// local to this particular QualType instance, not including any qualifiers\n  /// acquired through typedefs or other sugar.\n  unsigned getLocalCVRQualifiers() const {\n    return getLocalFastQualifiers();\n  }\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// applied to this type.\n  unsigned getCVRQualifiers() const;\n\n  bool isConstant(const ASTContext& Ctx) const {\n    return QualType::isConstant(*this, Ctx);\n  }\n\n  /// Determine whether this is a Plain Old Data (POD) type (C++ 3.9p10).\n  bool isPODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the rules of the C++98\n  /// standard, regardless of the current compilation's language.\n  bool isCXX98PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the more relaxed rules\n  /// of the C++11 standard, regardless of the current compilation's language.\n  /// (C++0x [basic.types]p9). Note that, unlike\n  /// CXXRecordDecl::isCXX11StandardLayout, this takes DRs into account.\n  bool isCXX11PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivial type per (C++0x [basic.types]p9)\n  bool isTrivialType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivially copyable type (C++0x [basic.types]p9)\n  bool isTriviallyCopyableType(const ASTContext &Context) const;\n\n\n  /// Returns true if it is a class and it might be dynamic.\n  bool mayBeDynamicClass() const;\n\n  /// Returns true if it is not a class or if the class might not be dynamic.\n  bool mayBeNotDynamicClass() const;\n\n  // Don't promise in the API that anything besides 'const' can be\n  // easily added.\n\n  /// Add the `const` type qualifier to this QualType.\n  void addConst() {\n    addFastQualifiers(Qualifiers::Const);\n  }\n  QualType withConst() const {\n    return withFastQualifiers(Qualifiers::Const);\n  }\n\n  /// Add the `volatile` type qualifier to this QualType.\n  void addVolatile() {\n    addFastQualifiers(Qualifiers::Volatile);\n  }\n  QualType withVolatile() const {\n    return withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Add the `restrict` qualifier to this QualType.\n  void addRestrict() {\n    addFastQualifiers(Qualifiers::Restrict);\n  }\n  QualType withRestrict() const {\n    return withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  QualType withCVRQualifiers(unsigned CVR) const {\n    return withFastQualifiers(CVR);\n  }\n\n  void addFastQualifiers(unsigned TQs) {\n    assert(!(TQs & ~Qualifiers::FastMask)\n           && \"non-fast qualifier bits set in mask!\");\n    Value.setInt(Value.getInt() | TQs);\n  }\n\n  void removeLocalConst();\n  void removeLocalVolatile();\n  void removeLocalRestrict();\n  void removeLocalCVRQualifiers(unsigned Mask);\n\n  void removeLocalFastQualifiers() { Value.setInt(0); }\n  void removeLocalFastQualifiers(unsigned Mask) {\n    assert(!(Mask & ~Qualifiers::FastMask) && \"mask has non-fast qualifiers\");\n    Value.setInt(Value.getInt() & ~Mask);\n  }\n\n  // Creates a type with the given qualifiers in addition to any\n  // qualifiers already on this type.\n  QualType withFastQualifiers(unsigned TQs) const {\n    QualType T = *this;\n    T.addFastQualifiers(TQs);\n    return T;\n  }\n\n  // Creates a type with exactly the given fast qualifiers, removing\n  // any existing fast qualifiers.\n  QualType withExactLocalFastQualifiers(unsigned TQs) const {\n    return withoutLocalFastQualifiers().withFastQualifiers(TQs);\n  }\n\n  // Removes fast qualifiers, but leaves any extended qualifiers in place.\n  QualType withoutLocalFastQualifiers() const {\n    QualType T = *this;\n    T.removeLocalFastQualifiers();\n    return T;\n  }\n\n  QualType getCanonicalType() const;\n\n  /// Return this type with all of the instance-specific qualifiers\n  /// removed, but without removing any qualifiers that may have been applied\n  /// through typedefs.\n  QualType getLocalUnqualifiedType() const { return QualType(getTypePtr(), 0); }\n\n  /// Retrieve the unqualified variant of the given type,\n  /// removing as little sugar as possible.\n  ///\n  /// This routine looks through various kinds of sugar to find the\n  /// least-desugared type that is unqualified. For example, given:\n  ///\n  /// \\code\n  /// typedef int Integer;\n  /// typedef const Integer CInteger;\n  /// typedef CInteger DifferenceType;\n  /// \\endcode\n  ///\n  /// Executing \\c getUnqualifiedType() on the type \\c DifferenceType will\n  /// desugar until we hit the type \\c Integer, which has no qualifiers on it.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  inline QualType getUnqualifiedType() const;\n\n  /// Retrieve the unqualified variant of the given type, removing as little\n  /// sugar as possible.\n  ///\n  /// Like getUnqualifiedType(), but also returns the set of\n  /// qualifiers that were built up.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  inline SplitQualType getSplitUnqualifiedType() const;\n\n  /// Determine whether this type is more qualified than the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isMoreQualifiedThan(QualType Other) const;\n\n  /// Determine whether this type is at least as qualified as the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isAtLeastAsQualifiedAs(QualType Other) const;\n\n  QualType getNonReferenceType() const;\n\n  /// Determine the type of a (typically non-lvalue) expression with the\n  /// specified result type.\n  ///\n  /// This routine should be used for expressions for which the return type is\n  /// explicitly specified (e.g., in a cast or call) and isn't necessarily\n  /// an lvalue. It removes a top-level reference (since there are no\n  /// expressions of reference type) and deletes top-level cvr-qualifiers\n  /// from non-class types (in C++) or all types (in C).\n  QualType getNonLValueExprType(const ASTContext &Context) const;\n\n  /// Remove an outer pack expansion type (if any) from this type. Used as part\n  /// of converting the type of a declaration to the type of an expression that\n  /// references that expression. It's meaningless for an expression to have a\n  /// pack expansion type.\n  QualType getNonPackExpansionType() const;\n\n  /// Return the specified type with any \"sugar\" removed from\n  /// the type.  This takes off typedefs, typeof's etc.  If the outer level of\n  /// the type is already concrete, it returns it unmodified.  This is similar\n  /// to getting the canonical type, but it doesn't remove *all* typedefs.  For\n  /// example, it returns \"T*\" as \"T*\", (not as \"int*\"), because the pointer is\n  /// concrete.\n  ///\n  /// Qualifiers are left in place.\n  QualType getDesugaredType(const ASTContext &Context) const {\n    return getDesugaredType(*this, Context);\n  }\n\n  SplitQualType getSplitDesugaredType() const {\n    return getSplitDesugaredType(*this);\n  }\n\n  /// Return the specified type with one level of \"sugar\" removed from\n  /// the type.\n  ///\n  /// This routine takes off the first typedef, typeof, etc. If the outer level\n  /// of the type is already concrete, it returns it unmodified.\n  QualType getSingleStepDesugaredType(const ASTContext &Context) const {\n    return getSingleStepDesugaredTypeImpl(*this, Context);\n  }\n\n  /// Returns the specified type after dropping any\n  /// outer-level parentheses.\n  QualType IgnoreParens() const {\n    if (isa<ParenType>(*this))\n      return QualType::IgnoreParens(*this);\n    return *this;\n  }\n\n  /// Indicate whether the specified types and qualifiers are identical.\n  friend bool operator==(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value == RHS.Value;\n  }\n  friend bool operator!=(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value != RHS.Value;\n  }\n  friend bool operator<(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value < RHS.Value;\n  }\n\n  static std::string getAsString(SplitQualType split,\n                                 const PrintingPolicy &Policy) {\n    return getAsString(split.Ty, split.Quals, Policy);\n  }\n  static std::string getAsString(const Type *ty, Qualifiers qs,\n                                 const PrintingPolicy &Policy);\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             const Twine &PlaceHolder = Twine(),\n             unsigned Indentation = 0) const;\n\n  static void print(SplitQualType split, raw_ostream &OS,\n                    const PrintingPolicy &policy, const Twine &PlaceHolder,\n                    unsigned Indentation = 0) {\n    return print(split.Ty, split.Quals, OS, policy, PlaceHolder, Indentation);\n  }\n\n  static void print(const Type *ty, Qualifiers qs,\n                    raw_ostream &OS, const PrintingPolicy &policy,\n                    const Twine &PlaceHolder,\n                    unsigned Indentation = 0);\n\n  void getAsStringInternal(std::string &Str,\n                           const PrintingPolicy &Policy) const;\n\n  static void getAsStringInternal(SplitQualType split, std::string &out,\n                                  const PrintingPolicy &policy) {\n    return getAsStringInternal(split.Ty, split.Quals, out, policy);\n  }\n\n  static void getAsStringInternal(const Type *ty, Qualifiers qs,\n                                  std::string &out,\n                                  const PrintingPolicy &policy);\n\n  class StreamedQualTypeHelper {\n    const QualType &T;\n    const PrintingPolicy &Policy;\n    const Twine &PlaceHolder;\n    unsigned Indentation;\n\n  public:\n    StreamedQualTypeHelper(const QualType &T, const PrintingPolicy &Policy,\n                           const Twine &PlaceHolder, unsigned Indentation)\n        : T(T), Policy(Policy), PlaceHolder(PlaceHolder),\n          Indentation(Indentation) {}\n\n    friend raw_ostream &operator<<(raw_ostream &OS,\n                                   const StreamedQualTypeHelper &SQT) {\n      SQT.T.print(OS, SQT.Policy, SQT.PlaceHolder, SQT.Indentation);\n      return OS;\n    }\n  };\n\n  StreamedQualTypeHelper stream(const PrintingPolicy &Policy,\n                                const Twine &PlaceHolder = Twine(),\n                                unsigned Indentation = 0) const {\n    return StreamedQualTypeHelper(*this, Policy, PlaceHolder, Indentation);\n  }\n\n  void dump(const char *s) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n\n  /// Check if this type has any address space qualifier.\n  inline bool hasAddressSpace() const;\n\n  /// Return the address space of this type.\n  inline LangAS getAddressSpace() const;\n\n  /// Returns true if address space qualifiers overlap with T address space\n  /// qualifiers.\n  /// OpenCL C defines conversion rules for pointers to different address spaces\n  /// and notion of overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   address spaces overlap iff they are they same.\n  /// OpenCL C v2.0 s6.5.5 adds:\n  ///   __generic overlaps with any address space except for __constant.\n  bool isAddressSpaceOverlapping(QualType T) const {\n    Qualifiers Q = getQualifiers();\n    Qualifiers TQ = T.getQualifiers();\n    // Address spaces overlap if at least one of them is a superset of another\n    return Q.isAddressSpaceSupersetOf(TQ) || TQ.isAddressSpaceSupersetOf(Q);\n  }\n\n  /// Returns gc attribute of this type.\n  inline Qualifiers::GC getObjCGCAttr() const;\n\n  /// true when Type is objc's weak.\n  bool isObjCGCWeak() const {\n    return getObjCGCAttr() == Qualifiers::Weak;\n  }\n\n  /// true when Type is objc's strong.\n  bool isObjCGCStrong() const {\n    return getObjCGCAttr() == Qualifiers::Strong;\n  }\n\n  /// Returns lifetime attribute of this type.\n  Qualifiers::ObjCLifetime getObjCLifetime() const {\n    return getQualifiers().getObjCLifetime();\n  }\n\n  bool hasNonTrivialObjCLifetime() const {\n    return getQualifiers().hasNonTrivialObjCLifetime();\n  }\n\n  bool hasStrongOrWeakObjCLifetime() const {\n    return getQualifiers().hasStrongOrWeakObjCLifetime();\n  }\n\n  // true when Type is objc's weak and weak is enabled but ARC isn't.\n  bool isNonWeakInMRRWithObjCWeak(const ASTContext &Context) const;\n\n  enum PrimitiveDefaultInitializeKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PDIK_Trivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PDIK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PDIK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is not PCK_Trivial.\n    PDIK_Struct\n  };\n\n  /// Functions to query basic properties of non-trivial C struct types.\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to default initialize\n  /// and return the kind.\n  PrimitiveDefaultInitializeKind\n  isNonTrivialToPrimitiveDefaultInitialize() const;\n\n  enum PrimitiveCopyKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PCK_Trivial,\n\n    /// The type would be trivial except that it is volatile-qualified. Types\n    /// that fall into one of the other non-trivial cases may additionally be\n    /// volatile-qualified.\n    PCK_VolatileTrivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PCK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PCK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is neither\n    /// PCK_Trivial nor PCK_VolatileTrivial.\n    /// Note that a C++ struct type does not necessarily match this; C++ copying\n    /// semantics are too complex to express here, in part because they depend\n    /// on the exact constructor or assignment operator that is chosen by\n    /// overload resolution to do the copy.\n    PCK_Struct\n  };\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to copy and return the\n  /// kind.\n  PrimitiveCopyKind isNonTrivialToPrimitiveCopy() const;\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to destructively\n  /// move and return the kind. Destructive move in this context is a C++-style\n  /// move in which the source object is placed in a valid but unspecified state\n  /// after it is moved, as opposed to a truly destructive move in which the\n  /// source object is placed in an uninitialized state.\n  PrimitiveCopyKind isNonTrivialToPrimitiveDestructiveMove() const;\n\n  enum DestructionKind {\n    DK_none,\n    DK_cxx_destructor,\n    DK_objc_strong_lifetime,\n    DK_objc_weak_lifetime,\n    DK_nontrivial_c_struct\n  };\n\n  /// Returns a nonzero value if objects of this type require\n  /// non-trivial work to clean up after.  Non-zero because it's\n  /// conceivable that qualifiers (objc_gc(weak)?) could make\n  /// something require destruction.\n  DestructionKind isDestructedType() const {\n    return isDestructedTypeImpl(*this);\n  }\n\n  /// Check if this is or contains a C union that is non-trivial to\n  /// default-initialize, which is a union that has a member that is non-trivial\n  /// to default-initialize. If this returns true,\n  /// isNonTrivialToPrimitiveDefaultInitialize returns PDIK_Struct.\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to destruct,\n  /// which is a union that has a member that is non-trivial to destruct. If\n  /// this returns true, isDestructedType returns DK_nontrivial_c_struct.\n  bool hasNonTrivialToPrimitiveDestructCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to copy, which\n  /// is a union that has a member that is non-trivial to copy. If this returns\n  /// true, isNonTrivialToPrimitiveCopy returns PCK_Struct.\n  bool hasNonTrivialToPrimitiveCopyCUnion() const;\n\n  /// Determine whether expressions of the given type are forbidden\n  /// from being lvalues in C.\n  ///\n  /// The expression types that are forbidden to be lvalues are:\n  ///   - 'void', but not qualified void\n  ///   - function types\n  ///\n  /// The exact rule here is C99 6.3.2.1:\n  ///   An lvalue is an expression with an object type or an incomplete\n  ///   type other than void.\n  bool isCForbiddenLValueType() const;\n\n  /// Substitute type arguments for the Objective-C type parameters used in the\n  /// subject type.\n  ///\n  /// \\param ctx ASTContext in which the type exists.\n  ///\n  /// \\param typeArgs The type arguments that will be substituted for the\n  /// Objective-C type parameters in the subject type, which are generally\n  /// computed via \\c Type::getObjCSubstitutions. If empty, the type\n  /// parameters will be replaced with their bounds or id/Class, as appropriate\n  /// for the context.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the resulting type.\n  QualType substObjCTypeArgs(ASTContext &ctx,\n                             ArrayRef<QualType> typeArgs,\n                             ObjCSubstitutionContext context) const;\n\n  /// Substitute type arguments from an object type for the Objective-C type\n  /// parameters used in the subject type.\n  ///\n  /// This operation combines the computation of type arguments for\n  /// substitution (\\c Type::getObjCSubstitutions) with the actual process of\n  /// substitution (\\c QualType::substObjCTypeArgs) for the convenience of\n  /// callers that need to perform a single substitution in isolation.\n  ///\n  /// \\param objectType The type of the object whose member type we're\n  /// substituting into. For example, this might be the receiver of a message\n  /// or the base of a property access.\n  ///\n  /// \\param dc The declaration context from which the subject type was\n  /// retrieved, which indicates (for example) which type parameters should\n  /// be substituted.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the subject type after replacing all of the Objective-C type\n  /// parameters with their corresponding arguments.\n  QualType substObjCMemberType(QualType objectType,\n                               const DeclContext *dc,\n                               ObjCSubstitutionContext context) const;\n\n  /// Strip Objective-C \"__kindof\" types from the given type.\n  QualType stripObjCKindOfType(const ASTContext &ctx) const;\n\n  /// Remove all qualifiers including _Atomic.\n  QualType getAtomicUnqualifiedType() const;\n\nprivate:\n  // These methods are implemented in a separate translation unit;\n  // \"static\"-ize them to avoid creating temporary QualTypes in the\n  // caller.\n  static bool isConstant(QualType T, const ASTContext& Ctx);\n  static QualType getDesugaredType(QualType T, const ASTContext &Context);\n  static SplitQualType getSplitDesugaredType(QualType T);\n  static SplitQualType getSplitUnqualifiedTypeImpl(QualType type);\n  static QualType getSingleStepDesugaredTypeImpl(QualType type,\n                                                 const ASTContext &C);\n  static QualType IgnoreParens(QualType T);\n  static DestructionKind isDestructedTypeImpl(QualType type);\n\n  /// Check if \\param RD is or contains a non-trivial C union.\n  static bool hasNonTrivialToPrimitiveDefaultInitializeCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveDestructCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveCopyCUnion(const RecordDecl *RD);\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Implement simplify_type for QualType, so that we can dyn_cast from QualType\n/// to a specific Type class.\ntemplate<> struct simplify_type< ::clang::QualType> {\n  using SimpleType = const ::clang::Type *;\n\n  static SimpleType getSimplifiedValue(::clang::QualType Val) {\n    return Val.getTypePtr();\n  }\n};\n\n// Teach SmallPtrSet that QualType is \"basically a pointer\".\ntemplate<>\nstruct PointerLikeTypeTraits<clang::QualType> {\n  static inline void *getAsVoidPointer(clang::QualType P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static inline clang::QualType getFromVoidPointer(void *P) {\n    return clang::QualType::getFromOpaquePtr(P);\n  }\n\n  // Various qualifiers go in low bits.\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\n/// Base class that is common to both the \\c ExtQuals and \\c Type\n/// classes, which allows \\c QualType to access the common fields between the\n/// two.\nclass ExtQualsTypeCommonBase {\n  friend class ExtQuals;\n  friend class QualType;\n  friend class Type;\n\n  /// The \"base\" type of an extended qualifiers type (\\c ExtQuals) or\n  /// a self-referential pointer (for \\c Type).\n  ///\n  /// This pointer allows an efficient mapping from a QualType to its\n  /// underlying type pointer.\n  const Type *const BaseType;\n\n  /// The canonical type of this type.  A QualType.\n  QualType CanonicalType;\n\n  ExtQualsTypeCommonBase(const Type *baseType, QualType canon)\n      : BaseType(baseType), CanonicalType(canon) {}\n};\n\n/// We can encode up to four bits in the low bits of a\n/// type pointer, but there are many more type qualifiers that we want\n/// to be able to apply to an arbitrary type.  Therefore we have this\n/// struct, intended to be heap-allocated and used by QualType to\n/// store qualifiers.\n///\n/// The current design tags the 'const', 'restrict', and 'volatile' qualifiers\n/// in three low bits on the QualType pointer; a fourth bit records whether\n/// the pointer is an ExtQuals node. The extended qualifiers (address spaces,\n/// Objective-C GC attributes) are much more rare.\nclass ExtQuals : public ExtQualsTypeCommonBase, public llvm::FoldingSetNode {\n  // NOTE: changing the fast qualifiers should be straightforward as\n  // long as you don't make 'const' non-fast.\n  // 1. Qualifiers:\n  //    a) Modify the bitmasks (Qualifiers::TQ and DeclSpec::TQ).\n  //       Fast qualifiers must occupy the low-order bits.\n  //    b) Update Qualifiers::FastWidth and FastMask.\n  // 2. QualType:\n  //    a) Update is{Volatile,Restrict}Qualified(), defined inline.\n  //    b) Update remove{Volatile,Restrict}, defined near the end of\n  //       this header.\n  // 3. ASTContext:\n  //    a) Update get{Volatile,Restrict}Type.\n\n  /// The immutable set of qualifiers applied by this node. Always contains\n  /// extended qualifiers.\n  Qualifiers Quals;\n\n  ExtQuals *this_() { return this; }\n\npublic:\n  ExtQuals(const Type *baseType, QualType canon, Qualifiers quals)\n      : ExtQualsTypeCommonBase(baseType,\n                               canon.isNull() ? QualType(this_(), 0) : canon),\n        Quals(quals) {\n    assert(Quals.hasNonFastQualifiers()\n           && \"ExtQuals created with no fast qualifiers\");\n    assert(!Quals.hasFastQualifiers()\n           && \"ExtQuals created with fast qualifiers\");\n  }\n\n  Qualifiers getQualifiers() const { return Quals; }\n\n  bool hasObjCGCAttr() const { return Quals.hasObjCGCAttr(); }\n  Qualifiers::GC getObjCGCAttr() const { return Quals.getObjCGCAttr(); }\n\n  bool hasObjCLifetime() const { return Quals.hasObjCLifetime(); }\n  Qualifiers::ObjCLifetime getObjCLifetime() const {\n    return Quals.getObjCLifetime();\n  }\n\n  bool hasAddressSpace() const { return Quals.hasAddressSpace(); }\n  LangAS getAddressSpace() const { return Quals.getAddressSpace(); }\n\n  const Type *getBaseType() const { return BaseType; }\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getBaseType(), Quals);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const Type *BaseType,\n                      Qualifiers Quals) {\n    assert(!Quals.hasFastQualifiers() && \"fast qualifiers in ExtQuals hash!\");\n    ID.AddPointer(BaseType);\n    Quals.Profile(ID);\n  }\n};\n\n/// The kind of C++11 ref-qualifier associated with a function type.\n/// This determines whether a member function's \"this\" object can be an\n/// lvalue, rvalue, or neither.\nenum RefQualifierKind {\n  /// No ref-qualifier was provided.\n  RQ_None = 0,\n\n  /// An lvalue ref-qualifier was provided (\\c &).\n  RQ_LValue,\n\n  /// An rvalue ref-qualifier was provided (\\c &&).\n  RQ_RValue\n};\n\n/// Which keyword(s) were used to create an AutoType.\nenum class AutoTypeKeyword {\n  /// auto\n  Auto,\n\n  /// decltype(auto)\n  DecltypeAuto,\n\n  /// __auto_type (GNU extension)\n  GNUAutoType\n};\n\n/// The base class of the type hierarchy.\n///\n/// A central concept with types is that each type always has a canonical\n/// type.  A canonical type is the type with any typedef names stripped out\n/// of it or the types it references.  For example, consider:\n///\n///  typedef int  foo;\n///  typedef foo* bar;\n///    'int *'    'foo *'    'bar'\n///\n/// There will be a Type object created for 'int'.  Since int is canonical, its\n/// CanonicalType pointer points to itself.  There is also a Type for 'foo' (a\n/// TypedefType).  Its CanonicalType pointer points to the 'int' Type.  Next\n/// there is a PointerType that represents 'int*', which, like 'int', is\n/// canonical.  Finally, there is a PointerType type for 'foo*' whose canonical\n/// type is 'int*', and there is a TypedefType for 'bar', whose canonical type\n/// is also 'int*'.\n///\n/// Non-canonical types are useful for emitting diagnostics, without losing\n/// information about typedefs being used.  Canonical types are useful for type\n/// comparisons (they allow by-pointer equality tests) and useful for reasoning\n/// about whether something has a particular form (e.g. is a function type),\n/// because they implicitly, recursively, strip all typedefs out of a type.\n///\n/// Types, once created, are immutable.\n///\nclass alignas(8) Type : public ExtQualsTypeCommonBase {\npublic:\n  enum TypeClass {\n#define TYPE(Class, Base) Class,\n#define LAST_TYPE(Class) TypeLast = Class\n#define ABSTRACT_TYPE(Class, Base)\n#include \"clang/AST/TypeNodes.inc\"\n  };\n\nprivate:\n  /// Bitfields required by the Type class.\n  class TypeBitfields {\n    friend class Type;\n    template <class T> friend class TypePropertyCache;\n\n    /// TypeClass bitfield - Enum that specifies what subclass this belongs to.\n    unsigned TC : 8;\n\n    /// Store information on the type dependency.\n    unsigned Dependence : llvm::BitWidth<TypeDependence>;\n\n    /// True if the cache (i.e. the bitfields here starting with\n    /// 'Cache') is valid.\n    mutable unsigned CacheValid : 1;\n\n    /// Linkage of this type.\n    mutable unsigned CachedLinkage : 3;\n\n    /// Whether this type involves and local or unnamed types.\n    mutable unsigned CachedLocalOrUnnamed : 1;\n\n    /// Whether this type comes from an AST file.\n    mutable unsigned FromAST : 1;\n\n    bool isCacheValid() const {\n      return CacheValid;\n    }\n\n    Linkage getLinkage() const {\n      assert(isCacheValid() && \"getting linkage from invalid cache\");\n      return static_cast<Linkage>(CachedLinkage);\n    }\n\n    bool hasLocalOrUnnamedType() const {\n      assert(isCacheValid() && \"getting linkage from invalid cache\");\n      return CachedLocalOrUnnamed;\n    }\n  };\n  enum { NumTypeBits = 8 + llvm::BitWidth<TypeDependence> + 6 };\n\nprotected:\n  // These classes allow subclasses to somewhat cleanly pack bitfields\n  // into Type.\n\n  class ArrayTypeBitfields {\n    friend class ArrayType;\n\n    unsigned : NumTypeBits;\n\n    /// CVR qualifiers from declarations like\n    /// 'int X[static restrict 4]'. For function parameters only.\n    unsigned IndexTypeQuals : 3;\n\n    /// Storage class qualifiers from declarations like\n    /// 'int X[static restrict 4]'. For function parameters only.\n    /// Actually an ArrayType::ArraySizeModifier.\n    unsigned SizeModifier : 3;\n  };\n\n  class ConstantArrayTypeBitfields {\n    friend class ConstantArrayType;\n\n    unsigned : NumTypeBits + 3 + 3;\n\n    /// Whether we have a stored size expression.\n    unsigned HasStoredSizeExpr : 1;\n  };\n\n  class BuiltinTypeBitfields {\n    friend class BuiltinType;\n\n    unsigned : NumTypeBits;\n\n    /// The kind (BuiltinType::Kind) of builtin type this is.\n    unsigned Kind : 8;\n  };\n\n  /// FunctionTypeBitfields store various bits belonging to FunctionProtoType.\n  /// Only common bits are stored here. Additional uncommon bits are stored\n  /// in a trailing object after FunctionProtoType.\n  class FunctionTypeBitfields {\n    friend class FunctionProtoType;\n    friend class FunctionType;\n\n    unsigned : NumTypeBits;\n\n    /// Extra information which affects how the function is called, like\n    /// regparm and the calling convention.\n    unsigned ExtInfo : 13;\n\n    /// The ref-qualifier associated with a \\c FunctionProtoType.\n    ///\n    /// This is a value of type \\c RefQualifierKind.\n    unsigned RefQualifier : 2;\n\n    /// Used only by FunctionProtoType, put here to pack with the\n    /// other bitfields.\n    /// The qualifiers are part of FunctionProtoType because...\n    ///\n    /// C++ 8.3.5p4: The return type, the parameter type list and the\n    /// cv-qualifier-seq, [...], are part of the function type.\n    unsigned FastTypeQuals : Qualifiers::FastWidth;\n    /// Whether this function has extended Qualifiers.\n    unsigned HasExtQuals : 1;\n\n    /// The number of parameters this function has, not counting '...'.\n    /// According to [implimits] 8 bits should be enough here but this is\n    /// somewhat easy to exceed with metaprogramming and so we would like to\n    /// keep NumParams as wide as reasonably possible.\n    unsigned NumParams : 16;\n\n    /// The type of exception specification this function has.\n    unsigned ExceptionSpecType : 4;\n\n    /// Whether this function has extended parameter information.\n    unsigned HasExtParameterInfos : 1;\n\n    /// Whether the function is variadic.\n    unsigned Variadic : 1;\n\n    /// Whether this function has a trailing return type.\n    unsigned HasTrailingReturn : 1;\n  };\n\n  class ObjCObjectTypeBitfields {\n    friend class ObjCObjectType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of type arguments stored directly on this object type.\n    unsigned NumTypeArgs : 7;\n\n    /// The number of protocols stored directly on this object type.\n    unsigned NumProtocols : 6;\n\n    /// Whether this is a \"kindof\" type.\n    unsigned IsKindOf : 1;\n  };\n\n  class ReferenceTypeBitfields {\n    friend class ReferenceType;\n\n    unsigned : NumTypeBits;\n\n    /// True if the type was originally spelled with an lvalue sigil.\n    /// This is never true of rvalue references but can also be false\n    /// on lvalue references because of C++0x [dcl.typedef]p9,\n    /// as follows:\n    ///\n    ///   typedef int &ref;    // lvalue, spelled lvalue\n    ///   typedef int &&rvref; // rvalue\n    ///   ref &a;              // lvalue, inner ref, spelled lvalue\n    ///   ref &&a;             // lvalue, inner ref\n    ///   rvref &a;            // lvalue, inner ref, spelled lvalue\n    ///   rvref &&a;           // rvalue, inner ref\n    unsigned SpelledAsLValue : 1;\n\n    /// True if the inner type is a reference type.  This only happens\n    /// in non-canonical forms.\n    unsigned InnerRef : 1;\n  };\n\n  class TypeWithKeywordBitfields {\n    friend class TypeWithKeyword;\n\n    unsigned : NumTypeBits;\n\n    /// An ElaboratedTypeKeyword.  8 bits for efficient access.\n    unsigned Keyword : 8;\n  };\n\n  enum { NumTypeWithKeywordBits = 8 };\n\n  class ElaboratedTypeBitfields {\n    friend class ElaboratedType;\n\n    unsigned : NumTypeBits;\n    unsigned : NumTypeWithKeywordBits;\n\n    /// Whether the ElaboratedType has a trailing OwnedTagDecl.\n    unsigned HasOwnedTagDecl : 1;\n  };\n\n  class VectorTypeBitfields {\n    friend class VectorType;\n    friend class DependentVectorType;\n\n    unsigned : NumTypeBits;\n\n    /// The kind of vector, either a generic vector type or some\n    /// target-specific vector type such as for AltiVec or Neon.\n    unsigned VecKind : 3;\n    /// The number of elements in the vector.\n    uint32_t NumElements;\n  };\n\n  class AttributedTypeBitfields {\n    friend class AttributedType;\n\n    unsigned : NumTypeBits;\n\n    /// An AttributedType::Kind\n    unsigned AttrKind : 32 - NumTypeBits;\n  };\n\n  class AutoTypeBitfields {\n    friend class AutoType;\n\n    unsigned : NumTypeBits;\n\n    /// Was this placeholder type spelled as 'auto', 'decltype(auto)',\n    /// or '__auto_type'?  AutoTypeKeyword value.\n    unsigned Keyword : 2;\n\n    /// The number of template arguments in the type-constraints, which is\n    /// expected to be able to hold at least 1024 according to [implimits].\n    /// However as this limit is somewhat easy to hit with template\n    /// metaprogramming we'd prefer to keep it as large as possible.\n    /// At the moment it has been left as a non-bitfield since this type\n    /// safely fits in 64 bits as an unsigned, so there is no reason to\n    /// introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class SubstTemplateTypeParmPackTypeBitfields {\n    friend class SubstTemplateTypeParmPackType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of template arguments in \\c Arguments, which is\n    /// expected to be able to hold at least 1024 according to [implimits].\n    /// However as this limit is somewhat easy to hit with template\n    /// metaprogramming we'd prefer to keep it as large as possible.\n    /// At the moment it has been left as a non-bitfield since this type\n    /// safely fits in 64 bits as an unsigned, so there is no reason to\n    /// introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class TemplateSpecializationTypeBitfields {\n    friend class TemplateSpecializationType;\n\n    unsigned : NumTypeBits;\n\n    /// Whether this template specialization type is a substituted type alias.\n    unsigned TypeAlias : 1;\n\n    /// The number of template arguments named in this class template\n    /// specialization, which is expected to be able to hold at least 1024\n    /// according to [implimits]. However, as this limit is somewhat easy to\n    /// hit with template metaprogramming we'd prefer to keep it as large\n    /// as possible. At the moment it has been left as a non-bitfield since\n    /// this type safely fits in 64 bits as an unsigned, so there is no reason\n    /// to introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class DependentTemplateSpecializationTypeBitfields {\n    friend class DependentTemplateSpecializationType;\n\n    unsigned : NumTypeBits;\n    unsigned : NumTypeWithKeywordBits;\n\n    /// The number of template arguments named in this class template\n    /// specialization, which is expected to be able to hold at least 1024\n    /// according to [implimits]. However, as this limit is somewhat easy to\n    /// hit with template metaprogramming we'd prefer to keep it as large\n    /// as possible. At the moment it has been left as a non-bitfield since\n    /// this type safely fits in 64 bits as an unsigned, so there is no reason\n    /// to introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class PackExpansionTypeBitfields {\n    friend class PackExpansionType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of expansions that this pack expansion will\n    /// generate when substituted (+1), which is expected to be able to\n    /// hold at least 1024 according to [implimits]. However, as this limit\n    /// is somewhat easy to hit with template metaprogramming we'd prefer to\n    /// keep it as large as possible. At the moment it has been left as a\n    /// non-bitfield since this type safely fits in 64 bits as an unsigned, so\n    /// there is no reason to introduce the performance impact of a bitfield.\n    ///\n    /// This field will only have a non-zero value when some of the parameter\n    /// packs that occur within the pattern have been substituted but others\n    /// have not.\n    unsigned NumExpansions;\n  };\n\n  union {\n    TypeBitfields TypeBits;\n    ArrayTypeBitfields ArrayTypeBits;\n    ConstantArrayTypeBitfields ConstantArrayTypeBits;\n    AttributedTypeBitfields AttributedTypeBits;\n    AutoTypeBitfields AutoTypeBits;\n    BuiltinTypeBitfields BuiltinTypeBits;\n    FunctionTypeBitfields FunctionTypeBits;\n    ObjCObjectTypeBitfields ObjCObjectTypeBits;\n    ReferenceTypeBitfields ReferenceTypeBits;\n    TypeWithKeywordBitfields TypeWithKeywordBits;\n    ElaboratedTypeBitfields ElaboratedTypeBits;\n    VectorTypeBitfields VectorTypeBits;\n    SubstTemplateTypeParmPackTypeBitfields SubstTemplateTypeParmPackTypeBits;\n    TemplateSpecializationTypeBitfields TemplateSpecializationTypeBits;\n    DependentTemplateSpecializationTypeBitfields\n      DependentTemplateSpecializationTypeBits;\n    PackExpansionTypeBitfields PackExpansionTypeBits;\n  };\n\nprivate:\n  template <class T> friend class TypePropertyCache;\n\n  /// Set whether this type comes from an AST file.\n  void setFromAST(bool V = true) const {\n    TypeBits.FromAST = V;\n  }\n\nprotected:\n  friend class ASTContext;\n\n  Type(TypeClass tc, QualType canon, TypeDependence Dependence)\n      : ExtQualsTypeCommonBase(this,\n                               canon.isNull() ? QualType(this_(), 0) : canon) {\n    static_assert(sizeof(*this) <= 8 + sizeof(ExtQualsTypeCommonBase),\n                  \"changing bitfields changed sizeof(Type)!\");\n    static_assert(alignof(decltype(*this)) % sizeof(void *) == 0,\n                  \"Insufficient alignment!\");\n    TypeBits.TC = tc;\n    TypeBits.Dependence = static_cast<unsigned>(Dependence);\n    TypeBits.CacheValid = false;\n    TypeBits.CachedLocalOrUnnamed = false;\n    TypeBits.CachedLinkage = NoLinkage;\n    TypeBits.FromAST = false;\n  }\n\n  // silence VC++ warning C4355: 'this' : used in base member initializer list\n  Type *this_() { return this; }\n\n  void setDependence(TypeDependence D) {\n    TypeBits.Dependence = static_cast<unsigned>(D);\n  }\n\n  void addDependence(TypeDependence D) { setDependence(getDependence() | D); }\n\npublic:\n  friend class ASTReader;\n  friend class ASTWriter;\n  template <class T> friend class serialization::AbstractTypeReader;\n  template <class T> friend class serialization::AbstractTypeWriter;\n\n  Type(const Type &) = delete;\n  Type(Type &&) = delete;\n  Type &operator=(const Type &) = delete;\n  Type &operator=(Type &&) = delete;\n\n  TypeClass getTypeClass() const { return static_cast<TypeClass>(TypeBits.TC); }\n\n  /// Whether this type comes from an AST file.\n  bool isFromAST() const { return TypeBits.FromAST; }\n\n  /// Whether this type is or contains an unexpanded parameter\n  /// pack, used to support C++0x variadic templates.\n  ///\n  /// A type that contains a parameter pack shall be expanded by the\n  /// ellipsis operator at some point. For example, the typedef in the\n  /// following example contains an unexpanded parameter pack 'T':\n  ///\n  /// \\code\n  /// template<typename ...T>\n  /// struct X {\n  ///   typedef T* pointer_types; // ill-formed; T is a parameter pack.\n  /// };\n  /// \\endcode\n  ///\n  /// Note that this routine does not specify which\n  bool containsUnexpandedParameterPack() const {\n    return getDependence() & TypeDependence::UnexpandedPack;\n  }\n\n  /// Determines if this type would be canonical if it had no further\n  /// qualification.\n  bool isCanonicalUnqualified() const {\n    return CanonicalType == QualType(this, 0);\n  }\n\n  /// Pull a single level of sugar off of this locally-unqualified type.\n  /// Users should generally prefer SplitQualType::getSingleStepDesugaredType()\n  /// or QualType::getSingleStepDesugaredType(const ASTContext&).\n  QualType getLocallyUnqualifiedSingleStepDesugaredType() const;\n\n  /// As an extension, we classify types as one of \"sized\" or \"sizeless\";\n  /// every type is one or the other.  Standard types are all sized;\n  /// sizeless types are purely an extension.\n  ///\n  /// Sizeless types contain data with no specified size, alignment,\n  /// or layout.\n  bool isSizelessType() const;\n  bool isSizelessBuiltinType() const;\n\n  /// Determines if this is a sizeless type supported by the\n  /// 'arm_sve_vector_bits' type attribute, which can be applied to a single\n  /// SVE vector or predicate, excluding tuple types such as svint32x4_t.\n  bool isVLSTBuiltinType() const;\n\n  /// Returns the representative type for the element of an SVE builtin type.\n  /// This is used to represent fixed-length SVE vectors created with the\n  /// 'arm_sve_vector_bits' type attribute as VectorType.\n  QualType getSveEltType(const ASTContext &Ctx) const;\n\n  /// Types are partitioned into 3 broad categories (C99 6.2.5p1):\n  /// object types, function types, and incomplete types.\n\n  /// Return true if this is an incomplete type.\n  /// A type that can describe objects, but which lacks information needed to\n  /// determine its size (e.g. void, or a fwd declared struct). Clients of this\n  /// routine will need to determine if the size is actually required.\n  ///\n  /// Def If non-null, and the type refers to some kind of declaration\n  /// that can be completed (such as a C struct, C++ class, or Objective-C\n  /// class), will be set to the declaration.\n  bool isIncompleteType(NamedDecl **Def = nullptr) const;\n\n  /// Return true if this is an incomplete or object\n  /// type, in other words, not a function type.\n  bool isIncompleteOrObjectType() const {\n    return !isFunctionType();\n  }\n\n  /// Determine whether this type is an object type.\n  bool isObjectType() const {\n    // C++ [basic.types]p8:\n    //   An object type is a (possibly cv-qualified) type that is not a\n    //   function type, not a reference type, and not a void type.\n    return !isReferenceType() && !isFunctionType() && !isVoidType();\n  }\n\n  /// Return true if this is a literal type\n  /// (C++11 [basic.types]p10)\n  bool isLiteralType(const ASTContext &Ctx) const;\n\n  /// Determine if this type is a structural type, per C++20 [temp.param]p7.\n  bool isStructuralType() const;\n\n  /// Test if this type is a standard-layout type.\n  /// (C++0x [basic.type]p9)\n  bool isStandardLayoutType() const;\n\n  /// Helper methods to distinguish type categories. All type predicates\n  /// operate on the canonical type, ignoring typedefs and qualifiers.\n\n  /// Returns true if the type is a builtin type.\n  bool isBuiltinType() const;\n\n  /// Test for a particular builtin type.\n  bool isSpecificBuiltinType(unsigned K) const;\n\n  /// Test for a type which does not represent an actual type-system type but\n  /// is instead used as a placeholder for various convenient purposes within\n  /// Clang.  All such types are BuiltinTypes.\n  bool isPlaceholderType() const;\n  const BuiltinType *getAsPlaceholderType() const;\n\n  /// Test for a specific placeholder type.\n  bool isSpecificPlaceholderType(unsigned K) const;\n\n  /// Test for a placeholder type other than Overload; see\n  /// BuiltinType::isNonOverloadPlaceholderType.\n  bool isNonOverloadPlaceholderType() const;\n\n  /// isIntegerType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isIntegerType() const;     // C99 6.2.5p17 (int, char, bool, enum)\n  bool isEnumeralType() const;\n\n  /// Determine whether this type is a scoped enumeration type.\n  bool isScopedEnumeralType() const;\n  bool isBooleanType() const;\n  bool isCharType() const;\n  bool isWideCharType() const;\n  bool isChar8Type() const;\n  bool isChar16Type() const;\n  bool isChar32Type() const;\n  bool isAnyCharacterType() const;\n  bool isIntegralType(const ASTContext &Ctx) const;\n\n  /// Determine whether this type is an integral or enumeration type.\n  bool isIntegralOrEnumerationType() const;\n\n  /// Determine whether this type is an integral or unscoped enumeration type.\n  bool isIntegralOrUnscopedEnumerationType() const;\n  bool isUnscopedEnumerationType() const;\n\n  /// Floating point categories.\n  bool isRealFloatingType() const; // C99 6.2.5p10 (float, double, long double)\n  /// isComplexType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isComplexType() const;      // C99 6.2.5p11 (complex)\n  bool isAnyComplexType() const;   // C99 6.2.5p11 (complex) + Complex Int.\n  bool isFloatingType() const;     // C99 6.2.5p11 (real floating + complex)\n  bool isHalfType() const;         // OpenCL 6.1.1.1, NEON (IEEE 754-2008 half)\n  bool isFloat16Type() const;      // C11 extension ISO/IEC TS 18661\n  bool isBFloat16Type() const;\n  bool isFloat128Type() const;\n  bool isRealType() const;         // C99 6.2.5p17 (real floating + integer)\n  bool isArithmeticType() const;   // C99 6.2.5p18 (integer + floating)\n  bool isVoidType() const;         // C99 6.2.5p19\n  bool isScalarType() const;       // C99 6.2.5p21 (arithmetic + pointers)\n  bool isAggregateType() const;\n  bool isFundamentalType() const;\n  bool isCompoundType() const;\n\n  // Type Predicates: Check to see if this type is structurally the specified\n  // type, ignoring typedefs and qualifiers.\n  bool isFunctionType() const;\n  bool isFunctionNoProtoType() const { return getAs<FunctionNoProtoType>(); }\n  bool isFunctionProtoType() const { return getAs<FunctionProtoType>(); }\n  bool isPointerType() const;\n  bool isAnyPointerType() const;   // Any C pointer or ObjC object pointer\n  bool isBlockPointerType() const;\n  bool isVoidPointerType() const;\n  bool isReferenceType() const;\n  bool isLValueReferenceType() const;\n  bool isRValueReferenceType() const;\n  bool isObjectPointerType() const;\n  bool isFunctionPointerType() const;\n  bool isFunctionReferenceType() const;\n  bool isMemberPointerType() const;\n  bool isMemberFunctionPointerType() const;\n  bool isMemberDataPointerType() const;\n  bool isArrayType() const;\n  bool isConstantArrayType() const;\n  bool isIncompleteArrayType() const;\n  bool isVariableArrayType() const;\n  bool isDependentSizedArrayType() const;\n  bool isRecordType() const;\n  bool isClassType() const;\n  bool isStructureType() const;\n  bool isObjCBoxableRecordType() const;\n  bool isInterfaceType() const;\n  bool isStructureOrClassType() const;\n  bool isUnionType() const;\n  bool isComplexIntegerType() const;            // GCC _Complex integer type.\n  bool isVectorType() const;                    // GCC vector type.\n  bool isExtVectorType() const;                 // Extended vector type.\n  bool isMatrixType() const;                    // Matrix type.\n  bool isConstantMatrixType() const;            // Constant matrix type.\n  bool isDependentAddressSpaceType() const;     // value-dependent address space qualifier\n  bool isObjCObjectPointerType() const;         // pointer to ObjC object\n  bool isObjCRetainableType() const;            // ObjC object or block pointer\n  bool isObjCLifetimeType() const;              // (array of)* retainable type\n  bool isObjCIndirectLifetimeType() const;      // (pointer to)* lifetime type\n  bool isObjCNSObjectType() const;              // __attribute__((NSObject))\n  bool isObjCIndependentClassType() const;      // __attribute__((objc_independent_class))\n  // FIXME: change this to 'raw' interface type, so we can used 'interface' type\n  // for the common case.\n  bool isObjCObjectType() const;                // NSString or typeof(*(id)0)\n  bool isObjCQualifiedInterfaceType() const;    // NSString<foo>\n  bool isObjCQualifiedIdType() const;           // id<foo>\n  bool isObjCQualifiedClassType() const;        // Class<foo>\n  bool isObjCObjectOrInterfaceType() const;\n  bool isObjCIdType() const;                    // id\n  bool isDecltypeType() const;\n  /// Was this type written with the special inert-in-ARC __unsafe_unretained\n  /// qualifier?\n  ///\n  /// This approximates the answer to the following question: if this\n  /// translation unit were compiled in ARC, would this type be qualified\n  /// with __unsafe_unretained?\n  bool isObjCInertUnsafeUnretainedType() const {\n    return hasAttr(attr::ObjCInertUnsafeUnretained);\n  }\n\n  /// Whether the type is Objective-C 'id' or a __kindof type of an\n  /// object type, e.g., __kindof NSView * or __kindof id\n  /// <NSCopying>.\n  ///\n  /// \\param bound Will be set to the bound on non-id subtype types,\n  /// which will be (possibly specialized) Objective-C class type, or\n  /// null for 'id.\n  bool isObjCIdOrObjectKindOfType(const ASTContext &ctx,\n                                  const ObjCObjectType *&bound) const;\n\n  bool isObjCClassType() const;                 // Class\n\n  /// Whether the type is Objective-C 'Class' or a __kindof type of an\n  /// Class type, e.g., __kindof Class <NSCopying>.\n  ///\n  /// Unlike \\c isObjCIdOrObjectKindOfType, there is no relevant bound\n  /// here because Objective-C's type system cannot express \"a class\n  /// object for a subclass of NSFoo\".\n  bool isObjCClassOrClassKindOfType() const;\n\n  bool isBlockCompatibleObjCPointerType(ASTContext &ctx) const;\n  bool isObjCSelType() const;                 // Class\n  bool isObjCBuiltinType() const;               // 'id' or 'Class'\n  bool isObjCARCBridgableType() const;\n  bool isCARCBridgableType() const;\n  bool isTemplateTypeParmType() const;          // C++ template type parameter\n  bool isNullPtrType() const;                   // C++11 std::nullptr_t\n  bool isNothrowT() const;                      // C++   std::nothrow_t\n  bool isAlignValT() const;                     // C++17 std::align_val_t\n  bool isStdByteType() const;                   // C++17 std::byte\n  bool isAtomicType() const;                    // C11 _Atomic()\n  bool isUndeducedAutoType() const;             // C++11 auto or\n                                                // C++14 decltype(auto)\n  bool isTypedefNameType() const;               // typedef or alias template\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\n  bool isImageType() const;                     // Any OpenCL image type\n\n  bool isSamplerT() const;                      // OpenCL sampler_t\n  bool isEventT() const;                        // OpenCL event_t\n  bool isClkEventT() const;                     // OpenCL clk_event_t\n  bool isQueueT() const;                        // OpenCL queue_t\n  bool isReserveIDT() const;                    // OpenCL reserve_id_t\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  // Type defined in cl_intel_device_side_avc_motion_estimation OpenCL extension\n  bool isOCLIntelSubgroupAVCType() const;\n  bool isOCLExtOpaqueType() const;              // Any OpenCL extension type\n\n  bool isPipeType() const;                      // OpenCL pipe type\n  bool isExtIntType() const;                    // Extended Int Type\n  bool isOpenCLSpecificType() const;            // Any OpenCL specific type\n\n  /// Determines if this type, which must satisfy\n  /// isObjCLifetimeType(), is implicitly __unsafe_unretained rather\n  /// than implicitly __strong.\n  bool isObjCARCImplicitlyUnretainedType() const;\n\n  /// Check if the type is the CUDA device builtin surface type.\n  bool isCUDADeviceBuiltinSurfaceType() const;\n  /// Check if the type is the CUDA device builtin texture type.\n  bool isCUDADeviceBuiltinTextureType() const;\n\n  /// Return the implicit lifetime for this type, which must not be dependent.\n  Qualifiers::ObjCLifetime getObjCARCImplicitLifetime() const;\n\n  enum ScalarTypeKind {\n    STK_CPointer,\n    STK_BlockPointer,\n    STK_ObjCObjectPointer,\n    STK_MemberPointer,\n    STK_Bool,\n    STK_Integral,\n    STK_Floating,\n    STK_IntegralComplex,\n    STK_FloatingComplex,\n    STK_FixedPoint\n  };\n\n  /// Given that this is a scalar type, classify it.\n  ScalarTypeKind getScalarTypeKind() const;\n\n  TypeDependence getDependence() const {\n    return static_cast<TypeDependence>(TypeBits.Dependence);\n  }\n\n  /// Whether this type is an error type.\n  bool containsErrors() const {\n    return getDependence() & TypeDependence::Error;\n  }\n\n  /// Whether this type is a dependent type, meaning that its definition\n  /// somehow depends on a template parameter (C++ [temp.dep.type]).\n  bool isDependentType() const {\n    return getDependence() & TypeDependence::Dependent;\n  }\n\n  /// Determine whether this type is an instantiation-dependent type,\n  /// meaning that the type involves a template parameter (even if the\n  /// definition does not actually depend on the type substituted for that\n  /// template parameter).\n  bool isInstantiationDependentType() const {\n    return getDependence() & TypeDependence::Instantiation;\n  }\n\n  /// Determine whether this type is an undeduced type, meaning that\n  /// it somehow involves a C++11 'auto' type or similar which has not yet been\n  /// deduced.\n  bool isUndeducedType() const;\n\n  /// Whether this type is a variably-modified type (C99 6.7.5).\n  bool isVariablyModifiedType() const {\n    return getDependence() & TypeDependence::VariablyModified;\n  }\n\n  /// Whether this type involves a variable-length array type\n  /// with a definite size.\n  bool hasSizedVLAType() const;\n\n  /// Whether this type is or contains a local or unnamed type.\n  bool hasUnnamedOrLocalType() const;\n\n  bool isOverloadableType() const;\n\n  /// Determine wither this type is a C++ elaborated-type-specifier.\n  bool isElaboratedTypeSpecifier() const;\n\n  bool canDecayToPointerType() const;\n\n  /// Whether this type is represented natively as a pointer.  This includes\n  /// pointers, references, block pointers, and Objective-C interface,\n  /// qualified id, and qualified interface types, as well as nullptr_t.\n  bool hasPointerRepresentation() const;\n\n  /// Whether this type can represent an objective pointer type for the\n  /// purpose of GC'ability\n  bool hasObjCPointerRepresentation() const;\n\n  /// Determine whether this type has an integer representation\n  /// of some sort, e.g., it is an integer type or a vector.\n  bool hasIntegerRepresentation() const;\n\n  /// Determine whether this type has an signed integer representation\n  /// of some sort, e.g., it is an signed integer type or a vector.\n  bool hasSignedIntegerRepresentation() const;\n\n  /// Determine whether this type has an unsigned integer representation\n  /// of some sort, e.g., it is an unsigned integer type or a vector.\n  bool hasUnsignedIntegerRepresentation() const;\n\n  /// Determine whether this type has a floating-point representation\n  /// of some sort, e.g., it is a floating-point type or a vector thereof.\n  bool hasFloatingRepresentation() const;\n\n  // Type Checking Functions: Check to see if this type is structurally the\n  // specified type, ignoring typedefs and qualifiers, and return a pointer to\n  // the best type we can.\n  const RecordType *getAsStructureType() const;\n  /// NOTE: getAs*ArrayType are methods on ASTContext.\n  const RecordType *getAsUnionType() const;\n  const ComplexType *getAsComplexIntegerType() const; // GCC complex int type.\n  const ObjCObjectType *getAsObjCInterfaceType() const;\n\n  // The following is a convenience method that returns an ObjCObjectPointerType\n  // for object declared using an interface.\n  const ObjCObjectPointerType *getAsObjCInterfacePointerType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedIdType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedClassType() const;\n  const ObjCObjectType *getAsObjCQualifiedInterfaceType() const;\n\n  /// Retrieves the CXXRecordDecl that this type refers to, either\n  /// because the type is a RecordType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  CXXRecordDecl *getAsCXXRecordDecl() const;\n\n  /// Retrieves the RecordDecl this type refers to.\n  RecordDecl *getAsRecordDecl() const;\n\n  /// Retrieves the TagDecl that this type refers to, either\n  /// because the type is a TagType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  TagDecl *getAsTagDecl() const;\n\n  /// If this is a pointer or reference to a RecordType, return the\n  /// CXXRecordDecl that the type refers to.\n  ///\n  /// If this is not a pointer or reference, or the type being pointed to does\n  /// not refer to a CXXRecordDecl, returns NULL.\n  const CXXRecordDecl *getPointeeCXXRecordDecl() const;\n\n  /// Get the DeducedType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  DeducedType *getContainedDeducedType() const;\n\n  /// Get the AutoType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  AutoType *getContainedAutoType() const {\n    return dyn_cast_or_null<AutoType>(getContainedDeducedType());\n  }\n\n  /// Determine whether this type was written with a leading 'auto'\n  /// corresponding to a trailing return type (possibly for a nested\n  /// function type within a pointer to function type or similar).\n  bool hasAutoForTrailingReturnType() const;\n\n  /// Member-template getAs<specific type>'.  Look through sugar for\n  /// an instance of \\<specific type>.   This scheme will eventually\n  /// replace the specific getAsXXXX methods above.\n  ///\n  /// There are some specializations of this member template listed\n  /// immediately following this class.\n  template <typename T> const T *getAs() const;\n\n  /// Member-template getAsAdjusted<specific type>. Look through specific kinds\n  /// of sugar (parens, attributes, etc) for an instance of \\<specific type>.\n  /// This is used when you need to walk over sugar nodes that represent some\n  /// kind of type adjustment from a type that was written as a \\<specific type>\n  /// to another type that is still canonically a \\<specific type>.\n  template <typename T> const T *getAsAdjusted() const;\n\n  /// A variant of getAs<> for array types which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *getAsArrayTypeUnsafe() const;\n\n  /// Member-template castAs<specific type>.  Look through sugar for\n  /// the underlying instance of \\<specific type>.\n  ///\n  /// This method has the same relationship to getAs<T> as cast<T> has\n  /// to dyn_cast<T>; which is to say, the underlying type *must*\n  /// have the intended type, and this method will never return null.\n  template <typename T> const T *castAs() const;\n\n  /// A variant of castAs<> for array type which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *castAsArrayTypeUnsafe() const;\n\n  /// Determine whether this type had the specified attribute applied to it\n  /// (looking through top-level type sugar).\n  bool hasAttr(attr::Kind AK) const;\n\n  /// Get the base element type of this type, potentially discarding type\n  /// qualifiers.  This should never be used when type qualifiers\n  /// are meaningful.\n  const Type *getBaseElementTypeUnsafe() const;\n\n  /// If this is an array type, return the element type of the array,\n  /// potentially with type qualifiers missing.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getArrayElementTypeNoTypeQual() const;\n\n  /// If this is a pointer type, return the pointee type.\n  /// If this is an array type, return the array element type.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getPointeeOrArrayElementType() const;\n\n  /// If this is a pointer, ObjC object pointer, or block\n  /// pointer, this returns the respective pointee.\n  QualType getPointeeType() const;\n\n  /// Return the specified type with any \"sugar\" removed from the type,\n  /// removing any typedefs, typeofs, etc., as well as any qualifiers.\n  const Type *getUnqualifiedDesugaredType() const;\n\n  /// More type predicates useful for type checking/promotion\n  bool isPromotableIntegerType() const; // C99 6.3.1.1p2\n\n  /// Return true if this is an integer type that is\n  /// signed, according to C99 6.2.5p4 [char, signed char, short, int, long..],\n  /// or an enum decl which has a signed representation.\n  bool isSignedIntegerType() const;\n\n  /// Return true if this is an integer type that is\n  /// unsigned, according to C99 6.2.5p6 [which returns true for _Bool],\n  /// or an enum decl which has an unsigned representation.\n  bool isUnsignedIntegerType() const;\n\n  /// Determines whether this is an integer type that is signed or an\n  /// enumeration types whose underlying type is a signed integer type.\n  bool isSignedIntegerOrEnumerationType() const;\n\n  /// Determines whether this is an integer type that is unsigned or an\n  /// enumeration types whose underlying type is a unsigned integer type.\n  bool isUnsignedIntegerOrEnumerationType() const;\n\n  /// Return true if this is a fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169.\n  bool isFixedPointType() const;\n\n  /// Return true if this is a fixed point or integer type.\n  bool isFixedPointOrIntegerType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isSaturatedFixedPointType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isUnsaturatedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is signed according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isSignedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is unsigned according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isUnsignedFixedPointType() const;\n\n  /// Return true if this is not a variable sized type,\n  /// according to the rules of C99 6.7.5p3.  It is not legal to call this on\n  /// incomplete types.\n  bool isConstantSizeType() const;\n\n  /// Returns true if this type can be represented by some\n  /// set of type specifiers.\n  bool isSpecifierType() const;\n\n  /// Determine the linkage of this type.\n  Linkage getLinkage() const;\n\n  /// Determine the visibility of this type.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Return true if the visibility was explicitly set is the code.\n  bool isVisibilityExplicit() const {\n    return getLinkageAndVisibility().isVisibilityExplicit();\n  }\n\n  /// Determine the linkage and visibility of this type.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// Determine the nullability of the given type.\n  ///\n  /// Note that nullability is only captured as sugar within the type\n  /// system, not as part of the canonical type, so nullability will\n  /// be lost by canonicalization and desugaring.\n  Optional<NullabilityKind> getNullability(const ASTContext &context) const;\n\n  /// Determine whether the given type can have a nullability\n  /// specifier applied to it, i.e., if it is any kind of pointer type.\n  ///\n  /// \\param ResultIfUnknown The value to return if we don't yet know whether\n  ///        this type can have nullability because it is dependent.\n  bool canHaveNullability(bool ResultIfUnknown = true) const;\n\n  /// Retrieve the set of substitutions required when accessing a member\n  /// of the Objective-C receiver type that is declared in the given context.\n  ///\n  /// \\c *this is the type of the object we're operating on, e.g., the\n  /// receiver for a message send or the base of a property access, and is\n  /// expected to be of some object or object pointer type.\n  ///\n  /// \\param dc The declaration context for which we are building up a\n  /// substitution mapping, which should be an Objective-C class, extension,\n  /// category, or method within.\n  ///\n  /// \\returns an array of type arguments that can be substituted for\n  /// the type parameters of the given declaration context in any type described\n  /// within that context, or an empty optional to indicate that no\n  /// substitution is required.\n  Optional<ArrayRef<QualType>>\n  getObjCSubstitutions(const DeclContext *dc) const;\n\n  /// Determines if this is an ObjC interface type that may accept type\n  /// parameters.\n  bool acceptsObjCTypeParams() const;\n\n  const char *getTypeClassName() const;\n\n  QualType getCanonicalTypeInternal() const {\n    return CanonicalType;\n  }\n\n  CanQualType getCanonicalTypeUnqualified() const; // in CanonicalType.h\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n};\n\n/// This will check for a TypedefType by removing any existing sugar\n/// until it reaches a TypedefType or a non-sugared type.\ntemplate <> const TypedefType *Type::getAs() const;\n\n/// This will check for a TemplateSpecializationType by removing any\n/// existing sugar until it reaches a TemplateSpecializationType or a\n/// non-sugared type.\ntemplate <> const TemplateSpecializationType *Type::getAs() const;\n\n/// This will check for an AttributedType by removing any existing sugar\n/// until it reaches an AttributedType or a non-sugared type.\ntemplate <> const AttributedType *Type::getAs() const;\n\n// We can do canonical leaf types faster, because we don't have to\n// worry about preserving child type decoration.\n#define TYPE(Class, Base)\n#define LEAF_TYPE(Class) \\\ntemplate <> inline const Class##Type *Type::getAs() const { \\\n  return dyn_cast<Class##Type>(CanonicalType); \\\n} \\\ntemplate <> inline const Class##Type *Type::castAs() const { \\\n  return cast<Class##Type>(CanonicalType); \\\n}\n#include \"clang/AST/TypeNodes.inc\"\n\n/// This class is used for builtin types like 'int'.  Builtin\n/// types are always canonical and have a literal name field.\nclass BuiltinType : public Type {\npublic:\n  enum Kind {\n// OpenCL image types\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) Id,\n#include \"clang/Basic/OpenCLImageTypes.def\"\n// OpenCL extension types\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) Id,\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n// SVE Types\n#define SVE_TYPE(Name, Id, SingletonId) Id,\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n// PPC MMA Types\n#define PPC_VECTOR_TYPE(Name, Id, Size) Id,\n#include \"clang/Basic/PPCTypes.def\"\n// RVV Types\n#define RVV_TYPE(Name, Id, SingletonId) Id,\n#include \"clang/Basic/RISCVVTypes.def\"\n// All other builtin types\n#define BUILTIN_TYPE(Id, SingletonId) Id,\n#define LAST_BUILTIN_TYPE(Id) LastKind = Id\n#include \"clang/AST/BuiltinTypes.def\"\n  };\n\nprivate:\n  friend class ASTContext; // ASTContext creates these.\n\n  BuiltinType(Kind K)\n      : Type(Builtin, QualType(),\n             K == Dependent ? TypeDependence::DependentInstantiation\n                            : TypeDependence::None) {\n    BuiltinTypeBits.Kind = K;\n  }\n\npublic:\n  Kind getKind() const { return static_cast<Kind>(BuiltinTypeBits.Kind); }\n  StringRef getName(const PrintingPolicy &Policy) const;\n\n  const char *getNameAsCString(const PrintingPolicy &Policy) const {\n    // The StringRef is null-terminated.\n    StringRef str = getName(Policy);\n    assert(!str.empty() && str.data()[str.size()] == '\\0');\n    return str.data();\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  bool isInteger() const {\n    return getKind() >= Bool && getKind() <= Int128;\n  }\n\n  bool isSignedInteger() const {\n    return getKind() >= Char_S && getKind() <= Int128;\n  }\n\n  bool isUnsignedInteger() const {\n    return getKind() >= Bool && getKind() <= UInt128;\n  }\n\n  bool isFloatingPoint() const {\n    return getKind() >= Half && getKind() <= Float128;\n  }\n\n  /// Determines whether the given kind corresponds to a placeholder type.\n  static bool isPlaceholderTypeKind(Kind K) {\n    return K >= Overload;\n  }\n\n  /// Determines whether this type is a placeholder type, i.e. a type\n  /// which cannot appear in arbitrary positions in a fully-formed\n  /// expression.\n  bool isPlaceholderType() const {\n    return isPlaceholderTypeKind(getKind());\n  }\n\n  /// Determines whether this type is a placeholder type other than\n  /// Overload.  Most placeholder types require only syntactic\n  /// information about their context in order to be resolved (e.g.\n  /// whether it is a call expression), which means they can (and\n  /// should) be resolved in an earlier \"phase\" of analysis.\n  /// Overload expressions sometimes pick up further information\n  /// from their context, like whether the context expects a\n  /// specific function-pointer type, and so frequently need\n  /// special treatment.\n  bool isNonOverloadPlaceholderType() const {\n    return getKind() > Overload;\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Builtin; }\n};\n\n/// Complex values, per C99 6.2.5p11.  This supports the C99 complex\n/// types (_Complex float etc) as well as the GCC integer complex extensions.\nclass ComplexType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ElementType;\n\n  ComplexType(QualType Element, QualType CanonicalPtr)\n      : Type(Complex, CanonicalPtr, Element->getDependence()),\n        ElementType(Element) {}\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Element) {\n    ID.AddPointer(Element.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Complex; }\n};\n\n/// Sugar for parentheses used when specifying types.\nclass ParenType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType Inner;\n\n  ParenType(QualType InnerType, QualType CanonType)\n      : Type(Paren, CanonType, InnerType->getDependence()), Inner(InnerType) {}\n\npublic:\n  QualType getInnerType() const { return Inner; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getInnerType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getInnerType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Inner) {\n    Inner.Profile(ID);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Paren; }\n};\n\n/// PointerType - C99 6.7.5.1 - Pointer Declarators.\nclass PointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  PointerType(QualType Pointee, QualType CanonicalPtr)\n      : Type(Pointer, CanonicalPtr, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  QualType getPointeeType() const { return PointeeType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {\n    ID.AddPointer(Pointee.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Pointer; }\n};\n\n/// Represents a type which was implicitly adjusted by the semantic\n/// engine for arbitrary reasons.  For example, array and function types can\n/// decay, and function types can have their calling conventions adjusted.\nclass AdjustedType : public Type, public llvm::FoldingSetNode {\n  QualType OriginalTy;\n  QualType AdjustedTy;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  AdjustedType(TypeClass TC, QualType OriginalTy, QualType AdjustedTy,\n               QualType CanonicalPtr)\n      : Type(TC, CanonicalPtr, OriginalTy->getDependence()),\n        OriginalTy(OriginalTy), AdjustedTy(AdjustedTy) {}\n\npublic:\n  QualType getOriginalType() const { return OriginalTy; }\n  QualType getAdjustedType() const { return AdjustedTy; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return AdjustedTy; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, OriginalTy, AdjustedTy);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Orig, QualType New) {\n    ID.AddPointer(Orig.getAsOpaquePtr());\n    ID.AddPointer(New.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Adjusted || T->getTypeClass() == Decayed;\n  }\n};\n\n/// Represents a pointer type decayed from an array or function type.\nclass DecayedType : public AdjustedType {\n  friend class ASTContext; // ASTContext creates these.\n\n  inline\n  DecayedType(QualType OriginalType, QualType Decayed, QualType Canonical);\n\npublic:\n  QualType getDecayedType() const { return getAdjustedType(); }\n\n  inline QualType getPointeeType() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Decayed; }\n};\n\n/// Pointer to a block type.\n/// This type is to represent types syntactically represented as\n/// \"void (^)(int)\", etc. Pointee is required to always be a function type.\nclass BlockPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  // Block is some kind of pointer type\n  QualType PointeeType;\n\n  BlockPointerType(QualType Pointee, QualType CanonicalCls)\n      : Type(BlockPointer, CanonicalCls, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  // Get the pointee type. Pointee is required to always be a function type.\n  QualType getPointeeType() const { return PointeeType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n      Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {\n      ID.AddPointer(Pointee.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == BlockPointer;\n  }\n};\n\n/// Base for LValueReferenceType and RValueReferenceType\nclass ReferenceType : public Type, public llvm::FoldingSetNode {\n  QualType PointeeType;\n\nprotected:\n  ReferenceType(TypeClass tc, QualType Referencee, QualType CanonicalRef,\n                bool SpelledAsLValue)\n      : Type(tc, CanonicalRef, Referencee->getDependence()),\n        PointeeType(Referencee) {\n    ReferenceTypeBits.SpelledAsLValue = SpelledAsLValue;\n    ReferenceTypeBits.InnerRef = Referencee->isReferenceType();\n  }\n\npublic:\n  bool isSpelledAsLValue() const { return ReferenceTypeBits.SpelledAsLValue; }\n  bool isInnerRef() const { return ReferenceTypeBits.InnerRef; }\n\n  QualType getPointeeTypeAsWritten() const { return PointeeType; }\n\n  QualType getPointeeType() const {\n    // FIXME: this might strip inner qualifiers; okay?\n    const ReferenceType *T = this;\n    while (T->isInnerRef())\n      T = T->PointeeType->castAs<ReferenceType>();\n    return T->PointeeType;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, PointeeType, isSpelledAsLValue());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      QualType Referencee,\n                      bool SpelledAsLValue) {\n    ID.AddPointer(Referencee.getAsOpaquePtr());\n    ID.AddBoolean(SpelledAsLValue);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == LValueReference ||\n           T->getTypeClass() == RValueReference;\n  }\n};\n\n/// An lvalue reference type, per C++11 [dcl.ref].\nclass LValueReferenceType : public ReferenceType {\n  friend class ASTContext; // ASTContext creates these\n\n  LValueReferenceType(QualType Referencee, QualType CanonicalRef,\n                      bool SpelledAsLValue)\n      : ReferenceType(LValueReference, Referencee, CanonicalRef,\n                      SpelledAsLValue) {}\n\npublic:\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == LValueReference;\n  }\n};\n\n/// An rvalue reference type, per C++11 [dcl.ref].\nclass RValueReferenceType : public ReferenceType {\n  friend class ASTContext; // ASTContext creates these\n\n  RValueReferenceType(QualType Referencee, QualType CanonicalRef)\n       : ReferenceType(RValueReference, Referencee, CanonicalRef, false) {}\n\npublic:\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == RValueReference;\n  }\n};\n\n/// A pointer to member type per C++ 8.3.3 - Pointers to members.\n///\n/// This includes both pointers to data members and pointer to member functions.\nclass MemberPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  /// The class of which the pointee is a member. Must ultimately be a\n  /// RecordType, but could be a typedef or a template parameter too.\n  const Type *Class;\n\n  MemberPointerType(QualType Pointee, const Type *Cls, QualType CanonicalPtr)\n      : Type(MemberPointer, CanonicalPtr,\n             (Cls->getDependence() & ~TypeDependence::VariablyModified) |\n                 Pointee->getDependence()),\n        PointeeType(Pointee), Class(Cls) {}\n\npublic:\n  QualType getPointeeType() const { return PointeeType; }\n\n  /// Returns true if the member type (i.e. the pointee type) is a\n  /// function type rather than a data-member type.\n  bool isMemberFunctionPointer() const {\n    return PointeeType->isFunctionProtoType();\n  }\n\n  /// Returns true if the member type (i.e. the pointee type) is a\n  /// data type rather than a function type.\n  bool isMemberDataPointer() const {\n    return !PointeeType->isFunctionProtoType();\n  }\n\n  const Type *getClass() const { return Class; }\n  CXXRecordDecl *getMostRecentCXXRecordDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType(), getClass());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee,\n                      const Type *Class) {\n    ID.AddPointer(Pointee.getAsOpaquePtr());\n    ID.AddPointer(Class);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == MemberPointer;\n  }\n};\n\n/// Represents an array type, per C99 6.7.5.2 - Array Declarators.\nclass ArrayType : public Type, public llvm::FoldingSetNode {\npublic:\n  /// Capture whether this is a normal array (e.g. int X[4])\n  /// an array with a static size (e.g. int X[static 4]), or an array\n  /// with a star size (e.g. int X[*]).\n  /// 'static' is only allowed on function parameters.\n  enum ArraySizeModifier {\n    Normal, Static, Star\n  };\n\nprivate:\n  /// The element type of the array.\n  QualType ElementType;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  ArrayType(TypeClass tc, QualType et, QualType can, ArraySizeModifier sm,\n            unsigned tq, const Expr *sz = nullptr);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  ArraySizeModifier getSizeModifier() const {\n    return ArraySizeModifier(ArrayTypeBits.SizeModifier);\n  }\n\n  Qualifiers getIndexTypeQualifiers() const {\n    return Qualifiers::fromCVRMask(getIndexTypeCVRQualifiers());\n  }\n\n  unsigned getIndexTypeCVRQualifiers() const {\n    return ArrayTypeBits.IndexTypeQuals;\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantArray ||\n           T->getTypeClass() == VariableArray ||\n           T->getTypeClass() == IncompleteArray ||\n           T->getTypeClass() == DependentSizedArray;\n  }\n};\n\n/// Represents the canonical version of C arrays with a specified constant size.\n/// For example, the canonical type for 'int A[4 + 4*100]' is a\n/// ConstantArrayType where the element type is 'int' and the size is 404.\nclass ConstantArrayType final\n    : public ArrayType,\n      private llvm::TrailingObjects<ConstantArrayType, const Expr *> {\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  llvm::APInt Size; // Allows us to unique the type.\n\n  ConstantArrayType(QualType et, QualType can, const llvm::APInt &size,\n                    const Expr *sz, ArraySizeModifier sm, unsigned tq)\n      : ArrayType(ConstantArray, et, can, sm, tq, sz), Size(size) {\n    ConstantArrayTypeBits.HasStoredSizeExpr = sz != nullptr;\n    if (ConstantArrayTypeBits.HasStoredSizeExpr) {\n      assert(!can.isNull() && \"canonical constant array should not have size\");\n      *getTrailingObjects<const Expr*>() = sz;\n    }\n  }\n\n  unsigned numTrailingObjects(OverloadToken<const Expr*>) const {\n    return ConstantArrayTypeBits.HasStoredSizeExpr;\n  }\n\npublic:\n  const llvm::APInt &getSize() const { return Size; }\n  const Expr *getSizeExpr() const {\n    return ConstantArrayTypeBits.HasStoredSizeExpr\n               ? *getTrailingObjects<const Expr *>()\n               : nullptr;\n  }\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  /// Determine the number of bits required to address a member of\n  // an array with the given element type and number of elements.\n  static unsigned getNumAddressingBits(const ASTContext &Context,\n                                       QualType ElementType,\n                                       const llvm::APInt &NumElements);\n\n  /// Determine the maximum number of active bits that an array's size\n  /// can require, which limits the maximum size of the array.\n  static unsigned getMaxSizeBits(const ASTContext &Context);\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx) {\n    Profile(ID, Ctx, getElementType(), getSize(), getSizeExpr(),\n            getSizeModifier(), getIndexTypeCVRQualifiers());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx,\n                      QualType ET, const llvm::APInt &ArraySize,\n                      const Expr *SizeExpr, ArraySizeModifier SizeMod,\n                      unsigned TypeQuals);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantArray;\n  }\n};\n\n/// Represents a C array with an unspecified size.  For example 'int A[]' has\n/// an IncompleteArrayType where the element type is 'int' and the size is\n/// unspecified.\nclass IncompleteArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  IncompleteArrayType(QualType et, QualType can,\n                      ArraySizeModifier sm, unsigned tq)\n      : ArrayType(IncompleteArray, et, can, sm, tq) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == IncompleteArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getSizeModifier(),\n            getIndexTypeCVRQualifiers());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ET,\n                      ArraySizeModifier SizeMod, unsigned TypeQuals) {\n    ID.AddPointer(ET.getAsOpaquePtr());\n    ID.AddInteger(SizeMod);\n    ID.AddInteger(TypeQuals);\n  }\n};\n\n/// Represents a C array with a specified size that is not an\n/// integer-constant-expression.  For example, 'int s[x+foo()]'.\n/// Since the size expression is an arbitrary expression, we store it as such.\n///\n/// Note: VariableArrayType's aren't uniqued (since the expressions aren't) and\n/// should not be: two lexically equivalent variable array types could mean\n/// different things, for example, these variables do not have the same type\n/// dynamically:\n///\n/// void foo(int x) {\n///   int Y[x];\n///   ++x;\n///   int Z[x];\n/// }\nclass VariableArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  /// An assignment-expression. VLA's are only permitted within\n  /// a function block.\n  Stmt *SizeExpr;\n\n  /// The range spanned by the left and right array brackets.\n  SourceRange Brackets;\n\n  VariableArrayType(QualType et, QualType can, Expr *e,\n                    ArraySizeModifier sm, unsigned tq,\n                    SourceRange brackets)\n      : ArrayType(VariableArray, et, can, sm, tq, e),\n        SizeExpr((Stmt*) e), Brackets(brackets) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  Expr *getSizeExpr() const {\n    // We use C-style casts instead of cast<> here because we do not wish\n    // to have a dependency of Type.h on Stmt.h/Expr.h.\n    return (Expr*) SizeExpr;\n  }\n\n  SourceRange getBracketsRange() const { return Brackets; }\n  SourceLocation getLBracketLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRBracketLoc() const { return Brackets.getEnd(); }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == VariableArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    llvm_unreachable(\"Cannot unique VariableArrayTypes.\");\n  }\n};\n\n/// Represents an array type in C++ whose size is a value-dependent expression.\n///\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class array {\n///   T data[Size];\n/// };\n/// \\endcode\n///\n/// For these types, we won't actually know what the array bound is\n/// until template instantiation occurs, at which point this will\n/// become either a ConstantArrayType or a VariableArrayType.\nclass DependentSizedArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  const ASTContext &Context;\n\n  /// An assignment expression that will instantiate to the\n  /// size of the array.\n  ///\n  /// The expression itself might be null, in which case the array\n  /// type will have its size deduced from an initializer.\n  Stmt *SizeExpr;\n\n  /// The range spanned by the left and right array brackets.\n  SourceRange Brackets;\n\n  DependentSizedArrayType(const ASTContext &Context, QualType et, QualType can,\n                          Expr *e, ArraySizeModifier sm, unsigned tq,\n                          SourceRange brackets);\n\npublic:\n  friend class StmtIteratorBase;\n\n  Expr *getSizeExpr() const {\n    // We use C-style casts instead of cast<> here because we do not wish\n    // to have a dependency of Type.h on Stmt.h/Expr.h.\n    return (Expr*) SizeExpr;\n  }\n\n  SourceRange getBracketsRange() const { return Brackets; }\n  SourceLocation getLBracketLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRBracketLoc() const { return Brackets.getEnd(); }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(),\n            getSizeModifier(), getIndexTypeCVRQualifiers(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ET, ArraySizeModifier SizeMod,\n                      unsigned TypeQuals, Expr *E);\n};\n\n/// Represents an extended address space qualifier where the input address space\n/// value is dependent. Non-dependent address spaces are not represented with a\n/// special Type subclass; they are stored on an ExtQuals node as part of a QualType.\n///\n/// For example:\n/// \\code\n/// template<typename T, int AddrSpace>\n/// class AddressSpace {\n///   typedef T __attribute__((address_space(AddrSpace))) type;\n/// }\n/// \\endcode\nclass DependentAddressSpaceType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *AddrSpaceExpr;\n  QualType PointeeType;\n  SourceLocation loc;\n\n  DependentAddressSpaceType(const ASTContext &Context, QualType PointeeType,\n                            QualType can, Expr *AddrSpaceExpr,\n                            SourceLocation loc);\n\npublic:\n  Expr *getAddrSpaceExpr() const { return AddrSpaceExpr; }\n  QualType getPointeeType() const { return PointeeType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentAddressSpace;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getPointeeType(), getAddrSpaceExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType PointeeType, Expr *AddrSpaceExpr);\n};\n\n/// Represents an extended vector type where either the type or size is\n/// dependent.\n///\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((ext_vector_type(Size))) type;\n/// }\n/// \\endcode\nclass DependentSizedExtVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *SizeExpr;\n\n  /// The element type of the array.\n  QualType ElementType;\n\n  SourceLocation loc;\n\n  DependentSizedExtVectorType(const ASTContext &Context, QualType ElementType,\n                              QualType can, Expr *SizeExpr, SourceLocation loc);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedExtVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *SizeExpr);\n};\n\n\n/// Represents a GCC generic vector type. This type is created using\n/// __attribute__((vector_size(n)), where \"n\" specifies the vector size in\n/// bytes; or from an Altivec __vector or vector declaration.\n/// Since the constructor takes the number of vector elements, the\n/// client is responsible for converting the size into the number of elements.\nclass VectorType : public Type, public llvm::FoldingSetNode {\npublic:\n  enum VectorKind {\n    /// not a target-specific vector type\n    GenericVector,\n\n    /// is AltiVec vector\n    AltiVecVector,\n\n    /// is AltiVec 'vector Pixel'\n    AltiVecPixel,\n\n    /// is AltiVec 'vector bool ...'\n    AltiVecBool,\n\n    /// is ARM Neon vector\n    NeonVector,\n\n    /// is ARM Neon polynomial vector\n    NeonPolyVector,\n\n    /// is AArch64 SVE fixed-length data vector\n    SveFixedLengthDataVector,\n\n    /// is AArch64 SVE fixed-length predicate vector\n    SveFixedLengthPredicateVector\n  };\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  /// The element type of the vector.\n  QualType ElementType;\n\n  VectorType(QualType vecType, unsigned nElements, QualType canonType,\n             VectorKind vecKind);\n\n  VectorType(TypeClass tc, QualType vecType, unsigned nElements,\n             QualType canonType, VectorKind vecKind);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n  unsigned getNumElements() const { return VectorTypeBits.NumElements; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  VectorKind getVectorKind() const {\n    return VectorKind(VectorTypeBits.VecKind);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumElements(),\n            getTypeClass(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumElements, TypeClass TypeClass,\n                      VectorKind VecKind) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumElements);\n    ID.AddInteger(TypeClass);\n    ID.AddInteger(VecKind);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Vector || T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a vector type where either the type or size is dependent.\n////\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((vector_size(Size))) type;\n/// }\n/// \\endcode\nclass DependentVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  QualType ElementType;\n  Expr *SizeExpr;\n  SourceLocation Loc;\n\n  DependentVectorType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonType, Expr *SizeExpr,\n                           SourceLocation Loc, VectorType::VectorKind vecKind);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return Loc; }\n  VectorType::VectorKind getVectorKind() const {\n    return VectorType::VectorKind(VectorTypeBits.VecKind);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, const Expr *SizeExpr,\n                      VectorType::VectorKind VecKind);\n};\n\n/// ExtVectorType - Extended vector type. This type is created using\n/// __attribute__((ext_vector_type(n)), where \"n\" is the number of elements.\n/// Unlike vector_size, ext_vector_type is only allowed on typedef's. This\n/// class enables syntactic extensions, like Vector Components for accessing\n/// points (as .xyzw), colors (as .rgba), and textures (modeled after OpenGL\n/// Shading Language).\nclass ExtVectorType : public VectorType {\n  friend class ASTContext; // ASTContext creates these.\n\n  ExtVectorType(QualType vecType, unsigned nElements, QualType canonType)\n      : VectorType(ExtVector, vecType, nElements, canonType, GenericVector) {}\n\npublic:\n  static int getPointAccessorIdx(char c) {\n    switch (c) {\n    default: return -1;\n    case 'x': case 'r': return 0;\n    case 'y': case 'g': return 1;\n    case 'z': case 'b': return 2;\n    case 'w': case 'a': return 3;\n    }\n  }\n\n  static int getNumericAccessorIdx(char c) {\n    switch (c) {\n      default: return -1;\n      case '0': return 0;\n      case '1': return 1;\n      case '2': return 2;\n      case '3': return 3;\n      case '4': return 4;\n      case '5': return 5;\n      case '6': return 6;\n      case '7': return 7;\n      case '8': return 8;\n      case '9': return 9;\n      case 'A':\n      case 'a': return 10;\n      case 'B':\n      case 'b': return 11;\n      case 'C':\n      case 'c': return 12;\n      case 'D':\n      case 'd': return 13;\n      case 'E':\n      case 'e': return 14;\n      case 'F':\n      case 'f': return 15;\n    }\n  }\n\n  static int getAccessorIdx(char c, bool isNumericAccessor) {\n    if (isNumericAccessor)\n      return getNumericAccessorIdx(c);\n    else\n      return getPointAccessorIdx(c);\n  }\n\n  bool isAccessorWithinNumElements(char c, bool isNumericAccessor) const {\n    if (int idx = getAccessorIdx(c, isNumericAccessor)+1)\n      return unsigned(idx-1) < getNumElements();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a matrix type, as defined in the Matrix Types clang extensions.\n/// __attribute__((matrix_type(rows, columns))), where \"rows\" specifies\n/// number of rows and \"columns\" specifies the number of columns.\nclass MatrixType : public Type, public llvm::FoldingSetNode {\nprotected:\n  friend class ASTContext;\n\n  /// The element type of the matrix.\n  QualType ElementType;\n\n  MatrixType(QualType ElementTy, QualType CanonElementTy);\n\n  MatrixType(TypeClass TypeClass, QualType ElementTy, QualType CanonElementTy,\n             const Expr *RowExpr = nullptr, const Expr *ColumnExpr = nullptr);\n\npublic:\n  /// Returns type of the elements being stored in the matrix\n  QualType getElementType() const { return ElementType; }\n\n  /// Valid elements types are the following:\n  /// * an integer type (as in C2x 6.2.5p19), but excluding enumerated types\n  ///   and _Bool\n  /// * the standard floating types float or double\n  /// * a half-precision floating point type, if one is supported on the target\n  static bool isValidElementType(QualType T) {\n    return T->isDependentType() ||\n           (T->isRealType() && !T->isBooleanType() && !T->isEnumeralType());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix ||\n           T->getTypeClass() == DependentSizedMatrix;\n  }\n};\n\n/// Represents a concrete matrix type with constant number of rows and columns\nclass ConstantMatrixType final : public MatrixType {\nprotected:\n  friend class ASTContext;\n\n  /// The element type of the matrix.\n  // FIXME: Appears to be unused? There is also MatrixType::ElementType...\n  QualType ElementType;\n\n  /// Number of rows and columns.\n  unsigned NumRows;\n  unsigned NumColumns;\n\n  static constexpr unsigned MaxElementsPerDimension = (1 << 20) - 1;\n\n  ConstantMatrixType(QualType MatrixElementType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\n  ConstantMatrixType(TypeClass typeClass, QualType MatrixType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\npublic:\n  /// Returns the number of rows in the matrix.\n  unsigned getNumRows() const { return NumRows; }\n\n  /// Returns the number of columns in the matrix.\n  unsigned getNumColumns() const { return NumColumns; }\n\n  /// Returns the number of elements required to embed the matrix into a vector.\n  unsigned getNumElementsFlattened() const {\n    return getNumRows() * getNumColumns();\n  }\n\n  /// Returns true if \\p NumElements is a valid matrix dimension.\n  static constexpr bool isDimensionValid(size_t NumElements) {\n    return NumElements > 0 && NumElements <= MaxElementsPerDimension;\n  }\n\n  /// Returns the maximum number of elements per dimension.\n  static constexpr unsigned getMaxElementsPerDimension() {\n    return MaxElementsPerDimension;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumRows(), getNumColumns(),\n            getTypeClass());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumRows, unsigned NumColumns,\n                      TypeClass TypeClass) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumRows);\n    ID.AddInteger(NumColumns);\n    ID.AddInteger(TypeClass);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix;\n  }\n};\n\n/// Represents a matrix type where the type and the number of rows and columns\n/// is dependent on a template.\nclass DependentSizedMatrixType final : public MatrixType {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *RowExpr;\n  Expr *ColumnExpr;\n\n  SourceLocation loc;\n\n  DependentSizedMatrixType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonicalType, Expr *RowExpr,\n                           Expr *ColumnExpr, SourceLocation loc);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n  Expr *getRowExpr() const { return RowExpr; }\n  Expr *getColumnExpr() const { return ColumnExpr; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedMatrix;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getRowExpr(), getColumnExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *RowExpr, Expr *ColumnExpr);\n};\n\n/// FunctionType - C99 6.7.5.3 - Function Declarators.  This is the common base\n/// class of FunctionNoProtoType and FunctionProtoType.\nclass FunctionType : public Type {\n  // The type returned by the function.\n  QualType ResultType;\n\npublic:\n  /// Interesting information about a specific parameter that can't simply\n  /// be reflected in parameter's type. This is only used by FunctionProtoType\n  /// but is in FunctionType to make this class available during the\n  /// specification of the bases of FunctionProtoType.\n  ///\n  /// It makes sense to model language features this way when there's some\n  /// sort of parameter-specific override (such as an attribute) that\n  /// affects how the function is called.  For example, the ARC ns_consumed\n  /// attribute changes whether a parameter is passed at +0 (the default)\n  /// or +1 (ns_consumed).  This must be reflected in the function type,\n  /// but isn't really a change to the parameter type.\n  ///\n  /// One serious disadvantage of modelling language features this way is\n  /// that they generally do not work with language features that attempt\n  /// to destructure types.  For example, template argument deduction will\n  /// not be able to match a parameter declared as\n  ///   T (*)(U)\n  /// against an argument of type\n  ///   void (*)(__attribute__((ns_consumed)) id)\n  /// because the substitution of T=void, U=id into the former will\n  /// not produce the latter.\n  class ExtParameterInfo {\n    enum {\n      ABIMask = 0x0F,\n      IsConsumed = 0x10,\n      HasPassObjSize = 0x20,\n      IsNoEscape = 0x40,\n    };\n    unsigned char Data = 0;\n\n  public:\n    ExtParameterInfo() = default;\n\n    /// Return the ABI treatment of this parameter.\n    ParameterABI getABI() const { return ParameterABI(Data & ABIMask); }\n    ExtParameterInfo withABI(ParameterABI kind) const {\n      ExtParameterInfo copy = *this;\n      copy.Data = (copy.Data & ~ABIMask) | unsigned(kind);\n      return copy;\n    }\n\n    /// Is this parameter considered \"consumed\" by Objective-C ARC?\n    /// Consumed parameters must have retainable object type.\n    bool isConsumed() const { return (Data & IsConsumed); }\n    ExtParameterInfo withIsConsumed(bool consumed) const {\n      ExtParameterInfo copy = *this;\n      if (consumed)\n        copy.Data |= IsConsumed;\n      else\n        copy.Data &= ~IsConsumed;\n      return copy;\n    }\n\n    bool hasPassObjectSize() const { return Data & HasPassObjSize; }\n    ExtParameterInfo withHasPassObjectSize() const {\n      ExtParameterInfo Copy = *this;\n      Copy.Data |= HasPassObjSize;\n      return Copy;\n    }\n\n    bool isNoEscape() const { return Data & IsNoEscape; }\n    ExtParameterInfo withIsNoEscape(bool NoEscape) const {\n      ExtParameterInfo Copy = *this;\n      if (NoEscape)\n        Copy.Data |= IsNoEscape;\n      else\n        Copy.Data &= ~IsNoEscape;\n      return Copy;\n    }\n\n    unsigned char getOpaqueValue() const { return Data; }\n    static ExtParameterInfo getFromOpaqueValue(unsigned char data) {\n      ExtParameterInfo result;\n      result.Data = data;\n      return result;\n    }\n\n    friend bool operator==(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data == rhs.Data;\n    }\n\n    friend bool operator!=(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data != rhs.Data;\n    }\n  };\n\n  /// A class which abstracts out some details necessary for\n  /// making a call.\n  ///\n  /// It is not actually used directly for storing this information in\n  /// a FunctionType, although FunctionType does currently use the\n  /// same bit-pattern.\n  ///\n  // If you add a field (say Foo), other than the obvious places (both,\n  // constructors, compile failures), what you need to update is\n  // * Operator==\n  // * getFoo\n  // * withFoo\n  // * functionType. Add Foo, getFoo.\n  // * ASTContext::getFooType\n  // * ASTContext::mergeFunctionTypes\n  // * FunctionNoProtoType::Profile\n  // * FunctionProtoType::Profile\n  // * TypePrinter::PrintFunctionProto\n  // * AST read and write\n  // * Codegen\n  class ExtInfo {\n    friend class FunctionType;\n\n    // Feel free to rearrange or add bits, but if you go over 16, you'll need to\n    // adjust the Bits field below, and if you add bits, you'll need to adjust\n    // Type::FunctionTypeBitfields::ExtInfo as well.\n\n    // |  CC  |noreturn|produces|nocallersavedregs|regparm|nocfcheck|cmsenscall|\n    // |0 .. 4|   5    |    6   |       7         |8 .. 10|    11   |    12    |\n    //\n    // regparm is either 0 (no regparm attribute) or the regparm value+1.\n    enum { CallConvMask = 0x1F };\n    enum { NoReturnMask = 0x20 };\n    enum { ProducesResultMask = 0x40 };\n    enum { NoCallerSavedRegsMask = 0x80 };\n    enum {\n      RegParmMask =  0x700,\n      RegParmOffset = 8\n    };\n    enum { NoCfCheckMask = 0x800 };\n    enum { CmseNSCallMask = 0x1000 };\n    uint16_t Bits = CC_C;\n\n    ExtInfo(unsigned Bits) : Bits(static_cast<uint16_t>(Bits)) {}\n\n  public:\n    // Constructor with no defaults. Use this when you know that you\n    // have all the elements (when reading an AST file for example).\n    ExtInfo(bool noReturn, bool hasRegParm, unsigned regParm, CallingConv cc,\n            bool producesResult, bool noCallerSavedRegs, bool NoCfCheck,\n            bool cmseNSCall) {\n      assert((!hasRegParm || regParm < 7) && \"Invalid regparm value\");\n      Bits = ((unsigned)cc) | (noReturn ? NoReturnMask : 0) |\n             (producesResult ? ProducesResultMask : 0) |\n             (noCallerSavedRegs ? NoCallerSavedRegsMask : 0) |\n             (hasRegParm ? ((regParm + 1) << RegParmOffset) : 0) |\n             (NoCfCheck ? NoCfCheckMask : 0) |\n             (cmseNSCall ? CmseNSCallMask : 0);\n    }\n\n    // Constructor with all defaults. Use when for example creating a\n    // function known to use defaults.\n    ExtInfo() = default;\n\n    // Constructor with just the calling convention, which is an important part\n    // of the canonical type.\n    ExtInfo(CallingConv CC) : Bits(CC) {}\n\n    bool getNoReturn() const { return Bits & NoReturnMask; }\n    bool getProducesResult() const { return Bits & ProducesResultMask; }\n    bool getCmseNSCall() const { return Bits & CmseNSCallMask; }\n    bool getNoCallerSavedRegs() const { return Bits & NoCallerSavedRegsMask; }\n    bool getNoCfCheck() const { return Bits & NoCfCheckMask; }\n    bool getHasRegParm() const { return ((Bits & RegParmMask) >> RegParmOffset) != 0; }\n\n    unsigned getRegParm() const {\n      unsigned RegParm = (Bits & RegParmMask) >> RegParmOffset;\n      if (RegParm > 0)\n        --RegParm;\n      return RegParm;\n    }\n\n    CallingConv getCC() const { return CallingConv(Bits & CallConvMask); }\n\n    bool operator==(ExtInfo Other) const {\n      return Bits == Other.Bits;\n    }\n    bool operator!=(ExtInfo Other) const {\n      return Bits != Other.Bits;\n    }\n\n    // Note that we don't have setters. That is by design, use\n    // the following with methods instead of mutating these objects.\n\n    ExtInfo withNoReturn(bool noReturn) const {\n      if (noReturn)\n        return ExtInfo(Bits | NoReturnMask);\n      else\n        return ExtInfo(Bits & ~NoReturnMask);\n    }\n\n    ExtInfo withProducesResult(bool producesResult) const {\n      if (producesResult)\n        return ExtInfo(Bits | ProducesResultMask);\n      else\n        return ExtInfo(Bits & ~ProducesResultMask);\n    }\n\n    ExtInfo withCmseNSCall(bool cmseNSCall) const {\n      if (cmseNSCall)\n        return ExtInfo(Bits | CmseNSCallMask);\n      else\n        return ExtInfo(Bits & ~CmseNSCallMask);\n    }\n\n    ExtInfo withNoCallerSavedRegs(bool noCallerSavedRegs) const {\n      if (noCallerSavedRegs)\n        return ExtInfo(Bits | NoCallerSavedRegsMask);\n      else\n        return ExtInfo(Bits & ~NoCallerSavedRegsMask);\n    }\n\n    ExtInfo withNoCfCheck(bool noCfCheck) const {\n      if (noCfCheck)\n        return ExtInfo(Bits | NoCfCheckMask);\n      else\n        return ExtInfo(Bits & ~NoCfCheckMask);\n    }\n\n    ExtInfo withRegParm(unsigned RegParm) const {\n      assert(RegParm < 7 && \"Invalid regparm value\");\n      return ExtInfo((Bits & ~RegParmMask) |\n                     ((RegParm + 1) << RegParmOffset));\n    }\n\n    ExtInfo withCallingConv(CallingConv cc) const {\n      return ExtInfo((Bits & ~CallConvMask) | (unsigned) cc);\n    }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const {\n      ID.AddInteger(Bits);\n    }\n  };\n\n  /// A simple holder for a QualType representing a type in an\n  /// exception specification. Unfortunately needed by FunctionProtoType\n  /// because TrailingObjects cannot handle repeated types.\n  struct ExceptionType { QualType Type; };\n\n  /// A simple holder for various uncommon bits which do not fit in\n  /// FunctionTypeBitfields. Aligned to alignof(void *) to maintain the\n  /// alignment of subsequent objects in TrailingObjects. You must update\n  /// hasExtraBitfields in FunctionProtoType after adding extra data here.\n  struct alignas(void *) FunctionTypeExtraBitfields {\n    /// The number of types in the exception specification.\n    /// A whole unsigned is not needed here and according to\n    /// [implimits] 8 bits would be enough here.\n    unsigned NumExceptionType;\n  };\n\nprotected:\n  FunctionType(TypeClass tc, QualType res, QualType Canonical,\n               TypeDependence Dependence, ExtInfo Info)\n      : Type(tc, Canonical, Dependence), ResultType(res) {\n    FunctionTypeBits.ExtInfo = Info.Bits;\n  }\n\n  Qualifiers getFastTypeQuals() const {\n    return Qualifiers::fromFastMask(FunctionTypeBits.FastTypeQuals);\n  }\n\npublic:\n  QualType getReturnType() const { return ResultType; }\n\n  bool getHasRegParm() const { return getExtInfo().getHasRegParm(); }\n  unsigned getRegParmType() const { return getExtInfo().getRegParm(); }\n\n  /// Determine whether this function type includes the GNU noreturn\n  /// attribute. The C++11 [[noreturn]] attribute does not affect the function\n  /// type.\n  bool getNoReturnAttr() const { return getExtInfo().getNoReturn(); }\n\n  bool getCmseNSCallAttr() const { return getExtInfo().getCmseNSCall(); }\n  CallingConv getCallConv() const { return getExtInfo().getCC(); }\n  ExtInfo getExtInfo() const { return ExtInfo(FunctionTypeBits.ExtInfo); }\n\n  static_assert((~Qualifiers::FastMask & Qualifiers::CVRMask) == 0,\n                \"Const, volatile and restrict are assumed to be a subset of \"\n                \"the fast qualifiers.\");\n\n  bool isConst() const { return getFastTypeQuals().hasConst(); }\n  bool isVolatile() const { return getFastTypeQuals().hasVolatile(); }\n  bool isRestrict() const { return getFastTypeQuals().hasRestrict(); }\n\n  /// Determine the type of an expression that calls a function of\n  /// this type.\n  QualType getCallResultType(const ASTContext &Context) const {\n    return getReturnType().getNonLValueExprType(Context);\n  }\n\n  static StringRef getNameForCallConv(CallingConv CC);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto ||\n           T->getTypeClass() == FunctionProto;\n  }\n};\n\n/// Represents a K&R-style 'int foo()' function, which has\n/// no information available about its arguments.\nclass FunctionNoProtoType : public FunctionType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  FunctionNoProtoType(QualType Result, QualType Canonical, ExtInfo Info)\n      : FunctionType(FunctionNoProto, Result, Canonical,\n                     Result->getDependence() &\n                         ~(TypeDependence::DependentInstantiation |\n                           TypeDependence::UnexpandedPack),\n                     Info) {}\n\npublic:\n  // No additional state past what FunctionType provides.\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReturnType(), getExtInfo());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ResultType,\n                      ExtInfo Info) {\n    Info.Profile(ID);\n    ID.AddPointer(ResultType.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto;\n  }\n};\n\n/// Represents a prototype with parameter type info, e.g.\n/// 'int foo(int)' or 'int foo(void)'.  'void' is represented as having no\n/// parameters, not as having a single void parameter. Such a type can have\n/// an exception specification, but this specification is not part of the\n/// canonical type. FunctionProtoType has several trailing objects, some of\n/// which optional. For more information about the trailing objects see\n/// the first comment inside FunctionProtoType.\nclass FunctionProtoType final\n    : public FunctionType,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<\n          FunctionProtoType, QualType, SourceLocation,\n          FunctionType::FunctionTypeExtraBitfields, FunctionType::ExceptionType,\n          Expr *, FunctionDecl *, FunctionType::ExtParameterInfo, Qualifiers> {\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  // FunctionProtoType is followed by several trailing objects, some of\n  // which optional. They are in order:\n  //\n  // * An array of getNumParams() QualType holding the parameter types.\n  //   Always present. Note that for the vast majority of FunctionProtoType,\n  //   these will be the only trailing objects.\n  //\n  // * Optionally if the function is variadic, the SourceLocation of the\n  //   ellipsis.\n  //\n  // * Optionally if some extra data is stored in FunctionTypeExtraBitfields\n  //   (see FunctionTypeExtraBitfields and FunctionTypeBitfields):\n  //   a single FunctionTypeExtraBitfields. Present if and only if\n  //   hasExtraBitfields() is true.\n  //\n  // * Optionally exactly one of:\n  //   * an array of getNumExceptions() ExceptionType,\n  //   * a single Expr *,\n  //   * a pair of FunctionDecl *,\n  //   * a single FunctionDecl *\n  //   used to store information about the various types of exception\n  //   specification. See getExceptionSpecSize for the details.\n  //\n  // * Optionally an array of getNumParams() ExtParameterInfo holding\n  //   an ExtParameterInfo for each of the parameters. Present if and\n  //   only if hasExtParameterInfos() is true.\n  //\n  // * Optionally a Qualifiers object to represent extra qualifiers that can't\n  //   be represented by FunctionTypeBitfields.FastTypeQuals. Present if and only\n  //   if hasExtQualifiers() is true.\n  //\n  // The optional FunctionTypeExtraBitfields has to be before the data\n  // related to the exception specification since it contains the number\n  // of exception types.\n  //\n  // We put the ExtParameterInfos last.  If all were equal, it would make\n  // more sense to put these before the exception specification, because\n  // it's much easier to skip past them compared to the elaborate switch\n  // required to skip the exception specification.  However, all is not\n  // equal; ExtParameterInfos are used to model very uncommon features,\n  // and it's better not to burden the more common paths.\n\npublic:\n  /// Holds information about the various types of exception specification.\n  /// ExceptionSpecInfo is not stored as such in FunctionProtoType but is\n  /// used to group together the various bits of information about the\n  /// exception specification.\n  struct ExceptionSpecInfo {\n    /// The kind of exception specification this is.\n    ExceptionSpecificationType Type = EST_None;\n\n    /// Explicitly-specified list of exception types.\n    ArrayRef<QualType> Exceptions;\n\n    /// Noexcept expression, if this is a computed noexcept specification.\n    Expr *NoexceptExpr = nullptr;\n\n    /// The function whose exception specification this is, for\n    /// EST_Unevaluated and EST_Uninstantiated.\n    FunctionDecl *SourceDecl = nullptr;\n\n    /// The function template whose exception specification this is instantiated\n    /// from, for EST_Uninstantiated.\n    FunctionDecl *SourceTemplate = nullptr;\n\n    ExceptionSpecInfo() = default;\n\n    ExceptionSpecInfo(ExceptionSpecificationType EST) : Type(EST) {}\n  };\n\n  /// Extra information about a function prototype. ExtProtoInfo is not\n  /// stored as such in FunctionProtoType but is used to group together\n  /// the various bits of extra information about a function prototype.\n  struct ExtProtoInfo {\n    FunctionType::ExtInfo ExtInfo;\n    bool Variadic : 1;\n    bool HasTrailingReturn : 1;\n    Qualifiers TypeQuals;\n    RefQualifierKind RefQualifier = RQ_None;\n    ExceptionSpecInfo ExceptionSpec;\n    const ExtParameterInfo *ExtParameterInfos = nullptr;\n    SourceLocation EllipsisLoc;\n\n    ExtProtoInfo() : Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo(CallingConv CC)\n        : ExtInfo(CC), Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo withExceptionSpec(const ExceptionSpecInfo &ESI) {\n      ExtProtoInfo Result(*this);\n      Result.ExceptionSpec = ESI;\n      return Result;\n    }\n  };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<QualType>) const {\n    return getNumParams();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return isVariadic();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionTypeExtraBitfields>) const {\n    return hasExtraBitfields();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExceptionType>) const {\n    return getExceptionSpecSize().NumExceptionType;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return getExceptionSpecSize().NumExprPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionDecl *>) const {\n    return getExceptionSpecSize().NumFunctionDeclPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExtParameterInfo>) const {\n    return hasExtParameterInfos() ? getNumParams() : 0;\n  }\n\n  /// Determine whether there are any argument types that\n  /// contain an unexpanded parameter pack.\n  static bool containsAnyUnexpandedParameterPack(const QualType *ArgArray,\n                                                 unsigned numArgs) {\n    for (unsigned Idx = 0; Idx < numArgs; ++Idx)\n      if (ArgArray[Idx]->containsUnexpandedParameterPack())\n        return true;\n\n    return false;\n  }\n\n  FunctionProtoType(QualType result, ArrayRef<QualType> params,\n                    QualType canonical, const ExtProtoInfo &epi);\n\n  /// This struct is returned by getExceptionSpecSize and is used to\n  /// translate an ExceptionSpecificationType to the number and kind\n  /// of trailing objects related to the exception specification.\n  struct ExceptionSpecSizeHolder {\n    unsigned NumExceptionType;\n    unsigned NumExprPtr;\n    unsigned NumFunctionDeclPtr;\n  };\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  static ExceptionSpecSizeHolder\n  getExceptionSpecSize(ExceptionSpecificationType EST, unsigned NumExceptions) {\n    switch (EST) {\n    case EST_None:\n    case EST_DynamicNone:\n    case EST_MSAny:\n    case EST_BasicNoexcept:\n    case EST_Unparsed:\n    case EST_NoThrow:\n      return {0, 0, 0};\n\n    case EST_Dynamic:\n      return {NumExceptions, 0, 0};\n\n    case EST_DependentNoexcept:\n    case EST_NoexceptFalse:\n    case EST_NoexceptTrue:\n      return {0, 1, 0};\n\n    case EST_Uninstantiated:\n      return {0, 0, 2};\n\n    case EST_Unevaluated:\n      return {0, 0, 1};\n    }\n    llvm_unreachable(\"bad exception specification kind\");\n  }\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  ExceptionSpecSizeHolder getExceptionSpecSize() const {\n    return getExceptionSpecSize(getExceptionSpecType(), getNumExceptions());\n  }\n\n  /// Whether the trailing FunctionTypeExtraBitfields is present.\n  static bool hasExtraBitfields(ExceptionSpecificationType EST) {\n    // If the exception spec type is EST_Dynamic then we have > 0 exception\n    // types and the exact number is stored in FunctionTypeExtraBitfields.\n    return EST == EST_Dynamic;\n  }\n\n  /// Whether the trailing FunctionTypeExtraBitfields is present.\n  bool hasExtraBitfields() const {\n    return hasExtraBitfields(getExceptionSpecType());\n  }\n\n  bool hasExtQualifiers() const {\n    return FunctionTypeBits.HasExtQuals;\n  }\n\npublic:\n  unsigned getNumParams() const { return FunctionTypeBits.NumParams; }\n\n  QualType getParamType(unsigned i) const {\n    assert(i < getNumParams() && \"invalid parameter index\");\n    return param_type_begin()[i];\n  }\n\n  ArrayRef<QualType> getParamTypes() const {\n    return llvm::makeArrayRef(param_type_begin(), param_type_end());\n  }\n\n  ExtProtoInfo getExtProtoInfo() const {\n    ExtProtoInfo EPI;\n    EPI.ExtInfo = getExtInfo();\n    EPI.Variadic = isVariadic();\n    EPI.EllipsisLoc = getEllipsisLoc();\n    EPI.HasTrailingReturn = hasTrailingReturn();\n    EPI.ExceptionSpec = getExceptionSpecInfo();\n    EPI.TypeQuals = getMethodQuals();\n    EPI.RefQualifier = getRefQualifier();\n    EPI.ExtParameterInfos = getExtParameterInfosOrNull();\n    return EPI;\n  }\n\n  /// Get the kind of exception specification on this function.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    return static_cast<ExceptionSpecificationType>(\n        FunctionTypeBits.ExceptionSpecType);\n  }\n\n  /// Return whether this function has any kind of exception spec.\n  bool hasExceptionSpec() const { return getExceptionSpecType() != EST_None; }\n\n  /// Return whether this function has a dynamic (throw) exception spec.\n  bool hasDynamicExceptionSpec() const {\n    return isDynamicExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a noexcept exception spec.\n  bool hasNoexceptExceptionSpec() const {\n    return isNoexceptExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a dependent exception spec.\n  bool hasDependentExceptionSpec() const;\n\n  /// Return whether this function has an instantiation-dependent exception\n  /// spec.\n  bool hasInstantiationDependentExceptionSpec() const;\n\n  /// Return all the available information about this type's exception spec.\n  ExceptionSpecInfo getExceptionSpecInfo() const {\n    ExceptionSpecInfo Result;\n    Result.Type = getExceptionSpecType();\n    if (Result.Type == EST_Dynamic) {\n      Result.Exceptions = exceptions();\n    } else if (isComputedNoexcept(Result.Type)) {\n      Result.NoexceptExpr = getNoexceptExpr();\n    } else if (Result.Type == EST_Uninstantiated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n      Result.SourceTemplate = getExceptionSpecTemplate();\n    } else if (Result.Type == EST_Unevaluated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n    }\n    return Result;\n  }\n\n  /// Return the number of types in the exception specification.\n  unsigned getNumExceptions() const {\n    return getExceptionSpecType() == EST_Dynamic\n               ? getTrailingObjects<FunctionTypeExtraBitfields>()\n                     ->NumExceptionType\n               : 0;\n  }\n\n  /// Return the ith exception type, where 0 <= i < getNumExceptions().\n  QualType getExceptionType(unsigned i) const {\n    assert(i < getNumExceptions() && \"Invalid exception number!\");\n    return exception_begin()[i];\n  }\n\n  /// Return the expression inside noexcept(expression), or a null pointer\n  /// if there is none (because the exception spec is not of this form).\n  Expr *getNoexceptExpr() const {\n    if (!isComputedNoexcept(getExceptionSpecType()))\n      return nullptr;\n    return *getTrailingObjects<Expr *>();\n  }\n\n  /// If this function type has an exception specification which hasn't\n  /// been determined yet (either because it has not been evaluated or because\n  /// it has not been instantiated), this is the function whose exception\n  /// specification is represented by this type.\n  FunctionDecl *getExceptionSpecDecl() const {\n    if (getExceptionSpecType() != EST_Uninstantiated &&\n        getExceptionSpecType() != EST_Unevaluated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[0];\n  }\n\n  /// If this function type has an uninstantiated exception\n  /// specification, this is the function whose exception specification\n  /// should be instantiated to find the exception specification for\n  /// this type.\n  FunctionDecl *getExceptionSpecTemplate() const {\n    if (getExceptionSpecType() != EST_Uninstantiated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[1];\n  }\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification.\n  CanThrowResult canThrow() const;\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification. If this depends on template arguments, returns\n  /// \\c ResultIfDependent.\n  bool isNothrow(bool ResultIfDependent = false) const {\n    return ResultIfDependent ? canThrow() != CT_Can : canThrow() == CT_Cannot;\n  }\n\n  /// Whether this function prototype is variadic.\n  bool isVariadic() const { return FunctionTypeBits.Variadic; }\n\n  SourceLocation getEllipsisLoc() const {\n    return isVariadic() ? *getTrailingObjects<SourceLocation>()\n                        : SourceLocation();\n  }\n\n  /// Determines whether this function prototype contains a\n  /// parameter pack at the end.\n  ///\n  /// A function template whose last parameter is a parameter pack can be\n  /// called with an arbitrary number of arguments, much like a variadic\n  /// function.\n  bool isTemplateVariadic() const;\n\n  /// Whether this function prototype has a trailing return type.\n  bool hasTrailingReturn() const { return FunctionTypeBits.HasTrailingReturn; }\n\n  Qualifiers getMethodQuals() const {\n    if (hasExtQualifiers())\n      return *getTrailingObjects<Qualifiers>();\n    else\n      return getFastTypeQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this function type.\n  RefQualifierKind getRefQualifier() const {\n    return static_cast<RefQualifierKind>(FunctionTypeBits.RefQualifier);\n  }\n\n  using param_type_iterator = const QualType *;\n  using param_type_range = llvm::iterator_range<param_type_iterator>;\n\n  param_type_range param_types() const {\n    return param_type_range(param_type_begin(), param_type_end());\n  }\n\n  param_type_iterator param_type_begin() const {\n    return getTrailingObjects<QualType>();\n  }\n\n  param_type_iterator param_type_end() const {\n    return param_type_begin() + getNumParams();\n  }\n\n  using exception_iterator = const QualType *;\n\n  ArrayRef<QualType> exceptions() const {\n    return llvm::makeArrayRef(exception_begin(), exception_end());\n  }\n\n  exception_iterator exception_begin() const {\n    return reinterpret_cast<exception_iterator>(\n        getTrailingObjects<ExceptionType>());\n  }\n\n  exception_iterator exception_end() const {\n    return exception_begin() + getNumExceptions();\n  }\n\n  /// Is there any interesting extra information for any of the parameters\n  /// of this function type?\n  bool hasExtParameterInfos() const {\n    return FunctionTypeBits.HasExtParameterInfos;\n  }\n\n  ArrayRef<ExtParameterInfo> getExtParameterInfos() const {\n    assert(hasExtParameterInfos());\n    return ArrayRef<ExtParameterInfo>(getTrailingObjects<ExtParameterInfo>(),\n                                      getNumParams());\n  }\n\n  /// Return a pointer to the beginning of the array of extra parameter\n  /// information, if present, or else null if none of the parameters\n  /// carry it.  This is equivalent to getExtProtoInfo().ExtParameterInfos.\n  const ExtParameterInfo *getExtParameterInfosOrNull() const {\n    if (!hasExtParameterInfos())\n      return nullptr;\n    return getTrailingObjects<ExtParameterInfo>();\n  }\n\n  ExtParameterInfo getExtParameterInfo(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I];\n    return ExtParameterInfo();\n  }\n\n  ParameterABI getParameterABI(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].getABI();\n    return ParameterABI::Ordinary;\n  }\n\n  bool isParamConsumed(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].isConsumed();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void printExceptionSpecification(raw_ostream &OS,\n                                   const PrintingPolicy &Policy) const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionProto;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx);\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Result,\n                      param_type_iterator ArgTys, unsigned NumArgs,\n                      const ExtProtoInfo &EPI, const ASTContext &Context,\n                      bool Canonical);\n};\n\n/// Represents the dependent type named by a dependently-scoped\n/// typename using declaration, e.g.\n///   using typename Base<T>::foo;\n///\n/// Template instantiation turns these into the underlying type.\nclass UnresolvedUsingType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  UnresolvedUsingTypenameDecl *Decl;\n\n  UnresolvedUsingType(const UnresolvedUsingTypenameDecl *D)\n      : Type(UnresolvedUsing, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(const_cast<UnresolvedUsingTypenameDecl *>(D)) {}\n\npublic:\n  UnresolvedUsingTypenameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnresolvedUsing;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    return Profile(ID, Decl);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      UnresolvedUsingTypenameDecl *D) {\n    ID.AddPointer(D);\n  }\n};\n\nclass TypedefType : public Type {\n  TypedefNameDecl *Decl;\n\nprivate:\n  friend class ASTContext; // ASTContext creates these.\n\n  TypedefType(TypeClass tc, const TypedefNameDecl *D, QualType underlying,\n              QualType can);\n\npublic:\n  TypedefNameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Typedef; }\n};\n\n/// Sugar type that represents a type that was qualified by a qualifier written\n/// as a macro invocation.\nclass MacroQualifiedType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType UnderlyingTy;\n  const IdentifierInfo *MacroII;\n\n  MacroQualifiedType(QualType UnderlyingTy, QualType CanonTy,\n                     const IdentifierInfo *MacroII)\n      : Type(MacroQualified, CanonTy, UnderlyingTy->getDependence()),\n        UnderlyingTy(UnderlyingTy), MacroII(MacroII) {\n    assert(isa<AttributedType>(UnderlyingTy) &&\n           \"Expected a macro qualified type to only wrap attributed types.\");\n  }\n\npublic:\n  const IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n  QualType getUnderlyingType() const { return UnderlyingTy; }\n\n  /// Return this attributed type's modified type with no qualifiers attached to\n  /// it.\n  QualType getModifiedType() const;\n\n  bool isSugared() const { return true; }\n  QualType desugar() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == MacroQualified;\n  }\n};\n\n/// Represents a `typeof` (or __typeof__) expression (a GCC extension).\nclass TypeOfExprType : public Type {\n  Expr *TOExpr;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  TypeOfExprType(Expr *E, QualType can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return TOExpr; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOfExpr; }\n};\n\n/// Internal representation of canonical, dependent\n/// `typeof(expr)` types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via TypeOfExprType nodes.\nclass DependentTypeOfExprType\n  : public TypeOfExprType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentTypeOfExprType(const ASTContext &Context, Expr *E)\n      : TypeOfExprType(E), Context(Context) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E);\n};\n\n/// Represents `typeof(type)`, a GCC extension.\nclass TypeOfType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType TOType;\n\n  TypeOfType(QualType T, QualType can)\n      : Type(TypeOf, can, T->getDependence()), TOType(T) {\n    assert(!isa<TypedefType>(can) && \"Invalid canonical type\");\n  }\n\npublic:\n  QualType getUnderlyingType() const { return TOType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const { return getUnderlyingType(); }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOf; }\n};\n\n/// Represents the type `decltype(expr)` (C++11).\nclass DecltypeType : public Type {\n  Expr *E;\n  QualType UnderlyingType;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  DecltypeType(Expr *E, QualType underlyingType, QualType can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return E; }\n  QualType getUnderlyingType() const { return UnderlyingType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Decltype; }\n};\n\n/// Internal representation of canonical, dependent\n/// decltype(expr) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via DecltypeType nodes.\nclass DependentDecltypeType : public DecltypeType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentDecltypeType(const ASTContext &Context, Expr *E);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E);\n};\n\n/// A unary type transform, which is a type constructed from another.\nclass UnaryTransformType : public Type {\npublic:\n  enum UTTKind {\n    EnumUnderlyingType\n  };\n\nprivate:\n  /// The untransformed type.\n  QualType BaseType;\n\n  /// The transformed type if not dependent, otherwise the same as BaseType.\n  QualType UnderlyingType;\n\n  UTTKind UKind;\n\nprotected:\n  friend class ASTContext;\n\n  UnaryTransformType(QualType BaseTy, QualType UnderlyingTy, UTTKind UKind,\n                     QualType CanonicalTy);\n\npublic:\n  bool isSugared() const { return !isDependentType(); }\n  QualType desugar() const { return UnderlyingType; }\n\n  QualType getUnderlyingType() const { return UnderlyingType; }\n  QualType getBaseType() const { return BaseType; }\n\n  UTTKind getUTTKind() const { return UKind; }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnaryTransform;\n  }\n};\n\n/// Internal representation of canonical, dependent\n/// __underlying_type(type) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via UnaryTransformType nodes.\nclass DependentUnaryTransformType : public UnaryTransformType,\n                                    public llvm::FoldingSetNode {\npublic:\n  DependentUnaryTransformType(const ASTContext &C, QualType BaseType,\n                              UTTKind UKind);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getBaseType(), getUTTKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType BaseType,\n                      UTTKind UKind) {\n    ID.AddPointer(BaseType.getAsOpaquePtr());\n    ID.AddInteger((unsigned)UKind);\n  }\n};\n\nclass TagType : public Type {\n  friend class ASTReader;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  /// Stores the TagDecl associated with this type. The decl may point to any\n  /// TagDecl that declares the entity.\n  TagDecl *decl;\n\nprotected:\n  TagType(TypeClass TC, const TagDecl *D, QualType can);\n\npublic:\n  TagDecl *getDecl() const;\n\n  /// Determines whether this type is in the process of being defined.\n  bool isBeingDefined() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Enum || T->getTypeClass() == Record;\n  }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of structs/unions/classes.\nclass RecordType : public TagType {\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit RecordType(const RecordDecl *D)\n      : TagType(Record, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n  explicit RecordType(TypeClass TC, RecordDecl *D)\n      : TagType(TC, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  RecordDecl *getDecl() const {\n    return reinterpret_cast<RecordDecl*>(TagType::getDecl());\n  }\n\n  /// Recursively check all fields in the record for const-ness. If any field\n  /// is declared const, return true. Otherwise, return false.\n  bool hasConstFields() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Record; }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of enums.\nclass EnumType : public TagType {\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit EnumType(const EnumDecl *D)\n      : TagType(Enum, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  EnumDecl *getDecl() const {\n    return reinterpret_cast<EnumDecl*>(TagType::getDecl());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Enum; }\n};\n\n/// An attributed type is a type to which a type attribute has been applied.\n///\n/// The \"modified type\" is the fully-sugared type to which the attributed\n/// type was applied; generally it is not canonically equivalent to the\n/// attributed type. The \"equivalent type\" is the minimally-desugared type\n/// which the type is canonically equivalent to.\n///\n/// For example, in the following attributed type:\n///     int32_t __attribute__((vector_size(16)))\n///   - the modified type is the TypedefType for int32_t\n///   - the equivalent type is VectorType(16, int32_t)\n///   - the canonical type is VectorType(16, int)\nclass AttributedType : public Type, public llvm::FoldingSetNode {\npublic:\n  using Kind = attr::Kind;\n\nprivate:\n  friend class ASTContext; // ASTContext creates these\n\n  QualType ModifiedType;\n  QualType EquivalentType;\n\n  AttributedType(QualType canon, attr::Kind attrKind, QualType modified,\n                 QualType equivalent)\n      : Type(Attributed, canon, equivalent->getDependence()),\n        ModifiedType(modified), EquivalentType(equivalent) {\n    AttributedTypeBits.AttrKind = attrKind;\n  }\n\npublic:\n  Kind getAttrKind() const {\n    return static_cast<Kind>(AttributedTypeBits.AttrKind);\n  }\n\n  QualType getModifiedType() const { return ModifiedType; }\n  QualType getEquivalentType() const { return EquivalentType; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getEquivalentType(); }\n\n  /// Does this attribute behave like a type qualifier?\n  ///\n  /// A type qualifier adjusts a type to provide specialized rules for\n  /// a specific object, like the standard const and volatile qualifiers.\n  /// This includes attributes controlling things like nullability,\n  /// address spaces, and ARC ownership.  The value of the object is still\n  /// largely described by the modified type.\n  ///\n  /// In contrast, many type attributes \"rewrite\" their modified type to\n  /// produce a fundamentally different type, not necessarily related in any\n  /// formalizable way to the original type.  For example, calling convention\n  /// and vector attributes are not simple type qualifiers.\n  ///\n  /// Type qualifiers are often, but not always, reflected in the canonical\n  /// type.\n  bool isQualifier() const;\n\n  bool isMSTypeSpec() const;\n\n  bool isCallingConv() const;\n\n  llvm::Optional<NullabilityKind> getImmediateNullability() const;\n\n  /// Retrieve the attribute kind corresponding to the given\n  /// nullability kind.\n  static Kind getNullabilityAttrKind(NullabilityKind kind) {\n    switch (kind) {\n    case NullabilityKind::NonNull:\n      return attr::TypeNonNull;\n\n    case NullabilityKind::Nullable:\n      return attr::TypeNullable;\n\n    case NullabilityKind::NullableResult:\n      return attr::TypeNullableResult;\n\n    case NullabilityKind::Unspecified:\n      return attr::TypeNullUnspecified;\n    }\n    llvm_unreachable(\"Unknown nullability kind.\");\n  }\n\n  /// Strip off the top-level nullability annotation on the given\n  /// type, if it's there.\n  ///\n  /// \\param T The type to strip. If the type is exactly an\n  /// AttributedType specifying nullability (without looking through\n  /// type sugar), the nullability is returned and this type changed\n  /// to the underlying modified type.\n  ///\n  /// \\returns the top-level nullability, if present.\n  static Optional<NullabilityKind> stripOuterNullability(QualType &T);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getAttrKind(), ModifiedType, EquivalentType);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Kind attrKind,\n                      QualType modified, QualType equivalent) {\n    ID.AddInteger(attrKind);\n    ID.AddPointer(modified.getAsOpaquePtr());\n    ID.AddPointer(equivalent.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Attributed;\n  }\n};\n\nclass TemplateTypeParmType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  // Helper data collector for canonical types.\n  struct CanonicalTTPTInfo {\n    unsigned Depth : 15;\n    unsigned ParameterPack : 1;\n    unsigned Index : 16;\n  };\n\n  union {\n    // Info for the canonical type.\n    CanonicalTTPTInfo CanTTPTInfo;\n\n    // Info for the non-canonical type.\n    TemplateTypeParmDecl *TTPDecl;\n  };\n\n  /// Build a non-canonical type.\n  TemplateTypeParmType(TemplateTypeParmDecl *TTPDecl, QualType Canon)\n      : Type(TemplateTypeParm, Canon,\n             TypeDependence::DependentInstantiation |\n                 (Canon->getDependence() & TypeDependence::UnexpandedPack)),\n        TTPDecl(TTPDecl) {}\n\n  /// Build the canonical type.\n  TemplateTypeParmType(unsigned D, unsigned I, bool PP)\n      : Type(TemplateTypeParm, QualType(this, 0),\n             TypeDependence::DependentInstantiation |\n                 (PP ? TypeDependence::UnexpandedPack : TypeDependence::None)) {\n    CanTTPTInfo.Depth = D;\n    CanTTPTInfo.Index = I;\n    CanTTPTInfo.ParameterPack = PP;\n  }\n\n  const CanonicalTTPTInfo& getCanTTPTInfo() const {\n    QualType Can = getCanonicalTypeInternal();\n    return Can->castAs<TemplateTypeParmType>()->CanTTPTInfo;\n  }\n\npublic:\n  unsigned getDepth() const { return getCanTTPTInfo().Depth; }\n  unsigned getIndex() const { return getCanTTPTInfo().Index; }\n  bool isParameterPack() const { return getCanTTPTInfo().ParameterPack; }\n\n  TemplateTypeParmDecl *getDecl() const {\n    return isCanonicalUnqualified() ? nullptr : TTPDecl;\n  }\n\n  IdentifierInfo *getIdentifier() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getDepth(), getIndex(), isParameterPack(), getDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, unsigned Depth,\n                      unsigned Index, bool ParameterPack,\n                      TemplateTypeParmDecl *TTPDecl) {\n    ID.AddInteger(Depth);\n    ID.AddInteger(Index);\n    ID.AddBoolean(ParameterPack);\n    ID.AddPointer(TTPDecl);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a type for a template\n/// type parameter.\n///\n/// Within an instantiated template, all template type parameters have\n/// been replaced with these.  They are used solely to record that a\n/// type was originally written as a template type parameter;\n/// therefore they are never canonical.\nclass SubstTemplateTypeParmType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  // The original type parameter.\n  const TemplateTypeParmType *Replaced;\n\n  SubstTemplateTypeParmType(const TemplateTypeParmType *Param, QualType Canon)\n      : Type(SubstTemplateTypeParm, Canon, Canon->getDependence()),\n        Replaced(Param) {}\n\npublic:\n  /// Gets the template parameter that was substituted for.\n  const TemplateTypeParmType *getReplacedParameter() const {\n    return Replaced;\n  }\n\n  /// Gets the type that was substituted for the template\n  /// parameter.\n  QualType getReplacementType() const {\n    return getCanonicalTypeInternal();\n  }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getReplacementType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReplacedParameter(), getReplacementType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const TemplateTypeParmType *Replaced,\n                      QualType Replacement) {\n    ID.AddPointer(Replaced);\n    ID.AddPointer(Replacement.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a set of types for a template\n/// type parameter pack.\n///\n/// When a pack expansion in the source code contains multiple parameter packs\n/// and those parameter packs correspond to different levels of template\n/// parameter lists, this type node is used to represent a template type\n/// parameter pack from an outer level, which has already had its argument pack\n/// substituted but that still lives within a pack expansion that itself\n/// could not be instantiated. When actually performing a substitution into\n/// that pack expansion (e.g., when all template parameters have corresponding\n/// arguments), this type will be replaced with the \\c SubstTemplateTypeParmType\n/// at the current pack substitution index.\nclass SubstTemplateTypeParmPackType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// The original type parameter.\n  const TemplateTypeParmType *Replaced;\n\n  /// A pointer to the set of template arguments that this\n  /// parameter pack is instantiated with.\n  const TemplateArgument *Arguments;\n\n  SubstTemplateTypeParmPackType(const TemplateTypeParmType *Param,\n                                QualType Canon,\n                                const TemplateArgument &ArgPack);\n\npublic:\n  IdentifierInfo *getIdentifier() const { return Replaced->getIdentifier(); }\n\n  /// Gets the template parameter that was substituted for.\n  const TemplateTypeParmType *getReplacedParameter() const {\n    return Replaced;\n  }\n\n  unsigned getNumArgs() const {\n    return SubstTemplateTypeParmPackTypeBits.NumArgs;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  TemplateArgument getArgumentPack() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const TemplateTypeParmType *Replaced,\n                      const TemplateArgument &ArgPack);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParmPack;\n  }\n};\n\n/// Common base class for placeholders for types that get replaced by\n/// placeholder type deduction: C++11 auto, C++14 decltype(auto), C++17 deduced\n/// class template types, and constrained type names.\n///\n/// These types are usually a placeholder for a deduced type. However, before\n/// the initializer is attached, or (usually) if the initializer is\n/// type-dependent, there is no deduced type and the type is canonical. In\n/// the latter case, it is also a dependent type.\nclass DeducedType : public Type {\nprotected:\n  DeducedType(TypeClass TC, QualType DeducedAsType,\n              TypeDependence ExtraDependence)\n      : Type(TC,\n             // FIXME: Retain the sugared deduced type?\n             DeducedAsType.isNull() ? QualType(this, 0)\n                                    : DeducedAsType.getCanonicalType(),\n             ExtraDependence | (DeducedAsType.isNull()\n                                    ? TypeDependence::None\n                                    : DeducedAsType->getDependence() &\n                                          ~TypeDependence::VariablyModified)) {}\n\npublic:\n  bool isSugared() const { return !isCanonicalUnqualified(); }\n  QualType desugar() const { return getCanonicalTypeInternal(); }\n\n  /// Get the type deduced for this placeholder type, or null if it's\n  /// either not been deduced or was deduced to a dependent type.\n  QualType getDeducedType() const {\n    return !isCanonicalUnqualified() ? getCanonicalTypeInternal() : QualType();\n  }\n  bool isDeduced() const {\n    return !isCanonicalUnqualified() || isDependentType();\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto ||\n           T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a C++11 auto or C++14 decltype(auto) type, possibly constrained\n/// by a type-constraint.\nclass alignas(8) AutoType : public DeducedType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  ConceptDecl *TypeConstraintConcept;\n\n  AutoType(QualType DeducedAsType, AutoTypeKeyword Keyword,\n           TypeDependence ExtraDependence, ConceptDecl *CD,\n           ArrayRef<TemplateArgument> TypeConstraintArgs);\n\n  const TemplateArgument *getArgBuffer() const {\n    return reinterpret_cast<const TemplateArgument*>(this+1);\n  }\n\n  TemplateArgument *getArgBuffer() {\n    return reinterpret_cast<TemplateArgument*>(this+1);\n  }\n\npublic:\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return getArgBuffer();\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return AutoTypeBits.NumArgs;\n  }\n\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> getTypeConstraintArguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  ConceptDecl *getTypeConstraintConcept() const {\n    return TypeConstraintConcept;\n  }\n\n  bool isConstrained() const {\n    return TypeConstraintConcept != nullptr;\n  }\n\n  bool isDecltypeAuto() const {\n    return getKeyword() == AutoTypeKeyword::DecltypeAuto;\n  }\n\n  AutoTypeKeyword getKeyword() const {\n    return (AutoTypeKeyword)AutoTypeBits.Keyword;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {\n    Profile(ID, Context, getDeducedType(), getKeyword(), isDependentType(),\n            getTypeConstraintConcept(), getTypeConstraintArguments());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType Deduced, AutoTypeKeyword Keyword,\n                      bool IsDependent, ConceptDecl *CD,\n                      ArrayRef<TemplateArgument> Arguments);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto;\n  }\n};\n\n/// Represents a C++17 deduced template specialization type.\nclass DeducedTemplateSpecializationType : public DeducedType,\n                                          public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template whose arguments will be deduced.\n  TemplateName Template;\n\n  DeducedTemplateSpecializationType(TemplateName Template,\n                                    QualType DeducedAsType,\n                                    bool IsDeducedAsDependent)\n      : DeducedType(DeducedTemplateSpecialization, DeducedAsType,\n                    toTypeDependence(Template.getDependence()) |\n                        (IsDeducedAsDependent\n                             ? TypeDependence::DependentInstantiation\n                             : TypeDependence::None)),\n        Template(Template) {}\n\npublic:\n  /// Retrieve the name of the template that we are deducing.\n  TemplateName getTemplateName() const { return Template;}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getTemplateName(), getDeducedType(), isDependentType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName Template,\n                      QualType Deduced, bool IsDependent) {\n    Template.Profile(ID);\n    ID.AddPointer(Deduced.getAsOpaquePtr());\n    ID.AddBoolean(IsDependent);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a type template specialization; the template\n/// must be a class template, a type alias template, or a template\n/// template parameter.  A template which cannot be resolved to one of\n/// these, e.g. because it is written with a dependent scope\n/// specifier, is instead represented as a\n/// @c DependentTemplateSpecializationType.\n///\n/// A non-dependent template specialization type is always \"sugar\",\n/// typically for a \\c RecordType.  For example, a class template\n/// specialization type of \\c vector<int> will refer to a tag type for\n/// the instantiation \\c std::vector<int, std::allocator<int>>\n///\n/// Template specializations are dependent if either the template or\n/// any of the template arguments are dependent, in which case the\n/// type may also be canonical.\n///\n/// Instances of this type are allocated with a trailing array of\n/// TemplateArguments, followed by a QualType representing the\n/// non-canonical aliased type when the template is a type alias\n/// template.\nclass alignas(8) TemplateSpecializationType\n    : public Type,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template being specialized.  This is\n  /// either a TemplateName::Template (in which case it is a\n  /// ClassTemplateDecl*, a TemplateTemplateParmDecl*, or a\n  /// TypeAliasTemplateDecl*), a\n  /// TemplateName::SubstTemplateTemplateParmPack, or a\n  /// TemplateName::SubstTemplateTemplateParm (in which case the\n  /// replacement must, recursively, be one of these).\n  TemplateName Template;\n\n  TemplateSpecializationType(TemplateName T,\n                             ArrayRef<TemplateArgument> Args,\n                             QualType Canon,\n                             QualType Aliased);\n\npublic:\n  /// Determine whether any of the given template arguments are dependent.\n  ///\n  /// The converted arguments should be supplied when known; whether an\n  /// argument is dependent can depend on the conversions performed on it\n  /// (for example, a 'const int' passed as a template argument might be\n  /// dependent if the parameter is a reference but non-dependent if the\n  /// parameter is an int).\n  ///\n  /// Note that the \\p Args parameter is unused: this is intentional, to remind\n  /// the caller that they need to pass in the converted arguments, not the\n  /// specified arguments.\n  static bool\n  anyDependentTemplateArguments(ArrayRef<TemplateArgumentLoc> Args,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool\n  anyDependentTemplateArguments(const TemplateArgumentListInfo &,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool anyInstantiationDependentTemplateArguments(\n      ArrayRef<TemplateArgumentLoc> Args);\n\n  /// True if this template specialization type matches a current\n  /// instantiation in the context in which it is found.\n  bool isCurrentInstantiation() const {\n    return isa<InjectedClassNameType>(getCanonicalTypeInternal());\n  }\n\n  /// Determine if this template specialization type is for a type alias\n  /// template that has been substituted.\n  ///\n  /// Nearly every template specialization type whose template is an alias\n  /// template will be substituted. However, this is not the case when\n  /// the specialization contains a pack expansion but the template alias\n  /// does not have a corresponding parameter pack, e.g.,\n  ///\n  /// \\code\n  /// template<typename T, typename U, typename V> struct S;\n  /// template<typename T, typename U> using A = S<T, int, U>;\n  /// template<typename... Ts> struct X {\n  ///   typedef A<Ts...> type; // not a type alias\n  /// };\n  /// \\endcode\n  bool isTypeAlias() const { return TemplateSpecializationTypeBits.TypeAlias; }\n\n  /// Get the aliased type, if this is a specialization of a type alias\n  /// template.\n  QualType getAliasedType() const {\n    assert(isTypeAlias() && \"not a type alias template specialization\");\n    return *reinterpret_cast<const QualType*>(end());\n  }\n\n  using iterator = const TemplateArgument *;\n\n  iterator begin() const { return getArgs(); }\n  iterator end() const; // defined inline in TemplateBase.h\n\n  /// Retrieve the name of the template that we are specializing.\n  TemplateName getTemplateName() const { return Template; }\n\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return reinterpret_cast<const TemplateArgument *>(this + 1);\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return TemplateSpecializationTypeBits.NumArgs;\n  }\n\n  /// Retrieve a specific template argument as a type.\n  /// \\pre \\c isArgType(Arg)\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  bool isSugared() const {\n    return !isDependentType() || isCurrentInstantiation() || isTypeAlias();\n  }\n\n  QualType desugar() const {\n    return isTypeAlias() ? getAliasedType() : getCanonicalTypeInternal();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx) {\n    Profile(ID, Template, template_arguments(), Ctx);\n    if (isTypeAlias())\n      getAliasedType().Profile(ID);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName T,\n                      ArrayRef<TemplateArgument> Args,\n                      const ASTContext &Context);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateSpecialization;\n  }\n};\n\n/// Print a template argument list, including the '<' and '>'\n/// enclosing the template arguments.\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgument> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgumentLoc> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               const TemplateArgumentListInfo &Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\n/// The injected class name of a C++ class template or class\n/// template partial specialization.  Used to record that a type was\n/// spelled with a bare identifier rather than as a template-id; the\n/// equivalent for non-templated classes is just RecordType.\n///\n/// Injected class name types are always dependent.  Template\n/// instantiation turns these into RecordTypes.\n///\n/// Injected class name types are always canonical.  This works\n/// because it is impossible to compare an injected class name type\n/// with the corresponding non-injected template type, for the same\n/// reason that it is impossible to directly compare template\n/// parameters from different dependent contexts: injected class name\n/// types can only occur within the scope of a particular templated\n/// declaration, and within that scope every template specialization\n/// will canonicalize to the injected class name (when appropriate\n/// according to the rules of the language).\nclass InjectedClassNameType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTNodeImporter;\n  friend class ASTReader; // FIXME: ASTContext::getInjectedClassNameType is not\n                          // currently suitable for AST reading, too much\n                          // interdependencies.\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  CXXRecordDecl *Decl;\n\n  /// The template specialization which this type represents.\n  /// For example, in\n  ///   template <class T> class A { ... };\n  /// this is A<T>, whereas in\n  ///   template <class X, class Y> class A<B<X,Y> > { ... };\n  /// this is A<B<X,Y> >.\n  ///\n  /// It is always unqualified, always a template specialization type,\n  /// and always dependent.\n  QualType InjectedType;\n\n  InjectedClassNameType(CXXRecordDecl *D, QualType TST)\n      : Type(InjectedClassName, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(D), InjectedType(TST) {\n    assert(isa<TemplateSpecializationType>(TST));\n    assert(!TST.hasQualifiers());\n    assert(TST->isDependentType());\n  }\n\npublic:\n  QualType getInjectedSpecializationType() const { return InjectedType; }\n\n  const TemplateSpecializationType *getInjectedTST() const {\n    return cast<TemplateSpecializationType>(InjectedType.getTypePtr());\n  }\n\n  TemplateName getTemplateName() const {\n    return getInjectedTST()->getTemplateName();\n  }\n\n  CXXRecordDecl *getDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == InjectedClassName;\n  }\n};\n\n/// The kind of a tag type.\nenum TagTypeKind {\n  /// The \"struct\" keyword.\n  TTK_Struct,\n\n  /// The \"__interface\" keyword.\n  TTK_Interface,\n\n  /// The \"union\" keyword.\n  TTK_Union,\n\n  /// The \"class\" keyword.\n  TTK_Class,\n\n  /// The \"enum\" keyword.\n  TTK_Enum\n};\n\n/// The elaboration keyword that precedes a qualified type name or\n/// introduces an elaborated-type-specifier.\nenum ElaboratedTypeKeyword {\n  /// The \"struct\" keyword introduces the elaborated-type-specifier.\n  ETK_Struct,\n\n  /// The \"__interface\" keyword introduces the elaborated-type-specifier.\n  ETK_Interface,\n\n  /// The \"union\" keyword introduces the elaborated-type-specifier.\n  ETK_Union,\n\n  /// The \"class\" keyword introduces the elaborated-type-specifier.\n  ETK_Class,\n\n  /// The \"enum\" keyword introduces the elaborated-type-specifier.\n  ETK_Enum,\n\n  /// The \"typename\" keyword precedes the qualified type name, e.g.,\n  /// \\c typename T::type.\n  ETK_Typename,\n\n  /// No keyword precedes the qualified type name.\n  ETK_None\n};\n\n/// A helper class for Type nodes having an ElaboratedTypeKeyword.\n/// The keyword in stored in the free bits of the base class.\n/// Also provides a few static helpers for converting and printing\n/// elaborated type keyword and tag type kind enumerations.\nclass TypeWithKeyword : public Type {\nprotected:\n  TypeWithKeyword(ElaboratedTypeKeyword Keyword, TypeClass tc,\n                  QualType Canonical, TypeDependence Dependence)\n      : Type(tc, Canonical, Dependence) {\n    TypeWithKeywordBits.Keyword = Keyword;\n  }\n\npublic:\n  ElaboratedTypeKeyword getKeyword() const {\n    return static_cast<ElaboratedTypeKeyword>(TypeWithKeywordBits.Keyword);\n  }\n\n  /// Converts a type specifier (DeclSpec::TST) into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a type specifier (DeclSpec::TST) into a tag type kind.\n  /// It is an error to provide a type specifier which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a TagTypeKind into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTagTypeKind(TagTypeKind Tag);\n\n  /// Converts an elaborated type keyword into a TagTypeKind.\n  /// It is an error to provide an elaborated type keyword\n  /// which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForKeyword(ElaboratedTypeKeyword Keyword);\n\n  static bool KeywordIsTagTypeKind(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getKeywordName(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getTagTypeKindName(TagTypeKind Kind) {\n    return getKeywordName(getKeywordForTagTypeKind(Kind));\n  }\n\n  class CannotCastToThisType {};\n  static CannotCastToThisType classof(const Type *);\n};\n\n/// Represents a type that was referred to using an elaborated type\n/// keyword, e.g., struct S, or via a qualified name, e.g., N::M::type,\n/// or both.\n///\n/// This type is used to keep track of a type name as written in the\n/// source code, including tag keywords and any nested-name-specifiers.\n/// The type itself is always \"sugar\", used to express what was written\n/// in the source code but containing no additional semantic information.\nclass ElaboratedType final\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<ElaboratedType, TagDecl *> {\n  friend class ASTContext; // ASTContext creates these\n  friend TrailingObjects;\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this qualified name refers to.\n  QualType NamedType;\n\n  /// The (re)declaration of this tag type owned by this occurrence is stored\n  /// as a trailing object if there is one. Use getOwnedTagDecl to obtain\n  /// it, or obtain a null pointer if there is none.\n\n  ElaboratedType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                 QualType NamedType, QualType CanonType, TagDecl *OwnedTagDecl)\n      : TypeWithKeyword(Keyword, Elaborated, CanonType,\n                        // Any semantic dependence on the qualifier will have\n                        // been incorporated into NamedType. We still need to\n                        // track syntactic (instantiation / error / pack)\n                        // dependence on the qualifier.\n                        NamedType->getDependence() |\n                            (NNS ? toSyntacticDependence(\n                                       toTypeDependence(NNS->getDependence()))\n                                 : TypeDependence::None)),\n        NNS(NNS), NamedType(NamedType) {\n    ElaboratedTypeBits.HasOwnedTagDecl = false;\n    if (OwnedTagDecl) {\n      ElaboratedTypeBits.HasOwnedTagDecl = true;\n      *getTrailingObjects<TagDecl *>() = OwnedTagDecl;\n    }\n    assert(!(Keyword == ETK_None && NNS == nullptr) &&\n           \"ElaboratedType cannot have elaborated type keyword \"\n           \"and name qualifier both null.\");\n  }\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the qualified-id.\n  QualType getNamedType() const { return NamedType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const { return getNamedType(); }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  /// Return the (re)declaration of this type owned by this occurrence of this\n  /// type, or nullptr if there is none.\n  TagDecl *getOwnedTagDecl() const {\n    return ElaboratedTypeBits.HasOwnedTagDecl ? *getTrailingObjects<TagDecl *>()\n                                              : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, NamedType, getOwnedTagDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, QualType NamedType,\n                      TagDecl *OwnedTagDecl) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    NamedType.Profile(ID);\n    ID.AddPointer(OwnedTagDecl);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Elaborated; }\n};\n\n/// Represents a qualified type name for which the type name is\n/// dependent.\n///\n/// DependentNameType represents a class of dependent types that involve a\n/// possibly dependent nested-name-specifier (e.g., \"T::\") followed by a\n/// name of a type. The DependentNameType may start with a \"typename\" (for a\n/// typename-specifier), \"class\", \"struct\", \"union\", or \"enum\" (for a\n/// dependent elaborated-type-specifier), or nothing (in contexts where we\n/// know that we must be referring to a type, e.g., in a base class specifier).\n/// Typically the nested-name-specifier is dependent, but in MSVC compatibility\n/// mode, this type is used with non-dependent names to delay name lookup until\n/// instantiation.\nclass DependentNameType : public TypeWithKeyword, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this typename specifier refers to.\n  const IdentifierInfo *Name;\n\n  DependentNameType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                    const IdentifierInfo *Name, QualType CanonType)\n      : TypeWithKeyword(Keyword, DependentName, CanonType,\n                        TypeDependence::DependentInstantiation |\n                            toTypeDependence(NNS->getDependence())),\n        NNS(NNS), Name(Name) {}\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the typename specifier as an identifier.\n  ///\n  /// This routine will return a non-NULL identifier pointer when the\n  /// form of the original typename was terminated by an identifier,\n  /// e.g., \"typename T::type\".\n  const IdentifierInfo *getIdentifier() const {\n    return Name;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, Name);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, const IdentifierInfo *Name) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    ID.AddPointer(Name);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentName;\n  }\n};\n\n/// Represents a template specialization type whose template cannot be\n/// resolved, e.g.\n///   A<T>::template B<T>\nclass alignas(8) DependentTemplateSpecializationType\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The identifier of the template.\n  const IdentifierInfo *Name;\n\n  DependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,\n                                      NestedNameSpecifier *NNS,\n                                      const IdentifierInfo *Name,\n                                      ArrayRef<TemplateArgument> Args,\n                                      QualType Canon);\n\n  const TemplateArgument *getArgBuffer() const {\n    return reinterpret_cast<const TemplateArgument*>(this+1);\n  }\n\n  TemplateArgument *getArgBuffer() {\n    return reinterpret_cast<TemplateArgument*>(this+1);\n  }\n\npublic:\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n  const IdentifierInfo *getIdentifier() const { return Name; }\n\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return getArgBuffer();\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return DependentTemplateSpecializationTypeBits.NumArgs;\n  }\n\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  using iterator = const TemplateArgument *;\n\n  iterator begin() const { return getArgs(); }\n  iterator end() const; // inline in TemplateBase.h\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {\n    Profile(ID, Context, getKeyword(), NNS, Name, {getArgs(), getNumArgs()});\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ASTContext &Context,\n                      ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *Qualifier,\n                      const IdentifierInfo *Name,\n                      ArrayRef<TemplateArgument> Args);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentTemplateSpecialization;\n  }\n};\n\n/// Represents a pack expansion of types.\n///\n/// Pack expansions are part of C++11 variadic templates. A pack\n/// expansion contains a pattern, which itself contains one or more\n/// \"unexpanded\" parameter packs. When instantiated, a pack expansion\n/// produces a series of types, each instantiated from the pattern of\n/// the expansion, where the Ith instantiation of the pattern uses the\n/// Ith arguments bound to each of the unexpanded parameter packs. The\n/// pack expansion is considered to \"expand\" these unexpanded\n/// parameter packs.\n///\n/// \\code\n/// template<typename ...Types> struct tuple;\n///\n/// template<typename ...Types>\n/// struct tuple_of_references {\n///   typedef tuple<Types&...> type;\n/// };\n/// \\endcode\n///\n/// Here, the pack expansion \\c Types&... is represented via a\n/// PackExpansionType whose pattern is Types&.\nclass PackExpansionType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The pattern of the pack expansion.\n  QualType Pattern;\n\n  PackExpansionType(QualType Pattern, QualType Canon,\n                    Optional<unsigned> NumExpansions)\n      : Type(PackExpansion, Canon,\n             (Pattern->getDependence() | TypeDependence::Dependent |\n              TypeDependence::Instantiation) &\n                 ~TypeDependence::UnexpandedPack),\n        Pattern(Pattern) {\n    PackExpansionTypeBits.NumExpansions =\n        NumExpansions ? *NumExpansions + 1 : 0;\n  }\n\npublic:\n  /// Retrieve the pattern of this pack expansion, which is the\n  /// type that will be repeatedly instantiated when instantiating the\n  /// pack expansion itself.\n  QualType getPattern() const { return Pattern; }\n\n  /// Retrieve the number of expansions that this pack expansion will\n  /// generate, if known.\n  Optional<unsigned> getNumExpansions() const {\n    if (PackExpansionTypeBits.NumExpansions)\n      return PackExpansionTypeBits.NumExpansions - 1;\n    return None;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPattern(), getNumExpansions());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pattern,\n                      Optional<unsigned> NumExpansions) {\n    ID.AddPointer(Pattern.getAsOpaquePtr());\n    ID.AddBoolean(NumExpansions.hasValue());\n    if (NumExpansions)\n      ID.AddInteger(*NumExpansions);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == PackExpansion;\n  }\n};\n\n/// This class wraps the list of protocol qualifiers. For types that can\n/// take ObjC protocol qualifers, they can subclass this class.\ntemplate <class T>\nclass ObjCProtocolQualifiers {\nprotected:\n  ObjCProtocolQualifiers() = default;\n\n  ObjCProtocolDecl * const *getProtocolStorage() const {\n    return const_cast<ObjCProtocolQualifiers*>(this)->getProtocolStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorage() {\n    return static_cast<T*>(this)->getProtocolStorageImpl();\n  }\n\n  void setNumProtocols(unsigned N) {\n    static_cast<T*>(this)->setNumProtocolsImpl(N);\n  }\n\n  void initialize(ArrayRef<ObjCProtocolDecl *> protocols) {\n    setNumProtocols(protocols.size());\n    assert(getNumProtocols() == protocols.size() &&\n           \"bitfield overflow in protocol count\");\n    if (!protocols.empty())\n      memcpy(getProtocolStorage(), protocols.data(),\n             protocols.size() * sizeof(ObjCProtocolDecl*));\n  }\n\npublic:\n  using qual_iterator = ObjCProtocolDecl * const *;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n  qual_iterator qual_begin() const { return getProtocolStorage(); }\n  qual_iterator qual_end() const { return qual_begin() + getNumProtocols(); }\n\n  bool qual_empty() const { return getNumProtocols() == 0; }\n\n  /// Return the number of qualifying protocols in this type, or 0 if\n  /// there are none.\n  unsigned getNumProtocols() const {\n    return static_cast<const T*>(this)->getNumProtocolsImpl();\n  }\n\n  /// Fetch a protocol by index.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    assert(I < getNumProtocols() && \"Out-of-range protocol access\");\n    return qual_begin()[I];\n  }\n\n  /// Retrieve all of the protocol qualifiers.\n  ArrayRef<ObjCProtocolDecl *> getProtocols() const {\n    return ArrayRef<ObjCProtocolDecl *>(qual_begin(), getNumProtocols());\n  }\n};\n\n/// Represents a type parameter type in Objective C. It can take\n/// a list of protocols.\nclass ObjCTypeParamType : public Type,\n                          public ObjCProtocolQualifiers<ObjCTypeParamType>,\n                          public llvm::FoldingSetNode {\n  friend class ASTContext;\n  friend class ObjCProtocolQualifiers<ObjCTypeParamType>;\n\n  /// The number of protocols stored on this type.\n  unsigned NumProtocols : 6;\n\n  ObjCTypeParamDecl *OTPDecl;\n\n  /// The protocols are stored after the ObjCTypeParamType node. In the\n  /// canonical type, the list of protocols are sorted alphabetically\n  /// and uniqued.\n  ObjCProtocolDecl **getProtocolStorageImpl();\n\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return NumProtocols;\n  }\n\n  void setNumProtocolsImpl(unsigned N) {\n    NumProtocols = N;\n  }\n\n  ObjCTypeParamType(const ObjCTypeParamDecl *D,\n                    QualType can,\n                    ArrayRef<ObjCProtocolDecl *> protocols);\n\npublic:\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getCanonicalTypeInternal(); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCTypeParam;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ObjCTypeParamDecl *OTPDecl,\n                      QualType CanonicalType,\n                      ArrayRef<ObjCProtocolDecl *> protocols);\n\n  ObjCTypeParamDecl *getDecl() const { return OTPDecl; }\n};\n\n/// Represents a class type in Objective C.\n///\n/// Every Objective C type is a combination of a base type, a set of\n/// type arguments (optional, for parameterized classes) and a list of\n/// protocols.\n///\n/// Given the following declarations:\n/// \\code\n///   \\@class C<T>;\n///   \\@protocol P;\n/// \\endcode\n///\n/// 'C' is an ObjCInterfaceType C.  It is sugar for an ObjCObjectType\n/// with base C and no protocols.\n///\n/// 'C<P>' is an unspecialized ObjCObjectType with base C and protocol list [P].\n/// 'C<C*>' is a specialized ObjCObjectType with type arguments 'C*' and no\n/// protocol list.\n/// 'C<C*><P>' is a specialized ObjCObjectType with base C, type arguments 'C*',\n/// and protocol list [P].\n///\n/// 'id' is a TypedefType which is sugar for an ObjCObjectPointerType whose\n/// pointee is an ObjCObjectType with base BuiltinType::ObjCIdType\n/// and no protocols.\n///\n/// 'id<P>' is an ObjCObjectPointerType whose pointee is an ObjCObjectType\n/// with base BuiltinType::ObjCIdType and protocol list [P].  Eventually\n/// this should get its own sugar class to better represent the source.\nclass ObjCObjectType : public Type,\n                       public ObjCProtocolQualifiers<ObjCObjectType> {\n  friend class ObjCProtocolQualifiers<ObjCObjectType>;\n\n  // ObjCObjectType.NumTypeArgs - the number of type arguments stored\n  // after the ObjCObjectPointerType node.\n  // ObjCObjectType.NumProtocols - the number of protocols stored\n  // after the type arguments of ObjCObjectPointerType node.\n  //\n  // These protocols are those written directly on the type.  If\n  // protocol qualifiers ever become additive, the iterators will need\n  // to get kindof complicated.\n  //\n  // In the canonical object type, these are sorted alphabetically\n  // and uniqued.\n\n  /// Either a BuiltinType or an InterfaceType or sugar for either.\n  QualType BaseType;\n\n  /// Cached superclass type.\n  mutable llvm::PointerIntPair<const ObjCObjectType *, 1, bool>\n    CachedSuperClassType;\n\n  QualType *getTypeArgStorage();\n  const QualType *getTypeArgStorage() const {\n    return const_cast<ObjCObjectType *>(this)->getTypeArgStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorageImpl();\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return ObjCObjectTypeBits.NumProtocols;\n  }\n  void setNumProtocolsImpl(unsigned N) {\n    ObjCObjectTypeBits.NumProtocols = N;\n  }\n\nprotected:\n  enum Nonce_ObjCInterface { Nonce_ObjCInterface };\n\n  ObjCObjectType(QualType Canonical, QualType Base,\n                 ArrayRef<QualType> typeArgs,\n                 ArrayRef<ObjCProtocolDecl *> protocols,\n                 bool isKindOf);\n\n  ObjCObjectType(enum Nonce_ObjCInterface)\n      : Type(ObjCInterface, QualType(), TypeDependence::None),\n        BaseType(QualType(this_(), 0)) {\n    ObjCObjectTypeBits.NumProtocols = 0;\n    ObjCObjectTypeBits.NumTypeArgs = 0;\n    ObjCObjectTypeBits.IsKindOf = 0;\n  }\n\n  void computeSuperClassTypeSlow() const;\n\npublic:\n  /// Gets the base type of this object type.  This is always (possibly\n  /// sugar for) one of:\n  ///  - the 'id' builtin type (as opposed to the 'id' type visible to the\n  ///    user, which is a typedef for an ObjCObjectPointerType)\n  ///  - the 'Class' builtin type (same caveat)\n  ///  - an ObjCObjectType (currently always an ObjCInterfaceType)\n  QualType getBaseType() const { return BaseType; }\n\n  bool isObjCId() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCId);\n  }\n\n  bool isObjCClass() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCClass);\n  }\n\n  bool isObjCUnqualifiedId() const { return qual_empty() && isObjCId(); }\n  bool isObjCUnqualifiedClass() const { return qual_empty() && isObjCClass(); }\n  bool isObjCUnqualifiedIdOrClass() const {\n    if (!qual_empty()) return false;\n    if (const BuiltinType *T = getBaseType()->getAs<BuiltinType>())\n      return T->getKind() == BuiltinType::ObjCId ||\n             T->getKind() == BuiltinType::ObjCClass;\n    return false;\n  }\n  bool isObjCQualifiedId() const { return !qual_empty() && isObjCId(); }\n  bool isObjCQualifiedClass() const { return !qual_empty() && isObjCClass(); }\n\n  /// Gets the interface declaration for this object type, if the base type\n  /// really is an interface.\n  ObjCInterfaceDecl *getInterface() const;\n\n  /// Determine whether this object type is \"specialized\", meaning\n  /// that it has type arguments.\n  bool isSpecialized() const;\n\n  /// Determine whether this object type was written with type arguments.\n  bool isSpecializedAsWritten() const {\n    return ObjCObjectTypeBits.NumTypeArgs > 0;\n  }\n\n  /// Determine whether this object type is \"unspecialized\", meaning\n  /// that it has no type arguments.\n  bool isUnspecialized() const { return !isSpecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments of this object type (semantically).\n  ArrayRef<QualType> getTypeArgs() const;\n\n  /// Retrieve the type arguments of this object type as they were\n  /// written.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return llvm::makeArrayRef(getTypeArgStorage(),\n                              ObjCObjectTypeBits.NumTypeArgs);\n  }\n\n  /// Whether this is a \"__kindof\" type as written.\n  bool isKindOfTypeAsWritten() const { return ObjCObjectTypeBits.IsKindOf; }\n\n  /// Whether this ia a \"__kindof\" type (semantically).\n  bool isKindOfType() const;\n\n  /// Retrieve the type of the superclass of this object type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// specialization of the superclass type. Produces a null type if\n  /// there is no superclass.\n  QualType getSuperClassType() const {\n    if (!CachedSuperClassType.getInt())\n      computeSuperClassTypeSlow();\n\n    assert(CachedSuperClassType.getInt() && \"Superclass not set?\");\n    return QualType(CachedSuperClassType.getPointer(), 0);\n  }\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  QualType stripObjCKindOfTypeAndQuals(const ASTContext &ctx) const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObject ||\n           T->getTypeClass() == ObjCInterface;\n  }\n};\n\n/// A class providing a concrete implementation\n/// of ObjCObjectType, so as to not increase the footprint of\n/// ObjCInterfaceType.  Code outside of ASTContext and the core type\n/// system should not reference this type.\nclass ObjCObjectTypeImpl : public ObjCObjectType, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  // If anyone adds fields here, ObjCObjectType::getProtocolStorage()\n  // will need to be modified.\n\n  ObjCObjectTypeImpl(QualType Canonical, QualType Base,\n                     ArrayRef<QualType> typeArgs,\n                     ArrayRef<ObjCProtocolDecl *> protocols,\n                     bool isKindOf)\n      : ObjCObjectType(Canonical, Base, typeArgs, protocols, isKindOf) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      QualType Base,\n                      ArrayRef<QualType> typeArgs,\n                      ArrayRef<ObjCProtocolDecl *> protocols,\n                      bool isKindOf);\n};\n\ninline QualType *ObjCObjectType::getTypeArgStorage() {\n  return reinterpret_cast<QualType *>(static_cast<ObjCObjectTypeImpl*>(this)+1);\n}\n\ninline ObjCProtocolDecl **ObjCObjectType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             getTypeArgStorage() + ObjCObjectTypeBits.NumTypeArgs);\n}\n\ninline ObjCProtocolDecl **ObjCTypeParamType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             static_cast<ObjCTypeParamType*>(this)+1);\n}\n\n/// Interfaces are the core concept in Objective-C for object oriented design.\n/// They basically correspond to C++ classes.  There are two kinds of interface\n/// types: normal interfaces like `NSString`, and qualified interfaces, which\n/// are qualified with a protocol list like `NSString<NSCopyable, NSAmazing>`.\n///\n/// ObjCInterfaceType guarantees the following properties when considered\n/// as a subtype of its superclass, ObjCObjectType:\n///   - There are no protocol qualifiers.  To reinforce this, code which\n///     tries to invoke the protocol methods via an ObjCInterfaceType will\n///     fail to compile.\n///   - It is its own base type.  That is, if T is an ObjCInterfaceType*,\n///     T->getBaseType() == QualType(T, 0).\nclass ObjCInterfaceType : public ObjCObjectType {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTReader;\n  friend class ObjCInterfaceDecl;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  mutable ObjCInterfaceDecl *Decl;\n\n  ObjCInterfaceType(const ObjCInterfaceDecl *D)\n      : ObjCObjectType(Nonce_ObjCInterface),\n        Decl(const_cast<ObjCInterfaceDecl*>(D)) {}\n\npublic:\n  /// Get the declaration of this interface.\n  ObjCInterfaceDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCInterface;\n  }\n\n  // Nonsense to \"hide\" certain members of ObjCObjectType within this\n  // class.  People asking for protocols on an ObjCInterfaceType are\n  // not going to get what they want: ObjCInterfaceTypes are\n  // guaranteed to have no protocols.\n  enum {\n    qual_iterator,\n    qual_begin,\n    qual_end,\n    getNumProtocols,\n    getProtocol\n  };\n};\n\ninline ObjCInterfaceDecl *ObjCObjectType::getInterface() const {\n  QualType baseType = getBaseType();\n  while (const auto *ObjT = baseType->getAs<ObjCObjectType>()) {\n    if (const auto *T = dyn_cast<ObjCInterfaceType>(ObjT))\n      return T->getDecl();\n\n    baseType = ObjT->getBaseType();\n  }\n\n  return nullptr;\n}\n\n/// Represents a pointer to an Objective C object.\n///\n/// These are constructed from pointer declarators when the pointee type is\n/// an ObjCObjectType (or sugar for one).  In addition, the 'id' and 'Class'\n/// types are typedefs for these, and the protocol-qualified types 'id<P>'\n/// and 'Class<P>' are translated into these.\n///\n/// Pointers to pointers to Objective C objects are still PointerTypes;\n/// only the first level of pointer gets it own type implementation.\nclass ObjCObjectPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  ObjCObjectPointerType(QualType Canonical, QualType Pointee)\n      : Type(ObjCObjectPointer, Canonical, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  /// Gets the type pointed to by this ObjC pointer.\n  /// The result will always be an ObjCObjectType or sugar thereof.\n  QualType getPointeeType() const { return PointeeType; }\n\n  /// Gets the type pointed to by this ObjC pointer.  Always returns non-null.\n  ///\n  /// This method is equivalent to getPointeeType() except that\n  /// it discards any typedefs (or other sugar) between this\n  /// type and the \"outermost\" object type.  So for:\n  /// \\code\n  ///   \\@class A; \\@protocol P; \\@protocol Q;\n  ///   typedef A<P> AP;\n  ///   typedef A A1;\n  ///   typedef A1<P> A1P;\n  ///   typedef A1P<Q> A1PQ;\n  /// \\endcode\n  /// For 'A*', getObjectType() will return 'A'.\n  /// For 'A<P>*', getObjectType() will return 'A<P>'.\n  /// For 'AP*', getObjectType() will return 'A<P>'.\n  /// For 'A1*', getObjectType() will return 'A'.\n  /// For 'A1<P>*', getObjectType() will return 'A1<P>'.\n  /// For 'A1P*', getObjectType() will return 'A1<P>'.\n  /// For 'A1PQ*', getObjectType() will return 'A1<Q>', because\n  ///   adding protocols to a protocol-qualified base discards the\n  ///   old qualifiers (for now).  But if it didn't, getObjectType()\n  ///   would return 'A1P<Q>' (and we'd have to make iterating over\n  ///   qualifiers more complicated).\n  const ObjCObjectType *getObjectType() const {\n    return PointeeType->castAs<ObjCObjectType>();\n  }\n\n  /// If this pointer points to an Objective C\n  /// \\@interface type, gets the type for that interface.  Any protocol\n  /// qualifiers on the interface are ignored.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  const ObjCInterfaceType *getInterfaceType() const;\n\n  /// If this pointer points to an Objective \\@interface\n  /// type, gets the declaration for that interface.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  ObjCInterfaceDecl *getInterfaceDecl() const {\n    return getObjectType()->getInterface();\n  }\n\n  /// True if this is equivalent to the 'id' type, i.e. if\n  /// its object type is the primitive 'id' type with no protocols.\n  bool isObjCIdType() const {\n    return getObjectType()->isObjCUnqualifiedId();\n  }\n\n  /// True if this is equivalent to the 'Class' type,\n  /// i.e. if its object tive is the primitive 'Class' type with no protocols.\n  bool isObjCClassType() const {\n    return getObjectType()->isObjCUnqualifiedClass();\n  }\n\n  /// True if this is equivalent to the 'id' or 'Class' type,\n  bool isObjCIdOrClassType() const {\n    return getObjectType()->isObjCUnqualifiedIdOrClass();\n  }\n\n  /// True if this is equivalent to 'id<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedIdType() const {\n    return getObjectType()->isObjCQualifiedId();\n  }\n\n  /// True if this is equivalent to 'Class<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedClassType() const {\n    return getObjectType()->isObjCQualifiedClass();\n  }\n\n  /// Whether this is a \"__kindof\" type.\n  bool isKindOfType() const { return getObjectType()->isKindOfType(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecialized() const { return getObjectType()->isSpecialized(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecializedAsWritten() const {\n    return getObjectType()->isSpecializedAsWritten();\n  }\n\n  /// Whether this type is unspecialized, meaning that is has no type arguments.\n  bool isUnspecialized() const { return getObjectType()->isUnspecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgs() const {\n    return getObjectType()->getTypeArgs();\n  }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return getObjectType()->getTypeArgsAsWritten();\n  }\n\n  /// An iterator over the qualifiers on the object type.  Provided\n  /// for convenience.  This will always iterate over the full set of\n  /// protocols on a type, not just those provided directly.\n  using qual_iterator = ObjCObjectType::qual_iterator;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n\n  qual_iterator qual_begin() const {\n    return getObjectType()->qual_begin();\n  }\n\n  qual_iterator qual_end() const {\n    return getObjectType()->qual_end();\n  }\n\n  bool qual_empty() const { return getObjectType()->qual_empty(); }\n\n  /// Return the number of qualifying protocols on the object type.\n  unsigned getNumProtocols() const {\n    return getObjectType()->getNumProtocols();\n  }\n\n  /// Retrieve a qualifying protocol by index on the object type.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    return getObjectType()->getProtocol(I);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  /// Retrieve the type of the superclass of this object pointer type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// pointer to a specialization of the superclass type. Produces a\n  /// null type if there is no superclass.\n  QualType getSuperClassType() const;\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  const ObjCObjectPointerType *stripObjCKindOfTypeAndQuals(\n                                 const ASTContext &ctx) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObjectPointer;\n  }\n};\n\nclass AtomicType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ValueType;\n\n  AtomicType(QualType ValTy, QualType Canonical)\n      : Type(Atomic, Canonical, ValTy->getDependence()), ValueType(ValTy) {}\n\npublic:\n  /// Gets the type contained by this atomic type, i.e.\n  /// the type returned by performing an atomic load of this atomic type.\n  QualType getValueType() const { return ValueType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getValueType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Atomic;\n  }\n};\n\n/// PipeType - OpenCL20.\nclass PipeType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ElementType;\n  bool isRead;\n\n  PipeType(QualType elemType, QualType CanonicalPtr, bool isRead)\n      : Type(Pipe, CanonicalPtr, elemType->getDependence()),\n        ElementType(elemType), isRead(isRead) {}\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  bool isSugared() const { return false; }\n\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), isReadOnly());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T, bool isRead) {\n    ID.AddPointer(T.getAsOpaquePtr());\n    ID.AddBoolean(isRead);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Pipe;\n  }\n\n  bool isReadOnly() const { return isRead; }\n};\n\n/// A fixed int type of a specified bitwidth.\nclass ExtIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  unsigned IsUnsigned : 1;\n  unsigned NumBits : 24;\n\nprotected:\n  ExtIntType(bool isUnsigned, unsigned NumBits);\n\npublic:\n  bool isUnsigned() const { return IsUnsigned; }\n  bool isSigned() const { return !IsUnsigned; }\n  unsigned getNumBits() const { return NumBits; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, isUnsigned(), getNumBits());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, bool IsUnsigned,\n                      unsigned NumBits) {\n    ID.AddBoolean(IsUnsigned);\n    ID.AddInteger(NumBits);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == ExtInt; }\n};\n\nclass DependentExtIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  const ASTContext &Context;\n  llvm::PointerIntPair<Expr*, 1, bool> ExprAndUnsigned;\n\nprotected:\n  DependentExtIntType(const ASTContext &Context, bool IsUnsigned,\n                      Expr *NumBits);\n\npublic:\n  bool isUnsigned() const;\n  bool isSigned() const { return !isUnsigned(); }\n  Expr *getNumBitsExpr() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, isUnsigned(), getNumBitsExpr());\n  }\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      bool IsUnsigned, Expr *NumBitsExpr);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentExtInt;\n  }\n};\n\n/// A qualifier set is used to build a set of qualifiers.\nclass QualifierCollector : public Qualifiers {\npublic:\n  QualifierCollector(Qualifiers Qs = Qualifiers()) : Qualifiers(Qs) {}\n\n  /// Collect any qualifiers on the given type and return an\n  /// unqualified type.  The qualifiers are assumed to be consistent\n  /// with those already in the type.\n  const Type *strip(QualType type) {\n    addFastQualifiers(type.getLocalFastQualifiers());\n    if (!type.hasLocalNonFastQualifiers())\n      return type.getTypePtrUnsafe();\n\n    const ExtQuals *extQuals = type.getExtQualsUnsafe();\n    addConsistentQualifiers(extQuals->getQualifiers());\n    return extQuals->getBaseType();\n  }\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, QualType QT) const;\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, const Type* T) const;\n};\n\n/// A container of type source information.\n///\n/// A client can read the relevant info using TypeLoc wrappers, e.g:\n/// @code\n/// TypeLoc TL = TypeSourceInfo->getTypeLoc();\n/// TL.getBeginLoc().print(OS, SrcMgr);\n/// @endcode\nclass alignas(8) TypeSourceInfo {\n  // Contains a memory block after the class, used for type source information,\n  // allocated by ASTContext.\n  friend class ASTContext;\n\n  QualType Ty;\n\n  TypeSourceInfo(QualType ty) : Ty(ty) {}\n\npublic:\n  /// Return the type wrapped by this type source info.\n  QualType getType() const { return Ty; }\n\n  /// Return the TypeLoc wrapper for the type source info.\n  TypeLoc getTypeLoc() const; // implemented in TypeLoc.h\n\n  /// Override the type stored in this TypeSourceInfo. Use with caution!\n  void overrideType(QualType T) { Ty = T; }\n};\n\n// Inline function definitions.\n\ninline SplitQualType SplitQualType::getSingleStepDesugaredType() const {\n  SplitQualType desugar =\n    Ty->getLocallyUnqualifiedSingleStepDesugaredType().split();\n  desugar.Quals.addConsistentQualifiers(Quals);\n  return desugar;\n}\n\ninline const Type *QualType::getTypePtr() const {\n  return getCommonPtr()->BaseType;\n}\n\ninline const Type *QualType::getTypePtrOrNull() const {\n  return (isNull() ? nullptr : getCommonPtr()->BaseType);\n}\n\ninline SplitQualType QualType::split() const {\n  if (!hasLocalNonFastQualifiers())\n    return SplitQualType(getTypePtrUnsafe(),\n                         Qualifiers::fromFastMask(getLocalFastQualifiers()));\n\n  const ExtQuals *eq = getExtQualsUnsafe();\n  Qualifiers qs = eq->getQualifiers();\n  qs.addFastQualifiers(getLocalFastQualifiers());\n  return SplitQualType(eq->getBaseType(), qs);\n}\n\ninline Qualifiers QualType::getLocalQualifiers() const {\n  Qualifiers Quals;\n  if (hasLocalNonFastQualifiers())\n    Quals = getExtQualsUnsafe()->getQualifiers();\n  Quals.addFastQualifiers(getLocalFastQualifiers());\n  return Quals;\n}\n\ninline Qualifiers QualType::getQualifiers() const {\n  Qualifiers quals = getCommonPtr()->CanonicalType.getLocalQualifiers();\n  quals.addFastQualifiers(getLocalFastQualifiers());\n  return quals;\n}\n\ninline unsigned QualType::getCVRQualifiers() const {\n  unsigned cvr = getCommonPtr()->CanonicalType.getLocalCVRQualifiers();\n  cvr |= getLocalCVRQualifiers();\n  return cvr;\n}\n\ninline QualType QualType::getCanonicalType() const {\n  QualType canon = getCommonPtr()->CanonicalType;\n  return canon.withFastQualifiers(getLocalFastQualifiers());\n}\n\ninline bool QualType::isCanonical() const {\n  return getTypePtr()->isCanonicalUnqualified();\n}\n\ninline bool QualType::isCanonicalAsParam() const {\n  if (!isCanonical()) return false;\n  if (hasLocalQualifiers()) return false;\n\n  const Type *T = getTypePtr();\n  if (T->isVariablyModifiedType() && T->hasSizedVLAType())\n    return false;\n\n  return !isa<FunctionType>(T) && !isa<ArrayType>(T);\n}\n\ninline bool QualType::isConstQualified() const {\n  return isLocalConstQualified() ||\n         getCommonPtr()->CanonicalType.isLocalConstQualified();\n}\n\ninline bool QualType::isRestrictQualified() const {\n  return isLocalRestrictQualified() ||\n         getCommonPtr()->CanonicalType.isLocalRestrictQualified();\n}\n\n\ninline bool QualType::isVolatileQualified() const {\n  return isLocalVolatileQualified() ||\n         getCommonPtr()->CanonicalType.isLocalVolatileQualified();\n}\n\ninline bool QualType::hasQualifiers() const {\n  return hasLocalQualifiers() ||\n         getCommonPtr()->CanonicalType.hasLocalQualifiers();\n}\n\ninline QualType QualType::getUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return QualType(getTypePtr(), 0);\n\n  return QualType(getSplitUnqualifiedTypeImpl(*this).Ty, 0);\n}\n\ninline SplitQualType QualType::getSplitUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return split();\n\n  return getSplitUnqualifiedTypeImpl(*this);\n}\n\ninline void QualType::removeLocalConst() {\n  removeLocalFastQualifiers(Qualifiers::Const);\n}\n\ninline void QualType::removeLocalRestrict() {\n  removeLocalFastQualifiers(Qualifiers::Restrict);\n}\n\ninline void QualType::removeLocalVolatile() {\n  removeLocalFastQualifiers(Qualifiers::Volatile);\n}\n\ninline void QualType::removeLocalCVRQualifiers(unsigned Mask) {\n  assert(!(Mask & ~Qualifiers::CVRMask) && \"mask has non-CVR bits\");\n  static_assert((int)Qualifiers::CVRMask == (int)Qualifiers::FastMask,\n                \"Fast bits differ from CVR bits!\");\n\n  // Fast path: we don't need to touch the slow qualifiers.\n  removeLocalFastQualifiers(Mask);\n}\n\n/// Check if this type has any address space qualifier.\ninline bool QualType::hasAddressSpace() const {\n  return getQualifiers().hasAddressSpace();\n}\n\n/// Return the address space of this type.\ninline LangAS QualType::getAddressSpace() const {\n  return getQualifiers().getAddressSpace();\n}\n\n/// Return the gc attribute of this type.\ninline Qualifiers::GC QualType::getObjCGCAttr() const {\n  return getQualifiers().getObjCGCAttr();\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDefaultInitializeCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDestructCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDestructCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveCopyCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveCopyCUnion(RD);\n  return false;\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(const Type &t) {\n  if (const auto *PT = t.getAs<PointerType>()) {\n    if (const auto *FT = PT->getPointeeType()->getAs<FunctionType>())\n      return FT->getExtInfo();\n  } else if (const auto *FT = t.getAs<FunctionType>())\n    return FT->getExtInfo();\n\n  return FunctionType::ExtInfo();\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(QualType t) {\n  return getFunctionExtInfo(*t);\n}\n\n/// Determine whether this type is more\n/// qualified than the Other type. For example, \"const volatile int\"\n/// is more qualified than \"const int\", \"volatile int\", and\n/// \"int\". However, it is not more qualified than \"const volatile\n/// int\".\ninline bool QualType::isMoreQualifiedThan(QualType other) const {\n  Qualifiers MyQuals = getQualifiers();\n  Qualifiers OtherQuals = other.getQualifiers();\n  return (MyQuals != OtherQuals && MyQuals.compatiblyIncludes(OtherQuals));\n}\n\n/// Determine whether this type is at last\n/// as qualified as the Other type. For example, \"const volatile\n/// int\" is at least as qualified as \"const int\", \"volatile int\",\n/// \"int\", and \"const volatile int\".\ninline bool QualType::isAtLeastAsQualifiedAs(QualType other) const {\n  Qualifiers OtherQuals = other.getQualifiers();\n\n  // Ignore __unaligned qualifier if this type is a void.\n  if (getUnqualifiedType()->isVoidType())\n    OtherQuals.removeUnaligned();\n\n  return getQualifiers().compatiblyIncludes(OtherQuals);\n}\n\n/// If Type is a reference type (e.g., const\n/// int&), returns the type that the reference refers to (\"const\n/// int\"). Otherwise, returns the type itself. This routine is used\n/// throughout Sema to implement C++ 5p6:\n///\n///   If an expression initially has the type \"reference to T\" (8.3.2,\n///   8.5.3), the type is adjusted to \"T\" prior to any further\n///   analysis, the expression designates the object or function\n///   denoted by the reference, and the expression is an lvalue.\ninline QualType QualType::getNonReferenceType() const {\n  if (const auto *RefType = (*this)->getAs<ReferenceType>())\n    return RefType->getPointeeType();\n  else\n    return *this;\n}\n\ninline bool QualType::isCForbiddenLValueType() const {\n  return ((getTypePtr()->isVoidType() && !hasQualifiers()) ||\n          getTypePtr()->isFunctionType());\n}\n\n/// Tests whether the type is categorized as a fundamental type.\n///\n/// \\returns True for types specified in C++0x [basic.fundamental].\ninline bool Type::isFundamentalType() const {\n  return isVoidType() ||\n         isNullPtrType() ||\n         // FIXME: It's really annoying that we don't have an\n         // 'isArithmeticType()' which agrees with the standard definition.\n         (isArithmeticType() && !isEnumeralType());\n}\n\n/// Tests whether the type is categorized as a compound type.\n///\n/// \\returns True for types specified in C++0x [basic.compound].\ninline bool Type::isCompoundType() const {\n  // C++0x [basic.compound]p1:\n  //   Compound types can be constructed in the following ways:\n  //    -- arrays of objects of a given type [...];\n  return isArrayType() ||\n  //    -- functions, which have parameters of given types [...];\n         isFunctionType() ||\n  //    -- pointers to void or objects or functions [...];\n         isPointerType() ||\n  //    -- references to objects or functions of a given type. [...]\n         isReferenceType() ||\n  //    -- classes containing a sequence of objects of various types, [...];\n         isRecordType() ||\n  //    -- unions, which are classes capable of containing objects of different\n  //               types at different times;\n         isUnionType() ||\n  //    -- enumerations, which comprise a set of named constant values. [...];\n         isEnumeralType() ||\n  //    -- pointers to non-static class members, [...].\n         isMemberPointerType();\n}\n\ninline bool Type::isFunctionType() const {\n  return isa<FunctionType>(CanonicalType);\n}\n\ninline bool Type::isPointerType() const {\n  return isa<PointerType>(CanonicalType);\n}\n\ninline bool Type::isAnyPointerType() const {\n  return isPointerType() || isObjCObjectPointerType();\n}\n\ninline bool Type::isBlockPointerType() const {\n  return isa<BlockPointerType>(CanonicalType);\n}\n\ninline bool Type::isReferenceType() const {\n  return isa<ReferenceType>(CanonicalType);\n}\n\ninline bool Type::isLValueReferenceType() const {\n  return isa<LValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isRValueReferenceType() const {\n  return isa<RValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isObjectPointerType() const {\n  // Note: an \"object pointer type\" is not the same thing as a pointer to an\n  // object type; rather, it is a pointer to an object type or a pointer to cv\n  // void.\n  if (const auto *T = getAs<PointerType>())\n    return !T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionPointerType() const {\n  if (const auto *T = getAs<PointerType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionReferenceType() const {\n  if (const auto *T = getAs<ReferenceType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isMemberPointerType() const {\n  return isa<MemberPointerType>(CanonicalType);\n}\n\ninline bool Type::isMemberFunctionPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberFunctionPointer();\n  else\n    return false;\n}\n\ninline bool Type::isMemberDataPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberDataPointer();\n  else\n    return false;\n}\n\ninline bool Type::isArrayType() const {\n  return isa<ArrayType>(CanonicalType);\n}\n\ninline bool Type::isConstantArrayType() const {\n  return isa<ConstantArrayType>(CanonicalType);\n}\n\ninline bool Type::isIncompleteArrayType() const {\n  return isa<IncompleteArrayType>(CanonicalType);\n}\n\ninline bool Type::isVariableArrayType() const {\n  return isa<VariableArrayType>(CanonicalType);\n}\n\ninline bool Type::isDependentSizedArrayType() const {\n  return isa<DependentSizedArrayType>(CanonicalType);\n}\n\ninline bool Type::isBuiltinType() const {\n  return isa<BuiltinType>(CanonicalType);\n}\n\ninline bool Type::isRecordType() const {\n  return isa<RecordType>(CanonicalType);\n}\n\ninline bool Type::isEnumeralType() const {\n  return isa<EnumType>(CanonicalType);\n}\n\ninline bool Type::isAnyComplexType() const {\n  return isa<ComplexType>(CanonicalType);\n}\n\ninline bool Type::isVectorType() const {\n  return isa<VectorType>(CanonicalType);\n}\n\ninline bool Type::isExtVectorType() const {\n  return isa<ExtVectorType>(CanonicalType);\n}\n\ninline bool Type::isMatrixType() const {\n  return isa<MatrixType>(CanonicalType);\n}\n\ninline bool Type::isConstantMatrixType() const {\n  return isa<ConstantMatrixType>(CanonicalType);\n}\n\ninline bool Type::isDependentAddressSpaceType() const {\n  return isa<DependentAddressSpaceType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectPointerType() const {\n  return isa<ObjCObjectPointerType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectType() const {\n  return isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectOrInterfaceType() const {\n  return isa<ObjCInterfaceType>(CanonicalType) ||\n    isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isAtomicType() const {\n  return isa<AtomicType>(CanonicalType);\n}\n\ninline bool Type::isUndeducedAutoType() const {\n  return isa<AutoType>(CanonicalType);\n}\n\ninline bool Type::isObjCQualifiedIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedIdType();\n  return false;\n}\n\ninline bool Type::isObjCQualifiedClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedClassType();\n  return false;\n}\n\ninline bool Type::isObjCIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCIdType();\n  return false;\n}\n\ninline bool Type::isObjCClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCClassType();\n  return false;\n}\n\ninline bool Type::isObjCSelType() const {\n  if (const auto *OPT = getAs<PointerType>())\n    return OPT->getPointeeType()->isSpecificBuiltinType(BuiltinType::ObjCSel);\n  return false;\n}\n\ninline bool Type::isObjCBuiltinType() const {\n  return isObjCIdType() || isObjCClassType() || isObjCSelType();\n}\n\ninline bool Type::isDecltypeType() const {\n  return isa<DecltypeType>(this);\n}\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\ninline bool Type::isSamplerT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLSampler);\n}\n\ninline bool Type::isEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLEvent);\n}\n\ninline bool Type::isClkEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLClkEvent);\n}\n\ninline bool Type::isQueueT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLQueue);\n}\n\ninline bool Type::isReserveIDT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLReserveID);\n}\n\ninline bool Type::isImageType() const {\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLImageTypes.def\"\n      false; // end boolean or operation\n}\n\ninline bool Type::isPipeType() const {\n  return isa<PipeType>(CanonicalType);\n}\n\ninline bool Type::isExtIntType() const {\n  return isa<ExtIntType>(CanonicalType);\n}\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n\ninline bool Type::isOCLIntelSubgroupAVCType() const {\n#define INTEL_SUBGROUP_AVC_TYPE(ExtType, Id) \\\n  isOCLIntelSubgroupAVC##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOCLExtOpaqueType() const {\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOpenCLSpecificType() const {\n  return isSamplerT() || isEventT() || isImageType() || isClkEventT() ||\n         isQueueT() || isReserveIDT() || isPipeType() || isOCLExtOpaqueType();\n}\n\ninline bool Type::isTemplateTypeParmType() const {\n  return isa<TemplateTypeParmType>(CanonicalType);\n}\n\ninline bool Type::isSpecificBuiltinType(unsigned K) const {\n  if (const BuiltinType *BT = getAs<BuiltinType>()) {\n    return BT->getKind() == static_cast<BuiltinType::Kind>(K);\n  }\n  return false;\n}\n\ninline bool Type::isPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isPlaceholderType();\n  return false;\n}\n\ninline const BuiltinType *Type::getAsPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    if (BT->isPlaceholderType())\n      return BT;\n  return nullptr;\n}\n\ninline bool Type::isSpecificPlaceholderType(unsigned K) const {\n  assert(BuiltinType::isPlaceholderTypeKind((BuiltinType::Kind) K));\n  return isSpecificBuiltinType(K);\n}\n\ninline bool Type::isNonOverloadPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isNonOverloadPlaceholderType();\n  return false;\n}\n\ninline bool Type::isVoidType() const {\n  return isSpecificBuiltinType(BuiltinType::Void);\n}\n\ninline bool Type::isHalfType() const {\n  // FIXME: Should we allow complex __fp16? Probably not.\n  return isSpecificBuiltinType(BuiltinType::Half);\n}\n\ninline bool Type::isFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float16);\n}\n\ninline bool Type::isBFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::BFloat16);\n}\n\ninline bool Type::isFloat128Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float128);\n}\n\ninline bool Type::isNullPtrType() const {\n  return isSpecificBuiltinType(BuiltinType::NullPtr);\n}\n\nbool IsEnumDeclComplete(EnumDecl *);\nbool IsEnumDeclScoped(EnumDecl *);\n\ninline bool Type::isIntegerType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType)) {\n    // Incomplete enum types are not treated as integer types.\n    // FIXME: In C++, enum types are never integer types.\n    return IsEnumDeclComplete(ET->getDecl()) &&\n      !IsEnumDeclScoped(ET->getDecl());\n  }\n  return isExtIntType();\n}\n\ninline bool Type::isFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::ShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isFixedPointOrIntegerType() const {\n  return isFixedPointType() || isIntegerType();\n}\n\ninline bool Type::isSaturatedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::SatShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isUnsaturatedFixedPointType() const {\n  return isFixedPointType() && !isSaturatedFixedPointType();\n}\n\ninline bool Type::isSignedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return ((BT->getKind() >= BuiltinType::ShortAccum &&\n             BT->getKind() <= BuiltinType::LongAccum) ||\n            (BT->getKind() >= BuiltinType::ShortFract &&\n             BT->getKind() <= BuiltinType::LongFract) ||\n            (BT->getKind() >= BuiltinType::SatShortAccum &&\n             BT->getKind() <= BuiltinType::SatLongAccum) ||\n            (BT->getKind() >= BuiltinType::SatShortFract &&\n             BT->getKind() <= BuiltinType::SatLongFract));\n  }\n  return false;\n}\n\ninline bool Type::isUnsignedFixedPointType() const {\n  return isFixedPointType() && !isSignedFixedPointType();\n}\n\ninline bool Type::isScalarType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() > BuiltinType::Void &&\n           BT->getKind() <= BuiltinType::NullPtr;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType))\n    // Enums are scalar types, but only if they are defined.  Incomplete enums\n    // are not treated as scalar types.\n    return IsEnumDeclComplete(ET->getDecl());\n  return isa<PointerType>(CanonicalType) ||\n         isa<BlockPointerType>(CanonicalType) ||\n         isa<MemberPointerType>(CanonicalType) ||\n         isa<ComplexType>(CanonicalType) ||\n         isa<ObjCObjectPointerType>(CanonicalType) ||\n         isExtIntType();\n}\n\ninline bool Type::isIntegralOrEnumerationType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n\n  // Check for a complete enum type; incomplete enum types are not properly an\n  // enumeration type in the sense required here.\n  if (const auto *ET = dyn_cast<EnumType>(CanonicalType))\n    return IsEnumDeclComplete(ET->getDecl());\n\n  return isExtIntType();\n}\n\ninline bool Type::isBooleanType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() == BuiltinType::Bool;\n  return false;\n}\n\ninline bool Type::isUndeducedType() const {\n  auto *DT = getContainedDeducedType();\n  return DT && !DT->isDeduced();\n}\n\n/// Determines whether this is a type for which one can define\n/// an overloaded operator.\ninline bool Type::isOverloadableType() const {\n  return isDependentType() || isRecordType() || isEnumeralType();\n}\n\n/// Determines whether this type is written as a typedef-name.\ninline bool Type::isTypedefNameType() const {\n  if (getAs<TypedefType>())\n    return true;\n  if (auto *TST = getAs<TemplateSpecializationType>())\n    return TST->isTypeAlias();\n  return false;\n}\n\n/// Determines whether this type can decay to a pointer type.\ninline bool Type::canDecayToPointerType() const {\n  return isFunctionType() || isArrayType();\n}\n\ninline bool Type::hasPointerRepresentation() const {\n  return (isPointerType() || isReferenceType() || isBlockPointerType() ||\n          isObjCObjectPointerType() || isNullPtrType());\n}\n\ninline bool Type::hasObjCPointerRepresentation() const {\n  return isObjCObjectPointerType();\n}\n\ninline const Type *Type::getBaseElementTypeUnsafe() const {\n  const Type *type = this;\n  while (const ArrayType *arrayType = type->getAsArrayTypeUnsafe())\n    type = arrayType->getElementType().getTypePtr();\n  return type;\n}\n\ninline const Type *Type::getPointeeOrArrayElementType() const {\n  const Type *type = this;\n  if (type->isAnyPointerType())\n    return type->getPointeeType().getTypePtr();\n  else if (type->isArrayType())\n    return type->getBaseElementTypeUnsafe();\n  return type;\n}\n/// Insertion operator for partial diagnostics. This allows sending adress\n/// spaces into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             LangAS AS) {\n  PD.AddTaggedVal(static_cast<std::underlying_type_t<LangAS>>(AS),\n                  DiagnosticsEngine::ArgumentKind::ak_addrspace);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics. This allows sending Qualifiers\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             Qualifiers Q) {\n  PD.AddTaggedVal(Q.getAsOpaqueValue(),\n                  DiagnosticsEngine::ArgumentKind::ak_qual);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics.  This allows sending QualType's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             QualType T) {\n  PD.AddTaggedVal(reinterpret_cast<intptr_t>(T.getAsOpaquePtr()),\n                  DiagnosticsEngine::ak_qualtype);\n  return PD;\n}\n\n// Helper class template that is used by Type::getAs to ensure that one does\n// not try to look through a qualified type to get to an array type.\ntemplate <typename T>\nusing TypeIsArrayType =\n    std::integral_constant<bool, std::is_same<T, ArrayType>::value ||\n                                     std::is_base_of<ArrayType, T>::value>;\n\n// Member-template getAs<specific type>'.\ntemplate <typename T> const T *Type::getAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with getAs!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::getAsAdjusted() const {\n  static_assert(!TypeIsArrayType<T>::value, \"ArrayType cannot be used with getAsAdjusted!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // Strip off type adjustments that do not modify the underlying nature of the\n  // type.\n  const Type *Ty = this;\n  while (Ty) {\n    if (const auto *A = dyn_cast<AttributedType>(Ty))\n      Ty = A->getModifiedType().getTypePtr();\n    else if (const auto *E = dyn_cast<ElaboratedType>(Ty))\n      Ty = E->desugar().getTypePtr();\n    else if (const auto *P = dyn_cast<ParenType>(Ty))\n      Ty = P->desugar().getTypePtr();\n    else if (const auto *A = dyn_cast<AdjustedType>(Ty))\n      Ty = A->desugar().getTypePtr();\n    else if (const auto *M = dyn_cast<MacroQualifiedType>(Ty))\n      Ty = M->desugar().getTypePtr();\n    else\n      break;\n  }\n\n  // Just because the canonical type is correct does not mean we can use cast<>,\n  // since we may not have stripped off all the sugar down to the base type.\n  return dyn_cast<T>(Ty);\n}\n\ninline const ArrayType *Type::getAsArrayTypeUnsafe() const {\n  // If this is directly an array type, return it.\n  if (const auto *arr = dyn_cast<ArrayType>(this))\n    return arr;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<ArrayType>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::castAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with castAs!\");\n\n  if (const auto *ty = dyn_cast<T>(this)) return ty;\n  assert(isa<T>(CanonicalType));\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ninline const ArrayType *Type::castAsArrayTypeUnsafe() const {\n  assert(isa<ArrayType>(CanonicalType));\n  if (const auto *arr = dyn_cast<ArrayType>(this)) return arr;\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\nDecayedType::DecayedType(QualType OriginalType, QualType DecayedPtr,\n                         QualType CanonicalPtr)\n    : AdjustedType(Decayed, OriginalType, DecayedPtr, CanonicalPtr) {\n#ifndef NDEBUG\n  QualType Adjusted = getAdjustedType();\n  (void)AttributedType::stripOuterNullability(Adjusted);\n  assert(isa<PointerType>(Adjusted));\n#endif\n}\n\nQualType DecayedType::getPointeeType() const {\n  QualType Decayed = getDecayedType();\n  (void)AttributedType::stripOuterNullability(Decayed);\n  return cast<PointerType>(Decayed)->getPointeeType();\n}\n\n// Get the decimal string representation of a fixed point type, represented\n// as a scaled integer.\n// TODO: At some point, we should change the arguments to instead just accept an\n// APFixedPoint instead of APSInt and scale.\nvoid FixedPointValueToString(SmallVectorImpl<char> &Str, llvm::APSInt Val,\n                             unsigned Scale);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TYPE_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/UnresolvedSet.h", "content": "//===- UnresolvedSet.h - Unresolved sets of declarations --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the UnresolvedSet class, which is used to store\n//  collections of declarations in the AST.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_UNRESOLVEDSET_H\n#define LLVM_CLANG_AST_UNRESOLVEDSET_H\n\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include <cstddef>\n#include <iterator>\n\nnamespace clang {\n\nclass NamedDecl;\n\n/// The iterator over UnresolvedSets.  Serves as both the const and\n/// non-const iterator.\nclass UnresolvedSetIterator : public llvm::iterator_adaptor_base<\n                                  UnresolvedSetIterator, DeclAccessPair *,\n                                  std::random_access_iterator_tag, NamedDecl *,\n                                  std::ptrdiff_t, NamedDecl *, NamedDecl *> {\n  friend class ASTUnresolvedSet;\n  friend class OverloadExpr;\n  friend class UnresolvedSetImpl;\n\n  explicit UnresolvedSetIterator(DeclAccessPair *Iter)\n      : iterator_adaptor_base(Iter) {}\n  explicit UnresolvedSetIterator(const DeclAccessPair *Iter)\n      : iterator_adaptor_base(const_cast<DeclAccessPair *>(Iter)) {}\n\npublic:\n  // Work around a bug in MSVC 2013 where explicitly default constructed\n  // temporaries with defaulted ctors are not zero initialized.\n  UnresolvedSetIterator() : iterator_adaptor_base(nullptr) {}\n\n  NamedDecl *getDecl() const { return I->getDecl(); }\n  void setDecl(NamedDecl *ND) const { return I->setDecl(ND); }\n  AccessSpecifier getAccess() const { return I->getAccess(); }\n  void setAccess(AccessSpecifier AS) { I->setAccess(AS); }\n  const DeclAccessPair &getPair() const { return *I; }\n\n  NamedDecl *operator*() const { return getDecl(); }\n  NamedDecl *operator->() const { return **this; }\n};\n\n/// A set of unresolved declarations.\nclass UnresolvedSetImpl {\n  using DeclsTy = SmallVectorImpl<DeclAccessPair>;\n\n  // Don't allow direct construction, and only permit subclassing by\n  // UnresolvedSet.\nprivate:\n  template <unsigned N> friend class UnresolvedSet;\n\n  UnresolvedSetImpl() = default;\n  UnresolvedSetImpl(const UnresolvedSetImpl &) = default;\n  UnresolvedSetImpl &operator=(const UnresolvedSetImpl &) = default;\n\n  // FIXME: Switch these to \"= default\" once MSVC supports generating move ops\n  UnresolvedSetImpl(UnresolvedSetImpl &&) {}\n  UnresolvedSetImpl &operator=(UnresolvedSetImpl &&) { return *this; }\n\npublic:\n  // We don't currently support assignment through this iterator, so we might\n  // as well use the same implementation twice.\n  using iterator = UnresolvedSetIterator;\n  using const_iterator = UnresolvedSetIterator;\n\n  iterator begin() { return iterator(decls().begin()); }\n  iterator end() { return iterator(decls().end()); }\n\n  const_iterator begin() const { return const_iterator(decls().begin()); }\n  const_iterator end() const { return const_iterator(decls().end()); }\n\n  ArrayRef<DeclAccessPair> pairs() const { return decls(); }\n\n  void addDecl(NamedDecl *D) {\n    addDecl(D, AS_none);\n  }\n\n  void addDecl(NamedDecl *D, AccessSpecifier AS) {\n    decls().push_back(DeclAccessPair::make(D, AS));\n  }\n\n  /// Replaces the given declaration with the new one, once.\n  ///\n  /// \\return true if the set changed\n  bool replace(const NamedDecl* Old, NamedDecl *New) {\n    for (DeclsTy::iterator I = decls().begin(), E = decls().end(); I != E; ++I)\n      if (I->getDecl() == Old)\n        return (I->setDecl(New), true);\n    return false;\n  }\n\n  /// Replaces the declaration at the given iterator with the new one,\n  /// preserving the original access bits.\n  void replace(iterator I, NamedDecl *New) { I.I->setDecl(New); }\n\n  void replace(iterator I, NamedDecl *New, AccessSpecifier AS) {\n    I.I->set(New, AS);\n  }\n\n  void erase(unsigned I) { decls()[I] = decls().pop_back_val(); }\n\n  void erase(iterator I) { *I.I = decls().pop_back_val(); }\n\n  void setAccess(iterator I, AccessSpecifier AS) { I.I->setAccess(AS); }\n\n  void clear() { decls().clear(); }\n  void set_size(unsigned N) { decls().set_size(N); }\n\n  bool empty() const { return decls().empty(); }\n  unsigned size() const { return decls().size(); }\n\n  void append(iterator I, iterator E) { decls().append(I.I, E.I); }\n\n  template<typename Iter> void assign(Iter I, Iter E) { decls().assign(I, E); }\n\n  DeclAccessPair &operator[](unsigned I) { return decls()[I]; }\n  const DeclAccessPair &operator[](unsigned I) const { return decls()[I]; }\n\nprivate:\n  // These work because the only permitted subclass is UnresolvedSetImpl\n\n  DeclsTy &decls() {\n    return *reinterpret_cast<DeclsTy*>(this);\n  }\n  const DeclsTy &decls() const {\n    return *reinterpret_cast<const DeclsTy*>(this);\n  }\n};\n\n/// A set of unresolved declarations.\ntemplate <unsigned InlineCapacity> class UnresolvedSet :\n    public UnresolvedSetImpl {\n  SmallVector<DeclAccessPair, InlineCapacity> Decls;\n};\n\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_UNRESOLVEDSET_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "content": "//===- CFG.h - Classes for representing and building CFGs -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CFG and CFGBuilder classes for representing and\n//  building Control-Flow Graphs (CFGs) from ASTs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_CFG_H\n#define LLVM_CLANG_ANALYSIS_CFG_H\n\n#include \"clang/Analysis/Support/BumpVector.h\"\n#include \"clang/Analysis/ConstructionContext.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass BinaryOperator;\nclass CFG;\nclass CXXBaseSpecifier;\nclass CXXBindTemporaryExpr;\nclass CXXCtorInitializer;\nclass CXXDeleteExpr;\nclass CXXDestructorDecl;\nclass CXXNewExpr;\nclass CXXRecordDecl;\nclass Decl;\nclass FieldDecl;\nclass LangOptions;\nclass VarDecl;\n\n/// Represents a top-level expression in a basic block.\nclass CFGElement {\npublic:\n  enum Kind {\n    // main kind\n    Initializer,\n    ScopeBegin,\n    ScopeEnd,\n    NewAllocator,\n    LifetimeEnds,\n    LoopExit,\n    // stmt kind\n    Statement,\n    Constructor,\n    CXXRecordTypedCall,\n    STMT_BEGIN = Statement,\n    STMT_END = CXXRecordTypedCall,\n    // dtor kind\n    AutomaticObjectDtor,\n    DeleteDtor,\n    BaseDtor,\n    MemberDtor,\n    TemporaryDtor,\n    DTOR_BEGIN = AutomaticObjectDtor,\n    DTOR_END = TemporaryDtor\n  };\n\nprotected:\n  // The int bits are used to mark the kind.\n  llvm::PointerIntPair<void *, 2> Data1;\n  llvm::PointerIntPair<void *, 2> Data2;\n\n  CFGElement(Kind kind, const void *Ptr1, const void *Ptr2 = nullptr)\n      : Data1(const_cast<void*>(Ptr1), ((unsigned) kind) & 0x3),\n        Data2(const_cast<void*>(Ptr2), (((unsigned) kind) >> 2) & 0x3) {\n    assert(getKind() == kind);\n  }\n\n  CFGElement() = default;\n\npublic:\n  /// Convert to the specified CFGElement type, asserting that this\n  /// CFGElement is of the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    CFGElement& e = t;\n    e = *this;\n    return t;\n  }\n\n  /// Convert to the specified CFGElement type, returning None if this\n  /// CFGElement is not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    T t;\n    CFGElement& e = t;\n    e = *this;\n    return t;\n  }\n\n  Kind getKind() const {\n    unsigned x = Data2.getInt();\n    x <<= 2;\n    x |= Data1.getInt();\n    return (Kind) x;\n  }\n\n  void dumpToStream(llvm::raw_ostream &OS) const;\n\n  void dump() const {\n    dumpToStream(llvm::errs());\n  }\n};\n\nclass CFGStmt : public CFGElement {\npublic:\n  explicit CFGStmt(Stmt *S, Kind K = Statement) : CFGElement(K, S) {\n    assert(isKind(*this));\n  }\n\n  const Stmt *getStmt() const {\n    return static_cast<const Stmt *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() >= STMT_BEGIN && E.getKind() <= STMT_END;\n  }\n\nprotected:\n  CFGStmt() = default;\n};\n\n/// Represents C++ constructor call. Maintains information necessary to figure\n/// out what memory is being initialized by the constructor expression. For now\n/// this is only used by the analyzer's CFG.\nclass CFGConstructor : public CFGStmt {\npublic:\n  explicit CFGConstructor(CXXConstructExpr *CE, const ConstructionContext *C)\n      : CFGStmt(CE, Constructor) {\n    assert(C);\n    Data2.setPointer(const_cast<ConstructionContext *>(C));\n  }\n\n  const ConstructionContext *getConstructionContext() const {\n    return static_cast<ConstructionContext *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGConstructor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == Constructor;\n  }\n};\n\n/// Represents a function call that returns a C++ object by value. This, like\n/// constructor, requires a construction context in order to understand the\n/// storage of the returned object . In C such tracking is not necessary because\n/// no additional effort is required for destroying the object or modeling copy\n/// elision. Like CFGConstructor, this element is for now only used by the\n/// analyzer's CFG.\nclass CFGCXXRecordTypedCall : public CFGStmt {\npublic:\n  /// Returns true when call expression \\p CE needs to be represented\n  /// by CFGCXXRecordTypedCall, as opposed to a regular CFGStmt.\n  static bool isCXXRecordTypedCall(Expr *E) {\n    assert(isa<CallExpr>(E) || isa<ObjCMessageExpr>(E));\n    // There is no such thing as reference-type expression. If the function\n    // returns a reference, it'll return the respective lvalue or xvalue\n    // instead, and we're only interested in objects.\n    return !E->isGLValue() &&\n           E->getType().getCanonicalType()->getAsCXXRecordDecl();\n  }\n\n  explicit CFGCXXRecordTypedCall(Expr *E, const ConstructionContext *C)\n      : CFGStmt(E, CXXRecordTypedCall) {\n    assert(isCXXRecordTypedCall(E));\n    assert(C && (isa<TemporaryObjectConstructionContext>(C) ||\n                 // These are possible in C++17 due to mandatory copy elision.\n                 isa<ReturnedValueConstructionContext>(C) ||\n                 isa<VariableConstructionContext>(C) ||\n                 isa<ConstructorInitializerConstructionContext>(C) ||\n                 isa<ArgumentConstructionContext>(C)));\n    Data2.setPointer(const_cast<ConstructionContext *>(C));\n  }\n\n  const ConstructionContext *getConstructionContext() const {\n    return static_cast<ConstructionContext *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGCXXRecordTypedCall() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == CXXRecordTypedCall;\n  }\n};\n\n/// Represents C++ base or member initializer from constructor's initialization\n/// list.\nclass CFGInitializer : public CFGElement {\npublic:\n  explicit CFGInitializer(CXXCtorInitializer *initializer)\n      : CFGElement(Initializer, initializer) {}\n\n  CXXCtorInitializer* getInitializer() const {\n    return static_cast<CXXCtorInitializer*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGInitializer() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == Initializer;\n  }\n};\n\n/// Represents C++ allocator call.\nclass CFGNewAllocator : public CFGElement {\npublic:\n  explicit CFGNewAllocator(const CXXNewExpr *S)\n    : CFGElement(NewAllocator, S) {}\n\n  // Get the new expression.\n  const CXXNewExpr *getAllocatorExpr() const {\n    return static_cast<CXXNewExpr *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGNewAllocator() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == NewAllocator;\n  }\n};\n\n/// Represents the point where a loop ends.\n/// This element is is only produced when building the CFG for the static\n/// analyzer and hidden behind the 'cfg-loopexit' analyzer config flag.\n///\n/// Note: a loop exit element can be reached even when the loop body was never\n/// entered.\nclass CFGLoopExit : public CFGElement {\npublic:\n  explicit CFGLoopExit(const Stmt *stmt) : CFGElement(LoopExit, stmt) {}\n\n  const Stmt *getLoopStmt() const {\n    return static_cast<Stmt *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGLoopExit() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == LoopExit;\n  }\n};\n\n/// Represents the point where the lifetime of an automatic object ends\nclass CFGLifetimeEnds : public CFGElement {\npublic:\n  explicit CFGLifetimeEnds(const VarDecl *var, const Stmt *stmt)\n      : CFGElement(LifetimeEnds, var, stmt) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGLifetimeEnds() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == LifetimeEnds;\n  }\n};\n\n/// Represents beginning of a scope implicitly generated\n/// by the compiler on encountering a CompoundStmt\nclass CFGScopeBegin : public CFGElement {\npublic:\n  CFGScopeBegin() {}\n  CFGScopeBegin(const VarDecl *VD, const Stmt *S)\n      : CFGElement(ScopeBegin, VD, S) {}\n\n  // Get statement that triggered a new scope.\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt*>(Data2.getPointer());\n  }\n\n  // Get VD that triggered a new scope.\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind == ScopeBegin;\n  }\n};\n\n/// Represents end of a scope implicitly generated by\n/// the compiler after the last Stmt in a CompoundStmt's body\nclass CFGScopeEnd : public CFGElement {\npublic:\n  CFGScopeEnd() {}\n  CFGScopeEnd(const VarDecl *VD, const Stmt *S) : CFGElement(ScopeEnd, VD, S) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind == ScopeEnd;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated by compiler on various\n/// occasions.\nclass CFGImplicitDtor : public CFGElement {\nprotected:\n  CFGImplicitDtor() = default;\n\n  CFGImplicitDtor(Kind kind, const void *data1, const void *data2 = nullptr)\n    : CFGElement(kind, data1, data2) {\n    assert(kind >= DTOR_BEGIN && kind <= DTOR_END);\n  }\n\npublic:\n  const CXXDestructorDecl *getDestructorDecl(ASTContext &astContext) const;\n  bool isNoReturn(ASTContext &astContext) const;\n\nprivate:\n  friend class CFGElement;\n\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind >= DTOR_BEGIN && kind <= DTOR_END;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for automatic object\n/// or temporary bound to const reference at the point of leaving its local\n/// scope.\nclass CFGAutomaticObjDtor: public CFGImplicitDtor {\npublic:\n  CFGAutomaticObjDtor(const VarDecl *var, const Stmt *stmt)\n      : CFGImplicitDtor(AutomaticObjectDtor, var, stmt) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl*>(Data1.getPointer());\n  }\n\n  // Get statement end of which triggered the destructor call.\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt*>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGAutomaticObjDtor() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == AutomaticObjectDtor;\n  }\n};\n\n/// Represents C++ object destructor generated from a call to delete.\nclass CFGDeleteDtor : public CFGImplicitDtor {\npublic:\n  CFGDeleteDtor(const CXXRecordDecl *RD, const CXXDeleteExpr *DE)\n      : CFGImplicitDtor(DeleteDtor, RD, DE) {}\n\n  const CXXRecordDecl *getCXXRecordDecl() const {\n    return static_cast<CXXRecordDecl*>(Data1.getPointer());\n  }\n\n  // Get Delete expression which triggered the destructor call.\n  const CXXDeleteExpr *getDeleteExpr() const {\n    return static_cast<CXXDeleteExpr *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGDeleteDtor() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == DeleteDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for base object in\n/// destructor.\nclass CFGBaseDtor : public CFGImplicitDtor {\npublic:\n  CFGBaseDtor(const CXXBaseSpecifier *base)\n      : CFGImplicitDtor(BaseDtor, base) {}\n\n  const CXXBaseSpecifier *getBaseSpecifier() const {\n    return static_cast<const CXXBaseSpecifier*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGBaseDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == BaseDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for member object in\n/// destructor.\nclass CFGMemberDtor : public CFGImplicitDtor {\npublic:\n  CFGMemberDtor(const FieldDecl *field)\n      : CFGImplicitDtor(MemberDtor, field, nullptr) {}\n\n  const FieldDecl *getFieldDecl() const {\n    return static_cast<const FieldDecl*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGMemberDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == MemberDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated at the end of full\n/// expression for temporary object.\nclass CFGTemporaryDtor : public CFGImplicitDtor {\npublic:\n  CFGTemporaryDtor(CXXBindTemporaryExpr *expr)\n      : CFGImplicitDtor(TemporaryDtor, expr, nullptr) {}\n\n  const CXXBindTemporaryExpr *getBindTemporaryExpr() const {\n    return static_cast<const CXXBindTemporaryExpr *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGTemporaryDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == TemporaryDtor;\n  }\n};\n\n/// Represents CFGBlock terminator statement.\n///\nclass CFGTerminator {\npublic:\n  enum Kind {\n    /// A branch that corresponds to a statement in the code,\n    /// such as an if-statement.\n    StmtBranch,\n    /// A branch in control flow of destructors of temporaries. In this case\n    /// terminator statement is the same statement that branches control flow\n    /// in evaluation of matching full expression.\n    TemporaryDtorsBranch,\n    /// A shortcut around virtual base initializers. It gets taken when\n    /// virtual base classes have already been initialized by the constructor\n    /// of the most derived class while we're in the base class.\n    VirtualBaseBranch,\n\n    /// Number of different kinds, for sanity checks. We subtract 1 so that\n    /// to keep receiving compiler warnings when we don't cover all enum values\n    /// in a switch.\n    NumKindsMinusOne = VirtualBaseBranch\n  };\n\nprivate:\n  static constexpr int KindBits = 2;\n  static_assert((1 << KindBits) > NumKindsMinusOne,\n                \"Not enough room for kind!\");\n  llvm::PointerIntPair<Stmt *, KindBits> Data;\n\npublic:\n  CFGTerminator() { assert(!isValid()); }\n  CFGTerminator(Stmt *S, Kind K = StmtBranch) : Data(S, K) {}\n\n  bool isValid() const { return Data.getOpaqueValue() != nullptr; }\n  Stmt *getStmt() { return Data.getPointer(); }\n  const Stmt *getStmt() const { return Data.getPointer(); }\n  Kind getKind() const { return static_cast<Kind>(Data.getInt()); }\n\n  bool isStmtBranch() const {\n    return getKind() == StmtBranch;\n  }\n  bool isTemporaryDtorsBranch() const {\n    return getKind() == TemporaryDtorsBranch;\n  }\n  bool isVirtualBaseBranch() const {\n    return getKind() == VirtualBaseBranch;\n  }\n};\n\n/// Represents a single basic block in a source-level CFG.\n///  It consists of:\n///\n///  (1) A set of statements/expressions (which may contain subexpressions).\n///  (2) A \"terminator\" statement (not in the set of statements).\n///  (3) A list of successors and predecessors.\n///\n/// Terminator: The terminator represents the type of control-flow that occurs\n/// at the end of the basic block.  The terminator is a Stmt* referring to an\n/// AST node that has control-flow: if-statements, breaks, loops, etc.\n/// If the control-flow is conditional, the condition expression will appear\n/// within the set of statements in the block (usually the last statement).\n///\n/// Predecessors: the order in the set of predecessors is arbitrary.\n///\n/// Successors: the order in the set of successors is NOT arbitrary.  We\n///  currently have the following orderings based on the terminator:\n///\n///     Terminator     |   Successor Ordering\n///  ------------------|------------------------------------\n///       if           |  Then Block;  Else Block\n///     ? operator     |  LHS expression;  RHS expression\n///     logical and/or |  expression that consumes the op, RHS\n///     vbase inits    |  already handled by the most derived class; not yet\n///\n/// But note that any of that may be NULL in case of optimized-out edges.\nclass CFGBlock {\n  class ElementList {\n    using ImplTy = BumpVector<CFGElement>;\n\n    ImplTy Impl;\n\n  public:\n    ElementList(BumpVectorContext &C) : Impl(C, 4) {}\n\n    using iterator = std::reverse_iterator<ImplTy::iterator>;\n    using const_iterator = std::reverse_iterator<ImplTy::const_iterator>;\n    using reverse_iterator = ImplTy::iterator;\n    using const_reverse_iterator = ImplTy::const_iterator;\n    using const_reference = ImplTy::const_reference;\n\n    void push_back(CFGElement e, BumpVectorContext &C) { Impl.push_back(e, C); }\n\n    reverse_iterator insert(reverse_iterator I, size_t Cnt, CFGElement E,\n        BumpVectorContext &C) {\n      return Impl.insert(I, Cnt, E, C);\n    }\n\n    const_reference front() const { return Impl.back(); }\n    const_reference back() const { return Impl.front(); }\n\n    iterator begin() { return Impl.rbegin(); }\n    iterator end() { return Impl.rend(); }\n    const_iterator begin() const { return Impl.rbegin(); }\n    const_iterator end() const { return Impl.rend(); }\n    reverse_iterator rbegin() { return Impl.begin(); }\n    reverse_iterator rend() { return Impl.end(); }\n    const_reverse_iterator rbegin() const { return Impl.begin(); }\n    const_reverse_iterator rend() const { return Impl.end(); }\n\n    CFGElement operator[](size_t i) const  {\n      assert(i < Impl.size());\n      return Impl[Impl.size() - 1 - i];\n    }\n\n    size_t size() const { return Impl.size(); }\n    bool empty() const { return Impl.empty(); }\n  };\n\n  /// A convenience class for comparing CFGElements, since methods of CFGBlock\n  /// like operator[] return CFGElements by value. This is practically a wrapper\n  /// around a (CFGBlock, Index) pair.\n  template <bool IsConst> class ElementRefImpl {\n\n    template <bool IsOtherConst> friend class ElementRefImpl;\n\n    using CFGBlockPtr =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using CFGElementPtr =\n        std::conditional_t<IsConst, const CFGElement *, CFGElement *>;\n\n  protected:\n    CFGBlockPtr Parent;\n    size_t Index;\n\n  public:\n    ElementRefImpl(CFGBlockPtr Parent, size_t Index)\n        : Parent(Parent), Index(Index) {}\n\n    template <bool IsOtherConst>\n    ElementRefImpl(ElementRefImpl<IsOtherConst> Other)\n        : ElementRefImpl(Other.Parent, Other.Index) {}\n\n    size_t getIndexInBlock() const { return Index; }\n\n    CFGBlockPtr getParent() { return Parent; }\n    CFGBlockPtr getParent() const { return Parent; }\n\n    bool operator<(ElementRefImpl Other) const {\n      return std::make_pair(Parent, Index) <\n             std::make_pair(Other.Parent, Other.Index);\n    }\n\n    bool operator==(ElementRefImpl Other) const {\n      return Parent == Other.Parent && Index == Other.Index;\n    }\n\n    bool operator!=(ElementRefImpl Other) const { return !(*this == Other); }\n    CFGElement operator*() const { return (*Parent)[Index]; }\n    CFGElementPtr operator->() const { return &*(Parent->begin() + Index); }\n\n    void dumpToStream(llvm::raw_ostream &OS) const {\n      OS << getIndexInBlock() + 1 << \": \";\n      (*this)->dumpToStream(OS);\n    }\n\n    void dump() const {\n      dumpToStream(llvm::errs());\n    }\n  };\n\n  template <bool IsReverse, bool IsConst> class ElementRefIterator {\n\n    template <bool IsOtherReverse, bool IsOtherConst>\n    friend class ElementRefIterator;\n\n    using CFGBlockRef =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using UnderlayingIteratorTy = std::conditional_t<\n        IsConst,\n        std::conditional_t<IsReverse, ElementList::const_reverse_iterator,\n                           ElementList::const_iterator>,\n        std::conditional_t<IsReverse, ElementList::reverse_iterator,\n                           ElementList::iterator>>;\n\n    using IteratorTraits = typename std::iterator_traits<UnderlayingIteratorTy>;\n    using ElementRef = typename CFGBlock::ElementRefImpl<IsConst>;\n\n  public:\n    using difference_type = typename IteratorTraits::difference_type;\n    using value_type = ElementRef;\n    using pointer = ElementRef *;\n    using iterator_category = typename IteratorTraits::iterator_category;\n\n  private:\n    CFGBlockRef Parent;\n    UnderlayingIteratorTy Pos;\n\n  public:\n    ElementRefIterator(CFGBlockRef Parent, UnderlayingIteratorTy Pos)\n        : Parent(Parent), Pos(Pos) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<false, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, E.Pos.base()) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<true, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, llvm::make_reverse_iterator(E.Pos)) {}\n\n    bool operator<(ElementRefIterator Other) const {\n      assert(Parent == Other.Parent);\n      return Pos < Other.Pos;\n    }\n\n    bool operator==(ElementRefIterator Other) const {\n      return Parent == Other.Parent && Pos == Other.Pos;\n    }\n\n    bool operator!=(ElementRefIterator Other) const {\n      return !(*this == Other);\n    }\n\n  private:\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<true, IsOtherConst> E) {\n      return E.Parent->size() - (E.Pos - E.Parent->rbegin()) - 1;\n    }\n\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<false, IsOtherConst> E) {\n      return E.Pos - E.Parent->begin();\n    }\n\n  public:\n    value_type operator*() { return {Parent, getIndexInBlock(*this)}; }\n\n    difference_type operator-(ElementRefIterator Other) const {\n      return Pos - Other.Pos;\n    }\n\n    ElementRefIterator operator++() {\n      ++this->Pos;\n      return *this;\n    }\n    ElementRefIterator operator++(int) {\n      ElementRefIterator Ret = *this;\n      ++*this;\n      return Ret;\n    }\n    ElementRefIterator operator+(size_t count) {\n      this->Pos += count;\n      return *this;\n    }\n    ElementRefIterator operator-(size_t count) {\n      this->Pos -= count;\n      return *this;\n    }\n  };\n\npublic:\n  /// The set of statements in the basic block.\n  ElementList Elements;\n\n  /// An (optional) label that prefixes the executable statements in the block.\n  /// When this variable is non-NULL, it is either an instance of LabelStmt,\n  /// SwitchCase or CXXCatchStmt.\n  Stmt *Label = nullptr;\n\n  /// The terminator for a basic block that indicates the type of control-flow\n  /// that occurs between a block and its successors.\n  CFGTerminator Terminator;\n\n  /// Some blocks are used to represent the \"loop edge\" to the start of a loop\n  /// from within the loop body. This Stmt* will be refer to the loop statement\n  /// for such blocks (and be null otherwise).\n  const Stmt *LoopTarget = nullptr;\n\n  /// A numerical ID assigned to a CFGBlock during construction of the CFG.\n  unsigned BlockID;\n\npublic:\n  /// This class represents a potential adjacent block in the CFG.  It encodes\n  /// whether or not the block is actually reachable, or can be proved to be\n  /// trivially unreachable.  For some cases it allows one to encode scenarios\n  /// where a block was substituted because the original (now alternate) block\n  /// is unreachable.\n  class AdjacentBlock {\n    enum Kind {\n      AB_Normal,\n      AB_Unreachable,\n      AB_Alternate\n    };\n\n    CFGBlock *ReachableBlock;\n    llvm::PointerIntPair<CFGBlock *, 2> UnreachableBlock;\n\n  public:\n    /// Construct an AdjacentBlock with a possibly unreachable block.\n    AdjacentBlock(CFGBlock *B, bool IsReachable);\n\n    /// Construct an AdjacentBlock with a reachable block and an alternate\n    /// unreachable block.\n    AdjacentBlock(CFGBlock *B, CFGBlock *AlternateBlock);\n\n    /// Get the reachable block, if one exists.\n    CFGBlock *getReachableBlock() const {\n      return ReachableBlock;\n    }\n\n    /// Get the potentially unreachable block.\n    CFGBlock *getPossiblyUnreachableBlock() const {\n      return UnreachableBlock.getPointer();\n    }\n\n    /// Provide an implicit conversion to CFGBlock* so that\n    /// AdjacentBlock can be substituted for CFGBlock*.\n    operator CFGBlock*() const {\n      return getReachableBlock();\n    }\n\n    CFGBlock& operator *() const {\n      return *getReachableBlock();\n    }\n\n    CFGBlock* operator ->() const {\n      return getReachableBlock();\n    }\n\n    bool isReachable() const {\n      Kind K = (Kind) UnreachableBlock.getInt();\n      return K == AB_Normal || K == AB_Alternate;\n    }\n  };\n\nprivate:\n  /// Keep track of the predecessor / successor CFG blocks.\n  using AdjacentBlocks = BumpVector<AdjacentBlock>;\n  AdjacentBlocks Preds;\n  AdjacentBlocks Succs;\n\n  /// This bit is set when the basic block contains a function call\n  /// or implicit destructor that is attributed as 'noreturn'. In that case,\n  /// control cannot technically ever proceed past this block. All such blocks\n  /// will have a single immediate successor: the exit block. This allows them\n  /// to be easily reached from the exit block and using this bit quickly\n  /// recognized without scanning the contents of the block.\n  ///\n  /// Optimization Note: This bit could be profitably folded with Terminator's\n  /// storage if the memory usage of CFGBlock becomes an issue.\n  unsigned HasNoReturnElement : 1;\n\n  /// The parent CFG that owns this CFGBlock.\n  CFG *Parent;\n\npublic:\n  explicit CFGBlock(unsigned blockid, BumpVectorContext &C, CFG *parent)\n      : Elements(C), Terminator(nullptr), BlockID(blockid), Preds(C, 1),\n        Succs(C, 1), HasNoReturnElement(false), Parent(parent) {}\n\n  // Statement iterators\n  using iterator = ElementList::iterator;\n  using const_iterator = ElementList::const_iterator;\n  using reverse_iterator = ElementList::reverse_iterator;\n  using const_reverse_iterator = ElementList::const_reverse_iterator;\n\n  size_t getIndexInCFG() const;\n\n  CFGElement                 front()       const { return Elements.front();   }\n  CFGElement                 back()        const { return Elements.back();    }\n\n  iterator                   begin()             { return Elements.begin();   }\n  iterator                   end()               { return Elements.end();     }\n  const_iterator             begin()       const { return Elements.begin();   }\n  const_iterator             end()         const { return Elements.end();     }\n\n  reverse_iterator           rbegin()            { return Elements.rbegin();  }\n  reverse_iterator           rend()              { return Elements.rend();    }\n  const_reverse_iterator     rbegin()      const { return Elements.rbegin();  }\n  const_reverse_iterator     rend()        const { return Elements.rend();    }\n\n  using CFGElementRef = ElementRefImpl<false>;\n  using ConstCFGElementRef = ElementRefImpl<true>;\n\n  using ref_iterator = ElementRefIterator<false, false>;\n  using ref_iterator_range = llvm::iterator_range<ref_iterator>;\n  using const_ref_iterator = ElementRefIterator<false, true>;\n  using const_ref_iterator_range = llvm::iterator_range<const_ref_iterator>;\n\n  using reverse_ref_iterator = ElementRefIterator<true, false>;\n  using reverse_ref_iterator_range = llvm::iterator_range<reverse_ref_iterator>;\n\n  using const_reverse_ref_iterator = ElementRefIterator<true, true>;\n  using const_reverse_ref_iterator_range =\n      llvm::iterator_range<const_reverse_ref_iterator>;\n\n  ref_iterator ref_begin() { return {this, begin()}; }\n  ref_iterator ref_end() { return {this, end()}; }\n  const_ref_iterator ref_begin() const { return {this, begin()}; }\n  const_ref_iterator ref_end() const { return {this, end()}; }\n\n  reverse_ref_iterator rref_begin() { return {this, rbegin()}; }\n  reverse_ref_iterator rref_end() { return {this, rend()}; }\n  const_reverse_ref_iterator rref_begin() const { return {this, rbegin()}; }\n  const_reverse_ref_iterator rref_end() const { return {this, rend()}; }\n\n  ref_iterator_range refs() { return {ref_begin(), ref_end()}; }\n  const_ref_iterator_range refs() const { return {ref_begin(), ref_end()}; }\n  reverse_ref_iterator_range rrefs() { return {rref_begin(), rref_end()}; }\n  const_reverse_ref_iterator_range rrefs() const {\n    return {rref_begin(), rref_end()};\n  }\n\n  unsigned                   size()        const { return Elements.size();    }\n  bool                       empty()       const { return Elements.empty();   }\n\n  CFGElement operator[](size_t i) const  { return Elements[i]; }\n\n  // CFG iterators\n  using pred_iterator = AdjacentBlocks::iterator;\n  using const_pred_iterator = AdjacentBlocks::const_iterator;\n  using pred_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_pred_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using pred_range = llvm::iterator_range<pred_iterator>;\n  using pred_const_range = llvm::iterator_range<const_pred_iterator>;\n\n  using succ_iterator = AdjacentBlocks::iterator;\n  using const_succ_iterator = AdjacentBlocks::const_iterator;\n  using succ_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_succ_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using succ_range = llvm::iterator_range<succ_iterator>;\n  using succ_const_range = llvm::iterator_range<const_succ_iterator>;\n\n  pred_iterator                pred_begin()        { return Preds.begin();   }\n  pred_iterator                pred_end()          { return Preds.end();     }\n  const_pred_iterator          pred_begin()  const { return Preds.begin();   }\n  const_pred_iterator          pred_end()    const { return Preds.end();     }\n\n  pred_reverse_iterator        pred_rbegin()       { return Preds.rbegin();  }\n  pred_reverse_iterator        pred_rend()         { return Preds.rend();    }\n  const_pred_reverse_iterator  pred_rbegin() const { return Preds.rbegin();  }\n  const_pred_reverse_iterator  pred_rend()   const { return Preds.rend();    }\n\n  pred_range preds() {\n    return pred_range(pred_begin(), pred_end());\n  }\n\n  pred_const_range preds() const {\n    return pred_const_range(pred_begin(), pred_end());\n  }\n\n  succ_iterator                succ_begin()        { return Succs.begin();   }\n  succ_iterator                succ_end()          { return Succs.end();     }\n  const_succ_iterator          succ_begin()  const { return Succs.begin();   }\n  const_succ_iterator          succ_end()    const { return Succs.end();     }\n\n  succ_reverse_iterator        succ_rbegin()       { return Succs.rbegin();  }\n  succ_reverse_iterator        succ_rend()         { return Succs.rend();    }\n  const_succ_reverse_iterator  succ_rbegin() const { return Succs.rbegin();  }\n  const_succ_reverse_iterator  succ_rend()   const { return Succs.rend();    }\n\n  succ_range succs() {\n    return succ_range(succ_begin(), succ_end());\n  }\n\n  succ_const_range succs() const {\n    return succ_const_range(succ_begin(), succ_end());\n  }\n\n  unsigned                     succ_size()   const { return Succs.size();    }\n  bool                         succ_empty()  const { return Succs.empty();   }\n\n  unsigned                     pred_size()   const { return Preds.size();    }\n  bool                         pred_empty()  const { return Preds.empty();   }\n\n\n  class FilterOptions {\n  public:\n    unsigned IgnoreNullPredecessors : 1;\n    unsigned IgnoreDefaultsWithCoveredEnums : 1;\n\n    FilterOptions()\n        : IgnoreNullPredecessors(1), IgnoreDefaultsWithCoveredEnums(0) {}\n  };\n\n  static bool FilterEdge(const FilterOptions &F, const CFGBlock *Src,\n       const CFGBlock *Dst);\n\n  template <typename IMPL, bool IsPred>\n  class FilteredCFGBlockIterator {\n  private:\n    IMPL I, E;\n    const FilterOptions F;\n    const CFGBlock *From;\n\n  public:\n    explicit FilteredCFGBlockIterator(const IMPL &i, const IMPL &e,\n                                      const CFGBlock *from,\n                                      const FilterOptions &f)\n        : I(i), E(e), F(f), From(from) {\n      while (hasMore() && Filter(*I))\n        ++I;\n    }\n\n    bool hasMore() const { return I != E; }\n\n    FilteredCFGBlockIterator &operator++() {\n      do { ++I; } while (hasMore() && Filter(*I));\n      return *this;\n    }\n\n    const CFGBlock *operator*() const { return *I; }\n\n  private:\n    bool Filter(const CFGBlock *To) {\n      return IsPred ? FilterEdge(F, To, From) : FilterEdge(F, From, To);\n    }\n  };\n\n  using filtered_pred_iterator =\n      FilteredCFGBlockIterator<const_pred_iterator, true>;\n\n  using filtered_succ_iterator =\n      FilteredCFGBlockIterator<const_succ_iterator, false>;\n\n  filtered_pred_iterator filtered_pred_start_end(const FilterOptions &f) const {\n    return filtered_pred_iterator(pred_begin(), pred_end(), this, f);\n  }\n\n  filtered_succ_iterator filtered_succ_start_end(const FilterOptions &f) const {\n    return filtered_succ_iterator(succ_begin(), succ_end(), this, f);\n  }\n\n  // Manipulation of block contents\n\n  void setTerminator(CFGTerminator Term) { Terminator = Term; }\n  void setLabel(Stmt *Statement) { Label = Statement; }\n  void setLoopTarget(const Stmt *loopTarget) { LoopTarget = loopTarget; }\n  void setHasNoReturnElement() { HasNoReturnElement = true; }\n\n  /// Returns true if the block would eventually end with a sink (a noreturn\n  /// node).\n  bool isInevitablySinking() const;\n\n  CFGTerminator getTerminator() const { return Terminator; }\n\n  Stmt *getTerminatorStmt() { return Terminator.getStmt(); }\n  const Stmt *getTerminatorStmt() const { return Terminator.getStmt(); }\n\n  /// \\returns the last (\\c rbegin()) condition, e.g. observe the following code\n  /// snippet:\n  ///   if (A && B && C)\n  /// A block would be created for \\c A, \\c B, and \\c C. For the latter,\n  /// \\c getTerminatorStmt() would retrieve the entire condition, rather than\n  /// C itself, while this method would only return C.\n  const Expr *getLastCondition() const;\n\n  Stmt *getTerminatorCondition(bool StripParens = true);\n\n  const Stmt *getTerminatorCondition(bool StripParens = true) const {\n    return const_cast<CFGBlock*>(this)->getTerminatorCondition(StripParens);\n  }\n\n  const Stmt *getLoopTarget() const { return LoopTarget; }\n\n  Stmt *getLabel() { return Label; }\n  const Stmt *getLabel() const { return Label; }\n\n  bool hasNoReturnElement() const { return HasNoReturnElement; }\n\n  unsigned getBlockID() const { return BlockID; }\n\n  CFG *getParent() const { return Parent; }\n\n  void dump() const;\n\n  void dump(const CFG *cfg, const LangOptions &LO, bool ShowColors = false) const;\n  void print(raw_ostream &OS, const CFG* cfg, const LangOptions &LO,\n             bool ShowColors) const;\n\n  void printTerminator(raw_ostream &OS, const LangOptions &LO) const;\n  void printTerminatorJson(raw_ostream &Out, const LangOptions &LO,\n                           bool AddQuotes) const;\n\n  void printAsOperand(raw_ostream &OS, bool /*PrintType*/) {\n    OS << \"BB#\" << getBlockID();\n  }\n\n  /// Adds a (potentially unreachable) successor block to the current block.\n  void addSuccessor(AdjacentBlock Succ, BumpVectorContext &C);\n\n  void appendStmt(Stmt *statement, BumpVectorContext &C) {\n    Elements.push_back(CFGStmt(statement), C);\n  }\n\n  void appendConstructor(CXXConstructExpr *CE, const ConstructionContext *CC,\n                         BumpVectorContext &C) {\n    Elements.push_back(CFGConstructor(CE, CC), C);\n  }\n\n  void appendCXXRecordTypedCall(Expr *E,\n                                const ConstructionContext *CC,\n                                BumpVectorContext &C) {\n    Elements.push_back(CFGCXXRecordTypedCall(E, CC), C);\n  }\n\n  void appendInitializer(CXXCtorInitializer *initializer,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGInitializer(initializer), C);\n  }\n\n  void appendNewAllocator(CXXNewExpr *NE,\n                          BumpVectorContext &C) {\n    Elements.push_back(CFGNewAllocator(NE), C);\n  }\n\n  void appendScopeBegin(const VarDecl *VD, const Stmt *S,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGScopeBegin(VD, S), C);\n  }\n\n  void prependScopeBegin(const VarDecl *VD, const Stmt *S,\n                         BumpVectorContext &C) {\n    Elements.insert(Elements.rbegin(), 1, CFGScopeBegin(VD, S), C);\n  }\n\n  void appendScopeEnd(const VarDecl *VD, const Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGScopeEnd(VD, S), C);\n  }\n\n  void prependScopeEnd(const VarDecl *VD, const Stmt *S, BumpVectorContext &C) {\n    Elements.insert(Elements.rbegin(), 1, CFGScopeEnd(VD, S), C);\n  }\n\n  void appendBaseDtor(const CXXBaseSpecifier *BS, BumpVectorContext &C) {\n    Elements.push_back(CFGBaseDtor(BS), C);\n  }\n\n  void appendMemberDtor(FieldDecl *FD, BumpVectorContext &C) {\n    Elements.push_back(CFGMemberDtor(FD), C);\n  }\n\n  void appendTemporaryDtor(CXXBindTemporaryExpr *E, BumpVectorContext &C) {\n    Elements.push_back(CFGTemporaryDtor(E), C);\n  }\n\n  void appendAutomaticObjDtor(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGAutomaticObjDtor(VD, S), C);\n  }\n\n  void appendLifetimeEnds(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGLifetimeEnds(VD, S), C);\n  }\n\n  void appendLoopExit(const Stmt *LoopStmt, BumpVectorContext &C) {\n    Elements.push_back(CFGLoopExit(LoopStmt), C);\n  }\n\n  void appendDeleteDtor(CXXRecordDecl *RD, CXXDeleteExpr *DE, BumpVectorContext &C) {\n    Elements.push_back(CFGDeleteDtor(RD, DE), C);\n  }\n\n  // Destructors must be inserted in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginAutomaticObjDtorsInsert(iterator I, size_t Cnt,\n      BumpVectorContext &C) {\n    return iterator(Elements.insert(I.base(), Cnt,\n                                    CFGAutomaticObjDtor(nullptr, nullptr), C));\n  }\n  iterator insertAutomaticObjDtor(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGAutomaticObjDtor(VD, S);\n    return ++I;\n  }\n\n  // Scope leaving must be performed in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginLifetimeEndsInsert(iterator I, size_t Cnt,\n                                   BumpVectorContext &C) {\n    return iterator(\n        Elements.insert(I.base(), Cnt, CFGLifetimeEnds(nullptr, nullptr), C));\n  }\n  iterator insertLifetimeEnds(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGLifetimeEnds(VD, S);\n    return ++I;\n  }\n\n  // Scope leaving must be performed in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginScopeEndInsert(iterator I, size_t Cnt, BumpVectorContext &C) {\n    return iterator(\n        Elements.insert(I.base(), Cnt, CFGScopeEnd(nullptr, nullptr), C));\n  }\n  iterator insertScopeEnd(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGScopeEnd(VD, S);\n    return ++I;\n  }\n};\n\n/// CFGCallback defines methods that should be called when a logical\n/// operator error is found when building the CFG.\nclass CFGCallback {\npublic:\n  CFGCallback() = default;\n  virtual ~CFGCallback() = default;\n\n  virtual void compareAlwaysTrue(const BinaryOperator *B, bool isAlwaysTrue) {}\n  virtual void compareBitwiseEquality(const BinaryOperator *B,\n                                      bool isAlwaysTrue) {}\n  virtual void compareBitwiseOr(const BinaryOperator *B) {}\n};\n\n/// Represents a source-level, intra-procedural CFG that represents the\n///  control-flow of a Stmt.  The Stmt can represent an entire function body,\n///  or a single expression.  A CFG will always contain one empty block that\n///  represents the Exit point of the CFG.  A CFG will also contain a designated\n///  Entry block.  The CFG solely represents control-flow; it consists of\n///  CFGBlocks which are simply containers of Stmt*'s in the AST the CFG\n///  was constructed from.\nclass CFG {\npublic:\n  //===--------------------------------------------------------------------===//\n  // CFG Construction & Manipulation.\n  //===--------------------------------------------------------------------===//\n\n  class BuildOptions {\n    std::bitset<Stmt::lastStmtConstant> alwaysAddMask;\n\n  public:\n    using ForcedBlkExprs = llvm::DenseMap<const Stmt *, const CFGBlock *>;\n\n    ForcedBlkExprs **forcedBlkExprs = nullptr;\n    CFGCallback *Observer = nullptr;\n    bool PruneTriviallyFalseEdges = true;\n    bool AddEHEdges = false;\n    bool AddInitializers = false;\n    bool AddImplicitDtors = false;\n    bool AddLifetime = false;\n    bool AddLoopExit = false;\n    bool AddTemporaryDtors = false;\n    bool AddScopes = false;\n    bool AddStaticInitBranches = false;\n    bool AddCXXNewAllocator = false;\n    bool AddCXXDefaultInitExprInCtors = false;\n    bool AddCXXDefaultInitExprInAggregates = false;\n    bool AddRichCXXConstructors = false;\n    bool MarkElidedCXXConstructors = false;\n    bool AddVirtualBaseBranches = false;\n    bool OmitImplicitValueInitializers = false;\n\n    BuildOptions() = default;\n\n    bool alwaysAdd(const Stmt *stmt) const {\n      return alwaysAddMask[stmt->getStmtClass()];\n    }\n\n    BuildOptions &setAlwaysAdd(Stmt::StmtClass stmtClass, bool val = true) {\n      alwaysAddMask[stmtClass] = val;\n      return *this;\n    }\n\n    BuildOptions &setAllAlwaysAdd() {\n      alwaysAddMask.set();\n      return *this;\n    }\n  };\n\n  /// Builds a CFG from an AST.\n  static std::unique_ptr<CFG> buildCFG(const Decl *D, Stmt *AST, ASTContext *C,\n                                       const BuildOptions &BO);\n\n  /// Create a new block in the CFG. The CFG owns the block; the caller should\n  /// not directly free it.\n  CFGBlock *createBlock();\n\n  /// Set the entry block of the CFG. This is typically used only during CFG\n  /// construction. Most CFG clients expect that the entry block has no\n  /// predecessors and contains no statements.\n  void setEntry(CFGBlock *B) { Entry = B; }\n\n  /// Set the block used for indirect goto jumps. This is typically used only\n  /// during CFG construction.\n  void setIndirectGotoBlock(CFGBlock *B) { IndirectGotoBlock = B; }\n\n  //===--------------------------------------------------------------------===//\n  // Block Iterators\n  //===--------------------------------------------------------------------===//\n\n  using CFGBlockListTy = BumpVector<CFGBlock *>;\n  using iterator = CFGBlockListTy::iterator;\n  using const_iterator = CFGBlockListTy::const_iterator;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  CFGBlock &                front()                { return *Blocks.front(); }\n  CFGBlock &                back()                 { return *Blocks.back(); }\n\n  iterator                  begin()                { return Blocks.begin(); }\n  iterator                  end()                  { return Blocks.end(); }\n  const_iterator            begin()       const    { return Blocks.begin(); }\n  const_iterator            end()         const    { return Blocks.end(); }\n\n  iterator nodes_begin() { return iterator(Blocks.begin()); }\n  iterator nodes_end() { return iterator(Blocks.end()); }\n\n  llvm::iterator_range<iterator> nodes() { return {begin(), end()}; }\n  llvm::iterator_range<const_iterator> const_nodes() const {\n    return {begin(), end()};\n  }\n\n  const_iterator nodes_begin() const { return const_iterator(Blocks.begin()); }\n  const_iterator nodes_end() const { return const_iterator(Blocks.end()); }\n\n  reverse_iterator          rbegin()               { return Blocks.rbegin(); }\n  reverse_iterator          rend()                 { return Blocks.rend(); }\n  const_reverse_iterator    rbegin()      const    { return Blocks.rbegin(); }\n  const_reverse_iterator    rend()        const    { return Blocks.rend(); }\n\n  llvm::iterator_range<reverse_iterator> reverse_nodes() {\n    return {rbegin(), rend()};\n  }\n  llvm::iterator_range<const_reverse_iterator> const_reverse_nodes() const {\n    return {rbegin(), rend()};\n  }\n\n  CFGBlock &                getEntry()             { return *Entry; }\n  const CFGBlock &          getEntry()    const    { return *Entry; }\n  CFGBlock &                getExit()              { return *Exit; }\n  const CFGBlock &          getExit()     const    { return *Exit; }\n\n  CFGBlock *       getIndirectGotoBlock() { return IndirectGotoBlock; }\n  const CFGBlock * getIndirectGotoBlock() const { return IndirectGotoBlock; }\n\n  using try_block_iterator = std::vector<const CFGBlock *>::const_iterator;\n\n  try_block_iterator try_blocks_begin() const {\n    return TryDispatchBlocks.begin();\n  }\n\n  try_block_iterator try_blocks_end() const {\n    return TryDispatchBlocks.end();\n  }\n\n  void addTryDispatchBlock(const CFGBlock *block) {\n    TryDispatchBlocks.push_back(block);\n  }\n\n  /// Records a synthetic DeclStmt and the DeclStmt it was constructed from.\n  ///\n  /// The CFG uses synthetic DeclStmts when a single AST DeclStmt contains\n  /// multiple decls.\n  void addSyntheticDeclStmt(const DeclStmt *Synthetic,\n                            const DeclStmt *Source) {\n    assert(Synthetic->isSingleDecl() && \"Can handle single declarations only\");\n    assert(Synthetic != Source && \"Don't include original DeclStmts in map\");\n    assert(!SyntheticDeclStmts.count(Synthetic) && \"Already in map\");\n    SyntheticDeclStmts[Synthetic] = Source;\n  }\n\n  using synthetic_stmt_iterator =\n      llvm::DenseMap<const DeclStmt *, const DeclStmt *>::const_iterator;\n  using synthetic_stmt_range = llvm::iterator_range<synthetic_stmt_iterator>;\n\n  /// Iterates over synthetic DeclStmts in the CFG.\n  ///\n  /// Each element is a (synthetic statement, source statement) pair.\n  ///\n  /// \\sa addSyntheticDeclStmt\n  synthetic_stmt_iterator synthetic_stmt_begin() const {\n    return SyntheticDeclStmts.begin();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_iterator synthetic_stmt_end() const {\n    return SyntheticDeclStmts.end();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_range synthetic_stmts() const {\n    return synthetic_stmt_range(synthetic_stmt_begin(), synthetic_stmt_end());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Member templates useful for various batch operations over CFGs.\n  //===--------------------------------------------------------------------===//\n\n  template <typename CALLBACK>\n  void VisitBlockStmts(CALLBACK& O) const {\n    for (const_iterator I = begin(), E = end(); I != E; ++I)\n      for (CFGBlock::const_iterator BI = (*I)->begin(), BE = (*I)->end();\n           BI != BE; ++BI) {\n        if (Optional<CFGStmt> stmt = BI->getAs<CFGStmt>())\n          O(const_cast<Stmt*>(stmt->getStmt()));\n      }\n  }\n\n  //===--------------------------------------------------------------------===//\n  // CFG Introspection.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns the total number of BlockIDs allocated (which start at 0).\n  unsigned getNumBlockIDs() const { return NumBlockIDs; }\n\n  /// Return the total number of CFGBlocks within the CFG This is simply a\n  /// renaming of the getNumBlockIDs(). This is necessary because the dominator\n  /// implementation needs such an interface.\n  unsigned size() const { return NumBlockIDs; }\n\n  /// Returns true if the CFG has no branches. Usually it boils down to the CFG\n  /// having exactly three blocks (entry, the actual code, exit), but sometimes\n  /// more blocks appear due to having control flow that can be fully\n  /// resolved in compile time.\n  bool isLinear() const;\n\n  //===--------------------------------------------------------------------===//\n  // CFG Debugging: Pretty-Printing and Visualization.\n  //===--------------------------------------------------------------------===//\n\n  void viewCFG(const LangOptions &LO) const;\n  void print(raw_ostream &OS, const LangOptions &LO, bool ShowColors) const;\n  void dump(const LangOptions &LO, bool ShowColors) const;\n\n  //===--------------------------------------------------------------------===//\n  // Internal: constructors and data.\n  //===--------------------------------------------------------------------===//\n\n  CFG() : Blocks(BlkBVC, 10) {}\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return BlkBVC.getAllocator();\n  }\n\n  BumpVectorContext &getBumpVectorContext() {\n    return BlkBVC;\n  }\n\nprivate:\n  CFGBlock *Entry = nullptr;\n  CFGBlock *Exit = nullptr;\n\n  // Special block to contain collective dispatch for indirect gotos\n  CFGBlock* IndirectGotoBlock = nullptr;\n\n  unsigned  NumBlockIDs = 0;\n\n  BumpVectorContext BlkBVC;\n\n  CFGBlockListTy Blocks;\n\n  /// C++ 'try' statements are modeled with an indirect dispatch block.\n  /// This is the collection of such blocks present in the CFG.\n  std::vector<const CFGBlock *> TryDispatchBlocks;\n\n  /// Collects DeclStmts synthesized for this CFG and maps each one back to its\n  /// source DeclStmt.\n  llvm::DenseMap<const DeclStmt *, const DeclStmt *> SyntheticDeclStmts;\n};\n\n} // namespace clang\n\n//===----------------------------------------------------------------------===//\n// GraphTraits specializations for CFG basic block graphs (source-level CFGs)\n//===----------------------------------------------------------------------===//\n\nnamespace llvm {\n\n/// Implement simplify_type for CFGTerminator, so that we can dyn_cast from\n/// CFGTerminator to a specific Stmt class.\ntemplate <> struct simplify_type< ::clang::CFGTerminator> {\n  using SimpleType = ::clang::Stmt *;\n\n  static SimpleType getSimplifiedValue(::clang::CFGTerminator Val) {\n    return Val.getStmt();\n  }\n};\n\n// Traits for: CFGBlock\n\ntemplate <> struct GraphTraits< ::clang::CFGBlock *> {\n  using NodeRef = ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::succ_iterator;\n\n  static NodeRef getEntryNode(::clang::CFGBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<clang::CFGBlock>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits< const ::clang::CFGBlock *> {\n  using NodeRef = const ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_succ_iterator;\n\n  static NodeRef getEntryNode(const clang::CFGBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<const clang::CFGBlock>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits<Inverse< ::clang::CFGBlock *>> {\n  using NodeRef = ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<::clang::CFGBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<clang::CFGBlock>>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits<Inverse<const ::clang::CFGBlock *>> {\n  using NodeRef = const ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<const ::clang::CFGBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<const Inverse<clang::CFGBlock>>\n    : GraphTraits<clang::CFGBlock *> {};\n\n// Traits for: CFG\n\ntemplate <> struct GraphTraits< ::clang::CFG* >\n    : public GraphTraits< ::clang::CFGBlock *>  {\n  using nodes_iterator = ::clang::CFG::iterator;\n\n  static NodeRef getEntryNode(::clang::CFG *F) { return &F->getEntry(); }\n  static nodes_iterator nodes_begin(::clang::CFG* F) { return F->nodes_begin();}\n  static nodes_iterator   nodes_end(::clang::CFG* F) { return F->nodes_end(); }\n  static unsigned              size(::clang::CFG* F) { return F->size(); }\n};\n\ntemplate <> struct GraphTraits<const ::clang::CFG* >\n    : public GraphTraits<const ::clang::CFGBlock *>  {\n  using nodes_iterator = ::clang::CFG::const_iterator;\n\n  static NodeRef getEntryNode(const ::clang::CFG *F) { return &F->getEntry(); }\n\n  static nodes_iterator nodes_begin( const ::clang::CFG* F) {\n    return F->nodes_begin();\n  }\n\n  static nodes_iterator nodes_end( const ::clang::CFG* F) {\n    return F->nodes_end();\n  }\n\n  static unsigned size(const ::clang::CFG* F) {\n    return F->size();\n  }\n};\n\ntemplate <> struct GraphTraits<Inverse< ::clang::CFG *>>\n  : public GraphTraits<Inverse< ::clang::CFGBlock *>> {\n  using nodes_iterator = ::clang::CFG::iterator;\n\n  static NodeRef getEntryNode(::clang::CFG *F) { return &F->getExit(); }\n  static nodes_iterator nodes_begin( ::clang::CFG* F) {return F->nodes_begin();}\n  static nodes_iterator nodes_end( ::clang::CFG* F) { return F->nodes_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<const ::clang::CFG *>>\n  : public GraphTraits<Inverse<const ::clang::CFGBlock *>> {\n  using nodes_iterator = ::clang::CFG::const_iterator;\n\n  static NodeRef getEntryNode(const ::clang::CFG *F) { return &F->getExit(); }\n\n  static nodes_iterator nodes_begin(const ::clang::CFG* F) {\n    return F->nodes_begin();\n  }\n\n  static nodes_iterator nodes_end(const ::clang::CFG* F) {\n    return F->nodes_end();\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_ANALYSIS_CFG_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CodeInjector.h", "content": "//===-- CodeInjector.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the clang::CodeInjector interface which is responsible for\n/// injecting AST of function definitions that may not be available in the\n/// original source.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_CODEINJECTOR_H\n#define LLVM_CLANG_ANALYSIS_CODEINJECTOR_H\n\nnamespace clang {\n\nclass Stmt;\nclass FunctionDecl;\nclass ObjCMethodDecl;\n\n/// CodeInjector is an interface which is responsible for injecting AST\n/// of function definitions that may not be available in the original source.\n///\n/// The getBody function will be called each time the static analyzer examines a\n/// function call that has no definition available in the current translation\n/// unit. If the returned statement is not a null pointer, it is assumed to be\n/// the body of a function which will be used for the analysis. The source of\n/// the body can be arbitrary, but it is advised to use memoization to avoid\n/// unnecessary reparsing of the external source that provides the body of the\n/// functions.\nclass CodeInjector {\npublic:\n  CodeInjector();\n  virtual ~CodeInjector();\n\n  virtual Stmt *getBody(const FunctionDecl *D) = 0;\n  virtual Stmt *getBody(const ObjCMethodDecl *D) = 0;\n};\n}\n\n#endif\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "content": "//==- ProgramPoint.h - Program Points for Path-Sensitive Analysis --*- C++ -*-//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the interface ProgramPoint, which identifies a\n//  distinct location in a function.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H\n#define LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H\n\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass FunctionDecl;\nclass LocationContext;\n\n/// ProgramPoints can be \"tagged\" as representing points specific to a given\n/// analysis entity.  Tags are abstract annotations, with an associated\n/// description and potentially other information.\nclass ProgramPointTag {\npublic:\n  ProgramPointTag(void *tagKind = nullptr) : TagKind(tagKind) {}\n  virtual ~ProgramPointTag();\n  virtual StringRef getTagDescription() const = 0;\n\n  /// Used to implement 'isKind' in subclasses.\n  const void *getTagKind() const { return TagKind; }\n\nprivate:\n  const void *const TagKind;\n};\n\nclass SimpleProgramPointTag : public ProgramPointTag {\n  std::string Desc;\npublic:\n  SimpleProgramPointTag(StringRef MsgProvider, StringRef Msg);\n  StringRef getTagDescription() const override;\n};\n\nclass ProgramPoint {\npublic:\n  enum Kind { BlockEdgeKind,\n              BlockEntranceKind,\n              BlockExitKind,\n              PreStmtKind,\n              PreStmtPurgeDeadSymbolsKind,\n              PostStmtPurgeDeadSymbolsKind,\n              PostStmtKind,\n              PreLoadKind,\n              PostLoadKind,\n              PreStoreKind,\n              PostStoreKind,\n              PostConditionKind,\n              PostLValueKind,\n              PostAllocatorCallKind,\n              MinPostStmtKind = PostStmtKind,\n              MaxPostStmtKind = PostAllocatorCallKind,\n              PostInitializerKind,\n              CallEnterKind,\n              CallExitBeginKind,\n              CallExitEndKind,\n              FunctionExitKind,\n              PreImplicitCallKind,\n              PostImplicitCallKind,\n              MinImplicitCallKind = PreImplicitCallKind,\n              MaxImplicitCallKind = PostImplicitCallKind,\n              LoopExitKind,\n              EpsilonKind};\n\nprivate:\n  const void *Data1;\n  llvm::PointerIntPair<const void *, 2, unsigned> Data2;\n\n  // The LocationContext could be NULL to allow ProgramPoint to be used in\n  // context insensitive analysis.\n  llvm::PointerIntPair<const LocationContext *, 2, unsigned> L;\n\n  llvm::PointerIntPair<const ProgramPointTag *, 2, unsigned> Tag;\n\nprotected:\n  ProgramPoint() = default;\n  ProgramPoint(const void *P,\n               Kind k,\n               const LocationContext *l,\n               const ProgramPointTag *tag = nullptr)\n    : Data1(P),\n      Data2(nullptr, (((unsigned) k) >> 0) & 0x3),\n      L(l, (((unsigned) k) >> 2) & 0x3),\n      Tag(tag, (((unsigned) k) >> 4) & 0x3) {\n        assert(getKind() == k);\n        assert(getLocationContext() == l);\n        assert(getData1() == P);\n      }\n\n  ProgramPoint(const void *P1,\n               const void *P2,\n               Kind k,\n               const LocationContext *l,\n               const ProgramPointTag *tag = nullptr)\n    : Data1(P1),\n      Data2(P2, (((unsigned) k) >> 0) & 0x3),\n      L(l, (((unsigned) k) >> 2) & 0x3),\n      Tag(tag, (((unsigned) k) >> 4) & 0x3) {}\n\nprotected:\n  const void *getData1() const { return Data1; }\n  const void *getData2() const { return Data2.getPointer(); }\n  void setData2(const void *d) { Data2.setPointer(d); }\n\npublic:\n  /// Create a new ProgramPoint object that is the same as the original\n  /// except for using the specified tag value.\n  ProgramPoint withTag(const ProgramPointTag *tag) const {\n    return ProgramPoint(getData1(), getData2(), getKind(),\n                        getLocationContext(), tag);\n  }\n\n  /// Convert to the specified ProgramPoint type, asserting that this\n  /// ProgramPoint is of the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  /// Convert to the specified ProgramPoint type, returning None if this\n  /// ProgramPoint is not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  Kind getKind() const {\n    unsigned x = Tag.getInt();\n    x <<= 2;\n    x |= L.getInt();\n    x <<= 2;\n    x |= Data2.getInt();\n    return (Kind) x;\n  }\n\n  /// Is this a program point corresponding to purge/removal of dead\n  /// symbols and bindings.\n  bool isPurgeKind() {\n    Kind K = getKind();\n    return (K == PostStmtPurgeDeadSymbolsKind ||\n            K == PreStmtPurgeDeadSymbolsKind);\n  }\n\n  const ProgramPointTag *getTag() const { return Tag.getPointer(); }\n\n  const LocationContext *getLocationContext() const {\n    return L.getPointer();\n  }\n\n  const StackFrameContext *getStackFrame() const {\n    return getLocationContext()->getStackFrame();\n  }\n\n  // For use with DenseMap.  This hash is probably slow.\n  unsigned getHashValue() const {\n    llvm::FoldingSetNodeID ID;\n    Profile(ID);\n    return ID.ComputeHash();\n  }\n\n  bool operator==(const ProgramPoint & RHS) const {\n    return Data1 == RHS.Data1 &&\n           Data2 == RHS.Data2 &&\n           L == RHS.L &&\n           Tag == RHS.Tag;\n  }\n\n  bool operator!=(const ProgramPoint &RHS) const {\n    return Data1 != RHS.Data1 ||\n           Data2 != RHS.Data2 ||\n           L != RHS.L ||\n           Tag != RHS.Tag;\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.AddInteger((unsigned) getKind());\n    ID.AddPointer(getData1());\n    ID.AddPointer(getData2());\n    ID.AddPointer(getLocationContext());\n    ID.AddPointer(getTag());\n  }\n\n  void printJson(llvm::raw_ostream &Out, const char *NL = \"\\n\") const;\n\n  LLVM_DUMP_METHOD void dump() const;\n\n  static ProgramPoint getProgramPoint(const Stmt *S, ProgramPoint::Kind K,\n                                      const LocationContext *LC,\n                                      const ProgramPointTag *tag);\n};\n\nclass BlockEntrance : public ProgramPoint {\npublic:\n  BlockEntrance(const CFGBlock *B, const LocationContext *L,\n                const ProgramPointTag *tag = nullptr)\n    : ProgramPoint(B, BlockEntranceKind, L, tag) {\n    assert(B && \"BlockEntrance requires non-null block\");\n  }\n\n  const CFGBlock *getBlock() const {\n    return reinterpret_cast<const CFGBlock*>(getData1());\n  }\n\n  Optional<CFGElement> getFirstElement() const {\n    const CFGBlock *B = getBlock();\n    return B->empty() ? Optional<CFGElement>() : B->front();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockEntrance() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockEntranceKind;\n  }\n};\n\nclass BlockExit : public ProgramPoint {\npublic:\n  BlockExit(const CFGBlock *B, const LocationContext *L)\n    : ProgramPoint(B, BlockExitKind, L) {}\n\n  const CFGBlock *getBlock() const {\n    return reinterpret_cast<const CFGBlock*>(getData1());\n  }\n\n  const Stmt *getTerminator() const {\n    return getBlock()->getTerminatorStmt();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockExit() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockExitKind;\n  }\n};\n\nclass StmtPoint : public ProgramPoint {\npublic:\n  StmtPoint(const Stmt *S, const void *p2, Kind k, const LocationContext *L,\n            const ProgramPointTag *tag)\n    : ProgramPoint(S, p2, k, L, tag) {\n    assert(S);\n  }\n\n  const Stmt *getStmt() const { return (const Stmt*) getData1(); }\n\n  template <typename T>\n  const T* getStmtAs() const { return dyn_cast<T>(getStmt()); }\n\nprotected:\n  StmtPoint() = default;\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    unsigned k = Location.getKind();\n    return k >= PreStmtKind && k <= MaxPostStmtKind;\n  }\n};\n\n\nclass PreStmt : public StmtPoint {\npublic:\n  PreStmt(const Stmt *S, const LocationContext *L, const ProgramPointTag *tag,\n          const Stmt *SubStmt = nullptr)\n    : StmtPoint(S, SubStmt, PreStmtKind, L, tag) {}\n\n  const Stmt *getSubStmt() const { return (const Stmt*) getData2(); }\n\nprivate:\n  friend class ProgramPoint;\n  PreStmt() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreStmtKind;\n  }\n};\n\nclass PostStmt : public StmtPoint {\nprotected:\n  PostStmt() = default;\n  PostStmt(const Stmt *S, const void *data, Kind k, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, data, k, L, tag) {}\n\npublic:\n  explicit PostStmt(const Stmt *S, Kind k, const LocationContext *L,\n                    const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, k, L, tag) {}\n\n  explicit PostStmt(const Stmt *S, const LocationContext *L,\n                    const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PostStmtKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    unsigned k = Location.getKind();\n    return k >= MinPostStmtKind && k <= MaxPostStmtKind;\n  }\n};\n\nclass FunctionExitPoint : public ProgramPoint {\npublic:\n  explicit FunctionExitPoint(const ReturnStmt *S,\n                             const LocationContext *LC,\n                             const ProgramPointTag *tag = nullptr)\n      : ProgramPoint(S, FunctionExitKind, LC, tag) {}\n\n  const CFGBlock *getBlock() const {\n    return &getLocationContext()->getCFG()->getExit();\n  }\n\n  const ReturnStmt *getStmt() const {\n    return reinterpret_cast<const ReturnStmt *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  FunctionExitPoint() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == FunctionExitKind;\n  }\n};\n\n// PostCondition represents the post program point of a branch condition.\nclass PostCondition : public PostStmt {\npublic:\n  PostCondition(const Stmt *S, const LocationContext *L,\n                const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostConditionKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostCondition() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostConditionKind;\n  }\n};\n\nclass LocationCheck : public StmtPoint {\nprotected:\n  LocationCheck() = default;\n  LocationCheck(const Stmt *S, const LocationContext *L,\n                ProgramPoint::Kind K, const ProgramPointTag *tag)\n    : StmtPoint(S, nullptr, K, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &location) {\n    unsigned k = location.getKind();\n    return k == PreLoadKind || k == PreStoreKind;\n  }\n};\n\nclass PreLoad : public LocationCheck {\npublic:\n  PreLoad(const Stmt *S, const LocationContext *L,\n          const ProgramPointTag *tag = nullptr)\n    : LocationCheck(S, L, PreLoadKind, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreLoad() = default;\n  static bool isKind(const ProgramPoint &location) {\n    return location.getKind() == PreLoadKind;\n  }\n};\n\nclass PreStore : public LocationCheck {\npublic:\n  PreStore(const Stmt *S, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n  : LocationCheck(S, L, PreStoreKind, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreStore() = default;\n  static bool isKind(const ProgramPoint &location) {\n    return location.getKind() == PreStoreKind;\n  }\n};\n\nclass PostLoad : public PostStmt {\npublic:\n  PostLoad(const Stmt *S, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostLoadKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostLoad() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostLoadKind;\n  }\n};\n\n/// Represents a program point after a store evaluation.\nclass PostStore : public PostStmt {\npublic:\n  /// Construct the post store point.\n  /// \\param Loc can be used to store the information about the location\n  /// used in the form it was uttered in the code.\n  PostStore(const Stmt *S, const LocationContext *L, const void *Loc,\n            const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostStoreKind, L, tag) {\n    assert(getData2() == nullptr);\n    setData2(Loc);\n  }\n\n  /// Returns the information about the location used in the store,\n  /// how it was uttered in the code.\n  const void *getLocationValue() const {\n    return getData2();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  PostStore() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostStoreKind;\n  }\n};\n\nclass PostLValue : public PostStmt {\npublic:\n  PostLValue(const Stmt *S, const LocationContext *L,\n             const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostLValueKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostLValue() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostLValueKind;\n  }\n};\n\n/// Represents a point after we ran remove dead bindings BEFORE\n/// processing the given statement.\nclass PreStmtPurgeDeadSymbols : public StmtPoint {\npublic:\n  PreStmtPurgeDeadSymbols(const Stmt *S, const LocationContext *L,\n                       const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PreStmtPurgeDeadSymbolsKind, L, tag) { }\n\nprivate:\n  friend class ProgramPoint;\n  PreStmtPurgeDeadSymbols() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreStmtPurgeDeadSymbolsKind;\n  }\n};\n\n/// Represents a point after we ran remove dead bindings AFTER\n/// processing the  given statement.\nclass PostStmtPurgeDeadSymbols : public StmtPoint {\npublic:\n  PostStmtPurgeDeadSymbols(const Stmt *S, const LocationContext *L,\n                       const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PostStmtPurgeDeadSymbolsKind, L, tag) { }\n\nprivate:\n  friend class ProgramPoint;\n  PostStmtPurgeDeadSymbols() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostStmtPurgeDeadSymbolsKind;\n  }\n};\n\nclass BlockEdge : public ProgramPoint {\npublic:\n  BlockEdge(const CFGBlock *B1, const CFGBlock *B2, const LocationContext *L)\n    : ProgramPoint(B1, B2, BlockEdgeKind, L) {\n    assert(B1 && \"BlockEdge: source block must be non-null\");\n    assert(B2 && \"BlockEdge: destination block must be non-null\");\n  }\n\n  const CFGBlock *getSrc() const {\n    return static_cast<const CFGBlock*>(getData1());\n  }\n\n  const CFGBlock *getDst() const {\n    return static_cast<const CFGBlock*>(getData2());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockEdge() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockEdgeKind;\n  }\n};\n\nclass PostInitializer : public ProgramPoint {\npublic:\n  /// Construct a PostInitializer point that represents a location after\n  ///   CXXCtorInitializer expression evaluation.\n  ///\n  /// \\param I The initializer.\n  /// \\param Loc The location of the field being initialized.\n  PostInitializer(const CXXCtorInitializer *I,\n                  const void *Loc,\n                  const LocationContext *L)\n    : ProgramPoint(I, Loc, PostInitializerKind, L) {}\n\n  const CXXCtorInitializer *getInitializer() const {\n    return static_cast<const CXXCtorInitializer *>(getData1());\n  }\n\n  /// Returns the location of the field.\n  const void *getLocationValue() const {\n    return getData2();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  PostInitializer() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostInitializerKind;\n  }\n};\n\n/// Represents an implicit call event.\n///\n/// The nearest statement is provided for diagnostic purposes.\nclass ImplicitCallPoint : public ProgramPoint {\npublic:\n  ImplicitCallPoint(const Decl *D, SourceLocation Loc, Kind K,\n                    const LocationContext *L, const ProgramPointTag *Tag)\n    : ProgramPoint(Loc.getPtrEncoding(), D, K, L, Tag) {}\n\n  const Decl *getDecl() const { return static_cast<const Decl *>(getData2()); }\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromPtrEncoding(getData1());\n  }\n\nprotected:\n  ImplicitCallPoint() = default;\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() >= MinImplicitCallKind &&\n           Location.getKind() <= MaxImplicitCallKind;\n  }\n};\n\n/// Represents a program point just before an implicit call event.\n///\n/// Explicit calls will appear as PreStmt program points.\nclass PreImplicitCall : public ImplicitCallPoint {\npublic:\n  PreImplicitCall(const Decl *D, SourceLocation Loc, const LocationContext *L,\n                  const ProgramPointTag *Tag = nullptr)\n    : ImplicitCallPoint(D, Loc, PreImplicitCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreImplicitCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreImplicitCallKind;\n  }\n};\n\n/// Represents a program point just after an implicit call event.\n///\n/// Explicit calls will appear as PostStmt program points.\nclass PostImplicitCall : public ImplicitCallPoint {\npublic:\n  PostImplicitCall(const Decl *D, SourceLocation Loc, const LocationContext *L,\n                   const ProgramPointTag *Tag = nullptr)\n    : ImplicitCallPoint(D, Loc, PostImplicitCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostImplicitCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostImplicitCallKind;\n  }\n};\n\nclass PostAllocatorCall : public StmtPoint {\npublic:\n  PostAllocatorCall(const Stmt *S, const LocationContext *L,\n                    const ProgramPointTag *Tag = nullptr)\n      : StmtPoint(S, nullptr, PostAllocatorCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostAllocatorCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostAllocatorCallKind;\n  }\n};\n\n/// Represents a point when we begin processing an inlined call.\n/// CallEnter uses the caller's location context.\nclass CallEnter : public ProgramPoint {\npublic:\n  CallEnter(const Stmt *stmt, const StackFrameContext *calleeCtx,\n            const LocationContext *callerCtx)\n    : ProgramPoint(stmt, calleeCtx, CallEnterKind, callerCtx, nullptr) {}\n\n  const Stmt *getCallExpr() const {\n    return static_cast<const Stmt *>(getData1());\n  }\n\n  const StackFrameContext *getCalleeContext() const {\n    return static_cast<const StackFrameContext *>(getData2());\n  }\n\n  /// Returns the entry block in the CFG for the entered function.\n  const CFGBlock *getEntry() const {\n    const StackFrameContext *CalleeCtx = getCalleeContext();\n    const CFG *CalleeCFG = CalleeCtx->getCFG();\n    return &(CalleeCFG->getEntry());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallEnter() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallEnterKind;\n  }\n};\n\n/// Represents a point when we start the call exit sequence (for inlined call).\n///\n/// The call exit is simulated with a sequence of nodes, which occur between\n/// CallExitBegin and CallExitEnd. The following operations occur between the\n/// two program points:\n/// - CallExitBegin\n/// - Bind the return value\n/// - Run Remove dead bindings (to clean up the dead symbols from the callee).\n/// - CallExitEnd\nclass CallExitBegin : public ProgramPoint {\npublic:\n  // CallExitBegin uses the callee's location context.\n  CallExitBegin(const StackFrameContext *L, const ReturnStmt *RS)\n    : ProgramPoint(RS, CallExitBeginKind, L, nullptr) { }\n\n  const ReturnStmt *getReturnStmt() const {\n    return static_cast<const ReturnStmt *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallExitBegin() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallExitBeginKind;\n  }\n};\n\n/// Represents a point when we finish the call exit sequence (for inlined call).\n/// \\sa CallExitBegin\nclass CallExitEnd : public ProgramPoint {\npublic:\n  // CallExitEnd uses the caller's location context.\n  CallExitEnd(const StackFrameContext *CalleeCtx,\n              const LocationContext *CallerCtx)\n    : ProgramPoint(CalleeCtx, CallExitEndKind, CallerCtx, nullptr) {}\n\n  const StackFrameContext *getCalleeContext() const {\n    return static_cast<const StackFrameContext *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallExitEnd() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallExitEndKind;\n  }\n};\n\n/// Represents a point when we exit a loop.\n/// When this ProgramPoint is encountered we can be sure that the symbolic\n/// execution of the corresponding LoopStmt is finished on the given path.\n/// Note: It is possible to encounter a LoopExit element when we haven't even\n/// encountered the loop itself. At the current state not all loop exits will\n/// result in a LoopExit program point.\nclass LoopExit : public ProgramPoint {\npublic:\n    LoopExit(const Stmt *LoopStmt, const LocationContext *LC)\n            : ProgramPoint(LoopStmt, nullptr, LoopExitKind, LC) {}\n\n    const Stmt *getLoopStmt() const {\n      return static_cast<const Stmt *>(getData1());\n    }\n\nprivate:\n    friend class ProgramPoint;\n    LoopExit() = default;\n    static bool isKind(const ProgramPoint &Location) {\n      return Location.getKind() == LoopExitKind;\n    }\n};\n\n/// This is a meta program point, which should be skipped by all the diagnostic\n/// reasoning etc.\nclass EpsilonPoint : public ProgramPoint {\npublic:\n  EpsilonPoint(const LocationContext *L, const void *Data1,\n               const void *Data2 = nullptr,\n               const ProgramPointTag *tag = nullptr)\n    : ProgramPoint(Data1, Data2, EpsilonKind, L, tag) {}\n\n  const void *getData() const { return getData1(); }\n\nprivate:\n  friend class ProgramPoint;\n  EpsilonPoint() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == EpsilonKind;\n  }\n};\n\n} // end namespace clang\n\n\nnamespace llvm { // Traits specialization for DenseMap\n\ntemplate <> struct DenseMapInfo<clang::ProgramPoint> {\n\nstatic inline clang::ProgramPoint getEmptyKey() {\n  uintptr_t x =\n   reinterpret_cast<uintptr_t>(DenseMapInfo<void*>::getEmptyKey()) & ~0x7;\n  return clang::BlockEntrance(reinterpret_cast<clang::CFGBlock*>(x), nullptr);\n}\n\nstatic inline clang::ProgramPoint getTombstoneKey() {\n  uintptr_t x =\n   reinterpret_cast<uintptr_t>(DenseMapInfo<void*>::getTombstoneKey()) & ~0x7;\n  return clang::BlockEntrance(reinterpret_cast<clang::CFGBlock*>(x), nullptr);\n}\n\nstatic unsigned getHashValue(const clang::ProgramPoint &Loc) {\n  return Loc.getHashValue();\n}\n\nstatic bool isEqual(const clang::ProgramPoint &L,\n                    const clang::ProgramPoint &R) {\n  return L == R;\n}\n\n};\n\n} // end namespace llvm\n\n#endif\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h", "content": "//===- BumpVector.h - Vector-like ADT that uses bump allocation -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides BumpVector, a vector-like ADT whose contents are\n//  allocated from a BumpPtrAllocator.\n//\n//===----------------------------------------------------------------------===//\n\n// FIXME: Most of this is copy-and-paste from SmallVector.h.  We can\n// refactor this core logic into something common that is shared between\n// the two.  The main thing that is different is the allocation strategy.\n\n#ifndef LLVM_CLANG_ANALYSIS_SUPPORT_BUMPVECTOR_H\n#define LLVM_CLANG_ANALYSIS_SUPPORT_BUMPVECTOR_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <iterator>\n#include <memory>\n#include <type_traits>\n\nnamespace clang {\n\nclass BumpVectorContext {\n  llvm::PointerIntPair<llvm::BumpPtrAllocator*, 1> Alloc;\n\npublic:\n  /// Construct a new BumpVectorContext that creates a new BumpPtrAllocator\n  /// and destroys it when the BumpVectorContext object is destroyed.\n  BumpVectorContext() : Alloc(new llvm::BumpPtrAllocator(), 1) {}\n\n  BumpVectorContext(BumpVectorContext &&Other) : Alloc(Other.Alloc) {\n    Other.Alloc.setInt(false);\n    Other.Alloc.setPointer(nullptr);\n  }\n\n  /// Construct a new BumpVectorContext that reuses an existing\n  /// BumpPtrAllocator.  This BumpPtrAllocator is not destroyed when the\n  /// BumpVectorContext object is destroyed.\n  BumpVectorContext(llvm::BumpPtrAllocator &A) : Alloc(&A, 0) {}\n\n  ~BumpVectorContext() {\n    if (Alloc.getInt())\n      delete Alloc.getPointer();\n  }\n\n  llvm::BumpPtrAllocator &getAllocator() { return *Alloc.getPointer(); }\n};\n\ntemplate<typename T>\nclass BumpVector {\n  T *Begin = nullptr;\n  T *End = nullptr;\n  T *Capacity = nullptr;\n\npublic:\n  // Default ctor - Initialize to empty.\n  explicit BumpVector(BumpVectorContext &C, unsigned N) {\n    reserve(C, N);\n  }\n\n  ~BumpVector() {\n    if (std::is_class<T>::value) {\n      // Destroy the constructed elements in the vector.\n      destroy_range(Begin, End);\n    }\n  }\n\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  // forward iterator creation methods.\n  iterator begin() { return Begin; }\n  const_iterator begin() const { return Begin; }\n  iterator end() { return End; }\n  const_iterator end() const { return End; }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  bool empty() const { return Begin == End; }\n  size_type size() const { return End-Begin; }\n\n  reference operator[](unsigned idx) {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n  const_reference operator[](unsigned idx) const {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n\n  reference front() {\n    return begin()[0];\n  }\n  const_reference front() const {\n    return begin()[0];\n  }\n\n  reference back() {\n    return end()[-1];\n  }\n  const_reference back() const {\n    return end()[-1];\n  }\n\n  void pop_back() {\n    --End;\n    End->~T();\n  }\n\n  T pop_back_val() {\n    T Result = back();\n    pop_back();\n    return Result;\n  }\n\n  void clear() {\n    if (std::is_class<T>::value) {\n      destroy_range(Begin, End);\n    }\n    End = Begin;\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  pointer data() {\n    return pointer(Begin);\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const {\n    return const_pointer(Begin);\n  }\n\n  void push_back(const_reference Elt, BumpVectorContext &C) {\n    if (End < Capacity) {\n    Retry:\n      new (End) T(Elt);\n      ++End;\n      return;\n    }\n    grow(C);\n    goto Retry;\n  }\n\n  /// insert - Insert some number of copies of element into a position. Return\n  /// iterator to position after last inserted copy.\n  iterator insert(iterator I, size_t Cnt, const_reference E,\n      BumpVectorContext &C) {\n    assert(I >= Begin && I <= End && \"Iterator out of bounds.\");\n    if (End + Cnt <= Capacity) {\n    Retry:\n      move_range_right(I, End, Cnt);\n      construct_range(I, I + Cnt, E);\n      End += Cnt;\n      return I + Cnt;\n    }\n    ptrdiff_t D = I - Begin;\n    grow(C, size() + Cnt);\n    I = Begin + D;\n    goto Retry;\n  }\n\n  void reserve(BumpVectorContext &C, unsigned N) {\n    if (unsigned(Capacity-Begin) < N)\n      grow(C, N);\n  }\n\n  /// capacity - Return the total number of elements in the currently allocated\n  /// buffer.\n  size_t capacity() const { return Capacity - Begin; }\n\nprivate:\n  /// grow - double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(BumpVectorContext &C, size_type MinSize = 1);\n\n  void construct_range(T *S, T *E, const T &Elt) {\n    for (; S != E; ++S)\n      new (S) T(Elt);\n  }\n\n  void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\n  void move_range_right(T *S, T *E, size_t D) {\n    for (T *I = E + D - 1, *IL = S + D - 1; I != IL; --I) {\n      --E;\n      new (I) T(*E);\n      E->~T();\n    }\n  }\n};\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T>\nvoid BumpVector<T>::grow(BumpVectorContext &C, size_t MinSize) {\n  size_t CurCapacity = Capacity-Begin;\n  size_t CurSize = size();\n  size_t NewCapacity = 2*CurCapacity;\n  if (NewCapacity < MinSize)\n    NewCapacity = MinSize;\n\n  // Allocate the memory from the BumpPtrAllocator.\n  T *NewElts = C.getAllocator().template Allocate<T>(NewCapacity);\n\n  // Copy the elements over.\n  if (Begin != End) {\n    if (std::is_class<T>::value) {\n      std::uninitialized_copy(Begin, End, NewElts);\n      // Destroy the original elements.\n      destroy_range(Begin, End);\n    } else {\n      // Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).\n      memcpy(NewElts, Begin, CurSize * sizeof(T));\n    }\n  }\n\n  // For now, leak 'Begin'.  We can add it back to a freelist in\n  // BumpVectorContext.\n  Begin = NewElts;\n  End = NewElts+CurSize;\n  Capacity = Begin+NewCapacity;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_ANALYSIS_SUPPORT_BUMPVECTOR_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "content": "//===--- CodeGenOptions.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CodeGenOptions interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_CODEGENOPTIONS_H\n#define LLVM_CLANG_BASIC_CODEGENOPTIONS_H\n\n#include \"clang/Basic/DebugInfoOptions.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/XRayInstr.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include \"llvm/Transforms/Instrumentation/AddressSanitizerOptions.h\"\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// Bitfields of CodeGenOptions, split out from CodeGenOptions to ensure\n/// that this large collection of bitfields is a trivial class type.\nclass CodeGenOptionsBase {\n  friend class CompilerInvocation;\n\npublic:\n#define CODEGENOPT(Name, Bits, Default) unsigned Name : Bits;\n#define ENUM_CODEGENOPT(Name, Type, Bits, Default)\n#include \"clang/Basic/CodeGenOptions.def\"\n\nprotected:\n#define CODEGENOPT(Name, Bits, Default)\n#define ENUM_CODEGENOPT(Name, Type, Bits, Default) unsigned Name : Bits;\n#include \"clang/Basic/CodeGenOptions.def\"\n};\n\n/// CodeGenOptions - Track various options which control how the code\n/// is optimized and passed to the backend.\nclass CodeGenOptions : public CodeGenOptionsBase {\npublic:\n  enum InliningMethod {\n    NormalInlining,     // Use the standard function inlining pass.\n    OnlyHintInlining,   // Inline only (implicitly) hinted functions.\n    OnlyAlwaysInlining  // Only run the always inlining pass.\n  };\n\n  enum VectorLibrary {\n    NoLibrary,  // Don't use any vector library.\n    Accelerate, // Use the Accelerate framework.\n    LIBMVEC,    // GLIBC vector math library.\n    MASSV,      // IBM MASS vector library.\n    SVML        // Intel short vector math library.\n  };\n\n  enum ObjCDispatchMethodKind {\n    Legacy = 0,\n    NonLegacy = 1,\n    Mixed = 2\n  };\n\n  enum TLSModel {\n    GeneralDynamicTLSModel,\n    LocalDynamicTLSModel,\n    InitialExecTLSModel,\n    LocalExecTLSModel\n  };\n\n  /// Clang versions with different platform ABI conformance.\n  enum class ClangABI {\n    /// Attempt to be ABI-compatible with code generated by Clang 3.8.x\n    /// (SVN r257626). This causes <1 x long long> to be passed in an\n    /// integer register instead of an SSE register on x64_64.\n    Ver3_8,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 4.0.x\n    /// (SVN r291814). This causes move operations to be ignored when\n    /// determining whether a class type can be passed or returned directly.\n    Ver4,\n\n    /// Conform to the underlying platform's C and C++ ABIs as closely\n    /// as we can.\n    Latest\n  };\n\n  enum StructReturnConventionKind {\n    SRCK_Default,  // No special option was passed.\n    SRCK_OnStack,  // Small structs on the stack (-fpcc-struct-return).\n    SRCK_InRegs    // Small structs in registers (-freg-struct-return).\n  };\n\n  enum ProfileInstrKind {\n    ProfileNone,       // Profile instrumentation is turned off.\n    ProfileClangInstr, // Clang instrumentation to generate execution counts\n                       // to use with PGO.\n    ProfileIRInstr,    // IR level PGO instrumentation in LLVM.\n    ProfileCSIRInstr, // IR level PGO context sensitive instrumentation in LLVM.\n  };\n\n  enum EmbedBitcodeKind {\n    Embed_Off,      // No embedded bitcode.\n    Embed_All,      // Embed both bitcode and commandline in the output.\n    Embed_Bitcode,  // Embed just the bitcode in the output.\n    Embed_Marker    // Embed a marker as a placeholder for bitcode.\n  };\n\n  // This field stores one of the allowed values for the option\n  // -fbasic-block-sections=.  The allowed values with this option are:\n  // {\"labels\", \"all\", \"list=<file>\", \"none\"}.\n  //\n  // \"labels\":      Only generate basic block symbols (labels) for all basic\n  //                blocks, do not generate unique sections for basic blocks.\n  //                Use the machine basic block id in the symbol name to\n  //                associate profile info from virtual address to machine\n  //                basic block.\n  // \"all\" :        Generate basic block sections for all basic blocks.\n  // \"list=<file>\": Generate basic block sections for a subset of basic blocks.\n  //                The functions and the machine basic block ids are specified\n  //                in the file.\n  // \"none\":        Disable sections/labels for basic blocks.\n  std::string BBSections;\n\n  // If set, override the default value of MCAsmInfo::BinutilsVersion. If\n  // DisableIntegratedAS is specified, the assembly output will consider GNU as\n  // support. \"none\" means that all ELF features can be used, regardless of\n  // binutils support.\n  std::string BinutilsVersion;\n\n  enum class FramePointerKind {\n    None,        // Omit all frame pointers.\n    NonLeaf,     // Keep non-leaf frame pointers.\n    All,         // Keep all frame pointers.\n  };\n\n  enum FiniteLoopsKind {\n    Language, // Not specified, use language standard.\n    Always,   // All loops are assumed to be finite.\n    Never,    // No loop is assumed to be finite.\n  };\n\n  /// The code model to use (-mcmodel).\n  std::string CodeModel;\n\n  /// The filename with path we use for coverage data files. The runtime\n  /// allows further manipulation with the GCOV_PREFIX and GCOV_PREFIX_STRIP\n  /// environment variables.\n  std::string CoverageDataFile;\n\n  /// The filename with path we use for coverage notes files.\n  std::string CoverageNotesFile;\n\n  /// Regexes separated by a semi-colon to filter the files to instrument.\n  std::string ProfileFilterFiles;\n\n  /// Regexes separated by a semi-colon to filter the files to not instrument.\n  std::string ProfileExcludeFiles;\n\n  /// The version string to put into coverage files.\n  char CoverageVersion[4];\n\n  /// Enable additional debugging information.\n  std::string DebugPass;\n\n  /// The string to embed in debug information as the current working directory.\n  std::string DebugCompilationDir;\n\n  /// The string to embed in coverage mapping as the current working directory.\n  std::string CoverageCompilationDir;\n\n  /// The string to embed in the debug information for the compile unit, if\n  /// non-empty.\n  std::string DwarfDebugFlags;\n\n  /// The string containing the commandline for the llvm.commandline metadata,\n  /// if non-empty.\n  std::string RecordCommandLine;\n\n  std::map<std::string, std::string> DebugPrefixMap;\n  std::map<std::string, std::string> CoveragePrefixMap;\n\n  /// The ABI to use for passing floating point arguments.\n  std::string FloatABI;\n\n  /// The floating-point denormal mode to use.\n  llvm::DenormalMode FPDenormalMode = llvm::DenormalMode::getIEEE();\n\n  /// The floating-point denormal mode to use, for float.\n  llvm::DenormalMode FP32DenormalMode = llvm::DenormalMode::getIEEE();\n\n  /// The float precision limit to use, if non-empty.\n  std::string LimitFloatPrecision;\n\n  struct BitcodeFileToLink {\n    /// The filename of the bitcode file to link in.\n    std::string Filename;\n    /// If true, we set attributes functions in the bitcode library according to\n    /// our CodeGenOptions, much as we set attrs on functions that we generate\n    /// ourselves.\n    bool PropagateAttrs = false;\n    /// If true, we use LLVM module internalizer.\n    bool Internalize = false;\n    /// Bitwise combination of llvm::Linker::Flags, passed to the LLVM linker.\n    unsigned LinkFlags = 0;\n  };\n\n  /// The files specified here are linked in to the module before optimizations.\n  std::vector<BitcodeFileToLink> LinkBitcodeFiles;\n\n  /// The user provided name for the \"main file\", if non-empty. This is useful\n  /// in situations where the input file name does not match the original input\n  /// file, for example with -save-temps.\n  std::string MainFileName;\n\n  /// The name for the split debug info file used for the DW_AT_[GNU_]dwo_name\n  /// attribute in the skeleton CU.\n  std::string SplitDwarfFile;\n\n  /// Output filename for the split debug info, not used in the skeleton CU.\n  std::string SplitDwarfOutput;\n\n  /// The name of the relocation model to use.\n  llvm::Reloc::Model RelocationModel;\n\n  /// If not an empty string, trap intrinsics are lowered to calls to this\n  /// function instead of to trap instructions.\n  std::string TrapFuncName;\n\n  /// A list of dependent libraries.\n  std::vector<std::string> DependentLibraries;\n\n  /// A list of linker options to embed in the object file.\n  std::vector<std::string> LinkerOptions;\n\n  /// Name of the profile file to use as output for -fprofile-instr-generate,\n  /// -fprofile-generate, and -fcs-profile-generate.\n  std::string InstrProfileOutput;\n\n  /// Name of the profile file to use with -fprofile-sample-use.\n  std::string SampleProfileFile;\n\n  /// Name of the profile file to use as output for with -fmemory-profile.\n  std::string MemoryProfileOutput;\n\n  /// Name of the profile file to use as input for -fprofile-instr-use\n  std::string ProfileInstrumentUsePath;\n\n  /// Name of the profile remapping file to apply to the profile data supplied\n  /// by -fprofile-sample-use or -fprofile-instr-use.\n  std::string ProfileRemappingFile;\n\n  /// Name of the function summary index file to use for ThinLTO function\n  /// importing.\n  std::string ThinLTOIndexFile;\n\n  /// Name of a file that can optionally be written with minimized bitcode\n  /// to be used as input for the ThinLTO thin link step, which only needs\n  /// the summary and module symbol table (and not, e.g. any debug metadata).\n  std::string ThinLinkBitcodeFile;\n\n  /// Prefix to use for -save-temps output.\n  std::string SaveTempsFilePrefix;\n\n  /// Name of file passed with -fcuda-include-gpubinary option to forward to\n  /// CUDA runtime back-end for incorporating them into host-side object file.\n  std::string CudaGpuBinaryFileName;\n\n  /// The name of the file to which the backend should save YAML optimization\n  /// records.\n  std::string OptRecordFile;\n\n  /// The regex that filters the passes that should be saved to the optimization\n  /// records.\n  std::string OptRecordPasses;\n\n  /// The format used for serializing remarks (default: YAML)\n  std::string OptRecordFormat;\n\n  /// The name of the partition that symbols are assigned to, specified with\n  /// -fsymbol-partition (see https://lld.llvm.org/Partitions.html).\n  std::string SymbolPartition;\n\n  enum RemarkKind {\n    RK_Missing,            // Remark argument not present on the command line.\n    RK_Enabled,            // Remark enabled via '-Rgroup'.\n    RK_EnabledEverything,  // Remark enabled via '-Reverything'.\n    RK_Disabled,           // Remark disabled via '-Rno-group'.\n    RK_DisabledEverything, // Remark disabled via '-Rno-everything'.\n    RK_WithPattern,        // Remark pattern specified via '-Rgroup=regexp'.\n  };\n\n  /// Optimization remark with an optional regular expression pattern.\n  struct OptRemark {\n    RemarkKind Kind;\n    std::string Pattern;\n    std::shared_ptr<llvm::Regex> Regex;\n\n    /// By default, optimization remark is missing.\n    OptRemark() : Kind(RK_Missing), Pattern(\"\"), Regex(nullptr) {}\n\n    /// Returns true iff the optimization remark holds a valid regular\n    /// expression.\n    bool hasValidPattern() const { return Regex != nullptr; }\n\n    /// Matches the given string against the regex, if there is some.\n    bool patternMatches(StringRef String) const {\n      return hasValidPattern() && Regex->match(String);\n    }\n  };\n\n  /// Selected optimizations for which we should enable optimization remarks.\n  /// Transformation passes whose name matches the contained (optional) regular\n  /// expression (and support this feature), will emit a diagnostic whenever\n  /// they perform a transformation.\n  OptRemark OptimizationRemark;\n\n  /// Selected optimizations for which we should enable missed optimization\n  /// remarks. Transformation passes whose name matches the contained (optional)\n  /// regular expression (and support this feature), will emit a diagnostic\n  /// whenever they tried but failed to perform a transformation.\n  OptRemark OptimizationRemarkMissed;\n\n  /// Selected optimizations for which we should enable optimization analyses.\n  /// Transformation passes whose name matches the contained (optional) regular\n  /// expression (and support this feature), will emit a diagnostic whenever\n  /// they want to explain why they decided to apply or not apply a given\n  /// transformation.\n  OptRemark OptimizationRemarkAnalysis;\n\n  /// Set of files defining the rules for the symbol rewriting.\n  std::vector<std::string> RewriteMapFiles;\n\n  /// Set of sanitizer checks that are non-fatal (i.e. execution should be\n  /// continued when possible).\n  SanitizerSet SanitizeRecover;\n\n  /// Set of sanitizer checks that trap rather than diagnose.\n  SanitizerSet SanitizeTrap;\n\n  /// List of backend command-line options for -fembed-bitcode.\n  std::vector<uint8_t> CmdArgs;\n\n  /// A list of all -fno-builtin-* function names (e.g., memset).\n  std::vector<std::string> NoBuiltinFuncs;\n\n  std::vector<std::string> Reciprocals;\n\n  /// The preferred width for auto-vectorization transforms. This is intended to\n  /// override default transforms based on the width of the architected vector\n  /// registers.\n  std::string PreferVectorWidth;\n\n  /// Set of XRay instrumentation kinds to emit.\n  XRayInstrSet XRayInstrumentationBundle;\n\n  std::vector<std::string> DefaultFunctionAttrs;\n\n  /// List of dynamic shared object files to be loaded as pass plugins.\n  std::vector<std::string> PassPlugins;\n\n  /// Path to allowlist file specifying which objects\n  /// (files, functions) should exclusively be instrumented\n  /// by sanitizer coverage pass.\n  std::vector<std::string> SanitizeCoverageAllowlistFiles;\n\n  /// The guard style used for stack protector to get a initial value, this\n  /// value usually be gotten from TLS or get from __stack_chk_guard, or some\n  /// other styles we may implement in the future.\n  std::string StackProtectorGuard;\n\n  /// The TLS base register when StackProtectorGuard is \"tls\".\n  /// On x86 this can be \"fs\" or \"gs\".\n  std::string StackProtectorGuardReg;\n\n  /// Path to blocklist file specifying which objects\n  /// (files, functions) listed for instrumentation by sanitizer\n  /// coverage pass should actually not be instrumented.\n  std::vector<std::string> SanitizeCoverageBlocklistFiles;\n\n  /// Executable and command-line used to create a given CompilerInvocation.\n  /// Most of the time this will be the full -cc1 command.\n  const char *Argv0 = nullptr;\n  ArrayRef<const char *> CommandLineArgs;\n\n  /// The minimum hotness value a diagnostic needs in order to be included in\n  /// optimization diagnostics.\n  ///\n  /// The threshold is an Optional value, which maps to one of the 3 states:\n  /// 1. 0            => threshold disabled. All remarks will be printed.\n  /// 2. positive int => manual threshold by user. Remarks with hotness exceed\n  ///                    threshold will be printed.\n  /// 3. None         => 'auto' threshold by user. The actual value is not\n  ///                    available at command line, but will be synced with\n  ///                    hotness threshold from profile summary during\n  ///                    compilation.\n  ///\n  /// If threshold option is not specified, it is disabled by default.\n  Optional<uint64_t> DiagnosticsHotnessThreshold = 0;\n\npublic:\n  // Define accessors/mutators for code generation options of enumeration type.\n#define CODEGENOPT(Name, Bits, Default)\n#define ENUM_CODEGENOPT(Name, Type, Bits, Default) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/CodeGenOptions.def\"\n\n  CodeGenOptions();\n\n  const std::vector<std::string> &getNoBuiltinFuncs() const {\n    return NoBuiltinFuncs;\n  }\n\n  /// Check if Clang profile instrumenation is on.\n  bool hasProfileClangInstr() const {\n    return getProfileInstr() == ProfileClangInstr;\n  }\n\n  /// Check if IR level profile instrumentation is on.\n  bool hasProfileIRInstr() const {\n    return getProfileInstr() == ProfileIRInstr;\n  }\n\n  /// Check if CS IR level profile instrumentation is on.\n  bool hasProfileCSIRInstr() const {\n    return getProfileInstr() == ProfileCSIRInstr;\n  }\n\n  /// Check if Clang profile use is on.\n  bool hasProfileClangUse() const {\n    return getProfileUse() == ProfileClangInstr;\n  }\n\n  /// Check if IR level profile use is on.\n  bool hasProfileIRUse() const {\n    return getProfileUse() == ProfileIRInstr ||\n           getProfileUse() == ProfileCSIRInstr;\n  }\n\n  /// Check if CSIR profile use is on.\n  bool hasProfileCSIRUse() const { return getProfileUse() == ProfileCSIRInstr; }\n\n  /// Check if type and variable info should be emitted.\n  bool hasReducedDebugInfo() const {\n    return getDebugInfo() >= codegenoptions::DebugInfoConstructor;\n  }\n\n  /// Check if maybe unused type info should be emitted.\n  bool hasMaybeUnusedDebugInfo() const {\n    return getDebugInfo() >= codegenoptions::UnusedTypeInfo;\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "content": "//===- Diagnostic.h - C Language Family Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the Diagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTIC_H\n#define LLVM_CLANG_BASIC_DIAGNOSTIC_H\n\n#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\nclass Error;\n}\n\nnamespace clang {\n\nclass DeclContext;\nclass DiagnosticBuilder;\nclass DiagnosticConsumer;\nclass IdentifierInfo;\nclass LangOptions;\nclass Preprocessor;\nclass SourceManager;\nclass StoredDiagnostic;\n\nnamespace tok {\n\nenum TokenKind : unsigned short;\n\n} // namespace tok\n\n/// Annotates a diagnostic with some code that should be\n/// inserted, removed, or replaced to fix the problem.\n///\n/// This kind of hint should be used when we are certain that the\n/// introduction, removal, or modification of a particular (small!)\n/// amount of code will correct a compilation error. The compiler\n/// should also provide full recovery from such errors, such that\n/// suppressing the diagnostic output can still result in successful\n/// compilation.\nclass FixItHint {\npublic:\n  /// Code that should be replaced to correct the error. Empty for an\n  /// insertion hint.\n  CharSourceRange RemoveRange;\n\n  /// Code in the specific range that should be inserted in the insertion\n  /// location.\n  CharSourceRange InsertFromRange;\n\n  /// The actual code to insert at the insertion location, as a\n  /// string.\n  std::string CodeToInsert;\n\n  bool BeforePreviousInsertions = false;\n\n  /// Empty code modification hint, indicating that no code\n  /// modification is known.\n  FixItHint() = default;\n\n  bool isNull() const {\n    return !RemoveRange.isValid();\n  }\n\n  /// Create a code modification hint that inserts the given\n  /// code string at a specific location.\n  static FixItHint CreateInsertion(SourceLocation InsertionLoc,\n                                   StringRef Code,\n                                   bool BeforePreviousInsertions = false) {\n    FixItHint Hint;\n    Hint.RemoveRange =\n      CharSourceRange::getCharRange(InsertionLoc, InsertionLoc);\n    Hint.CodeToInsert = std::string(Code);\n    Hint.BeforePreviousInsertions = BeforePreviousInsertions;\n    return Hint;\n  }\n\n  /// Create a code modification hint that inserts the given\n  /// code from \\p FromRange at a specific location.\n  static FixItHint CreateInsertionFromRange(SourceLocation InsertionLoc,\n                                            CharSourceRange FromRange,\n                                        bool BeforePreviousInsertions = false) {\n    FixItHint Hint;\n    Hint.RemoveRange =\n      CharSourceRange::getCharRange(InsertionLoc, InsertionLoc);\n    Hint.InsertFromRange = FromRange;\n    Hint.BeforePreviousInsertions = BeforePreviousInsertions;\n    return Hint;\n  }\n\n  /// Create a code modification hint that removes the given\n  /// source range.\n  static FixItHint CreateRemoval(CharSourceRange RemoveRange) {\n    FixItHint Hint;\n    Hint.RemoveRange = RemoveRange;\n    return Hint;\n  }\n  static FixItHint CreateRemoval(SourceRange RemoveRange) {\n    return CreateRemoval(CharSourceRange::getTokenRange(RemoveRange));\n  }\n\n  /// Create a code modification hint that replaces the given\n  /// source range with the given code string.\n  static FixItHint CreateReplacement(CharSourceRange RemoveRange,\n                                     StringRef Code) {\n    FixItHint Hint;\n    Hint.RemoveRange = RemoveRange;\n    Hint.CodeToInsert = std::string(Code);\n    return Hint;\n  }\n\n  static FixItHint CreateReplacement(SourceRange RemoveRange,\n                                     StringRef Code) {\n    return CreateReplacement(CharSourceRange::getTokenRange(RemoveRange), Code);\n  }\n};\n\nstruct DiagnosticStorage {\n  enum {\n    /// The maximum number of arguments we can hold. We\n    /// currently only support up to 10 arguments (%0-%9).\n    ///\n    /// A single diagnostic with more than that almost certainly has to\n    /// be simplified anyway.\n    MaxArguments = 10\n  };\n\n  /// The number of entries in Arguments.\n  unsigned char NumDiagArgs = 0;\n\n  /// Specifies for each argument whether it is in DiagArgumentsStr\n  /// or in DiagArguments.\n  unsigned char DiagArgumentsKind[MaxArguments];\n\n  /// The values for the various substitution positions.\n  ///\n  /// This is used when the argument is not an std::string. The specific value\n  /// is mangled into an intptr_t and the interpretation depends on exactly\n  /// what sort of argument kind it is.\n  intptr_t DiagArgumentsVal[MaxArguments];\n\n  /// The values for the various substitution positions that have\n  /// string arguments.\n  std::string DiagArgumentsStr[MaxArguments];\n\n  /// The list of ranges added to this diagnostic.\n  SmallVector<CharSourceRange, 8> DiagRanges;\n\n  /// If valid, provides a hint with some code to insert, remove, or\n  /// modify at a particular position.\n  SmallVector<FixItHint, 6> FixItHints;\n\n  DiagnosticStorage() = default;\n};\n\n/// Concrete class used by the front-end to report problems and issues.\n///\n/// This massages the diagnostics (e.g. handling things like \"report warnings\n/// as errors\" and passes them off to the DiagnosticConsumer for reporting to\n/// the user. DiagnosticsEngine is tied to one translation unit and one\n/// SourceManager.\nclass DiagnosticsEngine : public RefCountedBase<DiagnosticsEngine> {\npublic:\n  /// The level of the diagnostic, after it has been through mapping.\n  enum Level {\n    Ignored = DiagnosticIDs::Ignored,\n    Note = DiagnosticIDs::Note,\n    Remark = DiagnosticIDs::Remark,\n    Warning = DiagnosticIDs::Warning,\n    Error = DiagnosticIDs::Error,\n    Fatal = DiagnosticIDs::Fatal\n  };\n\n  enum ArgumentKind {\n    /// std::string\n    ak_std_string,\n\n    /// const char *\n    ak_c_string,\n\n    /// int\n    ak_sint,\n\n    /// unsigned\n    ak_uint,\n\n    /// enum TokenKind : unsigned\n    ak_tokenkind,\n\n    /// IdentifierInfo\n    ak_identifierinfo,\n\n    /// address space\n    ak_addrspace,\n\n    /// Qualifiers\n    ak_qual,\n\n    /// QualType\n    ak_qualtype,\n\n    /// DeclarationName\n    ak_declarationname,\n\n    /// NamedDecl *\n    ak_nameddecl,\n\n    /// NestedNameSpecifier *\n    ak_nestednamespec,\n\n    /// DeclContext *\n    ak_declcontext,\n\n    /// pair<QualType, QualType>\n    ak_qualtype_pair,\n\n    /// Attr *\n    ak_attr\n  };\n\n  /// Represents on argument value, which is a union discriminated\n  /// by ArgumentKind, with a value.\n  using ArgumentValue = std::pair<ArgumentKind, intptr_t>;\n\nprivate:\n  // Used by __extension__\n  unsigned char AllExtensionsSilenced = 0;\n\n  // Treat fatal errors like errors.\n  bool FatalsAsError = false;\n\n  // Suppress all diagnostics.\n  bool SuppressAllDiagnostics = false;\n\n  // Elide common types of templates.\n  bool ElideType = true;\n\n  // Print a tree when comparing templates.\n  bool PrintTemplateTree = false;\n\n  // Color printing is enabled.\n  bool ShowColors = false;\n\n  // Which overload candidates to show.\n  OverloadsShown ShowOverloads = Ovl_All;\n\n  // With Ovl_Best, the number of overload candidates to show when we encounter\n  // an error.\n  //\n  // The value here is the number of candidates to show in the first nontrivial\n  // error.  Future errors may show a different number of candidates.\n  unsigned NumOverloadsToShow = 32;\n\n  // Cap of # errors emitted, 0 -> no limit.\n  unsigned ErrorLimit = 0;\n\n  // Cap on depth of template backtrace stack, 0 -> no limit.\n  unsigned TemplateBacktraceLimit = 0;\n\n  // Cap on depth of constexpr evaluation backtrace stack, 0 -> no limit.\n  unsigned ConstexprBacktraceLimit = 0;\n\n  IntrusiveRefCntPtr<DiagnosticIDs> Diags;\n  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts;\n  DiagnosticConsumer *Client = nullptr;\n  std::unique_ptr<DiagnosticConsumer> Owner;\n  SourceManager *SourceMgr = nullptr;\n\n  /// Mapping information for diagnostics.\n  ///\n  /// Mapping info is packed into four bits per diagnostic.  The low three\n  /// bits are the mapping (an instance of diag::Severity), or zero if unset.\n  /// The high bit is set when the mapping was established as a user mapping.\n  /// If the high bit is clear, then the low bits are set to the default\n  /// value, and should be mapped with -pedantic, -Werror, etc.\n  ///\n  /// A new DiagState is created and kept around when diagnostic pragmas modify\n  /// the state so that we know what is the diagnostic state at any given\n  /// source location.\n  class DiagState {\n    llvm::DenseMap<unsigned, DiagnosticMapping> DiagMap;\n\n  public:\n    // \"Global\" configuration state that can actually vary between modules.\n\n    // Ignore all warnings: -w\n    unsigned IgnoreAllWarnings : 1;\n\n    // Enable all warnings.\n    unsigned EnableAllWarnings : 1;\n\n    // Treat warnings like errors.\n    unsigned WarningsAsErrors : 1;\n\n    // Treat errors like fatal errors.\n    unsigned ErrorsAsFatal : 1;\n\n    // Suppress warnings in system headers.\n    unsigned SuppressSystemWarnings : 1;\n\n    // Map extensions to warnings or errors?\n    diag::Severity ExtBehavior = diag::Severity::Ignored;\n\n    DiagState()\n        : IgnoreAllWarnings(false), EnableAllWarnings(false),\n          WarningsAsErrors(false), ErrorsAsFatal(false),\n          SuppressSystemWarnings(false) {}\n\n    using iterator = llvm::DenseMap<unsigned, DiagnosticMapping>::iterator;\n    using const_iterator =\n        llvm::DenseMap<unsigned, DiagnosticMapping>::const_iterator;\n\n    void setMapping(diag::kind Diag, DiagnosticMapping Info) {\n      DiagMap[Diag] = Info;\n    }\n\n    DiagnosticMapping lookupMapping(diag::kind Diag) const {\n      return DiagMap.lookup(Diag);\n    }\n\n    DiagnosticMapping &getOrAddMapping(diag::kind Diag);\n\n    const_iterator begin() const { return DiagMap.begin(); }\n    const_iterator end() const { return DiagMap.end(); }\n  };\n\n  /// Keeps and automatically disposes all DiagStates that we create.\n  std::list<DiagState> DiagStates;\n\n  /// A mapping from files to the diagnostic states for those files. Lazily\n  /// built on demand for files in which the diagnostic state has not changed.\n  class DiagStateMap {\n  public:\n    /// Add an initial diagnostic state.\n    void appendFirst(DiagState *State);\n\n    /// Add a new latest state point.\n    void append(SourceManager &SrcMgr, SourceLocation Loc, DiagState *State);\n\n    /// Look up the diagnostic state at a given source location.\n    DiagState *lookup(SourceManager &SrcMgr, SourceLocation Loc) const;\n\n    /// Determine whether this map is empty.\n    bool empty() const { return Files.empty(); }\n\n    /// Clear out this map.\n    void clear() {\n      Files.clear();\n      FirstDiagState = CurDiagState = nullptr;\n      CurDiagStateLoc = SourceLocation();\n    }\n\n    /// Produce a debugging dump of the diagnostic state.\n    LLVM_DUMP_METHOD void dump(SourceManager &SrcMgr,\n                               StringRef DiagName = StringRef()) const;\n\n    /// Grab the most-recently-added state point.\n    DiagState *getCurDiagState() const { return CurDiagState; }\n\n    /// Get the location at which a diagnostic state was last added.\n    SourceLocation getCurDiagStateLoc() const { return CurDiagStateLoc; }\n\n  private:\n    friend class ASTReader;\n    friend class ASTWriter;\n\n    /// Represents a point in source where the diagnostic state was\n    /// modified because of a pragma.\n    ///\n    /// 'Loc' can be null if the point represents the diagnostic state\n    /// modifications done through the command-line.\n    struct DiagStatePoint {\n      DiagState *State;\n      unsigned Offset;\n\n      DiagStatePoint(DiagState *State, unsigned Offset)\n          : State(State), Offset(Offset) {}\n    };\n\n    /// Description of the diagnostic states and state transitions for a\n    /// particular FileID.\n    struct File {\n      /// The diagnostic state for the parent file. This is strictly redundant,\n      /// as looking up the DecomposedIncludedLoc for the FileID in the Files\n      /// map would give us this, but we cache it here for performance.\n      File *Parent = nullptr;\n\n      /// The offset of this file within its parent.\n      unsigned ParentOffset = 0;\n\n      /// Whether this file has any local (not imported from an AST file)\n      /// diagnostic state transitions.\n      bool HasLocalTransitions = false;\n\n      /// The points within the file where the state changes. There will always\n      /// be at least one of these (the state on entry to the file).\n      llvm::SmallVector<DiagStatePoint, 4> StateTransitions;\n\n      DiagState *lookup(unsigned Offset) const;\n    };\n\n    /// The diagnostic states for each file.\n    mutable std::map<FileID, File> Files;\n\n    /// The initial diagnostic state.\n    DiagState *FirstDiagState;\n\n    /// The current diagnostic state.\n    DiagState *CurDiagState;\n\n    /// The location at which the current diagnostic state was established.\n    SourceLocation CurDiagStateLoc;\n\n    /// Get the diagnostic state information for a file.\n    File *getFile(SourceManager &SrcMgr, FileID ID) const;\n  };\n\n  DiagStateMap DiagStatesByLoc;\n\n  /// Keeps the DiagState that was active during each diagnostic 'push'\n  /// so we can get back at it when we 'pop'.\n  std::vector<DiagState *> DiagStateOnPushStack;\n\n  DiagState *GetCurDiagState() const {\n    return DiagStatesByLoc.getCurDiagState();\n  }\n\n  void PushDiagStatePoint(DiagState *State, SourceLocation L);\n\n  /// Finds the DiagStatePoint that contains the diagnostic state of\n  /// the given source location.\n  DiagState *GetDiagStateForLoc(SourceLocation Loc) const {\n    return SourceMgr ? DiagStatesByLoc.lookup(*SourceMgr, Loc)\n                     : DiagStatesByLoc.getCurDiagState();\n  }\n\n  /// Sticky flag set to \\c true when an error is emitted.\n  bool ErrorOccurred;\n\n  /// Sticky flag set to \\c true when an \"uncompilable error\" occurs.\n  /// I.e. an error that was not upgraded from a warning by -Werror.\n  bool UncompilableErrorOccurred;\n\n  /// Sticky flag set to \\c true when a fatal error is emitted.\n  bool FatalErrorOccurred;\n\n  /// Indicates that an unrecoverable error has occurred.\n  bool UnrecoverableErrorOccurred;\n\n  /// Counts for DiagnosticErrorTrap to check whether an error occurred\n  /// during a parsing section, e.g. during parsing a function.\n  unsigned TrapNumErrorsOccurred;\n  unsigned TrapNumUnrecoverableErrorsOccurred;\n\n  /// The level of the last diagnostic emitted.\n  ///\n  /// This is used to emit continuation diagnostics with the same level as the\n  /// diagnostic that they follow.\n  DiagnosticIDs::Level LastDiagLevel;\n\n  /// Number of warnings reported\n  unsigned NumWarnings;\n\n  /// Number of errors reported\n  unsigned NumErrors;\n\n  /// A function pointer that converts an opaque diagnostic\n  /// argument to a strings.\n  ///\n  /// This takes the modifiers and argument that was present in the diagnostic.\n  ///\n  /// The PrevArgs array indicates the previous arguments formatted for this\n  /// diagnostic.  Implementations of this function can use this information to\n  /// avoid redundancy across arguments.\n  ///\n  /// This is a hack to avoid a layering violation between libbasic and libsema.\n  using ArgToStringFnTy = void (*)(\n      ArgumentKind Kind, intptr_t Val,\n      StringRef Modifier, StringRef Argument,\n      ArrayRef<ArgumentValue> PrevArgs,\n      SmallVectorImpl<char> &Output,\n      void *Cookie,\n      ArrayRef<intptr_t> QualTypeVals);\n\n  void *ArgToStringCookie = nullptr;\n  ArgToStringFnTy ArgToStringFn;\n\n  /// ID of the \"delayed\" diagnostic, which is a (typically\n  /// fatal) diagnostic that had to be delayed because it was found\n  /// while emitting another diagnostic.\n  unsigned DelayedDiagID;\n\n  /// First string argument for the delayed diagnostic.\n  std::string DelayedDiagArg1;\n\n  /// Second string argument for the delayed diagnostic.\n  std::string DelayedDiagArg2;\n\n  /// Third string argument for the delayed diagnostic.\n  std::string DelayedDiagArg3;\n\n  /// Optional flag value.\n  ///\n  /// Some flags accept values, for instance: -Wframe-larger-than=<value> and\n  /// -Rpass=<value>. The content of this string is emitted after the flag name\n  /// and '='.\n  std::string FlagValue;\n\npublic:\n  explicit DiagnosticsEngine(IntrusiveRefCntPtr<DiagnosticIDs> Diags,\n                             IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             DiagnosticConsumer *client = nullptr,\n                             bool ShouldOwnClient = true);\n  DiagnosticsEngine(const DiagnosticsEngine &) = delete;\n  DiagnosticsEngine &operator=(const DiagnosticsEngine &) = delete;\n  ~DiagnosticsEngine();\n\n  LLVM_DUMP_METHOD void dump() const;\n  LLVM_DUMP_METHOD void dump(StringRef DiagName) const;\n\n  const IntrusiveRefCntPtr<DiagnosticIDs> &getDiagnosticIDs() const {\n    return Diags;\n  }\n\n  /// Retrieve the diagnostic options.\n  DiagnosticOptions &getDiagnosticOptions() const { return *DiagOpts; }\n\n  using diag_mapping_range = llvm::iterator_range<DiagState::const_iterator>;\n\n  /// Get the current set of diagnostic mappings.\n  diag_mapping_range getDiagnosticMappings() const {\n    const DiagState &DS = *GetCurDiagState();\n    return diag_mapping_range(DS.begin(), DS.end());\n  }\n\n  DiagnosticConsumer *getClient() { return Client; }\n  const DiagnosticConsumer *getClient() const { return Client; }\n\n  /// Determine whether this \\c DiagnosticsEngine object own its client.\n  bool ownsClient() const { return Owner != nullptr; }\n\n  /// Return the current diagnostic client along with ownership of that\n  /// client.\n  std::unique_ptr<DiagnosticConsumer> takeClient() { return std::move(Owner); }\n\n  bool hasSourceManager() const { return SourceMgr != nullptr; }\n\n  SourceManager &getSourceManager() const {\n    assert(SourceMgr && \"SourceManager not set!\");\n    return *SourceMgr;\n  }\n\n  void setSourceManager(SourceManager *SrcMgr) {\n    assert(DiagStatesByLoc.empty() &&\n           \"Leftover diag state from a different SourceManager.\");\n    SourceMgr = SrcMgr;\n  }\n\n  //===--------------------------------------------------------------------===//\n  //  DiagnosticsEngine characterization methods, used by a client to customize\n  //  how diagnostics are emitted.\n  //\n\n  /// Copies the current DiagMappings and pushes the new copy\n  /// onto the top of the stack.\n  void pushMappings(SourceLocation Loc);\n\n  /// Pops the current DiagMappings off the top of the stack,\n  /// causing the new top of the stack to be the active mappings.\n  ///\n  /// \\returns \\c true if the pop happens, \\c false if there is only one\n  /// DiagMapping on the stack.\n  bool popMappings(SourceLocation Loc);\n\n  /// Set the diagnostic client associated with this diagnostic object.\n  ///\n  /// \\param ShouldOwnClient true if the diagnostic object should take\n  /// ownership of \\c client.\n  void setClient(DiagnosticConsumer *client, bool ShouldOwnClient = true);\n\n  /// Specify a limit for the number of errors we should\n  /// emit before giving up.\n  ///\n  /// Zero disables the limit.\n  void setErrorLimit(unsigned Limit) { ErrorLimit = Limit; }\n\n  /// Specify the maximum number of template instantiation\n  /// notes to emit along with a given diagnostic.\n  void setTemplateBacktraceLimit(unsigned Limit) {\n    TemplateBacktraceLimit = Limit;\n  }\n\n  /// Retrieve the maximum number of template instantiation\n  /// notes to emit along with a given diagnostic.\n  unsigned getTemplateBacktraceLimit() const {\n    return TemplateBacktraceLimit;\n  }\n\n  /// Specify the maximum number of constexpr evaluation\n  /// notes to emit along with a given diagnostic.\n  void setConstexprBacktraceLimit(unsigned Limit) {\n    ConstexprBacktraceLimit = Limit;\n  }\n\n  /// Retrieve the maximum number of constexpr evaluation\n  /// notes to emit along with a given diagnostic.\n  unsigned getConstexprBacktraceLimit() const {\n    return ConstexprBacktraceLimit;\n  }\n\n  /// When set to true, any unmapped warnings are ignored.\n  ///\n  /// If this and WarningsAsErrors are both set, then this one wins.\n  void setIgnoreAllWarnings(bool Val) {\n    GetCurDiagState()->IgnoreAllWarnings = Val;\n  }\n  bool getIgnoreAllWarnings() const {\n    return GetCurDiagState()->IgnoreAllWarnings;\n  }\n\n  /// When set to true, any unmapped ignored warnings are no longer\n  /// ignored.\n  ///\n  /// If this and IgnoreAllWarnings are both set, then that one wins.\n  void setEnableAllWarnings(bool Val) {\n    GetCurDiagState()->EnableAllWarnings = Val;\n  }\n  bool getEnableAllWarnings() const {\n    return GetCurDiagState()->EnableAllWarnings;\n  }\n\n  /// When set to true, any warnings reported are issued as errors.\n  void setWarningsAsErrors(bool Val) {\n    GetCurDiagState()->WarningsAsErrors = Val;\n  }\n  bool getWarningsAsErrors() const {\n    return GetCurDiagState()->WarningsAsErrors;\n  }\n\n  /// When set to true, any error reported is made a fatal error.\n  void setErrorsAsFatal(bool Val) { GetCurDiagState()->ErrorsAsFatal = Val; }\n  bool getErrorsAsFatal() const { return GetCurDiagState()->ErrorsAsFatal; }\n\n  /// \\brief When set to true, any fatal error reported is made an error.\n  ///\n  /// This setting takes precedence over the setErrorsAsFatal setting above.\n  void setFatalsAsError(bool Val) { FatalsAsError = Val; }\n  bool getFatalsAsError() const { return FatalsAsError; }\n\n  /// When set to true mask warnings that come from system headers.\n  void setSuppressSystemWarnings(bool Val) {\n    GetCurDiagState()->SuppressSystemWarnings = Val;\n  }\n  bool getSuppressSystemWarnings() const {\n    return GetCurDiagState()->SuppressSystemWarnings;\n  }\n\n  /// Suppress all diagnostics, to silence the front end when we\n  /// know that we don't want any more diagnostics to be passed along to the\n  /// client\n  void setSuppressAllDiagnostics(bool Val) { SuppressAllDiagnostics = Val; }\n  bool getSuppressAllDiagnostics() const { return SuppressAllDiagnostics; }\n\n  /// Set type eliding, to skip outputting same types occurring in\n  /// template types.\n  void setElideType(bool Val) { ElideType = Val; }\n  bool getElideType() { return ElideType; }\n\n  /// Set tree printing, to outputting the template difference in a\n  /// tree format.\n  void setPrintTemplateTree(bool Val) { PrintTemplateTree = Val; }\n  bool getPrintTemplateTree() { return PrintTemplateTree; }\n\n  /// Set color printing, so the type diffing will inject color markers\n  /// into the output.\n  void setShowColors(bool Val) { ShowColors = Val; }\n  bool getShowColors() { return ShowColors; }\n\n  /// Specify which overload candidates to show when overload resolution\n  /// fails.\n  ///\n  /// By default, we show all candidates.\n  void setShowOverloads(OverloadsShown Val) {\n    ShowOverloads = Val;\n  }\n  OverloadsShown getShowOverloads() const { return ShowOverloads; }\n\n  /// When a call or operator fails, print out up to this many candidate\n  /// overloads as suggestions.\n  ///\n  /// With Ovl_Best, we set a high limit for the first nontrivial overload set\n  /// we print, and a lower limit for later sets.  This way the user has a\n  /// chance of diagnosing at least one callsite in their program without\n  /// having to recompile with -fshow-overloads=all.\n  unsigned getNumOverloadCandidatesToShow() const {\n    switch (getShowOverloads()) {\n    case Ovl_All:\n      // INT_MAX rather than UINT_MAX so that we don't have to think about the\n      // effect of implicit conversions on this value. In practice we'll never\n      // hit 2^31 candidates anyway.\n      return std::numeric_limits<int>::max();\n    case Ovl_Best:\n      return NumOverloadsToShow;\n    }\n    llvm_unreachable(\"invalid OverloadsShown kind\");\n  }\n\n  /// Call this after showing N overload candidates.  This influences the value\n  /// returned by later calls to getNumOverloadCandidatesToShow().\n  void overloadCandidatesShown(unsigned N) {\n    // Current heuristic: Start out with a large value for NumOverloadsToShow,\n    // and then once we print one nontrivially-large overload set, decrease it\n    // for future calls.\n    if (N > 4) {\n      NumOverloadsToShow = 4;\n    }\n  }\n\n  /// Pretend that the last diagnostic issued was ignored, so any\n  /// subsequent notes will be suppressed, or restore a prior ignoring\n  /// state after ignoring some diagnostics and their notes, possibly in\n  /// the middle of another diagnostic.\n  ///\n  /// This can be used by clients who suppress diagnostics themselves.\n  void setLastDiagnosticIgnored(bool Ignored) {\n    if (LastDiagLevel == DiagnosticIDs::Fatal)\n      FatalErrorOccurred = true;\n    LastDiagLevel = Ignored ? DiagnosticIDs::Ignored : DiagnosticIDs::Warning;\n  }\n\n  /// Determine whether the previous diagnostic was ignored. This can\n  /// be used by clients that want to determine whether notes attached to a\n  /// diagnostic will be suppressed.\n  bool isLastDiagnosticIgnored() const {\n    return LastDiagLevel == DiagnosticIDs::Ignored;\n  }\n\n  /// Controls whether otherwise-unmapped extension diagnostics are\n  /// mapped onto ignore/warning/error.\n  ///\n  /// This corresponds to the GCC -pedantic and -pedantic-errors option.\n  void setExtensionHandlingBehavior(diag::Severity H) {\n    GetCurDiagState()->ExtBehavior = H;\n  }\n  diag::Severity getExtensionHandlingBehavior() const {\n    return GetCurDiagState()->ExtBehavior;\n  }\n\n  /// Counter bumped when an __extension__  block is/ encountered.\n  ///\n  /// When non-zero, all extension diagnostics are entirely silenced, no\n  /// matter how they are mapped.\n  void IncrementAllExtensionsSilenced() { ++AllExtensionsSilenced; }\n  void DecrementAllExtensionsSilenced() { --AllExtensionsSilenced; }\n  bool hasAllExtensionsSilenced() { return AllExtensionsSilenced != 0; }\n\n  /// This allows the client to specify that certain warnings are\n  /// ignored.\n  ///\n  /// Notes can never be mapped, errors can only be mapped to fatal, and\n  /// WARNINGs and EXTENSIONs can be mapped arbitrarily.\n  ///\n  /// \\param Loc The source location that this change of diagnostic state should\n  /// take affect. It can be null if we are setting the latest state.\n  void setSeverity(diag::kind Diag, diag::Severity Map, SourceLocation Loc);\n\n  /// Change an entire diagnostic group (e.g. \"unknown-pragmas\") to\n  /// have the specified mapping.\n  ///\n  /// \\returns true (and ignores the request) if \"Group\" was unknown, false\n  /// otherwise.\n  ///\n  /// \\param Flavor The flavor of group to affect. -Rfoo does not affect the\n  /// state of the -Wfoo group and vice versa.\n  ///\n  /// \\param Loc The source location that this change of diagnostic state should\n  /// take affect. It can be null if we are setting the state from command-line.\n  bool setSeverityForGroup(diag::Flavor Flavor, StringRef Group,\n                           diag::Severity Map,\n                           SourceLocation Loc = SourceLocation());\n\n  /// Set the warning-as-error flag for the given diagnostic group.\n  ///\n  /// This function always only operates on the current diagnostic state.\n  ///\n  /// \\returns True if the given group is unknown, false otherwise.\n  bool setDiagnosticGroupWarningAsError(StringRef Group, bool Enabled);\n\n  /// Set the error-as-fatal flag for the given diagnostic group.\n  ///\n  /// This function always only operates on the current diagnostic state.\n  ///\n  /// \\returns True if the given group is unknown, false otherwise.\n  bool setDiagnosticGroupErrorAsFatal(StringRef Group, bool Enabled);\n\n  /// Add the specified mapping to all diagnostics of the specified\n  /// flavor.\n  ///\n  /// Mainly to be used by -Wno-everything to disable all warnings but allow\n  /// subsequent -W options to enable specific warnings.\n  void setSeverityForAll(diag::Flavor Flavor, diag::Severity Map,\n                         SourceLocation Loc = SourceLocation());\n\n  bool hasErrorOccurred() const { return ErrorOccurred; }\n\n  /// Errors that actually prevent compilation, not those that are\n  /// upgraded from a warning by -Werror.\n  bool hasUncompilableErrorOccurred() const {\n    return UncompilableErrorOccurred;\n  }\n  bool hasFatalErrorOccurred() const { return FatalErrorOccurred; }\n\n  /// Determine whether any kind of unrecoverable error has occurred.\n  bool hasUnrecoverableErrorOccurred() const {\n    return FatalErrorOccurred || UnrecoverableErrorOccurred;\n  }\n\n  unsigned getNumErrors() const { return NumErrors; }\n  unsigned getNumWarnings() const { return NumWarnings; }\n\n  void setNumWarnings(unsigned NumWarnings) {\n    this->NumWarnings = NumWarnings;\n  }\n\n  /// Return an ID for a diagnostic with the specified format string and\n  /// level.\n  ///\n  /// If this is the first request for this diagnostic, it is registered and\n  /// created, otherwise the existing ID is returned.\n  ///\n  /// \\param FormatString A fixed diagnostic format string that will be hashed\n  /// and mapped to a unique DiagID.\n  template <unsigned N>\n  unsigned getCustomDiagID(Level L, const char (&FormatString)[N]) {\n    return Diags->getCustomDiagID((DiagnosticIDs::Level)L,\n                                  StringRef(FormatString, N - 1));\n  }\n\n  /// Converts a diagnostic argument (as an intptr_t) into the string\n  /// that represents it.\n  void ConvertArgToString(ArgumentKind Kind, intptr_t Val,\n                          StringRef Modifier, StringRef Argument,\n                          ArrayRef<ArgumentValue> PrevArgs,\n                          SmallVectorImpl<char> &Output,\n                          ArrayRef<intptr_t> QualTypeVals) const {\n    ArgToStringFn(Kind, Val, Modifier, Argument, PrevArgs, Output,\n                  ArgToStringCookie, QualTypeVals);\n  }\n\n  void SetArgToStringFn(ArgToStringFnTy Fn, void *Cookie) {\n    ArgToStringFn = Fn;\n    ArgToStringCookie = Cookie;\n  }\n\n  /// Note that the prior diagnostic was emitted by some other\n  /// \\c DiagnosticsEngine, and we may be attaching a note to that diagnostic.\n  void notePriorDiagnosticFrom(const DiagnosticsEngine &Other) {\n    LastDiagLevel = Other.LastDiagLevel;\n  }\n\n  /// Reset the state of the diagnostic object to its initial\n  /// configuration.\n  void Reset();\n\n  //===--------------------------------------------------------------------===//\n  // DiagnosticsEngine classification and reporting interfaces.\n  //\n\n  /// Determine whether the diagnostic is known to be ignored.\n  ///\n  /// This can be used to opportunistically avoid expensive checks when it's\n  /// known for certain that the diagnostic has been suppressed at the\n  /// specified location \\p Loc.\n  ///\n  /// \\param Loc The source location we are interested in finding out the\n  /// diagnostic state. Can be null in order to query the latest state.\n  bool isIgnored(unsigned DiagID, SourceLocation Loc) const {\n    return Diags->getDiagnosticSeverity(DiagID, Loc, *this) ==\n           diag::Severity::Ignored;\n  }\n\n  /// Based on the way the client configured the DiagnosticsEngine\n  /// object, classify the specified diagnostic ID into a Level, consumable by\n  /// the DiagnosticConsumer.\n  ///\n  /// To preserve invariant assumptions, this function should not be used to\n  /// influence parse or semantic analysis actions. Instead consider using\n  /// \\c isIgnored().\n  ///\n  /// \\param Loc The source location we are interested in finding out the\n  /// diagnostic state. Can be null in order to query the latest state.\n  Level getDiagnosticLevel(unsigned DiagID, SourceLocation Loc) const {\n    return (Level)Diags->getDiagnosticLevel(DiagID, Loc, *this);\n  }\n\n  /// Issue the message to the client.\n  ///\n  /// This actually returns an instance of DiagnosticBuilder which emits the\n  /// diagnostics (through @c ProcessDiag) when it is destroyed.\n  ///\n  /// \\param DiagID A member of the @c diag::kind enum.\n  /// \\param Loc Represents the source location associated with the diagnostic,\n  /// which can be an invalid location if no position information is available.\n  inline DiagnosticBuilder Report(SourceLocation Loc, unsigned DiagID);\n  inline DiagnosticBuilder Report(unsigned DiagID);\n\n  void Report(const StoredDiagnostic &storedDiag);\n\n  /// Determine whethere there is already a diagnostic in flight.\n  bool isDiagnosticInFlight() const {\n    return CurDiagID != std::numeric_limits<unsigned>::max();\n  }\n\n  /// Set the \"delayed\" diagnostic that will be emitted once\n  /// the current diagnostic completes.\n  ///\n  ///  If a diagnostic is already in-flight but the front end must\n  ///  report a problem (e.g., with an inconsistent file system\n  ///  state), this routine sets a \"delayed\" diagnostic that will be\n  ///  emitted after the current diagnostic completes. This should\n  ///  only be used for fatal errors detected at inconvenient\n  ///  times. If emitting a delayed diagnostic causes a second delayed\n  ///  diagnostic to be introduced, that second delayed diagnostic\n  ///  will be ignored.\n  ///\n  /// \\param DiagID The ID of the diagnostic being delayed.\n  ///\n  /// \\param Arg1 A string argument that will be provided to the\n  /// diagnostic. A copy of this string will be stored in the\n  /// DiagnosticsEngine object itself.\n  ///\n  /// \\param Arg2 A string argument that will be provided to the\n  /// diagnostic. A copy of this string will be stored in the\n  /// DiagnosticsEngine object itself.\n  ///\n  /// \\param Arg3 A string argument that will be provided to the\n  /// diagnostic. A copy of this string will be stored in the\n  /// DiagnosticsEngine object itself.\n  void SetDelayedDiagnostic(unsigned DiagID, StringRef Arg1 = \"\",\n                            StringRef Arg2 = \"\", StringRef Arg3 = \"\");\n\n  /// Clear out the current diagnostic.\n  void Clear() { CurDiagID = std::numeric_limits<unsigned>::max(); }\n\n  /// Return the value associated with this diagnostic flag.\n  StringRef getFlagValue() const { return FlagValue; }\n\nprivate:\n  // This is private state used by DiagnosticBuilder.  We put it here instead of\n  // in DiagnosticBuilder in order to keep DiagnosticBuilder a small lightweight\n  // object.  This implementation choice means that we can only have one\n  // diagnostic \"in flight\" at a time, but this seems to be a reasonable\n  // tradeoff to keep these objects small.  Assertions verify that only one\n  // diagnostic is in flight at a time.\n  friend class Diagnostic;\n  friend class DiagnosticBuilder;\n  friend class DiagnosticErrorTrap;\n  friend class DiagnosticIDs;\n  friend class PartialDiagnostic;\n\n  /// Report the delayed diagnostic.\n  void ReportDelayed();\n\n  /// The location of the current diagnostic that is in flight.\n  SourceLocation CurDiagLoc;\n\n  /// The ID of the current diagnostic that is in flight.\n  ///\n  /// This is set to std::numeric_limits<unsigned>::max() when there is no\n  /// diagnostic in flight.\n  unsigned CurDiagID;\n\n  enum {\n    /// The maximum number of arguments we can hold.\n    ///\n    /// We currently only support up to 10 arguments (%0-%9).  A single\n    /// diagnostic with more than that almost certainly has to be simplified\n    /// anyway.\n    MaxArguments = DiagnosticStorage::MaxArguments,\n  };\n\n  DiagnosticStorage DiagStorage;\n\n  DiagnosticMapping makeUserMapping(diag::Severity Map, SourceLocation L) {\n    bool isPragma = L.isValid();\n    DiagnosticMapping Mapping =\n        DiagnosticMapping::Make(Map, /*IsUser=*/true, isPragma);\n\n    // If this is a pragma mapping, then set the diagnostic mapping flags so\n    // that we override command line options.\n    if (isPragma) {\n      Mapping.setNoWarningAsError(true);\n      Mapping.setNoErrorAsFatal(true);\n    }\n\n    return Mapping;\n  }\n\n  /// Used to report a diagnostic that is finally fully formed.\n  ///\n  /// \\returns true if the diagnostic was emitted, false if it was suppressed.\n  bool ProcessDiag() {\n    return Diags->ProcessDiag(*this);\n  }\n\n  /// @name Diagnostic Emission\n  /// @{\nprotected:\n  friend class ASTReader;\n  friend class ASTWriter;\n\n  // Sema requires access to the following functions because the current design\n  // of SFINAE requires it to use its own SemaDiagnosticBuilder, which needs to\n  // access us directly to ensure we minimize the emitted code for the common\n  // Sema::Diag() patterns.\n  friend class Sema;\n\n  /// Emit the current diagnostic and clear the diagnostic state.\n  ///\n  /// \\param Force Emit the diagnostic regardless of suppression settings.\n  bool EmitCurrentDiagnostic(bool Force = false);\n\n  unsigned getCurrentDiagID() const { return CurDiagID; }\n\n  SourceLocation getCurrentDiagLoc() const { return CurDiagLoc; }\n\n  /// @}\n};\n\n/// RAII class that determines when any errors have occurred\n/// between the time the instance was created and the time it was\n/// queried.\n///\n/// Note that you almost certainly do not want to use this. It's usually\n/// meaningless to ask whether a particular scope triggered an error message,\n/// because error messages outside that scope can mark things invalid (or cause\n/// us to reach an error limit), which can suppress errors within that scope.\nclass DiagnosticErrorTrap {\n  DiagnosticsEngine &Diag;\n  unsigned NumErrors;\n  unsigned NumUnrecoverableErrors;\n\npublic:\n  explicit DiagnosticErrorTrap(DiagnosticsEngine &Diag)\n      : Diag(Diag) { reset(); }\n\n  /// Determine whether any errors have occurred since this\n  /// object instance was created.\n  bool hasErrorOccurred() const {\n    return Diag.TrapNumErrorsOccurred > NumErrors;\n  }\n\n  /// Determine whether any unrecoverable errors have occurred since this\n  /// object instance was created.\n  bool hasUnrecoverableErrorOccurred() const {\n    return Diag.TrapNumUnrecoverableErrorsOccurred > NumUnrecoverableErrors;\n  }\n\n  /// Set to initial state of \"no errors occurred\".\n  void reset() {\n    NumErrors = Diag.TrapNumErrorsOccurred;\n    NumUnrecoverableErrors = Diag.TrapNumUnrecoverableErrorsOccurred;\n  }\n};\n\n/// The streaming interface shared between DiagnosticBuilder and\n/// PartialDiagnostic. This class is not intended to be constructed directly\n/// but only as base class of DiagnosticBuilder and PartialDiagnostic builder.\n///\n/// Any new type of argument accepted by DiagnosticBuilder and PartialDiagnostic\n/// should be implemented as a '<<' operator of StreamingDiagnostic, e.g.\n///\n/// const StreamingDiagnostic&\n/// operator<<(const StreamingDiagnostic&, NewArgType);\n///\nclass StreamingDiagnostic {\npublic:\n  /// An allocator for DiagnosticStorage objects, which uses a small cache to\n  /// objects, used to reduce malloc()/free() traffic for partial diagnostics.\n  class DiagStorageAllocator {\n    static const unsigned NumCached = 16;\n    DiagnosticStorage Cached[NumCached];\n    DiagnosticStorage *FreeList[NumCached];\n    unsigned NumFreeListEntries;\n\n  public:\n    DiagStorageAllocator();\n    ~DiagStorageAllocator();\n\n    /// Allocate new storage.\n    DiagnosticStorage *Allocate() {\n      if (NumFreeListEntries == 0)\n        return new DiagnosticStorage;\n\n      DiagnosticStorage *Result = FreeList[--NumFreeListEntries];\n      Result->NumDiagArgs = 0;\n      Result->DiagRanges.clear();\n      Result->FixItHints.clear();\n      return Result;\n    }\n\n    /// Free the given storage object.\n    void Deallocate(DiagnosticStorage *S) {\n      if (S >= Cached && S <= Cached + NumCached) {\n        FreeList[NumFreeListEntries++] = S;\n        return;\n      }\n\n      delete S;\n    }\n  };\n\nprotected:\n  mutable DiagnosticStorage *DiagStorage = nullptr;\n\n  /// Allocator used to allocate storage for this diagnostic.\n  DiagStorageAllocator *Allocator = nullptr;\n\npublic:\n  /// Retrieve storage for this particular diagnostic.\n  DiagnosticStorage *getStorage() const {\n    if (DiagStorage)\n      return DiagStorage;\n\n    assert(Allocator);\n    DiagStorage = Allocator->Allocate();\n    return DiagStorage;\n  }\n\n  void freeStorage() {\n    if (!DiagStorage)\n      return;\n\n    // The hot path for PartialDiagnostic is when we just used it to wrap an ID\n    // (typically so we have the flexibility of passing a more complex\n    // diagnostic into the callee, but that does not commonly occur).\n    //\n    // Split this out into a slow function for silly compilers (*cough*) which\n    // can't do decent partial inlining.\n    freeStorageSlow();\n  }\n\n  void freeStorageSlow() {\n    if (!Allocator)\n      return;\n    Allocator->Deallocate(DiagStorage);\n    DiagStorage = nullptr;\n  }\n\n  void AddTaggedVal(intptr_t V, DiagnosticsEngine::ArgumentKind Kind) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    assert(DiagStorage->NumDiagArgs < DiagnosticStorage::MaxArguments &&\n           \"Too many arguments to diagnostic!\");\n    DiagStorage->DiagArgumentsKind[DiagStorage->NumDiagArgs] = Kind;\n    DiagStorage->DiagArgumentsVal[DiagStorage->NumDiagArgs++] = V;\n  }\n\n  void AddString(StringRef V) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    assert(DiagStorage->NumDiagArgs < DiagnosticStorage::MaxArguments &&\n           \"Too many arguments to diagnostic!\");\n    DiagStorage->DiagArgumentsKind[DiagStorage->NumDiagArgs] =\n        DiagnosticsEngine::ak_std_string;\n    DiagStorage->DiagArgumentsStr[DiagStorage->NumDiagArgs++] = std::string(V);\n  }\n\n  void AddSourceRange(const CharSourceRange &R) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    DiagStorage->DiagRanges.push_back(R);\n  }\n\n  void AddFixItHint(const FixItHint &Hint) const {\n    if (Hint.isNull())\n      return;\n\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    DiagStorage->FixItHints.push_back(Hint);\n  }\n\n  /// Conversion of StreamingDiagnostic to bool always returns \\c true.\n  ///\n  /// This allows is to be used in boolean error contexts (where \\c true is\n  /// used to indicate that an error has occurred), like:\n  /// \\code\n  /// return Diag(...);\n  /// \\endcode\n  operator bool() const { return true; }\n\nprotected:\n  StreamingDiagnostic() = default;\n\n  /// Construct with an external storage not owned by itself. The allocator\n  /// is a null pointer in this case.\n  explicit StreamingDiagnostic(DiagnosticStorage *Storage)\n      : DiagStorage(Storage) {}\n\n  /// Construct with a storage allocator which will manage the storage. The\n  /// allocator is not a null pointer in this case.\n  explicit StreamingDiagnostic(DiagStorageAllocator &Alloc)\n      : Allocator(&Alloc) {}\n\n  StreamingDiagnostic(const StreamingDiagnostic &Diag) = default;\n  StreamingDiagnostic(StreamingDiagnostic &&Diag) = default;\n\n  ~StreamingDiagnostic() { freeStorage(); }\n};\n\n//===----------------------------------------------------------------------===//\n// DiagnosticBuilder\n//===----------------------------------------------------------------------===//\n\n/// A little helper class used to produce diagnostics.\n///\n/// This is constructed by the DiagnosticsEngine::Report method, and\n/// allows insertion of extra information (arguments and source ranges) into\n/// the currently \"in flight\" diagnostic.  When the temporary for the builder\n/// is destroyed, the diagnostic is issued.\n///\n/// Note that many of these will be created as temporary objects (many call\n/// sites), so we want them to be small and we never want their address taken.\n/// This ensures that compilers with somewhat reasonable optimizers will promote\n/// the common fields to registers, eliminating increments of the NumArgs field,\n/// for example.\nclass DiagnosticBuilder : public StreamingDiagnostic {\n  friend class DiagnosticsEngine;\n  friend class PartialDiagnostic;\n\n  mutable DiagnosticsEngine *DiagObj = nullptr;\n\n  /// Status variable indicating if this diagnostic is still active.\n  ///\n  // NOTE: This field is redundant with DiagObj (IsActive iff (DiagObj == 0)),\n  // but LLVM is not currently smart enough to eliminate the null check that\n  // Emit() would end up with if we used that as our status variable.\n  mutable bool IsActive = false;\n\n  /// Flag indicating that this diagnostic is being emitted via a\n  /// call to ForceEmit.\n  mutable bool IsForceEmit = false;\n\n  DiagnosticBuilder() = default;\n\n  explicit DiagnosticBuilder(DiagnosticsEngine *diagObj)\n      : StreamingDiagnostic(&diagObj->DiagStorage), DiagObj(diagObj),\n        IsActive(true) {\n    assert(diagObj && \"DiagnosticBuilder requires a valid DiagnosticsEngine!\");\n    assert(DiagStorage &&\n           \"DiagnosticBuilder requires a valid DiagnosticStorage!\");\n    DiagStorage->NumDiagArgs = 0;\n    DiagStorage->DiagRanges.clear();\n    DiagStorage->FixItHints.clear();\n  }\n\nprotected:\n  /// Clear out the current diagnostic.\n  void Clear() const {\n    DiagObj = nullptr;\n    IsActive = false;\n    IsForceEmit = false;\n  }\n\n  /// Determine whether this diagnostic is still active.\n  bool isActive() const { return IsActive; }\n\n  /// Force the diagnostic builder to emit the diagnostic now.\n  ///\n  /// Once this function has been called, the DiagnosticBuilder object\n  /// should not be used again before it is destroyed.\n  ///\n  /// \\returns true if a diagnostic was emitted, false if the\n  /// diagnostic was suppressed.\n  bool Emit() {\n    // If this diagnostic is inactive, then its soul was stolen by the copy ctor\n    // (or by a subclass, as in SemaDiagnosticBuilder).\n    if (!isActive()) return false;\n\n    // Process the diagnostic.\n    bool Result = DiagObj->EmitCurrentDiagnostic(IsForceEmit);\n\n    // This diagnostic is dead.\n    Clear();\n\n    return Result;\n  }\n\npublic:\n  /// Copy constructor.  When copied, this \"takes\" the diagnostic info from the\n  /// input and neuters it.\n  DiagnosticBuilder(const DiagnosticBuilder &D) : StreamingDiagnostic() {\n    DiagObj = D.DiagObj;\n    DiagStorage = D.DiagStorage;\n    IsActive = D.IsActive;\n    IsForceEmit = D.IsForceEmit;\n    D.Clear();\n  }\n\n  template <typename T> const DiagnosticBuilder &operator<<(const T &V) const {\n    assert(isActive() && \"Clients must not add to cleared diagnostic!\");\n    const StreamingDiagnostic &DB = *this;\n    DB << V;\n    return *this;\n  }\n\n  // It is necessary to limit this to rvalue reference to avoid calling this\n  // function with a bitfield lvalue argument since non-const reference to\n  // bitfield is not allowed.\n  template <typename T, typename = typename std::enable_if<\n                            !std::is_lvalue_reference<T>::value>::type>\n  const DiagnosticBuilder &operator<<(T &&V) const {\n    assert(isActive() && \"Clients must not add to cleared diagnostic!\");\n    const StreamingDiagnostic &DB = *this;\n    DB << std::move(V);\n    return *this;\n  }\n\n  DiagnosticBuilder &operator=(const DiagnosticBuilder &) = delete;\n\n  /// Emits the diagnostic.\n  ~DiagnosticBuilder() { Emit(); }\n\n  /// Forces the diagnostic to be emitted.\n  const DiagnosticBuilder &setForceEmit() const {\n    IsForceEmit = true;\n    return *this;\n  }\n\n  void addFlagValue(StringRef V) const { DiagObj->FlagValue = std::string(V); }\n};\n\nstruct AddFlagValue {\n  StringRef Val;\n\n  explicit AddFlagValue(StringRef V) : Val(V) {}\n};\n\n/// Register a value for the flag in the current diagnostic. This\n/// value will be shown as the suffix \"=value\" after the flag name. It is\n/// useful in cases where the diagnostic flag accepts values (e.g.,\n/// -Rpass or -Wframe-larger-than).\ninline const DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB,\n                                           const AddFlagValue V) {\n  DB.addFlagValue(V.Val);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             StringRef S) {\n  DB.AddString(S);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const char *Str) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(Str),\n                  DiagnosticsEngine::ak_c_string);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             int I) {\n  DB.AddTaggedVal(I, DiagnosticsEngine::ak_sint);\n  return DB;\n}\n\n// We use enable_if here to prevent that this overload is selected for\n// pointers or other arguments that are implicitly convertible to bool.\ntemplate <typename T>\ninline std::enable_if_t<std::is_same<T, bool>::value,\n                        const StreamingDiagnostic &>\noperator<<(const StreamingDiagnostic &DB, T I) {\n  DB.AddTaggedVal(I, DiagnosticsEngine::ak_sint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             unsigned I) {\n  DB.AddTaggedVal(I, DiagnosticsEngine::ak_uint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             tok::TokenKind I) {\n  DB.AddTaggedVal(static_cast<unsigned>(I), DiagnosticsEngine::ak_tokenkind);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const IdentifierInfo *II) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(II),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n// Adds a DeclContext to the diagnostic. The enable_if template magic is here\n// so that we only match those arguments that are (statically) DeclContexts;\n// other arguments that derive from DeclContext (e.g., RecordDecls) will not\n// match.\ntemplate <typename T>\ninline std::enable_if_t<\n    std::is_same<std::remove_const_t<T>, DeclContext>::value,\n    const StreamingDiagnostic &>\noperator<<(const StreamingDiagnostic &DB, T *DC) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(DC),\n                  DiagnosticsEngine::ak_declcontext);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             SourceRange R) {\n  DB.AddSourceRange(CharSourceRange::getTokenRange(R));\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             ArrayRef<SourceRange> Ranges) {\n  for (SourceRange R : Ranges)\n    DB.AddSourceRange(CharSourceRange::getTokenRange(R));\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const CharSourceRange &R) {\n  DB.AddSourceRange(R);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const FixItHint &Hint) {\n  DB.AddFixItHint(Hint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             ArrayRef<FixItHint> Hints) {\n  for (const FixItHint &Hint : Hints)\n    DB.AddFixItHint(Hint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &\noperator<<(const StreamingDiagnostic &DB,\n           const llvm::Optional<SourceRange> &Opt) {\n  if (Opt)\n    DB << *Opt;\n  return DB;\n}\n\ninline const StreamingDiagnostic &\noperator<<(const StreamingDiagnostic &DB,\n           const llvm::Optional<CharSourceRange> &Opt) {\n  if (Opt)\n    DB << *Opt;\n  return DB;\n}\n\ninline const StreamingDiagnostic &\noperator<<(const StreamingDiagnostic &DB,\n           const llvm::Optional<FixItHint> &Opt) {\n  if (Opt)\n    DB << *Opt;\n  return DB;\n}\n\n/// A nullability kind paired with a bit indicating whether it used a\n/// context-sensitive keyword.\nusing DiagNullabilityKind = std::pair<NullabilityKind, bool>;\n\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      DiagNullabilityKind nullability);\n\ninline DiagnosticBuilder DiagnosticsEngine::Report(SourceLocation Loc,\n                                                   unsigned DiagID) {\n  assert(CurDiagID == std::numeric_limits<unsigned>::max() &&\n         \"Multiple diagnostics in flight at once!\");\n  CurDiagLoc = Loc;\n  CurDiagID = DiagID;\n  FlagValue.clear();\n  return DiagnosticBuilder(this);\n}\n\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      llvm::Error &&E);\n\ninline DiagnosticBuilder DiagnosticsEngine::Report(unsigned DiagID) {\n  return Report(SourceLocation(), DiagID);\n}\n\n//===----------------------------------------------------------------------===//\n// Diagnostic\n//===----------------------------------------------------------------------===//\n\n/// A little helper class (which is basically a smart pointer that forwards\n/// info from DiagnosticsEngine) that allows clients to enquire about the\n/// currently in-flight diagnostic.\nclass Diagnostic {\n  const DiagnosticsEngine *DiagObj;\n  StringRef StoredDiagMessage;\n\npublic:\n  explicit Diagnostic(const DiagnosticsEngine *DO) : DiagObj(DO) {}\n  Diagnostic(const DiagnosticsEngine *DO, StringRef storedDiagMessage)\n      : DiagObj(DO), StoredDiagMessage(storedDiagMessage) {}\n\n  const DiagnosticsEngine *getDiags() const { return DiagObj; }\n  unsigned getID() const { return DiagObj->CurDiagID; }\n  const SourceLocation &getLocation() const { return DiagObj->CurDiagLoc; }\n  bool hasSourceManager() const { return DiagObj->hasSourceManager(); }\n  SourceManager &getSourceManager() const { return DiagObj->getSourceManager();}\n\n  unsigned getNumArgs() const { return DiagObj->DiagStorage.NumDiagArgs; }\n\n  /// Return the kind of the specified index.\n  ///\n  /// Based on the kind of argument, the accessors below can be used to get\n  /// the value.\n  ///\n  /// \\pre Idx < getNumArgs()\n  DiagnosticsEngine::ArgumentKind getArgKind(unsigned Idx) const {\n    assert(Idx < getNumArgs() && \"Argument index out of range!\");\n    return (DiagnosticsEngine::ArgumentKind)\n        DiagObj->DiagStorage.DiagArgumentsKind[Idx];\n  }\n\n  /// Return the provided argument string specified by \\p Idx.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_std_string\n  const std::string &getArgStdStr(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_std_string &&\n           \"invalid argument accessor!\");\n    return DiagObj->DiagStorage.DiagArgumentsStr[Idx];\n  }\n\n  /// Return the specified C string argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_c_string\n  const char *getArgCStr(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_c_string &&\n           \"invalid argument accessor!\");\n    return reinterpret_cast<const char *>(\n        DiagObj->DiagStorage.DiagArgumentsVal[Idx]);\n  }\n\n  /// Return the specified signed integer argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_sint\n  int getArgSInt(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_sint &&\n           \"invalid argument accessor!\");\n    return (int)DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the specified unsigned integer argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_uint\n  unsigned getArgUInt(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_uint &&\n           \"invalid argument accessor!\");\n    return (unsigned)DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the specified IdentifierInfo argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_identifierinfo\n  const IdentifierInfo *getArgIdentifier(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_identifierinfo &&\n           \"invalid argument accessor!\");\n    return reinterpret_cast<IdentifierInfo *>(\n        DiagObj->DiagStorage.DiagArgumentsVal[Idx]);\n  }\n\n  /// Return the specified non-string argument in an opaque form.\n  /// \\pre getArgKind(Idx) != DiagnosticsEngine::ak_std_string\n  intptr_t getRawArg(unsigned Idx) const {\n    assert(getArgKind(Idx) != DiagnosticsEngine::ak_std_string &&\n           \"invalid argument accessor!\");\n    return DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the number of source ranges associated with this diagnostic.\n  unsigned getNumRanges() const {\n    return DiagObj->DiagStorage.DiagRanges.size();\n  }\n\n  /// \\pre Idx < getNumRanges()\n  const CharSourceRange &getRange(unsigned Idx) const {\n    assert(Idx < getNumRanges() && \"Invalid diagnostic range index!\");\n    return DiagObj->DiagStorage.DiagRanges[Idx];\n  }\n\n  /// Return an array reference for this diagnostic's ranges.\n  ArrayRef<CharSourceRange> getRanges() const {\n    return DiagObj->DiagStorage.DiagRanges;\n  }\n\n  unsigned getNumFixItHints() const {\n    return DiagObj->DiagStorage.FixItHints.size();\n  }\n\n  const FixItHint &getFixItHint(unsigned Idx) const {\n    assert(Idx < getNumFixItHints() && \"Invalid index!\");\n    return DiagObj->DiagStorage.FixItHints[Idx];\n  }\n\n  ArrayRef<FixItHint> getFixItHints() const {\n    return DiagObj->DiagStorage.FixItHints;\n  }\n\n  /// Format this diagnostic into a string, substituting the\n  /// formal arguments into the %0 slots.\n  ///\n  /// The result is appended onto the \\p OutStr array.\n  void FormatDiagnostic(SmallVectorImpl<char> &OutStr) const;\n\n  /// Format the given format-string into the output buffer using the\n  /// arguments stored in this diagnostic.\n  void FormatDiagnostic(const char *DiagStr, const char *DiagEnd,\n                        SmallVectorImpl<char> &OutStr) const;\n};\n\n/**\n * Represents a diagnostic in a form that can be retained until its\n * corresponding source manager is destroyed.\n */\nclass StoredDiagnostic {\n  unsigned ID;\n  DiagnosticsEngine::Level Level;\n  FullSourceLoc Loc;\n  std::string Message;\n  std::vector<CharSourceRange> Ranges;\n  std::vector<FixItHint> FixIts;\n\npublic:\n  StoredDiagnostic() = default;\n  StoredDiagnostic(DiagnosticsEngine::Level Level, const Diagnostic &Info);\n  StoredDiagnostic(DiagnosticsEngine::Level Level, unsigned ID,\n                   StringRef Message);\n  StoredDiagnostic(DiagnosticsEngine::Level Level, unsigned ID,\n                   StringRef Message, FullSourceLoc Loc,\n                   ArrayRef<CharSourceRange> Ranges,\n                   ArrayRef<FixItHint> Fixits);\n\n  /// Evaluates true when this object stores a diagnostic.\n  explicit operator bool() const { return !Message.empty(); }\n\n  unsigned getID() const { return ID; }\n  DiagnosticsEngine::Level getLevel() const { return Level; }\n  const FullSourceLoc &getLocation() const { return Loc; }\n  StringRef getMessage() const { return Message; }\n\n  void setLocation(FullSourceLoc Loc) { this->Loc = Loc; }\n\n  using range_iterator = std::vector<CharSourceRange>::const_iterator;\n\n  range_iterator range_begin() const { return Ranges.begin(); }\n  range_iterator range_end() const { return Ranges.end(); }\n  unsigned range_size() const { return Ranges.size(); }\n\n  ArrayRef<CharSourceRange> getRanges() const {\n    return llvm::makeArrayRef(Ranges);\n  }\n\n  using fixit_iterator = std::vector<FixItHint>::const_iterator;\n\n  fixit_iterator fixit_begin() const { return FixIts.begin(); }\n  fixit_iterator fixit_end() const { return FixIts.end(); }\n  unsigned fixit_size() const { return FixIts.size(); }\n\n  ArrayRef<FixItHint> getFixIts() const {\n    return llvm::makeArrayRef(FixIts);\n  }\n};\n\n/// Abstract interface, implemented by clients of the front-end, which\n/// formats and prints fully processed diagnostics.\nclass DiagnosticConsumer {\nprotected:\n  unsigned NumWarnings = 0;       ///< Number of warnings reported\n  unsigned NumErrors = 0;         ///< Number of errors reported\n\npublic:\n  DiagnosticConsumer() = default;\n  virtual ~DiagnosticConsumer();\n\n  unsigned getNumErrors() const { return NumErrors; }\n  unsigned getNumWarnings() const { return NumWarnings; }\n  virtual void clear() { NumWarnings = NumErrors = 0; }\n\n  /// Callback to inform the diagnostic client that processing\n  /// of a source file is beginning.\n  ///\n  /// Note that diagnostics may be emitted outside the processing of a source\n  /// file, for example during the parsing of command line options. However,\n  /// diagnostics with source range information are required to only be emitted\n  /// in between BeginSourceFile() and EndSourceFile().\n  ///\n  /// \\param LangOpts The language options for the source file being processed.\n  /// \\param PP The preprocessor object being used for the source; this is\n  /// optional, e.g., it may not be present when processing AST source files.\n  virtual void BeginSourceFile(const LangOptions &LangOpts,\n                               const Preprocessor *PP = nullptr) {}\n\n  /// Callback to inform the diagnostic client that processing\n  /// of a source file has ended.\n  ///\n  /// The diagnostic client should assume that any objects made available via\n  /// BeginSourceFile() are inaccessible.\n  virtual void EndSourceFile() {}\n\n  /// Callback to inform the diagnostic client that processing of all\n  /// source files has ended.\n  virtual void finish() {}\n\n  /// Indicates whether the diagnostics handled by this\n  /// DiagnosticConsumer should be included in the number of diagnostics\n  /// reported by DiagnosticsEngine.\n  ///\n  /// The default implementation returns true.\n  virtual bool IncludeInDiagnosticCounts() const;\n\n  /// Handle this diagnostic, reporting it to the user or\n  /// capturing it to a log as needed.\n  ///\n  /// The default implementation just keeps track of the total number of\n  /// warnings and errors.\n  virtual void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                                const Diagnostic &Info);\n};\n\n/// A diagnostic client that ignores all diagnostics.\nclass IgnoringDiagConsumer : public DiagnosticConsumer {\n  virtual void anchor();\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const Diagnostic &Info) override {\n    // Just ignore it.\n  }\n};\n\n/// Diagnostic consumer that forwards diagnostics along to an\n/// existing, already-initialized diagnostic consumer.\n///\nclass ForwardingDiagnosticConsumer : public DiagnosticConsumer {\n  DiagnosticConsumer &Target;\n\npublic:\n  ForwardingDiagnosticConsumer(DiagnosticConsumer &Target) : Target(Target) {}\n  ~ForwardingDiagnosticConsumer() override;\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const Diagnostic &Info) override;\n  void clear() override;\n\n  bool IncludeInDiagnosticCounts() const override;\n};\n\n// Struct used for sending info about how a type should be printed.\nstruct TemplateDiffTypes {\n  intptr_t FromType;\n  intptr_t ToType;\n  unsigned PrintTree : 1;\n  unsigned PrintFromType : 1;\n  unsigned ElideType : 1;\n  unsigned ShowColors : 1;\n\n  // The printer sets this variable to true if the template diff was used.\n  unsigned TemplateDiffUsed : 1;\n};\n\n/// Special character that the diagnostic printer will use to toggle the bold\n/// attribute.  The character itself will be not be printed.\nconst char ToggleHighlight = 127;\n\n/// ProcessWarningOptions - Initialize the diagnostic client and process the\n/// warning options specified on the command line.\nvoid ProcessWarningOptions(DiagnosticsEngine &Diags,\n                           const DiagnosticOptions &Opts,\n                           bool ReportDiags = true);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_DIAGNOSTIC_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "content": "//===--- DiagnosticIDs.h - Diagnostic IDs Handling --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the Diagnostic IDs-related interfaces.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n#define LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <vector>\n\nnamespace clang {\n  class DiagnosticsEngine;\n  class SourceLocation;\n\n  // Import the diagnostic enums themselves.\n  namespace diag {\n    // Size of each of the diagnostic categories.\n    enum {\n      DIAG_SIZE_COMMON        =  300,\n      DIAG_SIZE_DRIVER        =  250,\n      DIAG_SIZE_FRONTEND      =  150,\n      DIAG_SIZE_SERIALIZATION =  120,\n      DIAG_SIZE_LEX           =  400,\n      DIAG_SIZE_PARSE         =  600,\n      DIAG_SIZE_AST           =  250,\n      DIAG_SIZE_COMMENT       =  100,\n      DIAG_SIZE_CROSSTU       =  100,\n      DIAG_SIZE_SEMA          = 4500,\n      DIAG_SIZE_ANALYSIS      =  100,\n      DIAG_SIZE_REFACTORING   = 1000,\n    };\n    // Start position for diagnostics.\n    enum {\n      DIAG_START_COMMON        =                          0,\n      DIAG_START_DRIVER        = DIAG_START_COMMON        + DIAG_SIZE_COMMON,\n      DIAG_START_FRONTEND      = DIAG_START_DRIVER        + DIAG_SIZE_DRIVER,\n      DIAG_START_SERIALIZATION = DIAG_START_FRONTEND      + DIAG_SIZE_FRONTEND,\n      DIAG_START_LEX           = DIAG_START_SERIALIZATION + DIAG_SIZE_SERIALIZATION,\n      DIAG_START_PARSE         = DIAG_START_LEX           + DIAG_SIZE_LEX,\n      DIAG_START_AST           = DIAG_START_PARSE         + DIAG_SIZE_PARSE,\n      DIAG_START_COMMENT       = DIAG_START_AST           + DIAG_SIZE_AST,\n      DIAG_START_CROSSTU       = DIAG_START_COMMENT       + DIAG_SIZE_COMMENT,\n      DIAG_START_SEMA          = DIAG_START_CROSSTU       + DIAG_SIZE_CROSSTU,\n      DIAG_START_ANALYSIS      = DIAG_START_SEMA          + DIAG_SIZE_SEMA,\n      DIAG_START_REFACTORING   = DIAG_START_ANALYSIS      + DIAG_SIZE_ANALYSIS,\n      DIAG_UPPER_LIMIT         = DIAG_START_REFACTORING   + DIAG_SIZE_REFACTORING\n    };\n\n    class CustomDiagInfo;\n\n    /// All of the diagnostics that can be emitted by the frontend.\n    typedef unsigned kind;\n\n    // Get typedefs for common diagnostics.\n    enum {\n#define DIAG(ENUM, FLAGS, DEFAULT_MAPPING, DESC, GROUP, SFINAE, CATEGORY,      \\\n             NOWERROR, SHOWINSYSHEADER, DEFFERABLE)                            \\\n  ENUM,\n#define COMMONSTART\n#include \"clang/Basic/DiagnosticCommonKinds.inc\"\n      NUM_BUILTIN_COMMON_DIAGNOSTICS\n#undef DIAG\n    };\n\n    /// Enum values that allow the client to map NOTEs, WARNINGs, and EXTENSIONs\n    /// to either Ignore (nothing), Remark (emit a remark), Warning\n    /// (emit a warning) or Error (emit as an error).  It allows clients to\n    /// map ERRORs to Error or Fatal (stop emitting diagnostics after this one).\n    enum class Severity {\n      // NOTE: 0 means \"uncomputed\".\n      Ignored = 1, ///< Do not present this diagnostic, ignore it.\n      Remark = 2,  ///< Present this diagnostic as a remark.\n      Warning = 3, ///< Present this diagnostic as a warning.\n      Error = 4,   ///< Present this diagnostic as an error.\n      Fatal = 5    ///< Present this diagnostic as a fatal error.\n    };\n\n    /// Flavors of diagnostics we can emit. Used to filter for a particular\n    /// kind of diagnostic (for instance, for -W/-R flags).\n    enum class Flavor {\n      WarningOrError, ///< A diagnostic that indicates a problem or potential\n                      ///< problem. Can be made fatal by -Werror.\n      Remark          ///< A diagnostic that indicates normal progress through\n                      ///< compilation.\n    };\n  }\n\nclass DiagnosticMapping {\n  unsigned Severity : 3;\n  unsigned IsUser : 1;\n  unsigned IsPragma : 1;\n  unsigned HasNoWarningAsError : 1;\n  unsigned HasNoErrorAsFatal : 1;\n  unsigned WasUpgradedFromWarning : 1;\n\npublic:\n  static DiagnosticMapping Make(diag::Severity Severity, bool IsUser,\n                                bool IsPragma) {\n    DiagnosticMapping Result;\n    Result.Severity = (unsigned)Severity;\n    Result.IsUser = IsUser;\n    Result.IsPragma = IsPragma;\n    Result.HasNoWarningAsError = 0;\n    Result.HasNoErrorAsFatal = 0;\n    Result.WasUpgradedFromWarning = 0;\n    return Result;\n  }\n\n  diag::Severity getSeverity() const { return (diag::Severity)Severity; }\n  void setSeverity(diag::Severity Value) { Severity = (unsigned)Value; }\n\n  bool isUser() const { return IsUser; }\n  bool isPragma() const { return IsPragma; }\n\n  bool isErrorOrFatal() const {\n    return getSeverity() == diag::Severity::Error ||\n           getSeverity() == diag::Severity::Fatal;\n  }\n\n  bool hasNoWarningAsError() const { return HasNoWarningAsError; }\n  void setNoWarningAsError(bool Value) { HasNoWarningAsError = Value; }\n\n  bool hasNoErrorAsFatal() const { return HasNoErrorAsFatal; }\n  void setNoErrorAsFatal(bool Value) { HasNoErrorAsFatal = Value; }\n\n  /// Whether this mapping attempted to map the diagnostic to a warning, but\n  /// was overruled because the diagnostic was already mapped to an error or\n  /// fatal error.\n  bool wasUpgradedFromWarning() const { return WasUpgradedFromWarning; }\n  void setUpgradedFromWarning(bool Value) { WasUpgradedFromWarning = Value; }\n\n  /// Serialize this mapping as a raw integer.\n  unsigned serialize() const {\n    return (IsUser << 7) | (IsPragma << 6) | (HasNoWarningAsError << 5) |\n           (HasNoErrorAsFatal << 4) | (WasUpgradedFromWarning << 3) | Severity;\n  }\n  /// Deserialize a mapping.\n  static DiagnosticMapping deserialize(unsigned Bits) {\n    DiagnosticMapping Result;\n    Result.IsUser = (Bits >> 7) & 1;\n    Result.IsPragma = (Bits >> 6) & 1;\n    Result.HasNoWarningAsError = (Bits >> 5) & 1;\n    Result.HasNoErrorAsFatal = (Bits >> 4) & 1;\n    Result.WasUpgradedFromWarning = (Bits >> 3) & 1;\n    Result.Severity = Bits & 0x7;\n    return Result;\n  }\n};\n\n/// Used for handling and querying diagnostic IDs.\n///\n/// Can be used and shared by multiple Diagnostics for multiple translation units.\nclass DiagnosticIDs : public RefCountedBase<DiagnosticIDs> {\npublic:\n  /// The level of the diagnostic, after it has been through mapping.\n  enum Level {\n    Ignored, Note, Remark, Warning, Error, Fatal\n  };\n\nprivate:\n  /// Information for uniquing and looking up custom diags.\n  std::unique_ptr<diag::CustomDiagInfo> CustomDiagInfo;\n\npublic:\n  DiagnosticIDs();\n  ~DiagnosticIDs();\n\n  /// Return an ID for a diagnostic with the specified format string and\n  /// level.\n  ///\n  /// If this is the first request for this diagnostic, it is registered and\n  /// created, otherwise the existing ID is returned.\n\n  // FIXME: Replace this function with a create-only facilty like\n  // createCustomDiagIDFromFormatString() to enforce safe usage. At the time of\n  // writing, nearly all callers of this function were invalid.\n  unsigned getCustomDiagID(Level L, StringRef FormatString);\n\n  //===--------------------------------------------------------------------===//\n  // Diagnostic classification and reporting interfaces.\n  //\n\n  /// Given a diagnostic ID, return a description of the issue.\n  StringRef getDescription(unsigned DiagID) const;\n\n  /// Return true if the unmapped diagnostic levelof the specified\n  /// diagnostic ID is a Warning or Extension.\n  ///\n  /// This only works on builtin diagnostics, not custom ones, and is not\n  /// legal to call on NOTEs.\n  static bool isBuiltinWarningOrExtension(unsigned DiagID);\n\n  /// Return true if the specified diagnostic is mapped to errors by\n  /// default.\n  static bool isDefaultMappingAsError(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is a Note.\n  static bool isBuiltinNote(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort.\n  static bool isBuiltinExtensionDiag(unsigned DiagID) {\n    bool ignored;\n    return isBuiltinExtensionDiag(DiagID, ignored);\n  }\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort, and whether it is enabled by default.\n  ///\n  /// This also returns EnabledByDefault, which is set to indicate whether the\n  /// diagnostic is ignored by default (in which case -pedantic enables it) or\n  /// treated as a warning/error by default.\n  ///\n  static bool isBuiltinExtensionDiag(unsigned DiagID, bool &EnabledByDefault);\n\n\n  /// Return the lowest-level warning option that enables the specified\n  /// diagnostic.\n  ///\n  /// If there is no -Wfoo flag that controls the diagnostic, this returns null.\n  static StringRef getWarningOptionForDiag(unsigned DiagID);\n\n  /// Return the category number that a specified \\p DiagID belongs to,\n  /// or 0 if no category.\n  static unsigned getCategoryNumberForDiag(unsigned DiagID);\n\n  /// Return the number of diagnostic categories.\n  static unsigned getNumberOfCategories();\n\n  /// Given a category ID, return the name of the category.\n  static StringRef getCategoryNameFromID(unsigned CategoryID);\n\n  /// Return true if a given diagnostic falls into an ARC diagnostic\n  /// category.\n  static bool isARCDiagnostic(unsigned DiagID);\n\n  /// Enumeration describing how the emission of a diagnostic should\n  /// be treated when it occurs during C++ template argument deduction.\n  enum SFINAEResponse {\n    /// The diagnostic should not be reported, but it should cause\n    /// template argument deduction to fail.\n    ///\n    /// The vast majority of errors that occur during template argument\n    /// deduction fall into this category.\n    SFINAE_SubstitutionFailure,\n\n    /// The diagnostic should be suppressed entirely.\n    ///\n    /// Warnings generally fall into this category.\n    SFINAE_Suppress,\n\n    /// The diagnostic should be reported.\n    ///\n    /// The diagnostic should be reported. Various fatal errors (e.g.,\n    /// template instantiation depth exceeded) fall into this category.\n    SFINAE_Report,\n\n    /// The diagnostic is an access-control diagnostic, which will be\n    /// substitution failures in some contexts and reported in others.\n    SFINAE_AccessControl\n  };\n\n  /// Determines whether the given built-in diagnostic ID is\n  /// for an error that is suppressed if it occurs during C++ template\n  /// argument deduction.\n  ///\n  /// When an error is suppressed due to SFINAE, the template argument\n  /// deduction fails but no diagnostic is emitted. Certain classes of\n  /// errors, such as those errors that involve C++ access control,\n  /// are not SFINAE errors.\n  static SFINAEResponse getDiagnosticSFINAEResponse(unsigned DiagID);\n\n  /// Whether the diagnostic message can be deferred.\n  ///\n  /// For single source offloading languages, a diagnostic message occurred\n  /// in a device host function may be deferred until the function is sure\n  /// to be emitted.\n  static bool isDeferrable(unsigned DiagID);\n\n  /// Get the string of all diagnostic flags.\n  ///\n  /// \\returns A list of all diagnostics flags as they would be written in a\n  /// command line invocation including their `no-` variants. For example:\n  /// `{\"-Wempty-body\", \"-Wno-empty-body\", ...}`\n  static std::vector<std::string> getDiagnosticFlags();\n\n  /// Get the set of all diagnostic IDs in the group with the given name.\n  ///\n  /// \\param[out] Diags - On return, the diagnostics in the group.\n  /// \\returns \\c true if the given group is unknown, \\c false otherwise.\n  bool getDiagnosticsInGroup(diag::Flavor Flavor, StringRef Group,\n                             SmallVectorImpl<diag::kind> &Diags) const;\n\n  /// Get the set of all diagnostic IDs.\n  static void getAllDiagnostics(diag::Flavor Flavor,\n                                std::vector<diag::kind> &Diags);\n\n  /// Get the diagnostic option with the closest edit distance to the\n  /// given group name.\n  static StringRef getNearestOption(diag::Flavor Flavor, StringRef Group);\n\nprivate:\n  /// Classify the specified diagnostic ID into a Level, consumable by\n  /// the DiagnosticClient.\n  ///\n  /// The classification is based on the way the client configured the\n  /// DiagnosticsEngine object.\n  ///\n  /// \\param Loc The source location for which we are interested in finding out\n  /// the diagnostic state. Can be null in order to query the latest state.\n  DiagnosticIDs::Level\n  getDiagnosticLevel(unsigned DiagID, SourceLocation Loc,\n                     const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  diag::Severity\n  getDiagnosticSeverity(unsigned DiagID, SourceLocation Loc,\n                        const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  /// Used to report a diagnostic that is finally fully formed.\n  ///\n  /// \\returns \\c true if the diagnostic was emitted, \\c false if it was\n  /// suppressed.\n  bool ProcessDiag(DiagnosticsEngine &Diag) const;\n\n  /// Used to emit a diagnostic that is finally fully formed,\n  /// ignoring suppression.\n  void EmitDiag(DiagnosticsEngine &Diag, Level DiagLevel) const;\n\n  /// Whether the diagnostic may leave the AST in a state where some\n  /// invariants can break.\n  bool isUnrecoverable(unsigned DiagID) const;\n\n  friend class DiagnosticsEngine;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticOptions.h", "content": "//===- DiagnosticOptions.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTICOPTIONS_H\n#define LLVM_CLANG_BASIC_DIAGNOSTICOPTIONS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\nnamespace opt {\nclass ArgList;\n} // namespace opt\n} // namespace llvm\n\nnamespace clang {\nclass DiagnosticsEngine;\n\n/// Specifies which overload candidates to display when overload\n/// resolution fails.\nenum OverloadsShown : unsigned {\n  /// Show all overloads.\n  Ovl_All,\n\n  /// Show just the \"best\" overload candidates.\n  Ovl_Best\n};\n\n/// A bitmask representing the diagnostic levels used by\n/// VerifyDiagnosticConsumer.\nenum class DiagnosticLevelMask : unsigned {\n  None    = 0,\n  Note    = 1 << 0,\n  Remark  = 1 << 1,\n  Warning = 1 << 2,\n  Error   = 1 << 3,\n  All     = Note | Remark | Warning | Error\n};\n\ninline DiagnosticLevelMask operator~(DiagnosticLevelMask M) {\n  using UT = std::underlying_type<DiagnosticLevelMask>::type;\n  return static_cast<DiagnosticLevelMask>(~static_cast<UT>(M));\n}\n\ninline DiagnosticLevelMask operator|(DiagnosticLevelMask LHS,\n                                     DiagnosticLevelMask RHS) {\n  using UT = std::underlying_type<DiagnosticLevelMask>::type;\n  return static_cast<DiagnosticLevelMask>(\n    static_cast<UT>(LHS) | static_cast<UT>(RHS));\n}\n\ninline DiagnosticLevelMask operator&(DiagnosticLevelMask LHS,\n                                     DiagnosticLevelMask RHS) {\n  using UT = std::underlying_type<DiagnosticLevelMask>::type;\n  return static_cast<DiagnosticLevelMask>(\n    static_cast<UT>(LHS) & static_cast<UT>(RHS));\n}\n\nraw_ostream& operator<<(raw_ostream& Out, DiagnosticLevelMask M);\n\n/// Options for controlling the compiler diagnostics engine.\nclass DiagnosticOptions : public RefCountedBase<DiagnosticOptions>{\n  friend bool ParseDiagnosticArgs(DiagnosticOptions &, llvm::opt::ArgList &,\n                                  clang::DiagnosticsEngine *, bool);\n\n  friend class CompilerInvocation;\n\npublic:\n  enum TextDiagnosticFormat { Clang, MSVC, Vi };\n\n  // Default values.\n  enum {\n    DefaultTabStop = 8,\n    MaxTabStop = 100,\n    DefaultMacroBacktraceLimit = 6,\n    DefaultTemplateBacktraceLimit = 10,\n    DefaultConstexprBacktraceLimit = 10,\n    DefaultSpellCheckingLimit = 50,\n    DefaultSnippetLineLimit = 1,\n  };\n\n  // Define simple diagnostic options (with no accessors).\n#define DIAGOPT(Name, Bits, Default) unsigned Name : Bits;\n#define ENUM_DIAGOPT(Name, Type, Bits, Default)\n#include \"clang/Basic/DiagnosticOptions.def\"\n\nprotected:\n  // Define diagnostic options of enumeration type. These are private, and will\n  // have accessors (below).\n#define DIAGOPT(Name, Bits, Default)\n#define ENUM_DIAGOPT(Name, Type, Bits, Default) unsigned Name : Bits;\n#include \"clang/Basic/DiagnosticOptions.def\"\n\npublic:\n  /// The file to log diagnostic output to.\n  std::string DiagnosticLogFile;\n\n  /// The file to serialize diagnostics to (non-appending).\n  std::string DiagnosticSerializationFile;\n\n  /// The list of -W... options used to alter the diagnostic mappings, with the\n  /// prefixes removed.\n  std::vector<std::string> Warnings;\n\n  /// The list of prefixes from -Wundef-prefix=... used to generate warnings\n  /// for undefined macros.\n  std::vector<std::string> UndefPrefixes;\n\n  /// The list of -R... options used to alter the diagnostic mappings, with the\n  /// prefixes removed.\n  std::vector<std::string> Remarks;\n\n  /// The prefixes for comment directives sought by -verify (\"expected\" by\n  /// default).\n  std::vector<std::string> VerifyPrefixes;\n\npublic:\n  // Define accessors/mutators for diagnostic options of enumeration type.\n#define DIAGOPT(Name, Bits, Default)\n#define ENUM_DIAGOPT(Name, Type, Bits, Default) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/DiagnosticOptions.def\"\n\n  DiagnosticOptions() {\n#define DIAGOPT(Name, Bits, Default) Name = Default;\n#define ENUM_DIAGOPT(Name, Type, Bits, Default) set##Name(Default);\n#include \"clang/Basic/DiagnosticOptions.def\"\n  }\n};\n\nusing TextDiagnosticFormat = DiagnosticOptions::TextDiagnosticFormat;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_DIAGNOSTICOPTIONS_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "content": "//===- IdentifierTable.h - Hash table for identifier lookup -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::IdentifierInfo, clang::IdentifierTable, and\n/// clang::Selector interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n#define LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass DeclarationName;\nclass DeclarationNameTable;\nclass IdentifierInfo;\nclass LangOptions;\nclass MultiKeywordSelector;\nclass SourceLocation;\n\n/// A simple pair of identifier info and location.\nusing IdentifierLocPair = std::pair<IdentifierInfo *, SourceLocation>;\n\n/// IdentifierInfo and other related classes are aligned to\n/// 8 bytes so that DeclarationName can use the lower 3 bits\n/// of a pointer to one of these classes.\nenum { IdentifierInfoAlignment = 8 };\n\nstatic constexpr int ObjCOrBuiltinIDBits = 15;\n\n/// One of these records is kept for each identifier that\n/// is lexed.  This contains information about whether the token was \\#define'd,\n/// is a language keyword, or if it is a front-end token of some sort (e.g. a\n/// variable or function name).  The preprocessor keeps this information in a\n/// set, and all tok::identifier tokens have a pointer to one of these.\n/// It is aligned to 8 bytes because DeclarationName needs the lower 3 bits.\nclass alignas(IdentifierInfoAlignment) IdentifierInfo {\n  friend class IdentifierTable;\n\n  // Front-end token ID or tok::identifier.\n  unsigned TokenID : 9;\n\n  // ObjC keyword ('protocol' in '@protocol') or builtin (__builtin_inf).\n  // First NUM_OBJC_KEYWORDS values are for Objective-C,\n  // the remaining values are for builtins.\n  unsigned ObjCOrBuiltinID : ObjCOrBuiltinIDBits;\n\n  // True if there is a #define for this.\n  unsigned HasMacro : 1;\n\n  // True if there was a #define for this.\n  unsigned HadMacro : 1;\n\n  // True if the identifier is a language extension.\n  unsigned IsExtension : 1;\n\n  // True if the identifier is a keyword in a newer or proposed Standard.\n  unsigned IsFutureCompatKeyword : 1;\n\n  // True if the identifier is poisoned.\n  unsigned IsPoisoned : 1;\n\n  // True if the identifier is a C++ operator keyword.\n  unsigned IsCPPOperatorKeyword : 1;\n\n  // Internal bit set by the member function RecomputeNeedsHandleIdentifier.\n  // See comment about RecomputeNeedsHandleIdentifier for more info.\n  unsigned NeedsHandleIdentifier : 1;\n\n  // True if the identifier was loaded (at least partially) from an AST file.\n  unsigned IsFromAST : 1;\n\n  // True if the identifier has changed from the definition\n  // loaded from an AST file.\n  unsigned ChangedAfterLoad : 1;\n\n  // True if the identifier's frontend information has changed from the\n  // definition loaded from an AST file.\n  unsigned FEChangedAfterLoad : 1;\n\n  // True if revertTokenIDToIdentifier was called.\n  unsigned RevertedTokenID : 1;\n\n  // True if there may be additional information about\n  // this identifier stored externally.\n  unsigned OutOfDate : 1;\n\n  // True if this is the 'import' contextual keyword.\n  unsigned IsModulesImport : 1;\n\n  // True if this is a mangled OpenMP variant name.\n  unsigned IsMangledOpenMPVariantName : 1;\n\n  // 28 bits left in a 64-bit word.\n\n  // Managed by the language front-end.\n  void *FETokenInfo = nullptr;\n\n  llvm::StringMapEntry<IdentifierInfo *> *Entry = nullptr;\n\n  IdentifierInfo()\n      : TokenID(tok::identifier), ObjCOrBuiltinID(0), HasMacro(false),\n        HadMacro(false), IsExtension(false), IsFutureCompatKeyword(false),\n        IsPoisoned(false), IsCPPOperatorKeyword(false),\n        NeedsHandleIdentifier(false), IsFromAST(false), ChangedAfterLoad(false),\n        FEChangedAfterLoad(false), RevertedTokenID(false), OutOfDate(false),\n        IsModulesImport(false), IsMangledOpenMPVariantName(false) {}\n\npublic:\n  IdentifierInfo(const IdentifierInfo &) = delete;\n  IdentifierInfo &operator=(const IdentifierInfo &) = delete;\n  IdentifierInfo(IdentifierInfo &&) = delete;\n  IdentifierInfo &operator=(IdentifierInfo &&) = delete;\n\n  /// Return true if this is the identifier for the specified string.\n  ///\n  /// This is intended to be used for string literals only: II->isStr(\"foo\").\n  template <std::size_t StrLen>\n  bool isStr(const char (&Str)[StrLen]) const {\n    return getLength() == StrLen-1 &&\n           memcmp(getNameStart(), Str, StrLen-1) == 0;\n  }\n\n  /// Return true if this is the identifier for the specified StringRef.\n  bool isStr(llvm::StringRef Str) const {\n    llvm::StringRef ThisStr(getNameStart(), getLength());\n    return ThisStr == Str;\n  }\n\n  /// Return the beginning of the actual null-terminated string for this\n  /// identifier.\n  const char *getNameStart() const { return Entry->getKeyData(); }\n\n  /// Efficiently return the length of this identifier info.\n  unsigned getLength() const { return Entry->getKeyLength(); }\n\n  /// Return the actual identifier string.\n  StringRef getName() const {\n    return StringRef(getNameStart(), getLength());\n  }\n\n  /// Return true if this identifier is \\#defined to some other value.\n  /// \\note The current definition may be in a module and not currently visible.\n  bool hasMacroDefinition() const {\n    return HasMacro;\n  }\n  void setHasMacroDefinition(bool Val) {\n    if (HasMacro == Val) return;\n\n    HasMacro = Val;\n    if (Val) {\n      NeedsHandleIdentifier = true;\n      HadMacro = true;\n    } else {\n      RecomputeNeedsHandleIdentifier();\n    }\n  }\n  /// Returns true if this identifier was \\#defined to some value at any\n  /// moment. In this case there should be an entry for the identifier in the\n  /// macro history table in Preprocessor.\n  bool hadMacroDefinition() const {\n    return HadMacro;\n  }\n\n  /// If this is a source-language token (e.g. 'for'), this API\n  /// can be used to cause the lexer to map identifiers to source-language\n  /// tokens.\n  tok::TokenKind getTokenID() const { return (tok::TokenKind)TokenID; }\n\n  /// True if revertTokenIDToIdentifier() was called.\n  bool hasRevertedTokenIDToIdentifier() const { return RevertedTokenID; }\n\n  /// Revert TokenID to tok::identifier; used for GNU libstdc++ 4.2\n  /// compatibility.\n  ///\n  /// TokenID is normally read-only but there are 2 instances where we revert it\n  /// to tok::identifier for libstdc++ 4.2. Keep track of when this happens\n  /// using this method so we can inform serialization about it.\n  void revertTokenIDToIdentifier() {\n    assert(TokenID != tok::identifier && \"Already at tok::identifier\");\n    TokenID = tok::identifier;\n    RevertedTokenID = true;\n  }\n  void revertIdentifierToTokenID(tok::TokenKind TK) {\n    assert(TokenID == tok::identifier && \"Should be at tok::identifier\");\n    TokenID = TK;\n    RevertedTokenID = false;\n  }\n\n  /// Return the preprocessor keyword ID for this identifier.\n  ///\n  /// For example, \"define\" will return tok::pp_define.\n  tok::PPKeywordKind getPPKeywordID() const;\n\n  /// Return the Objective-C keyword ID for the this identifier.\n  ///\n  /// For example, 'class' will return tok::objc_class if ObjC is enabled.\n  tok::ObjCKeywordKind getObjCKeywordID() const {\n    if (ObjCOrBuiltinID < tok::NUM_OBJC_KEYWORDS)\n      return tok::ObjCKeywordKind(ObjCOrBuiltinID);\n    else\n      return tok::objc_not_keyword;\n  }\n  void setObjCKeywordID(tok::ObjCKeywordKind ID) { ObjCOrBuiltinID = ID; }\n\n  /// Return a value indicating whether this is a builtin function.\n  ///\n  /// 0 is not-built-in. 1+ are specific builtin functions.\n  unsigned getBuiltinID() const {\n    if (ObjCOrBuiltinID >= tok::NUM_OBJC_KEYWORDS)\n      return ObjCOrBuiltinID - tok::NUM_OBJC_KEYWORDS;\n    else\n      return 0;\n  }\n  void setBuiltinID(unsigned ID) {\n    ObjCOrBuiltinID = ID + tok::NUM_OBJC_KEYWORDS;\n    assert(ObjCOrBuiltinID - unsigned(tok::NUM_OBJC_KEYWORDS) == ID\n           && \"ID too large for field!\");\n  }\n\n  unsigned getObjCOrBuiltinID() const { return ObjCOrBuiltinID; }\n  void setObjCOrBuiltinID(unsigned ID) { ObjCOrBuiltinID = ID; }\n\n  /// get/setExtension - Initialize information about whether or not this\n  /// language token is an extension.  This controls extension warnings, and is\n  /// only valid if a custom token ID is set.\n  bool isExtensionToken() const { return IsExtension; }\n  void setIsExtensionToken(bool Val) {\n    IsExtension = Val;\n    if (Val)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// is/setIsFutureCompatKeyword - Initialize information about whether or not\n  /// this language token is a keyword in a newer or proposed Standard. This\n  /// controls compatibility warnings, and is only true when not parsing the\n  /// corresponding Standard. Once a compatibility problem has been diagnosed\n  /// with this keyword, the flag will be cleared.\n  bool isFutureCompatKeyword() const { return IsFutureCompatKeyword; }\n  void setIsFutureCompatKeyword(bool Val) {\n    IsFutureCompatKeyword = Val;\n    if (Val)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// setIsPoisoned - Mark this identifier as poisoned.  After poisoning, the\n  /// Preprocessor will emit an error every time this token is used.\n  void setIsPoisoned(bool Value = true) {\n    IsPoisoned = Value;\n    if (Value)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Return true if this token has been poisoned.\n  bool isPoisoned() const { return IsPoisoned; }\n\n  /// isCPlusPlusOperatorKeyword/setIsCPlusPlusOperatorKeyword controls whether\n  /// this identifier is a C++ alternate representation of an operator.\n  void setIsCPlusPlusOperatorKeyword(bool Val = true) {\n    IsCPPOperatorKeyword = Val;\n  }\n  bool isCPlusPlusOperatorKeyword() const { return IsCPPOperatorKeyword; }\n\n  /// Return true if this token is a keyword in the specified language.\n  bool isKeyword(const LangOptions &LangOpts) const;\n\n  /// Return true if this token is a C++ keyword in the specified\n  /// language.\n  bool isCPlusPlusKeyword(const LangOptions &LangOpts) const;\n\n  /// Get and set FETokenInfo. The language front-end is allowed to associate\n  /// arbitrary metadata with this token.\n  void *getFETokenInfo() const { return FETokenInfo; }\n  void setFETokenInfo(void *T) { FETokenInfo = T; }\n\n  /// Return true if the Preprocessor::HandleIdentifier must be called\n  /// on a token of this identifier.\n  ///\n  /// If this returns false, we know that HandleIdentifier will not affect\n  /// the token.\n  bool isHandleIdentifierCase() const { return NeedsHandleIdentifier; }\n\n  /// Return true if the identifier in its current state was loaded\n  /// from an AST file.\n  bool isFromAST() const { return IsFromAST; }\n\n  void setIsFromAST() { IsFromAST = true; }\n\n  /// Determine whether this identifier has changed since it was loaded\n  /// from an AST file.\n  bool hasChangedSinceDeserialization() const {\n    return ChangedAfterLoad;\n  }\n\n  /// Note that this identifier has changed since it was loaded from\n  /// an AST file.\n  void setChangedSinceDeserialization() {\n    ChangedAfterLoad = true;\n  }\n\n  /// Determine whether the frontend token information for this\n  /// identifier has changed since it was loaded from an AST file.\n  bool hasFETokenInfoChangedSinceDeserialization() const {\n    return FEChangedAfterLoad;\n  }\n\n  /// Note that the frontend token information for this identifier has\n  /// changed since it was loaded from an AST file.\n  void setFETokenInfoChangedSinceDeserialization() {\n    FEChangedAfterLoad = true;\n  }\n\n  /// Determine whether the information for this identifier is out of\n  /// date with respect to the external source.\n  bool isOutOfDate() const { return OutOfDate; }\n\n  /// Set whether the information for this identifier is out of\n  /// date with respect to the external source.\n  void setOutOfDate(bool OOD) {\n    OutOfDate = OOD;\n    if (OOD)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Determine whether this is the contextual keyword \\c import.\n  bool isModulesImport() const { return IsModulesImport; }\n\n  /// Set whether this identifier is the contextual keyword \\c import.\n  void setModulesImport(bool I) {\n    IsModulesImport = I;\n    if (I)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Determine whether this is the mangled name of an OpenMP variant.\n  bool isMangledOpenMPVariantName() const { return IsMangledOpenMPVariantName; }\n\n  /// Set whether this is the mangled name of an OpenMP variant.\n  void setMangledOpenMPVariantName(bool I) { IsMangledOpenMPVariantName = I; }\n\n  /// Return true if this identifier is an editor placeholder.\n  ///\n  /// Editor placeholders are produced by the code-completion engine and are\n  /// represented as characters between '<#' and '#>' in the source code. An\n  /// example of auto-completed call with a placeholder parameter is shown\n  /// below:\n  /// \\code\n  ///   function(<#int x#>);\n  /// \\endcode\n  bool isEditorPlaceholder() const {\n    return getName().startswith(\"<#\") && getName().endswith(\"#>\");\n  }\n\n  /// Determine whether \\p this is a name reserved for the implementation (C99\n  /// 7.1.3, C++ [lib.global.names]).\n  bool isReservedName(bool doubleUnderscoreOnly = false) const {\n    if (getLength() < 2)\n      return false;\n    const char *Name = getNameStart();\n    return Name[0] == '_' &&\n           (Name[1] == '_' ||\n            (Name[1] >= 'A' && Name[1] <= 'Z' && !doubleUnderscoreOnly));\n  }\n\n  /// Provide less than operator for lexicographical sorting.\n  bool operator<(const IdentifierInfo &RHS) const {\n    return getName() < RHS.getName();\n  }\n\nprivate:\n  /// The Preprocessor::HandleIdentifier does several special (but rare)\n  /// things to identifiers of various sorts.  For example, it changes the\n  /// \\c for keyword token from tok::identifier to tok::for.\n  ///\n  /// This method is very tied to the definition of HandleIdentifier.  Any\n  /// change to it should be reflected here.\n  void RecomputeNeedsHandleIdentifier() {\n    NeedsHandleIdentifier = isPoisoned() || hasMacroDefinition() ||\n                            isExtensionToken() || isFutureCompatKeyword() ||\n                            isOutOfDate() || isModulesImport();\n  }\n};\n\n/// An RAII object for [un]poisoning an identifier within a scope.\n///\n/// \\p II is allowed to be null, in which case objects of this type have\n/// no effect.\nclass PoisonIdentifierRAIIObject {\n  IdentifierInfo *const II;\n  const bool OldValue;\n\npublic:\n  PoisonIdentifierRAIIObject(IdentifierInfo *II, bool NewValue)\n    : II(II), OldValue(II ? II->isPoisoned() : false) {\n    if(II)\n      II->setIsPoisoned(NewValue);\n  }\n\n  ~PoisonIdentifierRAIIObject() {\n    if(II)\n      II->setIsPoisoned(OldValue);\n  }\n};\n\n/// An iterator that walks over all of the known identifiers\n/// in the lookup table.\n///\n/// Since this iterator uses an abstract interface via virtual\n/// functions, it uses an object-oriented interface rather than the\n/// more standard C++ STL iterator interface. In this OO-style\n/// iteration, the single function \\c Next() provides dereference,\n/// advance, and end-of-sequence checking in a single\n/// operation. Subclasses of this iterator type will provide the\n/// actual functionality.\nclass IdentifierIterator {\nprotected:\n  IdentifierIterator() = default;\n\npublic:\n  IdentifierIterator(const IdentifierIterator &) = delete;\n  IdentifierIterator &operator=(const IdentifierIterator &) = delete;\n\n  virtual ~IdentifierIterator();\n\n  /// Retrieve the next string in the identifier table and\n  /// advances the iterator for the following string.\n  ///\n  /// \\returns The next string in the identifier table. If there is\n  /// no such string, returns an empty \\c StringRef.\n  virtual StringRef Next() = 0;\n};\n\n/// Provides lookups to, and iteration over, IdentiferInfo objects.\nclass IdentifierInfoLookup {\npublic:\n  virtual ~IdentifierInfoLookup();\n\n  /// Return the IdentifierInfo for the specified named identifier.\n  ///\n  /// Unlike the version in IdentifierTable, this returns a pointer instead\n  /// of a reference.  If the pointer is null then the IdentifierInfo cannot\n  /// be found.\n  virtual IdentifierInfo* get(StringRef Name) = 0;\n\n  /// Retrieve an iterator into the set of all identifiers\n  /// known to this identifier lookup source.\n  ///\n  /// This routine provides access to all of the identifiers known to\n  /// the identifier lookup, allowing access to the contents of the\n  /// identifiers without introducing the overhead of constructing\n  /// IdentifierInfo objects for each.\n  ///\n  /// \\returns A new iterator into the set of known identifiers. The\n  /// caller is responsible for deleting this iterator.\n  virtual IdentifierIterator *getIdentifiers();\n};\n\n/// Implements an efficient mapping from strings to IdentifierInfo nodes.\n///\n/// This has no other purpose, but this is an extremely performance-critical\n/// piece of the code, as each occurrence of every identifier goes through\n/// here when lexed.\nclass IdentifierTable {\n  // Shark shows that using MallocAllocator is *much* slower than using this\n  // BumpPtrAllocator!\n  using HashTableTy = llvm::StringMap<IdentifierInfo *, llvm::BumpPtrAllocator>;\n  HashTableTy HashTable;\n\n  IdentifierInfoLookup* ExternalLookup;\n\npublic:\n  /// Create the identifier table.\n  explicit IdentifierTable(IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Create the identifier table, populating it with info about the\n  /// language keywords for the language specified by \\p LangOpts.\n  explicit IdentifierTable(const LangOptions &LangOpts,\n                           IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Set the external identifier lookup mechanism.\n  void setExternalIdentifierLookup(IdentifierInfoLookup *IILookup) {\n    ExternalLookup = IILookup;\n  }\n\n  /// Retrieve the external identifier lookup object, if any.\n  IdentifierInfoLookup *getExternalIdentifierLookup() const {\n    return ExternalLookup;\n  }\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return HashTable.getAllocator();\n  }\n\n  /// Return the identifier token info for the specified named\n  /// identifier.\n  IdentifierInfo &get(StringRef Name) {\n    auto &Entry = *HashTable.insert(std::make_pair(Name, nullptr)).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II) return *II;\n\n    // No entry; if we have an external lookup, look there first.\n    if (ExternalLookup) {\n      II = ExternalLookup->get(Name);\n      if (II)\n        return *II;\n    }\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    return *II;\n  }\n\n  IdentifierInfo &get(StringRef Name, tok::TokenKind TokenCode) {\n    IdentifierInfo &II = get(Name);\n    II.TokenID = TokenCode;\n    assert(II.TokenID == (unsigned) TokenCode && \"TokenCode too large\");\n    return II;\n  }\n\n  /// Gets an IdentifierInfo for the given name without consulting\n  ///        external sources.\n  ///\n  /// This is a version of get() meant for external sources that want to\n  /// introduce or modify an identifier. If they called get(), they would\n  /// likely end up in a recursion.\n  IdentifierInfo &getOwn(StringRef Name) {\n    auto &Entry = *HashTable.insert(std::make_pair(Name, nullptr)).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II)\n      return *II;\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    // If this is the 'import' contextual keyword, mark it as such.\n    if (Name.equals(\"import\"))\n      II->setModulesImport(true);\n\n    return *II;\n  }\n\n  using iterator = HashTableTy::const_iterator;\n  using const_iterator = HashTableTy::const_iterator;\n\n  iterator begin() const { return HashTable.begin(); }\n  iterator end() const   { return HashTable.end(); }\n  unsigned size() const  { return HashTable.size(); }\n\n  iterator find(StringRef Name) const { return HashTable.find(Name); }\n\n  /// Print some statistics to stderr that indicate how well the\n  /// hashing is doing.\n  void PrintStats() const;\n\n  /// Populate the identifier table with info about the language keywords\n  /// for the language specified by \\p LangOpts.\n  void AddKeywords(const LangOptions &LangOpts);\n};\n\n/// A family of Objective-C methods.\n///\n/// These families have no inherent meaning in the language, but are\n/// nonetheless central enough in the existing implementations to\n/// merit direct AST support.  While, in theory, arbitrary methods can\n/// be considered to form families, we focus here on the methods\n/// involving allocation and retain-count management, as these are the\n/// most \"core\" and the most likely to be useful to diverse clients\n/// without extra information.\n///\n/// Both selectors and actual method declarations may be classified\n/// into families.  Method families may impose additional restrictions\n/// beyond their selector name; for example, a method called '_init'\n/// that returns void is not considered to be in the 'init' family\n/// (but would be if it returned 'id').  It is also possible to\n/// explicitly change or remove a method's family.  Therefore the\n/// method's family should be considered the single source of truth.\nenum ObjCMethodFamily {\n  /// No particular method family.\n  OMF_None,\n\n  // Selectors in these families may have arbitrary arity, may be\n  // written with arbitrary leading underscores, and may have\n  // additional CamelCase \"words\" in their first selector chunk\n  // following the family name.\n  OMF_alloc,\n  OMF_copy,\n  OMF_init,\n  OMF_mutableCopy,\n  OMF_new,\n\n  // These families are singletons consisting only of the nullary\n  // selector with the given name.\n  OMF_autorelease,\n  OMF_dealloc,\n  OMF_finalize,\n  OMF_release,\n  OMF_retain,\n  OMF_retainCount,\n  OMF_self,\n  OMF_initialize,\n\n  // performSelector families\n  OMF_performSelector\n};\n\n/// Enough bits to store any enumerator in ObjCMethodFamily or\n/// InvalidObjCMethodFamily.\nenum { ObjCMethodFamilyBitWidth = 4 };\n\n/// An invalid value of ObjCMethodFamily.\nenum { InvalidObjCMethodFamily = (1 << ObjCMethodFamilyBitWidth) - 1 };\n\n/// A family of Objective-C methods.\n///\n/// These are family of methods whose result type is initially 'id', but\n/// but are candidate for the result type to be changed to 'instancetype'.\nenum ObjCInstanceTypeFamily {\n  OIT_None,\n  OIT_Array,\n  OIT_Dictionary,\n  OIT_Singleton,\n  OIT_Init,\n  OIT_ReturnsSelf\n};\n\nenum ObjCStringFormatFamily {\n  SFF_None,\n  SFF_NSString,\n  SFF_CFString\n};\n\n/// Smart pointer class that efficiently represents Objective-C method\n/// names.\n///\n/// This class will either point to an IdentifierInfo or a\n/// MultiKeywordSelector (which is private). This enables us to optimize\n/// selectors that take no arguments and selectors that take 1 argument, which\n/// accounts for 78% of all selectors in Cocoa.h.\nclass Selector {\n  friend class Diagnostic;\n  friend class SelectorTable; // only the SelectorTable can create these\n  friend class DeclarationName; // and the AST's DeclarationName.\n\n  enum IdentifierInfoFlag {\n    // Empty selector = 0. Note that these enumeration values must\n    // correspond to the enumeration values of DeclarationName::StoredNameKind\n    ZeroArg  = 0x01,\n    OneArg   = 0x02,\n    MultiArg = 0x07,\n    ArgFlags = 0x07\n  };\n\n  /// A pointer to the MultiKeywordSelector or IdentifierInfo. We use the low\n  /// three bits of InfoPtr to store an IdentifierInfoFlag. Note that in any\n  /// case IdentifierInfo and MultiKeywordSelector are already aligned to\n  /// 8 bytes even on 32 bits archs because of DeclarationName.\n  uintptr_t InfoPtr = 0;\n\n  Selector(IdentifierInfo *II, unsigned nArgs) {\n    InfoPtr = reinterpret_cast<uintptr_t>(II);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    assert(nArgs < 2 && \"nArgs not equal to 0/1\");\n    InfoPtr |= nArgs+1;\n  }\n\n  Selector(MultiKeywordSelector *SI) {\n    InfoPtr = reinterpret_cast<uintptr_t>(SI);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    InfoPtr |= MultiArg;\n  }\n\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (getIdentifierInfoFlag() < MultiArg)\n      return reinterpret_cast<IdentifierInfo *>(InfoPtr & ~ArgFlags);\n    return nullptr;\n  }\n\n  MultiKeywordSelector *getMultiKeywordSelector() const {\n    return reinterpret_cast<MultiKeywordSelector *>(InfoPtr & ~ArgFlags);\n  }\n\n  unsigned getIdentifierInfoFlag() const {\n    return InfoPtr & ArgFlags;\n  }\n\n  static ObjCMethodFamily getMethodFamilyImpl(Selector sel);\n\n  static ObjCStringFormatFamily getStringFormatFamilyImpl(Selector sel);\n\npublic:\n  /// The default ctor should only be used when creating data structures that\n  ///  will contain selectors.\n  Selector() = default;\n  explicit Selector(uintptr_t V) : InfoPtr(V) {}\n\n  /// operator==/!= - Indicate whether the specified selectors are identical.\n  bool operator==(Selector RHS) const {\n    return InfoPtr == RHS.InfoPtr;\n  }\n  bool operator!=(Selector RHS) const {\n    return InfoPtr != RHS.InfoPtr;\n  }\n\n  void *getAsOpaquePtr() const {\n    return reinterpret_cast<void*>(InfoPtr);\n  }\n\n  /// Determine whether this is the empty selector.\n  bool isNull() const { return InfoPtr == 0; }\n\n  // Predicates to identify the selector type.\n  bool isKeywordSelector() const {\n    return getIdentifierInfoFlag() != ZeroArg;\n  }\n\n  bool isUnarySelector() const {\n    return getIdentifierInfoFlag() == ZeroArg;\n  }\n\n  /// If this selector is the specific keyword selector described by Names.\n  bool isKeywordSelector(ArrayRef<StringRef> Names) const;\n\n  /// If this selector is the specific unary selector described by Name.\n  bool isUnarySelector(StringRef Name) const;\n\n  unsigned getNumArgs() const;\n\n  /// Retrieve the identifier at a given position in the selector.\n  ///\n  /// Note that the identifier pointer returned may be NULL. Clients that only\n  /// care about the text of the identifier string, and not the specific,\n  /// uniqued identifier pointer, should use \\c getNameForSlot(), which returns\n  /// an empty string when the identifier pointer would be NULL.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the identifier.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the uniqued identifier for this slot, or NULL if this slot has\n  /// no corresponding identifier.\n  IdentifierInfo *getIdentifierInfoForSlot(unsigned argIndex) const;\n\n  /// Retrieve the name at a given position in the selector.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the name.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the name for this slot, which may be the empty string if no\n  /// name was supplied.\n  StringRef getNameForSlot(unsigned argIndex) const;\n\n  /// Derive the full selector name (e.g. \"foo:bar:\") and return\n  /// it as an std::string.\n  std::string getAsString() const;\n\n  /// Prints the full selector name (e.g. \"foo:bar:\").\n  void print(llvm::raw_ostream &OS) const;\n\n  void dump() const;\n\n  /// Derive the conventional family of this method.\n  ObjCMethodFamily getMethodFamily() const {\n    return getMethodFamilyImpl(*this);\n  }\n\n  ObjCStringFormatFamily getStringFormatFamily() const {\n    return getStringFormatFamilyImpl(*this);\n  }\n\n  static Selector getEmptyMarker() {\n    return Selector(uintptr_t(-1));\n  }\n\n  static Selector getTombstoneMarker() {\n    return Selector(uintptr_t(-2));\n  }\n\n  static ObjCInstanceTypeFamily getInstTypeMethodFamily(Selector sel);\n};\n\n/// This table allows us to fully hide how we implement\n/// multi-keyword caching.\nclass SelectorTable {\n  // Actually a SelectorTableImpl\n  void *Impl;\n\npublic:\n  SelectorTable();\n  SelectorTable(const SelectorTable &) = delete;\n  SelectorTable &operator=(const SelectorTable &) = delete;\n  ~SelectorTable();\n\n  /// Can create any sort of selector.\n  ///\n  /// \\p NumArgs indicates whether this is a no argument selector \"foo\", a\n  /// single argument selector \"foo:\" or multi-argument \"foo:bar:\".\n  Selector getSelector(unsigned NumArgs, IdentifierInfo **IIV);\n\n  Selector getUnarySelector(IdentifierInfo *ID) {\n    return Selector(ID, 1);\n  }\n\n  Selector getNullarySelector(IdentifierInfo *ID) {\n    return Selector(ID, 0);\n  }\n\n  /// Return the total amount of memory allocated for managing selectors.\n  size_t getTotalMemory() const;\n\n  /// Return the default setter name for the given identifier.\n  ///\n  /// This is \"set\" + \\p Name where the initial character of \\p Name\n  /// has been capitalized.\n  static SmallString<64> constructSetterName(StringRef Name);\n\n  /// Return the default setter selector for the given identifier.\n  ///\n  /// This is \"set\" + \\p Name where the initial character of \\p Name\n  /// has been capitalized.\n  static Selector constructSetterSelector(IdentifierTable &Idents,\n                                          SelectorTable &SelTable,\n                                          const IdentifierInfo *Name);\n\n  /// Return the property name for the given setter selector.\n  static std::string getPropertyNameFromSetterSelector(Selector Sel);\n};\n\nnamespace detail {\n\n/// DeclarationNameExtra is used as a base of various uncommon special names.\n/// This class is needed since DeclarationName has not enough space to store\n/// the kind of every possible names. Therefore the kind of common names is\n/// stored directly in DeclarationName, and the kind of uncommon names is\n/// stored in DeclarationNameExtra. It is aligned to 8 bytes because\n/// DeclarationName needs the lower 3 bits to store the kind of common names.\n/// DeclarationNameExtra is tightly coupled to DeclarationName and any change\n/// here is very likely to require changes in DeclarationName(Table).\nclass alignas(IdentifierInfoAlignment) DeclarationNameExtra {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\nprotected:\n  /// The kind of \"extra\" information stored in the DeclarationName. See\n  /// @c ExtraKindOrNumArgs for an explanation of how these enumerator values\n  /// are used. Note that DeclarationName depends on the numerical values\n  /// of the enumerators in this enum. See DeclarationName::StoredNameKind\n  /// for more info.\n  enum ExtraKind {\n    CXXDeductionGuideName,\n    CXXLiteralOperatorName,\n    CXXUsingDirective,\n    ObjCMultiArgSelector\n  };\n\n  /// ExtraKindOrNumArgs has one of the following meaning:\n  ///  * The kind of an uncommon C++ special name. This DeclarationNameExtra\n  ///    is in this case in fact either a CXXDeductionGuideNameExtra or\n  ///    a CXXLiteralOperatorIdName.\n  ///\n  ///  * It may be also name common to C++ using-directives (CXXUsingDirective),\n  ///\n  ///  * Otherwise it is ObjCMultiArgSelector+NumArgs, where NumArgs is\n  ///    the number of arguments in the Objective-C selector, in which\n  ///    case the DeclarationNameExtra is also a MultiKeywordSelector.\n  unsigned ExtraKindOrNumArgs;\n\n  DeclarationNameExtra(ExtraKind Kind) : ExtraKindOrNumArgs(Kind) {}\n  DeclarationNameExtra(unsigned NumArgs)\n      : ExtraKindOrNumArgs(ObjCMultiArgSelector + NumArgs) {}\n\n  /// Return the corresponding ExtraKind.\n  ExtraKind getKind() const {\n    return static_cast<ExtraKind>(ExtraKindOrNumArgs >\n                                          (unsigned)ObjCMultiArgSelector\n                                      ? (unsigned)ObjCMultiArgSelector\n                                      : ExtraKindOrNumArgs);\n  }\n\n  /// Return the number of arguments in an ObjC selector. Only valid when this\n  /// is indeed an ObjCMultiArgSelector.\n  unsigned getNumArgs() const {\n    assert(ExtraKindOrNumArgs >= (unsigned)ObjCMultiArgSelector &&\n           \"getNumArgs called but this is not an ObjC selector!\");\n    return ExtraKindOrNumArgs - (unsigned)ObjCMultiArgSelector;\n  }\n};\n\n} // namespace detail\n\n}  // namespace clang\n\nnamespace llvm {\n\n/// Define DenseMapInfo so that Selectors can be used as keys in DenseMap and\n/// DenseSets.\ntemplate <>\nstruct DenseMapInfo<clang::Selector> {\n  static clang::Selector getEmptyKey() {\n    return clang::Selector::getEmptyMarker();\n  }\n\n  static clang::Selector getTombstoneKey() {\n    return clang::Selector::getTombstoneMarker();\n  }\n\n  static unsigned getHashValue(clang::Selector S);\n\n  static bool isEqual(clang::Selector LHS, clang::Selector RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate<>\nstruct PointerLikeTypeTraits<clang::Selector> {\n  static const void *getAsVoidPointer(clang::Selector P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static clang::Selector getFromVoidPointer(const void *P) {\n    return clang::Selector(reinterpret_cast<uintptr_t>(P));\n  }\n\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n// Provide PointerLikeTypeTraits for IdentifierInfo pointers, which\n// are not guaranteed to be 8-byte aligned.\ntemplate<>\nstruct PointerLikeTypeTraits<clang::IdentifierInfo*> {\n  static void *getAsVoidPointer(clang::IdentifierInfo* P) {\n    return P;\n  }\n\n  static clang::IdentifierInfo *getFromVoidPointer(void *P) {\n    return static_cast<clang::IdentifierInfo*>(P);\n  }\n\n  static constexpr int NumLowBitsAvailable = 1;\n};\n\ntemplate<>\nstruct PointerLikeTypeTraits<const clang::IdentifierInfo*> {\n  static const void *getAsVoidPointer(const clang::IdentifierInfo* P) {\n    return P;\n  }\n\n  static const clang::IdentifierInfo *getFromVoidPointer(const void *P) {\n    return static_cast<const clang::IdentifierInfo*>(P);\n  }\n\n  static constexpr int NumLowBitsAvailable = 1;\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "content": "//===- LangOptions.h - C Language Family Language Options -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::LangOptions interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_LANGOPTIONS_H\n#define LLVM_CLANG_BASIC_LANGOPTIONS_H\n\n#include \"clang/Basic/CommentOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Basic/ObjCRuntime.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// Bitfields of LangOptions, split out from LangOptions in order to ensure that\n/// this large collection of bitfields is a trivial class type.\nclass LangOptionsBase {\n  friend class CompilerInvocation;\n\npublic:\n  // Define simple language options (with no accessors).\n#define LANGOPT(Name, Bits, Default, Description) unsigned Name : Bits;\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description)\n#include \"clang/Basic/LangOptions.def\"\n\nprotected:\n  // Define language options of enumeration type. These are private, and will\n  // have accessors (below).\n#define LANGOPT(Name, Bits, Default, Description)\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  unsigned Name : Bits;\n#include \"clang/Basic/LangOptions.def\"\n};\n\n/// In the Microsoft ABI, this controls the placement of virtual displacement\n/// members used to implement virtual inheritance.\nenum class MSVtorDispMode { Never, ForVBaseOverride, ForVFTable };\n\n/// Keeps track of the various options that can be\n/// enabled, which controls the dialect of C or C++ that is accepted.\nclass LangOptions : public LangOptionsBase {\npublic:\n  using Visibility = clang::Visibility;\n  using RoundingMode = llvm::RoundingMode;\n\n  enum GCMode { NonGC, GCOnly, HybridGC };\n  enum StackProtectorMode { SSPOff, SSPOn, SSPStrong, SSPReq };\n\n  // Automatic variables live on the stack, and when trivial they're usually\n  // uninitialized because it's undefined behavior to use them without\n  // initializing them.\n  enum class TrivialAutoVarInitKind { Uninitialized, Zero, Pattern };\n\n  enum SignedOverflowBehaviorTy {\n    // Default C standard behavior.\n    SOB_Undefined,\n\n    // -fwrapv\n    SOB_Defined,\n\n    // -ftrapv\n    SOB_Trapping\n  };\n\n  // FIXME: Unify with TUKind.\n  enum CompilingModuleKind {\n    /// Not compiling a module interface at all.\n    CMK_None,\n\n    /// Compiling a module from a module map.\n    CMK_ModuleMap,\n\n    /// Compiling a module from a list of header files.\n    CMK_HeaderModule,\n\n    /// Compiling a C++ modules TS module interface unit.\n    CMK_ModuleInterface,\n  };\n\n  enum PragmaMSPointersToMembersKind {\n    PPTMK_BestCase,\n    PPTMK_FullGeneralitySingleInheritance,\n    PPTMK_FullGeneralityMultipleInheritance,\n    PPTMK_FullGeneralityVirtualInheritance\n  };\n\n  using MSVtorDispMode = clang::MSVtorDispMode;\n\n  enum DefaultCallingConvention {\n    DCC_None,\n    DCC_CDecl,\n    DCC_FastCall,\n    DCC_StdCall,\n    DCC_VectorCall,\n    DCC_RegCall\n  };\n\n  enum AddrSpaceMapMangling { ASMM_Target, ASMM_On, ASMM_Off };\n\n  // Corresponds to _MSC_VER\n  enum MSVCMajorVersion {\n    MSVC2010 = 1600,\n    MSVC2012 = 1700,\n    MSVC2013 = 1800,\n    MSVC2015 = 1900,\n    MSVC2017 = 1910,\n    MSVC2017_5 = 1912,\n    MSVC2017_7 = 1914,\n    MSVC2019 = 1920,\n  };\n\n  enum SYCLMajorVersion {\n    SYCL_None,\n    SYCL_2017,\n  };\n\n  /// Clang versions with different platform ABI conformance.\n  enum class ClangABI {\n    /// Attempt to be ABI-compatible with code generated by Clang 3.8.x\n    /// (SVN r257626). This causes <1 x long long> to be passed in an\n    /// integer register instead of an SSE register on x64_64.\n    Ver3_8,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 4.0.x\n    /// (SVN r291814). This causes move operations to be ignored when\n    /// determining whether a class type can be passed or returned directly.\n    Ver4,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 6.0.x\n    /// (SVN r321711). This causes determination of whether a type is\n    /// standard-layout to ignore collisions between empty base classes\n    /// and between base classes and member subobjects, which affects\n    /// whether we reuse base class tail padding in some ABIs.\n    Ver6,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 7.0.x\n    /// (SVN r338536). This causes alignof (C++) and _Alignof (C11) to be\n    /// compatible with __alignof (i.e., return the preferred alignment)\n    /// rather than returning the required alignment.\n    Ver7,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 9.0.x\n    /// (SVN r351319). This causes vectors of __int128 to be passed in memory\n    /// instead of passing in multiple scalar registers on x86_64 on Linux and\n    /// NetBSD.\n    Ver9,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 11.0.x\n    /// (git  2e10b7a39b93). This causes clang to pass unions with a 256-bit\n    /// vector member on the stack instead of using registers, to not properly\n    /// mangle substitutions for template names in some cases, and to mangle\n    /// declaration template arguments without a cast to the parameter type\n    /// even when that can lead to mangling collisions.\n    Ver11,\n\n    /// Conform to the underlying platform's C and C++ ABIs as closely\n    /// as we can.\n    Latest\n  };\n\n  enum class CoreFoundationABI {\n    /// No interoperability ABI has been specified\n    Unspecified,\n    /// CoreFoundation does not have any language interoperability\n    Standalone,\n    /// Interoperability with the ObjectiveC runtime\n    ObjectiveC,\n    /// Interoperability with the latest known version of the Swift runtime\n    Swift,\n    /// Interoperability with the Swift 5.0 runtime\n    Swift5_0,\n    /// Interoperability with the Swift 4.2 runtime\n    Swift4_2,\n    /// Interoperability with the Swift 4.1 runtime\n    Swift4_1,\n  };\n\n  enum FPModeKind {\n    // Disable the floating point pragma\n    FPM_Off,\n\n    // Enable the floating point pragma\n    FPM_On,\n\n    // Aggressively fuse FP ops (E.g. FMA) disregarding pragmas.\n    FPM_Fast,\n\n    // Aggressively fuse FP ops and honor pragmas.\n    FPM_FastHonorPragmas\n  };\n\n  /// Alias for RoundingMode::NearestTiesToEven.\n  static constexpr unsigned FPR_ToNearest =\n      static_cast<unsigned>(llvm::RoundingMode::NearestTiesToEven);\n\n  /// Possible floating point exception behavior.\n  enum FPExceptionModeKind {\n    /// Assume that floating-point exceptions are masked.\n    FPE_Ignore,\n    /// Transformations do not cause new exceptions but may hide some.\n    FPE_MayTrap,\n    /// Strictly preserve the floating-point exception semantics.\n    FPE_Strict\n  };\n\n  /// Possible exception handling behavior.\n  using ExceptionHandlingKind = llvm::ExceptionHandling;\n\n  enum class LaxVectorConversionKind {\n    /// Permit no implicit vector bitcasts.\n    None,\n    /// Permit vector bitcasts between integer vectors with different numbers\n    /// of elements but the same total bit-width.\n    Integer,\n    /// Permit vector bitcasts between all vectors with the same total\n    /// bit-width.\n    All,\n  };\n\n  enum class SignReturnAddressScopeKind {\n    /// No signing for any function.\n    None,\n    /// Sign the return address of functions that spill LR.\n    NonLeaf,\n    /// Sign the return address of all functions,\n    All\n  };\n\n  enum class SignReturnAddressKeyKind {\n    /// Return address signing uses APIA key.\n    AKey,\n    /// Return address signing uses APIB key.\n    BKey\n  };\n\n  enum class ThreadModelKind {\n    /// POSIX Threads.\n    POSIX,\n    /// Single Threaded Environment.\n    Single\n  };\n\npublic:\n  /// The used language standard.\n  LangStandard::Kind LangStd;\n\n  /// Set of enabled sanitizers.\n  SanitizerSet Sanitize;\n\n  /// Paths to files specifying which objects\n  /// (files, functions, variables) should not be instrumented.\n  std::vector<std::string> NoSanitizeFiles;\n\n  /// Paths to the XRay \"always instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"always instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayAlwaysInstrumentFiles;\n\n  /// Paths to the XRay \"never instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"never instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayNeverInstrumentFiles;\n\n  /// Paths to the XRay attribute list files, specifying which objects\n  /// (files, functions, variables) should be imbued with the appropriate XRay\n  /// attribute(s).\n  std::vector<std::string> XRayAttrListFiles;\n\n  /// Paths to special case list files specifying which entities\n  /// (files, functions) should or should not be instrumented.\n  std::vector<std::string> ProfileListFiles;\n\n  clang::ObjCRuntime ObjCRuntime;\n\n  CoreFoundationABI CFRuntime = CoreFoundationABI::Unspecified;\n\n  std::string ObjCConstantStringClass;\n\n  /// The name of the handler function to be called when -ftrapv is\n  /// specified.\n  ///\n  /// If none is specified, abort (GCC-compatible behaviour).\n  std::string OverflowHandler;\n\n  /// The module currently being compiled as specified by -fmodule-name.\n  std::string ModuleName;\n\n  /// The name of the current module, of which the main source file\n  /// is a part. If CompilingModule is set, we are compiling the interface\n  /// of this module, otherwise we are compiling an implementation file of\n  /// it. This starts as ModuleName in case -fmodule-name is provided and\n  /// changes during compilation to reflect the current module.\n  std::string CurrentModule;\n\n  /// The names of any features to enable in module 'requires' decls\n  /// in addition to the hard-coded list in Module.cpp and the target features.\n  ///\n  /// This list is sorted.\n  std::vector<std::string> ModuleFeatures;\n\n  /// Options for parsing comments.\n  CommentOptions CommentOpts;\n\n  /// A list of all -fno-builtin-* function names (e.g., memset).\n  std::vector<std::string> NoBuiltinFuncs;\n\n  /// Triples of the OpenMP targets that the host code codegen should\n  /// take into account in order to generate accurate offloading descriptors.\n  std::vector<llvm::Triple> OMPTargetTriples;\n\n  /// Name of the IR file that contains the result of the OpenMP target\n  /// host code generation.\n  std::string OMPHostIRFile;\n\n  /// The user provided compilation unit ID, if non-empty. This is used to\n  /// externalize static variables which is needed to support accessing static\n  /// device variables in host code for single source offloading languages\n  /// like CUDA/HIP.\n  std::string CUID;\n\n  /// Indicates whether the front-end is explicitly told that the\n  /// input is a header file (i.e. -x c-header).\n  bool IsHeaderFile = false;\n\n  LangOptions();\n\n  // Define accessors/mutators for language options of enumeration type.\n#define LANGOPT(Name, Bits, Default, Description)\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/LangOptions.def\"\n\n  /// Are we compiling a module interface (.cppm or module map)?\n  bool isCompilingModule() const {\n    return getCompilingModule() != CMK_None;\n  }\n\n  /// Do we need to track the owning module for a local declaration?\n  bool trackLocalOwningModule() const {\n    return isCompilingModule() || ModulesLocalVisibility;\n  }\n\n  bool isSignedOverflowDefined() const {\n    return getSignedOverflowBehavior() == SOB_Defined;\n  }\n\n  bool isSubscriptPointerArithmetic() const {\n    return ObjCRuntime.isSubscriptPointerArithmetic() &&\n           !ObjCSubscriptingLegacyRuntime;\n  }\n\n  bool isCompatibleWithMSVC(MSVCMajorVersion MajorVersion) const {\n    return MSCompatibilityVersion >= MajorVersion * 100000U;\n  }\n\n  /// Reset all of the options that are not considered when building a\n  /// module.\n  void resetNonModularOptions();\n\n  /// Is this a libc/libm function that is no longer recognized as a\n  /// builtin because a -fno-builtin-* option has been specified?\n  bool isNoBuiltinFunc(StringRef Name) const;\n\n  /// True if any ObjC types may have non-trivial lifetime qualifiers.\n  bool allowsNonTrivialObjCLifetimeQualifiers() const {\n    return ObjCAutoRefCount || ObjCWeak;\n  }\n\n  bool assumeFunctionsAreConvergent() const {\n    return ConvergentFunctions;\n  }\n\n  /// Return the OpenCL C or C++ version as a VersionTuple.\n  VersionTuple getOpenCLVersionTuple() const;\n\n  /// Check if return address signing is enabled.\n  bool hasSignReturnAddress() const {\n    return getSignReturnAddressScope() != SignReturnAddressScopeKind::None;\n  }\n\n  /// Check if return address signing uses AKey.\n  bool isSignReturnAddressWithAKey() const {\n    return getSignReturnAddressKey() == SignReturnAddressKeyKind::AKey;\n  }\n\n  /// Check if leaf functions are also signed.\n  bool isSignReturnAddressScopeAll() const {\n    return getSignReturnAddressScope() == SignReturnAddressScopeKind::All;\n  }\n\n  bool hasSjLjExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::SjLj;\n  }\n\n  bool hasSEHExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::WinEH;\n  }\n\n  bool hasDWARFExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::DwarfCFI;\n  }\n\n  bool hasWasmExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::Wasm;\n  }\n};\n\n/// Floating point control options\nclass FPOptionsOverride;\nclass FPOptions {\npublic:\n  // We start by defining the layout.\n  using storage_type = uint16_t;\n\n  using RoundingMode = llvm::RoundingMode;\n\n  static constexpr unsigned StorageBitSize = 8 * sizeof(storage_type);\n\n  // Define a fake option named \"First\" so that we have a PREVIOUS even for the\n  // real first option.\n  static constexpr storage_type FirstShift = 0, FirstWidth = 0;\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  static constexpr storage_type NAME##Shift =                                  \\\n      PREVIOUS##Shift + PREVIOUS##Width;                                       \\\n  static constexpr storage_type NAME##Width = WIDTH;                           \\\n  static constexpr storage_type NAME##Mask = ((1 << NAME##Width) - 1)          \\\n                                             << NAME##Shift;\n#include \"clang/Basic/FPOptions.def\"\n\n  static constexpr storage_type TotalWidth = 0\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS) +WIDTH\n#include \"clang/Basic/FPOptions.def\"\n      ;\n  static_assert(TotalWidth <= StorageBitSize, \"Too short type for FPOptions\");\n\nprivate:\n  storage_type Value;\n\npublic:\n  FPOptions() : Value(0) {\n    setFPContractMode(LangOptions::FPM_Off);\n    setRoundingMode(static_cast<RoundingMode>(LangOptions::FPR_ToNearest));\n    setFPExceptionMode(LangOptions::FPE_Ignore);\n  }\n  explicit FPOptions(const LangOptions &LO) {\n    Value = 0;\n    // The language fp contract option FPM_FastHonorPragmas has the same effect\n    // as FPM_Fast in frontend. For simplicity, use FPM_Fast uniformly in\n    // frontend.\n    auto LangOptContractMode = LO.getDefaultFPContractMode();\n    if (LangOptContractMode == LangOptions::FPM_FastHonorPragmas)\n      LangOptContractMode = LangOptions::FPM_Fast;\n    setFPContractMode(LangOptContractMode);\n    setRoundingMode(LO.getFPRoundingMode());\n    setFPExceptionMode(LO.getFPExceptionMode());\n    setAllowFPReassociate(LO.AllowFPReassoc);\n    setNoHonorNaNs(LO.NoHonorNaNs);\n    setNoHonorInfs(LO.NoHonorInfs);\n    setNoSignedZero(LO.NoSignedZero);\n    setAllowReciprocal(LO.AllowRecip);\n    setAllowApproxFunc(LO.ApproxFunc);\n    if (getFPContractMode() == LangOptions::FPM_On &&\n        getRoundingMode() == llvm::RoundingMode::Dynamic &&\n        getFPExceptionMode() == LangOptions::FPE_Strict)\n      // If the FP settings are set to the \"strict\" model, then\n      // FENV access is set to true. (ffp-model=strict)\n      setAllowFEnvAccess(true);\n    else\n      setAllowFEnvAccess(LangOptions::FPM_Off);\n  }\n\n  bool allowFPContractWithinStatement() const {\n    return getFPContractMode() == LangOptions::FPM_On;\n  }\n  void setAllowFPContractWithinStatement() {\n    setFPContractMode(LangOptions::FPM_On);\n  }\n\n  bool allowFPContractAcrossStatement() const {\n    return getFPContractMode() == LangOptions::FPM_Fast;\n  }\n  void setAllowFPContractAcrossStatement() {\n    setFPContractMode(LangOptions::FPM_Fast);\n  }\n\n  bool isFPConstrained() const {\n    return getRoundingMode() != llvm::RoundingMode::NearestTiesToEven ||\n           getFPExceptionMode() != LangOptions::FPE_Ignore ||\n           getAllowFEnvAccess();\n  }\n\n  bool operator==(FPOptions other) const { return Value == other.Value; }\n\n  /// Return the default value of FPOptions that's used when trailing\n  /// storage isn't required.\n  static FPOptions defaultWithoutTrailingStorage(const LangOptions &LO);\n\n  storage_type getAsOpaqueInt() const { return Value; }\n  static FPOptions getFromOpaqueInt(storage_type Value) {\n    FPOptions Opts;\n    Opts.Value = Value;\n    return Opts;\n  }\n\n  // We can define most of the accessors automatically:\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  TYPE get##NAME() const {                                                     \\\n    return static_cast<TYPE>((Value & NAME##Mask) >> NAME##Shift);             \\\n  }                                                                            \\\n  void set##NAME(TYPE value) {                                                 \\\n    Value = (Value & ~NAME##Mask) | (storage_type(value) << NAME##Shift);      \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n};\n\n/// Represents difference between two FPOptions values.\n///\n/// The effect of language constructs changing the set of floating point options\n/// is usually a change of some FP properties while leaving others intact. This\n/// class describes such changes by keeping information about what FP options\n/// are overridden.\n///\n/// The integral set of FP options, described by the class FPOptions, may be\n/// represented as a default FP option set, defined by language standard and\n/// command line options, with the overrides introduced by pragmas.\n///\n/// The is implemented as a value of the new FPOptions plus a mask showing which\n/// fields are actually set in it.\nclass FPOptionsOverride {\n  FPOptions Options = FPOptions::getFromOpaqueInt(0);\n  FPOptions::storage_type OverrideMask = 0;\n\npublic:\n  using RoundingMode = llvm::RoundingMode;\n\n  /// The type suitable for storing values of FPOptionsOverride. Must be twice\n  /// as wide as bit size of FPOption.\n  using storage_type = uint32_t;\n  static_assert(sizeof(storage_type) >= 2 * sizeof(FPOptions::storage_type),\n                \"Too short type for FPOptionsOverride\");\n\n  /// Bit mask selecting bits of OverrideMask in serialized representation of\n  /// FPOptionsOverride.\n  static constexpr storage_type OverrideMaskBits =\n      (static_cast<storage_type>(1) << FPOptions::StorageBitSize) - 1;\n\n  FPOptionsOverride() {}\n  FPOptionsOverride(const LangOptions &LO)\n      : Options(LO), OverrideMask(OverrideMaskBits) {}\n  FPOptionsOverride(FPOptions FPO)\n      : Options(FPO), OverrideMask(OverrideMaskBits) {}\n\n  bool requiresTrailingStorage() const { return OverrideMask != 0; }\n\n  void setAllowFPContractWithinStatement() {\n    setFPContractModeOverride(LangOptions::FPM_On);\n  }\n\n  void setAllowFPContractAcrossStatement() {\n    setFPContractModeOverride(LangOptions::FPM_Fast);\n  }\n\n  void setDisallowFPContract() {\n    setFPContractModeOverride(LangOptions::FPM_Off);\n  }\n\n  void setFPPreciseEnabled(bool Value) {\n    setAllowFPReassociateOverride(!Value);\n    setNoHonorNaNsOverride(!Value);\n    setNoHonorInfsOverride(!Value);\n    setNoSignedZeroOverride(!Value);\n    setAllowReciprocalOverride(!Value);\n    setAllowApproxFuncOverride(!Value);\n    if (Value)\n      /* Precise mode implies fp_contract=on and disables ffast-math */\n      setAllowFPContractWithinStatement();\n    else\n      /* Precise mode disabled sets fp_contract=fast and enables ffast-math */\n      setAllowFPContractAcrossStatement();\n  }\n\n  storage_type getAsOpaqueInt() const {\n    return (static_cast<storage_type>(Options.getAsOpaqueInt())\n            << FPOptions::StorageBitSize) |\n           OverrideMask;\n  }\n  static FPOptionsOverride getFromOpaqueInt(storage_type I) {\n    FPOptionsOverride Opts;\n    Opts.OverrideMask = I & OverrideMaskBits;\n    Opts.Options = FPOptions::getFromOpaqueInt(I >> FPOptions::StorageBitSize);\n    return Opts;\n  }\n\n  FPOptions applyOverrides(FPOptions Base) {\n    FPOptions Result =\n        FPOptions::getFromOpaqueInt((Base.getAsOpaqueInt() & ~OverrideMask) |\n                                     (Options.getAsOpaqueInt() & OverrideMask));\n    return Result;\n  }\n\n  FPOptions applyOverrides(const LangOptions &LO) {\n    return applyOverrides(FPOptions(LO));\n  }\n\n  bool operator==(FPOptionsOverride other) const {\n    return Options == other.Options && OverrideMask == other.OverrideMask;\n  }\n  bool operator!=(FPOptionsOverride other) const { return !(*this == other); }\n\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  bool has##NAME##Override() const {                                           \\\n    return OverrideMask & FPOptions::NAME##Mask;                               \\\n  }                                                                            \\\n  TYPE get##NAME##Override() const {                                           \\\n    assert(has##NAME##Override());                                             \\\n    return Options.get##NAME();                                                \\\n  }                                                                            \\\n  void clear##NAME##Override() {                                               \\\n    /* Clear the actual value so that we don't have spurious differences when  \\\n     * testing equality. */                                                    \\\n    Options.set##NAME(TYPE(0));                                                \\\n    OverrideMask &= ~FPOptions::NAME##Mask;                                    \\\n  }                                                                            \\\n  void set##NAME##Override(TYPE value) {                                       \\\n    Options.set##NAME(value);                                                  \\\n    OverrideMask |= FPOptions::NAME##Mask;                                     \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n};\n\n/// Describes the kind of translation unit being processed.\nenum TranslationUnitKind {\n  /// The translation unit is a complete translation unit.\n  TU_Complete,\n\n  /// The translation unit is a prefix to a translation unit, and is\n  /// not complete.\n  TU_Prefix,\n\n  /// The translation unit is a module.\n  TU_Module\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_LANGOPTIONS_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "content": "//===- PartialDiagnostic.h - Diagnostic \"closures\" --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Implements a partial diagnostic that can be emitted anwyhere\n/// in a DiagnosticBuilder stream.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n#define LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass DeclContext;\nclass IdentifierInfo;\n\nclass PartialDiagnostic : public StreamingDiagnostic {\nprivate:\n  // NOTE: Sema assumes that PartialDiagnostic is location-invariant\n  // in the sense that its bits can be safely memcpy'ed and destructed\n  // in the new location.\n\n  /// The diagnostic ID.\n  mutable unsigned DiagID = 0;\npublic:\n  struct NullDiagnostic {};\n\n  /// Create a null partial diagnostic, which cannot carry a payload,\n  /// and only exists to be swapped with a real partial diagnostic.\n  PartialDiagnostic(NullDiagnostic) {}\n\n  PartialDiagnostic(unsigned DiagID, DiagStorageAllocator &Allocator_)\n      : StreamingDiagnostic(Allocator_), DiagID(DiagID) {}\n\n  PartialDiagnostic(const PartialDiagnostic &Other)\n      : StreamingDiagnostic(), DiagID(Other.DiagID) {\n    Allocator = Other.Allocator;\n    if (Other.DiagStorage) {\n      DiagStorage = getStorage();\n      *DiagStorage = *Other.DiagStorage;\n    }\n  }\n\n  template <typename T> const PartialDiagnostic &operator<<(const T &V) const {\n    const StreamingDiagnostic &DB = *this;\n    DB << V;\n    return *this;\n  }\n\n  // It is necessary to limit this to rvalue reference to avoid calling this\n  // function with a bitfield lvalue argument since non-const reference to\n  // bitfield is not allowed.\n  template <typename T, typename = typename std::enable_if<\n                            !std::is_lvalue_reference<T>::value>::type>\n  const PartialDiagnostic &operator<<(T &&V) const {\n    const StreamingDiagnostic &DB = *this;\n    DB << std::move(V);\n    return *this;\n  }\n\n  PartialDiagnostic(PartialDiagnostic &&Other) : DiagID(Other.DiagID) {\n    Allocator = Other.Allocator;\n    DiagStorage = Other.DiagStorage;\n    Other.DiagStorage = nullptr;\n  }\n\n  PartialDiagnostic(const PartialDiagnostic &Other,\n                    DiagnosticStorage *DiagStorage_)\n      : DiagID(Other.DiagID) {\n    Allocator = reinterpret_cast<DiagStorageAllocator *>(~uintptr_t(0));\n    DiagStorage = DiagStorage_;\n    if (Other.DiagStorage)\n      *this->DiagStorage = *Other.DiagStorage;\n  }\n\n  PartialDiagnostic(const Diagnostic &Other, DiagStorageAllocator &Allocator_)\n      : DiagID(Other.getID()) {\n    Allocator = &Allocator_;\n    // Copy arguments.\n    for (unsigned I = 0, N = Other.getNumArgs(); I != N; ++I) {\n      if (Other.getArgKind(I) == DiagnosticsEngine::ak_std_string)\n        AddString(Other.getArgStdStr(I));\n      else\n        AddTaggedVal(Other.getRawArg(I), Other.getArgKind(I));\n    }\n\n    // Copy source ranges.\n    for (unsigned I = 0, N = Other.getNumRanges(); I != N; ++I)\n      AddSourceRange(Other.getRange(I));\n\n    // Copy fix-its.\n    for (unsigned I = 0, N = Other.getNumFixItHints(); I != N; ++I)\n      AddFixItHint(Other.getFixItHint(I));\n  }\n\n  PartialDiagnostic &operator=(const PartialDiagnostic &Other) {\n    DiagID = Other.DiagID;\n    if (Other.DiagStorage) {\n      if (!DiagStorage)\n        DiagStorage = getStorage();\n\n      *DiagStorage = *Other.DiagStorage;\n    } else {\n      freeStorage();\n    }\n\n    return *this;\n  }\n\n  PartialDiagnostic &operator=(PartialDiagnostic &&Other) {\n    freeStorage();\n\n    DiagID = Other.DiagID;\n    DiagStorage = Other.DiagStorage;\n    Allocator = Other.Allocator;\n\n    Other.DiagStorage = nullptr;\n    return *this;\n  }\n\n  void swap(PartialDiagnostic &PD) {\n    std::swap(DiagID, PD.DiagID);\n    std::swap(DiagStorage, PD.DiagStorage);\n    std::swap(Allocator, PD.Allocator);\n  }\n\n  unsigned getDiagID() const { return DiagID; }\n  void setDiagID(unsigned ID) { DiagID = ID; }\n\n  void Emit(const DiagnosticBuilder &DB) const {\n    if (!DiagStorage)\n      return;\n\n    // Add all arguments.\n    for (unsigned i = 0, e = DiagStorage->NumDiagArgs; i != e; ++i) {\n      if ((DiagnosticsEngine::ArgumentKind)DiagStorage->DiagArgumentsKind[i]\n            == DiagnosticsEngine::ak_std_string)\n        DB.AddString(DiagStorage->DiagArgumentsStr[i]);\n      else\n        DB.AddTaggedVal(DiagStorage->DiagArgumentsVal[i],\n            (DiagnosticsEngine::ArgumentKind)DiagStorage->DiagArgumentsKind[i]);\n    }\n\n    // Add all ranges.\n    for (const CharSourceRange &Range : DiagStorage->DiagRanges)\n      DB.AddSourceRange(Range);\n\n    // Add all fix-its.\n    for (const FixItHint &Fix : DiagStorage->FixItHints)\n      DB.AddFixItHint(Fix);\n  }\n\n  void EmitToString(DiagnosticsEngine &Diags,\n                    SmallVectorImpl<char> &Buf) const {\n    // FIXME: It should be possible to render a diagnostic to a string without\n    //        messing with the state of the diagnostics engine.\n    DiagnosticBuilder DB(Diags.Report(getDiagID()));\n    Emit(DB);\n    Diagnostic(&Diags).FormatDiagnostic(Buf);\n    DB.Clear();\n    Diags.Clear();\n  }\n\n  /// Clear out this partial diagnostic, giving it a new diagnostic ID\n  /// and removing all of its arguments, ranges, and fix-it hints.\n  void Reset(unsigned DiagID = 0) {\n    this->DiagID = DiagID;\n    freeStorage();\n  }\n\n  bool hasStorage() const { return DiagStorage != nullptr; }\n\n  /// Retrieve the string argument at the given index.\n  StringRef getStringArg(unsigned I) {\n    assert(DiagStorage && \"No diagnostic storage?\");\n    assert(I < DiagStorage->NumDiagArgs && \"Not enough diagnostic args\");\n    assert(DiagStorage->DiagArgumentsKind[I]\n             == DiagnosticsEngine::ak_std_string && \"Not a string arg\");\n    return DiagStorage->DiagArgumentsStr[I];\n  }\n};\n\ninline const DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB,\n                                           const PartialDiagnostic &PD) {\n  PD.Emit(DB);\n  return DB;\n}\n\n/// A partial diagnostic along with the source location where this\n/// diagnostic occurs.\nusing PartialDiagnosticAt = std::pair<SourceLocation, PartialDiagnostic>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SyncScope.h", "content": "//===--- SyncScope.h - Atomic synchronization scopes ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Provides definitions for the atomic synchronization scopes.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SYNCSCOPE_H\n#define LLVM_CLANG_BASIC_SYNCSCOPE_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n\nnamespace clang {\n\n/// Defines synch scope values used internally by clang.\n///\n/// The enum values start from 0 and are contiguous. They are mainly used for\n/// enumerating all supported synch scope values and mapping them to LLVM\n/// synch scopes. Their numerical values may be different from the corresponding\n/// synch scope enums used in source languages.\n///\n/// In atomic builtin and expressions, language-specific synch scope enums are\n/// used. Currently only OpenCL memory scope enums are supported and assumed\n/// to be used by all languages. However, in the future, other languages may\n/// define their own set of synch scope enums. The language-specific synch scope\n/// values are represented by class AtomicScopeModel and its derived classes.\n///\n/// To add a new enum value:\n///   Add the enum value to enum class SyncScope.\n///   Update enum value Last if necessary.\n///   Update getAsString.\n///\nenum class SyncScope {\n  OpenCLWorkGroup,\n  OpenCLDevice,\n  OpenCLAllSVMDevices,\n  OpenCLSubGroup,\n  Last = OpenCLSubGroup\n};\n\ninline llvm::StringRef getAsString(SyncScope S) {\n  switch (S) {\n  case SyncScope::OpenCLWorkGroup:\n    return \"opencl_workgroup\";\n  case SyncScope::OpenCLDevice:\n    return \"opencl_device\";\n  case SyncScope::OpenCLAllSVMDevices:\n    return \"opencl_allsvmdevices\";\n  case SyncScope::OpenCLSubGroup:\n    return \"opencl_subgroup\";\n  }\n  llvm_unreachable(\"Invalid synch scope\");\n}\n\n/// Defines the kind of atomic scope models.\nenum class AtomicScopeModelKind { None, OpenCL };\n\n/// Defines the interface for synch scope model.\nclass AtomicScopeModel {\npublic:\n  virtual ~AtomicScopeModel() {}\n  /// Maps language specific synch scope values to internal\n  /// SyncScope enum.\n  virtual SyncScope map(unsigned S) const = 0;\n\n  /// Check if the compile-time constant synch scope value\n  /// is valid.\n  virtual bool isValid(unsigned S) const = 0;\n\n  /// Get all possible synch scope values that might be\n  /// encountered at runtime for the current language.\n  virtual ArrayRef<unsigned> getRuntimeValues() const = 0;\n\n  /// If atomic builtin function is called with invalid\n  /// synch scope value at runtime, it will fall back to a valid\n  /// synch scope value returned by this function.\n  virtual unsigned getFallBackValue() const = 0;\n\n  /// Create an atomic scope model by AtomicScopeModelKind.\n  /// \\return an empty std::unique_ptr for AtomicScopeModelKind::None.\n  static std::unique_ptr<AtomicScopeModel> create(AtomicScopeModelKind K);\n};\n\n/// Defines the synch scope model for OpenCL.\nclass AtomicScopeOpenCLModel : public AtomicScopeModel {\npublic:\n  /// The enum values match the pre-defined macros\n  /// __OPENCL_MEMORY_SCOPE_*, which are used to define memory_scope_*\n  /// enums in opencl-c-base.h.\n  enum ID {\n    WorkGroup = 1,\n    Device = 2,\n    AllSVMDevices = 3,\n    SubGroup = 4,\n    Last = SubGroup\n  };\n\n  AtomicScopeOpenCLModel() {}\n\n  SyncScope map(unsigned S) const override {\n    switch (static_cast<ID>(S)) {\n    case WorkGroup:\n      return SyncScope::OpenCLWorkGroup;\n    case Device:\n      return SyncScope::OpenCLDevice;\n    case AllSVMDevices:\n      return SyncScope::OpenCLAllSVMDevices;\n    case SubGroup:\n      return SyncScope::OpenCLSubGroup;\n    }\n    llvm_unreachable(\"Invalid language synch scope value\");\n  }\n\n  bool isValid(unsigned S) const override {\n    return S >= static_cast<unsigned>(WorkGroup) &&\n           S <= static_cast<unsigned>(Last);\n  }\n\n  ArrayRef<unsigned> getRuntimeValues() const override {\n    static_assert(Last == SubGroup, \"Does not include all synch scopes\");\n    static const unsigned Scopes[] = {\n        static_cast<unsigned>(WorkGroup), static_cast<unsigned>(Device),\n        static_cast<unsigned>(AllSVMDevices), static_cast<unsigned>(SubGroup)};\n    return llvm::makeArrayRef(Scopes);\n  }\n\n  unsigned getFallBackValue() const override {\n    return static_cast<unsigned>(AllSVMDevices);\n  }\n};\n\ninline std::unique_ptr<AtomicScopeModel>\nAtomicScopeModel::create(AtomicScopeModelKind K) {\n  switch (K) {\n  case AtomicScopeModelKind::None:\n    return std::unique_ptr<AtomicScopeModel>{};\n  case AtomicScopeModelKind::OpenCL:\n    return std::make_unique<AtomicScopeOpenCLModel>();\n  }\n  llvm_unreachable(\"Invalid atomic scope model kind\");\n}\n}\n\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Visibility.h", "content": "//===--- Visibility.h - Visibility enumeration and utilities ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the clang::Visibility enumeration and various utility\n/// functions.\n///\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_BASIC_VISIBILITY_H\n#define LLVM_CLANG_BASIC_VISIBILITY_H\n\n#include \"clang/Basic/Linkage.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace clang {\n\n/// Describes the different kinds of visibility that a declaration\n/// may have.\n///\n/// Visibility determines how a declaration interacts with the dynamic\n/// linker.  It may also affect whether the symbol can be found by runtime\n/// symbol lookup APIs.\n///\n/// Visibility is not described in any language standard and\n/// (nonetheless) sometimes has odd behavior.  Not all platforms\n/// support all visibility kinds.\nenum Visibility {\n  /// Objects with \"hidden\" visibility are not seen by the dynamic\n  /// linker.\n  HiddenVisibility,\n\n  /// Objects with \"protected\" visibility are seen by the dynamic\n  /// linker but always dynamically resolve to an object within this\n  /// shared object.\n  ProtectedVisibility,\n\n  /// Objects with \"default\" visibility are seen by the dynamic linker\n  /// and act like normal objects.\n  DefaultVisibility\n};\n\ninline Visibility minVisibility(Visibility L, Visibility R) {\n  return L < R ? L : R;\n}\n\nclass LinkageInfo {\n  uint8_t linkage_    : 3;\n  uint8_t visibility_ : 2;\n  uint8_t explicit_   : 1;\n\n  void setVisibility(Visibility V, bool E) { visibility_ = V; explicit_ = E; }\npublic:\n  LinkageInfo() : linkage_(ExternalLinkage), visibility_(DefaultVisibility),\n                  explicit_(false) {}\n  LinkageInfo(Linkage L, Visibility V, bool E)\n    : linkage_(L), visibility_(V), explicit_(E) {\n    assert(getLinkage() == L && getVisibility() == V &&\n           isVisibilityExplicit() == E && \"Enum truncated!\");\n  }\n\n  static LinkageInfo external() {\n    return LinkageInfo();\n  }\n  static LinkageInfo internal() {\n    return LinkageInfo(InternalLinkage, DefaultVisibility, false);\n  }\n  static LinkageInfo uniqueExternal() {\n    return LinkageInfo(UniqueExternalLinkage, DefaultVisibility, false);\n  }\n  static LinkageInfo none() {\n    return LinkageInfo(NoLinkage, DefaultVisibility, false);\n  }\n  static LinkageInfo visible_none() {\n    return LinkageInfo(VisibleNoLinkage, DefaultVisibility, false);\n  }\n\n  Linkage getLinkage() const { return (Linkage)linkage_; }\n  Visibility getVisibility() const { return (Visibility)visibility_; }\n  bool isVisibilityExplicit() const { return explicit_; }\n\n  void setLinkage(Linkage L) { linkage_ = L; }\n\n  void mergeLinkage(Linkage L) {\n    setLinkage(minLinkage(getLinkage(), L));\n  }\n  void mergeLinkage(LinkageInfo other) {\n    mergeLinkage(other.getLinkage());\n  }\n\n  void mergeExternalVisibility(Linkage L) {\n    Linkage ThisL = getLinkage();\n    if (!isExternallyVisible(L)) {\n      if (ThisL == VisibleNoLinkage)\n        ThisL = NoLinkage;\n      else if (ThisL == ExternalLinkage)\n        ThisL = UniqueExternalLinkage;\n    }\n    setLinkage(ThisL);\n  }\n  void mergeExternalVisibility(LinkageInfo Other) {\n    mergeExternalVisibility(Other.getLinkage());\n  }\n\n  /// Merge in the visibility 'newVis'.\n  void mergeVisibility(Visibility newVis, bool newExplicit) {\n    Visibility oldVis = getVisibility();\n\n    // Never increase visibility.\n    if (oldVis < newVis)\n      return;\n\n    // If the new visibility is the same as the old and the new\n    // visibility isn't explicit, we have nothing to add.\n    if (oldVis == newVis && !newExplicit)\n      return;\n\n    // Otherwise, we're either decreasing visibility or making our\n    // existing visibility explicit.\n    setVisibility(newVis, newExplicit);\n  }\n  void mergeVisibility(LinkageInfo other) {\n    mergeVisibility(other.getVisibility(), other.isVisibilityExplicit());\n  }\n\n  /// Merge both linkage and visibility.\n  void merge(LinkageInfo other) {\n    mergeLinkage(other);\n    mergeVisibility(other);\n  }\n\n  /// Merge linkage and conditionally merge visibility.\n  void mergeMaybeWithVisibility(LinkageInfo other, bool withVis) {\n    mergeLinkage(other);\n    if (withVis) mergeVisibility(other);\n  }\n};\n}\n\n#endif // LLVM_CLANG_BASIC_VISIBILITY_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h", "content": "//===- DynamicTypeInfo.h - Runtime type information -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_DYNAMICTYPEINFO_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_DYNAMICTYPEINFO_H\n\n#include \"clang/AST/Type.h\"\n\nnamespace clang {\nnamespace ento {\n\n/// Stores the currently inferred strictest bound on the runtime type\n/// of a region in a given state along the analysis path.\nclass DynamicTypeInfo {\npublic:\n  DynamicTypeInfo() : DynTy(QualType()) {}\n\n  DynamicTypeInfo(QualType Ty, bool CanBeSub = true)\n      : DynTy(Ty), CanBeASubClass(CanBeSub) {}\n\n  /// Returns false if the type information is precise (the type 'DynTy' is\n  /// the only type in the lattice), true otherwise.\n  bool canBeASubClass() const { return CanBeASubClass; }\n\n  /// Returns true if the dynamic type info is available.\n  bool isValid() const { return !DynTy.isNull(); }\n\n  /// Returns the currently inferred upper bound on the runtime type.\n  QualType getType() const { return DynTy; }\n\n  operator bool() const { return isValid(); }\n\n  bool operator==(const DynamicTypeInfo &RHS) const {\n    return DynTy == RHS.DynTy && CanBeASubClass == RHS.CanBeASubClass;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.Add(DynTy);\n    ID.AddBoolean(CanBeASubClass);\n  }\n\nprivate:\n  QualType DynTy;\n  bool CanBeASubClass;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_DYNAMICTYPEINFO_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "content": "//===- SVals.h - Abstract Values for Static Analysis ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines SVal, Loc, and NonLoc, classes that represent\n//  abstract r-values for use with path-sensitive value tracking.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableList.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n#include <utility>\n\n//==------------------------------------------------------------------------==//\n//  Base SVal types.\n//==------------------------------------------------------------------------==//\n\nnamespace clang {\n\nclass CXXBaseSpecifier;\nclass DeclaratorDecl;\nclass FunctionDecl;\nclass LabelDecl;\n\nnamespace ento {\n\nclass BasicValueFactory;\nclass CompoundValData;\nclass LazyCompoundValData;\nclass MemRegion;\nclass PointerToMemberData;\nclass SValBuilder;\nclass TypedValueRegion;\n\nnamespace nonloc {\n\n/// Sub-kinds for NonLoc values.\nenum Kind {\n#define NONLOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace nonloc\n\nnamespace loc {\n\n/// Sub-kinds for Loc values.\nenum Kind {\n#define LOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace loc\n\n/// SVal - This represents a symbolic expression, which can be either\n///  an L-value or an R-value.\n///\nclass SVal {\npublic:\n  enum BaseKind {\n    // The enumerators must be representable using 2 bits.\n#define BASIC_SVAL(Id, Parent) Id ## Kind,\n#define ABSTRACT_SVAL_WITH_KIND(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n  };\n  enum { BaseBits = 2, BaseMask = 0b11 };\n\nprotected:\n  const void *Data = nullptr;\n\n  /// The lowest 2 bits are a BaseKind (0 -- 3).\n  ///  The higher bits are an unsigned \"kind\" value.\n  unsigned Kind = 0;\n\n  explicit SVal(const void *d, bool isLoc, unsigned ValKind)\n      : Data(d), Kind((isLoc ? LocKind : NonLocKind) | (ValKind << BaseBits)) {}\n\n  explicit SVal(BaseKind k, const void *D = nullptr) : Data(D), Kind(k) {}\n\npublic:\n  explicit SVal() = default;\n\n  /// Convert to the specified SVal type, asserting that this SVal is of\n  /// the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    return *static_cast<const T *>(this);\n  }\n\n  /// Convert to the specified SVal type, returning None if this SVal is\n  /// not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    return *static_cast<const T *>(this);\n  }\n\n  unsigned getRawKind() const { return Kind; }\n  BaseKind getBaseKind() const { return (BaseKind) (Kind & BaseMask); }\n  unsigned getSubKind() const { return Kind >> BaseBits; }\n\n  // This method is required for using SVal in a FoldingSetNode.  It\n  // extracts a unique signature for this SVal object.\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger((unsigned) getRawKind());\n    ID.AddPointer(Data);\n  }\n\n  bool operator==(const SVal &R) const {\n    return getRawKind() == R.getRawKind() && Data == R.Data;\n  }\n\n  bool operator!=(const SVal &R) const {\n    return !(*this == R);\n  }\n\n  bool isUnknown() const {\n    return getRawKind() == UnknownValKind;\n  }\n\n  bool isUndef() const {\n    return getRawKind() == UndefinedValKind;\n  }\n\n  bool isUnknownOrUndef() const {\n    return getRawKind() <= UnknownValKind;\n  }\n\n  bool isValid() const {\n    return getRawKind() > UnknownValKind;\n  }\n\n  bool isConstant() const;\n\n  bool isConstant(int I) const;\n\n  bool isZeroConstant() const;\n\n  /// hasConjuredSymbol - If this SVal wraps a conjured symbol, return true;\n  bool hasConjuredSymbol() const;\n\n  /// getAsFunctionDecl - If this SVal is a MemRegionVal and wraps a\n  /// CodeTextRegion wrapping a FunctionDecl, return that FunctionDecl.\n  /// Otherwise return 0.\n  const FunctionDecl *getAsFunctionDecl() const;\n\n  /// If this SVal is a location and wraps a symbol, return that\n  ///  SymbolRef. Otherwise return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsLocSymbol(bool IncludeBaseRegions = false) const;\n\n  /// Get the symbol in the SVal or its base region.\n  SymbolRef getLocSymbolInBase() const;\n\n  /// If this SVal wraps a symbol return that SymbolRef.\n  /// Otherwise, return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsSymbol(bool IncludeBaseRegions = false) const;\n\n  const MemRegion *getAsRegion() const;\n\n  /// printJson - Pretty-prints in JSON format.\n  void printJson(raw_ostream &Out, bool AddQuotes) const;\n\n  void dumpToStream(raw_ostream &OS) const;\n  void dump() const;\n\n  SymExpr::symbol_iterator symbol_begin() const {\n    const SymExpr *SE = getAsSymbol(/*IncludeBaseRegions=*/true);\n    if (SE)\n      return SE->symbol_begin();\n    else\n      return SymExpr::symbol_iterator();\n  }\n\n  SymExpr::symbol_iterator symbol_end() const {\n    return SymExpr::symbol_end();\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &os, clang::ento::SVal V) {\n  V.dumpToStream(os);\n  return os;\n}\n\nclass UndefinedVal : public SVal {\npublic:\n  UndefinedVal() : SVal(UndefinedValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == UndefinedValKind;\n  }\n};\n\nclass DefinedOrUnknownSVal : public SVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically false.\n  bool isUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedOrUnknownSVal() = default;\n  explicit DefinedOrUnknownSVal(const void *d, bool isLoc, unsigned ValKind)\n      : SVal(d, isLoc, ValKind) {}\n  explicit DefinedOrUnknownSVal(BaseKind k, void *D = nullptr) : SVal(k, D) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUndef();\n  }\n};\n\nclass UnknownVal : public DefinedOrUnknownSVal {\npublic:\n  explicit UnknownVal() : DefinedOrUnknownSVal(UnknownValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal &V) {\n    return V.getBaseKind() == UnknownValKind;\n  }\n};\n\nclass DefinedSVal : public DefinedOrUnknownSVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically true/false.\n  bool isUnknown() const = delete;\n  bool isUnknownOrUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedSVal() = default;\n  explicit DefinedSVal(const void *d, bool isLoc, unsigned ValKind)\n      : DefinedOrUnknownSVal(d, isLoc, ValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUnknownOrUndef();\n  }\n};\n\n/// Represents an SVal that is guaranteed to not be UnknownVal.\nclass KnownSVal : public SVal {\n  friend class SVal;\n\n  KnownSVal() = default;\n\n  static bool isKind(const SVal &V) {\n    return !V.isUnknown();\n  }\n\npublic:\n  KnownSVal(const DefinedSVal &V) : SVal(V) {}\n  KnownSVal(const UndefinedVal &V) : SVal(V) {}\n};\n\nclass NonLoc : public DefinedSVal {\nprotected:\n  NonLoc() = default;\n  explicit NonLoc(unsigned SubKind, const void *d)\n      : DefinedSVal(d, false, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isCompoundType(QualType T) {\n    return T->isArrayType() || T->isRecordType() ||\n           T->isAnyComplexType() || T->isVectorType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind;\n  }\n};\n\nclass Loc : public DefinedSVal {\nprotected:\n  Loc() = default;\n  explicit Loc(unsigned SubKind, const void *D)\n      : DefinedSVal(const_cast<void *>(D), true, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isLocType(QualType T) {\n    return T->isAnyPointerType() || T->isBlockPointerType() ||\n           T->isReferenceType() || T->isNullPtrType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind;\n  }\n};\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of NonLoc.\n//==------------------------------------------------------------------------==//\n\nnamespace nonloc {\n\n/// Represents symbolic expression that isn't a location.\nclass SymbolVal : public NonLoc {\npublic:\n  SymbolVal() = delete;\n  SymbolVal(SymbolRef sym) : NonLoc(SymbolValKind, sym) {\n    assert(sym);\n    assert(!Loc::isLocType(sym->getType()));\n  }\n\n  SymbolRef getSymbol() const {\n    return (const SymExpr *) Data;\n  }\n\n  bool isExpression() const {\n    return !isa<SymbolData>(getSymbol());\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == SymbolValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == SymbolValKind;\n  }\n};\n\n/// Value representing integer constant.\nclass ConcreteInt : public NonLoc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : NonLoc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt& getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(SValBuilder &svalBuilder, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\n  ConcreteInt evalComplement(SValBuilder &svalBuilder) const;\n\n  ConcreteInt evalMinus(SValBuilder &svalBuilder) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\nclass LocAsInteger : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LocAsInteger(const std::pair<SVal, uintptr_t> &data)\n      : NonLoc(LocAsIntegerKind, &data) {\n    // We do not need to represent loc::ConcreteInt as LocAsInteger,\n    // as it'd collapse into a nonloc::ConcreteInt instead.\n    assert(data.first.getBaseKind() == LocKind &&\n           (data.first.getSubKind() == loc::MemRegionValKind ||\n            data.first.getSubKind() == loc::GotoLabelKind));\n  }\n\npublic:\n  Loc getLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->first.castAs<Loc>();\n  }\n\n  Loc getPersistentLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    const SVal& V = D->first;\n    return V.castAs<Loc>();\n  }\n\n  unsigned getNumBits() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->second;\n  }\n\nprivate:\n  friend class SVal;\n\n  LocAsInteger() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LocAsIntegerKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LocAsIntegerKind;\n  }\n};\n\nclass CompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit CompoundVal(const CompoundValData* D) : NonLoc(CompoundValKind, D) {}\n\npublic:\n  const CompoundValData* getValue() const {\n    return static_cast<const CompoundValData *>(Data);\n  }\n\n  using iterator = llvm::ImmutableList<SVal>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  CompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind && V.getSubKind() == CompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == CompoundValKind;\n  }\n};\n\nclass LazyCompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LazyCompoundVal(const LazyCompoundValData *D)\n      : NonLoc(LazyCompoundValKind, D) {}\n\npublic:\n  const LazyCompoundValData *getCVData() const {\n    return static_cast<const LazyCompoundValData *>(Data);\n  }\n\n  const void *getStore() const;\n  const TypedValueRegion *getRegion() const;\n\nprivate:\n  friend class SVal;\n\n  LazyCompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LazyCompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LazyCompoundValKind;\n  }\n};\n\n/// Value representing pointer-to-member.\n///\n/// This value is qualified as NonLoc because neither loading nor storing\n/// operations are applied to it. Instead, the analyzer uses the L-value coming\n/// from pointer-to-member applied to an object.\n/// This SVal is represented by a NamedDecl which can be a member function\n/// pointer or a member data pointer and an optional list of CXXBaseSpecifiers.\n/// This list is required to accumulate the pointer-to-member cast history to\n/// figure out the correct subobject field. In particular, implicit casts grow\n/// this list and explicit casts like static_cast shrink this list.\nclass PointerToMember : public NonLoc {\n  friend class ento::SValBuilder;\n\npublic:\n  using PTMDataType =\n      llvm::PointerUnion<const NamedDecl *, const PointerToMemberData *>;\n\n  const PTMDataType getPTMData() const {\n    return PTMDataType::getFromOpaqueValue(const_cast<void *>(Data));\n  }\n\n  bool isNullMemberPointer() const;\n\n  const NamedDecl *getDecl() const;\n\n  template<typename AdjustedDecl>\n  const AdjustedDecl *getDeclAs() const {\n    return dyn_cast_or_null<AdjustedDecl>(getDecl());\n  }\n\n  using iterator = llvm::ImmutableList<const CXXBaseSpecifier *>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  PointerToMember() = default;\n  explicit PointerToMember(const PTMDataType D)\n      : NonLoc(PointerToMemberKind, D.getOpaqueValue()) {}\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == PointerToMemberKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == PointerToMemberKind;\n  }\n};\n\n} // namespace nonloc\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of Loc.\n//==------------------------------------------------------------------------==//\n\nnamespace loc {\n\nclass GotoLabel : public Loc {\npublic:\n  explicit GotoLabel(const LabelDecl *Label) : Loc(GotoLabelKind, Label) {\n    assert(Label);\n  }\n\n  const LabelDecl *getLabel() const {\n    return static_cast<const LabelDecl *>(Data);\n  }\n\nprivate:\n  friend class SVal;\n\n  GotoLabel() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind && V.getSubKind() == GotoLabelKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == GotoLabelKind;\n  }\n};\n\nclass MemRegionVal : public Loc {\npublic:\n  explicit MemRegionVal(const MemRegion* r) : Loc(MemRegionValKind, r) {\n    assert(r);\n  }\n\n  /// Get the underlining region.\n  const MemRegion *getRegion() const {\n    return static_cast<const MemRegion *>(Data);\n  }\n\n  /// Get the underlining region and strip casts.\n  const MemRegion* stripCasts(bool StripBaseCasts = true) const;\n\n  template <typename REGION>\n  const REGION* getRegionAs() const {\n    return dyn_cast<REGION>(getRegion());\n  }\n\n  bool operator==(const MemRegionVal &R) const {\n    return getRegion() == R.getRegion();\n  }\n\n  bool operator!=(const MemRegionVal &R) const {\n    return getRegion() != R.getRegion();\n  }\n\nprivate:\n  friend class SVal;\n\n  MemRegionVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == MemRegionValKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == MemRegionValKind;\n  }\n};\n\nclass ConcreteInt : public Loc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : Loc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt &getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(BasicValueFactory& BasicVals, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\n} // namespace loc\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "content": "//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the fixed point number interface.\n/// This is a class for abstracting various operations performed on fixed point\n/// types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFIXEDPOINT_H\n#define LLVM_ADT_APFIXEDPOINT_H\n\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nclass APFloat;\nstruct fltSemantics;\n\n/// The fixed point semantics work similarly to fltSemantics. The width\n/// specifies the whole bit width of the underlying scaled integer (with padding\n/// if any). The scale represents the number of fractional bits in this type.\n/// When HasUnsignedPadding is true and this type is unsigned, the first bit\n/// in the value this represents is treated as padding.\nclass FixedPointSemantics {\npublic:\n  FixedPointSemantics(unsigned Width, unsigned Scale, bool IsSigned,\n                      bool IsSaturated, bool HasUnsignedPadding)\n      : Width(Width), Scale(Scale), IsSigned(IsSigned),\n        IsSaturated(IsSaturated), HasUnsignedPadding(HasUnsignedPadding) {\n    assert(Width >= Scale && \"Not enough room for the scale\");\n    assert(!(IsSigned && HasUnsignedPadding) &&\n           \"Cannot have unsigned padding on a signed type.\");\n  }\n\n  unsigned getWidth() const { return Width; }\n  unsigned getScale() const { return Scale; }\n  bool isSigned() const { return IsSigned; }\n  bool isSaturated() const { return IsSaturated; }\n  bool hasUnsignedPadding() const { return HasUnsignedPadding; }\n\n  void setSaturated(bool Saturated) { IsSaturated = Saturated; }\n\n  /// Return the number of integral bits represented by these semantics. These\n  /// are separate from the fractional bits and do not include the sign or\n  /// padding bit.\n  unsigned getIntegralBits() const {\n    if (IsSigned || (!IsSigned && HasUnsignedPadding))\n      return Width - Scale - 1;\n    else\n      return Width - Scale;\n  }\n\n  /// Return the FixedPointSemantics that allows for calculating the full\n  /// precision semantic that can precisely represent the precision and ranges\n  /// of both input values. This does not compute the resulting semantics for a\n  /// given binary operation.\n  FixedPointSemantics\n  getCommonSemantics(const FixedPointSemantics &Other) const;\n\n  /// Returns true if this fixed-point semantic with its value bits interpreted\n  /// as an integer can fit in the given floating point semantic without\n  /// overflowing to infinity.\n  /// For example, a signed 8-bit fixed-point semantic has a maximum and\n  /// minimum integer representation of 127 and -128, respectively. If both of\n  /// these values can be represented (possibly inexactly) in the floating\n  /// point semantic without overflowing, this returns true.\n  bool fitsInFloatSemantics(const fltSemantics &FloatSema) const;\n\n  /// Return the FixedPointSemantics for an integer type.\n  static FixedPointSemantics GetIntegerSemantics(unsigned Width,\n                                                 bool IsSigned) {\n    return FixedPointSemantics(Width, /*Scale=*/0, IsSigned,\n                               /*IsSaturated=*/false,\n                               /*HasUnsignedPadding=*/false);\n  }\n\nprivate:\n  unsigned Width          : 16;\n  unsigned Scale          : 13;\n  unsigned IsSigned       : 1;\n  unsigned IsSaturated    : 1;\n  unsigned HasUnsignedPadding : 1;\n};\n\n/// The APFixedPoint class works similarly to APInt/APSInt in that it is a\n/// functional replacement for a scaled integer. It is meant to replicate the\n/// fixed point types proposed in ISO/IEC JTC1 SC22 WG14 N1169. The class carries\n/// info about the fixed point type's width, sign, scale, and saturation, and\n/// provides different operations that would normally be performed on fixed point\n/// types.\nclass APFixedPoint {\npublic:\n  APFixedPoint(const APInt &Val, const FixedPointSemantics &Sema)\n      : Val(Val, !Sema.isSigned()), Sema(Sema) {\n    assert(Val.getBitWidth() == Sema.getWidth() &&\n           \"The value should have a bit width that matches the Sema width\");\n  }\n\n  APFixedPoint(uint64_t Val, const FixedPointSemantics &Sema)\n      : APFixedPoint(APInt(Sema.getWidth(), Val, Sema.isSigned()), Sema) {}\n\n  // Zero initialization.\n  APFixedPoint(const FixedPointSemantics &Sema) : APFixedPoint(0, Sema) {}\n\n  APSInt getValue() const { return APSInt(Val, !Sema.isSigned()); }\n  inline unsigned getWidth() const { return Sema.getWidth(); }\n  inline unsigned getScale() const { return Sema.getScale(); }\n  inline bool isSaturated() const { return Sema.isSaturated(); }\n  inline bool isSigned() const { return Sema.isSigned(); }\n  inline bool hasPadding() const { return Sema.hasUnsignedPadding(); }\n  FixedPointSemantics getSemantics() const { return Sema; }\n\n  bool getBoolValue() const { return Val.getBoolValue(); }\n\n  // Convert this number to match the semantics provided. If the overflow\n  // parameter is provided, set this value to true or false to indicate if this\n  // operation results in an overflow.\n  APFixedPoint convert(const FixedPointSemantics &DstSema,\n                       bool *Overflow = nullptr) const;\n\n  // Perform binary operations on a fixed point type. The resulting fixed point\n  // value will be in the common, full precision semantics that can represent\n  // the precision and ranges of both input values. See convert() for an\n  // explanation of the Overflow parameter.\n  APFixedPoint add(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint sub(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint mul(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint div(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n\n  // Perform shift operations on a fixed point type. Unlike the other binary\n  // operations, the resulting fixed point value will be in the original\n  // semantic.\n  APFixedPoint shl(unsigned Amt, bool *Overflow = nullptr) const;\n  APFixedPoint shr(unsigned Amt, bool *Overflow = nullptr) const {\n    // Right shift cannot overflow.\n    if (Overflow)\n      *Overflow = false;\n    return APFixedPoint(Val >> Amt, Sema);\n  }\n\n  /// Perform a unary negation (-X) on this fixed point type, taking into\n  /// account saturation if applicable.\n  APFixedPoint negate(bool *Overflow = nullptr) const;\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. (-2.5k -> -2)\n  APSInt getIntPart() const {\n    if (Val < 0 && Val != -Val) // Cover the case when we have the min val\n      return -(-Val >> getScale());\n    else\n      return Val >> getScale();\n  }\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. The value is stored into an APSInt with the provided width and sign.\n  /// If the overflow parameter is provided, and the integral value is not able\n  /// to be fully stored in the provided width and sign, the overflow parameter\n  /// is set to true.\n  APSInt convertToInt(unsigned DstWidth, bool DstSign,\n                      bool *Overflow = nullptr) const;\n\n  /// Convert this fixed point number to a floating point value with the\n  /// provided semantics.\n  APFloat convertToFloat(const fltSemantics &FloatSema) const;\n\n  void toString(SmallVectorImpl<char> &Str) const;\n  std::string toString() const {\n    SmallString<40> S;\n    toString(S);\n    return std::string(S.str());\n  }\n\n  // If LHS > RHS, return 1. If LHS == RHS, return 0. If LHS < RHS, return -1.\n  int compare(const APFixedPoint &Other) const;\n  bool operator==(const APFixedPoint &Other) const {\n    return compare(Other) == 0;\n  }\n  bool operator!=(const APFixedPoint &Other) const {\n    return compare(Other) != 0;\n  }\n  bool operator>(const APFixedPoint &Other) const { return compare(Other) > 0; }\n  bool operator<(const APFixedPoint &Other) const { return compare(Other) < 0; }\n  bool operator>=(const APFixedPoint &Other) const {\n    return compare(Other) >= 0;\n  }\n  bool operator<=(const APFixedPoint &Other) const {\n    return compare(Other) <= 0;\n  }\n\n  static APFixedPoint getMax(const FixedPointSemantics &Sema);\n  static APFixedPoint getMin(const FixedPointSemantics &Sema);\n\n  /// Given a floating point semantic, return the next floating point semantic\n  /// with a larger exponent and larger or equal mantissa.\n  static const fltSemantics *promoteFloatSemantics(const fltSemantics *S);\n\n  /// Create an APFixedPoint with a value equal to that of the provided integer,\n  /// and in the same semantics as the provided target semantics. If the value\n  /// is not able to fit in the specified fixed point semantics, and the\n  /// overflow parameter is provided, it is set to true.\n  static APFixedPoint getFromIntValue(const APSInt &Value,\n                                      const FixedPointSemantics &DstFXSema,\n                                      bool *Overflow = nullptr);\n\n  /// Create an APFixedPoint with a value equal to that of the provided\n  /// floating point value, in the provided target semantics. If the value is\n  /// not able to fit in the specified fixed point semantics and the overflow\n  /// parameter is specified, it is set to true.\n  /// For NaN, the Overflow flag is always set. For +inf and -inf, if the\n  /// semantic is saturating, the value saturates. Otherwise, the Overflow flag\n  /// is set.\n  static APFixedPoint getFromFloatValue(const APFloat &Value,\n                                        const FixedPointSemantics &DstFXSema,\n                                        bool *Overflow = nullptr);\n\nprivate:\n  APSInt Val;\n  FixedPointSemantics Sema;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APFixedPoint &FX) {\n  OS << FX.toString();\n  return OS;\n}\n\n} // namespace llvm\n\n#endif\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "content": "//===- llvm/ADT/APFloat.h - Arbitrary Precision Floating Point ---*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief\n/// This file declares a class to represent arbitrary precision floating point\n/// values and provide a variety of arithmetic operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFLOAT_H\n#define LLVM_ADT_APFLOAT_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <memory>\n\n#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \\\n  do {                                                                         \\\n    if (usesLayout<IEEEFloat>(getSemantics()))                                 \\\n      return U.IEEE.METHOD_CALL;                                               \\\n    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \\\n      return U.Double.METHOD_CALL;                                             \\\n    llvm_unreachable(\"Unexpected semantics\");                                  \\\n  } while (false)\n\nnamespace llvm {\n\nstruct fltSemantics;\nclass APSInt;\nclass StringRef;\nclass APFloat;\nclass raw_ostream;\n\ntemplate <typename T> class Expected;\ntemplate <typename T> class SmallVectorImpl;\n\n/// Enum that represents what fraction of the LSB truncated bits of an fp number\n/// represent.\n///\n/// This essentially combines the roles of guard and sticky bits.\nenum lostFraction { // Example of truncated bits:\n  lfExactlyZero,    // 000000\n  lfLessThanHalf,   // 0xxxxx  x's not all zero\n  lfExactlyHalf,    // 100000\n  lfMoreThanHalf    // 1xxxxx  x's not all zero\n};\n\n/// A self-contained host- and target-independent arbitrary-precision\n/// floating-point software implementation.\n///\n/// APFloat uses bignum integer arithmetic as provided by static functions in\n/// the APInt class.  The library will work with bignum integers whose parts are\n/// any unsigned type at least 16 bits wide, but 64 bits is recommended.\n///\n/// Written for clarity rather than speed, in particular with a view to use in\n/// the front-end of a cross compiler so that target arithmetic can be correctly\n/// performed on the host.  Performance should nonetheless be reasonable,\n/// particularly for its intended use.  It may be useful as a base\n/// implementation for a run-time library during development of a faster\n/// target-specific one.\n///\n/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n/// implemented operations.  Currently implemented operations are add, subtract,\n/// multiply, divide, fused-multiply-add, conversion-to-float,\n/// conversion-to-integer and conversion-from-integer.  New rounding modes\n/// (e.g. away from zero) can be added with three or four lines of code.\n///\n/// Four formats are built-in: IEEE single precision, double precision,\n/// quadruple precision, and x87 80-bit extended double (when operating with\n/// full extended precision).  Adding a new format that obeys IEEE semantics\n/// only requires adding two lines of code: a declaration and definition of the\n/// format.\n///\n/// All operations return the status of that operation as an exception bit-mask,\n/// so multiple operations can be done consecutively with their results or-ed\n/// together.  The returned status can be useful for compiler diagnostics; e.g.,\n/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n/// and compiler optimizers can determine what exceptions would be raised by\n/// folding operations and optimize, or perhaps not optimize, accordingly.\n///\n/// At present, underflow tininess is detected after rounding; it should be\n/// straight forward to add support for the before-rounding case too.\n///\n/// The library reads hexadecimal floating point numbers as per C99, and\n/// correctly rounds if necessary according to the specified rounding mode.\n/// Syntax is required to have been validated by the caller.  It also converts\n/// floating point numbers to hexadecimal text as per the C99 %a and %A\n/// conversions.  The output precision (or alternatively the natural minimal\n/// precision) can be specified; if the requested precision is less than the\n/// natural precision the output is correctly rounded for the specified rounding\n/// mode.\n///\n/// It also reads decimal floating point numbers and correctly rounds according\n/// to the specified rounding mode.\n///\n/// Conversion to decimal text is not currently implemented.\n///\n/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n/// signed exponent, and the significand as an array of integer parts.  After\n/// normalization of a number of precision P the exponent is within the range of\n/// the format, and if the number is not denormal the P-th bit of the\n/// significand is set as an explicit integer bit.  For denormals the most\n/// significant bit is shifted right so that the exponent is maintained at the\n/// format's minimum, so that the smallest denormal has just the least\n/// significant bit of the significand set.  The sign of zeroes and infinities\n/// is significant; the exponent and significand of such numbers is not stored,\n/// but has a known implicit (deterministic) value: 0 for the significands, 0\n/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and\n/// significand are deterministic, although not really meaningful, and preserved\n/// in non-conversion operations.  The exponent is implicitly all 1 bits.\n///\n/// APFloat does not provide any exception handling beyond default exception\n/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n/// by encoding Signaling NaNs with the first bit of its trailing significand as\n/// 0.\n///\n/// TODO\n/// ====\n///\n/// Some features that may or may not be worth adding:\n///\n/// Binary to decimal conversion (hard).\n///\n/// Optional ability to detect underflow tininess before rounding.\n///\n/// New formats: x87 in single and double precision mode (IEEE apart from\n/// extended exponent range) (hard).\n///\n/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.\n///\n\n// This is the common type definitions shared by APFloat and its internal\n// implementation classes. This struct should not define any non-static data\n// members.\nstruct APFloatBase {\n  typedef APInt::WordType integerPart;\n  static constexpr unsigned integerPartWidth = APInt::APINT_BITS_PER_WORD;\n\n  /// A signed type to represent a floating point numbers unbiased exponent.\n  typedef int32_t ExponentType;\n\n  /// \\name Floating Point Semantics.\n  /// @{\n  enum Semantics {\n    S_IEEEhalf,\n    S_BFloat,\n    S_IEEEsingle,\n    S_IEEEdouble,\n    S_x87DoubleExtended,\n    S_IEEEquad,\n    S_PPCDoubleDouble\n  };\n\n  static const llvm::fltSemantics &EnumToSemantics(Semantics S);\n  static Semantics SemanticsToEnum(const llvm::fltSemantics &Sem);\n\n  static const fltSemantics &IEEEhalf() LLVM_READNONE;\n  static const fltSemantics &BFloat() LLVM_READNONE;\n  static const fltSemantics &IEEEsingle() LLVM_READNONE;\n  static const fltSemantics &IEEEdouble() LLVM_READNONE;\n  static const fltSemantics &IEEEquad() LLVM_READNONE;\n  static const fltSemantics &PPCDoubleDouble() LLVM_READNONE;\n  static const fltSemantics &x87DoubleExtended() LLVM_READNONE;\n\n  /// A Pseudo fltsemantic used to construct APFloats that cannot conflict with\n  /// anything real.\n  static const fltSemantics &Bogus() LLVM_READNONE;\n\n  /// @}\n\n  /// IEEE-754R 5.11: Floating Point Comparison Relations.\n  enum cmpResult {\n    cmpLessThan,\n    cmpEqual,\n    cmpGreaterThan,\n    cmpUnordered\n  };\n\n  /// IEEE-754R 4.3: Rounding-direction attributes.\n  using roundingMode = llvm::RoundingMode;\n\n  static constexpr roundingMode rmNearestTiesToEven =\n                                                RoundingMode::NearestTiesToEven;\n  static constexpr roundingMode rmTowardPositive = RoundingMode::TowardPositive;\n  static constexpr roundingMode rmTowardNegative = RoundingMode::TowardNegative;\n  static constexpr roundingMode rmTowardZero     = RoundingMode::TowardZero;\n  static constexpr roundingMode rmNearestTiesToAway =\n                                                RoundingMode::NearestTiesToAway;\n\n  /// IEEE-754R 7: Default exception handling.\n  ///\n  /// opUnderflow or opOverflow are always returned or-ed with opInexact.\n  ///\n  /// APFloat models this behavior specified by IEEE-754:\n  ///   \"For operations producing results in floating-point format, the default\n  ///    result of an operation that signals the invalid operation exception\n  ///    shall be a quiet NaN.\"\n  enum opStatus {\n    opOK = 0x00,\n    opInvalidOp = 0x01,\n    opDivByZero = 0x02,\n    opOverflow = 0x04,\n    opUnderflow = 0x08,\n    opInexact = 0x10\n  };\n\n  /// Category of internally-represented number.\n  enum fltCategory {\n    fcInfinity,\n    fcNaN,\n    fcNormal,\n    fcZero\n  };\n\n  /// Convenience enum used to construct an uninitialized APFloat.\n  enum uninitializedTag {\n    uninitialized\n  };\n\n  /// Enumeration of \\c ilogb error results.\n  enum IlogbErrorKinds {\n    IEK_Zero = INT_MIN + 1,\n    IEK_NaN = INT_MIN,\n    IEK_Inf = INT_MAX\n  };\n\n  static unsigned int semanticsPrecision(const fltSemantics &);\n  static ExponentType semanticsMinExponent(const fltSemantics &);\n  static ExponentType semanticsMaxExponent(const fltSemantics &);\n  static unsigned int semanticsSizeInBits(const fltSemantics &);\n\n  /// Returns the size of the floating point number (in bits) in the given\n  /// semantics.\n  static unsigned getSizeInBits(const fltSemantics &Sem);\n};\n\nnamespace detail {\n\nclass IEEEFloat final : public APFloatBase {\npublic:\n  /// \\name Constructors\n  /// @{\n\n  IEEEFloat(const fltSemantics &); // Default construct to +0.0\n  IEEEFloat(const fltSemantics &, integerPart);\n  IEEEFloat(const fltSemantics &, uninitializedTag);\n  IEEEFloat(const fltSemantics &, const APInt &);\n  explicit IEEEFloat(double d);\n  explicit IEEEFloat(float f);\n  IEEEFloat(const IEEEFloat &);\n  IEEEFloat(IEEEFloat &&);\n  ~IEEEFloat();\n\n  /// @}\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return partCount() > 1; }\n\n  /// \\name Convenience \"constructors\"\n  /// @{\n\n  /// @}\n\n  /// \\name Arithmetic\n  /// @{\n\n  opStatus add(const IEEEFloat &, roundingMode);\n  opStatus subtract(const IEEEFloat &, roundingMode);\n  opStatus multiply(const IEEEFloat &, roundingMode);\n  opStatus divide(const IEEEFloat &, roundingMode);\n  /// IEEE remainder.\n  opStatus remainder(const IEEEFloat &);\n  /// C fmod, or llvm frem.\n  opStatus mod(const IEEEFloat &);\n  opStatus fusedMultiplyAdd(const IEEEFloat &, const IEEEFloat &, roundingMode);\n  opStatus roundToIntegral(roundingMode);\n  /// IEEE-754R 5.3.1: nextUp/nextDown.\n  opStatus next(bool nextDown);\n\n  /// @}\n\n  /// \\name Sign operations.\n  /// @{\n\n  void changeSign();\n\n  /// @}\n\n  /// \\name Conversions\n  /// @{\n\n  opStatus convert(const fltSemantics &, roundingMode, bool *);\n  opStatus convertToInteger(MutableArrayRef<integerPart>, unsigned int, bool,\n                            roundingMode, bool *) const;\n  opStatus convertFromAPInt(const APInt &, bool, roundingMode);\n  opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const;\n  double convertToDouble() const;\n  float convertToFloat() const;\n\n  /// @}\n\n  /// The definition of equality is not straightforward for floating point, so\n  /// we won't use operator==.  Use one of the following, or write whatever it\n  /// is you really mean.\n  bool operator==(const IEEEFloat &) const = delete;\n\n  /// IEEE comparison with another floating point number (NaNs compare\n  /// unordered, 0==-0).\n  cmpResult compare(const IEEEFloat &) const;\n\n  /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n  bool bitwiseIsEqual(const IEEEFloat &) const;\n\n  /// Write out a hexadecimal representation of the floating point value to DST,\n  /// which must be of sufficient size, in the C99 form [-]0xh.hhhhp[+-]d.\n  /// Return the number of characters written, excluding the terminating NUL.\n  unsigned int convertToHexString(char *dst, unsigned int hexDigits,\n                                  bool upperCase, roundingMode) const;\n\n  /// \\name IEEE-754R 5.7.2 General operations.\n  /// @{\n\n  /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n  /// negative.\n  ///\n  /// This applies to zeros and NaNs as well.\n  bool isNegative() const { return sign; }\n\n  /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n  ///\n  /// This implies that the current value of the float is not zero, subnormal,\n  /// infinite, or NaN following the definition of normality from IEEE-754R.\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n\n  /// Returns true if and only if the current value is zero, subnormal, or\n  /// normal.\n  ///\n  /// This means that the value is not infinite or NaN.\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  /// Returns true if and only if the float is plus or minus zero.\n  bool isZero() const { return category == fcZero; }\n\n  /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n  /// denormal.\n  bool isDenormal() const;\n\n  /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n  bool isInfinity() const { return category == fcInfinity; }\n\n  /// Returns true if and only if the float is a quiet or signaling NaN.\n  bool isNaN() const { return category == fcNaN; }\n\n  /// Returns true if and only if the float is a signaling NaN.\n  bool isSignaling() const;\n\n  /// @}\n\n  /// \\name Simple Queries\n  /// @{\n\n  fltCategory getCategory() const { return category; }\n  const fltSemantics &getSemantics() const { return *semantics; }\n  bool isNonZero() const { return category != fcZero; }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n\n  /// Returns true if and only if the number has the smallest possible non-zero\n  /// magnitude in the current semantics.\n  bool isSmallest() const;\n\n  /// Returns true if and only if the number has the largest possible finite\n  /// magnitude in the current semantics.\n  bool isLargest() const;\n\n  /// Returns true if and only if the number is an exact integer.\n  bool isInteger() const;\n\n  /// @}\n\n  IEEEFloat &operator=(const IEEEFloat &);\n  IEEEFloat &operator=(IEEEFloat &&);\n\n  /// Overload to compute a hash code for an APFloat value.\n  ///\n  /// Note that the use of hash codes for floating point values is in general\n  /// frought with peril. Equality is hard to define for these values. For\n  /// example, should negative and positive zero hash to different codes? Are\n  /// they equal or not? This hash value implementation specifically\n  /// emphasizes producing different codes for different inputs in order to\n  /// be used in canonicalization and memoization. As such, equality is\n  /// bitwiseIsEqual, and 0 != -0.\n  friend hash_code hash_value(const IEEEFloat &Arg);\n\n  /// Converts this value into a decimal string.\n  ///\n  /// \\param FormatPrecision The maximum number of digits of\n  ///   precision to output.  If there are fewer digits available,\n  ///   zero padding will not be used unless the value is\n  ///   integral and small enough to be expressed in\n  ///   FormatPrecision digits.  0 means to use the natural\n  ///   precision of the number.\n  /// \\param FormatMaxPadding The maximum number of zeros to\n  ///   consider inserting before falling back to scientific\n  ///   notation.  0 means to always use scientific notation.\n  ///\n  /// \\param TruncateZero Indicate whether to remove the trailing zero in\n  ///   fraction part or not. Also setting this parameter to false forcing\n  ///   producing of output more similar to default printf behavior.\n  ///   Specifically the lower e is used as exponent delimiter and exponent\n  ///   always contains no less than two digits.\n  ///\n  /// Number       Precision    MaxPadding      Result\n  /// ------       ---------    ----------      ------\n  /// 1.01E+4              5             2       10100\n  /// 1.01E+4              4             2       1.01E+4\n  /// 1.01E+4              5             1       1.01E+4\n  /// 1.01E-2              5             2       0.0101\n  /// 1.01E-2              4             2       0.0101\n  /// 1.01E-2              4             1       1.01E-2\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const;\n\n  /// If this value has an exact multiplicative inverse, store it in inv and\n  /// return true.\n  bool getExactInverse(APFloat *inv) const;\n\n  /// Returns the exponent of the internal representation of the APFloat.\n  ///\n  /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).\n  /// For special APFloat values, this returns special error codes:\n  ///\n  ///   NaN -> \\c IEK_NaN\n  ///   0   -> \\c IEK_Zero\n  ///   Inf -> \\c IEK_Inf\n  ///\n  friend int ilogb(const IEEEFloat &Arg);\n\n  /// Returns: X * 2^Exp for integral exponents.\n  friend IEEEFloat scalbn(IEEEFloat X, int Exp, roundingMode);\n\n  friend IEEEFloat frexp(const IEEEFloat &X, int &Exp, roundingMode);\n\n  /// \\name Special value setters.\n  /// @{\n\n  void makeLargest(bool Neg = false);\n  void makeSmallest(bool Neg = false);\n  void makeNaN(bool SNaN = false, bool Neg = false,\n               const APInt *fill = nullptr);\n  void makeInf(bool Neg = false);\n  void makeZero(bool Neg = false);\n  void makeQuiet();\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  void makeSmallestNormalized(bool Negative = false);\n\n  /// @}\n\n  cmpResult compareAbsoluteValue(const IEEEFloat &) const;\n\nprivate:\n  /// \\name Simple Queries\n  /// @{\n\n  integerPart *significandParts();\n  const integerPart *significandParts() const;\n  unsigned int partCount() const;\n\n  /// @}\n\n  /// \\name Significand operations.\n  /// @{\n\n  integerPart addSignificand(const IEEEFloat &);\n  integerPart subtractSignificand(const IEEEFloat &, integerPart);\n  lostFraction addOrSubtractSignificand(const IEEEFloat &, bool subtract);\n  lostFraction multiplySignificand(const IEEEFloat &, IEEEFloat);\n  lostFraction multiplySignificand(const IEEEFloat&);\n  lostFraction divideSignificand(const IEEEFloat &);\n  void incrementSignificand();\n  void initialize(const fltSemantics *);\n  void shiftSignificandLeft(unsigned int);\n  lostFraction shiftSignificandRight(unsigned int);\n  unsigned int significandLSB() const;\n  unsigned int significandMSB() const;\n  void zeroSignificand();\n  /// Return true if the significand excluding the integral bit is all ones.\n  bool isSignificandAllOnes() const;\n  /// Return true if the significand excluding the integral bit is all zeros.\n  bool isSignificandAllZeros() const;\n\n  /// @}\n\n  /// \\name Arithmetic on special values.\n  /// @{\n\n  opStatus addOrSubtractSpecials(const IEEEFloat &, bool subtract);\n  opStatus divideSpecials(const IEEEFloat &);\n  opStatus multiplySpecials(const IEEEFloat &);\n  opStatus modSpecials(const IEEEFloat &);\n  opStatus remainderSpecials(const IEEEFloat&);\n\n  /// @}\n\n  /// \\name Miscellany\n  /// @{\n\n  bool convertFromStringSpecials(StringRef str);\n  opStatus normalize(roundingMode, lostFraction);\n  opStatus addOrSubtract(const IEEEFloat &, roundingMode, bool subtract);\n  opStatus handleOverflow(roundingMode);\n  bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;\n  opStatus convertToSignExtendedInteger(MutableArrayRef<integerPart>,\n                                        unsigned int, bool, roundingMode,\n                                        bool *) const;\n  opStatus convertFromUnsignedParts(const integerPart *, unsigned int,\n                                    roundingMode);\n  Expected<opStatus> convertFromHexadecimalString(StringRef, roundingMode);\n  Expected<opStatus> convertFromDecimalString(StringRef, roundingMode);\n  char *convertNormalToHexString(char *, unsigned int, bool,\n                                 roundingMode) const;\n  opStatus roundSignificandWithExponent(const integerPart *, unsigned int, int,\n                                        roundingMode);\n  ExponentType exponentNaN() const;\n  ExponentType exponentInf() const;\n  ExponentType exponentZero() const;\n\n  /// @}\n\n  APInt convertHalfAPFloatToAPInt() const;\n  APInt convertBFloatAPFloatToAPInt() const;\n  APInt convertFloatAPFloatToAPInt() const;\n  APInt convertDoubleAPFloatToAPInt() const;\n  APInt convertQuadrupleAPFloatToAPInt() const;\n  APInt convertF80LongDoubleAPFloatToAPInt() const;\n  APInt convertPPCDoubleDoubleAPFloatToAPInt() const;\n  void initFromAPInt(const fltSemantics *Sem, const APInt &api);\n  void initFromHalfAPInt(const APInt &api);\n  void initFromBFloatAPInt(const APInt &api);\n  void initFromFloatAPInt(const APInt &api);\n  void initFromDoubleAPInt(const APInt &api);\n  void initFromQuadrupleAPInt(const APInt &api);\n  void initFromF80LongDoubleAPInt(const APInt &api);\n  void initFromPPCDoubleDoubleAPInt(const APInt &api);\n\n  void assign(const IEEEFloat &);\n  void copySignificand(const IEEEFloat &);\n  void freeSignificand();\n\n  /// Note: this must be the first data member.\n  /// The semantics that this value obeys.\n  const fltSemantics *semantics;\n\n  /// A binary fraction with an explicit integer bit.\n  ///\n  /// The significand must be at least one bit wider than the target precision.\n  union Significand {\n    integerPart part;\n    integerPart *parts;\n  } significand;\n\n  /// The signed unbiased exponent of the value.\n  ExponentType exponent;\n\n  /// What kind of floating point number this is.\n  ///\n  /// Only 2 bits are required, but VisualStudio incorrectly sign extends it.\n  /// Using the extra bit keeps it from failing under VisualStudio.\n  fltCategory category : 3;\n\n  /// Sign bit of the number.\n  unsigned int sign : 1;\n};\n\nhash_code hash_value(const IEEEFloat &Arg);\nint ilogb(const IEEEFloat &Arg);\nIEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode);\nIEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM);\n\n// This mode implements more precise float in terms of two APFloats.\n// The interface and layout is designed for arbitrary underlying semantics,\n// though currently only PPCDoubleDouble semantics are supported, whose\n// corresponding underlying semantics are IEEEdouble.\nclass DoubleAPFloat final : public APFloatBase {\n  // Note: this must be the first data member.\n  const fltSemantics *Semantics;\n  std::unique_ptr<APFloat[]> Floats;\n\n  opStatus addImpl(const APFloat &a, const APFloat &aa, const APFloat &c,\n                   const APFloat &cc, roundingMode RM);\n\n  opStatus addWithSpecial(const DoubleAPFloat &LHS, const DoubleAPFloat &RHS,\n                          DoubleAPFloat &Out, roundingMode RM);\n\npublic:\n  DoubleAPFloat(const fltSemantics &S);\n  DoubleAPFloat(const fltSemantics &S, uninitializedTag);\n  DoubleAPFloat(const fltSemantics &S, integerPart);\n  DoubleAPFloat(const fltSemantics &S, const APInt &I);\n  DoubleAPFloat(const fltSemantics &S, APFloat &&First, APFloat &&Second);\n  DoubleAPFloat(const DoubleAPFloat &RHS);\n  DoubleAPFloat(DoubleAPFloat &&RHS);\n\n  DoubleAPFloat &operator=(const DoubleAPFloat &RHS);\n\n  DoubleAPFloat &operator=(DoubleAPFloat &&RHS) {\n    if (this != &RHS) {\n      this->~DoubleAPFloat();\n      new (this) DoubleAPFloat(std::move(RHS));\n    }\n    return *this;\n  }\n\n  bool needsCleanup() const { return Floats != nullptr; }\n\n  APFloat &getFirst() { return Floats[0]; }\n  const APFloat &getFirst() const { return Floats[0]; }\n  APFloat &getSecond() { return Floats[1]; }\n  const APFloat &getSecond() const { return Floats[1]; }\n\n  opStatus add(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus subtract(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus multiply(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus divide(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus remainder(const DoubleAPFloat &RHS);\n  opStatus mod(const DoubleAPFloat &RHS);\n  opStatus fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,\n                            const DoubleAPFloat &Addend, roundingMode RM);\n  opStatus roundToIntegral(roundingMode RM);\n  void changeSign();\n  cmpResult compareAbsoluteValue(const DoubleAPFloat &RHS) const;\n\n  fltCategory getCategory() const;\n  bool isNegative() const;\n\n  void makeInf(bool Neg);\n  void makeZero(bool Neg);\n  void makeLargest(bool Neg);\n  void makeSmallest(bool Neg);\n  void makeSmallestNormalized(bool Neg);\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill);\n\n  cmpResult compare(const DoubleAPFloat &RHS) const;\n  bool bitwiseIsEqual(const DoubleAPFloat &RHS) const;\n  APInt bitcastToAPInt() const;\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  opStatus next(bool nextDown);\n\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned, roundingMode RM);\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const;\n\n  bool isDenormal() const;\n  bool isSmallest() const;\n  bool isLargest() const;\n  bool isInteger() const;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,\n                unsigned FormatMaxPadding, bool TruncateZero = true) const;\n\n  bool getExactInverse(APFloat *inv) const;\n\n  friend DoubleAPFloat scalbn(const DoubleAPFloat &X, int Exp, roundingMode);\n  friend DoubleAPFloat frexp(const DoubleAPFloat &X, int &Exp, roundingMode);\n  friend hash_code hash_value(const DoubleAPFloat &Arg);\n};\n\nhash_code hash_value(const DoubleAPFloat &Arg);\n\n} // End detail namespace\n\n// This is a interface class that is currently forwarding functionalities from\n// detail::IEEEFloat.\nclass APFloat : public APFloatBase {\n  typedef detail::IEEEFloat IEEEFloat;\n  typedef detail::DoubleAPFloat DoubleAPFloat;\n\n  static_assert(std::is_standard_layout<IEEEFloat>::value, \"\");\n\n  union Storage {\n    const fltSemantics *semantics;\n    IEEEFloat IEEE;\n    DoubleAPFloat Double;\n\n    explicit Storage(IEEEFloat F, const fltSemantics &S);\n    explicit Storage(DoubleAPFloat F, const fltSemantics &S)\n        : Double(std::move(F)) {\n      assert(&S == &PPCDoubleDouble());\n    }\n\n    template <typename... ArgTypes>\n    Storage(const fltSemantics &Semantics, ArgTypes &&... Args) {\n      if (usesLayout<IEEEFloat>(Semantics)) {\n        new (&IEEE) IEEEFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(Semantics)) {\n        new (&Double) DoubleAPFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    ~Storage() {\n      if (usesLayout<IEEEFloat>(*semantics)) {\n        IEEE.~IEEEFloat();\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*semantics)) {\n        Double.~DoubleAPFloat();\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(RHS.IEEE);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(RHS.Double);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(std::move(RHS.IEEE));\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(std::move(RHS.Double));\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage &operator=(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = RHS.IEEE;\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = RHS.Double;\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(RHS);\n      }\n      return *this;\n    }\n\n    Storage &operator=(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = std::move(RHS.IEEE);\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = std::move(RHS.Double);\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(std::move(RHS));\n      }\n      return *this;\n    }\n  } U;\n\n  template <typename T> static bool usesLayout(const fltSemantics &Semantics) {\n    static_assert(std::is_same<T, IEEEFloat>::value ||\n                  std::is_same<T, DoubleAPFloat>::value, \"\");\n    if (std::is_same<T, DoubleAPFloat>::value) {\n      return &Semantics == &PPCDoubleDouble();\n    }\n    return &Semantics != &PPCDoubleDouble();\n  }\n\n  IEEEFloat &getIEEE() {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  const IEEEFloat &getIEEE() const {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  void makeZero(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeZero(Neg)); }\n\n  void makeInf(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeInf(Neg)); }\n\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeNaN(SNaN, Neg, fill));\n  }\n\n  void makeLargest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeLargest(Neg));\n  }\n\n  void makeSmallest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallest(Neg));\n  }\n\n  void makeSmallestNormalized(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallestNormalized(Neg));\n  }\n\n  // FIXME: This is due to clang 3.3 (or older version) always checks for the\n  // default constructor in an array aggregate initialization, even if no\n  // elements in the array is default initialized.\n  APFloat() : U(IEEEdouble()) {\n    llvm_unreachable(\"This is a workaround for old clang.\");\n  }\n\n  explicit APFloat(IEEEFloat F, const fltSemantics &S) : U(std::move(F), S) {}\n  explicit APFloat(DoubleAPFloat F, const fltSemantics &S)\n      : U(std::move(F), S) {}\n\n  cmpResult compareAbsoluteValue(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compareAbsoluteValue(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compareAbsoluteValue(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\npublic:\n  APFloat(const fltSemantics &Semantics) : U(Semantics) {}\n  APFloat(const fltSemantics &Semantics, StringRef S);\n  APFloat(const fltSemantics &Semantics, integerPart I) : U(Semantics, I) {}\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>>\n  APFloat(const fltSemantics &Semantics, T V) = delete;\n  // TODO: Remove this constructor. This isn't faster than the first one.\n  APFloat(const fltSemantics &Semantics, uninitializedTag)\n      : U(Semantics, uninitialized) {}\n  APFloat(const fltSemantics &Semantics, const APInt &I) : U(Semantics, I) {}\n  explicit APFloat(double d) : U(IEEEFloat(d), IEEEdouble()) {}\n  explicit APFloat(float f) : U(IEEEFloat(f), IEEEsingle()) {}\n  APFloat(const APFloat &RHS) = default;\n  APFloat(APFloat &&RHS) = default;\n\n  ~APFloat() = default;\n\n  bool needsCleanup() const { APFLOAT_DISPATCH_ON_SEMANTICS(needsCleanup()); }\n\n  /// Factory for Positive and Negative Zero.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeZero(Negative);\n    return Val;\n  }\n\n  /// Factory for Positive and Negative Infinity.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeInf(Negative);\n    return Val;\n  }\n\n  /// Factory for NaN values.\n  ///\n  /// \\param Negative - True iff the NaN generated should be negative.\n  /// \\param payload - The unspecified fill bits for creating the NaN, 0 by\n  /// default.  The value is truncated as necessary.\n  static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,\n                        uint64_t payload = 0) {\n    if (payload) {\n      APInt intPayload(64, payload);\n      return getQNaN(Sem, Negative, &intPayload);\n    } else {\n      return getQNaN(Sem, Negative, nullptr);\n    }\n  }\n\n  /// Factory for QNaN values.\n  static APFloat getQNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(false, Negative, payload);\n    return Val;\n  }\n\n  /// Factory for SNaN values.\n  static APFloat getSNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(true, Negative, payload);\n    return Val;\n  }\n\n  /// Returns the largest finite number in the given semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getLargest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeLargest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) finite number in the given semantics.\n  /// Might be denormalized, which implies a relative loss of precision.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallestNormalized(const fltSemantics &Sem,\n                                       bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallestNormalized(Negative);\n    return Val;\n  }\n\n  /// Returns a float which is bitcasted from an all one value int.\n  ///\n  /// \\param Semantics - type float semantics\n  /// \\param BitWidth - Select float type\n  static APFloat getAllOnesValue(const fltSemantics &Semantics,\n                                 unsigned BitWidth);\n\n  /// Used to insert APFloat objects, or objects that contain APFloat objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID &NID) const;\n\n  opStatus add(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.add(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.add(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus subtract(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.subtract(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.subtract(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus multiply(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.multiply(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.multiply(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus divide(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.divide(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.divide(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus remainder(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.remainder(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.remainder(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus mod(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.mod(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.mod(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus fusedMultiplyAdd(const APFloat &Multiplicand, const APFloat &Addend,\n                            roundingMode RM) {\n    assert(&getSemantics() == &Multiplicand.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    assert(&getSemantics() == &Addend.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.fusedMultiplyAdd(Multiplicand.U.IEEE, Addend.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.fusedMultiplyAdd(Multiplicand.U.Double, Addend.U.Double,\n                                       RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus roundToIntegral(roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(roundToIntegral(RM));\n  }\n\n  // TODO: bool parameters are not readable and a source of bugs.\n  // Do something.\n  opStatus next(bool nextDown) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(next(nextDown));\n  }\n\n  /// Negate an APFloat.\n  APFloat operator-() const {\n    APFloat Result(*this);\n    Result.changeSign();\n    return Result;\n  }\n\n  /// Add two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator+(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.add(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Subtract two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator-(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.subtract(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Multiply two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator*(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.multiply(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Divide the first APFloat by the second, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator/(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.divide(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  void changeSign() { APFLOAT_DISPATCH_ON_SEMANTICS(changeSign()); }\n  void clearSign() {\n    if (isNegative())\n      changeSign();\n  }\n  void copySign(const APFloat &RHS) {\n    if (isNegative() != RHS.isNegative())\n      changeSign();\n  }\n\n  /// A static helper to produce a copy of an APFloat value with its sign\n  /// copied from some other APFloat.\n  static APFloat copySign(APFloat Value, const APFloat &Sign) {\n    Value.copySign(Sign);\n    return Value;\n  }\n\n  opStatus convert(const fltSemantics &ToSemantics, roundingMode RM,\n                   bool *losesInfo);\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToInteger(Input, Width, IsSigned, RM, IsExact));\n  }\n  opStatus convertToInteger(APSInt &Result, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned,\n                            roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(convertFromAPInt(Input, IsSigned, RM));\n  }\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(bitcastToAPInt());\n  }\n  double convertToDouble() const { return getIEEE().convertToDouble(); }\n  float convertToFloat() const { return getIEEE().convertToFloat(); }\n\n  bool operator==(const APFloat &RHS) const { return compare(RHS) == cmpEqual; }\n\n  bool operator!=(const APFloat &RHS) const { return compare(RHS) != cmpEqual; }\n\n  bool operator<(const APFloat &RHS) const {\n    return compare(RHS) == cmpLessThan;\n  }\n\n  bool operator>(const APFloat &RHS) const {\n    return compare(RHS) == cmpGreaterThan;\n  }\n\n  bool operator<=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpLessThan || Res == cmpEqual;\n  }\n\n  bool operator>=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpGreaterThan || Res == cmpEqual;\n  }\n\n  cmpResult compare(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compare(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compare(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  bool bitwiseIsEqual(const APFloat &RHS) const {\n    if (&getSemantics() != &RHS.getSemantics())\n      return false;\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.bitwiseIsEqual(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.bitwiseIsEqual(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n  ///\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat Tmp(V);\n    Tmp.convert(getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return bitwiseIsEqual(Tmp);\n  }\n\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToHexString(DST, HexDigits, UpperCase, RM));\n  }\n\n  bool isZero() const { return getCategory() == fcZero; }\n  bool isInfinity() const { return getCategory() == fcInfinity; }\n  bool isNaN() const { return getCategory() == fcNaN; }\n\n  bool isNegative() const { return getIEEE().isNegative(); }\n  bool isDenormal() const { APFLOAT_DISPATCH_ON_SEMANTICS(isDenormal()); }\n  bool isSignaling() const { return getIEEE().isSignaling(); }\n\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  fltCategory getCategory() const { return getIEEE().getCategory(); }\n  const fltSemantics &getSemantics() const { return *U.semantics; }\n  bool isNonZero() const { return !isZero(); }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n  bool isSmallest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isSmallest()); }\n  bool isLargest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isLargest()); }\n  bool isInteger() const { APFLOAT_DISPATCH_ON_SEMANTICS(isInteger()); }\n  bool isIEEE() const { return usesLayout<IEEEFloat>(getSemantics()); }\n\n  APFloat &operator=(const APFloat &RHS) = default;\n  APFloat &operator=(APFloat &&RHS) = default;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero));\n  }\n\n  void print(raw_ostream &) const;\n  void dump() const;\n\n  bool getExactInverse(APFloat *inv) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(getExactInverse(inv));\n  }\n\n  friend hash_code hash_value(const APFloat &Arg);\n  friend int ilogb(const APFloat &Arg) { return ilogb(Arg.getIEEE()); }\n  friend APFloat scalbn(APFloat X, int Exp, roundingMode RM);\n  friend APFloat frexp(const APFloat &X, int &Exp, roundingMode RM);\n  friend IEEEFloat;\n  friend DoubleAPFloat;\n};\n\n/// See friend declarations above.\n///\n/// These additional declarations are required in order to compile LLVM with IBM\n/// xlC compiler.\nhash_code hash_value(const APFloat &Arg);\ninline APFloat scalbn(APFloat X, int Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n\n/// Equivalent of C standard library function.\n///\n/// While the C standard says Exp is an unspecified value for infinity and nan,\n/// this returns INT_MAX for infinities, and INT_MIN for NaNs.\ninline APFloat frexp(const APFloat &X, int &Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n/// Returns the absolute value of the argument.\ninline APFloat abs(APFloat X) {\n  X.clearSign();\n  return X;\n}\n\n/// Returns the negated value of the argument.\ninline APFloat neg(APFloat X) {\n  X.changeSign();\n  return X;\n}\n\n/// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat minnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat maxnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return A < B ? B : A;\n}\n\n/// Implements IEEE 754-2018 minimum semantics. Returns the smaller of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat minimum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? A : B;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE 754-2018 maximum semantics. Returns the larger of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat maximum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? B : A;\n  return A < B ? B : A;\n}\n\n} // namespace llvm\n\n#undef APFLOAT_DISPATCH_ON_SEMANTICS\n#endif // LLVM_ADT_APFLOAT_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "content": "//===- llvm/ADT/DenseSet.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseSet and SmallDenseSet classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSESET_H\n#define LLVM_ADT_DENSESET_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cstddef>\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\nstruct DenseSetEmpty {};\n\n// Use the empty base class trick so we can create a DenseMap where the buckets\n// contain only a single item.\ntemplate <typename KeyT> class DenseSetPair : public DenseSetEmpty {\n  KeyT key;\n\npublic:\n  KeyT &getFirst() { return key; }\n  const KeyT &getFirst() const { return key; }\n  DenseSetEmpty &getSecond() { return *this; }\n  const DenseSetEmpty &getSecond() const { return *this; }\n};\n\n/// Base class for DenseSet and DenseSmallSet.\n///\n/// MapTy should be either\n///\n///   DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n///            detail::DenseSetPair<ValueT>>\n///\n/// or the equivalent SmallDenseMap type.  ValueInfoT must implement the\n/// DenseMapInfo \"concept\".\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nclass DenseSetImpl {\n  static_assert(sizeof(typename MapTy::value_type) == sizeof(ValueT),\n                \"DenseMap buckets unexpectedly large!\");\n  MapTy TheMap;\n\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using key_type = ValueT;\n  using value_type = ValueT;\n  using size_type = unsigned;\n\n  explicit DenseSetImpl(unsigned InitialReserve = 0) : TheMap(InitialReserve) {}\n\n  template <typename InputIt>\n  DenseSetImpl(const InputIt &I, const InputIt &E)\n      : DenseSetImpl(PowerOf2Ceil(std::distance(I, E))) {\n    insert(I, E);\n  }\n\n  DenseSetImpl(std::initializer_list<ValueT> Elems)\n      : DenseSetImpl(PowerOf2Ceil(Elems.size())) {\n    insert(Elems.begin(), Elems.end());\n  }\n\n  bool empty() const { return TheMap.empty(); }\n  size_type size() const { return TheMap.size(); }\n  size_t getMemorySize() const { return TheMap.getMemorySize(); }\n\n  /// Grow the DenseSet so that it has at least Size buckets. Will not shrink\n  /// the Size of the set.\n  void resize(size_t Size) { TheMap.resize(Size); }\n\n  /// Grow the DenseSet so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_t Size) { TheMap.reserve(Size); }\n\n  void clear() {\n    TheMap.clear();\n  }\n\n  /// Return 1 if the specified key is in the set, 0 otherwise.\n  size_type count(const_arg_type_t<ValueT> V) const {\n    return TheMap.count(V);\n  }\n\n  bool erase(const ValueT &V) {\n    return TheMap.erase(V);\n  }\n\n  void swap(DenseSetImpl &RHS) { TheMap.swap(RHS.TheMap); }\n\n  // Iterators.\n\n  class ConstIterator;\n\n  class Iterator {\n    typename MapTy::iterator I;\n    friend class DenseSetImpl;\n    friend class ConstIterator;\n\n  public:\n    using difference_type = typename MapTy::iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = value_type *;\n    using reference = value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    Iterator() = default;\n    Iterator(const typename MapTy::iterator &i) : I(i) {}\n\n    ValueT &operator*() { return I->getFirst(); }\n    const ValueT &operator*() const { return I->getFirst(); }\n    ValueT *operator->() { return &I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    Iterator& operator++() { ++I; return *this; }\n    Iterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const Iterator &X, const Iterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const Iterator &X, const Iterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  class ConstIterator {\n    typename MapTy::const_iterator I;\n    friend class DenseSetImpl;\n    friend class Iterator;\n\n  public:\n    using difference_type = typename MapTy::const_iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = const value_type *;\n    using reference = const value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    ConstIterator() = default;\n    ConstIterator(const Iterator &B) : I(B.I) {}\n    ConstIterator(const typename MapTy::const_iterator &i) : I(i) {}\n\n    const ValueT &operator*() const { return I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    ConstIterator& operator++() { ++I; return *this; }\n    ConstIterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  using iterator = Iterator;\n  using const_iterator = ConstIterator;\n\n  iterator begin() { return Iterator(TheMap.begin()); }\n  iterator end() { return Iterator(TheMap.end()); }\n\n  const_iterator begin() const { return ConstIterator(TheMap.begin()); }\n  const_iterator end() const { return ConstIterator(TheMap.end()); }\n\n  iterator find(const_arg_type_t<ValueT> V) { return Iterator(TheMap.find(V)); }\n  const_iterator find(const_arg_type_t<ValueT> V) const {\n    return ConstIterator(TheMap.find(V));\n  }\n\n  /// Check if the set contains the given element.\n  bool contains(const_arg_type_t<ValueT> V) const {\n    return TheMap.find(V) != TheMap.end();\n  }\n\n  /// Alternative version of find() which allows a different, and possibly less\n  /// expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key type\n  /// used.\n  template <class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    return Iterator(TheMap.find_as(Val));\n  }\n  template <class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    return ConstIterator(TheMap.find_as(Val));\n  }\n\n  void erase(Iterator I) { return TheMap.erase(I.I); }\n  void erase(ConstIterator CI) { return TheMap.erase(CI.I); }\n\n  std::pair<iterator, bool> insert(const ValueT &V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(V, Empty);\n  }\n\n  std::pair<iterator, bool> insert(ValueT &&V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(std::move(V), Empty);\n  }\n\n  /// Alternative version of insert that uses a different (and possibly less\n  /// expensive) key type.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(const ValueT &V,\n                                      const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({V, detail::DenseSetEmpty()}, LookupKey);\n  }\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(ValueT &&V, const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({std::move(V), detail::DenseSetEmpty()}, LookupKey);\n  }\n\n  // Range insertion of values.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n};\n\n/// Equality comparison for DenseSet.\n///\n/// Iterates over elements of LHS confirming that each element is also a member\n/// of RHS, and that RHS contains no additional values.\n/// Equivalent to N calls to RHS.count. Amortized complexity is linear, worst\n/// case is O(N^2) (if every hash collides).\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator==(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &E : LHS)\n    if (!RHS.count(E))\n      return false;\n\n  return true;\n}\n\n/// Inequality comparison for DenseSet.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator!=(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace detail\n\n/// Implements a dense probed hash-table based set.\ntemplate <typename ValueT, typename ValueInfoT = DenseMapInfo<ValueT>>\nclass DenseSet : public detail::DenseSetImpl<\n                     ValueT, DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                      detail::DenseSetPair<ValueT>>,\n                     ValueInfoT> {\n  using BaseT =\n      detail::DenseSetImpl<ValueT,\n                           DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                    detail::DenseSetPair<ValueT>>,\n                           ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n/// Implements a dense probed hash-table based set with some number of buckets\n/// stored inline.\ntemplate <typename ValueT, unsigned InlineBuckets = 4,\n          typename ValueInfoT = DenseMapInfo<ValueT>>\nclass SmallDenseSet\n    : public detail::DenseSetImpl<\n          ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                                ValueInfoT, detail::DenseSetPair<ValueT>>,\n          ValueInfoT> {\n  using BaseT = detail::DenseSetImpl<\n      ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                            ValueInfoT, detail::DenseSetPair<ValueT>>,\n      ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSESET_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "content": "//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a hash set that can be used to remove duplication of nodes\n// in a graph.  This code was originally created by Chris Lattner for use with\n// SelectionDAGCSEMap, but was isolated to provide use across the llvm code set.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_FOLDINGSET_H\n#define LLVM_ADT_FOLDINGSET_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\n/// This folding set used for two purposes:\n///   1. Given information about a node we want to create, look up the unique\n///      instance of the node in the set.  If the node already exists, return\n///      it, otherwise return the bucket it should be inserted into.\n///   2. Given a node that has already been created, remove it from the set.\n///\n/// This class is implemented as a single-link chained hash table, where the\n/// \"buckets\" are actually the nodes themselves (the next pointer is in the\n/// node).  The last node points back to the bucket to simplify node removal.\n///\n/// Any node that is to be included in the folding set must be a subclass of\n/// FoldingSetNode.  The node class must also define a Profile method used to\n/// establish the unique bits of data for the node.  The Profile method is\n/// passed a FoldingSetNodeID object which is used to gather the bits.  Just\n/// call one of the Add* functions defined in the FoldingSetBase::NodeID class.\n/// NOTE: That the folding set does not own the nodes and it is the\n/// responsibility of the user to dispose of the nodes.\n///\n/// Eg.\n///    class MyNode : public FoldingSetNode {\n///    private:\n///      std::string Name;\n///      unsigned Value;\n///    public:\n///      MyNode(const char *N, unsigned V) : Name(N), Value(V) {}\n///       ...\n///      void Profile(FoldingSetNodeID &ID) const {\n///        ID.AddString(Name);\n///        ID.AddInteger(Value);\n///      }\n///      ...\n///    };\n///\n/// To define the folding set itself use the FoldingSet template;\n///\n/// Eg.\n///    FoldingSet<MyNode> MyFoldingSet;\n///\n/// Four public methods are available to manipulate the folding set;\n///\n/// 1) If you have an existing node that you want add to the set but unsure\n/// that the node might already exist then call;\n///\n///    MyNode *M = MyFoldingSet.GetOrInsertNode(N);\n///\n/// If The result is equal to the input then the node has been inserted.\n/// Otherwise, the result is the node existing in the folding set, and the\n/// input can be discarded (use the result instead.)\n///\n/// 2) If you are ready to construct a node but want to check if it already\n/// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to\n/// check;\n///\n///   FoldingSetNodeID ID;\n///   ID.AddString(Name);\n///   ID.AddInteger(Value);\n///   void *InsertPoint;\n///\n///    MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);\n///\n/// If found then M will be non-NULL, else InsertPoint will point to where it\n/// should be inserted using InsertNode.\n///\n/// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a\n/// new node with InsertNode;\n///\n///    MyFoldingSet.InsertNode(M, InsertPoint);\n///\n/// 4) Finally, if you want to remove a node from the folding set call;\n///\n///    bool WasRemoved = MyFoldingSet.RemoveNode(M);\n///\n/// The result indicates whether the node existed in the folding set.\n\nclass FoldingSetNodeID;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBase - Implements the folding set functionality.  The main\n/// structure is an array of buckets.  Each bucket is indexed by the hash of\n/// the nodes it contains.  The bucket itself points to the nodes contained\n/// in the bucket via a singly linked list.  The last node in the list points\n/// back to the bucket to facilitate node removal.\n///\nclass FoldingSetBase {\nprotected:\n  /// Buckets - Array of bucket chains.\n  void **Buckets;\n\n  /// NumBuckets - Length of the Buckets array.  Always a power of 2.\n  unsigned NumBuckets;\n\n  /// NumNodes - Number of nodes in the folding set. Growth occurs when NumNodes\n  /// is greater than twice the number of buckets.\n  unsigned NumNodes;\n\n  explicit FoldingSetBase(unsigned Log2InitSize = 6);\n  FoldingSetBase(FoldingSetBase &&Arg);\n  FoldingSetBase &operator=(FoldingSetBase &&RHS);\n  ~FoldingSetBase();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  /// Node - This class is used to maintain the singly linked bucket list in\n  /// a folding set.\n  class Node {\n  private:\n    // NextInFoldingSetBucket - next link in the bucket list.\n    void *NextInFoldingSetBucket = nullptr;\n\n  public:\n    Node() = default;\n\n    // Accessors\n    void *getNextInBucket() const { return NextInFoldingSetBucket; }\n    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }\n  };\n\n  /// clear - Remove all nodes from the folding set.\n  void clear();\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return NumNodes; }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return NumNodes == 0; }\n\n  /// capacity - Returns the number of nodes permitted in the folding set\n  /// before a rebucket operation is performed.\n  unsigned capacity() {\n    // We allow a load factor of up to 2.0,\n    // so that means our capacity is NumBuckets * 2\n    return NumBuckets * 2;\n  }\n\nprotected:\n  /// Functions provided by the derived class to compute folding properties.\n  /// This is effectively a vtable for FoldingSetBase, except that we don't\n  /// actually store a pointer to it in the object.\n  struct FoldingSetInfo {\n    /// GetNodeProfile - Instantiations of the FoldingSet template implement\n    /// this function to gather data bits for the given node.\n    void (*GetNodeProfile)(const FoldingSetBase *Self, Node *N,\n                           FoldingSetNodeID &ID);\n\n    /// NodeEquals - Instantiations of the FoldingSet template implement\n    /// this function to compare the given node with the given ID.\n    bool (*NodeEquals)(const FoldingSetBase *Self, Node *N,\n                       const FoldingSetNodeID &ID, unsigned IDHash,\n                       FoldingSetNodeID &TempID);\n\n    /// ComputeNodeHash - Instantiations of the FoldingSet template implement\n    /// this function to compute a hash value for the given node.\n    unsigned (*ComputeNodeHash)(const FoldingSetBase *Self, Node *N,\n                                FoldingSetNodeID &TempID);\n  };\n\nprivate:\n  /// GrowHashTable - Double the size of the hash table and rehash everything.\n  void GrowHashTable(const FoldingSetInfo &Info);\n\n  /// GrowBucketCount - resize the hash table and rehash everything.\n  /// NewBucketCount must be a power of two, and must be greater than the old\n  /// bucket count.\n  void GrowBucketCount(unsigned NewBucketCount, const FoldingSetInfo &Info);\n\nprotected:\n  // The below methods are protected to encourage subclasses to provide a more\n  // type-safe API.\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount, const FoldingSetInfo &Info);\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(Node *N);\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and return\n  /// it instead.\n  Node *GetOrInsertNode(Node *N, const FoldingSetInfo &Info);\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos,\n                            const FoldingSetInfo &Info);\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(Node *N, void *InsertPos, const FoldingSetInfo &Info);\n};\n\n//===----------------------------------------------------------------------===//\n\n/// DefaultFoldingSetTrait - This class provides default implementations\n/// for FoldingSetTrait implementations.\ntemplate<typename T> struct DefaultFoldingSetTrait {\n  static void Profile(const T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n  static void Profile(T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n\n  // Equals - Test if the profile for X would match ID, using TempID\n  // to compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular comparison. Implementations\n  // can override this to provide more efficient implementations.\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID);\n\n  // ComputeHash - Compute a hash value for X, using TempID to\n  // compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular hash computation.\n  // Implementations can override this to provide more efficient\n  // implementations.\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);\n};\n\n/// FoldingSetTrait - This trait class is used to define behavior of how\n/// to \"profile\" (in the FoldingSet parlance) an object of a given type.\n/// The default behavior is to invoke a 'Profile' method on an object, but\n/// through template specialization the behavior can be tailored for specific\n/// types.  Combined with the FoldingSetNodeWrapper class, one can add objects\n/// to FoldingSets that were not originally designed to have that behavior.\ntemplate<typename T> struct FoldingSetTrait\n  : public DefaultFoldingSetTrait<T> {};\n\n/// DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait, but\n/// for ContextualFoldingSets.\ntemplate<typename T, typename Ctx>\nstruct DefaultContextualFoldingSetTrait {\n  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {\n    X.Profile(ID, Context);\n  }\n\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID, Ctx Context);\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,\n                                     Ctx Context);\n};\n\n/// ContextualFoldingSetTrait - Like FoldingSetTrait, but for\n/// ContextualFoldingSets.\ntemplate<typename T, typename Ctx> struct ContextualFoldingSetTrait\n  : public DefaultContextualFoldingSetTrait<T, Ctx> {};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeIDRef - This class describes a reference to an interned\n/// FoldingSetNodeID, which can be a useful to store node id data rather\n/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector\n/// is often much larger than necessary, and the possibility of heap\n/// allocation means it requires a non-trivial destructor call.\nclass FoldingSetNodeIDRef {\n  const unsigned *Data = nullptr;\n  size_t Size = 0;\n\npublic:\n  FoldingSetNodeIDRef() = default;\n  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,\n  /// used to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  bool operator==(FoldingSetNodeIDRef) const;\n\n  bool operator!=(FoldingSetNodeIDRef RHS) const { return !(*this == RHS); }\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(FoldingSetNodeIDRef) const;\n\n  const unsigned *getData() const { return Data; }\n  size_t getSize() const { return Size; }\n};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeID - This class is used to gather all the unique data bits of\n/// a node.  When all the bits are gathered this class is used to produce a\n/// hash value for the node.\nclass FoldingSetNodeID {\n  /// Bits - Vector of all the data bits that make the node unique.\n  /// Use a SmallVector to avoid a heap allocation in the common case.\n  SmallVector<unsigned, 32> Bits;\n\npublic:\n  FoldingSetNodeID() = default;\n\n  FoldingSetNodeID(FoldingSetNodeIDRef Ref)\n    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}\n\n  /// Add* - Add various data types to Bit data.\n  void AddPointer(const void *Ptr);\n  void AddInteger(signed I);\n  void AddInteger(unsigned I);\n  void AddInteger(long I);\n  void AddInteger(unsigned long I);\n  void AddInteger(long long I);\n  void AddInteger(unsigned long long I);\n  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }\n  void AddString(StringRef String);\n  void AddNodeID(const FoldingSetNodeID &ID);\n\n  template <typename T>\n  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }\n\n  /// clear - Clear the accumulated profile, allowing this FoldingSetNodeID\n  /// object to be used to compute a new profile.\n  inline void clear() { Bits.clear(); }\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used\n  /// to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  /// operator== - Used to compare two nodes to each other.\n  bool operator==(const FoldingSetNodeID &RHS) const;\n  bool operator==(const FoldingSetNodeIDRef RHS) const;\n\n  bool operator!=(const FoldingSetNodeID &RHS) const { return !(*this == RHS); }\n  bool operator!=(const FoldingSetNodeIDRef RHS) const { return !(*this ==RHS);}\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(const FoldingSetNodeID &RHS) const;\n  bool operator<(const FoldingSetNodeIDRef RHS) const;\n\n  /// Intern - Copy this node's data to a memory region allocated from the\n  /// given allocator and return a FoldingSetNodeIDRef describing the\n  /// interned data.\n  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;\n};\n\n// Convenience type to hide the implementation of the folding set.\nusing FoldingSetNode = FoldingSetBase::Node;\ntemplate<class T> class FoldingSetIterator;\ntemplate<class T> class FoldingSetBucketIterator;\n\n// Definitions of FoldingSetTrait and ContextualFoldingSetTrait functions, which\n// require the definition of FoldingSetNodeID.\ntemplate<typename T>\ninline bool\nDefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,\n                                  unsigned /*IDHash*/,\n                                  FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID == ID;\n}\ntemplate<typename T>\ninline unsigned\nDefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID.ComputeHash();\n}\ntemplate<typename T, typename Ctx>\ninline bool\nDefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,\n                                                 const FoldingSetNodeID &ID,\n                                                 unsigned /*IDHash*/,\n                                                 FoldingSetNodeID &TempID,\n                                                 Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID == ID;\n}\ntemplate<typename T, typename Ctx>\ninline unsigned\nDefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,\n                                                      FoldingSetNodeID &TempID,\n                                                      Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID.ComputeHash();\n}\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetImpl - An implementation detail that lets us share code between\n/// FoldingSet and ContextualFoldingSet.\ntemplate <class Derived, class T> class FoldingSetImpl : public FoldingSetBase {\nprotected:\n  explicit FoldingSetImpl(unsigned Log2InitSize)\n      : FoldingSetBase(Log2InitSize) {}\n\n  FoldingSetImpl(FoldingSetImpl &&Arg) = default;\n  FoldingSetImpl &operator=(FoldingSetImpl &&RHS) = default;\n  ~FoldingSetImpl() = default;\n\npublic:\n  using iterator = FoldingSetIterator<T>;\n\n  iterator begin() { return iterator(Buckets); }\n  iterator end() { return iterator(Buckets+NumBuckets); }\n\n  using const_iterator = FoldingSetIterator<const T>;\n\n  const_iterator begin() const { return const_iterator(Buckets); }\n  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }\n\n  using bucket_iterator = FoldingSetBucketIterator<T>;\n\n  bucket_iterator bucket_begin(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));\n  }\n\n  bucket_iterator bucket_end(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);\n  }\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount) {\n    return FoldingSetBase::reserve(EltCount, Derived::getFoldingSetInfo());\n  }\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(T *N) {\n    return FoldingSetBase::RemoveNode(N);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    return static_cast<T *>(\n        FoldingSetBase::GetOrInsertNode(N, Derived::getFoldingSetInfo()));\n  }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return static_cast<T *>(FoldingSetBase::FindNodeOrInsertPos(\n        ID, InsertPos, Derived::getFoldingSetInfo()));\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    FoldingSetBase::InsertNode(N, InsertPos, Derived::getFoldingSetInfo());\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    T *Inserted = GetOrInsertNode(N);\n    (void)Inserted;\n    assert(Inserted == N && \"Node already inserted!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSet - This template class is used to instantiate a specialized\n/// implementation of the folding set to the node class T.  T must be a\n/// subclass of FoldingSetNode and implement a Profile function.\n///\n/// Note that this set type is movable and move-assignable. However, its\n/// moved-from state is not a valid state for anything other than\n/// move-assigning and destroying. This is primarily to enable movable APIs\n/// that incorporate these objects.\ntemplate <class T>\nclass FoldingSet : public FoldingSetImpl<FoldingSet<T>, T> {\n  using Super = FoldingSetImpl<FoldingSet, T>;\n  using Node = typename Super::Node;\n\n  /// GetNodeProfile - Each instantiation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    FoldingSetTrait<T>::Profile(*TN, ID);\n  }\n\n  /// NodeEquals - Instantiations may optionally provide a way to compare a\n  /// node with a specified ID.\n  static bool NodeEquals(const FoldingSetBase *, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);\n  }\n\n  /// ComputeNodeHash - Instantiations may optionally provide a way to compute a\n  /// hash value directly from a node.\n  static unsigned ComputeNodeHash(const FoldingSetBase *, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit FoldingSet(unsigned Log2InitSize = 6) : Super(Log2InitSize) {}\n  FoldingSet(FoldingSet &&Arg) = default;\n  FoldingSet &operator=(FoldingSet &&RHS) = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// ContextualFoldingSet - This template class is a further refinement\n/// of FoldingSet which provides a context argument when calling\n/// Profile on its nodes.  Currently, that argument is fixed at\n/// initialization time.\n///\n/// T must be a subclass of FoldingSetNode and implement a Profile\n/// function with signature\n///   void Profile(FoldingSetNodeID &, Ctx);\ntemplate <class T, class Ctx>\nclass ContextualFoldingSet\n    : public FoldingSetImpl<ContextualFoldingSet<T, Ctx>, T> {\n  // Unfortunately, this can't derive from FoldingSet<T> because the\n  // construction of the vtable for FoldingSet<T> requires\n  // FoldingSet<T>::GetNodeProfile to be instantiated, which in turn\n  // requires a single-argument T::Profile().\n\n  using Super = FoldingSetImpl<ContextualFoldingSet, T>;\n  using Node = typename Super::Node;\n\n  Ctx Context;\n\n  static const Ctx &getContext(const FoldingSetBase *Base) {\n    return static_cast<const ContextualFoldingSet*>(Base)->Context;\n  }\n\n  /// GetNodeProfile - Each instantiatation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *Base, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, getContext(Base));\n  }\n\n  static bool NodeEquals(const FoldingSetBase *Base, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,\n                                                     getContext(Base));\n  }\n\n  static unsigned ComputeNodeHash(const FoldingSetBase *Base, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID,\n                                                          getContext(Base));\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)\n      : Super(Log2InitSize), Context(Context) {}\n\n  Ctx getContext() const { return Context; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetVector - This template class combines a FoldingSet and a vector\n/// to provide the interface of FoldingSet but with deterministic iteration\n/// order based on the insertion order. T must be a subclass of FoldingSetNode\n/// and implement a Profile function.\ntemplate <class T, class VectorT = SmallVector<T*, 8>>\nclass FoldingSetVector {\n  FoldingSet<T> Set;\n  VectorT Vector;\n\npublic:\n  explicit FoldingSetVector(unsigned Log2InitSize = 6) : Set(Log2InitSize) {}\n\n  using iterator = pointee_iterator<typename VectorT::iterator>;\n\n  iterator begin() { return Vector.begin(); }\n  iterator end()   { return Vector.end(); }\n\n  using const_iterator = pointee_iterator<typename VectorT::const_iterator>;\n\n  const_iterator begin() const { return Vector.begin(); }\n  const_iterator end()   const { return Vector.end(); }\n\n  /// clear - Remove all nodes from the folding set.\n  void clear() { Set.clear(); Vector.clear(); }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return Set.FindNodeOrInsertPos(ID, InsertPos);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    T *Result = Set.GetOrInsertNode(N);\n    if (Result == N) Vector.push_back(N);\n    return Result;\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    Set.InsertNode(N, InsertPos);\n    Vector.push_back(N);\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    Set.InsertNode(N);\n    Vector.push_back(N);\n  }\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return Set.size(); }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return Set.empty(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetIteratorImpl - This is the common iterator support shared by all\n/// folding sets, which knows how to walk the folding set hash table.\nclass FoldingSetIteratorImpl {\nprotected:\n  FoldingSetNode *NodePtr;\n\n  FoldingSetIteratorImpl(void **Bucket);\n\n  void advance();\n\npublic:\n  bool operator==(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr == RHS.NodePtr;\n  }\n  bool operator!=(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr != RHS.NodePtr;\n  }\n};\n\ntemplate <class T> class FoldingSetIterator : public FoldingSetIteratorImpl {\npublic:\n  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}\n\n  T &operator*() const {\n    return *static_cast<T*>(NodePtr);\n  }\n\n  T *operator->() const {\n    return static_cast<T*>(NodePtr);\n  }\n\n  inline FoldingSetIterator &operator++() {          // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetIterator operator++(int) {        // Postincrement\n    FoldingSetIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBucketIteratorImpl - This is the common bucket iterator support\n/// shared by all folding sets, which knows how to walk a particular bucket\n/// of a folding set hash table.\nclass FoldingSetBucketIteratorImpl {\nprotected:\n  void *Ptr;\n\n  explicit FoldingSetBucketIteratorImpl(void **Bucket);\n\n  FoldingSetBucketIteratorImpl(void **Bucket, bool) : Ptr(Bucket) {}\n\n  void advance() {\n    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();\n    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;\n    Ptr = reinterpret_cast<void*>(x);\n  }\n\npublic:\n  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr == RHS.Ptr;\n  }\n  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr != RHS.Ptr;\n  }\n};\n\ntemplate <class T>\nclass FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {\npublic:\n  explicit FoldingSetBucketIterator(void **Bucket) :\n    FoldingSetBucketIteratorImpl(Bucket) {}\n\n  FoldingSetBucketIterator(void **Bucket, bool) :\n    FoldingSetBucketIteratorImpl(Bucket, true) {}\n\n  T &operator*() const { return *static_cast<T*>(Ptr); }\n  T *operator->() const { return static_cast<T*>(Ptr); }\n\n  inline FoldingSetBucketIterator &operator++() { // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetBucketIterator operator++(int) {      // Postincrement\n    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetNodeWrapper - This template class is used to \"wrap\" arbitrary\n/// types in an enclosing object so that they can be inserted into FoldingSets.\ntemplate <typename T>\nclass FoldingSetNodeWrapper : public FoldingSetNode {\n  T data;\n\npublic:\n  template <typename... Ts>\n  explicit FoldingSetNodeWrapper(Ts &&... Args)\n      : data(std::forward<Ts>(Args)...) {}\n\n  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }\n\n  T &getValue() { return data; }\n  const T &getValue() const { return data; }\n\n  operator T&() { return data; }\n  operator const T&() const { return data; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FastFoldingSetNode - This is a subclass of FoldingSetNode which stores\n/// a FoldingSetNodeID value rather than requiring the node to recompute it\n/// each time it is needed. This trades space for speed (which can be\n/// significant if the ID is long), and it also permits nodes to drop\n/// information that would otherwise only be required for recomputing an ID.\nclass FastFoldingSetNode : public FoldingSetNode {\n  FoldingSetNodeID FastID;\n\nprotected:\n  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}\n\npublic:\n  void Profile(FoldingSetNodeID &ID) const { ID.AddNodeID(FastID); }\n};\n\n//===----------------------------------------------------------------------===//\n// Partial specializations of FoldingSetTrait.\n\ntemplate<typename T> struct FoldingSetTrait<T*> {\n  static inline void Profile(T *X, FoldingSetNodeID &ID) {\n    ID.AddPointer(X);\n  }\n};\ntemplate <typename T1, typename T2>\nstruct FoldingSetTrait<std::pair<T1, T2>> {\n  static inline void Profile(const std::pair<T1, T2> &P,\n                             FoldingSetNodeID &ID) {\n    ID.Add(P.first);\n    ID.Add(P.second);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_FOLDINGSET_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "content": "//==--- ImmutableList.h - Immutable (functional) list interface --*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ImmutableList class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_IMMUTABLELIST_H\n#define LLVM_ADT_IMMUTABLELIST_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstdint>\n#include <new>\n\nnamespace llvm {\n\ntemplate <typename T> class ImmutableListFactory;\n\ntemplate <typename T>\nclass ImmutableListImpl : public FoldingSetNode {\n  friend class ImmutableListFactory<T>;\n\n  T Head;\n  const ImmutableListImpl* Tail;\n\n  template <typename ElemT>\n  ImmutableListImpl(ElemT &&head, const ImmutableListImpl *tail = nullptr)\n    : Head(std::forward<ElemT>(head)), Tail(tail) {}\n\npublic:\n  ImmutableListImpl(const ImmutableListImpl &) = delete;\n  ImmutableListImpl &operator=(const ImmutableListImpl &) = delete;\n\n  const T& getHead() const { return Head; }\n  const ImmutableListImpl* getTail() const { return Tail; }\n\n  static inline void Profile(FoldingSetNodeID& ID, const T& H,\n                             const ImmutableListImpl* L){\n    ID.AddPointer(L);\n    ID.Add(H);\n  }\n\n  void Profile(FoldingSetNodeID& ID) {\n    Profile(ID, Head, Tail);\n  }\n};\n\n/// ImmutableList - This class represents an immutable (functional) list.\n///  It is implemented as a smart pointer (wraps ImmutableListImpl), so it\n///  it is intended to always be copied by value as if it were a pointer.\n///  This interface matches ImmutableSet and ImmutableMap.  ImmutableList\n///  objects should almost never be created directly, and instead should\n///  be created by ImmutableListFactory objects that manage the lifetime\n///  of a group of lists.  When the factory object is reclaimed, all lists\n///  created by that factory are released as well.\ntemplate <typename T>\nclass ImmutableList {\npublic:\n  using value_type = T;\n  using Factory = ImmutableListFactory<T>;\n\n  static_assert(std::is_trivially_destructible<T>::value,\n                \"T must be trivially destructible!\");\n\nprivate:\n  const ImmutableListImpl<T>* X;\n\npublic:\n  // This constructor should normally only be called by ImmutableListFactory<T>.\n  // There may be cases, however, when one needs to extract the internal pointer\n  // and reconstruct a list object from that pointer.\n  ImmutableList(const ImmutableListImpl<T>* x = nullptr) : X(x) {}\n\n  const ImmutableListImpl<T>* getInternalPointer() const {\n    return X;\n  }\n\n  class iterator {\n    const ImmutableListImpl<T>* L = nullptr;\n\n  public:\n    iterator() = default;\n    iterator(ImmutableList l) : L(l.getInternalPointer()) {}\n\n    iterator& operator++() { L = L->getTail(); return *this; }\n    bool operator==(const iterator& I) const { return L == I.L; }\n    bool operator!=(const iterator& I) const { return L != I.L; }\n    const value_type& operator*() const { return L->getHead(); }\n    const typename std::remove_reference<value_type>::type* operator->() const {\n      return &L->getHead();\n    }\n\n    ImmutableList getList() const { return L; }\n  };\n\n  /// begin - Returns an iterator referring to the head of the list, or\n  ///  an iterator denoting the end of the list if the list is empty.\n  iterator begin() const { return iterator(X); }\n\n  /// end - Returns an iterator denoting the end of the list.  This iterator\n  ///  does not refer to a valid list element.\n  iterator end() const { return iterator(); }\n\n  /// isEmpty - Returns true if the list is empty.\n  bool isEmpty() const { return !X; }\n\n  bool contains(const T& V) const {\n    for (iterator I = begin(), E = end(); I != E; ++I) {\n      if (*I == V)\n        return true;\n    }\n    return false;\n  }\n\n  /// isEqual - Returns true if two lists are equal.  Because all lists created\n  ///  from the same ImmutableListFactory are uniqued, this has O(1) complexity\n  ///  because it the contents of the list do not need to be compared.  Note\n  ///  that you should only compare two lists created from the same\n  ///  ImmutableListFactory.\n  bool isEqual(const ImmutableList& L) const { return X == L.X; }\n\n  bool operator==(const ImmutableList& L) const { return isEqual(L); }\n\n  /// getHead - Returns the head of the list.\n  const T& getHead() const {\n    assert(!isEmpty() && \"Cannot get the head of an empty list.\");\n    return X->getHead();\n  }\n\n  /// getTail - Returns the tail of the list, which is another (possibly empty)\n  ///  ImmutableList.\n  ImmutableList getTail() const {\n    return X ? X->getTail() : nullptr;\n  }\n\n  void Profile(FoldingSetNodeID& ID) const {\n    ID.AddPointer(X);\n  }\n};\n\ntemplate <typename T>\nclass ImmutableListFactory {\n  using ListTy = ImmutableListImpl<T>;\n  using CacheTy = FoldingSet<ListTy>;\n\n  CacheTy Cache;\n  uintptr_t Allocator;\n\n  bool ownsAllocator() const {\n    return (Allocator & 0x1) == 0;\n  }\n\n  BumpPtrAllocator& getAllocator() const {\n    return *reinterpret_cast<BumpPtrAllocator*>(Allocator & ~0x1);\n  }\n\npublic:\n  ImmutableListFactory()\n    : Allocator(reinterpret_cast<uintptr_t>(new BumpPtrAllocator())) {}\n\n  ImmutableListFactory(BumpPtrAllocator& Alloc)\n  : Allocator(reinterpret_cast<uintptr_t>(&Alloc) | 0x1) {}\n\n  ~ImmutableListFactory() {\n    if (ownsAllocator()) delete &getAllocator();\n  }\n\n  template <typename ElemT>\n  LLVM_NODISCARD ImmutableList<T> concat(ElemT &&Head, ImmutableList<T> Tail) {\n    // Profile the new list to see if it already exists in our cache.\n    FoldingSetNodeID ID;\n    void* InsertPos;\n\n    const ListTy* TailImpl = Tail.getInternalPointer();\n    ListTy::Profile(ID, Head, TailImpl);\n    ListTy* L = Cache.FindNodeOrInsertPos(ID, InsertPos);\n\n    if (!L) {\n      // The list does not exist in our cache.  Create it.\n      BumpPtrAllocator& A = getAllocator();\n      L = (ListTy*) A.Allocate<ListTy>();\n      new (L) ListTy(std::forward<ElemT>(Head), TailImpl);\n\n      // Insert the new list into the cache.\n      Cache.InsertNode(L, InsertPos);\n    }\n\n    return L;\n  }\n\n  template <typename ElemT>\n  LLVM_NODISCARD ImmutableList<T> add(ElemT &&Data, ImmutableList<T> L) {\n    return concat(std::forward<ElemT>(Data), L);\n  }\n\n  template <typename ...CtorArgs>\n  LLVM_NODISCARD ImmutableList<T> emplace(ImmutableList<T> Tail,\n                                          CtorArgs &&...Args) {\n    return concat(T(std::forward<CtorArgs>(Args)...), Tail);\n  }\n\n  ImmutableList<T> getEmptyList() const {\n    return ImmutableList<T>(nullptr);\n  }\n\n  template <typename ElemT>\n  ImmutableList<T> create(ElemT &&Data) {\n    return concat(std::forward<ElemT>(Data), getEmptyList());\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Partially-specialized Traits.\n//===----------------------------------------------------------------------===//\n\ntemplate<typename T> struct DenseMapInfo;\ntemplate<typename T> struct DenseMapInfo<ImmutableList<T>> {\n  static inline ImmutableList<T> getEmptyKey() {\n    return reinterpret_cast<ImmutableListImpl<T>*>(-1);\n  }\n\n  static inline ImmutableList<T> getTombstoneKey() {\n    return reinterpret_cast<ImmutableListImpl<T>*>(-2);\n  }\n\n  static unsigned getHashValue(ImmutableList<T> X) {\n    uintptr_t PtrVal = reinterpret_cast<uintptr_t>(X.getInternalPointer());\n    return (unsigned((uintptr_t)PtrVal) >> 4) ^\n           (unsigned((uintptr_t)PtrVal) >> 9);\n  }\n\n  static bool isEqual(ImmutableList<T> X1, ImmutableList<T> X2) {\n    return X1 == X2;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_IMMUTABLELIST_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "content": "//===--- ImmutableMap.h - Immutable (functional) map interface --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ImmutableMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_IMMUTABLEMAP_H\n#define LLVM_ADT_IMMUTABLEMAP_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableSet.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <utility>\n\nnamespace llvm {\n\n/// ImutKeyValueInfo -Traits class used by ImmutableMap.  While both the first\n/// and second elements in a pair are used to generate profile information,\n/// only the first element (the key) is used by isEqual and isLess.\ntemplate <typename T, typename S>\nstruct ImutKeyValueInfo {\n  using value_type = const std::pair<T,S>;\n  using value_type_ref = const value_type&;\n  using key_type = const T;\n  using key_type_ref = const T&;\n  using data_type = const S;\n  using data_type_ref = const S&;\n\n  static inline key_type_ref KeyOfValue(value_type_ref V) {\n    return V.first;\n  }\n\n  static inline data_type_ref DataOfValue(value_type_ref V) {\n    return V.second;\n  }\n\n  static inline bool isEqual(key_type_ref L, key_type_ref R) {\n    return ImutContainerInfo<T>::isEqual(L,R);\n  }\n  static inline bool isLess(key_type_ref L, key_type_ref R) {\n    return ImutContainerInfo<T>::isLess(L,R);\n  }\n\n  static inline bool isDataEqual(data_type_ref L, data_type_ref R) {\n    return ImutContainerInfo<S>::isEqual(L,R);\n  }\n\n  static inline void Profile(FoldingSetNodeID& ID, value_type_ref V) {\n    ImutContainerInfo<T>::Profile(ID, V.first);\n    ImutContainerInfo<S>::Profile(ID, V.second);\n  }\n};\n\ntemplate <typename KeyT, typename ValT,\n          typename ValInfo = ImutKeyValueInfo<KeyT,ValT>>\nclass ImmutableMap {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using key_type = typename ValInfo::key_type;\n  using key_type_ref = typename ValInfo::key_type_ref;\n  using data_type = typename ValInfo::data_type;\n  using data_type_ref = typename ValInfo::data_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n\nprotected:\n  IntrusiveRefCntPtr<TreeTy> Root;\n\npublic:\n  /// Constructs a map from a pointer to a tree root.  In general one\n  /// should use a Factory object to create maps instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  explicit ImmutableMap(const TreeTy *R) : Root(const_cast<TreeTy *>(R)) {}\n\n  class Factory {\n    typename TreeTy::Factory F;\n    const bool Canonicalize;\n\n  public:\n    Factory(bool canonicalize = true) : Canonicalize(canonicalize) {}\n\n    Factory(BumpPtrAllocator &Alloc, bool canonicalize = true)\n        : F(Alloc), Canonicalize(canonicalize) {}\n\n    Factory(const Factory &) = delete;\n    Factory &operator=(const Factory &) = delete;\n\n    ImmutableMap getEmptyMap() { return ImmutableMap(F.getEmptyTree()); }\n\n    LLVM_NODISCARD ImmutableMap add(ImmutableMap Old, key_type_ref K,\n                                    data_type_ref D) {\n      TreeTy *T = F.add(Old.Root.get(), std::pair<key_type, data_type>(K, D));\n      return ImmutableMap(Canonicalize ? F.getCanonicalTree(T): T);\n    }\n\n    LLVM_NODISCARD ImmutableMap remove(ImmutableMap Old, key_type_ref K) {\n      TreeTy *T = F.remove(Old.Root.get(), K);\n      return ImmutableMap(Canonicalize ? F.getCanonicalTree(T): T);\n    }\n\n    typename TreeTy::Factory *getTreeFactory() const {\n      return const_cast<typename TreeTy::Factory *>(&F);\n    }\n  };\n\n  bool contains(key_type_ref K) const {\n    return Root ? Root->contains(K) : false;\n  }\n\n  bool operator==(const ImmutableMap &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableMap &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  TreeTy *getRoot() const {\n    if (Root) { Root->retain(); }\n    return Root.get();\n  }\n\n  TreeTy *getRootWithoutRetain() const { return Root.get(); }\n\n  void manualRetain() {\n    if (Root) Root->retain();\n  }\n\n  void manualRelease() {\n    if (Root) Root->release();\n  }\n\n  bool isEmpty() const { return !Root; }\n\n  //===--------------------------------------------------===//\n  // Foreach - A limited form of map iteration.\n  //===--------------------------------------------------===//\n\nprivate:\n  template <typename Callback>\n  struct CBWrapper {\n    Callback C;\n\n    void operator()(value_type_ref V) { C(V.first,V.second); }\n  };\n\n  template <typename Callback>\n  struct CBWrapperRef {\n    Callback &C;\n\n    CBWrapperRef(Callback& c) : C(c) {}\n\n    void operator()(value_type_ref V) { C(V.first,V.second); }\n  };\n\npublic:\n  template <typename Callback>\n  void foreach(Callback& C) {\n    if (Root) {\n      CBWrapperRef<Callback> CB(C);\n      Root->foreach(CB);\n    }\n  }\n\n  template <typename Callback>\n  void foreach() {\n    if (Root) {\n      CBWrapper<Callback> CB;\n      Root->foreach(CB);\n    }\n  }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void verify() const { if (Root) Root->verify(); }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  class iterator : public ImutAVLValueIterator<ImmutableMap> {\n    friend class ImmutableMap;\n\n    iterator() = default;\n    explicit iterator(TreeTy *Tree) : iterator::ImutAVLValueIterator(Tree) {}\n\n  public:\n    key_type_ref getKey() const { return (*this)->first; }\n    data_type_ref getData() const { return (*this)->second; }\n  };\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  data_type* lookup(key_type_ref K) const {\n    if (Root) {\n      TreeTy* T = Root->find(K);\n      if (T) return &T->getValue().second;\n    }\n\n    return nullptr;\n  }\n\n  /// getMaxElement - Returns the <key,value> pair in the ImmutableMap for\n  ///  which key is the highest in the ordering of keys in the map.  This\n  ///  method returns NULL if the map is empty.\n  value_type* getMaxElement() const {\n    return Root ? &(Root->getMaxElement()->getValue()) : nullptr;\n  }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static inline void Profile(FoldingSetNodeID& ID, const ImmutableMap& M) {\n    ID.AddPointer(M.Root.get());\n  }\n\n  inline void Profile(FoldingSetNodeID& ID) const {\n    return Profile(ID,*this);\n  }\n};\n\n// NOTE: This will possibly become the new implementation of ImmutableMap some day.\ntemplate <typename KeyT, typename ValT,\ntypename ValInfo = ImutKeyValueInfo<KeyT,ValT>>\nclass ImmutableMapRef {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using key_type = typename ValInfo::key_type;\n  using key_type_ref = typename ValInfo::key_type_ref;\n  using data_type = typename ValInfo::data_type;\n  using data_type_ref = typename ValInfo::data_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n  using FactoryTy = typename TreeTy::Factory;\n\nprotected:\n  IntrusiveRefCntPtr<TreeTy> Root;\n  FactoryTy *Factory;\n\npublic:\n  /// Constructs a map from a pointer to a tree root.  In general one\n  /// should use a Factory object to create maps instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  ImmutableMapRef(const TreeTy *R, FactoryTy *F)\n      : Root(const_cast<TreeTy *>(R)), Factory(F) {}\n\n  ImmutableMapRef(const ImmutableMap<KeyT, ValT> &X,\n                  typename ImmutableMap<KeyT, ValT>::Factory &F)\n      : Root(X.getRootWithoutRetain()), Factory(F.getTreeFactory()) {}\n\n  static inline ImmutableMapRef getEmptyMap(FactoryTy *F) {\n    return ImmutableMapRef(0, F);\n  }\n\n  void manualRetain() {\n    if (Root) Root->retain();\n  }\n\n  void manualRelease() {\n    if (Root) Root->release();\n  }\n\n  ImmutableMapRef add(key_type_ref K, data_type_ref D) const {\n    TreeTy *NewT =\n        Factory->add(Root.get(), std::pair<key_type, data_type>(K, D));\n    return ImmutableMapRef(NewT, Factory);\n  }\n\n  ImmutableMapRef remove(key_type_ref K) const {\n    TreeTy *NewT = Factory->remove(Root.get(), K);\n    return ImmutableMapRef(NewT, Factory);\n  }\n\n  bool contains(key_type_ref K) const {\n    return Root ? Root->contains(K) : false;\n  }\n\n  ImmutableMap<KeyT, ValT> asImmutableMap() const {\n    return ImmutableMap<KeyT, ValT>(Factory->getCanonicalTree(Root.get()));\n  }\n\n  bool operator==(const ImmutableMapRef &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableMapRef &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  bool isEmpty() const { return !Root; }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void verify() const {\n    if (Root)\n      Root->verify();\n  }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  class iterator : public ImutAVLValueIterator<ImmutableMapRef> {\n    friend class ImmutableMapRef;\n\n    iterator() = default;\n    explicit iterator(TreeTy *Tree) : iterator::ImutAVLValueIterator(Tree) {}\n\n  public:\n    key_type_ref getKey() const { return (*this)->first; }\n    data_type_ref getData() const { return (*this)->second; }\n  };\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  data_type *lookup(key_type_ref K) const {\n    if (Root) {\n      TreeTy* T = Root->find(K);\n      if (T) return &T->getValue().second;\n    }\n\n    return nullptr;\n  }\n\n  /// getMaxElement - Returns the <key,value> pair in the ImmutableMap for\n  ///  which key is the highest in the ordering of keys in the map.  This\n  ///  method returns NULL if the map is empty.\n  value_type* getMaxElement() const {\n    return Root ? &(Root->getMaxElement()->getValue()) : 0;\n  }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static inline void Profile(FoldingSetNodeID &ID, const ImmutableMapRef &M) {\n    ID.AddPointer(M.Root.get());\n  }\n\n  inline void Profile(FoldingSetNodeID &ID) const { return Profile(ID, *this); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_IMMUTABLEMAP_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "content": "//===--- ImmutableSet.h - Immutable (functional) set interface --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ImutAVLTree and ImmutableSet classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_IMMUTABLESET_H\n#define LLVM_ADT_IMMUTABLESET_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <new>\n#include <vector>\n\nnamespace llvm {\n\n//===----------------------------------------------------------------------===//\n// Immutable AVL-Tree Definition.\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ImutInfo> class ImutAVLFactory;\ntemplate <typename ImutInfo> class ImutIntervalAVLFactory;\ntemplate <typename ImutInfo> class ImutAVLTreeInOrderIterator;\ntemplate <typename ImutInfo> class ImutAVLTreeGenericIterator;\n\ntemplate <typename ImutInfo >\nclass ImutAVLTree {\npublic:\n  using key_type_ref = typename ImutInfo::key_type_ref;\n  using value_type = typename ImutInfo::value_type;\n  using value_type_ref = typename ImutInfo::value_type_ref;\n  using Factory = ImutAVLFactory<ImutInfo>;\n  using iterator = ImutAVLTreeInOrderIterator<ImutInfo>;\n\n  friend class ImutAVLFactory<ImutInfo>;\n  friend class ImutIntervalAVLFactory<ImutInfo>;\n  friend class ImutAVLTreeGenericIterator<ImutInfo>;\n\n  //===----------------------------------------------------===//\n  // Public Interface.\n  //===----------------------------------------------------===//\n\n  /// Return a pointer to the left subtree.  This value\n  ///  is NULL if there is no left subtree.\n  ImutAVLTree *getLeft() const { return left; }\n\n  /// Return a pointer to the right subtree.  This value is\n  ///  NULL if there is no right subtree.\n  ImutAVLTree *getRight() const { return right; }\n\n  /// getHeight - Returns the height of the tree.  A tree with no subtrees\n  ///  has a height of 1.\n  unsigned getHeight() const { return height; }\n\n  /// getValue - Returns the data value associated with the tree node.\n  const value_type& getValue() const { return value; }\n\n  /// find - Finds the subtree associated with the specified key value.\n  ///  This method returns NULL if no matching subtree is found.\n  ImutAVLTree* find(key_type_ref K) {\n    ImutAVLTree *T = this;\n    while (T) {\n      key_type_ref CurrentKey = ImutInfo::KeyOfValue(T->getValue());\n      if (ImutInfo::isEqual(K,CurrentKey))\n        return T;\n      else if (ImutInfo::isLess(K,CurrentKey))\n        T = T->getLeft();\n      else\n        T = T->getRight();\n    }\n    return nullptr;\n  }\n\n  /// getMaxElement - Find the subtree associated with the highest ranged\n  ///  key value.\n  ImutAVLTree* getMaxElement() {\n    ImutAVLTree *T = this;\n    ImutAVLTree *Right = T->getRight();\n    while (Right) { T = Right; Right = T->getRight(); }\n    return T;\n  }\n\n  /// size - Returns the number of nodes in the tree, which includes\n  ///  both leaves and non-leaf nodes.\n  unsigned size() const {\n    unsigned n = 1;\n    if (const ImutAVLTree* L = getLeft())\n      n += L->size();\n    if (const ImutAVLTree* R = getRight())\n      n += R->size();\n    return n;\n  }\n\n  /// begin - Returns an iterator that iterates over the nodes of the tree\n  ///  in an inorder traversal.  The returned iterator thus refers to the\n  ///  the tree node with the minimum data element.\n  iterator begin() const { return iterator(this); }\n\n  /// end - Returns an iterator for the tree that denotes the end of an\n  ///  inorder traversal.\n  iterator end() const { return iterator(); }\n\n  bool isElementEqual(value_type_ref V) const {\n    // Compare the keys.\n    if (!ImutInfo::isEqual(ImutInfo::KeyOfValue(getValue()),\n                           ImutInfo::KeyOfValue(V)))\n      return false;\n\n    // Also compare the data values.\n    if (!ImutInfo::isDataEqual(ImutInfo::DataOfValue(getValue()),\n                               ImutInfo::DataOfValue(V)))\n      return false;\n\n    return true;\n  }\n\n  bool isElementEqual(const ImutAVLTree* RHS) const {\n    return isElementEqual(RHS->getValue());\n  }\n\n  /// isEqual - Compares two trees for structural equality and returns true\n  ///   if they are equal.  This worst case performance of this operation is\n  //    linear in the sizes of the trees.\n  bool isEqual(const ImutAVLTree& RHS) const {\n    if (&RHS == this)\n      return true;\n\n    iterator LItr = begin(), LEnd = end();\n    iterator RItr = RHS.begin(), REnd = RHS.end();\n\n    while (LItr != LEnd && RItr != REnd) {\n      if (&*LItr == &*RItr) {\n        LItr.skipSubTree();\n        RItr.skipSubTree();\n        continue;\n      }\n\n      if (!LItr->isElementEqual(&*RItr))\n        return false;\n\n      ++LItr;\n      ++RItr;\n    }\n\n    return LItr == LEnd && RItr == REnd;\n  }\n\n  /// isNotEqual - Compares two trees for structural inequality.  Performance\n  ///  is the same is isEqual.\n  bool isNotEqual(const ImutAVLTree& RHS) const { return !isEqual(RHS); }\n\n  /// contains - Returns true if this tree contains a subtree (node) that\n  ///  has an data element that matches the specified key.  Complexity\n  ///  is logarithmic in the size of the tree.\n  bool contains(key_type_ref K) { return (bool) find(K); }\n\n  /// foreach - A member template the accepts invokes operator() on a functor\n  ///  object (specified by Callback) for every node/subtree in the tree.\n  ///  Nodes are visited using an inorder traversal.\n  template <typename Callback>\n  void foreach(Callback& C) {\n    if (ImutAVLTree* L = getLeft())\n      L->foreach(C);\n\n    C(value);\n\n    if (ImutAVLTree* R = getRight())\n      R->foreach(C);\n  }\n\n  /// validateTree - A utility method that checks that the balancing and\n  ///  ordering invariants of the tree are satisfied.  It is a recursive\n  ///  method that returns the height of the tree, which is then consumed\n  ///  by the enclosing validateTree call.  External callers should ignore the\n  ///  return value.  An invalid tree will cause an assertion to fire in\n  ///  a debug build.\n  unsigned validateTree() const {\n    unsigned HL = getLeft() ? getLeft()->validateTree() : 0;\n    unsigned HR = getRight() ? getRight()->validateTree() : 0;\n    (void) HL;\n    (void) HR;\n\n    assert(getHeight() == ( HL > HR ? HL : HR ) + 1\n            && \"Height calculation wrong\");\n\n    assert((HL > HR ? HL-HR : HR-HL) <= 2\n           && \"Balancing invariant violated\");\n\n    assert((!getLeft() ||\n            ImutInfo::isLess(ImutInfo::KeyOfValue(getLeft()->getValue()),\n                             ImutInfo::KeyOfValue(getValue()))) &&\n           \"Value in left child is not less that current value\");\n\n    assert((!getRight() ||\n             ImutInfo::isLess(ImutInfo::KeyOfValue(getValue()),\n                              ImutInfo::KeyOfValue(getRight()->getValue()))) &&\n           \"Current value is not less that value of right child\");\n\n    return getHeight();\n  }\n\n  //===----------------------------------------------------===//\n  // Internal values.\n  //===----------------------------------------------------===//\n\nprivate:\n  Factory *factory;\n  ImutAVLTree *left;\n  ImutAVLTree *right;\n  ImutAVLTree *prev = nullptr;\n  ImutAVLTree *next = nullptr;\n\n  unsigned height : 28;\n  bool IsMutable : 1;\n  bool IsDigestCached : 1;\n  bool IsCanonicalized : 1;\n\n  value_type value;\n  uint32_t digest = 0;\n  uint32_t refCount = 0;\n\n  //===----------------------------------------------------===//\n  // Internal methods (node manipulation; used by Factory).\n  //===----------------------------------------------------===//\n\nprivate:\n  /// ImutAVLTree - Internal constructor that is only called by\n  ///   ImutAVLFactory.\n  ImutAVLTree(Factory *f, ImutAVLTree* l, ImutAVLTree* r, value_type_ref v,\n              unsigned height)\n    : factory(f), left(l), right(r), height(height), IsMutable(true),\n      IsDigestCached(false), IsCanonicalized(false), value(v)\n  {\n    if (left) left->retain();\n    if (right) right->retain();\n  }\n\n  /// isMutable - Returns true if the left and right subtree references\n  ///  (as well as height) can be changed.  If this method returns false,\n  ///  the tree is truly immutable.  Trees returned from an ImutAVLFactory\n  ///  object should always have this method return true.  Further, if this\n  ///  method returns false for an instance of ImutAVLTree, all subtrees\n  ///  will also have this method return false.  The converse is not true.\n  bool isMutable() const { return IsMutable; }\n\n  /// hasCachedDigest - Returns true if the digest for this tree is cached.\n  ///  This can only be true if the tree is immutable.\n  bool hasCachedDigest() const { return IsDigestCached; }\n\n  //===----------------------------------------------------===//\n  // Mutating operations.  A tree root can be manipulated as\n  // long as its reference has not \"escaped\" from internal\n  // methods of a factory object (see below).  When a tree\n  // pointer is externally viewable by client code, the\n  // internal \"mutable bit\" is cleared to mark the tree\n  // immutable.  Note that a tree that still has its mutable\n  // bit set may have children (subtrees) that are themselves\n  // immutable.\n  //===----------------------------------------------------===//\n\n  /// markImmutable - Clears the mutable flag for a tree.  After this happens,\n  ///   it is an error to call setLeft(), setRight(), and setHeight().\n  void markImmutable() {\n    assert(isMutable() && \"Mutable flag already removed.\");\n    IsMutable = false;\n  }\n\n  /// markedCachedDigest - Clears the NoCachedDigest flag for a tree.\n  void markedCachedDigest() {\n    assert(!hasCachedDigest() && \"NoCachedDigest flag already removed.\");\n    IsDigestCached = true;\n  }\n\n  /// setHeight - Changes the height of the tree.  Used internally by\n  ///  ImutAVLFactory.\n  void setHeight(unsigned h) {\n    assert(isMutable() && \"Only a mutable tree can have its height changed.\");\n    height = h;\n  }\n\n  static uint32_t computeDigest(ImutAVLTree *L, ImutAVLTree *R,\n                                value_type_ref V) {\n    uint32_t digest = 0;\n\n    if (L)\n      digest += L->computeDigest();\n\n    // Compute digest of stored data.\n    FoldingSetNodeID ID;\n    ImutInfo::Profile(ID,V);\n    digest += ID.ComputeHash();\n\n    if (R)\n      digest += R->computeDigest();\n\n    return digest;\n  }\n\n  uint32_t computeDigest() {\n    // Check the lowest bit to determine if digest has actually been\n    // pre-computed.\n    if (hasCachedDigest())\n      return digest;\n\n    uint32_t X = computeDigest(getLeft(), getRight(), getValue());\n    digest = X;\n    markedCachedDigest();\n    return X;\n  }\n\n  //===----------------------------------------------------===//\n  // Reference count operations.\n  //===----------------------------------------------------===//\n\npublic:\n  void retain() { ++refCount; }\n\n  void release() {\n    assert(refCount > 0);\n    if (--refCount == 0)\n      destroy();\n  }\n\n  void destroy() {\n    if (left)\n      left->release();\n    if (right)\n      right->release();\n    if (IsCanonicalized) {\n      if (next)\n        next->prev = prev;\n\n      if (prev)\n        prev->next = next;\n      else\n        factory->Cache[factory->maskCacheIndex(computeDigest())] = next;\n    }\n\n    // We need to clear the mutability bit in case we are\n    // destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().\n    IsMutable = false;\n    factory->freeNodes.push_back(this);\n  }\n};\n\ntemplate <typename ImutInfo>\nstruct IntrusiveRefCntPtrInfo<ImutAVLTree<ImutInfo>> {\n  static void retain(ImutAVLTree<ImutInfo> *Tree) { Tree->retain(); }\n  static void release(ImutAVLTree<ImutInfo> *Tree) { Tree->release(); }\n};\n\n//===----------------------------------------------------------------------===//\n// Immutable AVL-Tree Factory class.\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ImutInfo >\nclass ImutAVLFactory {\n  friend class ImutAVLTree<ImutInfo>;\n\n  using TreeTy = ImutAVLTree<ImutInfo>;\n  using value_type_ref = typename TreeTy::value_type_ref;\n  using key_type_ref = typename TreeTy::key_type_ref;\n  using CacheTy = DenseMap<unsigned, TreeTy*>;\n\n  CacheTy Cache;\n  uintptr_t Allocator;\n  std::vector<TreeTy*> createdNodes;\n  std::vector<TreeTy*> freeNodes;\n\n  bool ownsAllocator() const {\n    return (Allocator & 0x1) == 0;\n  }\n\n  BumpPtrAllocator& getAllocator() const {\n    return *reinterpret_cast<BumpPtrAllocator*>(Allocator & ~0x1);\n  }\n\n  //===--------------------------------------------------===//\n  // Public interface.\n  //===--------------------------------------------------===//\n\npublic:\n  ImutAVLFactory()\n    : Allocator(reinterpret_cast<uintptr_t>(new BumpPtrAllocator())) {}\n\n  ImutAVLFactory(BumpPtrAllocator& Alloc)\n    : Allocator(reinterpret_cast<uintptr_t>(&Alloc) | 0x1) {}\n\n  ~ImutAVLFactory() {\n    if (ownsAllocator()) delete &getAllocator();\n  }\n\n  TreeTy* add(TreeTy* T, value_type_ref V) {\n    T = add_internal(V,T);\n    markImmutable(T);\n    recoverNodes();\n    return T;\n  }\n\n  TreeTy* remove(TreeTy* T, key_type_ref V) {\n    T = remove_internal(V,T);\n    markImmutable(T);\n    recoverNodes();\n    return T;\n  }\n\n  TreeTy* getEmptyTree() const { return nullptr; }\n\nprotected:\n  //===--------------------------------------------------===//\n  // A bunch of quick helper functions used for reasoning\n  // about the properties of trees and their children.\n  // These have succinct names so that the balancing code\n  // is as terse (and readable) as possible.\n  //===--------------------------------------------------===//\n\n  bool            isEmpty(TreeTy* T) const { return !T; }\n  unsigned        getHeight(TreeTy* T) const { return T ? T->getHeight() : 0; }\n  TreeTy*         getLeft(TreeTy* T) const { return T->getLeft(); }\n  TreeTy*         getRight(TreeTy* T) const { return T->getRight(); }\n  value_type_ref  getValue(TreeTy* T) const { return T->value; }\n\n  // Make sure the index is not the Tombstone or Entry key of the DenseMap.\n  static unsigned maskCacheIndex(unsigned I) { return (I & ~0x02); }\n\n  unsigned incrementHeight(TreeTy* L, TreeTy* R) const {\n    unsigned hl = getHeight(L);\n    unsigned hr = getHeight(R);\n    return (hl > hr ? hl : hr) + 1;\n  }\n\n  static bool compareTreeWithSection(TreeTy* T,\n                                     typename TreeTy::iterator& TI,\n                                     typename TreeTy::iterator& TE) {\n    typename TreeTy::iterator I = T->begin(), E = T->end();\n    for ( ; I!=E ; ++I, ++TI) {\n      if (TI == TE || !I->isElementEqual(&*TI))\n        return false;\n    }\n    return true;\n  }\n\n  //===--------------------------------------------------===//\n  // \"createNode\" is used to generate new tree roots that link\n  // to other trees.  The function may also simply move links\n  // in an existing root if that root is still marked mutable.\n  // This is necessary because otherwise our balancing code\n  // would leak memory as it would create nodes that are\n  // then discarded later before the finished tree is\n  // returned to the caller.\n  //===--------------------------------------------------===//\n\n  TreeTy* createNode(TreeTy* L, value_type_ref V, TreeTy* R) {\n    BumpPtrAllocator& A = getAllocator();\n    TreeTy* T;\n    if (!freeNodes.empty()) {\n      T = freeNodes.back();\n      freeNodes.pop_back();\n      assert(T != L);\n      assert(T != R);\n    } else {\n      T = (TreeTy*) A.Allocate<TreeTy>();\n    }\n    new (T) TreeTy(this, L, R, V, incrementHeight(L,R));\n    createdNodes.push_back(T);\n    return T;\n  }\n\n  TreeTy* createNode(TreeTy* newLeft, TreeTy* oldTree, TreeTy* newRight) {\n    return createNode(newLeft, getValue(oldTree), newRight);\n  }\n\n  void recoverNodes() {\n    for (unsigned i = 0, n = createdNodes.size(); i < n; ++i) {\n      TreeTy *N = createdNodes[i];\n      if (N->isMutable() && N->refCount == 0)\n        N->destroy();\n    }\n    createdNodes.clear();\n  }\n\n  /// balanceTree - Used by add_internal and remove_internal to\n  ///  balance a newly created tree.\n  TreeTy* balanceTree(TreeTy* L, value_type_ref V, TreeTy* R) {\n    unsigned hl = getHeight(L);\n    unsigned hr = getHeight(R);\n\n    if (hl > hr + 2) {\n      assert(!isEmpty(L) && \"Left tree cannot be empty to have a height >= 2\");\n\n      TreeTy *LL = getLeft(L);\n      TreeTy *LR = getRight(L);\n\n      if (getHeight(LL) >= getHeight(LR))\n        return createNode(LL, L, createNode(LR,V,R));\n\n      assert(!isEmpty(LR) && \"LR cannot be empty because it has a height >= 1\");\n\n      TreeTy *LRL = getLeft(LR);\n      TreeTy *LRR = getRight(LR);\n\n      return createNode(createNode(LL,L,LRL), LR, createNode(LRR,V,R));\n    }\n\n    if (hr > hl + 2) {\n      assert(!isEmpty(R) && \"Right tree cannot be empty to have a height >= 2\");\n\n      TreeTy *RL = getLeft(R);\n      TreeTy *RR = getRight(R);\n\n      if (getHeight(RR) >= getHeight(RL))\n        return createNode(createNode(L,V,RL), R, RR);\n\n      assert(!isEmpty(RL) && \"RL cannot be empty because it has a height >= 1\");\n\n      TreeTy *RLL = getLeft(RL);\n      TreeTy *RLR = getRight(RL);\n\n      return createNode(createNode(L,V,RLL), RL, createNode(RLR,R,RR));\n    }\n\n    return createNode(L,V,R);\n  }\n\n  /// add_internal - Creates a new tree that includes the specified\n  ///  data and the data from the original tree.  If the original tree\n  ///  already contained the data item, the original tree is returned.\n  TreeTy* add_internal(value_type_ref V, TreeTy* T) {\n    if (isEmpty(T))\n      return createNode(T, V, T);\n    assert(!T->isMutable());\n\n    key_type_ref K = ImutInfo::KeyOfValue(V);\n    key_type_ref KCurrent = ImutInfo::KeyOfValue(getValue(T));\n\n    if (ImutInfo::isEqual(K,KCurrent))\n      return createNode(getLeft(T), V, getRight(T));\n    else if (ImutInfo::isLess(K,KCurrent))\n      return balanceTree(add_internal(V, getLeft(T)), getValue(T), getRight(T));\n    else\n      return balanceTree(getLeft(T), getValue(T), add_internal(V, getRight(T)));\n  }\n\n  /// remove_internal - Creates a new tree that includes all the data\n  ///  from the original tree except the specified data.  If the\n  ///  specified data did not exist in the original tree, the original\n  ///  tree is returned.\n  TreeTy* remove_internal(key_type_ref K, TreeTy* T) {\n    if (isEmpty(T))\n      return T;\n\n    assert(!T->isMutable());\n\n    key_type_ref KCurrent = ImutInfo::KeyOfValue(getValue(T));\n\n    if (ImutInfo::isEqual(K,KCurrent)) {\n      return combineTrees(getLeft(T), getRight(T));\n    } else if (ImutInfo::isLess(K,KCurrent)) {\n      return balanceTree(remove_internal(K, getLeft(T)),\n                                            getValue(T), getRight(T));\n    } else {\n      return balanceTree(getLeft(T), getValue(T),\n                         remove_internal(K, getRight(T)));\n    }\n  }\n\n  TreeTy* combineTrees(TreeTy* L, TreeTy* R) {\n    if (isEmpty(L))\n      return R;\n    if (isEmpty(R))\n      return L;\n    TreeTy* OldNode;\n    TreeTy* newRight = removeMinBinding(R,OldNode);\n    return balanceTree(L, getValue(OldNode), newRight);\n  }\n\n  TreeTy* removeMinBinding(TreeTy* T, TreeTy*& Noderemoved) {\n    assert(!isEmpty(T));\n    if (isEmpty(getLeft(T))) {\n      Noderemoved = T;\n      return getRight(T);\n    }\n    return balanceTree(removeMinBinding(getLeft(T), Noderemoved),\n                       getValue(T), getRight(T));\n  }\n\n  /// markImmutable - Clears the mutable bits of a root and all of its\n  ///  descendants.\n  void markImmutable(TreeTy* T) {\n    if (!T || !T->isMutable())\n      return;\n    T->markImmutable();\n    markImmutable(getLeft(T));\n    markImmutable(getRight(T));\n  }\n\npublic:\n  TreeTy *getCanonicalTree(TreeTy *TNew) {\n    if (!TNew)\n      return nullptr;\n\n    if (TNew->IsCanonicalized)\n      return TNew;\n\n    // Search the hashtable for another tree with the same digest, and\n    // if find a collision compare those trees by their contents.\n    unsigned digest = TNew->computeDigest();\n    TreeTy *&entry = Cache[maskCacheIndex(digest)];\n    do {\n      if (!entry)\n        break;\n      for (TreeTy *T = entry ; T != nullptr; T = T->next) {\n        // Compare the Contents('T') with Contents('TNew')\n        typename TreeTy::iterator TI = T->begin(), TE = T->end();\n        if (!compareTreeWithSection(TNew, TI, TE))\n          continue;\n        if (TI != TE)\n          continue; // T has more contents than TNew.\n        // Trees did match!  Return 'T'.\n        if (TNew->refCount == 0)\n          TNew->destroy();\n        return T;\n      }\n      entry->prev = TNew;\n      TNew->next = entry;\n    }\n    while (false);\n\n    entry = TNew;\n    TNew->IsCanonicalized = true;\n    return TNew;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Immutable AVL-Tree Iterators.\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ImutInfo>\nclass ImutAVLTreeGenericIterator\n    : public std::iterator<std::bidirectional_iterator_tag,\n                           ImutAVLTree<ImutInfo>> {\n  SmallVector<uintptr_t,20> stack;\n\npublic:\n  enum VisitFlag { VisitedNone=0x0, VisitedLeft=0x1, VisitedRight=0x3,\n                   Flags=0x3 };\n\n  using TreeTy = ImutAVLTree<ImutInfo>;\n\n  ImutAVLTreeGenericIterator() = default;\n  ImutAVLTreeGenericIterator(const TreeTy *Root) {\n    if (Root) stack.push_back(reinterpret_cast<uintptr_t>(Root));\n  }\n\n  TreeTy &operator*() const {\n    assert(!stack.empty());\n    return *reinterpret_cast<TreeTy *>(stack.back() & ~Flags);\n  }\n  TreeTy *operator->() const { return &*this; }\n\n  uintptr_t getVisitState() const {\n    assert(!stack.empty());\n    return stack.back() & Flags;\n  }\n\n  bool atEnd() const { return stack.empty(); }\n\n  bool atBeginning() const {\n    return stack.size() == 1 && getVisitState() == VisitedNone;\n  }\n\n  void skipToParent() {\n    assert(!stack.empty());\n    stack.pop_back();\n    if (stack.empty())\n      return;\n    switch (getVisitState()) {\n      case VisitedNone:\n        stack.back() |= VisitedLeft;\n        break;\n      case VisitedLeft:\n        stack.back() |= VisitedRight;\n        break;\n      default:\n        llvm_unreachable(\"Unreachable.\");\n    }\n  }\n\n  bool operator==(const ImutAVLTreeGenericIterator &x) const {\n    return stack == x.stack;\n  }\n\n  bool operator!=(const ImutAVLTreeGenericIterator &x) const {\n    return !(*this == x);\n  }\n\n  ImutAVLTreeGenericIterator &operator++() {\n    assert(!stack.empty());\n    TreeTy* Current = reinterpret_cast<TreeTy*>(stack.back() & ~Flags);\n    assert(Current);\n    switch (getVisitState()) {\n      case VisitedNone:\n        if (TreeTy* L = Current->getLeft())\n          stack.push_back(reinterpret_cast<uintptr_t>(L));\n        else\n          stack.back() |= VisitedLeft;\n        break;\n      case VisitedLeft:\n        if (TreeTy* R = Current->getRight())\n          stack.push_back(reinterpret_cast<uintptr_t>(R));\n        else\n          stack.back() |= VisitedRight;\n        break;\n      case VisitedRight:\n        skipToParent();\n        break;\n      default:\n        llvm_unreachable(\"Unreachable.\");\n    }\n    return *this;\n  }\n\n  ImutAVLTreeGenericIterator &operator--() {\n    assert(!stack.empty());\n    TreeTy* Current = reinterpret_cast<TreeTy*>(stack.back() & ~Flags);\n    assert(Current);\n    switch (getVisitState()) {\n      case VisitedNone:\n        stack.pop_back();\n        break;\n      case VisitedLeft:\n        stack.back() &= ~Flags; // Set state to \"VisitedNone.\"\n        if (TreeTy* L = Current->getLeft())\n          stack.push_back(reinterpret_cast<uintptr_t>(L) | VisitedRight);\n        break;\n      case VisitedRight:\n        stack.back() &= ~Flags;\n        stack.back() |= VisitedLeft;\n        if (TreeTy* R = Current->getRight())\n          stack.push_back(reinterpret_cast<uintptr_t>(R) | VisitedRight);\n        break;\n      default:\n        llvm_unreachable(\"Unreachable.\");\n    }\n    return *this;\n  }\n};\n\ntemplate <typename ImutInfo>\nclass ImutAVLTreeInOrderIterator\n    : public std::iterator<std::bidirectional_iterator_tag,\n                           ImutAVLTree<ImutInfo>> {\n  using InternalIteratorTy = ImutAVLTreeGenericIterator<ImutInfo>;\n\n  InternalIteratorTy InternalItr;\n\npublic:\n  using TreeTy = ImutAVLTree<ImutInfo>;\n\n  ImutAVLTreeInOrderIterator(const TreeTy* Root) : InternalItr(Root) {\n    if (Root)\n      ++*this; // Advance to first element.\n  }\n\n  ImutAVLTreeInOrderIterator() : InternalItr() {}\n\n  bool operator==(const ImutAVLTreeInOrderIterator &x) const {\n    return InternalItr == x.InternalItr;\n  }\n\n  bool operator!=(const ImutAVLTreeInOrderIterator &x) const {\n    return !(*this == x);\n  }\n\n  TreeTy &operator*() const { return *InternalItr; }\n  TreeTy *operator->() const { return &*InternalItr; }\n\n  ImutAVLTreeInOrderIterator &operator++() {\n    do ++InternalItr;\n    while (!InternalItr.atEnd() &&\n           InternalItr.getVisitState() != InternalIteratorTy::VisitedLeft);\n\n    return *this;\n  }\n\n  ImutAVLTreeInOrderIterator &operator--() {\n    do --InternalItr;\n    while (!InternalItr.atBeginning() &&\n           InternalItr.getVisitState() != InternalIteratorTy::VisitedLeft);\n\n    return *this;\n  }\n\n  void skipSubTree() {\n    InternalItr.skipToParent();\n\n    while (!InternalItr.atEnd() &&\n           InternalItr.getVisitState() != InternalIteratorTy::VisitedLeft)\n      ++InternalItr;\n  }\n};\n\n/// Generic iterator that wraps a T::TreeTy::iterator and exposes\n/// iterator::getValue() on dereference.\ntemplate <typename T>\nstruct ImutAVLValueIterator\n    : iterator_adaptor_base<\n          ImutAVLValueIterator<T>, typename T::TreeTy::iterator,\n          typename std::iterator_traits<\n              typename T::TreeTy::iterator>::iterator_category,\n          const typename T::value_type> {\n  ImutAVLValueIterator() = default;\n  explicit ImutAVLValueIterator(typename T::TreeTy *Tree)\n      : ImutAVLValueIterator::iterator_adaptor_base(Tree) {}\n\n  typename ImutAVLValueIterator::reference operator*() const {\n    return this->I->getValue();\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Trait classes for Profile information.\n//===----------------------------------------------------------------------===//\n\n/// Generic profile template.  The default behavior is to invoke the\n/// profile method of an object.  Specializations for primitive integers\n/// and generic handling of pointers is done below.\ntemplate <typename T>\nstruct ImutProfileInfo {\n  using value_type = const T;\n  using value_type_ref = const T&;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    FoldingSetTrait<T>::Profile(X,ID);\n  }\n};\n\n/// Profile traits for integers.\ntemplate <typename T>\nstruct ImutProfileInteger {\n  using value_type = const T;\n  using value_type_ref = const T&;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    ID.AddInteger(X);\n  }\n};\n\n#define PROFILE_INTEGER_INFO(X)\\\ntemplate<> struct ImutProfileInfo<X> : ImutProfileInteger<X> {};\n\nPROFILE_INTEGER_INFO(char)\nPROFILE_INTEGER_INFO(unsigned char)\nPROFILE_INTEGER_INFO(short)\nPROFILE_INTEGER_INFO(unsigned short)\nPROFILE_INTEGER_INFO(unsigned)\nPROFILE_INTEGER_INFO(signed)\nPROFILE_INTEGER_INFO(long)\nPROFILE_INTEGER_INFO(unsigned long)\nPROFILE_INTEGER_INFO(long long)\nPROFILE_INTEGER_INFO(unsigned long long)\n\n#undef PROFILE_INTEGER_INFO\n\n/// Profile traits for booleans.\ntemplate <>\nstruct ImutProfileInfo<bool> {\n  using value_type = const bool;\n  using value_type_ref = const bool&;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    ID.AddBoolean(X);\n  }\n};\n\n/// Generic profile trait for pointer types.  We treat pointers as\n/// references to unique objects.\ntemplate <typename T>\nstruct ImutProfileInfo<T*> {\n  using value_type = const T*;\n  using value_type_ref = value_type;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    ID.AddPointer(X);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Trait classes that contain element comparison operators and type\n//  definitions used by ImutAVLTree, ImmutableSet, and ImmutableMap.  These\n//  inherit from the profile traits (ImutProfileInfo) to include operations\n//  for element profiling.\n//===----------------------------------------------------------------------===//\n\n/// ImutContainerInfo - Generic definition of comparison operations for\n///   elements of immutable containers that defaults to using\n///   std::equal_to<> and std::less<> to perform comparison of elements.\ntemplate <typename T>\nstruct ImutContainerInfo : public ImutProfileInfo<T> {\n  using value_type = typename ImutProfileInfo<T>::value_type;\n  using value_type_ref = typename ImutProfileInfo<T>::value_type_ref;\n  using key_type = value_type;\n  using key_type_ref = value_type_ref;\n  using data_type = bool;\n  using data_type_ref = bool;\n\n  static key_type_ref KeyOfValue(value_type_ref D) { return D; }\n  static data_type_ref DataOfValue(value_type_ref) { return true; }\n\n  static bool isEqual(key_type_ref LHS, key_type_ref RHS) {\n    return std::equal_to<key_type>()(LHS,RHS);\n  }\n\n  static bool isLess(key_type_ref LHS, key_type_ref RHS) {\n    return std::less<key_type>()(LHS,RHS);\n  }\n\n  static bool isDataEqual(data_type_ref, data_type_ref) { return true; }\n};\n\n/// ImutContainerInfo - Specialization for pointer values to treat pointers\n///  as references to unique objects.  Pointers are thus compared by\n///  their addresses.\ntemplate <typename T>\nstruct ImutContainerInfo<T*> : public ImutProfileInfo<T*> {\n  using value_type = typename ImutProfileInfo<T*>::value_type;\n  using value_type_ref = typename ImutProfileInfo<T*>::value_type_ref;\n  using key_type = value_type;\n  using key_type_ref = value_type_ref;\n  using data_type = bool;\n  using data_type_ref = bool;\n\n  static key_type_ref KeyOfValue(value_type_ref D) { return D; }\n  static data_type_ref DataOfValue(value_type_ref) { return true; }\n\n  static bool isEqual(key_type_ref LHS, key_type_ref RHS) { return LHS == RHS; }\n\n  static bool isLess(key_type_ref LHS, key_type_ref RHS) { return LHS < RHS; }\n\n  static bool isDataEqual(data_type_ref, data_type_ref) { return true; }\n};\n\n//===----------------------------------------------------------------------===//\n// Immutable Set\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ValT, typename ValInfo = ImutContainerInfo<ValT>>\nclass ImmutableSet {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n\nprivate:\n  IntrusiveRefCntPtr<TreeTy> Root;\n\npublic:\n  /// Constructs a set from a pointer to a tree root.  In general one\n  /// should use a Factory object to create sets instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  explicit ImmutableSet(TreeTy *R) : Root(R) {}\n\n  class Factory {\n    typename TreeTy::Factory F;\n    const bool Canonicalize;\n\n  public:\n    Factory(bool canonicalize = true)\n      : Canonicalize(canonicalize) {}\n\n    Factory(BumpPtrAllocator& Alloc, bool canonicalize = true)\n      : F(Alloc), Canonicalize(canonicalize) {}\n\n    Factory(const Factory& RHS) = delete;\n    void operator=(const Factory& RHS) = delete;\n\n    /// getEmptySet - Returns an immutable set that contains no elements.\n    ImmutableSet getEmptySet() {\n      return ImmutableSet(F.getEmptyTree());\n    }\n\n    /// add - Creates a new immutable set that contains all of the values\n    ///  of the original set with the addition of the specified value.  If\n    ///  the original set already included the value, then the original set is\n    ///  returned and no memory is allocated.  The time and space complexity\n    ///  of this operation is logarithmic in the size of the original set.\n    ///  The memory allocated to represent the set is released when the\n    ///  factory object that created the set is destroyed.\n    LLVM_NODISCARD ImmutableSet add(ImmutableSet Old, value_type_ref V) {\n      TreeTy *NewT = F.add(Old.Root.get(), V);\n      return ImmutableSet(Canonicalize ? F.getCanonicalTree(NewT) : NewT);\n    }\n\n    /// remove - Creates a new immutable set that contains all of the values\n    ///  of the original set with the exception of the specified value.  If\n    ///  the original set did not contain the value, the original set is\n    ///  returned and no memory is allocated.  The time and space complexity\n    ///  of this operation is logarithmic in the size of the original set.\n    ///  The memory allocated to represent the set is released when the\n    ///  factory object that created the set is destroyed.\n    LLVM_NODISCARD ImmutableSet remove(ImmutableSet Old, value_type_ref V) {\n      TreeTy *NewT = F.remove(Old.Root.get(), V);\n      return ImmutableSet(Canonicalize ? F.getCanonicalTree(NewT) : NewT);\n    }\n\n    BumpPtrAllocator& getAllocator() { return F.getAllocator(); }\n\n    typename TreeTy::Factory *getTreeFactory() const {\n      return const_cast<typename TreeTy::Factory *>(&F);\n    }\n  };\n\n  friend class Factory;\n\n  /// Returns true if the set contains the specified value.\n  bool contains(value_type_ref V) const {\n    return Root ? Root->contains(V) : false;\n  }\n\n  bool operator==(const ImmutableSet &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableSet &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  TreeTy *getRoot() {\n    if (Root) { Root->retain(); }\n    return Root.get();\n  }\n\n  TreeTy *getRootWithoutRetain() const { return Root.get(); }\n\n  /// isEmpty - Return true if the set contains no elements.\n  bool isEmpty() const { return !Root; }\n\n  /// isSingleton - Return true if the set contains exactly one element.\n  ///   This method runs in constant time.\n  bool isSingleton() const { return getHeight() == 1; }\n\n  template <typename Callback>\n  void foreach(Callback& C) { if (Root) Root->foreach(C); }\n\n  template <typename Callback>\n  void foreach() { if (Root) { Callback C; Root->foreach(C); } }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  using iterator = ImutAVLValueIterator<ImmutableSet>;\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static void Profile(FoldingSetNodeID &ID, const ImmutableSet &S) {\n    ID.AddPointer(S.Root.get());\n  }\n\n  void Profile(FoldingSetNodeID &ID) const { return Profile(ID, *this); }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void validateTree() const { if (Root) Root->validateTree(); }\n};\n\n// NOTE: This may some day replace the current ImmutableSet.\ntemplate <typename ValT, typename ValInfo = ImutContainerInfo<ValT>>\nclass ImmutableSetRef {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n  using FactoryTy = typename TreeTy::Factory;\n\nprivate:\n  IntrusiveRefCntPtr<TreeTy> Root;\n  FactoryTy *Factory;\n\npublic:\n  /// Constructs a set from a pointer to a tree root.  In general one\n  /// should use a Factory object to create sets instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  ImmutableSetRef(TreeTy *R, FactoryTy *F) : Root(R), Factory(F) {}\n\n  static ImmutableSetRef getEmptySet(FactoryTy *F) {\n    return ImmutableSetRef(0, F);\n  }\n\n  ImmutableSetRef add(value_type_ref V) {\n    return ImmutableSetRef(Factory->add(Root.get(), V), Factory);\n  }\n\n  ImmutableSetRef remove(value_type_ref V) {\n    return ImmutableSetRef(Factory->remove(Root.get(), V), Factory);\n  }\n\n  /// Returns true if the set contains the specified value.\n  bool contains(value_type_ref V) const {\n    return Root ? Root->contains(V) : false;\n  }\n\n  ImmutableSet<ValT> asImmutableSet(bool canonicalize = true) const {\n    return ImmutableSet<ValT>(\n        canonicalize ? Factory->getCanonicalTree(Root.get()) : Root.get());\n  }\n\n  TreeTy *getRootWithoutRetain() const { return Root.get(); }\n\n  bool operator==(const ImmutableSetRef &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableSetRef &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  /// isEmpty - Return true if the set contains no elements.\n  bool isEmpty() const { return !Root; }\n\n  /// isSingleton - Return true if the set contains exactly one element.\n  ///   This method runs in constant time.\n  bool isSingleton() const { return getHeight() == 1; }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  using iterator = ImutAVLValueIterator<ImmutableSetRef>;\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static void Profile(FoldingSetNodeID &ID, const ImmutableSetRef &S) {\n    ID.AddPointer(S.Root.get());\n  }\n\n  void Profile(FoldingSetNodeID &ID) const { return Profile(ID, *this); }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void validateTree() const { if (Root) Root->validateTree(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_IMMUTABLESET_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/MapVector.h", "content": "//===- llvm/ADT/MapVector.h - Map w/ deterministic value order --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a map that provides insertion order iteration. The\n// interface is purposefully minimal. The key is assumed to be cheap to copy\n// and 2 copies are kept, one for indexing in a DenseMap, one for iteration in\n// a std::vector.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_MAPVECTOR_H\n#define LLVM_ADT_MAPVECTOR_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n/// This class implements a map that also provides access to all stored values\n/// in a deterministic order. The values are kept in a std::vector and the\n/// mapping is done with DenseMap from Keys to indexes in that vector.\ntemplate<typename KeyT, typename ValueT,\n         typename MapType = DenseMap<KeyT, unsigned>,\n         typename VectorType = std::vector<std::pair<KeyT, ValueT>>>\nclass MapVector {\n  MapType Map;\n  VectorType Vector;\n\n  static_assert(\n      std::is_integral<typename MapType::mapped_type>::value,\n      \"The mapped_type of the specified Map must be an integral type\");\n\npublic:\n  using value_type = typename VectorType::value_type;\n  using size_type = typename VectorType::size_type;\n\n  using iterator = typename VectorType::iterator;\n  using const_iterator = typename VectorType::const_iterator;\n  using reverse_iterator = typename VectorType::reverse_iterator;\n  using const_reverse_iterator = typename VectorType::const_reverse_iterator;\n\n  /// Clear the MapVector and return the underlying vector.\n  VectorType takeVector() {\n    Map.clear();\n    return std::move(Vector);\n  }\n\n  size_type size() const { return Vector.size(); }\n\n  /// Grow the MapVector so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    Map.reserve(NumEntries);\n    Vector.reserve(NumEntries);\n  }\n\n  iterator begin() { return Vector.begin(); }\n  const_iterator begin() const { return Vector.begin(); }\n  iterator end() { return Vector.end(); }\n  const_iterator end() const { return Vector.end(); }\n\n  reverse_iterator rbegin() { return Vector.rbegin(); }\n  const_reverse_iterator rbegin() const { return Vector.rbegin(); }\n  reverse_iterator rend() { return Vector.rend(); }\n  const_reverse_iterator rend() const { return Vector.rend(); }\n\n  bool empty() const {\n    return Vector.empty();\n  }\n\n  std::pair<KeyT, ValueT>       &front()       { return Vector.front(); }\n  const std::pair<KeyT, ValueT> &front() const { return Vector.front(); }\n  std::pair<KeyT, ValueT>       &back()        { return Vector.back(); }\n  const std::pair<KeyT, ValueT> &back()  const { return Vector.back(); }\n\n  void clear() {\n    Map.clear();\n    Vector.clear();\n  }\n\n  void swap(MapVector &RHS) {\n    std::swap(Map, RHS.Map);\n    std::swap(Vector, RHS.Vector);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    std::pair<KeyT, typename MapType::mapped_type> Pair = std::make_pair(Key, 0);\n    std::pair<typename MapType::iterator, bool> Result = Map.insert(Pair);\n    auto &I = Result.first->second;\n    if (Result.second) {\n      Vector.push_back(std::make_pair(Key, ValueT()));\n      I = Vector.size() - 1;\n    }\n    return Vector[I].second;\n  }\n\n  // Returns a copy of the value.  Only allowed if ValueT is copyable.\n  ValueT lookup(const KeyT &Key) const {\n    static_assert(std::is_copy_constructible<ValueT>::value,\n                  \"Cannot call lookup() if ValueT is not copyable.\");\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? ValueT() : Vector[Pos->second].second;\n  }\n\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    std::pair<KeyT, typename MapType::mapped_type> Pair = std::make_pair(KV.first, 0);\n    std::pair<typename MapType::iterator, bool> Result = Map.insert(Pair);\n    auto &I = Result.first->second;\n    if (Result.second) {\n      Vector.push_back(std::make_pair(KV.first, KV.second));\n      I = Vector.size() - 1;\n      return std::make_pair(std::prev(end()), true);\n    }\n    return std::make_pair(begin() + I, false);\n  }\n\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    // Copy KV.first into the map, then move it into the vector.\n    std::pair<KeyT, typename MapType::mapped_type> Pair = std::make_pair(KV.first, 0);\n    std::pair<typename MapType::iterator, bool> Result = Map.insert(Pair);\n    auto &I = Result.first->second;\n    if (Result.second) {\n      Vector.push_back(std::move(KV));\n      I = Vector.size() - 1;\n      return std::make_pair(std::prev(end()), true);\n    }\n    return std::make_pair(begin() + I, false);\n  }\n\n  size_type count(const KeyT &Key) const {\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? 0 : 1;\n  }\n\n  iterator find(const KeyT &Key) {\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? Vector.end() :\n                            (Vector.begin() + Pos->second);\n  }\n\n  const_iterator find(const KeyT &Key) const {\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? Vector.end() :\n                            (Vector.begin() + Pos->second);\n  }\n\n  /// Remove the last element from the vector.\n  void pop_back() {\n    typename MapType::iterator Pos = Map.find(Vector.back().first);\n    Map.erase(Pos);\n    Vector.pop_back();\n  }\n\n  /// Remove the element given by Iterator.\n  ///\n  /// Returns an iterator to the element following the one which was removed,\n  /// which may be end().\n  ///\n  /// \\note This is a deceivingly expensive operation (linear time).  It's\n  /// usually better to use \\a remove_if() if possible.\n  typename VectorType::iterator erase(typename VectorType::iterator Iterator) {\n    Map.erase(Iterator->first);\n    auto Next = Vector.erase(Iterator);\n    if (Next == Vector.end())\n      return Next;\n\n    // Update indices in the map.\n    size_t Index = Next - Vector.begin();\n    for (auto &I : Map) {\n      assert(I.second != Index && \"Index was already erased!\");\n      if (I.second > Index)\n        --I.second;\n    }\n    return Next;\n  }\n\n  /// Remove all elements with the key value Key.\n  ///\n  /// Returns the number of elements removed.\n  size_type erase(const KeyT &Key) {\n    auto Iterator = find(Key);\n    if (Iterator == end())\n      return 0;\n    erase(Iterator);\n    return 1;\n  }\n\n  /// Remove the elements that match the predicate.\n  ///\n  /// Erase all elements that match \\c Pred in a single pass.  Takes linear\n  /// time.\n  template <class Predicate> void remove_if(Predicate Pred);\n};\n\ntemplate <typename KeyT, typename ValueT, typename MapType, typename VectorType>\ntemplate <class Function>\nvoid MapVector<KeyT, ValueT, MapType, VectorType>::remove_if(Function Pred) {\n  auto O = Vector.begin();\n  for (auto I = O, E = Vector.end(); I != E; ++I) {\n    if (Pred(*I)) {\n      // Erase from the map.\n      Map.erase(I->first);\n      continue;\n    }\n\n    if (I != O) {\n      // Move the value and update the index in the map.\n      *O = std::move(*I);\n      Map[O->first] = O - Vector.begin();\n    }\n    ++O;\n  }\n  // Erase trailing entries in the vector.\n  Vector.erase(O, Vector.end());\n}\n\n/// A MapVector that performs no allocations if smaller than a certain\n/// size.\ntemplate <typename KeyT, typename ValueT, unsigned N>\nstruct SmallMapVector\n    : MapVector<KeyT, ValueT, SmallDenseMap<KeyT, unsigned, N>,\n                SmallVector<std::pair<KeyT, ValueT>, N>> {\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_MAPVECTOR_H\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "content": "//===- llvm/ADT/PointerUnion.h - Discriminated Union of 2 Ptrs --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PointerUnion class, which is a discriminated union of\n// pointer types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERUNION_H\n#define LLVM_ADT_POINTERUNION_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <typename T> struct PointerUnionTypeSelectorReturn {\n  using Return = T;\n};\n\n/// Get a type based on whether two types are the same or not.\n///\n/// For:\n///\n/// \\code\n///   using Ret = typename PointerUnionTypeSelector<T1, T2, EQ, NE>::Return;\n/// \\endcode\n///\n/// Ret will be EQ type if T1 is same as T2 or NE type otherwise.\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_NE>::Return;\n};\n\ntemplate <typename T, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector<T, T, RET_EQ, RET_NE> {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_EQ>::Return;\n};\n\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelectorReturn<\n    PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>> {\n  using Return =\n      typename PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>::Return;\n};\n\nnamespace pointer_union_detail {\n  /// Determine the number of bits required to store integers with values < n.\n  /// This is ceil(log2(n)).\n  constexpr int bitsRequired(unsigned n) {\n    return n > 1 ? 1 + bitsRequired((n + 1) / 2) : 0;\n  }\n\n  template <typename... Ts> constexpr int lowBitsAvailable() {\n    return std::min<int>({PointerLikeTypeTraits<Ts>::NumLowBitsAvailable...});\n  }\n\n  /// Find the index of a type in a list of types. TypeIndex<T, Us...>::Index\n  /// is the index of T in Us, or sizeof...(Us) if T does not appear in the\n  /// list.\n  template <typename T, typename ...Us> struct TypeIndex;\n  template <typename T, typename ...Us> struct TypeIndex<T, T, Us...> {\n    static constexpr int Index = 0;\n  };\n  template <typename T, typename U, typename... Us>\n  struct TypeIndex<T, U, Us...> {\n    static constexpr int Index = 1 + TypeIndex<T, Us...>::Index;\n  };\n  template <typename T> struct TypeIndex<T> {\n    static constexpr int Index = 0;\n  };\n\n  /// Find the first type in a list of types.\n  template <typename T, typename...> struct GetFirstType {\n    using type = T;\n  };\n\n  /// Provide PointerLikeTypeTraits for void* that is used by PointerUnion\n  /// for the template arguments.\n  template <typename ...PTs> class PointerUnionUIntTraits {\n  public:\n    static inline void *getAsVoidPointer(void *P) { return P; }\n    static inline void *getFromVoidPointer(void *P) { return P; }\n    static constexpr int NumLowBitsAvailable = lowBitsAvailable<PTs...>();\n  };\n\n  template <typename Derived, typename ValTy, int I, typename ...Types>\n  class PointerUnionMembers;\n\n  template <typename Derived, typename ValTy, int I>\n  class PointerUnionMembers<Derived, ValTy, I> {\n  protected:\n    ValTy Val;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(ValTy Val) : Val(Val) {}\n\n    friend struct PointerLikeTypeTraits<Derived>;\n  };\n\n  template <typename Derived, typename ValTy, int I, typename Type,\n            typename ...Types>\n  class PointerUnionMembers<Derived, ValTy, I, Type, Types...>\n      : public PointerUnionMembers<Derived, ValTy, I + 1, Types...> {\n    using Base = PointerUnionMembers<Derived, ValTy, I + 1, Types...>;\n  public:\n    using Base::Base;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(Type V)\n        : Base(ValTy(const_cast<void *>(\n                         PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n                     I)) {}\n\n    using Base::operator=;\n    Derived &operator=(Type V) {\n      this->Val = ValTy(\n          const_cast<void *>(PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n          I);\n      return static_cast<Derived &>(*this);\n    };\n  };\n}\n\n/// A discriminated union of two or more pointer types, with the discriminator\n/// in the low bit of the pointer.\n///\n/// This implementation is extremely efficient in space due to leveraging the\n/// low bits of the pointer, while exposing a natural and type-safe API.\n///\n/// Common use patterns would be something like this:\n///    PointerUnion<int*, float*> P;\n///    P = (int*)0;\n///    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n///    X = P.get<int*>();     // ok.\n///    Y = P.get<float*>();   // runtime assertion failure.\n///    Z = P.get<double*>();  // compile time failure.\n///    P = (float*)0;\n///    Y = P.get<float*>();   // ok.\n///    X = P.get<int*>();     // runtime assertion failure.\ntemplate <typename... PTs>\nclass PointerUnion\n    : public pointer_union_detail::PointerUnionMembers<\n          PointerUnion<PTs...>,\n          PointerIntPair<\n              void *, pointer_union_detail::bitsRequired(sizeof...(PTs)), int,\n              pointer_union_detail::PointerUnionUIntTraits<PTs...>>,\n          0, PTs...> {\n  // The first type is special because we want to directly cast a pointer to a\n  // default-initialized union to a pointer to the first type. But we don't\n  // want PointerUnion to be a 'template <typename First, typename ...Rest>'\n  // because it's much more convenient to have a name for the whole pack. So\n  // split off the first type here.\n  using First = typename pointer_union_detail::GetFirstType<PTs...>::type;\n  using Base = typename PointerUnion::PointerUnionMembers;\n\npublic:\n  PointerUnion() = default;\n\n  PointerUnion(std::nullptr_t) : PointerUnion() {}\n  using Base::Base;\n\n  /// Test if the pointer held in the union is null, regardless of\n  /// which type it is.\n  bool isNull() const { return !this->Val.getPointer(); }\n\n  explicit operator bool() const { return !isNull(); }\n\n  /// Test if the Union currently holds the type matching T.\n  template <typename T> bool is() const {\n    constexpr int Index = pointer_union_detail::TypeIndex<T, PTs...>::Index;\n    static_assert(Index < sizeof...(PTs),\n                  \"PointerUnion::is<T> given type not in the union\");\n    return this->Val.getInt() == Index;\n  }\n\n  /// Returns the value of the specified pointer type.\n  ///\n  /// If the specified pointer type is incorrect, assert.\n  template <typename T> T get() const {\n    assert(is<T>() && \"Invalid accessor called\");\n    return PointerLikeTypeTraits<T>::getFromVoidPointer(this->Val.getPointer());\n  }\n\n  /// Returns the current pointer if it is of the specified pointer type,\n  /// otherwise returns null.\n  template <typename T> T dyn_cast() const {\n    if (is<T>())\n      return get<T>();\n    return T();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First const *getAddrOfPtr1() const {\n    return const_cast<PointerUnion *>(this)->getAddrOfPtr1();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First *getAddrOfPtr1() {\n    assert(is<First>() && \"Val is not the first pointer\");\n    assert(\n        PointerLikeTypeTraits<First>::getAsVoidPointer(get<First>()) ==\n            this->Val.getPointer() &&\n        \"Can't get the address because PointerLikeTypeTraits changes the ptr\");\n    return const_cast<First *>(\n        reinterpret_cast<const First *>(this->Val.getAddrOfPointer()));\n  }\n\n  /// Assignment from nullptr which just clears the union.\n  const PointerUnion &operator=(std::nullptr_t) {\n    this->Val.initWithPointer(nullptr);\n    return *this;\n  }\n\n  /// Assignment from elements of the union.\n  using Base::operator=;\n\n  void *getOpaqueValue() const { return this->Val.getOpaqueValue(); }\n  static inline PointerUnion getFromOpaqueValue(void *VP) {\n    PointerUnion V;\n    V.Val = decltype(V.Val)::getFromOpaqueValue(VP);\n    return V;\n  }\n};\n\ntemplate <typename ...PTs>\nbool operator==(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() == rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator!=(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() != rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator<(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() < rhs.getOpaqueValue();\n}\n\n// Teach SmallPtrSet that PointerUnion is \"basically a pointer\", that has\n// # low bits available = min(PT1bits,PT2bits)-1.\ntemplate <typename ...PTs>\nstruct PointerLikeTypeTraits<PointerUnion<PTs...>> {\n  static inline void *getAsVoidPointer(const PointerUnion<PTs...> &P) {\n    return P.getOpaqueValue();\n  }\n\n  static inline PointerUnion<PTs...> getFromVoidPointer(void *P) {\n    return PointerUnion<PTs...>::getFromOpaqueValue(P);\n  }\n\n  // The number of bits available are the min of the pointer types minus the\n  // bits needed for the discriminator.\n  static constexpr int NumLowBitsAvailable = PointerLikeTypeTraits<decltype(\n      PointerUnion<PTs...>::Val)>::NumLowBitsAvailable;\n};\n\n// Teach DenseMap how to use PointerUnions as keys.\ntemplate <typename ...PTs> struct DenseMapInfo<PointerUnion<PTs...>> {\n  using Union = PointerUnion<PTs...>;\n  using FirstInfo =\n      DenseMapInfo<typename pointer_union_detail::GetFirstType<PTs...>::type>;\n\n  static inline Union getEmptyKey() { return Union(FirstInfo::getEmptyKey()); }\n\n  static inline Union getTombstoneKey() {\n    return Union(FirstInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const Union &UnionVal) {\n    intptr_t key = (intptr_t)UnionVal.getOpaqueValue();\n    return DenseMapInfo<intptr_t>::getHashValue(key);\n  }\n\n  static bool isEqual(const Union &LHS, const Union &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERUNION_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "content": "//===- llvm/ADT/TinyPtrVector.h - 'Normally tiny' vectors -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_TINYPTRVECTOR_H\n#define LLVM_ADT_TINYPTRVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n\nnamespace llvm {\n\n/// TinyPtrVector - This class is specialized for cases where there are\n/// normally 0 or 1 element in a vector, but is general enough to go beyond that\n/// when required.\n///\n/// NOTE: This container doesn't allow you to store a null pointer into it.\n///\ntemplate <typename EltTy>\nclass TinyPtrVector {\npublic:\n  using VecTy = SmallVector<EltTy, 4>;\n  using value_type = typename VecTy::value_type;\n  // EltTy must be the first pointer type so that is<EltTy> is true for the\n  // default-constructed PtrUnion. This allows an empty TinyPtrVector to\n  // naturally vend a begin/end iterator of type EltTy* without an additional\n  // check for the empty state.\n  using PtrUnion = PointerUnion<EltTy, VecTy *>;\n\nprivate:\n  PtrUnion Val;\n\npublic:\n  TinyPtrVector() = default;\n\n  ~TinyPtrVector() {\n    if (VecTy *V = Val.template dyn_cast<VecTy*>())\n      delete V;\n  }\n\n  TinyPtrVector(const TinyPtrVector &RHS) : Val(RHS.Val) {\n    if (VecTy *V = Val.template dyn_cast<VecTy*>())\n      Val = new VecTy(*V);\n  }\n\n  TinyPtrVector &operator=(const TinyPtrVector &RHS) {\n    if (this == &RHS)\n      return *this;\n    if (RHS.empty()) {\n      this->clear();\n      return *this;\n    }\n\n    // Try to squeeze into the single slot. If it won't fit, allocate a copied\n    // vector.\n    if (Val.template is<EltTy>()) {\n      if (RHS.size() == 1)\n        Val = RHS.front();\n      else\n        Val = new VecTy(*RHS.Val.template get<VecTy*>());\n      return *this;\n    }\n\n    // If we have a full vector allocated, try to re-use it.\n    if (RHS.Val.template is<EltTy>()) {\n      Val.template get<VecTy*>()->clear();\n      Val.template get<VecTy*>()->push_back(RHS.front());\n    } else {\n      *Val.template get<VecTy*>() = *RHS.Val.template get<VecTy*>();\n    }\n    return *this;\n  }\n\n  TinyPtrVector(TinyPtrVector &&RHS) : Val(RHS.Val) {\n    RHS.Val = (EltTy)nullptr;\n  }\n\n  TinyPtrVector &operator=(TinyPtrVector &&RHS) {\n    if (this == &RHS)\n      return *this;\n    if (RHS.empty()) {\n      this->clear();\n      return *this;\n    }\n\n    // If this vector has been allocated on the heap, re-use it if cheap. If it\n    // would require more copying, just delete it and we'll steal the other\n    // side.\n    if (VecTy *V = Val.template dyn_cast<VecTy*>()) {\n      if (RHS.Val.template is<EltTy>()) {\n        V->clear();\n        V->push_back(RHS.front());\n        RHS.Val = EltTy();\n        return *this;\n      }\n      delete V;\n    }\n\n    Val = RHS.Val;\n    RHS.Val = EltTy();\n    return *this;\n  }\n\n  TinyPtrVector(std::initializer_list<EltTy> IL)\n      : Val(IL.size() == 0\n                ? PtrUnion()\n                : IL.size() == 1 ? PtrUnion(*IL.begin())\n                                 : PtrUnion(new VecTy(IL.begin(), IL.end()))) {}\n\n  /// Constructor from an ArrayRef.\n  ///\n  /// This also is a constructor for individual array elements due to the single\n  /// element constructor for ArrayRef.\n  explicit TinyPtrVector(ArrayRef<EltTy> Elts)\n      : Val(Elts.empty()\n                ? PtrUnion()\n                : Elts.size() == 1\n                      ? PtrUnion(Elts[0])\n                      : PtrUnion(new VecTy(Elts.begin(), Elts.end()))) {}\n\n  TinyPtrVector(size_t Count, EltTy Value)\n      : Val(Count == 0 ? PtrUnion()\n                       : Count == 1 ? PtrUnion(Value)\n                                    : PtrUnion(new VecTy(Count, Value))) {}\n\n  // implicit conversion operator to ArrayRef.\n  operator ArrayRef<EltTy>() const {\n    if (Val.isNull())\n      return None;\n    if (Val.template is<EltTy>())\n      return *Val.getAddrOfPtr1();\n    return *Val.template get<VecTy*>();\n  }\n\n  // implicit conversion operator to MutableArrayRef.\n  operator MutableArrayRef<EltTy>() {\n    if (Val.isNull())\n      return None;\n    if (Val.template is<EltTy>())\n      return *Val.getAddrOfPtr1();\n    return *Val.template get<VecTy*>();\n  }\n\n  // Implicit conversion to ArrayRef<U> if EltTy* implicitly converts to U*.\n  template <\n      typename U,\n      std::enable_if_t<std::is_convertible<ArrayRef<EltTy>, ArrayRef<U>>::value,\n                       bool> = false>\n  operator ArrayRef<U>() const {\n    return operator ArrayRef<EltTy>();\n  }\n\n  bool empty() const {\n    // This vector can be empty if it contains no element, or if it\n    // contains a pointer to an empty vector.\n    if (Val.isNull()) return true;\n    if (VecTy *Vec = Val.template dyn_cast<VecTy*>())\n      return Vec->empty();\n    return false;\n  }\n\n  unsigned size() const {\n    if (empty())\n      return 0;\n    if (Val.template is<EltTy>())\n      return 1;\n    return Val.template get<VecTy*>()->size();\n  }\n\n  using iterator = EltTy *;\n  using const_iterator = const EltTy *;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  iterator begin() {\n    if (Val.template is<EltTy>())\n      return Val.getAddrOfPtr1();\n\n    return Val.template get<VecTy *>()->begin();\n  }\n\n  iterator end() {\n    if (Val.template is<EltTy>())\n      return begin() + (Val.isNull() ? 0 : 1);\n\n    return Val.template get<VecTy *>()->end();\n  }\n\n  const_iterator begin() const {\n    return (const_iterator)const_cast<TinyPtrVector*>(this)->begin();\n  }\n\n  const_iterator end() const {\n    return (const_iterator)const_cast<TinyPtrVector*>(this)->end();\n  }\n\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(end());\n  }\n\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  EltTy operator[](unsigned i) const {\n    assert(!Val.isNull() && \"can't index into an empty vector\");\n    if (Val.template is<EltTy>()) {\n      assert(i == 0 && \"tinyvector index out of range\");\n      return Val.template get<EltTy>();\n    }\n\n    assert(i < Val.template get<VecTy*>()->size() &&\n           \"tinyvector index out of range\");\n    return (*Val.template get<VecTy*>())[i];\n  }\n\n  EltTy front() const {\n    assert(!empty() && \"vector empty\");\n    if (Val.template is<EltTy>())\n      return Val.template get<EltTy>();\n    return Val.template get<VecTy*>()->front();\n  }\n\n  EltTy back() const {\n    assert(!empty() && \"vector empty\");\n    if (Val.template is<EltTy>())\n      return Val.template get<EltTy>();\n    return Val.template get<VecTy*>()->back();\n  }\n\n  void push_back(EltTy NewVal) {\n    // If we have nothing, add something.\n    if (Val.isNull()) {\n      Val = NewVal;\n      assert(!Val.isNull() && \"Can't add a null value\");\n      return;\n    }\n\n    // If we have a single value, convert to a vector.\n    if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      Val = new VecTy();\n      Val.template get<VecTy*>()->push_back(V);\n    }\n\n    // Add the new value, we know we have a vector.\n    Val.template get<VecTy*>()->push_back(NewVal);\n  }\n\n  void pop_back() {\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>())\n      Val = (EltTy)nullptr;\n    else if (VecTy *Vec = Val.template get<VecTy*>())\n      Vec->pop_back();\n  }\n\n  void clear() {\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>()) {\n      Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      // If we have a vector form, just clear it.\n      Vec->clear();\n    }\n    // Otherwise, we're already empty.\n  }\n\n  iterator erase(iterator I) {\n    assert(I >= begin() && \"Iterator to erase is out of bounds.\");\n    assert(I < end() && \"Erasing at past-the-end iterator.\");\n\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>()) {\n      if (I == begin())\n        Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      // multiple items in a vector; just do the erase, there is no\n      // benefit to collapsing back to a pointer\n      return Vec->erase(I);\n    }\n    return end();\n  }\n\n  iterator erase(iterator S, iterator E) {\n    assert(S >= begin() && \"Range to erase is out of bounds.\");\n    assert(S <= E && \"Trying to erase invalid range.\");\n    assert(E <= end() && \"Trying to erase past the end.\");\n\n    if (Val.template is<EltTy>()) {\n      if (S == begin() && S != E)\n        Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      return Vec->erase(S, E);\n    }\n    return end();\n  }\n\n  iterator insert(iterator I, const EltTy &Elt) {\n    assert(I >= this->begin() && \"Insertion iterator is out of bounds.\");\n    assert(I <= this->end() && \"Inserting past the end of the vector.\");\n    if (I == end()) {\n      push_back(Elt);\n      return std::prev(end());\n    }\n    assert(!Val.isNull() && \"Null value with non-end insert iterator.\");\n    if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      assert(I == begin());\n      Val = Elt;\n      push_back(V);\n      return begin();\n    }\n\n    return Val.template get<VecTy*>()->insert(I, Elt);\n  }\n\n  template<typename ItTy>\n  iterator insert(iterator I, ItTy From, ItTy To) {\n    assert(I >= this->begin() && \"Insertion iterator is out of bounds.\");\n    assert(I <= this->end() && \"Inserting past the end of the vector.\");\n    if (From == To)\n      return I;\n\n    // If we have a single value, convert to a vector.\n    ptrdiff_t Offset = I - begin();\n    if (Val.isNull()) {\n      if (std::next(From) == To) {\n        Val = *From;\n        return begin();\n      }\n\n      Val = new VecTy();\n    } else if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      Val = new VecTy();\n      Val.template get<VecTy*>()->push_back(V);\n    }\n    return Val.template get<VecTy*>()->insert(begin() + Offset, From, To);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_TINYPTRVECTOR_H\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h", "content": "//===- MCTargetOptions.h - MC Target Options --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCTARGETOPTIONS_H\n#define LLVM_MC_MCTARGETOPTIONS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nenum class ExceptionHandling {\n  None,     ///< No exception support\n  DwarfCFI, ///< DWARF-like instruction based exceptions\n  SjLj,     ///< setjmp/longjmp based exceptions\n  ARM,      ///< ARM EHABI\n  WinEH,    ///< Windows Exception Handling\n  Wasm,     ///< WebAssembly Exception Handling\n  AIX,      ///< AIX Exception Handling\n};\n\nenum class DebugCompressionType {\n  None, ///< No compression\n  GNU,  ///< zlib-gnu style compression\n  Z,    ///< zlib style complession\n};\n\nclass StringRef;\n\nclass MCTargetOptions {\npublic:\n  enum AsmInstrumentation {\n    AsmInstrumentationNone,\n    AsmInstrumentationAddress\n  };\n\n  bool MCRelaxAll : 1;\n  bool MCNoExecStack : 1;\n  bool MCFatalWarnings : 1;\n  bool MCNoWarn : 1;\n  bool MCNoDeprecatedWarn : 1;\n  bool MCSaveTempLabels : 1;\n  bool MCUseDwarfDirectory : 1;\n  bool MCIncrementalLinkerCompatible : 1;\n  bool ShowMCEncoding : 1;\n  bool ShowMCInst : 1;\n  bool AsmVerbose : 1;\n\n  /// Preserve Comments in Assembly.\n  bool PreserveAsmComments : 1;\n\n  bool Dwarf64 : 1;\n  int DwarfVersion = 0;\n\n  std::string ABIName;\n  std::string AssemblyLanguage;\n  std::string SplitDwarfFile;\n\n  const char *Argv0 = nullptr;\n  ArrayRef<const char *> CommandLineArgs;\n\n  /// Additional paths to search for `.include` directives when using the\n  /// integrated assembler.\n  std::vector<std::string> IASSearchPaths;\n\n  MCTargetOptions();\n\n  /// getABIName - If this returns a non-empty string this represents the\n  /// textual name of the ABI that we want the backend to use, e.g. o32, or\n  /// aapcs-linux.\n  StringRef getABIName() const;\n\n  /// getAssemblyLanguage - If this returns a non-empty string this represents\n  /// the textual name of the assembly language that we will use for this\n  /// target, e.g. masm.\n  StringRef getAssemblyLanguage() const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCTARGETOPTIONS_H\n"}, "67": {"id": 67, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SaveAndRestore.h", "content": "//===-- SaveAndRestore.h - Utility  -------------------------------*- C++ -*-=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file provides utility classes that use RAII to save and restore\n/// values.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SAVEANDRESTORE_H\n#define LLVM_SUPPORT_SAVEANDRESTORE_H\n\nnamespace llvm {\n\n/// A utility class that uses RAII to save and restore the value of a variable.\ntemplate <typename T> struct SaveAndRestore {\n  SaveAndRestore(T &X) : X(X), OldValue(X) {}\n  SaveAndRestore(T &X, const T &NewValue) : X(X), OldValue(X) {\n    X = NewValue;\n  }\n  ~SaveAndRestore() { X = OldValue; }\n  T get() { return OldValue; }\n\nprivate:\n  T &X;\n  T OldValue;\n};\n\n} // namespace llvm\n\n#endif\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "content": "//===--- TrailingObjects.h - Variable-length classes ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This header defines support for implementing classes that have\n/// some trailing object (or arrays of objects) appended to them. The\n/// main purpose is to make it obvious where this idiom is being used,\n/// and to make the usage more idiomatic and more difficult to get\n/// wrong.\n///\n/// The TrailingObject template abstracts away the reinterpret_cast,\n/// pointer arithmetic, and size calculations used for the allocation\n/// and access of appended arrays of objects, and takes care that they\n/// are all allocated at their required alignment. Additionally, it\n/// ensures that the base type is final -- deriving from a class that\n/// expects data appended immediately after it is typically not safe.\n///\n/// Users are expected to derive from this template, and provide\n/// numTrailingObjects implementations for each trailing type except\n/// the last, e.g. like this sample:\n///\n/// \\code\n/// class VarLengthObj : private TrailingObjects<VarLengthObj, int, double> {\n///   friend TrailingObjects;\n///\n///   unsigned NumInts, NumDoubles;\n///   size_t numTrailingObjects(OverloadToken<int>) const { return NumInts; }\n///  };\n/// \\endcode\n///\n/// You can access the appended arrays via 'getTrailingObjects', and\n/// determine the size needed for allocation via\n/// 'additionalSizeToAlloc' and 'totalSizeToAlloc'.\n///\n/// All the methods implemented by this class are are intended for use\n/// by the implementation of the class, not as part of its interface\n/// (thus, private inheritance is suggested).\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TRAILINGOBJECTS_H\n#define LLVM_SUPPORT_TRAILINGOBJECTS_H\n\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <new>\n#include <type_traits>\n\nnamespace llvm {\n\nnamespace trailing_objects_internal {\n/// Helper template to calculate the max alignment requirement for a set of\n/// objects.\ntemplate <typename First, typename... Rest> class AlignmentCalcHelper {\nprivate:\n  enum {\n    FirstAlignment = alignof(First),\n    RestAlignment = AlignmentCalcHelper<Rest...>::Alignment,\n  };\n\npublic:\n  enum {\n    Alignment = FirstAlignment > RestAlignment ? FirstAlignment : RestAlignment\n  };\n};\n\ntemplate <typename First> class AlignmentCalcHelper<First> {\npublic:\n  enum { Alignment = alignof(First) };\n};\n\n/// The base class for TrailingObjects* classes.\nclass TrailingObjectsBase {\nprotected:\n  /// OverloadToken's purpose is to allow specifying function overloads\n  /// for different types, without actually taking the types as\n  /// parameters. (Necessary because member function templates cannot\n  /// be specialized, so overloads must be used instead of\n  /// specialization.)\n  template <typename T> struct OverloadToken {};\n};\n\n// Just a little helper for transforming a type pack into the same\n// number of a different type. e.g.:\n//   ExtractSecondType<Foo..., int>::type\ntemplate <typename Ty1, typename Ty2> struct ExtractSecondType {\n  typedef Ty2 type;\n};\n\n// TrailingObjectsImpl is somewhat complicated, because it is a\n// recursively inheriting template, in order to handle the template\n// varargs. Each level of inheritance picks off a single trailing type\n// then recurses on the rest. The \"Align\", \"BaseTy\", and\n// \"TopTrailingObj\" arguments are passed through unchanged through the\n// recursion. \"PrevTy\" is, at each level, the type handled by the\n// level right above it.\n\ntemplate <int Align, typename BaseTy, typename TopTrailingObj, typename PrevTy,\n          typename... MoreTys>\nclass TrailingObjectsImpl {\n  // The main template definition is never used -- the two\n  // specializations cover all possibilities.\n};\n\ntemplate <int Align, typename BaseTy, typename TopTrailingObj, typename PrevTy,\n          typename NextTy, typename... MoreTys>\nclass TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, PrevTy, NextTy,\n                          MoreTys...>\n    : public TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, NextTy,\n                                 MoreTys...> {\n\n  typedef TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, NextTy, MoreTys...>\n      ParentType;\n\n  struct RequiresRealignment {\n    static const bool value = alignof(PrevTy) < alignof(NextTy);\n  };\n\n  static constexpr bool requiresRealignment() {\n    return RequiresRealignment::value;\n  }\n\nprotected:\n  // Ensure the inherited getTrailingObjectsImpl is not hidden.\n  using ParentType::getTrailingObjectsImpl;\n\n  // These two functions are helper functions for\n  // TrailingObjects::getTrailingObjects. They recurse to the left --\n  // the result for each type in the list of trailing types depends on\n  // the result of calling the function on the type to the\n  // left. However, the function for the type to the left is\n  // implemented by a *subclass* of this class, so we invoke it via\n  // the TopTrailingObj, which is, via the\n  // curiously-recurring-template-pattern, the most-derived type in\n  // this recursion, and thus, contains all the overloads.\n  static const NextTy *\n  getTrailingObjectsImpl(const BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<NextTy>) {\n    auto *Ptr = TopTrailingObj::getTrailingObjectsImpl(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>()) +\n                TopTrailingObj::callNumTrailingObjects(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>());\n\n    if (requiresRealignment())\n      return reinterpret_cast<const NextTy *>(\n          alignAddr(Ptr, Align::Of<NextTy>()));\n    else\n      return reinterpret_cast<const NextTy *>(Ptr);\n  }\n\n  static NextTy *\n  getTrailingObjectsImpl(BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<NextTy>) {\n    auto *Ptr = TopTrailingObj::getTrailingObjectsImpl(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>()) +\n                TopTrailingObj::callNumTrailingObjects(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>());\n\n    if (requiresRealignment())\n      return reinterpret_cast<NextTy *>(alignAddr(Ptr, Align::Of<NextTy>()));\n    else\n      return reinterpret_cast<NextTy *>(Ptr);\n  }\n\n  // Helper function for TrailingObjects::additionalSizeToAlloc: this\n  // function recurses to superclasses, each of which requires one\n  // fewer size_t argument, and adds its own size.\n  static constexpr size_t additionalSizeToAllocImpl(\n      size_t SizeSoFar, size_t Count1,\n      typename ExtractSecondType<MoreTys, size_t>::type... MoreCounts) {\n    return ParentType::additionalSizeToAllocImpl(\n        (requiresRealignment() ? llvm::alignTo<alignof(NextTy)>(SizeSoFar)\n                               : SizeSoFar) +\n            sizeof(NextTy) * Count1,\n        MoreCounts...);\n  }\n};\n\n// The base case of the TrailingObjectsImpl inheritance recursion,\n// when there's no more trailing types.\ntemplate <int Align, typename BaseTy, typename TopTrailingObj, typename PrevTy>\nclass alignas(Align) TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, PrevTy>\n    : public TrailingObjectsBase {\nprotected:\n  // This is a dummy method, only here so the \"using\" doesn't fail --\n  // it will never be called, because this function recurses backwards\n  // up the inheritance chain to subclasses.\n  static void getTrailingObjectsImpl();\n\n  static constexpr size_t additionalSizeToAllocImpl(size_t SizeSoFar) {\n    return SizeSoFar;\n  }\n\n  template <bool CheckAlignment> static void verifyTrailingObjectsAlignment() {}\n};\n\n} // end namespace trailing_objects_internal\n\n// Finally, the main type defined in this file, the one intended for users...\n\n/// See the file comment for details on the usage of the\n/// TrailingObjects type.\ntemplate <typename BaseTy, typename... TrailingTys>\nclass TrailingObjects : private trailing_objects_internal::TrailingObjectsImpl<\n                            trailing_objects_internal::AlignmentCalcHelper<\n                                TrailingTys...>::Alignment,\n                            BaseTy, TrailingObjects<BaseTy, TrailingTys...>,\n                            BaseTy, TrailingTys...> {\n\n  template <int A, typename B, typename T, typename P, typename... M>\n  friend class trailing_objects_internal::TrailingObjectsImpl;\n\n  template <typename... Tys> class Foo {};\n\n  typedef trailing_objects_internal::TrailingObjectsImpl<\n      trailing_objects_internal::AlignmentCalcHelper<TrailingTys...>::Alignment,\n      BaseTy, TrailingObjects<BaseTy, TrailingTys...>, BaseTy, TrailingTys...>\n      ParentType;\n  using TrailingObjectsBase = trailing_objects_internal::TrailingObjectsBase;\n\n  using ParentType::getTrailingObjectsImpl;\n\n  // This function contains only a static_assert BaseTy is final. The\n  // static_assert must be in a function, and not at class-level\n  // because BaseTy isn't complete at class instantiation time, but\n  // will be by the time this function is instantiated.\n  static void verifyTrailingObjectsAssertions() {\n    static_assert(std::is_final<BaseTy>(), \"BaseTy must be final.\");\n  }\n\n  // These two methods are the base of the recursion for this method.\n  static const BaseTy *\n  getTrailingObjectsImpl(const BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<BaseTy>) {\n    return Obj;\n  }\n\n  static BaseTy *\n  getTrailingObjectsImpl(BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<BaseTy>) {\n    return Obj;\n  }\n\n  // callNumTrailingObjects simply calls numTrailingObjects on the\n  // provided Obj -- except when the type being queried is BaseTy\n  // itself. There is always only one of the base object, so that case\n  // is handled here. (An additional benefit of indirecting through\n  // this function is that consumers only say \"friend\n  // TrailingObjects\", and thus, only this class itself can call the\n  // numTrailingObjects function.)\n  static size_t\n  callNumTrailingObjects(const BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<BaseTy>) {\n    return 1;\n  }\n\n  template <typename T>\n  static size_t callNumTrailingObjects(const BaseTy *Obj,\n                                       TrailingObjectsBase::OverloadToken<T>) {\n    return Obj->numTrailingObjects(TrailingObjectsBase::OverloadToken<T>());\n  }\n\npublic:\n  // Make this (privately inherited) member public.\n#ifndef _MSC_VER\n  using ParentType::OverloadToken;\n#else\n  // An MSVC bug prevents the above from working, (last tested at CL version\n  // 19.28). \"Class5\" in TrailingObjectsTest.cpp tests the problematic case.\n  template <typename T>\n  using OverloadToken = typename ParentType::template OverloadToken<T>;\n#endif\n\n  /// Returns a pointer to the trailing object array of the given type\n  /// (which must be one of those specified in the class template). The\n  /// array may have zero or more elements in it.\n  template <typename T> const T *getTrailingObjects() const {\n    verifyTrailingObjectsAssertions();\n    // Forwards to an impl function with overloads, since member\n    // function templates can't be specialized.\n    return this->getTrailingObjectsImpl(\n        static_cast<const BaseTy *>(this),\n        TrailingObjectsBase::OverloadToken<T>());\n  }\n\n  /// Returns a pointer to the trailing object array of the given type\n  /// (which must be one of those specified in the class template). The\n  /// array may have zero or more elements in it.\n  template <typename T> T *getTrailingObjects() {\n    verifyTrailingObjectsAssertions();\n    // Forwards to an impl function with overloads, since member\n    // function templates can't be specialized.\n    return this->getTrailingObjectsImpl(\n        static_cast<BaseTy *>(this), TrailingObjectsBase::OverloadToken<T>());\n  }\n\n  /// Returns the size of the trailing data, if an object were\n  /// allocated with the given counts (The counts are in the same order\n  /// as the template arguments). This does not include the size of the\n  /// base object.  The template arguments must be the same as those\n  /// used in the class; they are supplied here redundantly only so\n  /// that it's clear what the counts are counting in callers.\n  template <typename... Tys>\n  static constexpr std::enable_if_t<\n      std::is_same<Foo<TrailingTys...>, Foo<Tys...>>::value, size_t>\n  additionalSizeToAlloc(typename trailing_objects_internal::ExtractSecondType<\n                        TrailingTys, size_t>::type... Counts) {\n    return ParentType::additionalSizeToAllocImpl(0, Counts...);\n  }\n\n  /// Returns the total size of an object if it were allocated with the\n  /// given trailing object counts. This is the same as\n  /// additionalSizeToAlloc, except it *does* include the size of the base\n  /// object.\n  template <typename... Tys>\n  static constexpr std::enable_if_t<\n      std::is_same<Foo<TrailingTys...>, Foo<Tys...>>::value, size_t>\n  totalSizeToAlloc(typename trailing_objects_internal::ExtractSecondType<\n                   TrailingTys, size_t>::type... Counts) {\n    return sizeof(BaseTy) + ParentType::additionalSizeToAllocImpl(0, Counts...);\n  }\n\n  TrailingObjects() = default;\n  TrailingObjects(const TrailingObjects &) = delete;\n  TrailingObjects(TrailingObjects &&) = delete;\n  TrailingObjects &operator=(const TrailingObjects &) = delete;\n  TrailingObjects &operator=(TrailingObjects &&) = delete;\n\n  /// A type where its ::with_counts template member has a ::type member\n  /// suitable for use as uninitialized storage for an object with the given\n  /// trailing object counts. The template arguments are similar to those\n  /// of additionalSizeToAlloc.\n  ///\n  /// Use with FixedSizeStorageOwner, e.g.:\n  ///\n  /// \\code{.cpp}\n  ///\n  /// MyObj::FixedSizeStorage<void *>::with_counts<1u>::type myStackObjStorage;\n  /// MyObj::FixedSizeStorageOwner\n  ///     myStackObjOwner(new ((void *)&myStackObjStorage) MyObj);\n  /// MyObj *const myStackObjPtr = myStackObjOwner.get();\n  ///\n  /// \\endcode\n  template <typename... Tys> struct FixedSizeStorage {\n    template <size_t... Counts> struct with_counts {\n      enum { Size = totalSizeToAlloc<Tys...>(Counts...) };\n      struct type {\n        alignas(BaseTy) char buffer[Size];\n      };\n    };\n  };\n\n  /// A type that acts as the owner for an object placed into fixed storage.\n  class FixedSizeStorageOwner {\n  public:\n    FixedSizeStorageOwner(BaseTy *p) : p(p) {}\n    ~FixedSizeStorageOwner() {\n      assert(p && \"FixedSizeStorageOwner owns null?\");\n      p->~BaseTy();\n    }\n\n    BaseTy *get() { return p; }\n    const BaseTy *get() const { return p; }\n\n  private:\n    FixedSizeStorageOwner(const FixedSizeStorageOwner &) = delete;\n    FixedSizeStorageOwner(FixedSizeStorageOwner &&) = delete;\n    FixedSizeStorageOwner &operator=(const FixedSizeStorageOwner &) = delete;\n    FixedSizeStorageOwner &operator=(FixedSizeStorageOwner &&) = delete;\n\n    BaseTy *const p;\n  };\n};\n\n} // end namespace llvm\n\n#endif\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "content": "//===- TypeSize.h - Wrapper around type sizes -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides a struct that can be used to query the size of IR types\n// which may be scalable vectors. It provides convenience operators so that\n// it can be used in much the same way as a single scalar value.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TYPESIZE_H\n#define LLVM_SUPPORT_TYPESIZE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/WithColor.h\"\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <type_traits>\n\nnamespace llvm {\n\ntemplate <typename LeafTy> struct LinearPolyBaseTypeTraits {};\n\n//===----------------------------------------------------------------------===//\n// LinearPolyBase - a base class for linear polynomials with multiple\n// dimensions. This can e.g. be used to describe offsets that are have both a\n// fixed and scalable component.\n//===----------------------------------------------------------------------===//\n\n/// LinearPolyBase describes a linear polynomial:\n///  c0 * scale0 + c1 * scale1 + ... + cK * scaleK\n/// where the scale is implicit, so only the coefficients are encoded.\ntemplate <typename LeafTy>\nclass LinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprivate:\n  std::array<ScalarTy, Dimensions> Coefficients;\n\nprotected:\n  LinearPolyBase(ArrayRef<ScalarTy> Values) {\n    std::copy(Values.begin(), Values.end(), Coefficients.begin());\n  }\n\npublic:\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] += RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] -= RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    for (auto &C : LHS.Coefficients)\n      C *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if_t<std::is_signed<U>::value, LeafTy>\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\n  bool operator==(const LinearPolyBase &RHS) const {\n    return std::equal(Coefficients.begin(), Coefficients.end(),\n                      RHS.Coefficients.begin());\n  }\n\n  bool operator!=(const LinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const {\n    return all_of(Coefficients, [](const ScalarTy &C) { return C == 0; });\n  }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n\n  ScalarTy getValue(unsigned Dim) const { return Coefficients[Dim]; }\n};\n\n//===----------------------------------------------------------------------===//\n// StackOffset - Represent an offset with named fixed and scalable components.\n//===----------------------------------------------------------------------===//\n\nclass StackOffset;\ntemplate <> struct LinearPolyBaseTypeTraits<StackOffset> {\n  using ScalarTy = int64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n/// StackOffset is a class to represent an offset with 2 dimensions,\n/// named fixed and scalable, respectively. This class allows a value for both\n/// dimensions to depict e.g. \"8 bytes and 16 scalable bytes\", which is needed\n/// to represent stack offsets.\nclass StackOffset : public LinearPolyBase<StackOffset> {\nprotected:\n  StackOffset(ScalarTy Fixed, ScalarTy Scalable)\n      : LinearPolyBase<StackOffset>({Fixed, Scalable}) {}\n\npublic:\n  StackOffset() : StackOffset({0, 0}) {}\n  StackOffset(const LinearPolyBase<StackOffset> &Other)\n      : LinearPolyBase<StackOffset>(Other) {}\n  static StackOffset getFixed(ScalarTy Fixed) { return {Fixed, 0}; }\n  static StackOffset getScalable(ScalarTy Scalable) { return {0, Scalable}; }\n  static StackOffset get(ScalarTy Fixed, ScalarTy Scalable) {\n    return {Fixed, Scalable};\n  }\n\n  ScalarTy getFixed() const { return this->getValue(0); }\n  ScalarTy getScalable() const { return this->getValue(1); }\n};\n\n//===----------------------------------------------------------------------===//\n// UnivariateLinearPolyBase - a base class for linear polynomials with multiple\n// dimensions, but where only one dimension can be set at any time.\n// This can e.g. be used to describe sizes that are either fixed or scalable.\n//===----------------------------------------------------------------------===//\n\n/// UnivariateLinearPolyBase is a base class for ElementCount and TypeSize.\n/// Like LinearPolyBase it tries to represent a linear polynomial\n/// where only one dimension can be set at any time, e.g.\n///   0 * scale0 + 0 * scale1 + ... + cJ * scaleJ + ... + 0 * scaleK\n/// The dimension that is set is the univariate dimension.\ntemplate <typename LeafTy>\nclass UnivariateLinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprotected:\n  ScalarTy Value;         // The value at the univeriate dimension.\n  unsigned UnivariateDim; // The univeriate dimension.\n\n  UnivariateLinearPolyBase(ScalarTy Val, unsigned UnivariateDim)\n      : Value(Val), UnivariateDim(UnivariateDim) {\n    assert(UnivariateDim < Dimensions && \"Dimension out of range\");\n  }\n\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value += RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value -= RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    LHS.Value *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if<std::is_signed<U>::value, LeafTy>::type\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\npublic:\n  bool operator==(const UnivariateLinearPolyBase &RHS) const {\n    return Value == RHS.Value && UnivariateDim == RHS.UnivariateDim;\n  }\n\n  bool operator!=(const UnivariateLinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const { return !Value; }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n  ScalarTy getValue() const { return Value; }\n  ScalarTy getValue(unsigned Dim) const {\n    return Dim == UnivariateDim ? Value : 0;\n  }\n\n  /// Add \\p RHS to the value at the univariate dimension.\n  LeafTy getWithIncrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value + RHS, UnivariateDim));\n  }\n\n  /// Subtract \\p RHS from the value at the univariate dimension.\n  LeafTy getWithDecrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value - RHS, UnivariateDim));\n  }\n};\n\n\n//===----------------------------------------------------------------------===//\n// LinearPolySize - base class for fixed- or scalable sizes.\n//  ^  ^ \n//  |  |\n//  |  +----- ElementCount - Leaf class to represent an element count\n//  |                        (vscale x unsigned)\n//  |\n//  +-------- TypeSize - Leaf class to represent a type size\n//                       (vscale x uint64_t)\n//===----------------------------------------------------------------------===//\n\n/// LinearPolySize is a base class to represent sizes. It is either\n/// fixed-sized or it is scalable-sized, but it cannot be both.\ntemplate <typename LeafTy>\nclass LinearPolySize : public UnivariateLinearPolyBase<LeafTy> {\n  // Make the parent class a friend, so that it can access the protected\n  // conversion/copy-constructor for UnivariatePolyBase<LeafTy> ->\n  // LinearPolySize<LeafTy>.\n  friend class UnivariateLinearPolyBase<LeafTy>;\n\npublic:\n  using ScalarTy = typename UnivariateLinearPolyBase<LeafTy>::ScalarTy;\n  enum Dims : unsigned { FixedDim = 0, ScalableDim = 1 };\n\nprotected:\n  LinearPolySize(ScalarTy MinVal, Dims D)\n      : UnivariateLinearPolyBase<LeafTy>(MinVal, D) {}\n\n  LinearPolySize(const UnivariateLinearPolyBase<LeafTy> &V)\n      : UnivariateLinearPolyBase<LeafTy>(V) {}\n\npublic:\n\n  static LeafTy getFixed(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, FixedDim));\n  }\n  static LeafTy getScalable(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, ScalableDim));\n  }\n  static LeafTy get(ScalarTy MinVal, bool Scalable) {\n    return static_cast<LeafTy>(\n        LinearPolySize(MinVal, Scalable ? ScalableDim : FixedDim));\n  }\n  static LeafTy getNull() { return get(0, false); }\n\n  /// Returns the minimum value this size can represent.\n  ScalarTy getKnownMinValue() const { return this->getValue(); }\n  /// Returns whether the size is scaled by a runtime quantity (vscale).\n  bool isScalable() const { return this->UnivariateDim == ScalableDim; }\n  /// A return value of true indicates we know at compile time that the number\n  /// of elements (vscale * Min) is definitely even. However, returning false\n  /// does not guarantee that the total number of elements is odd.\n  bool isKnownEven() const { return (getKnownMinValue() & 0x1) == 0; }\n  /// This function tells the caller whether the element count is known at\n  /// compile time to be a multiple of the scalar value RHS.\n  bool isKnownMultipleOf(ScalarTy RHS) const {\n    return getKnownMinValue() % RHS == 0;\n  }\n\n  // Return the minimum value with the assumption that the count is exact.\n  // Use in places where a scalable count doesn't make sense (e.g. non-vector\n  // types, or vectors in backends which don't support scalable vectors).\n  ScalarTy getFixedValue() const {\n    assert(!isScalable() &&\n           \"Request for a fixed element count on a scalable object\");\n    return getKnownMinValue();\n  }\n\n  // For some cases, size ordering between scalable and fixed size types cannot\n  // be determined at compile time, so such comparisons aren't allowed.\n  //\n  // e.g. <vscale x 2 x i16> could be bigger than <4 x i32> with a runtime\n  // vscale >= 5, equal sized with a vscale of 4, and smaller with\n  // a vscale <= 3.\n  //\n  // All the functions below make use of the fact vscale is always >= 1, which\n  // means that <vscale x 4 x i32> is guaranteed to be >= <4 x i32>, etc.\n\n  static bool isKnownLT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() < RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() > RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownLE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() <= RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() >= RHS.getKnownMinValue();\n    return false;\n  }\n\n  /// We do not provide the '/' operator here because division for polynomial\n  /// types does not work in the same way as for normal integer types. We can\n  /// only divide the minimum value (or coefficient) by RHS, which is not the\n  /// same as\n  ///   (Min * Vscale) / RHS\n  /// The caller is recommended to use this function in combination with\n  /// isKnownMultipleOf(RHS), which lets the caller know if it's possible to\n  /// perform a lossless divide by RHS.\n  LeafTy divideCoefficientBy(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        LinearPolySize::get(getKnownMinValue() / RHS, isScalable()));\n  }\n\n  LeafTy coefficientNextPowerOf2() const {\n    return static_cast<LeafTy>(LinearPolySize::get(\n        static_cast<ScalarTy>(llvm::NextPowerOf2(getKnownMinValue())),\n        isScalable()));\n  }\n\n  /// Printing function.\n  void print(raw_ostream &OS) const {\n    if (isScalable())\n      OS << \"vscale x \";\n    OS << getKnownMinValue();\n  }\n};\n\nclass ElementCount;\ntemplate <> struct LinearPolyBaseTypeTraits<ElementCount> {\n  using ScalarTy = unsigned;\n  static constexpr unsigned Dimensions = 2;\n};\n\nclass ElementCount : public LinearPolySize<ElementCount> {\npublic:\n  ElementCount() : LinearPolySize(LinearPolySize::getNull()) {}\n\n  ElementCount(const LinearPolySize<ElementCount> &V) : LinearPolySize(V) {}\n\n  /// Counting predicates.\n  ///\n  ///@{ Number of elements..\n  /// Exactly one element.\n  bool isScalar() const { return !isScalable() && getKnownMinValue() == 1; }\n  /// One or more elements.\n  bool isVector() const {\n    return (isScalable() && getKnownMinValue() != 0) || getKnownMinValue() > 1;\n  }\n  ///@}\n};\n\n// This class is used to represent the size of types. If the type is of fixed\nclass TypeSize;\ntemplate <> struct LinearPolyBaseTypeTraits<TypeSize> {\n  using ScalarTy = uint64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n// TODO: Most functionality in this class will gradually be phased out\n// so it will resemble LinearPolySize as much as possible.\n//\n// TypeSize is used to represent the size of types. If the type is of fixed\n// size, it will represent the exact size. If the type is a scalable vector,\n// it will represent the known minimum size.\nclass TypeSize : public LinearPolySize<TypeSize> {\npublic:\n  TypeSize(const LinearPolySize<TypeSize> &V) : LinearPolySize(V) {}\n  TypeSize(ScalarTy MinVal, bool IsScalable)\n      : LinearPolySize(LinearPolySize::get(MinVal, IsScalable)) {}\n\n  static TypeSize Fixed(ScalarTy MinVal) { return TypeSize(MinVal, false); }\n  static TypeSize Scalable(ScalarTy MinVal) { return TypeSize(MinVal, true); }\n\n  ScalarTy getFixedSize() const { return getFixedValue(); }\n  ScalarTy getKnownMinSize() const { return getKnownMinValue(); }\n\n  // All code for this class below this point is needed because of the\n  // temporary implicit conversion to uint64_t. The operator overloads are\n  // needed because otherwise the conversion of the parent class\n  // UnivariateLinearPolyBase -> TypeSize is ambiguous.\n  // TODO: Remove the implicit conversion.\n\n  // Casts to a uint64_t if this is a fixed-width size.\n  //\n  // This interface is deprecated and will be removed in a future version\n  // of LLVM in favour of upgrading uses that rely on this implicit conversion\n  // to uint64_t. Calls to functions that return a TypeSize should use the\n  // proper interfaces to TypeSize.\n  // In practice this is mostly calls to MVT/EVT::getSizeInBits().\n  //\n  // To determine how to upgrade the code:\n  //\n  //   if (<algorithm works for both scalable and fixed-width vectors>)\n  //     use getKnownMinValue()\n  //   else if (<algorithm works only for fixed-width vectors>) {\n  //     if <algorithm can be adapted for both scalable and fixed-width vectors>\n  //       update the algorithm and use getKnownMinValue()\n  //     else\n  //       bail out early for scalable vectors and use getFixedValue()\n  //   }\n  operator ScalarTy() const {\n#ifdef STRICT_FIXED_SIZE_VECTORS\n    return getFixedValue();\n#else\n    if (isScalable())\n      WithColor::warning() << \"Compiler has made implicit assumption that \"\n                              \"TypeSize is not scalable. This may or may not \"\n                              \"lead to broken code.\\n\";\n    return getKnownMinValue();\n#endif\n  }\n\n  // Additional operators needed to avoid ambiguous parses\n  // because of the implicit conversion hack.\n  friend TypeSize operator*(const TypeSize &LHS, const int RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const unsigned RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const int64_t RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const int LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const unsigned LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const int64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const uint64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Utilities\n//===----------------------------------------------------------------------===//\n\n/// Returns a TypeSize with a known minimum size that is the next integer\n/// (mod 2**64) that is greater than or equal to \\p Value and is a multiple\n/// of \\p Align. \\p Align must be non-zero.\n///\n/// Similar to the alignTo functions in MathExtras.h\ninline TypeSize alignTo(TypeSize Size, uint64_t Align) {\n  assert(Align != 0u && \"Align must be non-zero\");\n  return {(Size.getKnownMinValue() + Align - 1) / Align * Align,\n          Size.isScalable()};\n}\n\n/// Stream operator function for `LinearPolySize`.\ntemplate <typename LeafTy>\ninline raw_ostream &operator<<(raw_ostream &OS,\n                               const LinearPolySize<LeafTy> &PS) {\n  PS.print(OS);\n  return OS;\n}\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <> struct DenseMapInfo<ElementCount> {\n  static inline ElementCount getEmptyKey() {\n    return ElementCount::getScalable(~0U);\n  }\n  static inline ElementCount getTombstoneKey() {\n    return ElementCount::getFixed(~0U - 1);\n  }\n  static unsigned getHashValue(const ElementCount &EltCnt) {\n    unsigned HashVal = EltCnt.getKnownMinValue() * 37U;\n    if (EltCnt.isScalable())\n      return (HashVal - 1U);\n\n    return HashVal;\n  }\n\n  static bool isEqual(const ElementCount &LHS, const ElementCount &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_TYPESIZE_H\n"}, "70": {"id": 70, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "content": "//===- VersionTuple.h - Version Number Handling -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the llvm::VersionTuple class, which represents a version in\n/// the form major[.minor[.subminor]].\n///\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_SUPPORT_VERSIONTUPLE_H\n#define LLVM_SUPPORT_VERSIONTUPLE_H\n\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/Optional.h\"\n#include <string>\n#include <tuple>\n\nnamespace llvm {\nclass raw_ostream;\nclass StringRef;\n\n/// Represents a version number in the form major[.minor[.subminor[.build]]].\nclass VersionTuple {\n  unsigned Major : 32;\n\n  unsigned Minor : 31;\n  unsigned HasMinor : 1;\n\n  unsigned Subminor : 31;\n  unsigned HasSubminor : 1;\n\n  unsigned Build : 31;\n  unsigned HasBuild : 1;\n\npublic:\n  VersionTuple()\n      : Major(0), Minor(0), HasMinor(false), Subminor(0), HasSubminor(false),\n        Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major)\n      : Major(Major), Minor(0), HasMinor(false), Subminor(0),\n        HasSubminor(false), Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major, unsigned Minor)\n      : Major(Major), Minor(Minor), HasMinor(true), Subminor(0),\n        HasSubminor(false), Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major, unsigned Minor, unsigned Subminor)\n      : Major(Major), Minor(Minor), HasMinor(true), Subminor(Subminor),\n        HasSubminor(true), Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major, unsigned Minor, unsigned Subminor,\n                        unsigned Build)\n      : Major(Major), Minor(Minor), HasMinor(true), Subminor(Subminor),\n        HasSubminor(true), Build(Build), HasBuild(true) {}\n\n  /// Determine whether this version information is empty\n  /// (e.g., all version components are zero).\n  bool empty() const {\n    return Major == 0 && Minor == 0 && Subminor == 0 && Build == 0;\n  }\n\n  /// Retrieve the major version number.\n  unsigned getMajor() const { return Major; }\n\n  /// Retrieve the minor version number, if provided.\n  Optional<unsigned> getMinor() const {\n    if (!HasMinor)\n      return None;\n    return Minor;\n  }\n\n  /// Retrieve the subminor version number, if provided.\n  Optional<unsigned> getSubminor() const {\n    if (!HasSubminor)\n      return None;\n    return Subminor;\n  }\n\n  /// Retrieve the build version number, if provided.\n  Optional<unsigned> getBuild() const {\n    if (!HasBuild)\n      return None;\n    return Build;\n  }\n\n  /// Return a version tuple that contains only the first 3 version components.\n  VersionTuple withoutBuild() const {\n    if (HasBuild)\n      return VersionTuple(Major, Minor, Subminor);\n    return *this;\n  }\n\n  /// Determine if two version numbers are equivalent. If not\n  /// provided, minor and subminor version numbers are considered to be zero.\n  friend bool operator==(const VersionTuple &X, const VersionTuple &Y) {\n    return X.Major == Y.Major && X.Minor == Y.Minor &&\n           X.Subminor == Y.Subminor && X.Build == Y.Build;\n  }\n\n  /// Determine if two version numbers are not equivalent.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator!=(const VersionTuple &X, const VersionTuple &Y) {\n    return !(X == Y);\n  }\n\n  /// Determine whether one version number precedes another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator<(const VersionTuple &X, const VersionTuple &Y) {\n    return std::tie(X.Major, X.Minor, X.Subminor, X.Build) <\n           std::tie(Y.Major, Y.Minor, Y.Subminor, Y.Build);\n  }\n\n  /// Determine whether one version number follows another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator>(const VersionTuple &X, const VersionTuple &Y) {\n    return Y < X;\n  }\n\n  /// Determine whether one version number precedes or is\n  /// equivalent to another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator<=(const VersionTuple &X, const VersionTuple &Y) {\n    return !(Y < X);\n  }\n\n  /// Determine whether one version number follows or is\n  /// equivalent to another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator>=(const VersionTuple &X, const VersionTuple &Y) {\n    return !(X < Y);\n  }\n\n  friend llvm::hash_code hash_value(const VersionTuple &VT) {\n    return llvm::hash_combine(VT.Major, VT.Minor, VT.Subminor, VT.Build);\n  }\n\n  /// Retrieve a string representation of the version number.\n  std::string getAsString() const;\n\n  /// Try to parse the given string as a version number.\n  /// \\returns \\c true if the string does not match the regular expression\n  ///   [0-9]+(\\.[0-9]+){0,3}\n  bool tryParse(StringRef string);\n};\n\n/// Print a version number.\nraw_ostream &operator<<(raw_ostream &Out, const VersionTuple &V);\n\n} // end namespace llvm\n#endif // LLVM_SUPPORT_VERSIONTUPLE_H\n"}, "73": {"id": 73, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/TargetOptions.h", "content": "//===-- llvm/Target/TargetOptions.h - Target Options ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines command line option flags that are shared across various\n// targets.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TARGET_TARGETOPTIONS_H\n#define LLVM_TARGET_TARGETOPTIONS_H\n\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n\n#include <memory>\n\nnamespace llvm {\n  struct fltSemantics;\n  class MachineFunction;\n  class MemoryBuffer;\n\n  namespace FloatABI {\n    enum ABIType {\n      Default, // Target-specific (either soft or hard depending on triple, etc).\n      Soft,    // Soft float.\n      Hard     // Hard float.\n    };\n  }\n\n  namespace FPOpFusion {\n    enum FPOpFusionMode {\n      Fast,     // Enable fusion of FP ops wherever it's profitable.\n      Standard, // Only allow fusion of 'blessed' ops (currently just fmuladd).\n      Strict    // Never fuse FP-ops.\n    };\n  }\n\n  namespace JumpTable {\n    enum JumpTableType {\n      Single,          // Use a single table for all indirect jumptable calls.\n      Arity,           // Use one table per number of function parameters.\n      Simplified,      // Use one table per function type, with types projected\n                       // into 4 types: pointer to non-function, struct,\n                       // primitive, and function pointer.\n      Full             // Use one table per unique function type\n    };\n  }\n\n  namespace ThreadModel {\n    enum Model {\n      POSIX,  // POSIX Threads\n      Single  // Single Threaded Environment\n    };\n  }\n\n  enum class BasicBlockSection {\n    All,    // Use Basic Block Sections for all basic blocks.  A section\n            // for every basic block can significantly bloat object file sizes.\n    List,   // Get list of functions & BBs from a file. Selectively enables\n            // basic block sections for a subset of basic blocks which can be\n            // used to control object size bloats from creating sections.\n    Labels, // Do not use Basic Block Sections but label basic blocks.  This\n            // is useful when associating profile counts from virtual addresses\n            // to basic blocks.\n    Preset, // Similar to list but the blocks are identified by passes which\n            // seek to use Basic Block Sections, e.g. MachineFunctionSplitter.\n            // This option cannot be set via the command line.\n    None    // Do not use Basic Block Sections.\n  };\n\n  enum class StackProtectorGuards {\n    None,\n    TLS,\n    Global\n  };\n\n  enum class EABI {\n    Unknown,\n    Default, // Default means not specified\n    EABI4,   // Target-specific (either 4, 5 or gnu depending on triple).\n    EABI5,\n    GNU\n  };\n\n  /// Identify a debugger for \"tuning\" the debug info.\n  ///\n  /// The \"debugger tuning\" concept allows us to present a more intuitive\n  /// interface that unpacks into different sets of defaults for the various\n  /// individual feature-flag settings, that suit the preferences of the\n  /// various debuggers.  However, it's worth remembering that debuggers are\n  /// not the only consumers of debug info, and some variations in DWARF might\n  /// better be treated as target/platform issues. Fundamentally,\n  /// o if the feature is useful (or not) to a particular debugger, regardless\n  ///   of the target, that's a tuning decision;\n  /// o if the feature is useful (or not) on a particular platform, regardless\n  ///   of the debugger, that's a target decision.\n  /// It's not impossible to see both factors in some specific case.\n  ///\n  /// The \"tuning\" should be used to set defaults for individual feature flags\n  /// in DwarfDebug; if a given feature has a more specific command-line option,\n  /// that option should take precedence over the tuning.\n  enum class DebuggerKind {\n    Default,  // No specific tuning requested.\n    GDB,      // Tune debug info for gdb.\n    LLDB,     // Tune debug info for lldb.\n    SCE       // Tune debug info for SCE targets (e.g. PS4).\n  };\n\n  /// Enable abort calls when global instruction selection fails to lower/select\n  /// an instruction.\n  enum class GlobalISelAbortMode {\n    Disable,        // Disable the abort.\n    Enable,         // Enable the abort.\n    DisableWithDiag // Disable the abort but emit a diagnostic on failure.\n  };\n\n  class TargetOptions {\n  public:\n    TargetOptions()\n        : UnsafeFPMath(false), NoInfsFPMath(false), NoNaNsFPMath(false),\n          NoTrappingFPMath(true), NoSignedZerosFPMath(false),\n          EnableAIXExtendedAltivecABI(false),\n          HonorSignDependentRoundingFPMathOption(false), NoZerosInBSS(false),\n          GuaranteedTailCallOpt(false), StackSymbolOrdering(true),\n          EnableFastISel(false), EnableGlobalISel(false), UseInitArray(false),\n          DisableIntegratedAS(false), RelaxELFRelocations(false),\n          FunctionSections(false), DataSections(false),\n          IgnoreXCOFFVisibility(false), XCOFFTracebackTable(true),\n          UniqueSectionNames(true), UniqueBasicBlockSectionNames(false),\n          TrapUnreachable(false), NoTrapAfterNoreturn(false), TLSSize(0),\n          EmulatedTLS(false), ExplicitEmulatedTLS(false), EnableIPRA(false),\n          EmitStackSizeSection(false), EnableMachineOutliner(false),\n          EnableMachineFunctionSplitter(false), SupportsDefaultOutlining(false),\n          EmitAddrsig(false), EmitCallSiteInfo(false),\n          SupportsDebugEntryValues(false), EnableDebugEntryValues(false),\n          PseudoProbeForProfiling(false), ValueTrackingVariableLocations(false),\n          ForceDwarfFrameSection(false), XRayOmitFunctionIndex(false),\n          FPDenormalMode(DenormalMode::IEEE, DenormalMode::IEEE) {}\n\n    /// DisableFramePointerElim - This returns true if frame pointer elimination\n    /// optimization should be disabled for the given machine function.\n    bool DisableFramePointerElim(const MachineFunction &MF) const;\n\n    /// If greater than 0, override the default value of\n    /// MCAsmInfo::BinutilsVersion.\n    std::pair<int, int> BinutilsVersion{0, 0};\n\n    /// UnsafeFPMath - This flag is enabled when the\n    /// -enable-unsafe-fp-math flag is specified on the command line.  When\n    /// this flag is off (the default), the code generator is not allowed to\n    /// produce results that are \"less precise\" than IEEE allows.  This includes\n    /// use of X86 instructions like FSIN and FCOS instead of libcalls.\n    unsigned UnsafeFPMath : 1;\n\n    /// NoInfsFPMath - This flag is enabled when the\n    /// -enable-no-infs-fp-math flag is specified on the command line. When\n    /// this flag is off (the default), the code generator is not allowed to\n    /// assume the FP arithmetic arguments and results are never +-Infs.\n    unsigned NoInfsFPMath : 1;\n\n    /// NoNaNsFPMath - This flag is enabled when the\n    /// -enable-no-nans-fp-math flag is specified on the command line. When\n    /// this flag is off (the default), the code generator is not allowed to\n    /// assume the FP arithmetic arguments and results are never NaNs.\n    unsigned NoNaNsFPMath : 1;\n\n    /// NoTrappingFPMath - This flag is enabled when the\n    /// -enable-no-trapping-fp-math is specified on the command line. This\n    /// specifies that there are no trap handlers to handle exceptions.\n    unsigned NoTrappingFPMath : 1;\n\n    /// NoSignedZerosFPMath - This flag is enabled when the\n    /// -enable-no-signed-zeros-fp-math is specified on the command line. This\n    /// specifies that optimizations are allowed to treat the sign of a zero\n    /// argument or result as insignificant.\n    unsigned NoSignedZerosFPMath : 1;\n\n    /// EnableAIXExtendedAltivecABI - This flag returns true when -vec-extabi is\n    /// specified. The code generator is then able to use both volatile and\n    /// nonvolitle vector regisers. When false, the code generator only uses\n    /// volatile vector registers which is the default setting on AIX.\n    unsigned EnableAIXExtendedAltivecABI : 1;\n\n    /// HonorSignDependentRoundingFPMath - This returns true when the\n    /// -enable-sign-dependent-rounding-fp-math is specified.  If this returns\n    /// false (the default), the code generator is allowed to assume that the\n    /// rounding behavior is the default (round-to-zero for all floating point\n    /// to integer conversions, and round-to-nearest for all other arithmetic\n    /// truncations).  If this is enabled (set to true), the code generator must\n    /// assume that the rounding mode may dynamically change.\n    unsigned HonorSignDependentRoundingFPMathOption : 1;\n    bool HonorSignDependentRoundingFPMath() const;\n\n    /// NoZerosInBSS - By default some codegens place zero-initialized data to\n    /// .bss section. This flag disables such behaviour (necessary, e.g. for\n    /// crt*.o compiling).\n    unsigned NoZerosInBSS : 1;\n\n    /// GuaranteedTailCallOpt - This flag is enabled when -tailcallopt is\n    /// specified on the commandline. When the flag is on, participating targets\n    /// will perform tail call optimization on all calls which use the fastcc\n    /// calling convention and which satisfy certain target-independent\n    /// criteria (being at the end of a function, having the same return type\n    /// as their parent function, etc.), using an alternate ABI if necessary.\n    unsigned GuaranteedTailCallOpt : 1;\n\n    /// StackAlignmentOverride - Override default stack alignment for target.\n    unsigned StackAlignmentOverride = 0;\n\n    /// StackSymbolOrdering - When true, this will allow CodeGen to order\n    /// the local stack symbols (for code size, code locality, or any other\n    /// heuristics). When false, the local symbols are left in whatever order\n    /// they were generated. Default is true.\n    unsigned StackSymbolOrdering : 1;\n\n    /// EnableFastISel - This flag enables fast-path instruction selection\n    /// which trades away generated code quality in favor of reducing\n    /// compile time.\n    unsigned EnableFastISel : 1;\n\n    /// EnableGlobalISel - This flag enables global instruction selection.\n    unsigned EnableGlobalISel : 1;\n\n    /// EnableGlobalISelAbort - Control abort behaviour when global instruction\n    /// selection fails to lower/select an instruction.\n    GlobalISelAbortMode GlobalISelAbort = GlobalISelAbortMode::Enable;\n\n    /// UseInitArray - Use .init_array instead of .ctors for static\n    /// constructors.\n    unsigned UseInitArray : 1;\n\n    /// Disable the integrated assembler.\n    unsigned DisableIntegratedAS : 1;\n\n    /// Compress DWARF debug sections.\n    DebugCompressionType CompressDebugSections = DebugCompressionType::None;\n\n    unsigned RelaxELFRelocations : 1;\n\n    /// Emit functions into separate sections.\n    unsigned FunctionSections : 1;\n\n    /// Emit data into separate sections.\n    unsigned DataSections : 1;\n\n    /// Do not emit visibility attribute for xcoff.\n    unsigned IgnoreXCOFFVisibility : 1;\n\n    /// Emit XCOFF traceback table.\n    unsigned XCOFFTracebackTable : 1;\n\n    unsigned UniqueSectionNames : 1;\n\n    /// Use unique names for basic block sections.\n    unsigned UniqueBasicBlockSectionNames : 1;\n\n    /// Emit target-specific trap instruction for 'unreachable' IR instructions.\n    unsigned TrapUnreachable : 1;\n\n    /// Do not emit a trap instruction for 'unreachable' IR instructions behind\n    /// noreturn calls, even if TrapUnreachable is true.\n    unsigned NoTrapAfterNoreturn : 1;\n\n    /// Bit size of immediate TLS offsets (0 == use the default).\n    unsigned TLSSize : 8;\n\n    /// EmulatedTLS - This flag enables emulated TLS model, using emutls\n    /// function in the runtime library..\n    unsigned EmulatedTLS : 1;\n\n    /// Whether -emulated-tls or -no-emulated-tls is set.\n    unsigned ExplicitEmulatedTLS : 1;\n\n    /// This flag enables InterProcedural Register Allocation (IPRA).\n    unsigned EnableIPRA : 1;\n\n    /// Emit section containing metadata on function stack sizes.\n    unsigned EmitStackSizeSection : 1;\n\n    /// Enables the MachineOutliner pass.\n    unsigned EnableMachineOutliner : 1;\n\n    /// Enables the MachineFunctionSplitter pass.\n    unsigned EnableMachineFunctionSplitter : 1;\n\n    /// Set if the target supports default outlining behaviour.\n    unsigned SupportsDefaultOutlining : 1;\n\n    /// Emit address-significance table.\n    unsigned EmitAddrsig : 1;\n\n    /// Emit basic blocks into separate sections.\n    BasicBlockSection BBSections = BasicBlockSection::None;\n\n    /// Memory Buffer that contains information on sampled basic blocks and used\n    /// to selectively generate basic block sections.\n    std::shared_ptr<MemoryBuffer> BBSectionsFuncListBuf;\n\n    /// The flag enables call site info production. It is used only for debug\n    /// info, and it is restricted only to optimized code. This can be used for\n    /// something else, so that should be controlled in the frontend.\n    unsigned EmitCallSiteInfo : 1;\n    /// Set if the target supports the debug entry values by default.\n    unsigned SupportsDebugEntryValues : 1;\n    /// When set to true, the EnableDebugEntryValues option forces production\n    /// of debug entry values even if the target does not officially support\n    /// it. Useful for testing purposes only. This flag should never be checked\n    /// directly, always use \\ref ShouldEmitDebugEntryValues instead.\n     unsigned EnableDebugEntryValues : 1;\n    /// NOTE: There are targets that still do not support the debug entry values\n    /// production.\n    bool ShouldEmitDebugEntryValues() const;\n\n    /// Emit pseudo probes into the binary for sample profiling\n    unsigned PseudoProbeForProfiling : 1;\n\n    // When set to true, use experimental new debug variable location tracking,\n    // which seeks to follow the values of variables rather than their location,\n    // post isel.\n    unsigned ValueTrackingVariableLocations : 1;\n\n    /// Emit DWARF debug frame section.\n    unsigned ForceDwarfFrameSection : 1;\n\n    /// Emit XRay Function Index section\n    unsigned XRayOmitFunctionIndex : 1;\n\n    /// Stack protector guard offset to use.\n    unsigned StackProtectorGuardOffset : 32;\n\n    /// Stack protector guard mode to use, e.g. tls, global.\n    StackProtectorGuards StackProtectorGuard =\n                                         StackProtectorGuards::None;\n\n    /// Stack protector guard reg to use, e.g. usually fs or gs in X86.\n    std::string StackProtectorGuardReg = \"None\";\n\n    /// FloatABIType - This setting is set by -float-abi=xxx option is specfied\n    /// on the command line. This setting may either be Default, Soft, or Hard.\n    /// Default selects the target's default behavior. Soft selects the ABI for\n    /// software floating point, but does not indicate that FP hardware may not\n    /// be used. Such a combination is unfortunately popular (e.g.\n    /// arm-apple-darwin). Hard presumes that the normal FP ABI is used.\n    FloatABI::ABIType FloatABIType = FloatABI::Default;\n\n    /// AllowFPOpFusion - This flag is set by the -fuse-fp-ops=xxx option.\n    /// This controls the creation of fused FP ops that store intermediate\n    /// results in higher precision than IEEE allows (E.g. FMAs).\n    ///\n    /// Fast mode - allows formation of fused FP ops whenever they're\n    /// profitable.\n    /// Standard mode - allow fusion only for 'blessed' FP ops. At present the\n    /// only blessed op is the fmuladd intrinsic. In the future more blessed ops\n    /// may be added.\n    /// Strict mode - allow fusion only if/when it can be proven that the excess\n    /// precision won't effect the result.\n    ///\n    /// Note: This option only controls formation of fused ops by the\n    /// optimizers.  Fused operations that are explicitly specified (e.g. FMA\n    /// via the llvm.fma.* intrinsic) will always be honored, regardless of\n    /// the value of this option.\n    FPOpFusion::FPOpFusionMode AllowFPOpFusion = FPOpFusion::Standard;\n\n    /// ThreadModel - This flag specifies the type of threading model to assume\n    /// for things like atomics\n    ThreadModel::Model ThreadModel = ThreadModel::POSIX;\n\n    /// EABIVersion - This flag specifies the EABI version\n    EABI EABIVersion = EABI::Default;\n\n    /// Which debugger to tune for.\n    DebuggerKind DebuggerTuning = DebuggerKind::Default;\n\n  private:\n    /// Flushing mode to assume in default FP environment.\n    DenormalMode FPDenormalMode;\n\n    /// Flushing mode to assume in default FP environment, for float/vector of\n    /// float.\n    DenormalMode FP32DenormalMode;\n\n  public:\n    void setFPDenormalMode(DenormalMode Mode) {\n      FPDenormalMode = Mode;\n    }\n\n    void setFP32DenormalMode(DenormalMode Mode) {\n      FP32DenormalMode = Mode;\n    }\n\n    DenormalMode getRawFPDenormalMode() const {\n      return FPDenormalMode;\n    }\n\n    DenormalMode getRawFP32DenormalMode() const {\n      return FP32DenormalMode;\n    }\n\n    DenormalMode getDenormalMode(const fltSemantics &FPType) const;\n\n    /// What exception model to use\n    ExceptionHandling ExceptionModel = ExceptionHandling::None;\n\n    /// Machine level options.\n    MCTargetOptions MCOptions;\n  };\n\n} // End llvm namespace\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 48}, "message": "default constructor 'TypeInfoLValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "1953a872dae34228e5e3d0f07cefc333", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 69}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 69}, "message": "default constructor 'DynamicAllocLValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "53f176fea5677af93a9152600264d239", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 152}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 0, "line": 152}, "message": "default constructor 'LValueBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "933c23f316af5855f6684a4686d1bd82", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 214}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 0, "line": 214}, "message": "default constructor 'LValuePathEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "be8fe4fc465bf3708871fc5480faa746", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 262}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 0, "line": 262}, "message": "default constructor 'ComplexAPSInt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "bbf27d9411c86d8808730e4dfdf700ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 266}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 0, "line": 266}, "message": "default constructor 'ComplexAPFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "f9581000f2e813f093327c001709d11b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 272}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 0, "line": 272}, "message": "default constructor 'Vec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "be44b0d73bd3c613fac14c15ea686314", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 291}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 0, "line": 291}, "message": "default constructor 'UnionData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "a5e927b3e36adef027ff6f5f5a99c467", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 309}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 309}, "message": "default constructor 'APValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "e384c8c6ac72c01fdbf2914d01cfd104", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 329}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 329}, "message": "move constructor 'APValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "627e4aeb132306146d036dbdacb7884a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 0, "line": 365}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 0, "line": 365}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "24776dcaf2b50ebbba31e5879799a7bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 380}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 0, "line": 380}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "7db3895896516284bd78dcc5f42123a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 1, "line": 135}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 1, "line": 135}, "message": "default constructor 'ConceptReference' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTConcept.h", "reportHash": "0d889c7d8f26b16538e3a77336ec4705", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 2, "line": 170}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 2, "line": 170}, "message": "default constructor 'TypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "reportHash": "a57ad28145e5f059dd48a3c697c3ced1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 2, "line": 180}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 2, "line": 180}, "message": "default constructor 'TypeInfoChars' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "reportHash": "004fdfc77ad9ce4652818e8c9941116d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 2, "line": 2981}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 2, "line": 2981}, "message": "default constructor 'ObjCEncOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "reportHash": "a10c0eff7b6599457c104a5508baab32", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 52}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 52}, "message": "default constructor 'ASTVector<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTVector.h", "reportHash": "074d20b860cd7cbde672fd7ee6c6f18c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 54}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 54}, "message": "move constructor 'ASTVector<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTVector.h", "reportHash": "e3dd11bd3dc4f60cf00f72e80c37f3ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 3, "line": 64}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 3, "line": 64}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTVector.h", "reportHash": "2d2a4d4a013ce1a1f2f5453e7e2b83b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 75}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 75}, "message": "destructor '~ASTVector<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTVector.h", "reportHash": "4fbd452efd2653cc38216039790f3df4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 4, "line": 63}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 4, "line": 63}, "message": "default constructor 'specific_attr_iterator<SpecificAttr, Container>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/AttrIterator.h", "reportHash": "ecd348dee3e663b564ea3dcfddcd29cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 5, "line": 71}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 5, "line": 71}, "message": "default constructor 'CanQual<type-parameter-0-0>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "reportHash": "b3d594aaa810f363d0f8295eed81154f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 5, "line": 352}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 5, "line": 352}, "message": "default constructor 'CanProxy<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "reportHash": "df49308ba238b804c7c255ad75136cd6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 5, "line": 410}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 5, "line": 410}, "message": "default constructor 'CanTypeIterator<InputIterator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "reportHash": "faa4ddad529259e47459defed62237a0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 6, "line": 827}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 6, "line": 827}, "message": "default constructor 'EvaluatedStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "f2647d7a93c9d2488c10ff9a42fa56dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 7, "line": 373}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 7, "line": 373}, "message": "default constructor 'Decl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "702dea3ef18cffac25773ddf9ff99cc2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 7, "line": 375}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 7, "line": 375}, "message": "move constructor 'Decl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "0e62e81b3bd3be1841c861e015b87512", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 377}, "message": "mark 'noexcept'"}, {"location": {"col": 9, "file": 7, "line": 377}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "c4eb627de5db65c8f3ec802f5dccc194", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 7, "line": 2108}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 7, "line": 2108}, "message": "default constructor 'specific_decl_iterator<SpecificDecl>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "314910ebc5114d07814abd788396e34f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 7, "line": 2186}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 7, "line": 2186}, "message": "default constructor 'filtered_decl_iterator<SpecificDecl, Acceptable>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "c255916ec66bff5a5ac30f286ed6938a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 8, "line": 1215}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 8, "line": 1215}, "message": "default constructor 'DefinitionData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "494907e72610e054360349c4e719826a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 8, "line": 1588}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 8, "line": 1588}, "message": "default constructor 'filtered_category_iterator<Filter>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "72fc5a56ad91f6acceb7a305f4845474", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 336}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 9, "line": 336}, "message": "default constructor 'DefaultArgStorage<ParmDecl, ArgType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "380d05fd8aff375edb2226c56ff6896f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 9, "line": 817}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 9, "line": 817}, "message": "default constructor 'CommonBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "08a095fa522cd44ed5a0c5e5e90fe5df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 1153}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 9, "line": 1153}, "message": "default constructor 'TemplateParmPosition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "01a7c5d5963e32352801291920633c22", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 10, "line": 348}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 10, "line": 348}, "message": "default constructor 'DeclarationName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "b2501b7ffd511ae6bbd79eb8f5d4fba7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 10, "line": 608}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 10, "line": 608}, "message": "move constructor 'DeclarationNameTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "9b78468acc9070cf1690efb12b24daea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 10, "line": 609}, "message": "mark 'noexcept'"}, {"location": {"col": 25, "file": 10, "line": 609}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "98a512dd59935b74211fe55df3d281a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 10, "line": 696}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 10, "line": 696}, "message": "default constructor 'DeclarationNameLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "d65cf800c569ca896c5bd82eb932d102", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 10, "line": 771}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 10, "line": 771}, "message": "default constructor 'DeclarationNameInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "3b2285f80f3cf901d96181872a191cc5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 11, "line": 137}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 11, "line": 137}, "message": "default constructor 'Dependence' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DependenceFlags.h", "reportHash": "3f5a4a69bc38e107b8ec18cd7b0d862f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 12, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 12, "line": 113}, "message": "default constructor 'Expr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "febdaf6c01bcc793b7a4f13ac3f5837d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 12, "line": 115}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 12, "line": 115}, "message": "move constructor 'Expr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "a8353572462028feb01f6e19780929c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 117}, "message": "mark 'noexcept'"}, {"location": {"col": 9, "file": 12, "line": 117}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "62bcf99c24ff771f35efdae2088a7b09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 12, "line": 368}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 12, "line": 368}, "message": "default constructor 'Classification' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "83b86912be8826ef9554bbd088c55378", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 12, "line": 597}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 12, "line": 597}, "message": "default constructor 'EvalStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "4bfcbc7869f6c1a0aafea4f9b8248d94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 12, "line": 1454}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 12, "line": 1454}, "message": "default constructor 'APNumericStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "a4749c5a34407b111c813ad3447aa9cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 12, "line": 5040}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 12, "line": 5040}, "message": "default constructor 'Designator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "648245401c205439259a38d5d71fef3a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 12, "line": 5648}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 12, "line": 5648}, "message": "default constructor 'AssociationIteratorTy<Const>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "e2785f976dd3599c71a2c8844e238288", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 13, "line": 334}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 13, "line": 334}, "message": "default constructor 'LazyOffsetPtr<T, OffsT, Get>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExternalASTSource.h", "reportHash": "1065923d61897607901cc6f33bc9c0f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 13, "line": 529}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 13, "line": 529}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExternalASTSource.h", "reportHash": "b57452af294eb803a0b21d962e7168ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 14, "line": 106}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 14, "line": 106}, "message": "default constructor 'NestedNameSpecifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h", "reportHash": "31c3ff957ae41f5de1a6ef6a372f884b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 15, "line": 45}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 15, "line": 45}, "message": "default constructor 'RawComment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/RawCommentList.h", "reportHash": "9ff539fdf765a51d906fbf17fe5a2403", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 16, "line": 252}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 16, "line": 252}, "message": "default constructor 'redecl_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "reportHash": "0ff2ebc3f67a554ae39bbbc7097ed81c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 314}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 314}, "message": "default constructor 'Mergeable<decl_type>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "reportHash": "5c3bd5f60253be5c3d87052372b7b8a5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 349}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 349}, "message": "default constructor 'CanonicalDeclPtr<decl_type>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "reportHash": "6cef5d9bc40a2644d8a5dcd906d9063a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 17, "line": 1123}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 17, "line": 1123}, "message": "default constructor 'CastIterator<T, TPtr, StmtPtr>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "75fa044d853dab27feab94fa4166b180", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 17, "line": 1147}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 17, "line": 1147}, "message": "default constructor 'Stmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "63043835132556476294a5dffb666c8f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 17, "line": 1149}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 17, "line": 1149}, "message": "move constructor 'Stmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "c09339c4532b5c86fe5f8c9ba4f19cf0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1151}, "message": "mark 'noexcept'"}, {"location": {"col": 9, "file": 17, "line": 1151}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "abb2f626df40d715b4bce4485f379a2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 18, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 18, "line": 46}, "message": "default constructor 'StmtIteratorBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "739fd28465bdcc4ca2adbf9ebff47704", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 18, "line": 85}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 18, "line": 85}, "message": "default constructor 'StmtIteratorImpl<DERIVED, REFERENCE>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "a28261806fa134af6a05916784f62ebb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 19, "line": 152}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 19, "line": 152}, "message": "default constructor 'TemplateArgument' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "c59f458f1804a6d75f5ca62d628e0b44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 424}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 424}, "message": "default constructor 'TemplateArgumentLocInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "b88d1821efdd4ab4c2ba0ef40c3731c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 462}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 462}, "message": "default constructor 'TemplateArgumentLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "2585f13253808dcc7ae8c99131950b8a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 20, "line": 1842}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 20, "line": 1842}, "message": "move constructor 'Type' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "a647e4499fbd07cc707c7cdc649e2c53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 1844}, "message": "mark 'noexcept'"}, {"location": {"col": 9, "file": 20, "line": 1844}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "9e26db375688afddaab2fd9b52d3b093", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 20, "line": 3973}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 20, "line": 3973}, "message": "default constructor 'ExtProtoInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "1fc1290db8e0f7e4f6459013715878b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 20, "line": 5683}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 20, "line": 5683}, "message": "default constructor 'ObjCProtocolQualifiers<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "e7aeb3b15758196112d1e026fe8f2a4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 20, "line": 6362}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 20, "line": 6362}, "message": "default constructor 'QualifierCollector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "07f72e014610c852506d53dc3dd93a1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 21, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 21, "line": 48}, "message": "default constructor 'UnresolvedSetIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/UnresolvedSet.h", "reportHash": "02405d7aff2c37e9302ef277264405d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 21, "line": 74}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 21, "line": 74}, "message": "move constructor 'UnresolvedSetImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/UnresolvedSet.h", "reportHash": "b37ae1bb2d905be35bb4947e49ffb3fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 21, "line": 75}, "message": "mark 'noexcept'"}, {"location": {"col": 22, "file": 21, "line": 75}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/UnresolvedSet.h", "reportHash": "abda577da5b7d216ff582ed29bd79c05", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 317}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 317}, "message": "default constructor 'CFGScopeBegin' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "599d50e8620656a759415656580aac15", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 343}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 343}, "message": "default constructor 'CFGScopeEnd' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "0b525a0b53544cafb159bc6362230425", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 531}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 531}, "message": "default constructor 'CFGTerminator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "3697c99c155cb355de61c3b35168de69", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 22, "line": 985}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 22, "line": 985}, "message": "default constructor 'FilterOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "84dc1c578a18374e0f74a4ad080fc934", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 1432}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 1432}, "message": "default constructor 'CFG' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "b89a9ee011863e3aeb8e063c65879e89", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 23, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 23, "line": 37}, "message": "default constructor 'CodeInjector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CodeInjector.h", "reportHash": "07bbb9e10a9fadc07155fe625d008912", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 41}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 41}, "message": "default constructor 'ProgramPointTag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "546563a4e5b1cd74c68b31fbea7ff138", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 25, "line": 38}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 25, "line": 38}, "message": "default constructor 'BumpVectorContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h", "reportHash": "3ab230416528cb24b14478e37d25113f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 25, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 25, "line": 40}, "message": "move constructor 'BumpVectorContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h", "reportHash": "36fa38000849b6c2e86568268cf07d1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 25, "line": 70}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 25, "line": 70}, "message": "destructor '~BumpVector<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h", "reportHash": "d17bf9d7383d41f249d7c5b7a2188e88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 26, "line": 307}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 26, "line": 307}, "message": "default constructor 'OptRemark' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "reportHash": "6e7b54b5e683dcf9e5f4bd2577ca865f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 26, "line": 416}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 26, "line": 416}, "message": "default constructor 'CodeGenOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "reportHash": "c2d04aa6d98ad65e4f2096ee83663b9c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 27, "line": 333}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 27, "line": 333}, "message": "default constructor 'DiagState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "reportHash": "953a3590f888f27df5d8d55758d8e0b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 27, "line": 1116}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 27, "line": 1116}, "message": "default constructor 'DiagStorageAllocator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "reportHash": "1aac06e11583f18932e20c8e21430574", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 28, "line": 71}, "message": "'clang/Basic/DiagnosticCommonKinds.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "reportHash": "0212dcde1e4a793396a6f1f45b22be74", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 3, "file": 28, "line": 176}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 28, "line": 176}, "message": "default constructor 'DiagnosticIDs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "reportHash": "e3a987bfd1b670157e63a080d0c1ec14", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 133}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 133}, "message": "default constructor 'DiagnosticOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticOptions.h", "reportHash": "f7b267e430fcfa708aca28c6c7730037", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 30, "line": 123}, "message": "default constructor 'IdentifierInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "4d7f6b80afe566debcb2da450bfa6187", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 134}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 30, "line": 134}, "message": "move constructor 'IdentifierInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "bda340849323e4b7ccfd656e4c049cdb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 30, "line": 135}, "message": "mark 'noexcept'"}, {"location": {"col": 19, "file": 30, "line": 135}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "2fbed1db1475aa9addbfd2b5fb82e5cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 505}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 30, "line": 505}, "message": "default constructor 'IdentifierTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "5d7d91e69f27c0feab6acff7dcffb6b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 834}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 30, "line": 834}, "message": "default constructor 'SelectorTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "fef923f761090230fb30fd14dddcc49f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 344}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 344}, "message": "default constructor 'LangOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "5d7c5108d54bec9b8d8a731acfc5b3b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 460}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 460}, "message": "default constructor 'FPOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "cd2cb2589f4761d3cd46791349b6ee91", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 568}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 568}, "message": "default constructor 'FPOptionsOverride' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "ae6bb22183d5fbfd63b00bab4e36f048", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 32, "line": 78}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 32, "line": 78}, "message": "move constructor 'PartialDiagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "reportHash": "06cc3a63d106d06dc37ef3ba0f1a915a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 32, "line": 127}, "message": "mark 'noexcept'"}, {"location": {"col": 22, "file": 32, "line": 127}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "reportHash": "89ffdebef7065bd15889a9bd2f555477", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 32, "line": 138}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 32, "line": 138}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "reportHash": "fce83595f57affab4d45a9bcdc20b9f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 107}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 107}, "message": "default constructor 'AtomicScopeOpenCLModel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SyncScope.h", "reportHash": "d9f4782a40cc7c4c06aaf04738d657b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 34, "line": 59}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 34, "line": 59}, "message": "default constructor 'LinkageInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Visibility.h", "reportHash": "6da9aaa7e2fea4e53039a0da51c0d2d7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 21}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 21}, "message": "default constructor 'DynamicTypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h", "reportHash": "69319e68167fcb769caa94ebfd89819e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 36, "line": 213}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 36, "line": 213}, "message": "default constructor 'UndefinedVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "d04ce372b92aae0f45b3d9076b7ffa9a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 36, "line": 246}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 36, "line": 246}, "message": "default constructor 'UnknownVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "0797316f56237e640274bb41060f14c6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 36, "line": 345}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 36, "line": 345}, "message": "default constructor 'SymbolVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "8a276be44acbd6b224f775c3d4aed9f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 100}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 37, "line": 100}, "message": "move constructor 'APFixedPoint' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "d6cebcb1886ca1152bf40f79c5e23d94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 38, "line": 259}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 38, "line": 259}, "message": "move constructor 'IEEEFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "70dfe4159a16dd05aaff41fb1e0710c6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 38, "line": 396}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 38, "line": 396}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "b938e63d91455ca43d0e57a20db57365", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 38, "line": 620}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 38, "line": 620}, "message": "move constructor 'DoubleAPFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "d7bd6f621c36f5d782ee6250fb42b059", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 38, "line": 624}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 38, "line": 624}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "bd4fe1e366be808be386732b91c968bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 38, "line": 755}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 38, "line": 755}, "message": "move constructor 'Storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "5c63af22232dcf81caaa2cc3a5dc0feb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 38, "line": 781}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 38, "line": 781}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "b7c3ef47f982efe26b933d9760aaf583", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 38, "line": 844}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 38, "line": 844}, "message": "default constructor 'APFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "ef4a9f970a5cfc4a158346fda68021da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 43, "line": 67}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 43, "line": 67}, "message": "default constructor 'DenseSetImpl<ValueT, MapTy, ValueInfoT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "4415fae964930ba2eddfc6e04dcab1cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 43, "line": 105}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 43, "line": 105}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "562bdda290611fe2f7a1b10d66c19bc2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 43, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 43, "line": 123}, "message": "default constructor 'Iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "0c383324ec4d0d810cb837126a86d2a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 43, "line": 153}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 43, "line": 153}, "message": "default constructor 'ConstIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "833dfeda8ab83be2f89f03b138cfd5b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 44, "line": 124}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 44, "line": 124}, "message": "default constructor 'FoldingSetBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "e6d6b6a95217c0fce186f171bcdac943", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 125}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 125}, "message": "move constructor 'FoldingSetBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "c373dce0ac83ddfb6e144cadc3637eb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 44, "line": 126}, "message": "mark 'noexcept'"}, {"location": {"col": 19, "file": 44, "line": 126}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "1bd2d025401559a78d82066a5434c6f2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 413}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 413}, "message": "move constructor 'FoldingSetImpl<Derived, T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "e8676bd1d82f493885b1492454517ad0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 44, "line": 414}, "message": "mark 'noexcept'"}, {"location": {"col": 19, "file": 44, "line": 414}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "a8c954042220bb4b969f9ef7af115853", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 415}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 415}, "message": "destructor '~FoldingSetImpl<Derived, T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "6deb1ea717232e3b2d36d2667c10f5fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 44, "line": 530}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 44, "line": 530}, "message": "default constructor 'FoldingSet<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "d9903e2b3fec243819db0cb1fc7a47cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 531}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 531}, "message": "move constructor 'FoldingSet<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "1eca738a75bf55dfe190f8ce530caaa2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 44, "line": 532}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 44, "line": 532}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "200b37a418526a6a6b695fc4fa7c353b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 44, "line": 609}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 44, "line": 609}, "message": "default constructor 'FoldingSetVector<T, VectorT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "a3091f938b702e4404ddf4c14da7e075", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 44, "line": 760}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 44, "line": 760}, "message": "default constructor 'FoldingSetNodeWrapper<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "3e5c9178914583fe6322d342fe0e6881", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 79}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 79}, "message": "default constructor 'ImmutableList<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "reportHash": "fd6df51f24eb233c7049a55423fdcd0e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 46, "line": 89}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 46, "line": 89}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "reportHash": "9005ff7186831b6892d439482a0b7072", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 165}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 165}, "message": "default constructor 'ImmutableListFactory<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "reportHash": "b936468970a55a07afc7c41ceefee3c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 171}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 171}, "message": "destructor '~ImmutableListFactory<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "reportHash": "839260df011a91ff27003ff0a4bd2053", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 87}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 47, "line": 87}, "message": "default constructor 'Factory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "reportHash": "781c200eceed95fb31d637e9453026a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 194}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 47, "line": 194}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "reportHash": "7aa0cffa15999333db0580d5b537f31f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 324}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 47, "line": 324}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "reportHash": "7aa0cffa15999333db0580d5b537f31f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 48, "line": 398}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 48, "line": 398}, "message": "default constructor 'ImutAVLFactory<ImutInfo>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "d927ac06ee22350c346beb5d435ee3f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 48, "line": 404}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 48, "line": 404}, "message": "destructor '~ImutAVLFactory<ImutInfo>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "2248e0a41340bce0a5da7f94a9c2c736", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 48, "line": 666}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 48, "line": 666}, "message": "default constructor 'ImutAVLTreeGenericIterator<ImutInfo>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "ae1c7553e47e86f1b12a6ffe54263dea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 48, "line": 781}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 48, "line": 781}, "message": "default constructor 'ImutAVLTreeInOrderIterator<ImutInfo>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "7de932b46bea38fad93ef77158c7bb58", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 48, "line": 828}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 48, "line": 828}, "message": "default constructor 'ImutAVLValueIterator<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "40c8b2374366095dede9491376158a7f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 48, "line": 985}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 48, "line": 985}, "message": "default constructor 'Factory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "59fb396b82fc0f3951eab28b3fe07583", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 93}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 50, "line": 93}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/MapVector.h", "reportHash": "736aa5ae7d87593347dc1ed0553fa003", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 53, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 53, "line": 103}, "message": "default constructor 'PointerUnionMembers<type-parameter-0-0, type-parameter-0-1, I>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "8f91314ea4857b3e9f774f52e3d80108", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 53, "line": 116}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 53, "line": 116}, "message": "default constructor 'PointerUnionMembers<type-parameter-0-0, type-parameter-0-1, I, type-parameter-0-3, type-parameter-0-4...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "8c78606a36ed5743f5233bb39a85484d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 165}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 165}, "message": "default constructor 'PointerUnion<PTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "34f87da3ff18bfe6abab766385048532", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 44}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 44}, "message": "default constructor 'TinyPtrVector<EltTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "reportHash": "3252212ef86cbac24236a3bbcd76ffae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 46}, "message": "destructor '~TinyPtrVector<EltTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "reportHash": "35f856163014aef4e830adcbca5f0182", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 84}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 84}, "message": "move constructor 'TinyPtrVector<EltTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "reportHash": "d28b0655fff722fa64f158547b181a97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 59, "line": 88}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 59, "line": 88}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "reportHash": "7401c6ec3f2d6c74bb9ae723b001db12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 63, "line": 72}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 63, "line": 72}, "message": "default constructor 'MCTargetOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h", "reportHash": "ca8adf1f6b6bfc3d46c00b8885f4b67d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 67, "line": 26}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 67, "line": 26}, "message": "destructor '~SaveAndRestore<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SaveAndRestore.h", "reportHash": "cd71244a0fbfdd3a89ebd7e5ac72f66f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 68, "line": 331}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 68, "line": 331}, "message": "default constructor 'TrailingObjects<BaseTy, TrailingTys...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "f64db46aa60e292e8e24af8a58e21447", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 68, "line": 333}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 68, "line": 333}, "message": "move constructor 'TrailingObjects<BaseTy, TrailingTys...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "b82ac7be41a6a9fc2a4dfe1c5021e63a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 68, "line": 335}, "message": "mark 'noexcept'"}, {"location": {"col": 20, "file": 68, "line": 335}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "8f41a7f61aa1b04aaf1eaacb0ab63d42", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 68, "line": 365}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 68, "line": 365}, "message": "destructor '~FixedSizeStorageOwner' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "fa9b741072eb7c87e296b298f22223fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 68, "line": 375}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 68, "line": 375}, "message": "move constructor 'FixedSizeStorageOwner' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "fcac3a5e1e42ab38445a99ffe5dcf1cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 68, "line": 377}, "message": "mark 'noexcept'"}, {"location": {"col": 28, "file": 68, "line": 377}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "4fb080e5a01c5a16ca50efc0f2aadad2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 69, "line": 136}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 69, "line": 136}, "message": "default constructor 'StackOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "32e5c286f4ebf7fe4558273c71a457f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 69, "line": 384}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 69, "line": 384}, "message": "default constructor 'ElementCount' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "ecbb8effc5e2adda73ae21e9836b0556", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 70, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 70, "line": 40}, "message": "default constructor 'VersionTuple' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "reportHash": "622780de0b37ebd2432e90ca097a4fc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 73, "line": 124}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 73, "line": 124}, "message": "default constructor 'TargetOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/TargetOptions.h", "reportHash": "5bfa4781d19f731775c1fc59367f5dfe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
