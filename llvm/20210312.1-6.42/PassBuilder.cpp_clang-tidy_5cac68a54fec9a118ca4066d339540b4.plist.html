<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "content": "//===- llvm/ADT/DirectedGraph.h - Directed Graph ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the interface and a base class implementation for a\n// directed graph.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DIRECTEDGRAPH_H\n#define LLVM_ADT_DIRECTEDGRAPH_H\n\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\n/// Represent an edge in the directed graph.\n/// The edge contains the target node it connects to.\ntemplate <class NodeType, class EdgeType> class DGEdge {\npublic:\n  DGEdge() = delete;\n  /// Create an edge pointing to the given node \\p N.\n  explicit DGEdge(NodeType &N) : TargetNode(N) {}\n  explicit DGEdge(const DGEdge<NodeType, EdgeType> &E)\n      : TargetNode(E.TargetNode) {}\n  DGEdge<NodeType, EdgeType> &operator=(const DGEdge<NodeType, EdgeType> &E) {\n    TargetNode = E.TargetNode;\n    return *this;\n  }\n\n  /// Static polymorphism: delegate implementation (via isEqualTo) to the\n  /// derived class.\n  bool operator==(const DGEdge &E) const {\n    return getDerived().isEqualTo(E.getDerived());\n  }\n  bool operator!=(const DGEdge &E) const { return !operator==(E); }\n\n  /// Retrieve the target node this edge connects to.\n  const NodeType &getTargetNode() const { return TargetNode; }\n  NodeType &getTargetNode() {\n    return const_cast<NodeType &>(\n        static_cast<const DGEdge<NodeType, EdgeType> &>(*this).getTargetNode());\n  }\n\n  /// Set the target node this edge connects to.\n  void setTargetNode(const NodeType &N) { TargetNode = N; }\n\nprotected:\n  // As the default implementation use address comparison for equality.\n  bool isEqualTo(const EdgeType &E) const { return this == &E; }\n\n  // Cast the 'this' pointer to the derived type and return a reference.\n  EdgeType &getDerived() { return *static_cast<EdgeType *>(this); }\n  const EdgeType &getDerived() const {\n    return *static_cast<const EdgeType *>(this);\n  }\n\n  // The target node this edge connects to.\n  NodeType &TargetNode;\n};\n\n/// Represent a node in the directed graph.\n/// The node has a (possibly empty) list of outgoing edges.\ntemplate <class NodeType, class EdgeType> class DGNode {\npublic:\n  using EdgeListTy = SetVector<EdgeType *>;\n  using iterator = typename EdgeListTy::iterator;\n  using const_iterator = typename EdgeListTy::const_iterator;\n\n  /// Create a node with a single outgoing edge \\p E.\n  explicit DGNode(EdgeType &E) : Edges() { Edges.insert(&E); }\n  DGNode() = default;\n\n  explicit DGNode(const DGNode<NodeType, EdgeType> &N) : Edges(N.Edges) {}\n  DGNode(DGNode<NodeType, EdgeType> &&N) : Edges(std::move(N.Edges)) {}\n\n  DGNode<NodeType, EdgeType> &operator=(const DGNode<NodeType, EdgeType> &N) {\n    Edges = N.Edges;\n    return *this;\n  }\n  DGNode<NodeType, EdgeType> &operator=(const DGNode<NodeType, EdgeType> &&N) {\n    Edges = std::move(N.Edges);\n    return *this;\n  }\n\n  /// Static polymorphism: delegate implementation (via isEqualTo) to the\n  /// derived class.\n  friend bool operator==(const NodeType &M, const NodeType &N) {\n    return M.isEqualTo(N);\n  }\n  friend bool operator!=(const NodeType &M, const NodeType &N) {\n    return !(M == N);\n  }\n\n  const_iterator begin() const { return Edges.begin(); }\n  const_iterator end() const { return Edges.end(); }\n  iterator begin() { return Edges.begin(); }\n  iterator end() { return Edges.end(); }\n  const EdgeType &front() const { return *Edges.front(); }\n  EdgeType &front() { return *Edges.front(); }\n  const EdgeType &back() const { return *Edges.back(); }\n  EdgeType &back() { return *Edges.back(); }\n\n  /// Collect in \\p EL, all the edges from this node to \\p N.\n  /// Return true if at least one edge was found, and false otherwise.\n  /// Note that this implementation allows more than one edge to connect\n  /// a given pair of nodes.\n  bool findEdgesTo(const NodeType &N, SmallVectorImpl<EdgeType *> &EL) const {\n    assert(EL.empty() && \"Expected the list of edges to be empty.\");\n    for (auto *E : Edges)\n      if (E->getTargetNode() == N)\n        EL.push_back(E);\n    return !EL.empty();\n  }\n\n  /// Add the given edge \\p E to this node, if it doesn't exist already. Returns\n  /// true if the edge is added and false otherwise.\n  bool addEdge(EdgeType &E) { return Edges.insert(&E); }\n\n  /// Remove the given edge \\p E from this node, if it exists.\n  void removeEdge(EdgeType &E) { Edges.remove(&E); }\n\n  /// Test whether there is an edge that goes from this node to \\p N.\n  bool hasEdgeTo(const NodeType &N) const {\n    return (findEdgeTo(N) != Edges.end());\n  }\n\n  /// Retrieve the outgoing edges for the node.\n  const EdgeListTy &getEdges() const { return Edges; }\n  EdgeListTy &getEdges() {\n    return const_cast<EdgeListTy &>(\n        static_cast<const DGNode<NodeType, EdgeType> &>(*this).Edges);\n  }\n\n  /// Clear the outgoing edges.\n  void clear() { Edges.clear(); }\n\nprotected:\n  // As the default implementation use address comparison for equality.\n  bool isEqualTo(const NodeType &N) const { return this == &N; }\n\n  // Cast the 'this' pointer to the derived type and return a reference.\n  NodeType &getDerived() { return *static_cast<NodeType *>(this); }\n  const NodeType &getDerived() const {\n    return *static_cast<const NodeType *>(this);\n  }\n\n  /// Find an edge to \\p N. If more than one edge exists, this will return\n  /// the first one in the list of edges.\n  const_iterator findEdgeTo(const NodeType &N) const {\n    return llvm::find_if(\n        Edges, [&N](const EdgeType *E) { return E->getTargetNode() == N; });\n  }\n\n  // The list of outgoing edges.\n  EdgeListTy Edges;\n};\n\n/// Directed graph\n///\n/// The graph is represented by a table of nodes.\n/// Each node contains a (possibly empty) list of outgoing edges.\n/// Each edge contains the target node it connects to.\ntemplate <class NodeType, class EdgeType> class DirectedGraph {\nprotected:\n  using NodeListTy = SmallVector<NodeType *, 10>;\n  using EdgeListTy = SmallVector<EdgeType *, 10>;\npublic:\n  using iterator = typename NodeListTy::iterator;\n  using const_iterator = typename NodeListTy::const_iterator;\n  using DGraphType = DirectedGraph<NodeType, EdgeType>;\n\n  DirectedGraph() = default;\n  explicit DirectedGraph(NodeType &N) : Nodes() { addNode(N); }\n  DirectedGraph(const DGraphType &G) : Nodes(G.Nodes) {}\n  DirectedGraph(DGraphType &&RHS) : Nodes(std::move(RHS.Nodes)) {}\n  DGraphType &operator=(const DGraphType &G) {\n    Nodes = G.Nodes;\n    return *this;\n  }\n  DGraphType &operator=(const DGraphType &&G) {\n    Nodes = std::move(G.Nodes);\n    return *this;\n  }\n\n  const_iterator begin() const { return Nodes.begin(); }\n  const_iterator end() const { return Nodes.end(); }\n  iterator begin() { return Nodes.begin(); }\n  iterator end() { return Nodes.end(); }\n  const NodeType &front() const { return *Nodes.front(); }\n  NodeType &front() { return *Nodes.front(); }\n  const NodeType &back() const { return *Nodes.back(); }\n  NodeType &back() { return *Nodes.back(); }\n\n  size_t size() const { return Nodes.size(); }\n\n  /// Find the given node \\p N in the table.\n  const_iterator findNode(const NodeType &N) const {\n    return llvm::find_if(Nodes,\n                         [&N](const NodeType *Node) { return *Node == N; });\n  }\n  iterator findNode(const NodeType &N) {\n    return const_cast<iterator>(\n        static_cast<const DGraphType &>(*this).findNode(N));\n  }\n\n  /// Add the given node \\p N to the graph if it is not already present.\n  bool addNode(NodeType &N) {\n    if (findNode(N) != Nodes.end())\n      return false;\n    Nodes.push_back(&N);\n    return true;\n  }\n\n  /// Collect in \\p EL all edges that are coming into node \\p N. Return true\n  /// if at least one edge was found, and false otherwise.\n  bool findIncomingEdgesToNode(const NodeType &N, SmallVectorImpl<EdgeType*> &EL) const {\n    assert(EL.empty() && \"Expected the list of edges to be empty.\");\n    EdgeListTy TempList;\n    for (auto *Node : Nodes) {\n      if (*Node == N)\n        continue;\n      Node->findEdgesTo(N, TempList);\n      llvm::append_range(EL, TempList);\n      TempList.clear();\n    }\n    return !EL.empty();\n  }\n\n  /// Remove the given node \\p N from the graph. If the node has incoming or\n  /// outgoing edges, they are also removed. Return true if the node was found\n  /// and then removed, and false if the node was not found in the graph to\n  /// begin with.\n  bool removeNode(NodeType &N) {\n    iterator IT = findNode(N);\n    if (IT == Nodes.end())\n      return false;\n    // Remove incoming edges.\n    EdgeListTy EL;\n    for (auto *Node : Nodes) {\n      if (*Node == N)\n        continue;\n      Node->findEdgesTo(N, EL);\n      for (auto *E : EL)\n        Node->removeEdge(*E);\n      EL.clear();\n    }\n    N.clear();\n    Nodes.erase(IT);\n    return true;\n  }\n\n  /// Assuming nodes \\p Src and \\p Dst are already in the graph, connect node \\p\n  /// Src to node \\p Dst using the provided edge \\p E. Return true if \\p Src is\n  /// not already connected to \\p Dst via \\p E, and false otherwise.\n  bool connect(NodeType &Src, NodeType &Dst, EdgeType &E) {\n    assert(findNode(Src) != Nodes.end() && \"Src node should be present.\");\n    assert(findNode(Dst) != Nodes.end() && \"Dst node should be present.\");\n    assert((E.getTargetNode() == Dst) &&\n           \"Target of the given edge does not match Dst.\");\n    return Src.addEdge(E);\n  }\n\nprotected:\n  // The list of nodes in the graph.\n  NodeListTy Nodes;\n};\n\n} // namespace llvm\n\n#endif // LLVM_ADT_DIRECTEDGRAPH_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "content": "//===- llvm/Analysis/DDG.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the Data-Dependence Graph (DDG).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_DDG_H\n#define LLVM_ANALYSIS_DDG_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DirectedGraph.h\"\n#include \"llvm/Analysis/DependenceAnalysis.h\"\n#include \"llvm/Analysis/DependenceGraphBuilder.h\"\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/IR/Instructions.h\"\n\nnamespace llvm {\nclass DDGNode;\nclass DDGEdge;\nusing DDGNodeBase = DGNode<DDGNode, DDGEdge>;\nusing DDGEdgeBase = DGEdge<DDGNode, DDGEdge>;\nusing DDGBase = DirectedGraph<DDGNode, DDGEdge>;\nclass LPMUpdater;\n\n/// Data Dependence Graph Node\n/// The graph can represent the following types of nodes:\n/// 1. Single instruction node containing just one instruction.\n/// 2. Multiple instruction node where two or more instructions from\n///    the same basic block are merged into one node.\n/// 3. Pi-block node which is a group of other DDG nodes that are part of a\n///    strongly-connected component of the graph.\n///    A pi-block node contains more than one single or multiple instruction\n///    nodes. The root node cannot be part of a pi-block.\n/// 4. Root node is a special node that connects to all components such that\n///    there is always a path from it to any node in the graph.\nclass DDGNode : public DDGNodeBase {\npublic:\n  using InstructionListType = SmallVectorImpl<Instruction *>;\n\n  enum class NodeKind {\n    Unknown,\n    SingleInstruction,\n    MultiInstruction,\n    PiBlock,\n    Root,\n  };\n\n  DDGNode() = delete;\n  DDGNode(const NodeKind K) : DDGNodeBase(), Kind(K) {}\n  DDGNode(const DDGNode &N) : DDGNodeBase(N), Kind(N.Kind) {}\n  DDGNode(DDGNode &&N) : DDGNodeBase(std::move(N)), Kind(N.Kind) {}\n  virtual ~DDGNode() = 0;\n\n  DDGNode &operator=(const DDGNode &N) {\n    DGNode::operator=(N);\n    Kind = N.Kind;\n    return *this;\n  }\n\n  DDGNode &operator=(DDGNode &&N) {\n    DGNode::operator=(std::move(N));\n    Kind = N.Kind;\n    return *this;\n  }\n\n  /// Getter for the kind of this node.\n  NodeKind getKind() const { return Kind; }\n\n  /// Collect a list of instructions, in \\p IList, for which predicate \\p Pred\n  /// evaluates to true when iterating over instructions of this node. Return\n  /// true if at least one instruction was collected, and false otherwise.\n  bool collectInstructions(llvm::function_ref<bool(Instruction *)> const &Pred,\n                           InstructionListType &IList) const;\n\nprotected:\n  /// Setter for the kind of this node.\n  void setKind(NodeKind K) { Kind = K; }\n\nprivate:\n  NodeKind Kind;\n};\n\n/// Subclass of DDGNode representing the root node of the graph.\n/// There should only be one such node in a given graph.\nclass RootDDGNode : public DDGNode {\npublic:\n  RootDDGNode() : DDGNode(NodeKind::Root) {}\n  RootDDGNode(const RootDDGNode &N) = delete;\n  RootDDGNode(RootDDGNode &&N) : DDGNode(std::move(N)) {}\n  ~RootDDGNode() {}\n\n  /// Define classof to be able to use isa<>, cast<>, dyn_cast<>, etc.\n  static bool classof(const DDGNode *N) {\n    return N->getKind() == NodeKind::Root;\n  }\n  static bool classof(const RootDDGNode *N) { return true; }\n};\n\n/// Subclass of DDGNode representing single or multi-instruction nodes.\nclass SimpleDDGNode : public DDGNode {\n  friend class DDGBuilder;\n\npublic:\n  SimpleDDGNode() = delete;\n  SimpleDDGNode(Instruction &I);\n  SimpleDDGNode(const SimpleDDGNode &N);\n  SimpleDDGNode(SimpleDDGNode &&N);\n  ~SimpleDDGNode();\n\n  SimpleDDGNode &operator=(const SimpleDDGNode &N) {\n    DDGNode::operator=(N);\n    InstList = N.InstList;\n    return *this;\n  }\n\n  SimpleDDGNode &operator=(SimpleDDGNode &&N) {\n    DDGNode::operator=(std::move(N));\n    InstList = std::move(N.InstList);\n    return *this;\n  }\n\n  /// Get the list of instructions in this node.\n  const InstructionListType &getInstructions() const {\n    assert(!InstList.empty() && \"Instruction List is empty.\");\n    return InstList;\n  }\n  InstructionListType &getInstructions() {\n    return const_cast<InstructionListType &>(\n        static_cast<const SimpleDDGNode *>(this)->getInstructions());\n  }\n\n  /// Get the first/last instruction in the node.\n  Instruction *getFirstInstruction() const { return getInstructions().front(); }\n  Instruction *getLastInstruction() const { return getInstructions().back(); }\n\n  /// Define classof to be able to use isa<>, cast<>, dyn_cast<>, etc.\n  static bool classof(const DDGNode *N) {\n    return N->getKind() == NodeKind::SingleInstruction ||\n           N->getKind() == NodeKind::MultiInstruction;\n  }\n  static bool classof(const SimpleDDGNode *N) { return true; }\n\nprivate:\n  /// Append the list of instructions in \\p Input to this node.\n  void appendInstructions(const InstructionListType &Input) {\n    setKind((InstList.size() == 0 && Input.size() == 1)\n                ? NodeKind::SingleInstruction\n                : NodeKind::MultiInstruction);\n    llvm::append_range(InstList, Input);\n  }\n  void appendInstructions(const SimpleDDGNode &Input) {\n    appendInstructions(Input.getInstructions());\n  }\n\n  /// List of instructions associated with a single or multi-instruction node.\n  SmallVector<Instruction *, 2> InstList;\n};\n\n/// Subclass of DDGNode representing a pi-block. A pi-block represents a group\n/// of DDG nodes that are part of a strongly-connected component of the graph.\n/// Replacing all the SCCs with pi-blocks results in an acyclic representation\n/// of the DDG. For example if we have:\n/// {a -> b}, {b -> c, d}, {c -> a}\n/// the cycle a -> b -> c -> a is abstracted into a pi-block \"p\" as follows:\n/// {p -> d} with \"p\" containing: {a -> b}, {b -> c}, {c -> a}\nclass PiBlockDDGNode : public DDGNode {\npublic:\n  using PiNodeList = SmallVector<DDGNode *, 4>;\n\n  PiBlockDDGNode() = delete;\n  PiBlockDDGNode(const PiNodeList &List);\n  PiBlockDDGNode(const PiBlockDDGNode &N);\n  PiBlockDDGNode(PiBlockDDGNode &&N);\n  ~PiBlockDDGNode();\n\n  PiBlockDDGNode &operator=(const PiBlockDDGNode &N) {\n    DDGNode::operator=(N);\n    NodeList = N.NodeList;\n    return *this;\n  }\n\n  PiBlockDDGNode &operator=(PiBlockDDGNode &&N) {\n    DDGNode::operator=(std::move(N));\n    NodeList = std::move(N.NodeList);\n    return *this;\n  }\n\n  /// Get the list of nodes in this pi-block.\n  const PiNodeList &getNodes() const {\n    assert(!NodeList.empty() && \"Node list is empty.\");\n    return NodeList;\n  }\n  PiNodeList &getNodes() {\n    return const_cast<PiNodeList &>(\n        static_cast<const PiBlockDDGNode *>(this)->getNodes());\n  }\n\n  /// Define classof to be able to use isa<>, cast<>, dyn_cast<>, etc.\n  static bool classof(const DDGNode *N) {\n    return N->getKind() == NodeKind::PiBlock;\n  }\n\nprivate:\n  /// List of nodes in this pi-block.\n  PiNodeList NodeList;\n};\n\n/// Data Dependency Graph Edge.\n/// An edge in the DDG can represent a def-use relationship or\n/// a memory dependence based on the result of DependenceAnalysis.\n/// A rooted edge connects the root node to one of the components\n/// of the graph.\nclass DDGEdge : public DDGEdgeBase {\npublic:\n  /// The kind of edge in the DDG\n  enum class EdgeKind {\n    Unknown,\n    RegisterDefUse,\n    MemoryDependence,\n    Rooted,\n    Last = Rooted // Must be equal to the largest enum value.\n  };\n\n  explicit DDGEdge(DDGNode &N) = delete;\n  DDGEdge(DDGNode &N, EdgeKind K) : DDGEdgeBase(N), Kind(K) {}\n  DDGEdge(const DDGEdge &E) : DDGEdgeBase(E), Kind(E.getKind()) {}\n  DDGEdge(DDGEdge &&E) : DDGEdgeBase(std::move(E)), Kind(E.Kind) {}\n  DDGEdge &operator=(const DDGEdge &E) {\n    DDGEdgeBase::operator=(E);\n    Kind = E.Kind;\n    return *this;\n  }\n\n  DDGEdge &operator=(DDGEdge &&E) {\n    DDGEdgeBase::operator=(std::move(E));\n    Kind = E.Kind;\n    return *this;\n  }\n\n  /// Get the edge kind\n  EdgeKind getKind() const { return Kind; };\n\n  /// Return true if this is a def-use edge, and false otherwise.\n  bool isDefUse() const { return Kind == EdgeKind::RegisterDefUse; }\n\n  /// Return true if this is a memory dependence edge, and false otherwise.\n  bool isMemoryDependence() const { return Kind == EdgeKind::MemoryDependence; }\n\n  /// Return true if this is an edge stemming from the root node, and false\n  /// otherwise.\n  bool isRooted() const { return Kind == EdgeKind::Rooted; }\n\nprivate:\n  EdgeKind Kind;\n};\n\n/// Encapsulate some common data and functionality needed for different\n/// variations of data dependence graphs.\ntemplate <typename NodeType> class DependenceGraphInfo {\npublic:\n  using DependenceList = SmallVector<std::unique_ptr<Dependence>, 1>;\n\n  DependenceGraphInfo() = delete;\n  DependenceGraphInfo(const DependenceGraphInfo &G) = delete;\n  DependenceGraphInfo(const std::string &N, const DependenceInfo &DepInfo)\n      : Name(N), DI(DepInfo), Root(nullptr) {}\n  DependenceGraphInfo(DependenceGraphInfo &&G)\n      : Name(std::move(G.Name)), DI(std::move(G.DI)), Root(G.Root) {}\n  virtual ~DependenceGraphInfo() {}\n\n  /// Return the label that is used to name this graph.\n  StringRef getName() const { return Name; }\n\n  /// Return the root node of the graph.\n  NodeType &getRoot() const {\n    assert(Root && \"Root node is not available yet. Graph construction may \"\n                   \"still be in progress\\n\");\n    return *Root;\n  }\n\n  /// Collect all the data dependency infos coming from any pair of memory\n  /// accesses from \\p Src to \\p Dst, and store them into \\p Deps. Return true\n  /// if a dependence exists, and false otherwise.\n  bool getDependencies(const NodeType &Src, const NodeType &Dst,\n                       DependenceList &Deps) const;\n\n  /// Return a string representing the type of dependence that the dependence\n  /// analysis identified between the two given nodes. This function assumes\n  /// that there is a memory dependence between the given two nodes.\n  std::string getDependenceString(const NodeType &Src,\n                                  const NodeType &Dst) const;\n\nprotected:\n  // Name of the graph.\n  std::string Name;\n\n  // Store a copy of DependenceInfo in the graph, so that individual memory\n  // dependencies don't need to be stored. Instead when the dependence is\n  // queried it is recomputed using @DI.\n  const DependenceInfo DI;\n\n  // A special node in the graph that has an edge to every connected component of\n  // the graph, to ensure all nodes are reachable in a graph walk.\n  NodeType *Root = nullptr;\n};\n\nusing DDGInfo = DependenceGraphInfo<DDGNode>;\n\n/// Data Dependency Graph\nclass DataDependenceGraph : public DDGBase, public DDGInfo {\n  friend AbstractDependenceGraphBuilder<DataDependenceGraph>;\n  friend class DDGBuilder;\n\npublic:\n  using NodeType = DDGNode;\n  using EdgeType = DDGEdge;\n\n  DataDependenceGraph() = delete;\n  DataDependenceGraph(const DataDependenceGraph &G) = delete;\n  DataDependenceGraph(DataDependenceGraph &&G)\n      : DDGBase(std::move(G)), DDGInfo(std::move(G)) {}\n  DataDependenceGraph(Function &F, DependenceInfo &DI);\n  DataDependenceGraph(Loop &L, LoopInfo &LI, DependenceInfo &DI);\n  ~DataDependenceGraph();\n\n  /// If node \\p N belongs to a pi-block return a pointer to the pi-block,\n  /// otherwise return null.\n  const PiBlockDDGNode *getPiBlock(const NodeType &N) const;\n\nprotected:\n  /// Add node \\p N to the graph, if it's not added yet, and keep track of the\n  /// root node as well as pi-blocks and their members. Return true if node is\n  /// successfully added.\n  bool addNode(NodeType &N);\n\nprivate:\n  using PiBlockMapType = DenseMap<const NodeType *, const PiBlockDDGNode *>;\n\n  /// Mapping from graph nodes to their containing pi-blocks. If a node is not\n  /// part of a pi-block, it will not appear in this map.\n  PiBlockMapType PiBlockMap;\n};\n\n/// Concrete implementation of a pure data dependence graph builder. This class\n/// provides custom implementation for the pure-virtual functions used in the\n/// generic dependence graph build algorithm.\n///\n/// For information about time complexity of the build algorithm see the\n/// comments near the declaration of AbstractDependenceGraphBuilder.\nclass DDGBuilder : public AbstractDependenceGraphBuilder<DataDependenceGraph> {\npublic:\n  DDGBuilder(DataDependenceGraph &G, DependenceInfo &D,\n             const BasicBlockListType &BBs)\n      : AbstractDependenceGraphBuilder(G, D, BBs) {}\n  DDGNode &createRootNode() final override {\n    auto *RN = new RootDDGNode();\n    assert(RN && \"Failed to allocate memory for DDG root node.\");\n    Graph.addNode(*RN);\n    return *RN;\n  }\n  DDGNode &createFineGrainedNode(Instruction &I) final override {\n    auto *SN = new SimpleDDGNode(I);\n    assert(SN && \"Failed to allocate memory for simple DDG node.\");\n    Graph.addNode(*SN);\n    return *SN;\n  }\n  DDGNode &createPiBlock(const NodeListType &L) final override {\n    auto *Pi = new PiBlockDDGNode(L);\n    assert(Pi && \"Failed to allocate memory for pi-block node.\");\n    Graph.addNode(*Pi);\n    return *Pi;\n  }\n  DDGEdge &createDefUseEdge(DDGNode &Src, DDGNode &Tgt) final override {\n    auto *E = new DDGEdge(Tgt, DDGEdge::EdgeKind::RegisterDefUse);\n    assert(E && \"Failed to allocate memory for edge\");\n    Graph.connect(Src, Tgt, *E);\n    return *E;\n  }\n  DDGEdge &createMemoryEdge(DDGNode &Src, DDGNode &Tgt) final override {\n    auto *E = new DDGEdge(Tgt, DDGEdge::EdgeKind::MemoryDependence);\n    assert(E && \"Failed to allocate memory for edge\");\n    Graph.connect(Src, Tgt, *E);\n    return *E;\n  }\n  DDGEdge &createRootedEdge(DDGNode &Src, DDGNode &Tgt) final override {\n    auto *E = new DDGEdge(Tgt, DDGEdge::EdgeKind::Rooted);\n    assert(E && \"Failed to allocate memory for edge\");\n    assert(isa<RootDDGNode>(Src) && \"Expected root node\");\n    Graph.connect(Src, Tgt, *E);\n    return *E;\n  }\n\n  const NodeListType &getNodesInPiBlock(const DDGNode &N) final override {\n    auto *PiNode = dyn_cast<const PiBlockDDGNode>(&N);\n    assert(PiNode && \"Expected a pi-block node.\");\n    return PiNode->getNodes();\n  }\n\n  /// Return true if the two nodes \\pSrc and \\pTgt are both simple nodes and\n  /// the consecutive instructions after merging belong to the same basic block.\n  bool areNodesMergeable(const DDGNode &Src,\n                         const DDGNode &Tgt) const final override;\n  void mergeNodes(DDGNode &Src, DDGNode &Tgt) final override;\n  bool shouldSimplify() const final override;\n  bool shouldCreatePiBlocks() const final override;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const DDGNode &N);\nraw_ostream &operator<<(raw_ostream &OS, const DDGNode::NodeKind K);\nraw_ostream &operator<<(raw_ostream &OS, const DDGEdge &E);\nraw_ostream &operator<<(raw_ostream &OS, const DDGEdge::EdgeKind K);\nraw_ostream &operator<<(raw_ostream &OS, const DataDependenceGraph &G);\n\n//===--------------------------------------------------------------------===//\n// DDG Analysis Passes\n//===--------------------------------------------------------------------===//\n\n/// Analysis pass that builds the DDG for a loop.\nclass DDGAnalysis : public AnalysisInfoMixin<DDGAnalysis> {\npublic:\n  using Result = std::unique_ptr<DataDependenceGraph>;\n  Result run(Loop &L, LoopAnalysisManager &AM, LoopStandardAnalysisResults &AR);\n\nprivate:\n  friend AnalysisInfoMixin<DDGAnalysis>;\n  static AnalysisKey Key;\n};\n\n/// Textual printer pass for the DDG of a loop.\nclass DDGAnalysisPrinterPass : public PassInfoMixin<DDGAnalysisPrinterPass> {\npublic:\n  explicit DDGAnalysisPrinterPass(raw_ostream &OS) : OS(OS) {}\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n\nprivate:\n  raw_ostream &OS;\n};\n\n//===--------------------------------------------------------------------===//\n// DependenceGraphInfo Implementation\n//===--------------------------------------------------------------------===//\n\ntemplate <typename NodeType>\nbool DependenceGraphInfo<NodeType>::getDependencies(\n    const NodeType &Src, const NodeType &Dst, DependenceList &Deps) const {\n  assert(Deps.empty() && \"Expected empty output list at the start.\");\n\n  // List of memory access instructions from src and dst nodes.\n  SmallVector<Instruction *, 8> SrcIList, DstIList;\n  auto isMemoryAccess = [](const Instruction *I) {\n    return I->mayReadOrWriteMemory();\n  };\n  Src.collectInstructions(isMemoryAccess, SrcIList);\n  Dst.collectInstructions(isMemoryAccess, DstIList);\n\n  for (auto *SrcI : SrcIList)\n    for (auto *DstI : DstIList)\n      if (auto Dep =\n              const_cast<DependenceInfo *>(&DI)->depends(SrcI, DstI, true))\n        Deps.push_back(std::move(Dep));\n\n  return !Deps.empty();\n}\n\ntemplate <typename NodeType>\nstd::string\nDependenceGraphInfo<NodeType>::getDependenceString(const NodeType &Src,\n                                                   const NodeType &Dst) const {\n  std::string Str;\n  raw_string_ostream OS(Str);\n  DependenceList Deps;\n  if (!getDependencies(Src, Dst, Deps))\n    return OS.str();\n  interleaveComma(Deps, OS, [&](const std::unique_ptr<Dependence> &D) {\n    D->dump(OS);\n    // Remove the extra new-line character printed by the dump\n    // method\n    if (OS.str().back() == '\\n')\n      OS.str().pop_back();\n  });\n\n  return OS.str();\n}\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for the DDG\n//===--------------------------------------------------------------------===//\n\n/// non-const versions of the grapth trait specializations for DDG\ntemplate <> struct GraphTraits<DDGNode *> {\n  using NodeRef = DDGNode *;\n\n  static DDGNode *DDGGetTargetNode(DGEdge<DDGNode, DDGEdge> *P) {\n    return &P->getTargetNode();\n  }\n\n  // Provide a mapped iterator so that the GraphTrait-based implementations can\n  // find the target nodes without having to explicitly go through the edges.\n  using ChildIteratorType =\n      mapped_iterator<DDGNode::iterator, decltype(&DDGGetTargetNode)>;\n  using ChildEdgeIteratorType = DDGNode::iterator;\n\n  static NodeRef getEntryNode(NodeRef N) { return N; }\n  static ChildIteratorType child_begin(NodeRef N) {\n    return ChildIteratorType(N->begin(), &DDGGetTargetNode);\n  }\n  static ChildIteratorType child_end(NodeRef N) {\n    return ChildIteratorType(N->end(), &DDGGetTargetNode);\n  }\n\n  static ChildEdgeIteratorType child_edge_begin(NodeRef N) {\n    return N->begin();\n  }\n  static ChildEdgeIteratorType child_edge_end(NodeRef N) { return N->end(); }\n};\n\ntemplate <>\nstruct GraphTraits<DataDependenceGraph *> : public GraphTraits<DDGNode *> {\n  using nodes_iterator = DataDependenceGraph::iterator;\n  static NodeRef getEntryNode(DataDependenceGraph *DG) {\n    return &DG->getRoot();\n  }\n  static nodes_iterator nodes_begin(DataDependenceGraph *DG) {\n    return DG->begin();\n  }\n  static nodes_iterator nodes_end(DataDependenceGraph *DG) { return DG->end(); }\n};\n\n/// const versions of the grapth trait specializations for DDG\ntemplate <> struct GraphTraits<const DDGNode *> {\n  using NodeRef = const DDGNode *;\n\n  static const DDGNode *DDGGetTargetNode(const DGEdge<DDGNode, DDGEdge> *P) {\n    return &P->getTargetNode();\n  }\n\n  // Provide a mapped iterator so that the GraphTrait-based implementations can\n  // find the target nodes without having to explicitly go through the edges.\n  using ChildIteratorType =\n      mapped_iterator<DDGNode::const_iterator, decltype(&DDGGetTargetNode)>;\n  using ChildEdgeIteratorType = DDGNode::const_iterator;\n\n  static NodeRef getEntryNode(NodeRef N) { return N; }\n  static ChildIteratorType child_begin(NodeRef N) {\n    return ChildIteratorType(N->begin(), &DDGGetTargetNode);\n  }\n  static ChildIteratorType child_end(NodeRef N) {\n    return ChildIteratorType(N->end(), &DDGGetTargetNode);\n  }\n\n  static ChildEdgeIteratorType child_edge_begin(NodeRef N) {\n    return N->begin();\n  }\n  static ChildEdgeIteratorType child_edge_end(NodeRef N) { return N->end(); }\n};\n\ntemplate <>\nstruct GraphTraits<const DataDependenceGraph *>\n    : public GraphTraits<const DDGNode *> {\n  using nodes_iterator = DataDependenceGraph::const_iterator;\n  static NodeRef getEntryNode(const DataDependenceGraph *DG) {\n    return &DG->getRoot();\n  }\n  static nodes_iterator nodes_begin(const DataDependenceGraph *DG) {\n    return DG->begin();\n  }\n  static nodes_iterator nodes_end(const DataDependenceGraph *DG) {\n    return DG->end();\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_ANALYSIS_DDG_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h", "content": "//===- llvm/Analysis/DDGPrinter.h -------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DOT printer for the Data-Dependence Graph (DDG).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_DDGPRINTER_H\n#define LLVM_ANALYSIS_DDGPRINTER_H\n\n#include \"llvm/Analysis/DDG.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/DOTGraphTraits.h\"\n\nnamespace llvm {\n\n//===--------------------------------------------------------------------===//\n// Implementation of DDG DOT Printer for a loop.\n//===--------------------------------------------------------------------===//\nclass DDGDotPrinterPass : public PassInfoMixin<DDGDotPrinterPass> {\npublic:\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n};\n\n//===--------------------------------------------------------------------===//\n// Specialization of DOTGraphTraits.\n//===--------------------------------------------------------------------===//\ntemplate <>\nstruct DOTGraphTraits<const DataDependenceGraph *>\n    : public DefaultDOTGraphTraits {\n\n  DOTGraphTraits(bool IsSimple = false) : DefaultDOTGraphTraits(IsSimple) {}\n\n  /// Generate a title for the graph in DOT format\n  std::string getGraphName(const DataDependenceGraph *G) {\n    assert(G && \"expected a valid pointer to the graph.\");\n    return \"DDG for '\" + std::string(G->getName()) + \"'\";\n  }\n\n  /// Print a DDG node either in concise form (-ddg-dot-only) or\n  /// verbose mode (-ddg-dot).\n  std::string getNodeLabel(const DDGNode *Node,\n                           const DataDependenceGraph *Graph);\n\n  /// Print attributes of an edge in the DDG graph. If the edge\n  /// is a MemoryDependence edge, then detailed dependence info\n  /// available from DependenceAnalysis is displayed.\n  std::string\n  getEdgeAttributes(const DDGNode *Node,\n                    GraphTraits<const DDGNode *>::ChildIteratorType I,\n                    const DataDependenceGraph *G);\n\n  /// Do not print nodes that are part of a pi-block separately. They\n  /// will be printed when their containing pi-block is being printed.\n  bool isNodeHidden(const DDGNode *Node, const DataDependenceGraph *G);\n\nprivate:\n  /// Print a DDG node in concise form.\n  static std::string getSimpleNodeLabel(const DDGNode *Node,\n                                        const DataDependenceGraph *G);\n\n  /// Print a DDG node with more information including containing instructions\n  /// and detailed information about the dependence edges.\n  static std::string getVerboseNodeLabel(const DDGNode *Node,\n                                         const DataDependenceGraph *G);\n\n  /// Print a DDG edge in concise form.\n  static std::string getSimpleEdgeAttributes(const DDGNode *Src,\n                                             const DDGEdge *Edge,\n                                             const DataDependenceGraph *G);\n\n  /// Print a DDG edge with more information including detailed information\n  /// about the dependence edges.\n  static std::string getVerboseEdgeAttributes(const DDGNode *Src,\n                                              const DDGEdge *Edge,\n                                              const DataDependenceGraph *G);\n};\n\nusing DDGDotGraphTraits = DOTGraphTraits<const DataDependenceGraph *>;\n\n} // namespace llvm\n\n#endif // LLVM_ANALYSIS_DDGPRINTER_H\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h", "content": "//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// DependenceAnalysis is an LLVM pass that analyses dependences between memory\n// accesses. Currently, it is an implementation of the approach described in\n//\n//            Practical Dependence Testing\n//            Goff, Kennedy, Tseng\n//            PLDI 1991\n//\n// There's a single entry point that analyzes the dependence between a pair\n// of memory references in a function, returning either NULL, for no dependence,\n// or a more-or-less detailed description of the dependence between them.\n//\n// This pass exists to support the DependenceGraph pass. There are two separate\n// passes because there's a useful separation of concerns. A dependence exists\n// if two conditions are met:\n//\n//    1) Two instructions reference the same memory location, and\n//    2) There is a flow of control leading from one instruction to the other.\n//\n// DependenceAnalysis attacks the first condition; DependenceGraph will attack\n// the second (it's not yet ready).\n//\n// Please note that this is work in progress and the interface is subject to\n// change.\n//\n// Plausible changes:\n//    Return a set of more precise dependences instead of just one dependence\n//    summarizing all.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_DEPENDENCEANALYSIS_H\n#define LLVM_ANALYSIS_DEPENDENCEANALYSIS_H\n\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n\nnamespace llvm {\n  class AAResults;\n  template <typename T> class ArrayRef;\n  class Loop;\n  class LoopInfo;\n  class ScalarEvolution;\n  class SCEV;\n  class SCEVConstant;\n  class raw_ostream;\n\n  /// Dependence - This class represents a dependence between two memory\n  /// memory references in a function. It contains minimal information and\n  /// is used in the very common situation where the compiler is unable to\n  /// determine anything beyond the existence of a dependence; that is, it\n  /// represents a confused dependence (see also FullDependence). In most\n  /// cases (for output, flow, and anti dependences), the dependence implies\n  /// an ordering, where the source must precede the destination; in contrast,\n  /// input dependences are unordered.\n  ///\n  /// When a dependence graph is built, each Dependence will be a member of\n  /// the set of predecessor edges for its destination instruction and a set\n  /// if successor edges for its source instruction. These sets are represented\n  /// as singly-linked lists, with the \"next\" fields stored in the dependence\n  /// itelf.\n  class Dependence {\n  protected:\n    Dependence(Dependence &&) = default;\n    Dependence &operator=(Dependence &&) = default;\n\n  public:\n    Dependence(Instruction *Source,\n               Instruction *Destination) :\n      Src(Source),\n      Dst(Destination),\n      NextPredecessor(nullptr),\n      NextSuccessor(nullptr) {}\n    virtual ~Dependence() {}\n\n    /// Dependence::DVEntry - Each level in the distance/direction vector\n    /// has a direction (or perhaps a union of several directions), and\n    /// perhaps a distance.\n    struct DVEntry {\n      enum { NONE = 0,\n             LT = 1,\n             EQ = 2,\n             LE = 3,\n             GT = 4,\n             NE = 5,\n             GE = 6,\n             ALL = 7 };\n      unsigned char Direction : 3; // Init to ALL, then refine.\n      bool Scalar    : 1; // Init to true.\n      bool PeelFirst : 1; // Peeling the first iteration will break dependence.\n      bool PeelLast  : 1; // Peeling the last iteration will break the dependence.\n      bool Splitable : 1; // Splitting the loop will break dependence.\n      const SCEV *Distance; // NULL implies no distance available.\n      DVEntry() : Direction(ALL), Scalar(true), PeelFirst(false),\n                  PeelLast(false), Splitable(false), Distance(nullptr) { }\n    };\n\n    /// getSrc - Returns the source instruction for this dependence.\n    ///\n    Instruction *getSrc() const { return Src; }\n\n    /// getDst - Returns the destination instruction for this dependence.\n    ///\n    Instruction *getDst() const { return Dst; }\n\n    /// isInput - Returns true if this is an input dependence.\n    ///\n    bool isInput() const;\n\n    /// isOutput - Returns true if this is an output dependence.\n    ///\n    bool isOutput() const;\n\n    /// isFlow - Returns true if this is a flow (aka true) dependence.\n    ///\n    bool isFlow() const;\n\n    /// isAnti - Returns true if this is an anti dependence.\n    ///\n    bool isAnti() const;\n\n    /// isOrdered - Returns true if dependence is Output, Flow, or Anti\n    ///\n    bool isOrdered() const { return isOutput() || isFlow() || isAnti(); }\n\n    /// isUnordered - Returns true if dependence is Input\n    ///\n    bool isUnordered() const { return isInput(); }\n\n    /// isLoopIndependent - Returns true if this is a loop-independent\n    /// dependence.\n    virtual bool isLoopIndependent() const { return true; }\n\n    /// isConfused - Returns true if this dependence is confused\n    /// (the compiler understands nothing and makes worst-case\n    /// assumptions).\n    virtual bool isConfused() const { return true; }\n\n    /// isConsistent - Returns true if this dependence is consistent\n    /// (occurs every time the source and destination are executed).\n    virtual bool isConsistent() const { return false; }\n\n    /// getLevels - Returns the number of common loops surrounding the\n    /// source and destination of the dependence.\n    virtual unsigned getLevels() const { return 0; }\n\n    /// getDirection - Returns the direction associated with a particular\n    /// level.\n    virtual unsigned getDirection(unsigned Level) const { return DVEntry::ALL; }\n\n    /// getDistance - Returns the distance (or NULL) associated with a\n    /// particular level.\n    virtual const SCEV *getDistance(unsigned Level) const { return nullptr; }\n\n    /// isPeelFirst - Returns true if peeling the first iteration from\n    /// this loop will break this dependence.\n    virtual bool isPeelFirst(unsigned Level) const { return false; }\n\n    /// isPeelLast - Returns true if peeling the last iteration from\n    /// this loop will break this dependence.\n    virtual bool isPeelLast(unsigned Level) const { return false; }\n\n    /// isSplitable - Returns true if splitting this loop will break\n    /// the dependence.\n    virtual bool isSplitable(unsigned Level) const { return false; }\n\n    /// isScalar - Returns true if a particular level is scalar; that is,\n    /// if no subscript in the source or destination mention the induction\n    /// variable associated with the loop at this level.\n    virtual bool isScalar(unsigned Level) const;\n\n    /// getNextPredecessor - Returns the value of the NextPredecessor\n    /// field.\n    const Dependence *getNextPredecessor() const { return NextPredecessor; }\n\n    /// getNextSuccessor - Returns the value of the NextSuccessor\n    /// field.\n    const Dependence *getNextSuccessor() const { return NextSuccessor; }\n\n    /// setNextPredecessor - Sets the value of the NextPredecessor\n    /// field.\n    void setNextPredecessor(const Dependence *pred) { NextPredecessor = pred; }\n\n    /// setNextSuccessor - Sets the value of the NextSuccessor\n    /// field.\n    void setNextSuccessor(const Dependence *succ) { NextSuccessor = succ; }\n\n    /// dump - For debugging purposes, dumps a dependence to OS.\n    ///\n    void dump(raw_ostream &OS) const;\n\n  private:\n    Instruction *Src, *Dst;\n    const Dependence *NextPredecessor, *NextSuccessor;\n    friend class DependenceInfo;\n  };\n\n  /// FullDependence - This class represents a dependence between two memory\n  /// references in a function. It contains detailed information about the\n  /// dependence (direction vectors, etc.) and is used when the compiler is\n  /// able to accurately analyze the interaction of the references; that is,\n  /// it is not a confused dependence (see Dependence). In most cases\n  /// (for output, flow, and anti dependences), the dependence implies an\n  /// ordering, where the source must precede the destination; in contrast,\n  /// input dependences are unordered.\n  class FullDependence final : public Dependence {\n  public:\n    FullDependence(Instruction *Src, Instruction *Dst, bool LoopIndependent,\n                   unsigned Levels);\n\n    /// isLoopIndependent - Returns true if this is a loop-independent\n    /// dependence.\n    bool isLoopIndependent() const override { return LoopIndependent; }\n\n    /// isConfused - Returns true if this dependence is confused\n    /// (the compiler understands nothing and makes worst-case\n    /// assumptions).\n    bool isConfused() const override { return false; }\n\n    /// isConsistent - Returns true if this dependence is consistent\n    /// (occurs every time the source and destination are executed).\n    bool isConsistent() const override { return Consistent; }\n\n    /// getLevels - Returns the number of common loops surrounding the\n    /// source and destination of the dependence.\n    unsigned getLevels() const override { return Levels; }\n\n    /// getDirection - Returns the direction associated with a particular\n    /// level.\n    unsigned getDirection(unsigned Level) const override;\n\n    /// getDistance - Returns the distance (or NULL) associated with a\n    /// particular level.\n    const SCEV *getDistance(unsigned Level) const override;\n\n    /// isPeelFirst - Returns true if peeling the first iteration from\n    /// this loop will break this dependence.\n    bool isPeelFirst(unsigned Level) const override;\n\n    /// isPeelLast - Returns true if peeling the last iteration from\n    /// this loop will break this dependence.\n    bool isPeelLast(unsigned Level) const override;\n\n    /// isSplitable - Returns true if splitting the loop will break\n    /// the dependence.\n    bool isSplitable(unsigned Level) const override;\n\n    /// isScalar - Returns true if a particular level is scalar; that is,\n    /// if no subscript in the source or destination mention the induction\n    /// variable associated with the loop at this level.\n    bool isScalar(unsigned Level) const override;\n\n  private:\n    unsigned short Levels;\n    bool LoopIndependent;\n    bool Consistent; // Init to true, then refine.\n    std::unique_ptr<DVEntry[]> DV;\n    friend class DependenceInfo;\n  };\n\n  /// DependenceInfo - This class is the main dependence-analysis driver.\n  ///\n  class DependenceInfo {\n  public:\n    DependenceInfo(Function *F, AAResults *AA, ScalarEvolution *SE,\n                   LoopInfo *LI)\n        : AA(AA), SE(SE), LI(LI), F(F) {}\n\n    /// Handle transitive invalidation when the cached analysis results go away.\n    bool invalidate(Function &F, const PreservedAnalyses &PA,\n                    FunctionAnalysisManager::Invalidator &Inv);\n\n    /// depends - Tests for a dependence between the Src and Dst instructions.\n    /// Returns NULL if no dependence; otherwise, returns a Dependence (or a\n    /// FullDependence) with as much information as can be gleaned.\n    /// The flag PossiblyLoopIndependent should be set by the caller\n    /// if it appears that control flow can reach from Src to Dst\n    /// without traversing a loop back edge.\n    std::unique_ptr<Dependence> depends(Instruction *Src,\n                                        Instruction *Dst,\n                                        bool PossiblyLoopIndependent);\n\n    /// getSplitIteration - Give a dependence that's splittable at some\n    /// particular level, return the iteration that should be used to split\n    /// the loop.\n    ///\n    /// Generally, the dependence analyzer will be used to build\n    /// a dependence graph for a function (basically a map from instructions\n    /// to dependences). Looking for cycles in the graph shows us loops\n    /// that cannot be trivially vectorized/parallelized.\n    ///\n    /// We can try to improve the situation by examining all the dependences\n    /// that make up the cycle, looking for ones we can break.\n    /// Sometimes, peeling the first or last iteration of a loop will break\n    /// dependences, and there are flags for those possibilities.\n    /// Sometimes, splitting a loop at some other iteration will do the trick,\n    /// and we've got a flag for that case. Rather than waste the space to\n    /// record the exact iteration (since we rarely know), we provide\n    /// a method that calculates the iteration. It's a drag that it must work\n    /// from scratch, but wonderful in that it's possible.\n    ///\n    /// Here's an example:\n    ///\n    ///    for (i = 0; i < 10; i++)\n    ///        A[i] = ...\n    ///        ... = A[11 - i]\n    ///\n    /// There's a loop-carried flow dependence from the store to the load,\n    /// found by the weak-crossing SIV test. The dependence will have a flag,\n    /// indicating that the dependence can be broken by splitting the loop.\n    /// Calling getSplitIteration will return 5.\n    /// Splitting the loop breaks the dependence, like so:\n    ///\n    ///    for (i = 0; i <= 5; i++)\n    ///        A[i] = ...\n    ///        ... = A[11 - i]\n    ///    for (i = 6; i < 10; i++)\n    ///        A[i] = ...\n    ///        ... = A[11 - i]\n    ///\n    /// breaks the dependence and allows us to vectorize/parallelize\n    /// both loops.\n    const SCEV *getSplitIteration(const Dependence &Dep, unsigned Level);\n\n    Function *getFunction() const { return F; }\n\n  private:\n    AAResults *AA;\n    ScalarEvolution *SE;\n    LoopInfo *LI;\n    Function *F;\n\n    /// Subscript - This private struct represents a pair of subscripts from\n    /// a pair of potentially multi-dimensional array references. We use a\n    /// vector of them to guide subscript partitioning.\n    struct Subscript {\n      const SCEV *Src;\n      const SCEV *Dst;\n      enum ClassificationKind { ZIV, SIV, RDIV, MIV, NonLinear } Classification;\n      SmallBitVector Loops;\n      SmallBitVector GroupLoops;\n      SmallBitVector Group;\n    };\n\n    struct CoefficientInfo {\n      const SCEV *Coeff;\n      const SCEV *PosPart;\n      const SCEV *NegPart;\n      const SCEV *Iterations;\n    };\n\n    struct BoundInfo {\n      const SCEV *Iterations;\n      const SCEV *Upper[8];\n      const SCEV *Lower[8];\n      unsigned char Direction;\n      unsigned char DirSet;\n    };\n\n    /// Constraint - This private class represents a constraint, as defined\n    /// in the paper\n    ///\n    ///           Practical Dependence Testing\n    ///           Goff, Kennedy, Tseng\n    ///           PLDI 1991\n    ///\n    /// There are 5 kinds of constraint, in a hierarchy.\n    ///   1) Any - indicates no constraint, any dependence is possible.\n    ///   2) Line - A line ax + by = c, where a, b, and c are parameters,\n    ///             representing the dependence equation.\n    ///   3) Distance - The value d of the dependence distance;\n    ///   4) Point - A point <x, y> representing the dependence from\n    ///              iteration x to iteration y.\n    ///   5) Empty - No dependence is possible.\n    class Constraint {\n    private:\n      enum ConstraintKind { Empty, Point, Distance, Line, Any } Kind;\n      ScalarEvolution *SE;\n      const SCEV *A;\n      const SCEV *B;\n      const SCEV *C;\n      const Loop *AssociatedLoop;\n\n    public:\n      /// isEmpty - Return true if the constraint is of kind Empty.\n      bool isEmpty() const { return Kind == Empty; }\n\n      /// isPoint - Return true if the constraint is of kind Point.\n      bool isPoint() const { return Kind == Point; }\n\n      /// isDistance - Return true if the constraint is of kind Distance.\n      bool isDistance() const { return Kind == Distance; }\n\n      /// isLine - Return true if the constraint is of kind Line.\n      /// Since Distance's can also be represented as Lines, we also return\n      /// true if the constraint is of kind Distance.\n      bool isLine() const { return Kind == Line || Kind == Distance; }\n\n      /// isAny - Return true if the constraint is of kind Any;\n      bool isAny() const { return Kind == Any; }\n\n      /// getX - If constraint is a point <X, Y>, returns X.\n      /// Otherwise assert.\n      const SCEV *getX() const;\n\n      /// getY - If constraint is a point <X, Y>, returns Y.\n      /// Otherwise assert.\n      const SCEV *getY() const;\n\n      /// getA - If constraint is a line AX + BY = C, returns A.\n      /// Otherwise assert.\n      const SCEV *getA() const;\n\n      /// getB - If constraint is a line AX + BY = C, returns B.\n      /// Otherwise assert.\n      const SCEV *getB() const;\n\n      /// getC - If constraint is a line AX + BY = C, returns C.\n      /// Otherwise assert.\n      const SCEV *getC() const;\n\n      /// getD - If constraint is a distance, returns D.\n      /// Otherwise assert.\n      const SCEV *getD() const;\n\n      /// getAssociatedLoop - Returns the loop associated with this constraint.\n      const Loop *getAssociatedLoop() const;\n\n      /// setPoint - Change a constraint to Point.\n      void setPoint(const SCEV *X, const SCEV *Y, const Loop *CurrentLoop);\n\n      /// setLine - Change a constraint to Line.\n      void setLine(const SCEV *A, const SCEV *B,\n                   const SCEV *C, const Loop *CurrentLoop);\n\n      /// setDistance - Change a constraint to Distance.\n      void setDistance(const SCEV *D, const Loop *CurrentLoop);\n\n      /// setEmpty - Change a constraint to Empty.\n      void setEmpty();\n\n      /// setAny - Change a constraint to Any.\n      void setAny(ScalarEvolution *SE);\n\n      /// dump - For debugging purposes. Dumps the constraint\n      /// out to OS.\n      void dump(raw_ostream &OS) const;\n    };\n\n    /// establishNestingLevels - Examines the loop nesting of the Src and Dst\n    /// instructions and establishes their shared loops. Sets the variables\n    /// CommonLevels, SrcLevels, and MaxLevels.\n    /// The source and destination instructions needn't be contained in the same\n    /// loop. The routine establishNestingLevels finds the level of most deeply\n    /// nested loop that contains them both, CommonLevels. An instruction that's\n    /// not contained in a loop is at level = 0. MaxLevels is equal to the level\n    /// of the source plus the level of the destination, minus CommonLevels.\n    /// This lets us allocate vectors MaxLevels in length, with room for every\n    /// distinct loop referenced in both the source and destination subscripts.\n    /// The variable SrcLevels is the nesting depth of the source instruction.\n    /// It's used to help calculate distinct loops referenced by the destination.\n    /// Here's the map from loops to levels:\n    ///            0 - unused\n    ///            1 - outermost common loop\n    ///          ... - other common loops\n    /// CommonLevels - innermost common loop\n    ///          ... - loops containing Src but not Dst\n    ///    SrcLevels - innermost loop containing Src but not Dst\n    ///          ... - loops containing Dst but not Src\n    ///    MaxLevels - innermost loop containing Dst but not Src\n    /// Consider the follow code fragment:\n    ///    for (a = ...) {\n    ///      for (b = ...) {\n    ///        for (c = ...) {\n    ///          for (d = ...) {\n    ///            A[] = ...;\n    ///          }\n    ///        }\n    ///        for (e = ...) {\n    ///          for (f = ...) {\n    ///            for (g = ...) {\n    ///              ... = A[];\n    ///            }\n    ///          }\n    ///        }\n    ///      }\n    ///    }\n    /// If we're looking at the possibility of a dependence between the store\n    /// to A (the Src) and the load from A (the Dst), we'll note that they\n    /// have 2 loops in common, so CommonLevels will equal 2 and the direction\n    /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.\n    /// A map from loop names to level indices would look like\n    ///     a - 1\n    ///     b - 2 = CommonLevels\n    ///     c - 3\n    ///     d - 4 = SrcLevels\n    ///     e - 5\n    ///     f - 6\n    ///     g - 7 = MaxLevels\n    void establishNestingLevels(const Instruction *Src,\n                                const Instruction *Dst);\n\n    unsigned CommonLevels, SrcLevels, MaxLevels;\n\n    /// mapSrcLoop - Given one of the loops containing the source, return\n    /// its level index in our numbering scheme.\n    unsigned mapSrcLoop(const Loop *SrcLoop) const;\n\n    /// mapDstLoop - Given one of the loops containing the destination,\n    /// return its level index in our numbering scheme.\n    unsigned mapDstLoop(const Loop *DstLoop) const;\n\n    /// isLoopInvariant - Returns true if Expression is loop invariant\n    /// in LoopNest.\n    bool isLoopInvariant(const SCEV *Expression, const Loop *LoopNest) const;\n\n    /// Makes sure all subscript pairs share the same integer type by\n    /// sign-extending as necessary.\n    /// Sign-extending a subscript is safe because getelementptr assumes the\n    /// array subscripts are signed.\n    void unifySubscriptType(ArrayRef<Subscript *> Pairs);\n\n    /// removeMatchingExtensions - Examines a subscript pair.\n    /// If the source and destination are identically sign (or zero)\n    /// extended, it strips off the extension in an effort to\n    /// simplify the actual analysis.\n    void removeMatchingExtensions(Subscript *Pair);\n\n    /// collectCommonLoops - Finds the set of loops from the LoopNest that\n    /// have a level <= CommonLevels and are referred to by the SCEV Expression.\n    void collectCommonLoops(const SCEV *Expression,\n                            const Loop *LoopNest,\n                            SmallBitVector &Loops) const;\n\n    /// checkSrcSubscript - Examines the SCEV Src, returning true iff it's\n    /// linear. Collect the set of loops mentioned by Src.\n    bool checkSrcSubscript(const SCEV *Src,\n                           const Loop *LoopNest,\n                           SmallBitVector &Loops);\n\n    /// checkDstSubscript - Examines the SCEV Dst, returning true iff it's\n    /// linear. Collect the set of loops mentioned by Dst.\n    bool checkDstSubscript(const SCEV *Dst,\n                           const Loop *LoopNest,\n                           SmallBitVector &Loops);\n\n    /// isKnownPredicate - Compare X and Y using the predicate Pred.\n    /// Basically a wrapper for SCEV::isKnownPredicate,\n    /// but tries harder, especially in the presence of sign and zero\n    /// extensions and symbolics.\n    bool isKnownPredicate(ICmpInst::Predicate Pred,\n                          const SCEV *X,\n                          const SCEV *Y) const;\n\n    /// isKnownLessThan - Compare to see if S is less than Size\n    /// Another wrapper for isKnownNegative(S - max(Size, 1)) with some extra\n    /// checking if S is an AddRec and we can prove lessthan using the loop\n    /// bounds.\n    bool isKnownLessThan(const SCEV *S, const SCEV *Size) const;\n\n    /// isKnownNonNegative - Compare to see if S is known not to be negative\n    /// Uses the fact that S comes from Ptr, which may be an inbound GEP,\n    /// Proving there is no wrapping going on.\n    bool isKnownNonNegative(const SCEV *S, const Value *Ptr) const;\n\n    /// collectUpperBound - All subscripts are the same type (on my machine,\n    /// an i64). The loop bound may be a smaller type. collectUpperBound\n    /// find the bound, if available, and zero extends it to the Type T.\n    /// (I zero extend since the bound should always be >= 0.)\n    /// If no upper bound is available, return NULL.\n    const SCEV *collectUpperBound(const Loop *l, Type *T) const;\n\n    /// collectConstantUpperBound - Calls collectUpperBound(), then\n    /// attempts to cast it to SCEVConstant. If the cast fails,\n    /// returns NULL.\n    const SCEVConstant *collectConstantUpperBound(const Loop *l, Type *T) const;\n\n    /// classifyPair - Examines the subscript pair (the Src and Dst SCEVs)\n    /// and classifies it as either ZIV, SIV, RDIV, MIV, or Nonlinear.\n    /// Collects the associated loops in a set.\n    Subscript::ClassificationKind classifyPair(const SCEV *Src,\n                                           const Loop *SrcLoopNest,\n                                           const SCEV *Dst,\n                                           const Loop *DstLoopNest,\n                                           SmallBitVector &Loops);\n\n    /// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// If the dependence isn't proven to exist,\n    /// marks the Result as inconsistent.\n    bool testZIV(const SCEV *Src,\n                 const SCEV *Dst,\n                 FullDependence &Result) const;\n\n    /// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.\n    /// Things of the form [c1 + a1*i] and [c2 + a2*j], where\n    /// i and j are induction variables, c1 and c2 are loop invariant,\n    /// and a1 and a2 are constant.\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// Sets appropriate direction vector entry and, when possible,\n    /// the distance vector entry.\n    /// If the dependence isn't proven to exist,\n    /// marks the Result as inconsistent.\n    bool testSIV(const SCEV *Src,\n                 const SCEV *Dst,\n                 unsigned &Level,\n                 FullDependence &Result,\n                 Constraint &NewConstraint,\n                 const SCEV *&SplitIter) const;\n\n    /// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.\n    /// Things of the form [c1 + a1*i] and [c2 + a2*j]\n    /// where i and j are induction variables, c1 and c2 are loop invariant,\n    /// and a1 and a2 are constant.\n    /// With minor algebra, this test can also be used for things like\n    /// [c1 + a1*i + a2*j][c2].\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// Marks the Result as inconsistent.\n    bool testRDIV(const SCEV *Src,\n                  const SCEV *Dst,\n                  FullDependence &Result) const;\n\n    /// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.\n    /// Returns true if dependence disproved.\n    /// Can sometimes refine direction vectors.\n    bool testMIV(const SCEV *Src,\n                 const SCEV *Dst,\n                 const SmallBitVector &Loops,\n                 FullDependence &Result) const;\n\n    /// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst)\n    /// for dependence.\n    /// Things of the form [c1 + a*i] and [c2 + a*i],\n    /// where i is an induction variable, c1 and c2 are loop invariant,\n    /// and a is a constant\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// Sets appropriate direction and distance.\n    bool strongSIVtest(const SCEV *Coeff,\n                       const SCEV *SrcConst,\n                       const SCEV *DstConst,\n                       const Loop *CurrentLoop,\n                       unsigned Level,\n                       FullDependence &Result,\n                       Constraint &NewConstraint) const;\n\n    /// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair\n    /// (Src and Dst) for dependence.\n    /// Things of the form [c1 + a*i] and [c2 - a*i],\n    /// where i is an induction variable, c1 and c2 are loop invariant,\n    /// and a is a constant.\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// Sets appropriate direction entry.\n    /// Set consistent to false.\n    /// Marks the dependence as splitable.\n    bool weakCrossingSIVtest(const SCEV *SrcCoeff,\n                             const SCEV *SrcConst,\n                             const SCEV *DstConst,\n                             const Loop *CurrentLoop,\n                             unsigned Level,\n                             FullDependence &Result,\n                             Constraint &NewConstraint,\n                             const SCEV *&SplitIter) const;\n\n    /// ExactSIVtest - Tests the SIV subscript pair\n    /// (Src and Dst) for dependence.\n    /// Things of the form [c1 + a1*i] and [c2 + a2*i],\n    /// where i is an induction variable, c1 and c2 are loop invariant,\n    /// and a1 and a2 are constant.\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// Sets appropriate direction entry.\n    /// Set consistent to false.\n    bool exactSIVtest(const SCEV *SrcCoeff,\n                      const SCEV *DstCoeff,\n                      const SCEV *SrcConst,\n                      const SCEV *DstConst,\n                      const Loop *CurrentLoop,\n                      unsigned Level,\n                      FullDependence &Result,\n                      Constraint &NewConstraint) const;\n\n    /// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair\n    /// (Src and Dst) for dependence.\n    /// Things of the form [c1] and [c2 + a*i],\n    /// where i is an induction variable, c1 and c2 are loop invariant,\n    /// and a is a constant. See also weakZeroDstSIVtest.\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// Sets appropriate direction entry.\n    /// Set consistent to false.\n    /// If loop peeling will break the dependence, mark appropriately.\n    bool weakZeroSrcSIVtest(const SCEV *DstCoeff,\n                            const SCEV *SrcConst,\n                            const SCEV *DstConst,\n                            const Loop *CurrentLoop,\n                            unsigned Level,\n                            FullDependence &Result,\n                            Constraint &NewConstraint) const;\n\n    /// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair\n    /// (Src and Dst) for dependence.\n    /// Things of the form [c1 + a*i] and [c2],\n    /// where i is an induction variable, c1 and c2 are loop invariant,\n    /// and a is a constant. See also weakZeroSrcSIVtest.\n    /// Returns true if any possible dependence is disproved.\n    /// If there might be a dependence, returns false.\n    /// Sets appropriate direction entry.\n    /// Set consistent to false.\n    /// If loop peeling will break the dependence, mark appropriately.\n    bool weakZeroDstSIVtest(const SCEV *SrcCoeff,\n                            const SCEV *SrcConst,\n                            const SCEV *DstConst,\n                            const Loop *CurrentLoop,\n                            unsigned Level,\n                            FullDependence &Result,\n                            Constraint &NewConstraint) const;\n\n    /// exactRDIVtest - Tests the RDIV subscript pair for dependence.\n    /// Things of the form [c1 + a*i] and [c2 + b*j],\n    /// where i and j are induction variable, c1 and c2 are loop invariant,\n    /// and a and b are constants.\n    /// Returns true if any possible dependence is disproved.\n    /// Marks the result as inconsistent.\n    /// Works in some cases that symbolicRDIVtest doesn't,\n    /// and vice versa.\n    bool exactRDIVtest(const SCEV *SrcCoeff,\n                       const SCEV *DstCoeff,\n                       const SCEV *SrcConst,\n                       const SCEV *DstConst,\n                       const Loop *SrcLoop,\n                       const Loop *DstLoop,\n                       FullDependence &Result) const;\n\n    /// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.\n    /// Things of the form [c1 + a*i] and [c2 + b*j],\n    /// where i and j are induction variable, c1 and c2 are loop invariant,\n    /// and a and b are constants.\n    /// Returns true if any possible dependence is disproved.\n    /// Marks the result as inconsistent.\n    /// Works in some cases that exactRDIVtest doesn't,\n    /// and vice versa. Can also be used as a backup for\n    /// ordinary SIV tests.\n    bool symbolicRDIVtest(const SCEV *SrcCoeff,\n                          const SCEV *DstCoeff,\n                          const SCEV *SrcConst,\n                          const SCEV *DstConst,\n                          const Loop *SrcLoop,\n                          const Loop *DstLoop) const;\n\n    /// gcdMIVtest - Tests an MIV subscript pair for dependence.\n    /// Returns true if any possible dependence is disproved.\n    /// Marks the result as inconsistent.\n    /// Can sometimes disprove the equal direction for 1 or more loops.\n    //  Can handle some symbolics that even the SIV tests don't get,\n    /// so we use it as a backup for everything.\n    bool gcdMIVtest(const SCEV *Src,\n                    const SCEV *Dst,\n                    FullDependence &Result) const;\n\n    /// banerjeeMIVtest - Tests an MIV subscript pair for dependence.\n    /// Returns true if any possible dependence is disproved.\n    /// Marks the result as inconsistent.\n    /// Computes directions.\n    bool banerjeeMIVtest(const SCEV *Src,\n                         const SCEV *Dst,\n                         const SmallBitVector &Loops,\n                         FullDependence &Result) const;\n\n    /// collectCoefficientInfo - Walks through the subscript,\n    /// collecting each coefficient, the associated loop bounds,\n    /// and recording its positive and negative parts for later use.\n    CoefficientInfo *collectCoeffInfo(const SCEV *Subscript,\n                                      bool SrcFlag,\n                                      const SCEV *&Constant) const;\n\n    /// getPositivePart - X^+ = max(X, 0).\n    ///\n    const SCEV *getPositivePart(const SCEV *X) const;\n\n    /// getNegativePart - X^- = min(X, 0).\n    ///\n    const SCEV *getNegativePart(const SCEV *X) const;\n\n    /// getLowerBound - Looks through all the bounds info and\n    /// computes the lower bound given the current direction settings\n    /// at each level.\n    const SCEV *getLowerBound(BoundInfo *Bound) const;\n\n    /// getUpperBound - Looks through all the bounds info and\n    /// computes the upper bound given the current direction settings\n    /// at each level.\n    const SCEV *getUpperBound(BoundInfo *Bound) const;\n\n    /// exploreDirections - Hierarchically expands the direction vector\n    /// search space, combining the directions of discovered dependences\n    /// in the DirSet field of Bound. Returns the number of distinct\n    /// dependences discovered. If the dependence is disproved,\n    /// it will return 0.\n    unsigned exploreDirections(unsigned Level,\n                               CoefficientInfo *A,\n                               CoefficientInfo *B,\n                               BoundInfo *Bound,\n                               const SmallBitVector &Loops,\n                               unsigned &DepthExpanded,\n                               const SCEV *Delta) const;\n\n    /// testBounds - Returns true iff the current bounds are plausible.\n    bool testBounds(unsigned char DirKind,\n                    unsigned Level,\n                    BoundInfo *Bound,\n                    const SCEV *Delta) const;\n\n    /// findBoundsALL - Computes the upper and lower bounds for level K\n    /// using the * direction. Records them in Bound.\n    void findBoundsALL(CoefficientInfo *A,\n                       CoefficientInfo *B,\n                       BoundInfo *Bound,\n                       unsigned K) const;\n\n    /// findBoundsLT - Computes the upper and lower bounds for level K\n    /// using the < direction. Records them in Bound.\n    void findBoundsLT(CoefficientInfo *A,\n                      CoefficientInfo *B,\n                      BoundInfo *Bound,\n                      unsigned K) const;\n\n    /// findBoundsGT - Computes the upper and lower bounds for level K\n    /// using the > direction. Records them in Bound.\n    void findBoundsGT(CoefficientInfo *A,\n                      CoefficientInfo *B,\n                      BoundInfo *Bound,\n                      unsigned K) const;\n\n    /// findBoundsEQ - Computes the upper and lower bounds for level K\n    /// using the = direction. Records them in Bound.\n    void findBoundsEQ(CoefficientInfo *A,\n                      CoefficientInfo *B,\n                      BoundInfo *Bound,\n                      unsigned K) const;\n\n    /// intersectConstraints - Updates X with the intersection\n    /// of the Constraints X and Y. Returns true if X has changed.\n    bool intersectConstraints(Constraint *X,\n                              const Constraint *Y);\n\n    /// propagate - Review the constraints, looking for opportunities\n    /// to simplify a subscript pair (Src and Dst).\n    /// Return true if some simplification occurs.\n    /// If the simplification isn't exact (that is, if it is conservative\n    /// in terms of dependence), set consistent to false.\n    bool propagate(const SCEV *&Src,\n                   const SCEV *&Dst,\n                   SmallBitVector &Loops,\n                   SmallVectorImpl<Constraint> &Constraints,\n                   bool &Consistent);\n\n    /// propagateDistance - Attempt to propagate a distance\n    /// constraint into a subscript pair (Src and Dst).\n    /// Return true if some simplification occurs.\n    /// If the simplification isn't exact (that is, if it is conservative\n    /// in terms of dependence), set consistent to false.\n    bool propagateDistance(const SCEV *&Src,\n                           const SCEV *&Dst,\n                           Constraint &CurConstraint,\n                           bool &Consistent);\n\n    /// propagatePoint - Attempt to propagate a point\n    /// constraint into a subscript pair (Src and Dst).\n    /// Return true if some simplification occurs.\n    bool propagatePoint(const SCEV *&Src,\n                        const SCEV *&Dst,\n                        Constraint &CurConstraint);\n\n    /// propagateLine - Attempt to propagate a line\n    /// constraint into a subscript pair (Src and Dst).\n    /// Return true if some simplification occurs.\n    /// If the simplification isn't exact (that is, if it is conservative\n    /// in terms of dependence), set consistent to false.\n    bool propagateLine(const SCEV *&Src,\n                       const SCEV *&Dst,\n                       Constraint &CurConstraint,\n                       bool &Consistent);\n\n    /// findCoefficient - Given a linear SCEV,\n    /// return the coefficient corresponding to specified loop.\n    /// If there isn't one, return the SCEV constant 0.\n    /// For example, given a*i + b*j + c*k, returning the coefficient\n    /// corresponding to the j loop would yield b.\n    const SCEV *findCoefficient(const SCEV *Expr,\n                                const Loop *TargetLoop) const;\n\n    /// zeroCoefficient - Given a linear SCEV,\n    /// return the SCEV given by zeroing out the coefficient\n    /// corresponding to the specified loop.\n    /// For example, given a*i + b*j + c*k, zeroing the coefficient\n    /// corresponding to the j loop would yield a*i + c*k.\n    const SCEV *zeroCoefficient(const SCEV *Expr,\n                                const Loop *TargetLoop) const;\n\n    /// addToCoefficient - Given a linear SCEV Expr,\n    /// return the SCEV given by adding some Value to the\n    /// coefficient corresponding to the specified TargetLoop.\n    /// For example, given a*i + b*j + c*k, adding 1 to the coefficient\n    /// corresponding to the j loop would yield a*i + (b+1)*j + c*k.\n    const SCEV *addToCoefficient(const SCEV *Expr,\n                                 const Loop *TargetLoop,\n                                 const SCEV *Value)  const;\n\n    /// updateDirection - Update direction vector entry\n    /// based on the current constraint.\n    void updateDirection(Dependence::DVEntry &Level,\n                         const Constraint &CurConstraint) const;\n\n    /// Given a linear access function, tries to recover subscripts\n    /// for each dimension of the array element access.\n    bool tryDelinearize(Instruction *Src, Instruction *Dst,\n                        SmallVectorImpl<Subscript> &Pair);\n\n    /// Tries to delinearize access function for a fixed size multi-dimensional\n    /// array, by deriving subscripts from GEP instructions. Returns true upon\n    /// success and false otherwise.\n    bool tryDelinearizeFixedSize(Instruction *Src, Instruction *Dst,\n                                 const SCEV *SrcAccessFn,\n                                 const SCEV *DstAccessFn,\n                                 SmallVectorImpl<const SCEV *> &SrcSubscripts,\n                                 SmallVectorImpl<const SCEV *> &DstSubscripts);\n\n    /// Tries to delinearize access function for a multi-dimensional array with\n    /// symbolic runtime sizes.\n    /// Returns true upon success and false otherwise.\n    bool tryDelinearizeParametricSize(\n        Instruction *Src, Instruction *Dst, const SCEV *SrcAccessFn,\n        const SCEV *DstAccessFn, SmallVectorImpl<const SCEV *> &SrcSubscripts,\n        SmallVectorImpl<const SCEV *> &DstSubscripts);\n\n    /// checkSubscript - Helper function for checkSrcSubscript and\n    /// checkDstSubscript to avoid duplicate code\n    bool checkSubscript(const SCEV *Expr, const Loop *LoopNest,\n                        SmallBitVector &Loops, bool IsSrc);\n  }; // class DependenceInfo\n\n  /// AnalysisPass to compute dependence information in a function\n  class DependenceAnalysis : public AnalysisInfoMixin<DependenceAnalysis> {\n  public:\n    typedef DependenceInfo Result;\n    Result run(Function &F, FunctionAnalysisManager &FAM);\n\n  private:\n    static AnalysisKey Key;\n    friend struct AnalysisInfoMixin<DependenceAnalysis>;\n  }; // class DependenceAnalysis\n\n  /// Printer pass to dump DA results.\n  struct DependenceAnalysisPrinterPass\n      : public PassInfoMixin<DependenceAnalysisPrinterPass> {\n    DependenceAnalysisPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n    PreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM);\n\n  private:\n    raw_ostream &OS;\n  }; // class DependenceAnalysisPrinterPass\n\n  /// Legacy pass manager pass to access dependence information\n  class DependenceAnalysisWrapperPass : public FunctionPass {\n  public:\n    static char ID; // Class identification, replacement for typeinfo\n    DependenceAnalysisWrapperPass();\n\n    bool runOnFunction(Function &F) override;\n    void releaseMemory() override;\n    void getAnalysisUsage(AnalysisUsage &) const override;\n    void print(raw_ostream &, const Module * = nullptr) const override;\n    DependenceInfo &getDI() const;\n\n  private:\n    std::unique_ptr<DependenceInfo> info;\n  }; // class DependenceAnalysisWrapperPass\n\n  /// createDependenceAnalysisPass - This creates an instance of the\n  /// DependenceAnalysis wrapper pass.\n  FunctionPass *createDependenceAnalysisWrapperPass();\n\n} // namespace llvm\n\n#endif\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h", "content": "//===- llvm/Analysis/DependenceGraphBuilder.h -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a builder interface that can be used to populate dependence\n// graphs such as DDG and PDG.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_DEPENDENCEGRAPHBUILDER_H\n#define LLVM_ANALYSIS_DEPENDENCEGRAPHBUILDER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/EquivalenceClasses.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nnamespace llvm {\n\nclass BasicBlock;\nclass DependenceInfo;\nclass Instruction;\n\n/// This abstract builder class defines a set of high-level steps for creating\n/// DDG-like graphs. The client code is expected to inherit from this class and\n/// define concrete implementation for each of the pure virtual functions used\n/// in the high-level algorithm.\ntemplate <class GraphType> class AbstractDependenceGraphBuilder {\nprotected:\n  using BasicBlockListType = SmallVectorImpl<BasicBlock *>;\n\nprivate:\n  using NodeType = typename GraphType::NodeType;\n  using EdgeType = typename GraphType::EdgeType;\n\npublic:\n  using ClassesType = EquivalenceClasses<BasicBlock *>;\n  using NodeListType = SmallVector<NodeType *, 4>;\n\n  AbstractDependenceGraphBuilder(GraphType &G, DependenceInfo &D,\n                                 const BasicBlockListType &BBs)\n      : Graph(G), DI(D), BBList(BBs) {}\n  virtual ~AbstractDependenceGraphBuilder() {}\n\n  /// The main entry to the graph construction algorithm. It starts by\n  /// creating nodes in increasing order of granularity and then\n  /// adds def-use and memory edges. As one of the final stages, it\n  /// also creates pi-block nodes to facilitate codegen in transformations\n  /// that use dependence graphs.\n  ///\n  /// The algorithmic complexity of this implementation is O(V^2 * I^2), where V\n  /// is the number of vertecies (nodes) and I is the number of instructions in\n  /// each node. The total number of instructions, N, is equal to V * I,\n  /// therefore the worst-case time complexity is O(N^2). The average time\n  /// complexity is O((N^2)/2).\n  void populate() {\n    computeInstructionOrdinals();\n    createFineGrainedNodes();\n    createDefUseEdges();\n    createMemoryDependencyEdges();\n    simplify();\n    createAndConnectRootNode();\n    createPiBlocks();\n    sortNodesTopologically();\n  }\n\n  /// Compute ordinal numbers for each instruction and store them in a map for\n  /// future look up. These ordinals are used to compute node ordinals which are\n  /// in turn used to order nodes that are part of a cycle.\n  /// Instruction ordinals are assigned based on lexical program order.\n  void computeInstructionOrdinals();\n\n  /// Create fine grained nodes. These are typically atomic nodes that\n  /// consist of a single instruction.\n  void createFineGrainedNodes();\n\n  /// Analyze the def-use chains and create edges from the nodes containing\n  /// definitions to the nodes containing the uses.\n  void createDefUseEdges();\n\n  /// Analyze data dependencies that exist between memory loads or stores,\n  /// in the graph nodes and create edges between them.\n  void createMemoryDependencyEdges();\n\n  /// Create a root node and add edges such that each node in the graph is\n  /// reachable from the root.\n  void createAndConnectRootNode();\n\n  /// Apply graph abstraction to groups of nodes that belong to a strongly\n  /// connected component of the graph to create larger compound nodes\n  /// called pi-blocks. The purpose of this abstraction is to isolate sets of\n  /// program elements that need to stay together during codegen and turn\n  /// the dependence graph into an acyclic graph.\n  void createPiBlocks();\n\n  /// Go through all the nodes in the graph and collapse any two nodes\n  /// 'a' and 'b' if all of the following are true:\n  ///   - the only edge from 'a' is a def-use edge to 'b' and\n  ///   - the only edge to 'b' is a def-use edge from 'a' and\n  ///   - there is no cyclic edge from 'b' to 'a' and\n  ///   - all instructions in 'a' and 'b' belong to the same basic block and\n  ///   - both 'a' and 'b' are simple (single or multi instruction) nodes.\n  void simplify();\n\n  /// Topologically sort the graph nodes.\n  void sortNodesTopologically();\n\nprotected:\n  /// Create the root node of the graph.\n  virtual NodeType &createRootNode() = 0;\n\n  /// Create an atomic node in the graph given a single instruction.\n  virtual NodeType &createFineGrainedNode(Instruction &I) = 0;\n\n  /// Create a pi-block node in the graph representing a group of nodes in an\n  /// SCC of the graph.\n  virtual NodeType &createPiBlock(const NodeListType &L) = 0;\n\n  /// Create a def-use edge going from \\p Src to \\p Tgt.\n  virtual EdgeType &createDefUseEdge(NodeType &Src, NodeType &Tgt) = 0;\n\n  /// Create a memory dependence edge going from \\p Src to \\p Tgt.\n  virtual EdgeType &createMemoryEdge(NodeType &Src, NodeType &Tgt) = 0;\n\n  /// Create a rooted edge going from \\p Src to \\p Tgt .\n  virtual EdgeType &createRootedEdge(NodeType &Src, NodeType &Tgt) = 0;\n\n  /// Given a pi-block node, return a vector of all the nodes contained within\n  /// it.\n  virtual const NodeListType &getNodesInPiBlock(const NodeType &N) = 0;\n\n  /// Deallocate memory of edge \\p E.\n  virtual void destroyEdge(EdgeType &E) { delete &E; }\n\n  /// Deallocate memory of node \\p N.\n  virtual void destroyNode(NodeType &N) { delete &N; }\n\n  /// Return true if creation of pi-blocks are supported and desired,\n  /// and false otherwise.\n  virtual bool shouldCreatePiBlocks() const { return true; }\n\n  /// Return true if graph simplification step is requested, and false\n  /// otherwise.\n  virtual bool shouldSimplify() const { return true; }\n\n  /// Return true if it's safe to merge the two nodes.\n  virtual bool areNodesMergeable(const NodeType &A,\n                                 const NodeType &B) const = 0;\n\n  /// Append the content of node \\p B into node \\p A and remove \\p B and\n  /// the edge between \\p A and \\p B from the graph.\n  virtual void mergeNodes(NodeType &A, NodeType &B) = 0;\n\n  /// Given an instruction \\p I return its associated ordinal number.\n  size_t getOrdinal(Instruction &I) {\n    assert(InstOrdinalMap.find(&I) != InstOrdinalMap.end() &&\n           \"No ordinal computed for this instruction.\");\n    return InstOrdinalMap[&I];\n  }\n\n  /// Given a node \\p N return its associated ordinal number.\n  size_t getOrdinal(NodeType &N) {\n    assert(NodeOrdinalMap.find(&N) != NodeOrdinalMap.end() &&\n           \"No ordinal computed for this node.\");\n    return NodeOrdinalMap[&N];\n  }\n\n  /// Map types to map instructions to nodes used when populating the graph.\n  using InstToNodeMap = DenseMap<Instruction *, NodeType *>;\n\n  /// Map Types to map instruction/nodes to an ordinal number.\n  using InstToOrdinalMap = DenseMap<Instruction *, size_t>;\n  using NodeToOrdinalMap = DenseMap<NodeType *, size_t>;\n\n  /// Reference to the graph that gets built by a concrete implementation of\n  /// this builder.\n  GraphType &Graph;\n\n  /// Dependence information used to create memory dependence edges in the\n  /// graph.\n  DependenceInfo &DI;\n\n  /// The list of basic blocks to consider when building the graph.\n  const BasicBlockListType &BBList;\n\n  /// A mapping from instructions to the corresponding nodes in the graph.\n  InstToNodeMap IMap;\n\n  /// A mapping from each instruction to an ordinal number. This map is used to\n  /// populate the \\p NodeOrdinalMap.\n  InstToOrdinalMap InstOrdinalMap;\n\n  /// A mapping from nodes to an ordinal number. This map is used to sort nodes\n  /// in a pi-block based on program order.\n  NodeToOrdinalMap NodeOrdinalMap;\n};\n\n} // namespace llvm\n\n#endif // LLVM_ANALYSIS_DEPENDENCEGRAPHBUILDER_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/IVUsers.h", "content": "//===- llvm/Analysis/IVUsers.h - Induction Variable Users -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements bookkeeping for \"interesting\" users of expressions\n// computed from induction variables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_IVUSERS_H\n#define LLVM_ANALYSIS_IVUSERS_H\n\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/Analysis/LoopPass.h\"\n#include \"llvm/Analysis/ScalarEvolutionNormalization.h\"\n#include \"llvm/IR/ValueHandle.h\"\n\nnamespace llvm {\n\nclass AssumptionCache;\nclass DominatorTree;\nclass Instruction;\nclass Value;\nclass ScalarEvolution;\nclass SCEV;\nclass IVUsers;\nclass DataLayout;\n\n/// IVStrideUse - Keep track of one use of a strided induction variable.\n/// The Expr member keeps track of the expression, User is the actual user\n/// instruction of the operand, and 'OperandValToReplace' is the operand of\n/// the User that is the use.\nclass IVStrideUse final : public CallbackVH, public ilist_node<IVStrideUse> {\n  friend class IVUsers;\npublic:\n  IVStrideUse(IVUsers *P, Instruction* U, Value *O)\n    : CallbackVH(U), Parent(P), OperandValToReplace(O) {\n  }\n\n  /// getUser - Return the user instruction for this use.\n  Instruction *getUser() const {\n    return cast<Instruction>(getValPtr());\n  }\n\n  /// setUser - Assign a new user instruction for this use.\n  void setUser(Instruction *NewUser) {\n    setValPtr(NewUser);\n  }\n\n  /// getOperandValToReplace - Return the Value of the operand in the user\n  /// instruction that this IVStrideUse is representing.\n  Value *getOperandValToReplace() const {\n    return OperandValToReplace;\n  }\n\n  /// setOperandValToReplace - Assign a new Value as the operand value\n  /// to replace.\n  void setOperandValToReplace(Value *Op) {\n    OperandValToReplace = Op;\n  }\n\n  /// getPostIncLoops - Return the set of loops for which the expression has\n  /// been adjusted to use post-inc mode.\n  const PostIncLoopSet &getPostIncLoops() const {\n    return PostIncLoops;\n  }\n\n  /// transformToPostInc - Transform the expression to post-inc form for the\n  /// given loop.\n  void transformToPostInc(const Loop *L);\n\nprivate:\n  /// Parent - a pointer to the IVUsers that owns this IVStrideUse.\n  IVUsers *Parent;\n\n  /// OperandValToReplace - The Value of the operand in the user instruction\n  /// that this IVStrideUse is representing.\n  WeakTrackingVH OperandValToReplace;\n\n  /// PostIncLoops - The set of loops for which Expr has been adjusted to\n  /// use post-inc mode. This corresponds with SCEVExpander's post-inc concept.\n  PostIncLoopSet PostIncLoops;\n\n  /// Deleted - Implementation of CallbackVH virtual function to\n  /// receive notification when the User is deleted.\n  void deleted() override;\n};\n\nclass IVUsers {\n  friend class IVStrideUse;\n  Loop *L;\n  AssumptionCache *AC;\n  LoopInfo *LI;\n  DominatorTree *DT;\n  ScalarEvolution *SE;\n  SmallPtrSet<Instruction*, 16> Processed;\n\n  /// IVUses - A list of all tracked IV uses of induction variable expressions\n  /// we are interested in.\n  ilist<IVStrideUse> IVUses;\n\n  // Ephemeral values used by @llvm.assume in this function.\n  SmallPtrSet<const Value *, 32> EphValues;\n\npublic:\n  IVUsers(Loop *L, AssumptionCache *AC, LoopInfo *LI, DominatorTree *DT,\n          ScalarEvolution *SE);\n\n  IVUsers(IVUsers &&X)\n      : L(std::move(X.L)), AC(std::move(X.AC)), DT(std::move(X.DT)),\n        SE(std::move(X.SE)), Processed(std::move(X.Processed)),\n        IVUses(std::move(X.IVUses)), EphValues(std::move(X.EphValues)) {\n    for (IVStrideUse &U : IVUses)\n      U.Parent = this;\n  }\n  IVUsers(const IVUsers &) = delete;\n  IVUsers &operator=(IVUsers &&) = delete;\n  IVUsers &operator=(const IVUsers &) = delete;\n\n  Loop *getLoop() const { return L; }\n\n  /// AddUsersIfInteresting - Inspect the specified Instruction.  If it is a\n  /// reducible SCEV, recursively add its users to the IVUsesByStride set and\n  /// return true.  Otherwise, return false.\n  bool AddUsersIfInteresting(Instruction *I);\n\n  IVStrideUse &AddUser(Instruction *User, Value *Operand);\n\n  /// getReplacementExpr - Return a SCEV expression which computes the\n  /// value of the OperandValToReplace of the given IVStrideUse.\n  const SCEV *getReplacementExpr(const IVStrideUse &IU) const;\n\n  /// getExpr - Return the expression for the use.\n  const SCEV *getExpr(const IVStrideUse &IU) const;\n\n  const SCEV *getStride(const IVStrideUse &IU, const Loop *L) const;\n\n  typedef ilist<IVStrideUse>::iterator iterator;\n  typedef ilist<IVStrideUse>::const_iterator const_iterator;\n  iterator begin() { return IVUses.begin(); }\n  iterator end()   { return IVUses.end(); }\n  const_iterator begin() const { return IVUses.begin(); }\n  const_iterator end() const   { return IVUses.end(); }\n  bool empty() const { return IVUses.empty(); }\n\n  bool isIVUserOrOperand(Instruction *Inst) const {\n    return Processed.count(Inst);\n  }\n\n  void releaseMemory();\n\n  void print(raw_ostream &OS, const Module * = nullptr) const;\n\n  /// dump - This method is used for debugging.\n  void dump() const;\n\nprotected:\n  bool AddUsersImpl(Instruction *I, SmallPtrSetImpl<Loop*> &SimpleLoopNests);\n};\n\nPass *createIVUsersPass();\n\nclass IVUsersWrapperPass : public LoopPass {\n  std::unique_ptr<IVUsers> IU;\n\npublic:\n  static char ID;\n\n  IVUsersWrapperPass();\n\n  IVUsers &getIU() { return *IU; }\n  const IVUsers &getIU() const { return *IU; }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  bool runOnLoop(Loop *L, LPPassManager &LPM) override;\n\n  void releaseMemory() override;\n\n  void print(raw_ostream &OS, const Module * = nullptr) const override;\n};\n\n/// Analysis pass that exposes the \\c IVUsers for a loop.\nclass IVUsersAnalysis : public AnalysisInfoMixin<IVUsersAnalysis> {\n  friend AnalysisInfoMixin<IVUsersAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  typedef IVUsers Result;\n\n  IVUsers run(Loop &L, LoopAnalysisManager &AM,\n              LoopStandardAnalysisResults &AR);\n};\n\n}\n\n#endif\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InlineSizeEstimatorAnalysis.h", "content": "//===- InlineSizeEstimatorAnalysis.h - ML size estimator --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n\n#ifndef LLVM_ANALYSIS_INLINESIZEESTIMATORANALYSIS_H\n#define LLVM_ANALYSIS_INLINESIZEESTIMATORANALYSIS_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\nclass Function;\n\nclass TFModelEvaluator;\nclass InlineSizeEstimatorAnalysis\n    : public AnalysisInfoMixin<InlineSizeEstimatorAnalysis> {\npublic:\n  InlineSizeEstimatorAnalysis();\n  InlineSizeEstimatorAnalysis(InlineSizeEstimatorAnalysis &&);\n  ~InlineSizeEstimatorAnalysis();\n\n  static AnalysisKey Key;\n  using Result = Optional<size_t>;\n  Result run(const Function &F, FunctionAnalysisManager &FAM);\n  static bool isEvaluatorRequested();\n\nprivate:\n  std::unique_ptr<TFModelEvaluator> Evaluator;\n};\n\nclass InlineSizeEstimatorAnalysisPrinterPass\n    : public PassInfoMixin<InlineSizeEstimatorAnalysisPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit InlineSizeEstimatorAnalysisPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n} // namespace llvm\n#endif // LLVM_ANALYSIS_INLINESIZEESTIMATORANALYSIS_H\n"}, "77": {"id": 77, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h", "content": "//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file declares a simple ARC-aware AliasAnalysis using special knowledge\n/// of Objective C to enhance other optimization passes which rely on the Alias\n/// Analysis infrastructure.\n///\n/// WARNING: This file knows about certain library functions. It recognizes them\n/// by name, and hardwires knowledge of their semantics.\n///\n/// WARNING: This file knows about how certain Objective-C library functions are\n/// used. Naive LLVM IR transformations which would otherwise be\n/// behavior-preserving may break these assumptions.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_OBJCARCALIASANALYSIS_H\n#define LLVM_ANALYSIS_OBJCARCALIASANALYSIS_H\n\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Pass.h\"\n\nnamespace llvm {\nnamespace objcarc {\n\n/// This is a simple alias analysis implementation that uses knowledge\n/// of ARC constructs to answer queries.\n///\n/// TODO: This class could be generalized to know about other ObjC-specific\n/// tricks. Such as knowing that ivars in the non-fragile ABI are non-aliasing\n/// even though their offsets are dynamic.\nclass ObjCARCAAResult : public AAResultBase<ObjCARCAAResult> {\n  friend AAResultBase<ObjCARCAAResult>;\n\n  const DataLayout &DL;\n\npublic:\n  explicit ObjCARCAAResult(const DataLayout &DL) : AAResultBase(), DL(DL) {}\n  ObjCARCAAResult(ObjCARCAAResult &&Arg)\n      : AAResultBase(std::move(Arg)), DL(Arg.DL) {}\n\n  /// Handle invalidation events from the new pass manager.\n  ///\n  /// By definition, this result is stateless and so remains valid.\n  bool invalidate(Function &, const PreservedAnalyses &,\n                  FunctionAnalysisManager::Invalidator &) {\n    return false;\n  }\n\n  AliasResult alias(const MemoryLocation &LocA, const MemoryLocation &LocB,\n                    AAQueryInfo &AAQI);\n  bool pointsToConstantMemory(const MemoryLocation &Loc, AAQueryInfo &AAQI,\n                              bool OrLocal);\n\n  using AAResultBase::getModRefBehavior;\n  FunctionModRefBehavior getModRefBehavior(const Function *F);\n\n  using AAResultBase::getModRefInfo;\n  ModRefInfo getModRefInfo(const CallBase *Call, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n};\n\n/// Analysis pass providing a never-invalidated alias analysis result.\nclass ObjCARCAA : public AnalysisInfoMixin<ObjCARCAA> {\n  friend AnalysisInfoMixin<ObjCARCAA>;\n  static AnalysisKey Key;\n\npublic:\n  typedef ObjCARCAAResult Result;\n\n  ObjCARCAAResult run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Legacy wrapper pass to provide the ObjCARCAAResult object.\nclass ObjCARCAAWrapperPass : public ImmutablePass {\n  std::unique_ptr<ObjCARCAAResult> Result;\n\npublic:\n  static char ID;\n\n  ObjCARCAAWrapperPass();\n\n  ObjCARCAAResult &getResult() { return *Result; }\n  const ObjCARCAAResult &getResult() const { return *Result; }\n\n  bool doInitialization(Module &M) override;\n  bool doFinalization(Module &M) override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n\n} // namespace objcarc\n} // namespace llvm\n\n#endif\n"}, "112": {"id": 112, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h", "content": "//===- SafepointIRVerifier.h - Checks for GC relocation problems *- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a verifier which is useful for enforcing the relocation\n// properties required by a relocating GC.  Specifically, it looks for uses of\n// the unrelocated value of pointer SSA values after a possible safepoint. It\n// attempts to report no false negatives, but may end up reporting false\n// positives in rare cases (see the note at the top of the corresponding cpp\n// file.)\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_SAFEPOINTIRVERIFIER_H\n#define LLVM_IR_SAFEPOINTIRVERIFIER_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\nclass Function;\nclass FunctionPass;\n\n/// Run the safepoint verifier over a single function.  Crashes on failure.\nvoid verifySafepointIR(Function &F);\n\n/// Create an instance of the safepoint verifier pass which can be added to\n/// a pass pipeline to check for relocation bugs.\nFunctionPass *createSafepointIRVerifierPass();\n\n/// Create an instance of the safepoint verifier pass which can be added to\n/// a pass pipeline to check for relocation bugs.\nclass SafepointIRVerifierPass : public PassInfoMixin<SafepointIRVerifierPass> {\n\npublic:\n  explicit SafepointIRVerifierPass() {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n}\n\n#endif // LLVM_IR_SAFEPOINTIRVERIFIER_H\n"}, "154": {"id": 154, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Coroutines/CoroSplit.h", "content": "//===- CoroSplit.h - Converts a coroutine into a state machine -*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// \\file\n// This file declares the pass that builds the coroutine frame and outlines\n// the resume and destroy parts of the coroutine into separate functions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_COROUTINES_COROSPLIT_H\n#define LLVM_TRANSFORMS_COROUTINES_COROSPLIT_H\n\n#include \"llvm/Analysis/CGSCCPassManager.h\"\n#include \"llvm/Analysis/LazyCallGraph.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\nstruct CoroSplitPass : PassInfoMixin<CoroSplitPass> {\n  CoroSplitPass(bool ReuseFrameSlot = false) : ReuseFrameSlot(ReuseFrameSlot) {}\n\n  PreservedAnalyses run(LazyCallGraph::SCC &C, CGSCCAnalysisManager &AM,\n                        LazyCallGraph &CG, CGSCCUpdateResult &UR);\n  static bool isRequired() { return true; }\n\n  bool ReuseFrameSlot;\n};\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_COROUTINES_COROSPLIT_H\n"}, "156": {"id": 156, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/ArgumentPromotion.h", "content": "//===- ArgumentPromotion.h - Promote by-reference arguments -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_IPO_ARGUMENTPROMOTION_H\n#define LLVM_TRANSFORMS_IPO_ARGUMENTPROMOTION_H\n\n#include \"llvm/Analysis/CGSCCPassManager.h\"\n#include \"llvm/Analysis/LazyCallGraph.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\nclass TargetTransformInfo;\n\n/// Argument promotion pass.\n///\n/// This pass walks the functions in each SCC and for each one tries to\n/// transform it and all of its callers to replace indirect arguments with\n/// direct (by-value) arguments.\nclass ArgumentPromotionPass : public PassInfoMixin<ArgumentPromotionPass> {\n  unsigned MaxElements;\n\npublic:\n  ArgumentPromotionPass(unsigned MaxElements = 3u) : MaxElements(MaxElements) {}\n\n  /// Check if callers and the callee \\p F agree how promoted arguments would be\n  /// passed. The ones that they do not agree on are eliminated from the sets but\n  /// the return value has to be observed as well.\n  static bool areFunctionArgsABICompatible(\n      const Function &F, const TargetTransformInfo &TTI,\n      SmallPtrSetImpl<Argument *> &ArgsToPromote,\n      SmallPtrSetImpl<Argument *> &ByValArgsToTransform);\n\n  /// Checks if a type could have padding bytes.\n  static bool isDenselyPacked(Type *type, const DataLayout &DL);\n\n  PreservedAnalyses run(LazyCallGraph::SCC &C, CGSCCAnalysisManager &AM,\n                        LazyCallGraph &CG, CGSCCUpdateResult &UR);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_IPO_ARGUMENTPROMOTION_H\n"}, "158": {"id": 158, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h", "content": "//===- DeadArgumentElimination.h - Eliminate Dead Args ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass deletes dead arguments from internal functions.  Dead argument\n// elimination removes arguments which are directly dead, as well as arguments\n// only passed into function calls as dead arguments of other functions.  This\n// pass also deletes dead return values in a similar way.\n//\n// This pass is often useful as a cleanup pass to run after aggressive\n// interprocedural passes, which add possibly-dead arguments or return values.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_IPO_DEADARGUMENTELIMINATION_H\n#define LLVM_TRANSFORMS_IPO_DEADARGUMENTELIMINATION_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/PassManager.h\"\n#include <map>\n#include <set>\n#include <string>\n#include <tuple>\n\nnamespace llvm {\n\nclass Module;\nclass Use;\nclass Value;\n\n/// Eliminate dead arguments (and return values) from functions.\nclass DeadArgumentEliminationPass\n    : public PassInfoMixin<DeadArgumentEliminationPass> {\npublic:\n  /// Struct that represents (part of) either a return value or a function\n  /// argument.  Used so that arguments and return values can be used\n  /// interchangeably.\n  struct RetOrArg {\n    const Function *F;\n    unsigned Idx;\n    bool IsArg;\n\n    RetOrArg(const Function *F, unsigned Idx, bool IsArg)\n        : F(F), Idx(Idx), IsArg(IsArg) {}\n\n    /// Make RetOrArg comparable, so we can put it into a map.\n    bool operator<(const RetOrArg &O) const {\n      return std::tie(F, Idx, IsArg) < std::tie(O.F, O.Idx, O.IsArg);\n    }\n\n    /// Make RetOrArg comparable, so we can easily iterate the multimap.\n    bool operator==(const RetOrArg &O) const {\n      return F == O.F && Idx == O.Idx && IsArg == O.IsArg;\n    }\n\n    std::string getDescription() const {\n      return (Twine(IsArg ? \"Argument #\" : \"Return value #\") + Twine(Idx) +\n              \" of function \" + F->getName())\n          .str();\n    }\n  };\n\n  /// Liveness enum - During our initial pass over the program, we determine\n  /// that things are either alive or maybe alive. We don't mark anything\n  /// explicitly dead (even if we know they are), since anything not alive\n  /// with no registered uses (in Uses) will never be marked alive and will\n  /// thus become dead in the end.\n  enum Liveness { Live, MaybeLive };\n\n  DeadArgumentEliminationPass(bool ShouldHackArguments_ = false)\n      : ShouldHackArguments(ShouldHackArguments_) {}\n\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &);\n\n  /// Convenience wrapper\n  RetOrArg CreateRet(const Function *F, unsigned Idx) {\n    return RetOrArg(F, Idx, false);\n  }\n\n  /// Convenience wrapper\n  RetOrArg CreateArg(const Function *F, unsigned Idx) {\n    return RetOrArg(F, Idx, true);\n  }\n\n  using UseMap = std::multimap<RetOrArg, RetOrArg>;\n\n  /// This maps a return value or argument to any MaybeLive return values or\n  /// arguments it uses. This allows the MaybeLive values to be marked live\n  /// when any of its users is marked live.\n  /// For example (indices are left out for clarity):\n  ///  - Uses[ret F] = ret G\n  ///    This means that F calls G, and F returns the value returned by G.\n  ///  - Uses[arg F] = ret G\n  ///    This means that some function calls G and passes its result as an\n  ///    argument to F.\n  ///  - Uses[ret F] = arg F\n  ///    This means that F returns one of its own arguments.\n  ///  - Uses[arg F] = arg G\n  ///    This means that G calls F and passes one of its own (G's) arguments\n  ///    directly to F.\n  UseMap Uses;\n\n  using LiveSet = std::set<RetOrArg>;\n  using LiveFuncSet = std::set<const Function *>;\n\n  /// This set contains all values that have been determined to be live.\n  LiveSet LiveValues;\n\n  /// This set contains all values that are cannot be changed in any way.\n  LiveFuncSet LiveFunctions;\n\n  using UseVector = SmallVector<RetOrArg, 5>;\n\n  /// This allows this pass to do double-duty as the dead arg hacking pass\n  /// (used only by bugpoint).\n  bool ShouldHackArguments = false;\n\nprivate:\n  Liveness MarkIfNotLive(RetOrArg Use, UseVector &MaybeLiveUses);\n  Liveness SurveyUse(const Use *U, UseVector &MaybeLiveUses,\n                     unsigned RetValNum = -1U);\n  Liveness SurveyUses(const Value *V, UseVector &MaybeLiveUses);\n\n  void SurveyFunction(const Function &F);\n  bool IsLive(const RetOrArg &RA);\n  void MarkValue(const RetOrArg &RA, Liveness L,\n                 const UseVector &MaybeLiveUses);\n  void MarkLive(const RetOrArg &RA);\n  void MarkLive(const Function &F);\n  void PropagateLiveness(const RetOrArg &RA);\n  bool RemoveDeadStuffFromFunction(Function *F);\n  bool DeleteDeadVarargs(Function &Fn);\n  bool RemoveDeadArgumentsFromCallers(Function &Fn);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_IPO_DEADARGUMENTELIMINATION_H\n"}, "162": {"id": 162, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/LoopExtractor.h", "content": "//===- LoopExtractor.h - Extract each loop into a new function ------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// A pass wrapper around the ExtractLoop() scalar transformation to extract each\n// top-level loop into its own new function. If the loop is the ONLY loop in a\n// given function, it is not touched. This is a pass most useful for debugging\n// via bugpoint.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_IPO_LOOPEXTRACTOR_H\n#define LLVM_TRANSFORMS_IPO_LOOPEXTRACTOR_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\nstruct LoopExtractorPass : public PassInfoMixin<LoopExtractorPass> {\n  LoopExtractorPass(unsigned NumLoops = ~0) : NumLoops(NumLoops) {}\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\nprivate:\n  unsigned NumLoops;\n};\n} // namespace llvm\n\n#endif // LLVM_TRANSFORMS_IPO_LOOPEXTRACTOR_H\n"}, "163": {"id": 163, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h", "content": "//===- LowerTypeTests.h - type metadata lowering pass -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines parts of the type test lowering pass implementation that\n// may be usefully unit tested.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_IPO_LOWERTYPETESTS_H\n#define LLVM_TRANSFORMS_IPO_LOWERTYPETESTS_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/PassManager.h\"\n#include <cstdint>\n#include <cstring>\n#include <limits>\n#include <set>\n#include <vector>\n\nnamespace llvm {\n\nclass Module;\nclass ModuleSummaryIndex;\nclass raw_ostream;\n\nnamespace lowertypetests {\n\nstruct BitSetInfo {\n  // The indices of the set bits in the bitset.\n  std::set<uint64_t> Bits;\n\n  // The byte offset into the combined global represented by the bitset.\n  uint64_t ByteOffset;\n\n  // The size of the bitset in bits.\n  uint64_t BitSize;\n\n  // Log2 alignment of the bit set relative to the combined global.\n  // For example, a log2 alignment of 3 means that bits in the bitset\n  // represent addresses 8 bytes apart.\n  unsigned AlignLog2;\n\n  bool isSingleOffset() const {\n    return Bits.size() == 1;\n  }\n\n  bool isAllOnes() const {\n    return Bits.size() == BitSize;\n  }\n\n  bool containsGlobalOffset(uint64_t Offset) const;\n\n  void print(raw_ostream &OS) const;\n};\n\nstruct BitSetBuilder {\n  SmallVector<uint64_t, 16> Offsets;\n  uint64_t Min = std::numeric_limits<uint64_t>::max();\n  uint64_t Max = 0;\n\n  BitSetBuilder() = default;\n\n  void addOffset(uint64_t Offset) {\n    if (Min > Offset)\n      Min = Offset;\n    if (Max < Offset)\n      Max = Offset;\n\n    Offsets.push_back(Offset);\n  }\n\n  BitSetInfo build();\n};\n\n/// This class implements a layout algorithm for globals referenced by bit sets\n/// that tries to keep members of small bit sets together. This can\n/// significantly reduce bit set sizes in many cases.\n///\n/// It works by assembling fragments of layout from sets of referenced globals.\n/// Each set of referenced globals causes the algorithm to create a new\n/// fragment, which is assembled by appending each referenced global in the set\n/// into the fragment. If a referenced global has already been referenced by an\n/// fragment created earlier, we instead delete that fragment and append its\n/// contents into the fragment we are assembling.\n///\n/// By starting with the smallest fragments, we minimize the size of the\n/// fragments that are copied into larger fragments. This is most intuitively\n/// thought about when considering the case where the globals are virtual tables\n/// and the bit sets represent their derived classes: in a single inheritance\n/// hierarchy, the optimum layout would involve a depth-first search of the\n/// class hierarchy (and in fact the computed layout ends up looking a lot like\n/// a DFS), but a naive DFS would not work well in the presence of multiple\n/// inheritance. This aspect of the algorithm ends up fitting smaller\n/// hierarchies inside larger ones where that would be beneficial.\n///\n/// For example, consider this class hierarchy:\n///\n/// A       B\n///   \\   / | \\\n///     C   D   E\n///\n/// We have five bit sets: bsA (A, C), bsB (B, C, D, E), bsC (C), bsD (D) and\n/// bsE (E). If we laid out our objects by DFS traversing B followed by A, our\n/// layout would be {B, C, D, E, A}. This is optimal for bsB as it needs to\n/// cover the only 4 objects in its hierarchy, but not for bsA as it needs to\n/// cover 5 objects, i.e. the entire layout. Our algorithm proceeds as follows:\n///\n/// Add bsC, fragments {{C}}\n/// Add bsD, fragments {{C}, {D}}\n/// Add bsE, fragments {{C}, {D}, {E}}\n/// Add bsA, fragments {{A, C}, {D}, {E}}\n/// Add bsB, fragments {{B, A, C, D, E}}\n///\n/// This layout is optimal for bsA, as it now only needs to cover two (i.e. 3\n/// fewer) objects, at the cost of bsB needing to cover 1 more object.\n///\n/// The bit set lowering pass assigns an object index to each object that needs\n/// to be laid out, and calls addFragment for each bit set passing the object\n/// indices of its referenced globals. It then assembles a layout from the\n/// computed layout in the Fragments field.\nstruct GlobalLayoutBuilder {\n  /// The computed layout. Each element of this vector contains a fragment of\n  /// layout (which may be empty) consisting of object indices.\n  std::vector<std::vector<uint64_t>> Fragments;\n\n  /// Mapping from object index to fragment index.\n  std::vector<uint64_t> FragmentMap;\n\n  GlobalLayoutBuilder(uint64_t NumObjects)\n      : Fragments(1), FragmentMap(NumObjects) {}\n\n  /// Add F to the layout while trying to keep its indices contiguous.\n  /// If a previously seen fragment uses any of F's indices, that\n  /// fragment will be laid out inside F.\n  void addFragment(const std::set<uint64_t> &F);\n};\n\n/// This class is used to build a byte array containing overlapping bit sets. By\n/// loading from indexed offsets into the byte array and applying a mask, a\n/// program can test bits from the bit set with a relatively short instruction\n/// sequence. For example, suppose we have 15 bit sets to lay out:\n///\n/// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),\n/// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),\n/// L (4 bits), M (3 bits), N (2 bits), O (1 bit)\n///\n/// These bits can be laid out in a 16-byte array like this:\n///\n///       Byte Offset\n///     0123456789ABCDEF\n/// Bit\n///   7 HHHHHHHHHIIIIIII\n///   6 GGGGGGGGGGJJJJJJ\n///   5 FFFFFFFFFFFKKKKK\n///   4 EEEEEEEEEEEELLLL\n///   3 DDDDDDDDDDDDDMMM\n///   2 CCCCCCCCCCCCCCNN\n///   1 BBBBBBBBBBBBBBBO\n///   0 AAAAAAAAAAAAAAAA\n///\n/// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to\n/// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done\n/// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.\n///\n/// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,\n/// because for one thing it gives us better packing (the more bins there are,\n/// the less evenly they will be filled), and for another, the instruction\n/// sequences can be slightly shorter, both on x86 and ARM.\nstruct ByteArrayBuilder {\n  /// The byte array built so far.\n  std::vector<uint8_t> Bytes;\n\n  enum { BitsPerByte = 8 };\n\n  /// The number of bytes allocated so far for each of the bits.\n  uint64_t BitAllocs[BitsPerByte];\n\n  ByteArrayBuilder() {\n    memset(BitAllocs, 0, sizeof(BitAllocs));\n  }\n\n  /// Allocate BitSize bits in the byte array where Bits contains the bits to\n  /// set. AllocByteOffset is set to the offset within the byte array and\n  /// AllocMask is set to the bitmask for those bits. This uses the LPT (Longest\n  /// Processing Time) multiprocessor scheduling algorithm to lay out the bits\n  /// efficiently; the pass allocates bit sets in decreasing size order.\n  void allocate(const std::set<uint64_t> &Bits, uint64_t BitSize,\n                uint64_t &AllocByteOffset, uint8_t &AllocMask);\n};\n\nbool isJumpTableCanonical(Function *F);\n\n} // end namespace lowertypetests\n\nclass LowerTypeTestsPass : public PassInfoMixin<LowerTypeTestsPass> {\n  bool UseCommandLine = false;\n\n  ModuleSummaryIndex *ExportSummary = nullptr;\n  const ModuleSummaryIndex *ImportSummary = nullptr;\n  bool DropTypeTests = true;\n\npublic:\n  LowerTypeTestsPass() : UseCommandLine(true) {}\n  LowerTypeTestsPass(ModuleSummaryIndex *ExportSummary,\n                     const ModuleSummaryIndex *ImportSummary,\n                     bool DropTypeTests = false)\n      : ExportSummary(ExportSummary), ImportSummary(ImportSummary),\n        DropTypeTests(DropTypeTests) {}\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_IPO_LOWERTYPETESTS_H\n"}, "164": {"id": 164, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h", "content": "//===- SampleProfile.h - SamplePGO pass ---------- --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file provides the interface for the sampled PGO loader pass.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_IPO_SAMPLEPROFILE_H\n#define LLVM_TRANSFORMS_IPO_SAMPLEPROFILE_H\n\n#include \"llvm/IR/PassManager.h\"\n#include <string>\n\nnamespace llvm {\n\nclass Module;\n\n/// The sample profiler data loader pass.\nclass SampleProfileLoaderPass : public PassInfoMixin<SampleProfileLoaderPass> {\npublic:\n  SampleProfileLoaderPass(\n      std::string File = \"\", std::string RemappingFile = \"\",\n      ThinOrFullLTOPhase LTOPhase = ThinOrFullLTOPhase::None)\n      : ProfileFileName(File), ProfileRemappingFileName(RemappingFile),\n        LTOPhase(LTOPhase) {}\n\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\nprivate:\n  std::string ProfileFileName;\n  std::string ProfileRemappingFileName;\n  ThinOrFullLTOPhase LTOPhase;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_IPO_SAMPLEPROFILE_H\n"}, "166": {"id": 166, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h", "content": "//===- WholeProgramDevirt.h - Whole-program devirt pass ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines parts of the whole-program devirtualization pass\n// implementation that may be usefully unit tested.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_IPO_WHOLEPROGRAMDEVIRT_H\n#define LLVM_TRANSFORMS_IPO_WHOLEPROGRAMDEVIRT_H\n\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Transforms/IPO/FunctionImport.h\"\n#include <cassert>\n#include <cstdint>\n#include <set>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\ntemplate <typename T> class MutableArrayRef;\nclass Function;\nclass GlobalVariable;\nclass ModuleSummaryIndex;\nstruct ValueInfo;\n\nnamespace wholeprogramdevirt {\n\n// A bit vector that keeps track of which bits are used. We use this to\n// pack constant values compactly before and after each virtual table.\nstruct AccumBitVector {\n  std::vector<uint8_t> Bytes;\n\n  // Bits in BytesUsed[I] are 1 if matching bit in Bytes[I] is used, 0 if not.\n  std::vector<uint8_t> BytesUsed;\n\n  std::pair<uint8_t *, uint8_t *> getPtrToData(uint64_t Pos, uint8_t Size) {\n    if (Bytes.size() < Pos + Size) {\n      Bytes.resize(Pos + Size);\n      BytesUsed.resize(Pos + Size);\n    }\n    return std::make_pair(Bytes.data() + Pos, BytesUsed.data() + Pos);\n  }\n\n  // Set little-endian value Val with size Size at bit position Pos,\n  // and mark bytes as used.\n  void setLE(uint64_t Pos, uint64_t Val, uint8_t Size) {\n    assert(Pos % 8 == 0);\n    auto DataUsed = getPtrToData(Pos / 8, Size);\n    for (unsigned I = 0; I != Size; ++I) {\n      DataUsed.first[I] = Val >> (I * 8);\n      assert(!DataUsed.second[I]);\n      DataUsed.second[I] = 0xff;\n    }\n  }\n\n  // Set big-endian value Val with size Size at bit position Pos,\n  // and mark bytes as used.\n  void setBE(uint64_t Pos, uint64_t Val, uint8_t Size) {\n    assert(Pos % 8 == 0);\n    auto DataUsed = getPtrToData(Pos / 8, Size);\n    for (unsigned I = 0; I != Size; ++I) {\n      DataUsed.first[Size - I - 1] = Val >> (I * 8);\n      assert(!DataUsed.second[Size - I - 1]);\n      DataUsed.second[Size - I - 1] = 0xff;\n    }\n  }\n\n  // Set bit at bit position Pos to b and mark bit as used.\n  void setBit(uint64_t Pos, bool b) {\n    auto DataUsed = getPtrToData(Pos / 8, 1);\n    if (b)\n      *DataUsed.first |= 1 << (Pos % 8);\n    assert(!(*DataUsed.second & (1 << Pos % 8)));\n    *DataUsed.second |= 1 << (Pos % 8);\n  }\n};\n\n// The bits that will be stored before and after a particular vtable.\nstruct VTableBits {\n  // The vtable global.\n  GlobalVariable *GV;\n\n  // Cache of the vtable's size in bytes.\n  uint64_t ObjectSize = 0;\n\n  // The bit vector that will be laid out before the vtable. Note that these\n  // bytes are stored in reverse order until the globals are rebuilt. This means\n  // that any values in the array must be stored using the opposite endianness\n  // from the target.\n  AccumBitVector Before;\n\n  // The bit vector that will be laid out after the vtable.\n  AccumBitVector After;\n};\n\n// Information about a member of a particular type identifier.\nstruct TypeMemberInfo {\n  // The VTableBits for the vtable.\n  VTableBits *Bits;\n\n  // The offset in bytes from the start of the vtable (i.e. the address point).\n  uint64_t Offset;\n\n  bool operator<(const TypeMemberInfo &other) const {\n    return Bits < other.Bits || (Bits == other.Bits && Offset < other.Offset);\n  }\n};\n\n// A virtual call target, i.e. an entry in a particular vtable.\nstruct VirtualCallTarget {\n  VirtualCallTarget(Function *Fn, const TypeMemberInfo *TM);\n\n  // For testing only.\n  VirtualCallTarget(const TypeMemberInfo *TM, bool IsBigEndian)\n      : Fn(nullptr), TM(TM), IsBigEndian(IsBigEndian), WasDevirt(false) {}\n\n  // The function stored in the vtable.\n  Function *Fn;\n\n  // A pointer to the type identifier member through which the pointer to Fn is\n  // accessed.\n  const TypeMemberInfo *TM;\n\n  // When doing virtual constant propagation, this stores the return value for\n  // the function when passed the currently considered argument list.\n  uint64_t RetVal;\n\n  // Whether the target is big endian.\n  bool IsBigEndian;\n\n  // Whether at least one call site to the target was devirtualized.\n  bool WasDevirt;\n\n  // The minimum byte offset before the address point. This covers the bytes in\n  // the vtable object before the address point (e.g. RTTI, access-to-top,\n  // vtables for other base classes) and is equal to the offset from the start\n  // of the vtable object to the address point.\n  uint64_t minBeforeBytes() const { return TM->Offset; }\n\n  // The minimum byte offset after the address point. This covers the bytes in\n  // the vtable object after the address point (e.g. the vtable for the current\n  // class and any later base classes) and is equal to the size of the vtable\n  // object minus the offset from the start of the vtable object to the address\n  // point.\n  uint64_t minAfterBytes() const { return TM->Bits->ObjectSize - TM->Offset; }\n\n  // The number of bytes allocated (for the vtable plus the byte array) before\n  // the address point.\n  uint64_t allocatedBeforeBytes() const {\n    return minBeforeBytes() + TM->Bits->Before.Bytes.size();\n  }\n\n  // The number of bytes allocated (for the vtable plus the byte array) after\n  // the address point.\n  uint64_t allocatedAfterBytes() const {\n    return minAfterBytes() + TM->Bits->After.Bytes.size();\n  }\n\n  // Set the bit at position Pos before the address point to RetVal.\n  void setBeforeBit(uint64_t Pos) {\n    assert(Pos >= 8 * minBeforeBytes());\n    TM->Bits->Before.setBit(Pos - 8 * minBeforeBytes(), RetVal);\n  }\n\n  // Set the bit at position Pos after the address point to RetVal.\n  void setAfterBit(uint64_t Pos) {\n    assert(Pos >= 8 * minAfterBytes());\n    TM->Bits->After.setBit(Pos - 8 * minAfterBytes(), RetVal);\n  }\n\n  // Set the bytes at position Pos before the address point to RetVal.\n  // Because the bytes in Before are stored in reverse order, we use the\n  // opposite endianness to the target.\n  void setBeforeBytes(uint64_t Pos, uint8_t Size) {\n    assert(Pos >= 8 * minBeforeBytes());\n    if (IsBigEndian)\n      TM->Bits->Before.setLE(Pos - 8 * minBeforeBytes(), RetVal, Size);\n    else\n      TM->Bits->Before.setBE(Pos - 8 * minBeforeBytes(), RetVal, Size);\n  }\n\n  // Set the bytes at position Pos after the address point to RetVal.\n  void setAfterBytes(uint64_t Pos, uint8_t Size) {\n    assert(Pos >= 8 * minAfterBytes());\n    if (IsBigEndian)\n      TM->Bits->After.setBE(Pos - 8 * minAfterBytes(), RetVal, Size);\n    else\n      TM->Bits->After.setLE(Pos - 8 * minAfterBytes(), RetVal, Size);\n  }\n};\n\n// Find the minimum offset that we may store a value of size Size bits at. If\n// IsAfter is set, look for an offset before the object, otherwise look for an\n// offset after the object.\nuint64_t findLowestOffset(ArrayRef<VirtualCallTarget> Targets, bool IsAfter,\n                          uint64_t Size);\n\n// Set the stored value in each of Targets to VirtualCallTarget::RetVal at the\n// given allocation offset before the vtable address. Stores the computed\n// byte/bit offset to OffsetByte/OffsetBit.\nvoid setBeforeReturnValues(MutableArrayRef<VirtualCallTarget> Targets,\n                           uint64_t AllocBefore, unsigned BitWidth,\n                           int64_t &OffsetByte, uint64_t &OffsetBit);\n\n// Set the stored value in each of Targets to VirtualCallTarget::RetVal at the\n// given allocation offset after the vtable address. Stores the computed\n// byte/bit offset to OffsetByte/OffsetBit.\nvoid setAfterReturnValues(MutableArrayRef<VirtualCallTarget> Targets,\n                          uint64_t AllocAfter, unsigned BitWidth,\n                          int64_t &OffsetByte, uint64_t &OffsetBit);\n\n} // end namespace wholeprogramdevirt\n\nstruct WholeProgramDevirtPass : public PassInfoMixin<WholeProgramDevirtPass> {\n  ModuleSummaryIndex *ExportSummary;\n  const ModuleSummaryIndex *ImportSummary;\n  bool UseCommandLine = false;\n  WholeProgramDevirtPass()\n      : ExportSummary(nullptr), ImportSummary(nullptr), UseCommandLine(true) {}\n  WholeProgramDevirtPass(ModuleSummaryIndex *ExportSummary,\n                         const ModuleSummaryIndex *ImportSummary)\n      : ExportSummary(ExportSummary), ImportSummary(ImportSummary) {\n    assert(!(ExportSummary && ImportSummary));\n  }\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &);\n};\n\nstruct VTableSlotSummary {\n  StringRef TypeID;\n  uint64_t ByteOffset;\n};\n\nvoid updateVCallVisibilityInModule(\n    Module &M, bool WholeProgramVisibilityEnabledInLTO,\n    const DenseSet<GlobalValue::GUID> &DynamicExportSymbols);\nvoid updateVCallVisibilityInIndex(\n    ModuleSummaryIndex &Index, bool WholeProgramVisibilityEnabledInLTO,\n    const DenseSet<GlobalValue::GUID> &DynamicExportSymbols);\n\n/// Perform index-based whole program devirtualization on the \\p Summary\n/// index. Any devirtualized targets used by a type test in another module\n/// are added to the \\p ExportedGUIDs set. For any local devirtualized targets\n/// only used within the defining module, the information necessary for\n/// locating the corresponding WPD resolution is recorded for the ValueInfo\n/// in case it is exported by cross module importing (in which case the\n/// devirtualized target name will need adjustment).\nvoid runWholeProgramDevirtOnIndex(\n    ModuleSummaryIndex &Summary, std::set<GlobalValue::GUID> &ExportedGUIDs,\n    std::map<ValueInfo, std::vector<VTableSlotSummary>> &LocalWPDTargetsMap);\n\n/// Call after cross-module importing to update the recorded single impl\n/// devirt target names for any locals that were exported.\nvoid updateIndexWPDForExports(\n    ModuleSummaryIndex &Summary,\n    function_ref<bool(StringRef, ValueInfo)> isExported,\n    std::map<ValueInfo, std::vector<VTableSlotSummary>> &LocalWPDTargetsMap);\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_IPO_WHOLEPROGRAMDEVIRT_H\n"}, "168": {"id": 168, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizer.h", "content": "//===--------- Definition of the AddressSanitizer class ---------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the AddressSanitizer class which is a port of the legacy\n// AddressSanitizer pass to use the new PassManager infrastructure.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_ADDRESSSANITIZER_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_ADDRESSSANITIZER_H\n\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Transforms/Instrumentation/AddressSanitizerOptions.h\"\n\nnamespace llvm {\n\n/// Frontend-provided metadata for source location.\nstruct LocationMetadata {\n  StringRef Filename;\n  int LineNo = 0;\n  int ColumnNo = 0;\n\n  LocationMetadata() = default;\n\n  bool empty() const { return Filename.empty(); }\n  void parse(MDNode *MDN);\n};\n\n/// Frontend-provided metadata for global variables.\nclass GlobalsMetadata {\npublic:\n  struct Entry {\n    LocationMetadata SourceLoc;\n    StringRef Name;\n    bool IsDynInit = false;\n    bool IsExcluded = false;\n\n    Entry() = default;\n  };\n\n  /// Create a default uninitialized GlobalsMetadata instance.\n  GlobalsMetadata() = default;\n\n  /// Create an initialized GlobalsMetadata instance.\n  GlobalsMetadata(Module &M);\n\n  /// Returns metadata entry for a given global.\n  Entry get(GlobalVariable *G) const {\n    auto Pos = Entries.find(G);\n    return (Pos != Entries.end()) ? Pos->second : Entry();\n  }\n\n  /// Handle invalidation from the pass manager.\n  /// These results are never invalidated.\n  bool invalidate(Module &, const PreservedAnalyses &,\n                  ModuleAnalysisManager::Invalidator &) {\n    return false;\n  }\n  bool invalidate(Function &, const PreservedAnalyses &,\n                  FunctionAnalysisManager::Invalidator &) {\n    return false;\n  }\n\nprivate:\n  DenseMap<GlobalVariable *, Entry> Entries;\n};\n\n/// The ASanGlobalsMetadataAnalysis initializes and returns a GlobalsMetadata\n/// object. More specifically, ASan requires looking at all globals registered\n/// in 'llvm.asan.globals' before running, which only depends on reading module\n/// level metadata. This analysis is required to run before running the\n/// AddressSanitizerPass since it collects that metadata.\n/// The legacy pass manager equivalent of this is ASanGlobalsMetadataLegacyPass.\nclass ASanGlobalsMetadataAnalysis\n    : public AnalysisInfoMixin<ASanGlobalsMetadataAnalysis> {\npublic:\n  using Result = GlobalsMetadata;\n\n  Result run(Module &, ModuleAnalysisManager &);\n\nprivate:\n  friend AnalysisInfoMixin<ASanGlobalsMetadataAnalysis>;\n  static AnalysisKey Key;\n};\n\n/// Public interface to the address sanitizer pass for instrumenting code to\n/// check for various memory errors at runtime.\n///\n/// The sanitizer itself is a function pass that works by inserting various\n/// calls to the ASan runtime library functions. The runtime library essentially\n/// replaces malloc() and free() with custom implementations that allow regions\n/// surrounding requested memory to be checked for invalid accesses.\nclass AddressSanitizerPass : public PassInfoMixin<AddressSanitizerPass> {\npublic:\n  explicit AddressSanitizerPass(bool CompileKernel = false,\n                                bool Recover = false,\n                                bool UseAfterScope = false);\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n  static bool isRequired() { return true; }\n\nprivate:\n  bool CompileKernel;\n  bool Recover;\n  bool UseAfterScope;\n};\n\n/// Public interface to the address sanitizer module pass for instrumenting code\n/// to check for various memory errors.\n///\n/// This adds 'asan.module_ctor' to 'llvm.global_ctors'. This pass may also\n/// run intependently of the function address sanitizer.\nclass ModuleAddressSanitizerPass\n    : public PassInfoMixin<ModuleAddressSanitizerPass> {\npublic:\n  explicit ModuleAddressSanitizerPass(\n      bool CompileKernel = false, bool Recover = false, bool UseGlobalGC = true,\n      bool UseOdrIndicator = false,\n      AsanDtorKind DestructorKind = AsanDtorKind::Global);\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n  static bool isRequired() { return true; }\n\nprivate:\n  bool CompileKernel;\n  bool Recover;\n  bool UseGlobalGC;\n  bool UseOdrIndicator;\n  AsanDtorKind DestructorKind;\n};\n\n// Insert AddressSanitizer (address sanity checking) instrumentation\nFunctionPass *createAddressSanitizerFunctionPass(bool CompileKernel = false,\n                                                 bool Recover = false,\n                                                 bool UseAfterScope = false);\nModulePass *createModuleAddressSanitizerLegacyPassPass(\n    bool CompileKernel = false, bool Recover = false, bool UseGlobalsGC = true,\n    bool UseOdrIndicator = true,\n    AsanDtorKind DestructorKind = AsanDtorKind::Global);\n\n} // namespace llvm\n\n#endif\n"}, "169": {"id": 169, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ControlHeightReduction.h", "content": "//===- ControlHeightReduction.h - Control Height Reduction ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass merges conditional blocks of code and reduces the number of\n// conditional branches in the hot paths based on profiles.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_CONTROLHEIGHTREDUCTION_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_CONTROLHEIGHTREDUCTION_H\n\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\nclass ControlHeightReductionPass :\n      public PassInfoMixin<ControlHeightReductionPass> {\npublic:\n  ControlHeightReductionPass();\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM);\n};\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_INSTRUMENTATION_CONTROLHEIGHTREDUCTION_H\n"}, "170": {"id": 170, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/DataFlowSanitizer.h", "content": "//===- DataFlowSanitizer.h - dynamic data flow analysis -------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_DATAFLOWSANITIZER_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_DATAFLOWSANITIZER_H\n\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass DataFlowSanitizerPass : public PassInfoMixin<DataFlowSanitizerPass> {\nprivate:\n  std::vector<std::string> ABIListFiles;\n\npublic:\n  DataFlowSanitizerPass(\n      const std::vector<std::string> &ABIListFiles = std::vector<std::string>())\n      : ABIListFiles(ABIListFiles) {}\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n  static bool isRequired() { return true; }\n};\n\n} // namespace llvm\n\n#endif\n"}, "171": {"id": 171, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/GCOVProfiler.h", "content": "//===- Transforms/Instrumentation/GCOVProfiler.h ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file provides the interface for the GCOV style profiler  pass.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_GCOVPROFILER_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_GCOVPROFILER_H\n\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Transforms/Instrumentation.h\"\n\nnamespace llvm {\n/// The gcov-style instrumentation pass\nclass GCOVProfilerPass : public PassInfoMixin<GCOVProfilerPass> {\npublic:\n  GCOVProfilerPass(const GCOVOptions &Options = GCOVOptions::getDefault()) : GCOVOpts(Options) { }\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\nprivate:\n  GCOVOptions GCOVOpts;\n};\n\n} // namespace llvm\n#endif\n"}, "172": {"id": 172, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/HWAddressSanitizer.h", "content": "//===--------- Definition of the HWAddressSanitizer class -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Hardware AddressSanitizer class which is a port of the\n// legacy HWAddressSanitizer pass to use the new PassManager infrastructure.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_HWADDRESSSANITIZER_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_HWADDRESSSANITIZER_H\n\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\n/// This is a public interface to the hardware address sanitizer pass for\n/// instrumenting code to check for various memory errors at runtime, similar to\n/// AddressSanitizer but based on partial hardware assistance.\nclass HWAddressSanitizerPass : public PassInfoMixin<HWAddressSanitizerPass> {\npublic:\n  explicit HWAddressSanitizerPass(bool CompileKernel = false,\n                                  bool Recover = false);\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &MAM);\n  static bool isRequired() { return true; }\n\nprivate:\n  bool CompileKernel;\n  bool Recover;\n};\n\nFunctionPass *createHWAddressSanitizerLegacyPassPass(bool CompileKernel = false,\n                                                     bool Recover = false);\n\nnamespace HWASanAccessInfo {\n\n// Bit field positions for the accessinfo parameter to\n// llvm.hwasan.check.memaccess. Shared between the pass and the backend. Bits\n// 0-15 are also used by the runtime.\nenum {\n  AccessSizeShift = 0, // 4 bits\n  IsWriteShift = 4,\n  RecoverShift = 5,\n  MatchAllShift = 16, // 8 bits\n  HasMatchAllShift = 24,\n  CompileKernelShift = 25,\n};\n\nenum { RuntimeMask = 0xffff };\n\n} // namespace HWASanAccessInfo\n\n} // namespace llvm\n\n#endif\n"}, "173": {"id": 173, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/InstrProfiling.h", "content": "//===- Transforms/Instrumentation/InstrProfiling.h --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file provides the interface for LLVM's PGO Instrumentation lowering\n/// pass.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_INSTRPROFILING_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_INSTRPROFILING_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/ProfileData/InstrProf.h\"\n#include \"llvm/Transforms/Instrumentation.h\"\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <vector>\n\nnamespace llvm {\n\nclass TargetLibraryInfo;\nusing LoadStorePair = std::pair<Instruction *, Instruction *>;\n\n/// Instrumentation based profiling lowering pass. This pass lowers\n/// the profile instrumented code generated by FE or the IR based\n/// instrumentation pass.\nclass InstrProfiling : public PassInfoMixin<InstrProfiling> {\npublic:\n  InstrProfiling() : IsCS(false) {}\n  InstrProfiling(const InstrProfOptions &Options, bool IsCS = false)\n      : Options(Options), IsCS(IsCS) {}\n\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n  bool run(Module &M,\n           std::function<const TargetLibraryInfo &(Function &F)> GetTLI);\n\nprivate:\n  InstrProfOptions Options;\n  Module *M;\n  Triple TT;\n  std::function<const TargetLibraryInfo &(Function &F)> GetTLI;\n  struct PerFunctionProfileData {\n    uint32_t NumValueSites[IPVK_Last + 1];\n    GlobalVariable *RegionCounters = nullptr;\n    GlobalVariable *DataVar = nullptr;\n\n    PerFunctionProfileData() {\n      memset(NumValueSites, 0, sizeof(uint32_t) * (IPVK_Last + 1));\n    }\n  };\n  DenseMap<GlobalVariable *, PerFunctionProfileData> ProfileDataMap;\n  std::vector<GlobalValue *> CompilerUsedVars;\n  std::vector<GlobalValue *> UsedVars;\n  std::vector<GlobalVariable *> ReferencedNames;\n  GlobalVariable *NamesVar;\n  size_t NamesSize;\n\n  // Is this lowering for the context-sensitive instrumentation.\n  bool IsCS;\n\n  // vector of counter load/store pairs to be register promoted.\n  std::vector<LoadStorePair> PromotionCandidates;\n\n  int64_t TotalCountersPromoted = 0;\n\n  /// Lower instrumentation intrinsics in the function. Returns true if there\n  /// any lowering.\n  bool lowerIntrinsics(Function *F);\n\n  /// Register-promote counter loads and stores in loops.\n  void promoteCounterLoadStores(Function *F);\n\n  /// Returns true if relocating counters at runtime is enabled.\n  bool isRuntimeCounterRelocationEnabled() const;\n\n  /// Returns true if profile counter update register promotion is enabled.\n  bool isCounterPromotionEnabled() const;\n\n  /// Count the number of instrumented value sites for the function.\n  void computeNumValueSiteCounts(InstrProfValueProfileInst *Ins);\n\n  /// Replace instrprof_value_profile with a call to runtime library.\n  void lowerValueProfileInst(InstrProfValueProfileInst *Ins);\n\n  /// Replace instrprof_increment with an increment of the appropriate value.\n  void lowerIncrement(InstrProfIncrementInst *Inc);\n\n  /// Force emitting of name vars for unused functions.\n  void lowerCoverageData(GlobalVariable *CoverageNamesVar);\n\n  /// Get the region counters for an increment, creating them if necessary.\n  ///\n  /// If the counter array doesn't yet exist, the profile data variables\n  /// referring to them will also be created.\n  GlobalVariable *getOrCreateRegionCounters(InstrProfIncrementInst *Inc);\n\n  /// Emit the section with compressed function names.\n  void emitNameData();\n\n  /// Emit value nodes section for value profiling.\n  void emitVNodes();\n\n  /// Emit runtime registration functions for each profile data variable.\n  void emitRegistration();\n\n  /// Emit the necessary plumbing to pull in the runtime initialization.\n  /// Returns true if a change was made.\n  bool emitRuntimeHook();\n\n  /// Add uses of our data variables and runtime hook.\n  void emitUses();\n\n  /// Create a static initializer for our data, on platforms that need it,\n  /// and for any profile output file that was specified.\n  void emitInitialization();\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_INSTRUMENTATION_INSTRPROFILING_H\n"}, "174": {"id": 174, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h", "content": "//===--------- Definition of the MemProfiler class --------------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the MemProfiler class.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_MEMPROFILER_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_MEMPROFILER_H\n\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\n/// Public interface to the memory profiler pass for instrumenting code to\n/// profile memory accesses.\n///\n/// The profiler itself is a function pass that works by inserting various\n/// calls to the MemProfiler runtime library functions. The runtime library\n/// essentially replaces malloc() and free() with custom implementations that\n/// record data about the allocations.\nclass MemProfilerPass : public PassInfoMixin<MemProfilerPass> {\npublic:\n  explicit MemProfilerPass();\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n  static bool isRequired() { return true; }\n};\n\n/// Public interface to the memory profiler module pass for instrumenting code\n/// to profile memory allocations and accesses.\nclass ModuleMemProfilerPass : public PassInfoMixin<ModuleMemProfilerPass> {\npublic:\n  explicit ModuleMemProfilerPass();\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n  static bool isRequired() { return true; }\n};\n\n// Insert MemProfiler instrumentation\nFunctionPass *createMemProfilerFunctionPass();\nModulePass *createModuleMemProfilerLegacyPassPass();\n\n} // namespace llvm\n\n#endif\n"}, "175": {"id": 175, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemorySanitizer.h", "content": "//===- Transforms/Instrumentation/MemorySanitizer.h - MSan Pass -----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the memoy sanitizer pass.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_MEMORYSANITIZER_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_MEMORYSANITIZER_H\n\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n\nnamespace llvm {\n\nstruct MemorySanitizerOptions {\n  MemorySanitizerOptions() : MemorySanitizerOptions(0, false, false){};\n  MemorySanitizerOptions(int TrackOrigins, bool Recover, bool Kernel);\n  bool Kernel;\n  int TrackOrigins;\n  bool Recover;\n};\n\n// Insert MemorySanitizer instrumentation (detection of uninitialized reads)\nFunctionPass *\ncreateMemorySanitizerLegacyPassPass(MemorySanitizerOptions Options = {});\n\n/// A function pass for msan instrumentation.\n///\n/// Instruments functions to detect unitialized reads. This function pass\n/// inserts calls to runtime library functions. If the functions aren't declared\n/// yet, the pass inserts the declarations. Otherwise the existing globals are\n/// used.\nstruct MemorySanitizerPass : public PassInfoMixin<MemorySanitizerPass> {\n  MemorySanitizerPass(MemorySanitizerOptions Options) : Options(Options) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM);\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n  static bool isRequired() { return true; }\n\nprivate:\n  MemorySanitizerOptions Options;\n};\n}\n\n#endif /* LLVM_TRANSFORMS_INSTRUMENTATION_MEMORYSANITIZER_H */\n"}, "176": {"id": 176, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h", "content": "//===- Transforms/Instrumentation/PGOInstrumentation.h ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file provides the interface for IR based instrumentation passes (\n/// (profile-gen, and profile-use).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_PGOINSTRUMENTATION_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_PGOINSTRUMENTATION_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/IR/PassManager.h\"\n#include <cstdint>\n#include <string>\n\nnamespace llvm {\n\nclass Function;\nclass Instruction;\nclass Module;\n\n/// The instrumentation (profile-instr-gen) pass for IR based PGO.\n// We use this pass to create COMDAT profile variables for context\n// sensitive PGO (CSPGO). The reason to have a pass for this is CSPGO\n// can be run after LTO/ThinLTO linking. Lld linker needs to see\n// all the COMDAT variables before linking. So we have this pass\n// always run before linking for CSPGO.\nclass PGOInstrumentationGenCreateVar\n    : public PassInfoMixin<PGOInstrumentationGenCreateVar> {\npublic:\n  PGOInstrumentationGenCreateVar(std::string CSInstrName = \"\")\n      : CSInstrName(CSInstrName) {}\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\nprivate:\n  std::string CSInstrName;\n};\n\n/// The instrumentation (profile-instr-gen) pass for IR based PGO.\nclass PGOInstrumentationGen : public PassInfoMixin<PGOInstrumentationGen> {\npublic:\n  PGOInstrumentationGen(bool IsCS = false) : IsCS(IsCS) {}\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\nprivate:\n  // If this is a context sensitive instrumentation.\n  bool IsCS;\n};\n\n/// The profile annotation (profile-instr-use) pass for IR based PGO.\nclass PGOInstrumentationUse : public PassInfoMixin<PGOInstrumentationUse> {\npublic:\n  PGOInstrumentationUse(std::string Filename = \"\",\n                        std::string RemappingFilename = \"\", bool IsCS = false);\n\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\nprivate:\n  std::string ProfileFileName;\n  std::string ProfileRemappingFileName;\n  // If this is a context sensitive instrumentation.\n  bool IsCS;\n};\n\n/// The indirect function call promotion pass.\nclass PGOIndirectCallPromotion : public PassInfoMixin<PGOIndirectCallPromotion> {\npublic:\n  PGOIndirectCallPromotion(bool IsInLTO = false, bool SamplePGO = false)\n      : InLTO(IsInLTO), SamplePGO(SamplePGO) {}\n\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\nprivate:\n  bool InLTO;\n  bool SamplePGO;\n};\n\n/// The profile size based optimization pass for memory intrinsics.\nclass PGOMemOPSizeOpt : public PassInfoMixin<PGOMemOPSizeOpt> {\npublic:\n  PGOMemOPSizeOpt() = default;\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\nvoid setProfMetadata(Module *M, Instruction *TI, ArrayRef<uint64_t> EdgeCounts,\n                     uint64_t MaxCount);\n\nvoid setIrrLoopHeaderMetadata(Module *M, Instruction *TI, uint64_t Count);\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_INSTRUMENTATION_PGOINSTRUMENTATION_H\n"}, "177": {"id": 177, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/SanitizerCoverage.h", "content": "//===--------- Definition of the SanitizerCoverage class --------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SanitizerCoverage class which is a port of the legacy\n// SanitizerCoverage pass to use the new PassManager infrastructure.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_INSTRUMENTATION_SANITIZERCOVERAGE_H\n#define LLVM_TRANSFORMS_INSTRUMENTATION_SANITIZERCOVERAGE_H\n\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Support/SpecialCaseList.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Transforms/Instrumentation.h\"\n\nnamespace llvm {\n\n/// This is the ModuleSanitizerCoverage pass used in the new pass manager. The\n/// pass instruments functions for coverage, adds initialization calls to the\n/// module for trace PC guards and 8bit counters if they are requested, and\n/// appends globals to llvm.compiler.used.\nclass ModuleSanitizerCoveragePass\n    : public PassInfoMixin<ModuleSanitizerCoveragePass> {\npublic:\n  explicit ModuleSanitizerCoveragePass(\n      SanitizerCoverageOptions Options = SanitizerCoverageOptions(),\n      const std::vector<std::string> &AllowlistFiles =\n          std::vector<std::string>(),\n      const std::vector<std::string> &BlocklistFiles =\n          std::vector<std::string>())\n      : Options(Options) {\n    if (AllowlistFiles.size() > 0)\n      Allowlist = SpecialCaseList::createOrDie(AllowlistFiles,\n                                               *vfs::getRealFileSystem());\n    if (BlocklistFiles.size() > 0)\n      Blocklist = SpecialCaseList::createOrDie(BlocklistFiles,\n                                               *vfs::getRealFileSystem());\n  }\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n  static bool isRequired() { return true; }\n\nprivate:\n  SanitizerCoverageOptions Options;\n\n  std::unique_ptr<SpecialCaseList> Allowlist;\n  std::unique_ptr<SpecialCaseList> Blocklist;\n};\n\n// Insert SanitizerCoverage instrumentation.\nModulePass *createModuleSanitizerCoverageLegacyPassPass(\n    const SanitizerCoverageOptions &Options = SanitizerCoverageOptions(),\n    const std::vector<std::string> &AllowlistFiles = std::vector<std::string>(),\n    const std::vector<std::string> &BlocklistFiles =\n        std::vector<std::string>());\n\n} // namespace llvm\n\n#endif\n"}, "178": {"id": 178, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h", "content": "//===- EarlyCSE.h - Simple and fast CSE pass --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file provides the interface for a simple, fast CSE pass.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_EARLYCSE_H\n#define LLVM_TRANSFORMS_SCALAR_EARLYCSE_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\nclass Function;\n\n/// A simple and fast domtree-based CSE pass.\n///\n/// This pass does a simple depth-first walk over the dominator tree,\n/// eliminating trivially redundant instructions and using instsimplify to\n/// canonicalize things as it goes. It is intended to be fast and catch obvious\n/// cases so that instcombine and other passes are more effective. It is\n/// expected that a later pass of GVN will catch the interesting/hard cases.\nstruct EarlyCSEPass : PassInfoMixin<EarlyCSEPass> {\n  EarlyCSEPass(bool UseMemorySSA = false) : UseMemorySSA(UseMemorySSA) {}\n\n  /// Run the pass over the function.\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n\n  bool UseMemorySSA;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_EARLYCSE_H\n"}, "180": {"id": 180, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h", "content": "//===- IndVarSimplify.h - Induction Variable Simplification -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the interface for the Induction Variable\n// Simplification pass.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_INDVARSIMPLIFY_H\n#define LLVM_TRANSFORMS_SCALAR_INDVARSIMPLIFY_H\n\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\nclass Loop;\nclass LPMUpdater;\n\nclass IndVarSimplifyPass : public PassInfoMixin<IndVarSimplifyPass> {\n  /// Perform IV widening during the pass.\n  bool WidenIndVars;\n\npublic:\n  IndVarSimplifyPass(bool WidenIndVars = true) : WidenIndVars(WidenIndVars) {}\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_INDVARSIMPLIFY_H\n"}, "182": {"id": 182, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h", "content": "//===- JumpThreading.h - thread control through conditional BBs -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// See the comments on JumpThreadingPass.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_JUMPTHREADING_H\n#define LLVM_TRANSFORMS_SCALAR_JUMPTHREADING_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\n#include \"llvm/Analysis/BranchProbabilityInfo.h\"\n#include \"llvm/Analysis/DomTreeUpdater.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass AAResults;\nclass BasicBlock;\nclass BinaryOperator;\nclass BranchInst;\nclass CmpInst;\nclass Constant;\nclass DomTreeUpdater;\nclass Function;\nclass Instruction;\nclass IntrinsicInst;\nclass LazyValueInfo;\nclass LoadInst;\nclass PHINode;\nclass SelectInst;\nclass SwitchInst;\nclass TargetLibraryInfo;\nclass Value;\n\n/// A private \"module\" namespace for types and utilities used by\n/// JumpThreading.\n/// These are implementation details and should not be used by clients.\nnamespace jumpthreading {\n\n// These are at global scope so static functions can use them too.\nusing PredValueInfo = SmallVectorImpl<std::pair<Constant *, BasicBlock *>>;\nusing PredValueInfoTy = SmallVector<std::pair<Constant *, BasicBlock *>, 8>;\n\n// This is used to keep track of what kind of constant we're currently hoping\n// to find.\nenum ConstantPreference { WantInteger, WantBlockAddress };\n\n} // end namespace jumpthreading\n\n/// This pass performs 'jump threading', which looks at blocks that have\n/// multiple predecessors and multiple successors.  If one or more of the\n/// predecessors of the block can be proven to always jump to one of the\n/// successors, we forward the edge from the predecessor to the successor by\n/// duplicating the contents of this block.\n///\n/// An example of when this can occur is code like this:\n///\n///   if () { ...\n///     X = 4;\n///   }\n///   if (X < 3) {\n///\n/// In this case, the unconditional branch at the end of the first if can be\n/// revectored to the false side of the second if.\nclass JumpThreadingPass : public PassInfoMixin<JumpThreadingPass> {\n  TargetLibraryInfo *TLI;\n  LazyValueInfo *LVI;\n  AAResults *AA;\n  DomTreeUpdater *DTU;\n  std::unique_ptr<BlockFrequencyInfo> BFI;\n  std::unique_ptr<BranchProbabilityInfo> BPI;\n  bool HasProfileData = false;\n  bool HasGuards = false;\n#ifdef NDEBUG\n  SmallPtrSet<const BasicBlock *, 16> LoopHeaders;\n#else\n  SmallSet<AssertingVH<const BasicBlock>, 16> LoopHeaders;\n#endif\n\n  unsigned BBDupThreshold;\n  unsigned DefaultBBDupThreshold;\n  bool InsertFreezeWhenUnfoldingSelect;\n\npublic:\n  JumpThreadingPass(bool InsertFreezeWhenUnfoldingSelect = false, int T = -1);\n\n  // Glue for old PM.\n  bool runImpl(Function &F, TargetLibraryInfo *TLI, LazyValueInfo *LVI,\n               AAResults *AA, DomTreeUpdater *DTU, bool HasProfileData,\n               std::unique_ptr<BlockFrequencyInfo> BFI,\n               std::unique_ptr<BranchProbabilityInfo> BPI);\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n\n  void releaseMemory() {\n    BFI.reset();\n    BPI.reset();\n  }\n\n  void findLoopHeaders(Function &F);\n  bool processBlock(BasicBlock *BB);\n  bool maybeMergeBasicBlockIntoOnlyPred(BasicBlock *BB);\n  void updateSSA(BasicBlock *BB, BasicBlock *NewBB,\n                 DenseMap<Instruction *, Value *> &ValueMapping);\n  DenseMap<Instruction *, Value *> cloneInstructions(BasicBlock::iterator BI,\n                                                     BasicBlock::iterator BE,\n                                                     BasicBlock *NewBB,\n                                                     BasicBlock *PredBB);\n  bool tryThreadEdge(BasicBlock *BB,\n                     const SmallVectorImpl<BasicBlock *> &PredBBs,\n                     BasicBlock *SuccBB);\n  void threadEdge(BasicBlock *BB, const SmallVectorImpl<BasicBlock *> &PredBBs,\n                  BasicBlock *SuccBB);\n  bool duplicateCondBranchOnPHIIntoPred(\n      BasicBlock *BB, const SmallVectorImpl<BasicBlock *> &PredBBs);\n\n  bool computeValueKnownInPredecessorsImpl(\n      Value *V, BasicBlock *BB, jumpthreading::PredValueInfo &Result,\n      jumpthreading::ConstantPreference Preference,\n      DenseSet<Value *> &RecursionSet, Instruction *CxtI = nullptr);\n  bool\n  computeValueKnownInPredecessors(Value *V, BasicBlock *BB,\n                                  jumpthreading::PredValueInfo &Result,\n                                  jumpthreading::ConstantPreference Preference,\n                                  Instruction *CxtI = nullptr) {\n    DenseSet<Value *> RecursionSet;\n    return computeValueKnownInPredecessorsImpl(V, BB, Result, Preference,\n                                               RecursionSet, CxtI);\n  }\n\n  Constant *evaluateOnPredecessorEdge(BasicBlock *BB, BasicBlock *PredPredBB,\n                                      Value *cond);\n  bool maybethreadThroughTwoBasicBlocks(BasicBlock *BB, Value *Cond);\n  void threadThroughTwoBasicBlocks(BasicBlock *PredPredBB, BasicBlock *PredBB,\n                                   BasicBlock *BB, BasicBlock *SuccBB);\n  bool processThreadableEdges(Value *Cond, BasicBlock *BB,\n                              jumpthreading::ConstantPreference Preference,\n                              Instruction *CxtI = nullptr);\n\n  bool processBranchOnPHI(PHINode *PN);\n  bool processBranchOnXOR(BinaryOperator *BO);\n  bool processImpliedCondition(BasicBlock *BB);\n\n  bool simplifyPartiallyRedundantLoad(LoadInst *LI);\n  void unfoldSelectInstr(BasicBlock *Pred, BasicBlock *BB, SelectInst *SI,\n                         PHINode *SIUse, unsigned Idx);\n\n  bool tryToUnfoldSelect(CmpInst *CondCmp, BasicBlock *BB);\n  bool tryToUnfoldSelect(SwitchInst *SI, BasicBlock *BB);\n  bool tryToUnfoldSelectInCurrBB(BasicBlock *BB);\n\n  bool processGuards(BasicBlock *BB);\n  bool threadGuard(BasicBlock *BB, IntrinsicInst *Guard, BranchInst *BI);\n\nprivate:\n  BasicBlock *splitBlockPreds(BasicBlock *BB, ArrayRef<BasicBlock *> Preds,\n                              const char *Suffix);\n  void updateBlockFreqAndEdgeWeight(BasicBlock *PredBB, BasicBlock *BB,\n                                    BasicBlock *NewBB, BasicBlock *SuccBB);\n  /// Check if the block has profile metadata for its outgoing edges.\n  bool doesBlockHaveProfileData(BasicBlock *BB);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_JUMPTHREADING_H\n"}, "183": {"id": 183, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h", "content": "//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass performs loop invariant code motion, attempting to remove as much\n// code from the body of a loop as possible.  It does this by either hoisting\n// code into the preheader block, or by sinking code to the exit blocks if it is\n// safe.  This pass also promotes must-aliased memory locations in the loop to\n// live in registers, thus hoisting and sinking \"invariant\" loads and stores.\n//\n// This pass uses alias analysis for two purposes:\n//\n//  1. Moving loop invariant loads and calls out of loops.  If we can determine\n//     that a load or call inside of a loop never aliases anything stored to,\n//     we can hoist it or sink it like any other instruction.\n//  2. Scalar Promotion of Memory - If there is a store instruction inside of\n//     the loop, we try to move the store to happen AFTER the loop instead of\n//     inside of the loop.  This can only happen if a few conditions are true:\n//       A. The pointer stored through is loop invariant\n//       B. There are no stores or loads in the loop which _may_ alias the\n//          pointer.  There are no calls in the loop which mod/ref the pointer.\n//     If these conditions are true, we can promote the loads and stores in the\n//     loop of the pointer to use a temporary alloca'd variable.  We then use\n//     the SSAUpdater to construct the appropriate SSA form for the value.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_LICM_H\n#define LLVM_TRANSFORMS_SCALAR_LICM_H\n\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Transforms/Scalar/LoopPassManager.h\"\n\nnamespace llvm {\n\nextern cl::opt<unsigned> SetLicmMssaOptCap;\nextern cl::opt<unsigned> SetLicmMssaNoAccForPromotionCap;\n\n/// Performs Loop Invariant Code Motion Pass.\nclass LICMPass : public PassInfoMixin<LICMPass> {\n  unsigned LicmMssaOptCap;\n  unsigned LicmMssaNoAccForPromotionCap;\n\npublic:\n  LICMPass()\n      : LicmMssaOptCap(SetLicmMssaOptCap),\n        LicmMssaNoAccForPromotionCap(SetLicmMssaNoAccForPromotionCap) {}\n  LICMPass(unsigned LicmMssaOptCap, unsigned LicmMssaNoAccForPromotionCap)\n      : LicmMssaOptCap(LicmMssaOptCap),\n        LicmMssaNoAccForPromotionCap(LicmMssaNoAccForPromotionCap) {}\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n};\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_LICM_H\n"}, "185": {"id": 185, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h", "content": "//===- LoopRotation.h - Loop Rotation -------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the interface for the Loop Rotation pass.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_LOOPROTATION_H\n#define LLVM_TRANSFORMS_SCALAR_LOOPROTATION_H\n\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Transforms/Scalar/LoopPassManager.h\"\n\nnamespace llvm {\n\n/// A simple loop rotation transformation.\nclass LoopRotatePass : public PassInfoMixin<LoopRotatePass> {\npublic:\n  LoopRotatePass(bool EnableHeaderDuplication = true,\n                 bool PrepareForLTO = false);\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n\nprivate:\n  const bool EnableHeaderDuplication;\n  const bool PrepareForLTO;\n};\n}\n\n#endif // LLVM_TRANSFORMS_SCALAR_LOOPROTATION_H\n"}, "186": {"id": 186, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollAndJamPass.h", "content": "//===- LoopUnrollAndJamPass.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_LOOPUNROLLANDJAMPASS_H\n#define LLVM_TRANSFORMS_SCALAR_LOOPUNROLLANDJAMPASS_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\nclass Function;\n\n/// A simple loop rotation transformation.\nclass LoopUnrollAndJamPass : public PassInfoMixin<LoopUnrollAndJamPass> {\n  const int OptLevel;\n\npublic:\n  explicit LoopUnrollAndJamPass(int OptLevel = 2) : OptLevel(OptLevel) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_LOOPUNROLLANDJAMPASS_H\n"}, "187": {"id": 187, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h", "content": "//===- LoopUnrollPass.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_LOOPUNROLLPASS_H\n#define LLVM_TRANSFORMS_SCALAR_LOOPUNROLLPASS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Support/CommandLine.h\"\n\nnamespace llvm {\n\nextern cl::opt<bool> ForgetSCEVInLoopUnroll;\n\nclass Function;\nclass Loop;\nclass LPMUpdater;\n\n/// Loop unroll pass that only does full loop unrolling and peeling.\nclass LoopFullUnrollPass : public PassInfoMixin<LoopFullUnrollPass> {\n  const int OptLevel;\n\n  /// If false, use a cost model to determine whether unrolling of a loop is\n  /// profitable. If true, only loops that explicitly request unrolling via\n  /// metadata are considered. All other loops are skipped.\n  const bool OnlyWhenForced;\n\n  /// If true, forget all loops when unrolling. If false, forget top-most loop\n  /// of the currently processed loops, which removes one entry at a time from\n  /// the internal SCEV records. For large loops, the former is faster.\n  const bool ForgetSCEV;\n\npublic:\n  explicit LoopFullUnrollPass(int OptLevel = 2, bool OnlyWhenForced = false,\n                              bool ForgetSCEV = false)\n      : OptLevel(OptLevel), OnlyWhenForced(OnlyWhenForced),\n        ForgetSCEV(ForgetSCEV) {}\n\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n};\n\n/// A set of parameters used to control various transforms performed by the\n/// LoopUnroll pass. Each of the boolean parameters can be set to:\n///      true - enabling the transformation.\n///      false - disabling the transformation.\n///      None - relying on a global default.\n///\n/// There is also OptLevel parameter, which is used for additional loop unroll\n/// tuning.\n///\n/// Intended use is to create a default object, modify parameters with\n/// additional setters and then pass it to LoopUnrollPass.\n///\nstruct LoopUnrollOptions {\n  Optional<bool> AllowPartial;\n  Optional<bool> AllowPeeling;\n  Optional<bool> AllowRuntime;\n  Optional<bool> AllowUpperBound;\n  Optional<bool> AllowProfileBasedPeeling;\n  Optional<unsigned> FullUnrollMaxCount;\n  int OptLevel;\n\n  /// If false, use a cost model to determine whether unrolling of a loop is\n  /// profitable. If true, only loops that explicitly request unrolling via\n  /// metadata are considered. All other loops are skipped.\n  bool OnlyWhenForced;\n\n  /// If true, forget all loops when unrolling. If false, forget top-most loop\n  /// of the currently processed loops, which removes one entry at a time from\n  /// the internal SCEV records. For large loops, the former is faster.\n  const bool ForgetSCEV;\n\n  LoopUnrollOptions(int OptLevel = 2, bool OnlyWhenForced = false,\n                    bool ForgetSCEV = false)\n      : OptLevel(OptLevel), OnlyWhenForced(OnlyWhenForced),\n        ForgetSCEV(ForgetSCEV) {}\n\n  /// Enables or disables partial unrolling. When disabled only full unrolling\n  /// is allowed.\n  LoopUnrollOptions &setPartial(bool Partial) {\n    AllowPartial = Partial;\n    return *this;\n  }\n\n  /// Enables or disables unrolling of loops with runtime trip count.\n  LoopUnrollOptions &setRuntime(bool Runtime) {\n    AllowRuntime = Runtime;\n    return *this;\n  }\n\n  /// Enables or disables loop peeling.\n  LoopUnrollOptions &setPeeling(bool Peeling) {\n    AllowPeeling = Peeling;\n    return *this;\n  }\n\n  /// Enables or disables the use of trip count upper bound\n  /// in loop unrolling.\n  LoopUnrollOptions &setUpperBound(bool UpperBound) {\n    AllowUpperBound = UpperBound;\n    return *this;\n  }\n\n  // Sets \"optimization level\" tuning parameter for loop unrolling.\n  LoopUnrollOptions &setOptLevel(int O) {\n    OptLevel = O;\n    return *this;\n  }\n\n  // Enables or disables loop peeling basing on profile.\n  LoopUnrollOptions &setProfileBasedPeeling(int O) {\n    AllowProfileBasedPeeling = O;\n    return *this;\n  }\n\n  // Sets the max full unroll count.\n  LoopUnrollOptions &setFullUnrollMaxCount(unsigned O) {\n    FullUnrollMaxCount = O;\n    return *this;\n  }\n};\n\n/// Loop unroll pass that will support both full and partial unrolling.\n/// It is a function pass to have access to function and module analyses.\n/// It will also put loops into canonical form (simplified and LCSSA).\nclass LoopUnrollPass : public PassInfoMixin<LoopUnrollPass> {\n  LoopUnrollOptions UnrollOpts;\n\npublic:\n  /// This uses the target information (or flags) to control the thresholds for\n  /// different unrolling stategies but supports all of them.\n  explicit LoopUnrollPass(LoopUnrollOptions UnrollOpts = {})\n      : UnrollOpts(UnrollOpts) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_LOOPUNROLLPASS_H\n"}, "189": {"id": 189, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerMatrixIntrinsics.h", "content": "//===- LowerMatrixIntrinsics.h - Lower matrix intrinsics. -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass lowers matrix intrinsics down to vector operations.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_LOWERMATRIXINTRINSICS_H\n#define LLVM_TRANSFORMS_SCALAR_LOWERMATRIXINTRINSICS_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\nclass LowerMatrixIntrinsicsPass\n    : public PassInfoMixin<LowerMatrixIntrinsicsPass> {\n  bool Minimal;\n\npublic:\n  LowerMatrixIntrinsicsPass(bool Minimal = false) : Minimal(Minimal) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n  static bool isRequired() { return true; }\n};\n} // namespace llvm\n\n#endif\n"}, "190": {"id": 190, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h", "content": "//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//! \\file\n//! This pass performs merges of loads and stores on both sides of a\n//  diamond (hammock). It hoists the loads and sinks the stores.\n//\n// The algorithm iteratively hoists two loads to the same address out of a\n// diamond (hammock) and merges them into a single load in the header. Similar\n// it sinks and merges two stores to the tail block (footer). The algorithm\n// iterates over the instructions of one side of the diamond and attempts to\n// find a matching load/store on the other side. It hoists / sinks when it\n// thinks it safe to do so.  This optimization helps with eg. hiding load\n// latencies, triggering if-conversion, and reducing static code size.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_MERGEDLOADSTOREMOTION_H\n#define LLVM_TRANSFORMS_SCALAR_MERGEDLOADSTOREMOTION_H\n\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\nstruct MergedLoadStoreMotionOptions {\n  bool SplitFooterBB;\n  MergedLoadStoreMotionOptions(bool SplitFooterBB = false)\n      : SplitFooterBB(SplitFooterBB) {}\n\n  MergedLoadStoreMotionOptions &splitFooterBB(bool SFBB) {\n    SplitFooterBB = SFBB;\n    return *this;\n  }\n};\n\nclass MergedLoadStoreMotionPass\n    : public PassInfoMixin<MergedLoadStoreMotionPass> {\n  MergedLoadStoreMotionOptions Options;\n\npublic:\n  MergedLoadStoreMotionPass()\n      : MergedLoadStoreMotionPass(MergedLoadStoreMotionOptions()) {}\n  MergedLoadStoreMotionPass(const MergedLoadStoreMotionOptions &PassOptions)\n      : Options(PassOptions) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n}\n\n#endif // LLVM_TRANSFORMS_SCALAR_MERGEDLOADSTOREMOTION_H\n"}, "191": {"id": 191, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h", "content": "//===- SeparateConstOffsetFromGEP.h ---------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_SEPARATECONSTOFFSETFROMGEP_H\n#define LLVM_TRANSFORMS_SCALAR_SEPARATECONSTOFFSETFROMGEP_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\n\nclass SeparateConstOffsetFromGEPPass\n    : public PassInfoMixin<SeparateConstOffsetFromGEPPass> {\n  bool LowerGEP;\n\npublic:\n  SeparateConstOffsetFromGEPPass(bool LowerGEP = false) : LowerGEP(LowerGEP) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_SEPARATECONSTOFFSETFROMGEP_H\n"}, "193": {"id": 193, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h", "content": "//===- SimplifyCFG.h - Simplify and canonicalize the CFG --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file provides the interface for the pass responsible for both\n/// simplifying and canonicalizing the CFG.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_SIMPLIFYCFG_H\n#define LLVM_TRANSFORMS_SCALAR_SIMPLIFYCFG_H\n\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Transforms/Utils/SimplifyCFGOptions.h\"\n\nnamespace llvm {\n\n/// A pass to simplify and canonicalize the CFG of a function.\n///\n/// This pass iteratively simplifies the entire CFG of a function. It may change\n/// or remove control flow to put the CFG into a canonical form expected by\n/// other passes of the mid-level optimizer. Depending on the specified options,\n/// it may further optimize control-flow to create non-canonical forms.\nclass SimplifyCFGPass : public PassInfoMixin<SimplifyCFGPass> {\n  SimplifyCFGOptions Options;\n\npublic:\n  /// The default constructor sets the pass options to create canonical IR,\n  /// rather than optimal IR. That is, by default we bypass transformations that\n  /// are likely to improve performance but make analysis for other passes more\n  /// difficult.\n  SimplifyCFGPass();\n\n  /// Construct a pass with optional optimizations.\n  SimplifyCFGPass(const SimplifyCFGOptions &PassOptions);\n\n  /// Run the pass over the function.\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n}\n\n#endif\n"}, "194": {"id": 194, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h", "content": "//===- SpeculativeExecution.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass hoists instructions to enable speculative execution on\n// targets where branches are expensive. This is aimed at GPUs. It\n// currently works on simple if-then and if-then-else\n// patterns.\n//\n// Removing branches is not the only motivation for this\n// pass. E.g. consider this code and assume that there is no\n// addressing mode for multiplying by sizeof(*a):\n//\n//   if (b > 0)\n//     c = a[i + 1]\n//   if (d > 0)\n//     e = a[i + 2]\n//\n// turns into\n//\n//   p = &a[i + 1];\n//   if (b > 0)\n//     c = *p;\n//   q = &a[i + 2];\n//   if (d > 0)\n//     e = *q;\n//\n// which could later be optimized to\n//\n//   r = &a[i];\n//   if (b > 0)\n//     c = r[1];\n//   if (d > 0)\n//     e = r[2];\n//\n// Later passes sink back much of the speculated code that did not enable\n// further optimization.\n//\n// This pass is more aggressive than the function SpeculativeyExecuteBB in\n// SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and\n// it will speculate at most one instruction. It also will not speculate if\n// there is a value defined in the if-block that is only used in the then-block.\n// These restrictions make sense since the speculation in SimplifyCFG seems\n// aimed at introducing cheap selects, while this pass is intended to do more\n// aggressive speculation while counting on later passes to either capitalize on\n// that or clean it up.\n//\n// If the pass was created by calling\n// createSpeculativeExecutionIfHasBranchDivergencePass or the\n// -spec-exec-only-if-divergent-target option is present, this pass only has an\n// effect on targets where TargetTransformInfo::hasBranchDivergence() is true;\n// on other targets, it is a nop.\n//\n// This lets you include this pass unconditionally in the IR pass pipeline, but\n// only enable it for relevant targets.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_TRANSFORMS_SCALAR_SPECULATIVEEXECUTION_H\n#define LLVM_TRANSFORMS_SCALAR_SPECULATIVEEXECUTION_H\n\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\nclass SpeculativeExecutionPass\n    : public PassInfoMixin<SpeculativeExecutionPass> {\npublic:\n  SpeculativeExecutionPass(bool OnlyIfDivergentTarget = false);\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n\n  // Glue for old PM\n  bool runImpl(Function &F, TargetTransformInfo *TTI);\n\nprivate:\n  bool runOnBasicBlock(BasicBlock &B);\n  bool considerHoistingFromTo(BasicBlock &FromBlock, BasicBlock &ToBlock);\n\n  // If true, this pass is a nop unless the target architecture has branch\n  // divergence.\n  const bool OnlyIfDivergentTarget = false;\n\n  TargetTransformInfo *TTI = nullptr;\n};\n}\n\n#endif // LLVM_TRANSFORMS_SCALAR_SPECULATIVEEXECUTION_H\n"}, "195": {"id": 195, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h", "content": "//===- WarnMissedTransforms.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Emit warnings if forced code transformations have not been performed.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_WARNMISSEDTRANSFORMS_H\n#define LLVM_TRANSFORMS_SCALAR_WARNMISSEDTRANSFORMS_H\n\n#include \"llvm/IR/PassManager.h\"\n\nnamespace llvm {\nclass Function;\nclass Loop;\nclass LPMUpdater;\n\n// New pass manager boilerplate.\nclass WarnMissedTransformationsPass\n    : public PassInfoMixin<WarnMissedTransformationsPass> {\npublic:\n  explicit WarnMissedTransformationsPass() {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n// Legacy pass manager boilerplate.\nPass *createWarnMissedTransformationsPass();\nvoid initializeWarnMissedTransformationsLegacyPass(PassRegistry &);\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_WARNMISSEDTRANSFORMS_H\n"}, "198": {"id": 198, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h", "content": "//===- PredicateInfo.h - Build PredicateInfo ----------------------*-C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n///  This file implements the PredicateInfo analysis, which creates an Extended\n/// SSA form for operations used in branch comparisons and llvm.assume\n/// comparisons.\n///\n/// Copies of these operations are inserted into the true/false edge (and after\n/// assumes), and information attached to the copies.  All uses of the original\n/// operation in blocks dominated by the true/false edge (and assume), are\n/// replaced with uses of the copies.  This enables passes to easily and sparsely\n/// propagate condition based info into the operations that may be affected.\n///\n/// Example:\n/// %cmp = icmp eq i32 %x, 50\n/// br i1 %cmp, label %true, label %false\n/// true:\n/// ret i32 %x\n/// false:\n/// ret i32 1\n///\n/// will become\n///\n/// %cmp = icmp eq i32, %x, 50\n/// br i1 %cmp, label %true, label %false\n/// true:\n/// %x.0 = call \\@llvm.ssa_copy.i32(i32 %x)\n/// ret i32 %x.0\n/// false:\n/// ret i32 1\n///\n/// Using getPredicateInfoFor on x.0 will give you the comparison it is\n/// dominated by (the icmp), and that you are located in the true edge of that\n/// comparison, which tells you x.0 is 50.\n///\n/// In order to reduce the number of copies inserted, predicateinfo is only\n/// inserted where it would actually be live.  This means if there are no uses of\n/// an operation dominated by the branch edges, or by an assume, the associated\n/// predicate info is never inserted.\n///\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_UTILS_PREDICATEINFO_H\n#define LLVM_TRANSFORMS_UTILS_PREDICATEINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Pass.h\"\n\nnamespace llvm {\n\nclass AssumptionCache;\nclass DominatorTree;\nclass Function;\nclass IntrinsicInst;\nclass raw_ostream;\n\nenum PredicateType { PT_Branch, PT_Assume, PT_Switch };\n\n/// Constraint for a predicate of the form \"cmp Pred Op, OtherOp\", where Op\n/// is the value the constraint applies to (the ssa.copy result).\nstruct PredicateConstraint {\n  CmpInst::Predicate Predicate;\n  Value *OtherOp;\n};\n\n// Base class for all predicate information we provide.\n// All of our predicate information has at least a comparison.\nclass PredicateBase : public ilist_node<PredicateBase> {\npublic:\n  PredicateType Type;\n  // The original operand before we renamed it.\n  // This can be use by passes, when destroying predicateinfo, to know\n  // whether they can just drop the intrinsic, or have to merge metadata.\n  Value *OriginalOp;\n  // The renamed operand in the condition used for this predicate. For nested\n  // predicates, this is different to OriginalOp which refers to the initial\n  // operand.\n  Value *RenamedOp;\n  // The condition associated with this predicate.\n  Value *Condition;\n\n  PredicateBase(const PredicateBase &) = delete;\n  PredicateBase &operator=(const PredicateBase &) = delete;\n  PredicateBase() = delete;\n  virtual ~PredicateBase() = default;\n  static bool classof(const PredicateBase *PB) {\n    return PB->Type == PT_Assume || PB->Type == PT_Branch ||\n           PB->Type == PT_Switch;\n  }\n\n  /// Fetch condition in the form of PredicateConstraint, if possible.\n  Optional<PredicateConstraint> getConstraint() const;\n\nprotected:\n  PredicateBase(PredicateType PT, Value *Op, Value *Condition)\n      : Type(PT), OriginalOp(Op), Condition(Condition) {}\n};\n\n// Provides predicate information for assumes.  Since assumes are always true,\n// we simply provide the assume instruction, so you can tell your relative\n// position to it.\nclass PredicateAssume : public PredicateBase {\npublic:\n  IntrinsicInst *AssumeInst;\n  PredicateAssume(Value *Op, IntrinsicInst *AssumeInst, Value *Condition)\n      : PredicateBase(PT_Assume, Op, Condition), AssumeInst(AssumeInst) {}\n  PredicateAssume() = delete;\n  static bool classof(const PredicateBase *PB) {\n    return PB->Type == PT_Assume;\n  }\n};\n\n// Mixin class for edge predicates.  The FROM block is the block where the\n// predicate originates, and the TO block is the block where the predicate is\n// valid.\nclass PredicateWithEdge : public PredicateBase {\npublic:\n  BasicBlock *From;\n  BasicBlock *To;\n  PredicateWithEdge() = delete;\n  static bool classof(const PredicateBase *PB) {\n    return PB->Type == PT_Branch || PB->Type == PT_Switch;\n  }\n\nprotected:\n  PredicateWithEdge(PredicateType PType, Value *Op, BasicBlock *From,\n                    BasicBlock *To, Value *Cond)\n      : PredicateBase(PType, Op, Cond), From(From), To(To) {}\n};\n\n// Provides predicate information for branches.\nclass PredicateBranch : public PredicateWithEdge {\npublic:\n  // If true, SplitBB is the true successor, otherwise it's the false successor.\n  bool TrueEdge;\n  PredicateBranch(Value *Op, BasicBlock *BranchBB, BasicBlock *SplitBB,\n                  Value *Condition, bool TakenEdge)\n      : PredicateWithEdge(PT_Branch, Op, BranchBB, SplitBB, Condition),\n        TrueEdge(TakenEdge) {}\n  PredicateBranch() = delete;\n  static bool classof(const PredicateBase *PB) {\n    return PB->Type == PT_Branch;\n  }\n};\n\nclass PredicateSwitch : public PredicateWithEdge {\npublic:\n  Value *CaseValue;\n  // This is the switch instruction.\n  SwitchInst *Switch;\n  PredicateSwitch(Value *Op, BasicBlock *SwitchBB, BasicBlock *TargetBB,\n                  Value *CaseValue, SwitchInst *SI)\n      : PredicateWithEdge(PT_Switch, Op, SwitchBB, TargetBB,\n                          SI->getCondition()),\n        CaseValue(CaseValue), Switch(SI) {}\n  PredicateSwitch() = delete;\n  static bool classof(const PredicateBase *PB) {\n    return PB->Type == PT_Switch;\n  }\n};\n\n/// Encapsulates PredicateInfo, including all data associated with memory\n/// accesses.\nclass PredicateInfo {\npublic:\n  PredicateInfo(Function &, DominatorTree &, AssumptionCache &);\n  ~PredicateInfo();\n\n  void verifyPredicateInfo() const;\n\n  void dump() const;\n  void print(raw_ostream &) const;\n\n  const PredicateBase *getPredicateInfoFor(const Value *V) const {\n    return PredicateMap.lookup(V);\n  }\n\nprotected:\n  // Used by PredicateInfo annotater, dumpers, and wrapper pass.\n  friend class PredicateInfoAnnotatedWriter;\n  friend class PredicateInfoPrinterLegacyPass;\n  friend class PredicateInfoBuilder;\n\nprivate:\n  Function &F;\n\n  // This owns the all the predicate infos in the function, placed or not.\n  iplist<PredicateBase> AllInfos;\n\n  // This maps from copy operands to Predicate Info. Note that it does not own\n  // the Predicate Info, they belong to the ValueInfo structs in the ValueInfos\n  // vector.\n  DenseMap<const Value *, const PredicateBase *> PredicateMap;\n  // The set of ssa_copy declarations we created with our custom mangling.\n  SmallSet<AssertingVH<Function>, 20> CreatedDeclarations;\n};\n\n// This pass does eager building and then printing of PredicateInfo. It is used\n// by\n// the tests to be able to build, dump, and verify PredicateInfo.\nclass PredicateInfoPrinterLegacyPass : public FunctionPass {\npublic:\n  PredicateInfoPrinterLegacyPass();\n\n  static char ID;\n  bool runOnFunction(Function &) override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n\n/// Printer pass for \\c PredicateInfo.\nclass PredicateInfoPrinterPass\n    : public PassInfoMixin<PredicateInfoPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit PredicateInfoPrinterPass(raw_ostream &OS) : OS(OS) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for \\c PredicateInfo.\nstruct PredicateInfoVerifierPass : PassInfoMixin<PredicateInfoVerifierPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_UTILS_PREDICATEINFO_H\n"}, "202": {"id": 202, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h", "content": "//===- LoopVectorize.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This is the LLVM loop vectorizer. This pass modifies 'vectorizable' loops\n// and generates target-independent LLVM-IR.\n// The vectorizer uses the TargetTransformInfo analysis to estimate the costs\n// of instructions in order to estimate the profitability of vectorization.\n//\n// The loop vectorizer combines consecutive loop iterations into a single\n// 'wide' iteration. After this transformation the index is incremented\n// by the SIMD vector width, and not by one.\n//\n// This pass has three parts:\n// 1. The main loop pass that drives the different parts.\n// 2. LoopVectorizationLegality - A unit that checks for the legality\n//    of the vectorization.\n// 3. InnerLoopVectorizer - A unit that performs the actual\n//    widening of instructions.\n// 4. LoopVectorizationCostModel - A unit that checks for the profitability\n//    of vectorization. It decides on the optimal vector width, which\n//    can be one, if vectorization is not profitable.\n//\n// There is a development effort going on to migrate loop vectorizer to the\n// VPlan infrastructure and to introduce outer loop vectorization support (see\n// docs/Proposal/VectorizationPlan.rst and\n// http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this\n// purpose, we temporarily introduced the VPlan-native vectorization path: an\n// alternative vectorization path that is natively implemented on top of the\n// VPlan infrastructure. See EnableVPlanNativePath for enabling.\n//\n//===----------------------------------------------------------------------===//\n//\n// The reduction-variable vectorization is based on the paper:\n//  D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.\n//\n// Variable uniformity checks are inspired by:\n//  Karrenberg, R. and Hack, S. Whole Function Vectorization.\n//\n// The interleaved access vectorization is based on the paper:\n//  Dorit Nuzman, Ira Rosen and Ayal Zaks.  Auto-Vectorization of Interleaved\n//  Data for SIMD\n//\n// Other ideas/concepts are from:\n//  A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.\n//\n//  S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua.  An Evaluation of\n//  Vectorizing Compilers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_VECTORIZE_LOOPVECTORIZE_H\n#define LLVM_TRANSFORMS_VECTORIZE_LOOPVECTORIZE_H\n\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include <functional>\n\nnamespace llvm {\n\nclass AAResults;\nclass AssumptionCache;\nclass BlockFrequencyInfo;\nclass DemandedBits;\nclass DominatorTree;\nclass Function;\nclass Loop;\nclass LoopAccessInfo;\nclass LoopInfo;\nclass OptimizationRemarkEmitter;\nclass ProfileSummaryInfo;\nclass ScalarEvolution;\nclass TargetLibraryInfo;\nclass TargetTransformInfo;\n\nextern cl::opt<bool> EnableLoopInterleaving;\nextern cl::opt<bool> EnableLoopVectorization;\n\nstruct LoopVectorizeOptions {\n  /// If false, consider all loops for interleaving.\n  /// If true, only loops that explicitly request interleaving are considered.\n  bool InterleaveOnlyWhenForced;\n\n  /// If false, consider all loops for vectorization.\n  /// If true, only loops that explicitly request vectorization are considered.\n  bool VectorizeOnlyWhenForced;\n\n  /// The current defaults when creating the pass with no arguments are:\n  /// EnableLoopInterleaving = true and EnableLoopVectorization = true. This\n  /// means that interleaving default is consistent with the cl::opt flag, while\n  /// vectorization is not.\n  /// FIXME: The default for EnableLoopVectorization in the cl::opt should be\n  /// set to true, and the corresponding change to account for this be made in\n  /// opt.cpp. The initializations below will become:\n  /// InterleaveOnlyWhenForced(!EnableLoopInterleaving)\n  /// VectorizeOnlyWhenForced(!EnableLoopVectorization).\n  LoopVectorizeOptions()\n      : InterleaveOnlyWhenForced(false), VectorizeOnlyWhenForced(false) {}\n  LoopVectorizeOptions(bool InterleaveOnlyWhenForced,\n                       bool VectorizeOnlyWhenForced)\n      : InterleaveOnlyWhenForced(InterleaveOnlyWhenForced),\n        VectorizeOnlyWhenForced(VectorizeOnlyWhenForced) {}\n\n  LoopVectorizeOptions &setInterleaveOnlyWhenForced(bool Value) {\n    InterleaveOnlyWhenForced = Value;\n    return *this;\n  }\n\n  LoopVectorizeOptions &setVectorizeOnlyWhenForced(bool Value) {\n    VectorizeOnlyWhenForced = Value;\n    return *this;\n  }\n};\n\n/// Storage for information about made changes.\nstruct LoopVectorizeResult {\n  bool MadeAnyChange;\n  bool MadeCFGChange;\n\n  LoopVectorizeResult(bool MadeAnyChange, bool MadeCFGChange)\n      : MadeAnyChange(MadeAnyChange), MadeCFGChange(MadeCFGChange) {}\n};\n\n/// The LoopVectorize Pass.\nstruct LoopVectorizePass : public PassInfoMixin<LoopVectorizePass> {\nprivate:\n  /// If false, consider all loops for interleaving.\n  /// If true, only loops that explicitly request interleaving are considered.\n  bool InterleaveOnlyWhenForced;\n\n  /// If false, consider all loops for vectorization.\n  /// If true, only loops that explicitly request vectorization are considered.\n  bool VectorizeOnlyWhenForced;\n\npublic:\n  LoopVectorizePass(LoopVectorizeOptions Opts = {});\n\n  ScalarEvolution *SE;\n  LoopInfo *LI;\n  TargetTransformInfo *TTI;\n  DominatorTree *DT;\n  BlockFrequencyInfo *BFI;\n  TargetLibraryInfo *TLI;\n  DemandedBits *DB;\n  AAResults *AA;\n  AssumptionCache *AC;\n  std::function<const LoopAccessInfo &(Loop &)> *GetLAA;\n  OptimizationRemarkEmitter *ORE;\n  ProfileSummaryInfo *PSI;\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n\n  // Shim for old PM.\n  LoopVectorizeResult\n  runImpl(Function &F, ScalarEvolution &SE_, LoopInfo &LI_,\n          TargetTransformInfo &TTI_, DominatorTree &DT_,\n          BlockFrequencyInfo &BFI_, TargetLibraryInfo *TLI_, DemandedBits &DB_,\n          AAResults &AA_, AssumptionCache &AC_,\n          std::function<const LoopAccessInfo &(Loop &)> &GetLAA_,\n          OptimizationRemarkEmitter &ORE_, ProfileSummaryInfo *PSI_);\n\n  bool processLoop(Loop *L);\n};\n\n/// Reports a vectorization failure: print \\p DebugMsg for debugging\n/// purposes along with the corresponding optimization remark \\p RemarkName.\n/// If \\p I is passed, it is an instruction that prevents vectorization.\n/// Otherwise, the loop \\p TheLoop is used for the location of the remark.\nvoid reportVectorizationFailure(const StringRef DebugMsg,\n    const StringRef OREMsg, const StringRef ORETag,\n    OptimizationRemarkEmitter *ORE, Loop *TheLoop, Instruction *I = nullptr);\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_VECTORIZE_LOOPVECTORIZE_H\n"}, "203": {"id": 203, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Passes/PassBuilder.cpp", "content": "//===- Parsing, selection, and construction of pass pipelines -------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This file provides the implementation of the PassBuilder based on our\n/// static pass registry as well as related functionality. It also provides\n/// helpers to aid in analyzing, debugging, and testing passes and pass\n/// pipelines.\n///\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Passes/PassBuilder.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Analysis/AliasAnalysisEvaluator.h\"\n#include \"llvm/Analysis/AliasSetTracker.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/BasicAliasAnalysis.h\"\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\n#include \"llvm/Analysis/BranchProbabilityInfo.h\"\n#include \"llvm/Analysis/CFGPrinter.h\"\n#include \"llvm/Analysis/CFLAndersAliasAnalysis.h\"\n#include \"llvm/Analysis/CFLSteensAliasAnalysis.h\"\n#include \"llvm/Analysis/CGSCCPassManager.h\"\n#include \"llvm/Analysis/CallGraph.h\"\n#include \"llvm/Analysis/DDG.h\"\n#include \"llvm/Analysis/DDGPrinter.h\"\n#include \"llvm/Analysis/Delinearization.h\"\n#include \"llvm/Analysis/DemandedBits.h\"\n#include \"llvm/Analysis/DependenceAnalysis.h\"\n#include \"llvm/Analysis/DivergenceAnalysis.h\"\n#include \"llvm/Analysis/DominanceFrontier.h\"\n#include \"llvm/Analysis/FunctionPropertiesAnalysis.h\"\n#include \"llvm/Analysis/GlobalsModRef.h\"\n#include \"llvm/Analysis/IRSimilarityIdentifier.h\"\n#include \"llvm/Analysis/IVUsers.h\"\n#include \"llvm/Analysis/InlineAdvisor.h\"\n#include \"llvm/Analysis/InlineSizeEstimatorAnalysis.h\"\n#include \"llvm/Analysis/InstCount.h\"\n#include \"llvm/Analysis/LazyCallGraph.h\"\n#include \"llvm/Analysis/LazyValueInfo.h\"\n#include \"llvm/Analysis/Lint.h\"\n#include \"llvm/Analysis/LoopAccessAnalysis.h\"\n#include \"llvm/Analysis/LoopCacheAnalysis.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/LoopNestAnalysis.h\"\n#include \"llvm/Analysis/MemDerefPrinter.h\"\n#include \"llvm/Analysis/MemoryDependenceAnalysis.h\"\n#include \"llvm/Analysis/MemorySSA.h\"\n#include \"llvm/Analysis/ModuleDebugInfoPrinter.h\"\n#include \"llvm/Analysis/ModuleSummaryAnalysis.h\"\n#include \"llvm/Analysis/MustExecute.h\"\n#include \"llvm/Analysis/ObjCARCAliasAnalysis.h\"\n#include \"llvm/Analysis/OptimizationRemarkEmitter.h\"\n#include \"llvm/Analysis/PhiValues.h\"\n#include \"llvm/Analysis/PostDominators.h\"\n#include \"llvm/Analysis/ProfileSummaryInfo.h\"\n#include \"llvm/Analysis/RegionInfo.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/Analysis/ScalarEvolutionAliasAnalysis.h\"\n#include \"llvm/Analysis/ScopedNoAliasAA.h\"\n#include \"llvm/Analysis/StackLifetime.h\"\n#include \"llvm/Analysis/StackSafetyAnalysis.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/TypeBasedAliasAnalysis.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/IRPrintingPasses.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/PrintPasses.h\"\n#include \"llvm/IR/SafepointIRVerifier.h\"\n#include \"llvm/IR/Verifier.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include \"llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h\"\n#include \"llvm/Transforms/Coroutines/CoroCleanup.h\"\n#include \"llvm/Transforms/Coroutines/CoroEarly.h\"\n#include \"llvm/Transforms/Coroutines/CoroElide.h\"\n#include \"llvm/Transforms/Coroutines/CoroSplit.h\"\n#include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n#include \"llvm/Transforms/IPO/Annotation2Metadata.h\"\n#include \"llvm/Transforms/IPO/ArgumentPromotion.h\"\n#include \"llvm/Transforms/IPO/Attributor.h\"\n#include \"llvm/Transforms/IPO/BlockExtractor.h\"\n#include \"llvm/Transforms/IPO/CalledValuePropagation.h\"\n#include \"llvm/Transforms/IPO/ConstantMerge.h\"\n#include \"llvm/Transforms/IPO/CrossDSOCFI.h\"\n#include \"llvm/Transforms/IPO/DeadArgumentElimination.h\"\n#include \"llvm/Transforms/IPO/ElimAvailExtern.h\"\n#include \"llvm/Transforms/IPO/ForceFunctionAttrs.h\"\n#include \"llvm/Transforms/IPO/FunctionAttrs.h\"\n#include \"llvm/Transforms/IPO/FunctionImport.h\"\n#include \"llvm/Transforms/IPO/GlobalDCE.h\"\n#include \"llvm/Transforms/IPO/GlobalOpt.h\"\n#include \"llvm/Transforms/IPO/GlobalSplit.h\"\n#include \"llvm/Transforms/IPO/HotColdSplitting.h\"\n#include \"llvm/Transforms/IPO/IROutliner.h\"\n#include \"llvm/Transforms/IPO/InferFunctionAttrs.h\"\n#include \"llvm/Transforms/IPO/Inliner.h\"\n#include \"llvm/Transforms/IPO/Internalize.h\"\n#include \"llvm/Transforms/IPO/LoopExtractor.h\"\n#include \"llvm/Transforms/IPO/LowerTypeTests.h\"\n#include \"llvm/Transforms/IPO/MergeFunctions.h\"\n#include \"llvm/Transforms/IPO/OpenMPOpt.h\"\n#include \"llvm/Transforms/IPO/PartialInlining.h\"\n#include \"llvm/Transforms/IPO/SCCP.h\"\n#include \"llvm/Transforms/IPO/SampleProfile.h\"\n#include \"llvm/Transforms/IPO/SampleProfileProbe.h\"\n#include \"llvm/Transforms/IPO/StripDeadPrototypes.h\"\n#include \"llvm/Transforms/IPO/StripSymbols.h\"\n#include \"llvm/Transforms/IPO/SyntheticCountsPropagation.h\"\n#include \"llvm/Transforms/IPO/WholeProgramDevirt.h\"\n#include \"llvm/Transforms/InstCombine/InstCombine.h\"\n#include \"llvm/Transforms/Instrumentation.h\"\n#include \"llvm/Transforms/Instrumentation/AddressSanitizer.h\"\n#include \"llvm/Transforms/Instrumentation/BoundsChecking.h\"\n#include \"llvm/Transforms/Instrumentation/CGProfile.h\"\n#include \"llvm/Transforms/Instrumentation/ControlHeightReduction.h\"\n#include \"llvm/Transforms/Instrumentation/DataFlowSanitizer.h\"\n#include \"llvm/Transforms/Instrumentation/GCOVProfiler.h\"\n#include \"llvm/Transforms/Instrumentation/HWAddressSanitizer.h\"\n#include \"llvm/Transforms/Instrumentation/InstrOrderFile.h\"\n#include \"llvm/Transforms/Instrumentation/InstrProfiling.h\"\n#include \"llvm/Transforms/Instrumentation/MemProfiler.h\"\n#include \"llvm/Transforms/Instrumentation/MemorySanitizer.h\"\n#include \"llvm/Transforms/Instrumentation/PGOInstrumentation.h\"\n#include \"llvm/Transforms/Instrumentation/PoisonChecking.h\"\n#include \"llvm/Transforms/Instrumentation/SanitizerCoverage.h\"\n#include \"llvm/Transforms/Instrumentation/ThreadSanitizer.h\"\n#include \"llvm/Transforms/ObjCARC.h\"\n#include \"llvm/Transforms/Scalar/ADCE.h\"\n#include \"llvm/Transforms/Scalar/AlignmentFromAssumptions.h\"\n#include \"llvm/Transforms/Scalar/AnnotationRemarks.h\"\n#include \"llvm/Transforms/Scalar/BDCE.h\"\n#include \"llvm/Transforms/Scalar/CallSiteSplitting.h\"\n#include \"llvm/Transforms/Scalar/ConstantHoisting.h\"\n#include \"llvm/Transforms/Scalar/ConstraintElimination.h\"\n#include \"llvm/Transforms/Scalar/CorrelatedValuePropagation.h\"\n#include \"llvm/Transforms/Scalar/DCE.h\"\n#include \"llvm/Transforms/Scalar/DeadStoreElimination.h\"\n#include \"llvm/Transforms/Scalar/DivRemPairs.h\"\n#include \"llvm/Transforms/Scalar/EarlyCSE.h\"\n#include \"llvm/Transforms/Scalar/Float2Int.h\"\n#include \"llvm/Transforms/Scalar/GVN.h\"\n#include \"llvm/Transforms/Scalar/GuardWidening.h\"\n#include \"llvm/Transforms/Scalar/IVUsersPrinter.h\"\n#include \"llvm/Transforms/Scalar/IndVarSimplify.h\"\n#include \"llvm/Transforms/Scalar/InductiveRangeCheckElimination.h\"\n#include \"llvm/Transforms/Scalar/InferAddressSpaces.h\"\n#include \"llvm/Transforms/Scalar/InstSimplifyPass.h\"\n#include \"llvm/Transforms/Scalar/JumpThreading.h\"\n#include \"llvm/Transforms/Scalar/LICM.h\"\n#include \"llvm/Transforms/Scalar/LoopAccessAnalysisPrinter.h\"\n#include \"llvm/Transforms/Scalar/LoopDataPrefetch.h\"\n#include \"llvm/Transforms/Scalar/LoopDeletion.h\"\n#include \"llvm/Transforms/Scalar/LoopDistribute.h\"\n#include \"llvm/Transforms/Scalar/LoopFlatten.h\"\n#include \"llvm/Transforms/Scalar/LoopFuse.h\"\n#include \"llvm/Transforms/Scalar/LoopIdiomRecognize.h\"\n#include \"llvm/Transforms/Scalar/LoopInstSimplify.h\"\n#include \"llvm/Transforms/Scalar/LoopInterchange.h\"\n#include \"llvm/Transforms/Scalar/LoopLoadElimination.h\"\n#include \"llvm/Transforms/Scalar/LoopPassManager.h\"\n#include \"llvm/Transforms/Scalar/LoopPredication.h\"\n#include \"llvm/Transforms/Scalar/LoopReroll.h\"\n#include \"llvm/Transforms/Scalar/LoopRotation.h\"\n#include \"llvm/Transforms/Scalar/LoopSimplifyCFG.h\"\n#include \"llvm/Transforms/Scalar/LoopSink.h\"\n#include \"llvm/Transforms/Scalar/LoopStrengthReduce.h\"\n#include \"llvm/Transforms/Scalar/LoopUnrollAndJamPass.h\"\n#include \"llvm/Transforms/Scalar/LoopUnrollPass.h\"\n#include \"llvm/Transforms/Scalar/LoopVersioningLICM.h\"\n#include \"llvm/Transforms/Scalar/LowerAtomic.h\"\n#include \"llvm/Transforms/Scalar/LowerConstantIntrinsics.h\"\n#include \"llvm/Transforms/Scalar/LowerExpectIntrinsic.h\"\n#include \"llvm/Transforms/Scalar/LowerGuardIntrinsic.h\"\n#include \"llvm/Transforms/Scalar/LowerMatrixIntrinsics.h\"\n#include \"llvm/Transforms/Scalar/LowerWidenableCondition.h\"\n#include \"llvm/Transforms/Scalar/MakeGuardsExplicit.h\"\n#include \"llvm/Transforms/Scalar/MemCpyOptimizer.h\"\n#include \"llvm/Transforms/Scalar/MergeICmps.h\"\n#include \"llvm/Transforms/Scalar/MergedLoadStoreMotion.h\"\n#include \"llvm/Transforms/Scalar/NaryReassociate.h\"\n#include \"llvm/Transforms/Scalar/NewGVN.h\"\n#include \"llvm/Transforms/Scalar/PartiallyInlineLibCalls.h\"\n#include \"llvm/Transforms/Scalar/Reassociate.h\"\n#include \"llvm/Transforms/Scalar/Reg2Mem.h\"\n#include \"llvm/Transforms/Scalar/RewriteStatepointsForGC.h\"\n#include \"llvm/Transforms/Scalar/SCCP.h\"\n#include \"llvm/Transforms/Scalar/SROA.h\"\n#include \"llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h\"\n#include \"llvm/Transforms/Scalar/Scalarizer.h\"\n#include \"llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h\"\n#include \"llvm/Transforms/Scalar/SimpleLoopUnswitch.h\"\n#include \"llvm/Transforms/Scalar/SimplifyCFG.h\"\n#include \"llvm/Transforms/Scalar/Sink.h\"\n#include \"llvm/Transforms/Scalar/SpeculateAroundPHIs.h\"\n#include \"llvm/Transforms/Scalar/SpeculativeExecution.h\"\n#include \"llvm/Transforms/Scalar/StraightLineStrengthReduce.h\"\n#include \"llvm/Transforms/Scalar/StructurizeCFG.h\"\n#include \"llvm/Transforms/Scalar/TailRecursionElimination.h\"\n#include \"llvm/Transforms/Scalar/WarnMissedTransforms.h\"\n#include \"llvm/Transforms/Utils/AddDiscriminators.h\"\n#include \"llvm/Transforms/Utils/AssumeBundleBuilder.h\"\n#include \"llvm/Transforms/Utils/BreakCriticalEdges.h\"\n#include \"llvm/Transforms/Utils/CanonicalizeAliases.h\"\n#include \"llvm/Transforms/Utils/CanonicalizeFreezeInLoops.h\"\n#include \"llvm/Transforms/Utils/EntryExitInstrumenter.h\"\n#include \"llvm/Transforms/Utils/FixIrreducible.h\"\n#include \"llvm/Transforms/Utils/HelloWorld.h\"\n#include \"llvm/Transforms/Utils/InjectTLIMappings.h\"\n#include \"llvm/Transforms/Utils/InstructionNamer.h\"\n#include \"llvm/Transforms/Utils/LCSSA.h\"\n#include \"llvm/Transforms/Utils/LibCallsShrinkWrap.h\"\n#include \"llvm/Transforms/Utils/LoopSimplify.h\"\n#include \"llvm/Transforms/Utils/LoopVersioning.h\"\n#include \"llvm/Transforms/Utils/LowerInvoke.h\"\n#include \"llvm/Transforms/Utils/LowerSwitch.h\"\n#include \"llvm/Transforms/Utils/Mem2Reg.h\"\n#include \"llvm/Transforms/Utils/MetaRenamer.h\"\n#include \"llvm/Transforms/Utils/NameAnonGlobals.h\"\n#include \"llvm/Transforms/Utils/StripGCRelocates.h\"\n#include \"llvm/Transforms/Utils/StripNonLineTableDebugInfo.h\"\n#include \"llvm/Transforms/Utils/SymbolRewriter.h\"\n#include \"llvm/Transforms/Utils/UnifyFunctionExitNodes.h\"\n#include \"llvm/Transforms/Utils/UnifyLoopExits.h\"\n#include \"llvm/Transforms/Vectorize/LoadStoreVectorizer.h\"\n#include \"llvm/Transforms/Vectorize/LoopVectorize.h\"\n#include \"llvm/Transforms/Vectorize/SLPVectorizer.h\"\n#include \"llvm/Transforms/Vectorize/VectorCombine.h\"\n\nusing namespace llvm;\n\nextern cl::opt<unsigned> MaxDevirtIterations;\n\nstatic cl::opt<InliningAdvisorMode> UseInlineAdvisor(\n    \"enable-ml-inliner\", cl::init(InliningAdvisorMode::Default), cl::Hidden,\n    cl::desc(\"Enable ML policy for inliner. Currently trained for -Oz only\"),\n    cl::values(clEnumValN(InliningAdvisorMode::Default, \"default\",\n                          \"Heuristics-based inliner version.\"),\n               clEnumValN(InliningAdvisorMode::Development, \"development\",\n                          \"Use development mode (runtime-loadable model).\"),\n               clEnumValN(InliningAdvisorMode::Release, \"release\",\n                          \"Use release mode (AOT-compiled model).\")));\n\nstatic cl::opt<bool> EnableSyntheticCounts(\n    \"enable-npm-synthetic-counts\", cl::init(false), cl::Hidden, cl::ZeroOrMore,\n    cl::desc(\"Run synthetic function entry count generation \"\n             \"pass\"));\n\nstatic const Regex DefaultAliasRegex(\n    \"^(default|thinlto-pre-link|thinlto|lto-pre-link|lto)<(O[0123sz])>$\");\n\n/// Flag to enable inline deferral during PGO.\nstatic cl::opt<bool>\n    EnablePGOInlineDeferral(\"enable-npm-pgo-inline-deferral\", cl::init(true),\n                            cl::Hidden,\n                            cl::desc(\"Enable inline deferral during PGO\"));\n\nstatic cl::opt<bool> EnableMemProfiler(\"enable-mem-prof\", cl::init(false),\n                                       cl::Hidden, cl::ZeroOrMore,\n                                       cl::desc(\"Enable memory profiler\"));\n\nstatic cl::opt<bool> PerformMandatoryInliningsFirst(\n    \"mandatory-inlining-first\", cl::init(true), cl::Hidden, cl::ZeroOrMore,\n    cl::desc(\"Perform mandatory inlinings module-wide, before performing \"\n             \"inlining.\"));\n\nstatic cl::opt<bool> EnableO3NonTrivialUnswitching(\n    \"enable-npm-O3-nontrivial-unswitch\", cl::init(true), cl::Hidden,\n    cl::ZeroOrMore, cl::desc(\"Enable non-trivial loop unswitching for -O3\"));\n\nPipelineTuningOptions::PipelineTuningOptions() {\n  LoopInterleaving = true;\n  LoopVectorization = true;\n  SLPVectorization = false;\n  LoopUnrolling = true;\n  ForgetAllSCEVInLoopUnroll = ForgetSCEVInLoopUnroll;\n  Coroutines = false;\n  LicmMssaOptCap = SetLicmMssaOptCap;\n  LicmMssaNoAccForPromotionCap = SetLicmMssaNoAccForPromotionCap;\n  CallGraphProfile = true;\n  MergeFunctions = false;\n}\nextern cl::opt<bool> ExtraVectorizerPasses;\n\nextern cl::opt<bool> EnableConstraintElimination;\nextern cl::opt<bool> EnableGVNHoist;\nextern cl::opt<bool> EnableGVNSink;\nextern cl::opt<bool> EnableHotColdSplit;\nextern cl::opt<bool> EnableIROutliner;\nextern cl::opt<bool> EnableOrderFileInstrumentation;\nextern cl::opt<bool> EnableCHR;\nextern cl::opt<bool> EnableLoopInterchange;\nextern cl::opt<bool> EnableUnrollAndJam;\nextern cl::opt<bool> EnableLoopFlatten;\nextern cl::opt<bool> RunNewGVN;\nextern cl::opt<bool> RunPartialInlining;\n\nextern cl::opt<bool> FlattenedProfileUsed;\n\nextern cl::opt<AttributorRunOption> AttributorRun;\nextern cl::opt<bool> EnableKnowledgeRetention;\n\nextern cl::opt<bool> EnableMatrix;\n\nextern cl::opt<bool> DisablePreInliner;\nextern cl::opt<int> PreInlineThreshold;\n\nconst PassBuilder::OptimizationLevel PassBuilder::OptimizationLevel::O0 = {\n    /*SpeedLevel*/ 0,\n    /*SizeLevel*/ 0};\nconst PassBuilder::OptimizationLevel PassBuilder::OptimizationLevel::O1 = {\n    /*SpeedLevel*/ 1,\n    /*SizeLevel*/ 0};\nconst PassBuilder::OptimizationLevel PassBuilder::OptimizationLevel::O2 = {\n    /*SpeedLevel*/ 2,\n    /*SizeLevel*/ 0};\nconst PassBuilder::OptimizationLevel PassBuilder::OptimizationLevel::O3 = {\n    /*SpeedLevel*/ 3,\n    /*SizeLevel*/ 0};\nconst PassBuilder::OptimizationLevel PassBuilder::OptimizationLevel::Os = {\n    /*SpeedLevel*/ 2,\n    /*SizeLevel*/ 1};\nconst PassBuilder::OptimizationLevel PassBuilder::OptimizationLevel::Oz = {\n    /*SpeedLevel*/ 2,\n    /*SizeLevel*/ 2};\n\nnamespace {\n\n// The following passes/analyses have custom names, otherwise their name will\n// include `(anonymous namespace)`. These are special since they are only for\n// testing purposes and don't live in a header file.\n\n/// No-op module pass which does nothing.\nstruct NoOpModulePass : PassInfoMixin<NoOpModulePass> {\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &) {\n    return PreservedAnalyses::all();\n  }\n\n  static StringRef name() { return \"NoOpModulePass\"; }\n};\n\n/// No-op module analysis.\nclass NoOpModuleAnalysis : public AnalysisInfoMixin<NoOpModuleAnalysis> {\n  friend AnalysisInfoMixin<NoOpModuleAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  struct Result {};\n  Result run(Module &, ModuleAnalysisManager &) { return Result(); }\n  static StringRef name() { return \"NoOpModuleAnalysis\"; }\n};\n\n/// No-op CGSCC pass which does nothing.\nstruct NoOpCGSCCPass : PassInfoMixin<NoOpCGSCCPass> {\n  PreservedAnalyses run(LazyCallGraph::SCC &C, CGSCCAnalysisManager &,\n                        LazyCallGraph &, CGSCCUpdateResult &UR) {\n    return PreservedAnalyses::all();\n  }\n  static StringRef name() { return \"NoOpCGSCCPass\"; }\n};\n\n/// No-op CGSCC analysis.\nclass NoOpCGSCCAnalysis : public AnalysisInfoMixin<NoOpCGSCCAnalysis> {\n  friend AnalysisInfoMixin<NoOpCGSCCAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  struct Result {};\n  Result run(LazyCallGraph::SCC &, CGSCCAnalysisManager &, LazyCallGraph &G) {\n    return Result();\n  }\n  static StringRef name() { return \"NoOpCGSCCAnalysis\"; }\n};\n\n/// No-op function pass which does nothing.\nstruct NoOpFunctionPass : PassInfoMixin<NoOpFunctionPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &) {\n    return PreservedAnalyses::all();\n  }\n  static StringRef name() { return \"NoOpFunctionPass\"; }\n};\n\n/// No-op function analysis.\nclass NoOpFunctionAnalysis : public AnalysisInfoMixin<NoOpFunctionAnalysis> {\n  friend AnalysisInfoMixin<NoOpFunctionAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  struct Result {};\n  Result run(Function &, FunctionAnalysisManager &) { return Result(); }\n  static StringRef name() { return \"NoOpFunctionAnalysis\"; }\n};\n\n/// No-op loop pass which does nothing.\nstruct NoOpLoopPass : PassInfoMixin<NoOpLoopPass> {\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &,\n                        LoopStandardAnalysisResults &, LPMUpdater &) {\n    return PreservedAnalyses::all();\n  }\n  static StringRef name() { return \"NoOpLoopPass\"; }\n};\n\n/// No-op loop analysis.\nclass NoOpLoopAnalysis : public AnalysisInfoMixin<NoOpLoopAnalysis> {\n  friend AnalysisInfoMixin<NoOpLoopAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  struct Result {};\n  Result run(Loop &, LoopAnalysisManager &, LoopStandardAnalysisResults &) {\n    return Result();\n  }\n  static StringRef name() { return \"NoOpLoopAnalysis\"; }\n};\n\nAnalysisKey NoOpModuleAnalysis::Key;\nAnalysisKey NoOpCGSCCAnalysis::Key;\nAnalysisKey NoOpFunctionAnalysis::Key;\nAnalysisKey NoOpLoopAnalysis::Key;\n\n/// Whether or not we should populate a PassInstrumentationCallbacks's class to\n/// pass name map.\n///\n/// This is for optimization purposes so we don't populate it if we never use\n/// it. This should be updated if new pass instrumentation wants to use the map.\n/// We currently only use this for --print-before/after.\nbool shouldPopulateClassToPassNames() {\n  return !printBeforePasses().empty() || !printAfterPasses().empty();\n}\n\n} // namespace\n\nPassBuilder::PassBuilder(bool DebugLogging, TargetMachine *TM,\n                         PipelineTuningOptions PTO, Optional<PGOOptions> PGOOpt,\n                         PassInstrumentationCallbacks *PIC)\n    : DebugLogging(DebugLogging), TM(TM), PTO(PTO), PGOOpt(PGOOpt), PIC(PIC) {\n  if (TM)\n    TM->registerPassBuilderCallbacks(*this, DebugLogging);\n  if (PIC && shouldPopulateClassToPassNames()) {\n#define MODULE_PASS(NAME, CREATE_PASS)                                         \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#define MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#define FUNCTION_PASS(NAME, CREATE_PASS)                                       \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#define FUNCTION_ANALYSIS(NAME, CREATE_PASS)                                   \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#define LOOP_PASS(NAME, CREATE_PASS)                                           \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#define LOOP_ANALYSIS(NAME, CREATE_PASS)                                       \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#define CGSCC_PASS(NAME, CREATE_PASS)                                          \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#define CGSCC_ANALYSIS(NAME, CREATE_PASS)                                      \\\n  PIC->addClassToPassName(decltype(CREATE_PASS)::name(), NAME);\n#include \"PassRegistry.def\"\n  }\n}\n\nvoid PassBuilder::invokePeepholeEPCallbacks(\n    FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n  for (auto &C : PeepholeEPCallbacks)\n    C(FPM, Level);\n}\n\nvoid PassBuilder::registerModuleAnalyses(ModuleAnalysisManager &MAM) {\n#define MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \\\n  MAM.registerPass([&] { return CREATE_PASS; });\n#include \"PassRegistry.def\"\n\n  for (auto &C : ModuleAnalysisRegistrationCallbacks)\n    C(MAM);\n}\n\nvoid PassBuilder::registerCGSCCAnalyses(CGSCCAnalysisManager &CGAM) {\n#define CGSCC_ANALYSIS(NAME, CREATE_PASS)                                      \\\n  CGAM.registerPass([&] { return CREATE_PASS; });\n#include \"PassRegistry.def\"\n\n  for (auto &C : CGSCCAnalysisRegistrationCallbacks)\n    C(CGAM);\n}\n\nvoid PassBuilder::registerFunctionAnalyses(FunctionAnalysisManager &FAM) {\n#define FUNCTION_ANALYSIS(NAME, CREATE_PASS)                                   \\\n  FAM.registerPass([&] { return CREATE_PASS; });\n#include \"PassRegistry.def\"\n\n  for (auto &C : FunctionAnalysisRegistrationCallbacks)\n    C(FAM);\n}\n\nvoid PassBuilder::registerLoopAnalyses(LoopAnalysisManager &LAM) {\n#define LOOP_ANALYSIS(NAME, CREATE_PASS)                                       \\\n  LAM.registerPass([&] { return CREATE_PASS; });\n#include \"PassRegistry.def\"\n\n  for (auto &C : LoopAnalysisRegistrationCallbacks)\n    C(LAM);\n}\n\n// Helper to add AnnotationRemarksPass.\nstatic void addAnnotationRemarksPass(ModulePassManager &MPM) {\n  FunctionPassManager FPM;\n  FPM.addPass(AnnotationRemarksPass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n}\n\n// Helper to check if the current compilation phase is preparing for LTO\nstatic bool isLTOPreLink(ThinOrFullLTOPhase Phase) {\n  return Phase == ThinOrFullLTOPhase::ThinLTOPreLink ||\n         Phase == ThinOrFullLTOPhase::ThinLTOPreLink;\n}\n\n// TODO: Investigate the cost/benefit of tail call elimination on debugging.\nFunctionPassManager\nPassBuilder::buildO1FunctionSimplificationPipeline(OptimizationLevel Level,\n                                                   ThinOrFullLTOPhase Phase) {\n\n  FunctionPassManager FPM(DebugLogging);\n\n  // Form SSA out of local memory accesses after breaking apart aggregates into\n  // scalars.\n  FPM.addPass(SROA());\n\n  // Catch trivial redundancies\n  FPM.addPass(EarlyCSEPass(true /* Enable mem-ssa. */));\n\n  // Hoisting of scalars and load expressions.\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n\n  FPM.addPass(LibCallsShrinkWrapPass());\n\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  FPM.addPass(SimplifyCFGPass());\n\n  // Form canonically associated expression trees, and simplify the trees using\n  // basic mathematical properties. For example, this will form (nearly)\n  // minimal multiplication trees.\n  FPM.addPass(ReassociatePass());\n\n  // Add the primary loop simplification pipeline.\n  // FIXME: Currently this is split into two loop pass pipelines because we run\n  // some function passes in between them. These can and should be removed\n  // and/or replaced by scheduling the loop pass equivalents in the correct\n  // positions. But those equivalent passes aren't powerful enough yet.\n  // Specifically, `SimplifyCFGPass` and `InstCombinePass` are currently still\n  // used. We have `LoopSimplifyCFGPass` which isn't yet powerful enough yet to\n  // fully replace `SimplifyCFGPass`, and the closest to the other we have is\n  // `LoopInstSimplify`.\n  LoopPassManager LPM1(DebugLogging), LPM2(DebugLogging);\n\n  // Simplify the loop body. We do this initially to clean up after other loop\n  // passes run, either when iterating on a loop or on inner loops with\n  // implications on the outer loop.\n  LPM1.addPass(LoopInstSimplifyPass());\n  LPM1.addPass(LoopSimplifyCFGPass());\n\n  LPM1.addPass(LoopRotatePass(/* Disable header duplication */ true,\n                              isLTOPreLink(Phase)));\n  // TODO: Investigate promotion cap for O1.\n  LPM1.addPass(LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap));\n  LPM1.addPass(SimpleLoopUnswitchPass());\n\n  LPM2.addPass(LoopIdiomRecognizePass());\n  LPM2.addPass(IndVarSimplifyPass());\n\n  for (auto &C : LateLoopOptimizationsEPCallbacks)\n    C(LPM2, Level);\n\n  LPM2.addPass(LoopDeletionPass());\n\n  if (EnableLoopInterchange)\n    LPM2.addPass(LoopInterchangePass());\n\n  // Do not enable unrolling in PreLinkThinLTO phase during sample PGO\n  // because it changes IR to makes profile annotation in back compile\n  // inaccurate. The normal unroller doesn't pay attention to forced full unroll\n  // attributes so we need to make sure and allow the full unroll pass to pay\n  // attention to it.\n  if (Phase != ThinOrFullLTOPhase::ThinLTOPreLink || !PGOOpt ||\n      PGOOpt->Action != PGOOptions::SampleUse)\n    LPM2.addPass(LoopFullUnrollPass(Level.getSpeedupLevel(),\n                                    /* OnlyWhenForced= */ !PTO.LoopUnrolling,\n                                    PTO.ForgetAllSCEVInLoopUnroll));\n\n  for (auto &C : LoopOptimizerEndEPCallbacks)\n    C(LPM2, Level);\n\n  // We provide the opt remark emitter pass for LICM to use. We only need to do\n  // this once as it is immutable.\n  FPM.addPass(\n      RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function>());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM1), EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true,\n      DebugLogging));\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  if (EnableLoopFlatten)\n    FPM.addPass(LoopFlattenPass());\n  // The loop passes in LPM2 (LoopFullUnrollPass) do not preserve MemorySSA.\n  // *All* loop passes must preserve it, in order to be able to use it.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM2), /*UseMemorySSA=*/false, /*UseBlockFrequencyInfo=*/false,\n      DebugLogging));\n\n  // Delete small array after loop unroll.\n  FPM.addPass(SROA());\n\n  // Specially optimize memory movement as it doesn't look like dataflow in SSA.\n  FPM.addPass(MemCpyOptPass());\n\n  // Sparse conditional constant propagation.\n  // FIXME: It isn't clear why we do this *after* loop passes rather than\n  // before...\n  FPM.addPass(SCCPPass());\n\n  // Delete dead bit computations (instcombine runs after to fold away the dead\n  // computations, and then ADCE will run later to exploit any new DCE\n  // opportunities that creates).\n  FPM.addPass(BDCEPass());\n\n  // Run instcombine after redundancy and dead bit elimination to exploit\n  // opportunities opened up by them.\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  if (PTO.Coroutines)\n    FPM.addPass(CoroElidePass());\n\n  for (auto &C : ScalarOptimizerLateEPCallbacks)\n    C(FPM, Level);\n\n  // Finally, do an expensive DCE pass to catch all the dead code exposed by\n  // the simplifications and basic cleanup after all the simplifications.\n  // TODO: Investigate if this is too expensive.\n  FPM.addPass(ADCEPass());\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  return FPM;\n}\n\nFunctionPassManager\nPassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,\n                                                 ThinOrFullLTOPhase Phase) {\n  assert(Level != OptimizationLevel::O0 && \"Must request optimizations!\");\n\n  // The O1 pipeline has a separate pipeline creation function to simplify\n  // construction readability.\n  if (Level.getSpeedupLevel() == 1)\n    return buildO1FunctionSimplificationPipeline(Level, Phase);\n\n  FunctionPassManager FPM(DebugLogging);\n\n  // Form SSA out of local memory accesses after breaking apart aggregates into\n  // scalars.\n  FPM.addPass(SROA());\n\n  // Catch trivial redundancies\n  FPM.addPass(EarlyCSEPass(true /* Enable mem-ssa. */));\n  if (EnableKnowledgeRetention)\n    FPM.addPass(AssumeSimplifyPass());\n\n  // Hoisting of scalars and load expressions.\n  if (EnableGVNHoist)\n    FPM.addPass(GVNHoistPass());\n\n  // Global value numbering based sinking.\n  if (EnableGVNSink) {\n    FPM.addPass(GVNSinkPass());\n    FPM.addPass(SimplifyCFGPass());\n  }\n\n  if (EnableConstraintElimination)\n    FPM.addPass(ConstraintEliminationPass());\n\n  // Speculative execution if the target has divergent branches; otherwise nop.\n  FPM.addPass(SpeculativeExecutionPass(/* OnlyIfDivergentTarget =*/true));\n\n  // Optimize based on known information about branches, and cleanup afterward.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  FPM.addPass(SimplifyCFGPass());\n  if (Level == OptimizationLevel::O3)\n    FPM.addPass(AggressiveInstCombinePass());\n  FPM.addPass(InstCombinePass());\n\n  if (!Level.isOptimizingForSize())\n    FPM.addPass(LibCallsShrinkWrapPass());\n\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // For PGO use pipeline, try to optimize memory intrinsics such as memcpy\n  // using the size value profile. Don't perform this when optimizing for size.\n  if (PGOOpt && PGOOpt->Action == PGOOptions::IRUse &&\n      !Level.isOptimizingForSize())\n    FPM.addPass(PGOMemOPSizeOpt());\n\n  FPM.addPass(TailCallElimPass());\n  FPM.addPass(SimplifyCFGPass());\n\n  // Form canonically associated expression trees, and simplify the trees using\n  // basic mathematical properties. For example, this will form (nearly)\n  // minimal multiplication trees.\n  FPM.addPass(ReassociatePass());\n\n  // Add the primary loop simplification pipeline.\n  // FIXME: Currently this is split into two loop pass pipelines because we run\n  // some function passes in between them. These can and should be removed\n  // and/or replaced by scheduling the loop pass equivalents in the correct\n  // positions. But those equivalent passes aren't powerful enough yet.\n  // Specifically, `SimplifyCFGPass` and `InstCombinePass` are currently still\n  // used. We have `LoopSimplifyCFGPass` which isn't yet powerful enough yet to\n  // fully replace `SimplifyCFGPass`, and the closest to the other we have is\n  // `LoopInstSimplify`.\n  LoopPassManager LPM1(DebugLogging), LPM2(DebugLogging);\n\n  // Simplify the loop body. We do this initially to clean up after other loop\n  // passes run, either when iterating on a loop or on inner loops with\n  // implications on the outer loop.\n  LPM1.addPass(LoopInstSimplifyPass());\n  LPM1.addPass(LoopSimplifyCFGPass());\n\n  // Disable header duplication in loop rotation at -Oz.\n  LPM1.addPass(\n      LoopRotatePass(Level != OptimizationLevel::Oz, isLTOPreLink(Phase)));\n  // TODO: Investigate promotion cap for O1.\n  LPM1.addPass(LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap));\n  LPM1.addPass(\n      SimpleLoopUnswitchPass(/* NonTrivial */ Level == OptimizationLevel::O3 &&\n                             EnableO3NonTrivialUnswitching));\n  LPM2.addPass(LoopIdiomRecognizePass());\n  LPM2.addPass(IndVarSimplifyPass());\n\n  for (auto &C : LateLoopOptimizationsEPCallbacks)\n    C(LPM2, Level);\n\n  LPM2.addPass(LoopDeletionPass());\n\n  if (EnableLoopInterchange)\n    LPM2.addPass(LoopInterchangePass());\n\n  // Do not enable unrolling in PreLinkThinLTO phase during sample PGO\n  // because it changes IR to makes profile annotation in back compile\n  // inaccurate. The normal unroller doesn't pay attention to forced full unroll\n  // attributes so we need to make sure and allow the full unroll pass to pay\n  // attention to it.\n  if (Phase != ThinOrFullLTOPhase::ThinLTOPreLink || !PGOOpt ||\n      PGOOpt->Action != PGOOptions::SampleUse)\n    LPM2.addPass(LoopFullUnrollPass(Level.getSpeedupLevel(),\n                                    /* OnlyWhenForced= */ !PTO.LoopUnrolling,\n                                    PTO.ForgetAllSCEVInLoopUnroll));\n\n  for (auto &C : LoopOptimizerEndEPCallbacks)\n    C(LPM2, Level);\n\n  // We provide the opt remark emitter pass for LICM to use. We only need to do\n  // this once as it is immutable.\n  FPM.addPass(\n      RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function>());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM1), EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true,\n      DebugLogging));\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  if (EnableLoopFlatten)\n    FPM.addPass(LoopFlattenPass());\n  // The loop passes in LPM2 (LoopIdiomRecognizePass, IndVarSimplifyPass,\n  // LoopDeletionPass and LoopFullUnrollPass) do not preserve MemorySSA.\n  // *All* loop passes must preserve it, in order to be able to use it.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM2), /*UseMemorySSA=*/false, /*UseBlockFrequencyInfo=*/false,\n      DebugLogging));\n\n  // Delete small array after loop unroll.\n  FPM.addPass(SROA());\n\n  // Eliminate redundancies.\n  FPM.addPass(MergedLoadStoreMotionPass());\n  if (RunNewGVN)\n    FPM.addPass(NewGVNPass());\n  else\n    FPM.addPass(GVN());\n\n  // Sparse conditional constant propagation.\n  // FIXME: It isn't clear why we do this *after* loop passes rather than\n  // before...\n  FPM.addPass(SCCPPass());\n\n  // Delete dead bit computations (instcombine runs after to fold away the dead\n  // computations, and then ADCE will run later to exploit any new DCE\n  // opportunities that creates).\n  FPM.addPass(BDCEPass());\n\n  // Run instcombine after redundancy and dead bit elimination to exploit\n  // opportunities opened up by them.\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // Re-consider control flow based optimizations after redundancy elimination,\n  // redo DCE, etc.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  // Finally, do an expensive DCE pass to catch all the dead code exposed by\n  // the simplifications and basic cleanup after all the simplifications.\n  // TODO: Investigate if this is too expensive.\n  FPM.addPass(ADCEPass());\n\n  // Specially optimize memory movement as it doesn't look like dataflow in SSA.\n  FPM.addPass(MemCpyOptPass());\n\n  FPM.addPass(DSEPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap),\n      EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true, DebugLogging));\n\n  if (PTO.Coroutines)\n    FPM.addPass(CoroElidePass());\n\n  for (auto &C : ScalarOptimizerLateEPCallbacks)\n    C(FPM, Level);\n\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  if (EnableCHR && Level == OptimizationLevel::O3 && PGOOpt &&\n      (PGOOpt->Action == PGOOptions::IRUse ||\n       PGOOpt->Action == PGOOptions::SampleUse))\n    FPM.addPass(ControlHeightReductionPass());\n\n  return FPM;\n}\n\nvoid PassBuilder::addRequiredLTOPreLinkPasses(ModulePassManager &MPM) {\n  MPM.addPass(CanonicalizeAliasesPass());\n  MPM.addPass(NameAnonGlobalPass());\n}\n\nvoid PassBuilder::addPGOInstrPasses(ModulePassManager &MPM,\n                                    PassBuilder::OptimizationLevel Level,\n                                    bool RunProfileGen, bool IsCS,\n                                    std::string ProfileFile,\n                                    std::string ProfileRemappingFile) {\n  assert(Level != OptimizationLevel::O0 && \"Not expecting O0 here!\");\n  if (!IsCS && !DisablePreInliner) {\n    InlineParams IP;\n\n    IP.DefaultThreshold = PreInlineThreshold;\n\n    // FIXME: The hint threshold has the same value used by the regular inliner\n    // when not optimzing for size. This should probably be lowered after\n    // performance testing.\n    // FIXME: this comment is cargo culted from the old pass manager, revisit).\n    IP.HintThreshold = Level.isOptimizingForSize() ? PreInlineThreshold : 325;\n    ModuleInlinerWrapperPass MIWP(IP, DebugLogging);\n    CGSCCPassManager &CGPipeline = MIWP.getPM();\n\n    FunctionPassManager FPM;\n    FPM.addPass(SROA());\n    FPM.addPass(EarlyCSEPass());    // Catch trivial redundancies.\n    FPM.addPass(SimplifyCFGPass()); // Merge & remove basic blocks.\n    FPM.addPass(InstCombinePass()); // Combine silly sequences.\n    invokePeepholeEPCallbacks(FPM, Level);\n\n    CGPipeline.addPass(createCGSCCToFunctionPassAdaptor(std::move(FPM)));\n\n    MPM.addPass(std::move(MIWP));\n\n    // Delete anything that is now dead to make sure that we don't instrument\n    // dead code. Instrumentation can end up keeping dead code around and\n    // dramatically increase code size.\n    MPM.addPass(GlobalDCEPass());\n  }\n\n  if (!RunProfileGen) {\n    assert(!ProfileFile.empty() && \"Profile use expecting a profile file!\");\n    MPM.addPass(PGOInstrumentationUse(ProfileFile, ProfileRemappingFile, IsCS));\n    // Cache ProfileSummaryAnalysis once to avoid the potential need to insert\n    // RequireAnalysisPass for PSI before subsequent non-module passes.\n    MPM.addPass(RequireAnalysisPass<ProfileSummaryAnalysis, Module>());\n    return;\n  }\n\n  // Perform PGO instrumentation.\n  MPM.addPass(PGOInstrumentationGen(IsCS));\n\n  FunctionPassManager FPM;\n  // Disable header duplication in loop rotation at -Oz.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      LoopRotatePass(Level != OptimizationLevel::Oz), EnableMSSALoopDependency,\n      /*UseBlockFrequencyInfo=*/false, DebugLogging));\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n\n  // Add the profile lowering pass.\n  InstrProfOptions Options;\n  if (!ProfileFile.empty())\n    Options.InstrProfileOutput = ProfileFile;\n  // Do counter promotion at Level greater than O0.\n  Options.DoCounterPromotion = true;\n  Options.UseBFIInPromotion = IsCS;\n  MPM.addPass(InstrProfiling(Options, IsCS));\n}\n\nvoid PassBuilder::addPGOInstrPassesForO0(ModulePassManager &MPM,\n                                         bool RunProfileGen, bool IsCS,\n                                         std::string ProfileFile,\n                                         std::string ProfileRemappingFile) {\n  if (!RunProfileGen) {\n    assert(!ProfileFile.empty() && \"Profile use expecting a profile file!\");\n    MPM.addPass(PGOInstrumentationUse(ProfileFile, ProfileRemappingFile, IsCS));\n    // Cache ProfileSummaryAnalysis once to avoid the potential need to insert\n    // RequireAnalysisPass for PSI before subsequent non-module passes.\n    MPM.addPass(RequireAnalysisPass<ProfileSummaryAnalysis, Module>());\n    return;\n  }\n\n  // Perform PGO instrumentation.\n  MPM.addPass(PGOInstrumentationGen(IsCS));\n  // Add the profile lowering pass.\n  InstrProfOptions Options;\n  if (!ProfileFile.empty())\n    Options.InstrProfileOutput = ProfileFile;\n  // Do not do counter promotion at O0.\n  Options.DoCounterPromotion = false;\n  Options.UseBFIInPromotion = IsCS;\n  MPM.addPass(InstrProfiling(Options, IsCS));\n}\n\nstatic InlineParams\ngetInlineParamsFromOptLevel(PassBuilder::OptimizationLevel Level) {\n  return getInlineParams(Level.getSpeedupLevel(), Level.getSizeLevel());\n}\n\nModuleInlinerWrapperPass\nPassBuilder::buildInlinerPipeline(OptimizationLevel Level,\n                                  ThinOrFullLTOPhase Phase) {\n  InlineParams IP = getInlineParamsFromOptLevel(Level);\n  if (Phase == ThinOrFullLTOPhase::ThinLTOPreLink && PGOOpt &&\n      PGOOpt->Action == PGOOptions::SampleUse)\n    IP.HotCallSiteThreshold = 0;\n\n  if (PGOOpt)\n    IP.EnableDeferral = EnablePGOInlineDeferral;\n\n  ModuleInlinerWrapperPass MIWP(IP, DebugLogging,\n                                PerformMandatoryInliningsFirst,\n                                UseInlineAdvisor, MaxDevirtIterations);\n\n  // Require the GlobalsAA analysis for the module so we can query it within\n  // the CGSCC pipeline.\n  MIWP.addRequiredModuleAnalysis<GlobalsAA>();\n\n  // Require the ProfileSummaryAnalysis for the module so we can query it within\n  // the inliner pass.\n  MIWP.addRequiredModuleAnalysis<ProfileSummaryAnalysis>();\n\n  // Now begin the main postorder CGSCC pipeline.\n  // FIXME: The current CGSCC pipeline has its origins in the legacy pass\n  // manager and trying to emulate its precise behavior. Much of this doesn't\n  // make a lot of sense and we should revisit the core CGSCC structure.\n  CGSCCPassManager &MainCGPipeline = MIWP.getPM();\n\n  // Note: historically, the PruneEH pass was run first to deduce nounwind and\n  // generally clean up exception handling overhead. It isn't clear this is\n  // valuable as the inliner doesn't currently care whether it is inlining an\n  // invoke or a call.\n\n  if (AttributorRun & AttributorRunOption::CGSCC)\n    MainCGPipeline.addPass(AttributorCGSCCPass());\n\n  if (PTO.Coroutines)\n    MainCGPipeline.addPass(CoroSplitPass(Level != OptimizationLevel::O0));\n\n  // Now deduce any function attributes based in the current code.\n  MainCGPipeline.addPass(PostOrderFunctionAttrsPass());\n\n  // When at O3 add argument promotion to the pass pipeline.\n  // FIXME: It isn't at all clear why this should be limited to O3.\n  if (Level == OptimizationLevel::O3)\n    MainCGPipeline.addPass(ArgumentPromotionPass());\n\n  // Try to perform OpenMP specific optimizations. This is a (quick!) no-op if\n  // there are no OpenMP runtime calls present in the module.\n  if (Level == OptimizationLevel::O2 || Level == OptimizationLevel::O3)\n    MainCGPipeline.addPass(OpenMPOptPass());\n\n  for (auto &C : CGSCCOptimizerLateEPCallbacks)\n    C(MainCGPipeline, Level);\n\n  // Lastly, add the core function simplification pipeline nested inside the\n  // CGSCC walk.\n  MainCGPipeline.addPass(createCGSCCToFunctionPassAdaptor(\n      buildFunctionSimplificationPipeline(Level, Phase)));\n\n  return MIWP;\n}\n\nModulePassManager\nPassBuilder::buildModuleSimplificationPipeline(OptimizationLevel Level,\n                                               ThinOrFullLTOPhase Phase) {\n  ModulePassManager MPM(DebugLogging);\n\n  // Place pseudo probe instrumentation as the first pass of the pipeline to\n  // minimize the impact of optimization changes.\n  if (PGOOpt && PGOOpt->PseudoProbeForProfiling &&\n      Phase != ThinOrFullLTOPhase::ThinLTOPostLink)\n    MPM.addPass(SampleProfileProbePass(TM));\n\n  bool HasSampleProfile = PGOOpt && (PGOOpt->Action == PGOOptions::SampleUse);\n\n  // In ThinLTO mode, when flattened profile is used, all the available\n  // profile information will be annotated in PreLink phase so there is\n  // no need to load the profile again in PostLink.\n  bool LoadSampleProfile =\n      HasSampleProfile &&\n      !(FlattenedProfileUsed && Phase == ThinOrFullLTOPhase::ThinLTOPostLink);\n\n  // During the ThinLTO backend phase we perform early indirect call promotion\n  // here, before globalopt. Otherwise imported available_externally functions\n  // look unreferenced and are removed. If we are going to load the sample\n  // profile then defer until later.\n  // TODO: See if we can move later and consolidate with the location where\n  // we perform ICP when we are loading a sample profile.\n  // TODO: We pass HasSampleProfile (whether there was a sample profile file\n  // passed to the compile) to the SamplePGO flag of ICP. This is used to\n  // determine whether the new direct calls are annotated with prof metadata.\n  // Ideally this should be determined from whether the IR is annotated with\n  // sample profile, and not whether the a sample profile was provided on the\n  // command line. E.g. for flattened profiles where we will not be reloading\n  // the sample profile in the ThinLTO backend, we ideally shouldn't have to\n  // provide the sample profile file.\n  if (Phase == ThinOrFullLTOPhase::ThinLTOPostLink && !LoadSampleProfile)\n    MPM.addPass(PGOIndirectCallPromotion(true /* InLTO */, HasSampleProfile));\n\n  // Do basic inference of function attributes from known properties of system\n  // libraries and other oracles.\n  MPM.addPass(InferFunctionAttrsPass());\n\n  // Create an early function pass manager to cleanup the output of the\n  // frontend.\n  FunctionPassManager EarlyFPM(DebugLogging);\n  EarlyFPM.addPass(SimplifyCFGPass());\n  EarlyFPM.addPass(SROA());\n  EarlyFPM.addPass(EarlyCSEPass());\n  EarlyFPM.addPass(LowerExpectIntrinsicPass());\n  if (PTO.Coroutines)\n    EarlyFPM.addPass(CoroEarlyPass());\n  if (Level == OptimizationLevel::O3)\n    EarlyFPM.addPass(CallSiteSplittingPass());\n\n  // In SamplePGO ThinLTO backend, we need instcombine before profile annotation\n  // to convert bitcast to direct calls so that they can be inlined during the\n  // profile annotation prepration step.\n  // More details about SamplePGO design can be found in:\n  // https://research.google.com/pubs/pub45290.html\n  // FIXME: revisit how SampleProfileLoad/Inliner/ICP is structured.\n  if (LoadSampleProfile)\n    EarlyFPM.addPass(InstCombinePass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(EarlyFPM)));\n\n  if (LoadSampleProfile) {\n    // Annotate sample profile right after early FPM to ensure freshness of\n    // the debug info.\n    MPM.addPass(SampleProfileLoaderPass(PGOOpt->ProfileFile,\n                                        PGOOpt->ProfileRemappingFile, Phase));\n    // Cache ProfileSummaryAnalysis once to avoid the potential need to insert\n    // RequireAnalysisPass for PSI before subsequent non-module passes.\n    MPM.addPass(RequireAnalysisPass<ProfileSummaryAnalysis, Module>());\n    // Do not invoke ICP in the LTOPrelink phase as it makes it hard\n    // for the profile annotation to be accurate in the LTO backend.\n    if (Phase != ThinOrFullLTOPhase::ThinLTOPreLink &&\n        Phase != ThinOrFullLTOPhase::FullLTOPreLink)\n      // We perform early indirect call promotion here, before globalopt.\n      // This is important for the ThinLTO backend phase because otherwise\n      // imported available_externally functions look unreferenced and are\n      // removed.\n      MPM.addPass(\n          PGOIndirectCallPromotion(true /* IsInLTO */, true /* SamplePGO */));\n  }\n\n  if (AttributorRun & AttributorRunOption::MODULE)\n    MPM.addPass(AttributorPass());\n\n  // Lower type metadata and the type.test intrinsic in the ThinLTO\n  // post link pipeline after ICP. This is to enable usage of the type\n  // tests in ICP sequences.\n  if (Phase == ThinOrFullLTOPhase::ThinLTOPostLink)\n    MPM.addPass(LowerTypeTestsPass(nullptr, nullptr, true));\n\n  for (auto &C : PipelineEarlySimplificationEPCallbacks)\n    C(MPM, Level);\n\n  // Interprocedural constant propagation now that basic cleanup has occurred\n  // and prior to optimizing globals.\n  // FIXME: This position in the pipeline hasn't been carefully considered in\n  // years, it should be re-analyzed.\n  MPM.addPass(IPSCCPPass());\n\n  // Attach metadata to indirect call sites indicating the set of functions\n  // they may target at run-time. This should follow IPSCCP.\n  MPM.addPass(CalledValuePropagationPass());\n\n  // Optimize globals to try and fold them into constants.\n  MPM.addPass(GlobalOptPass());\n\n  // Promote any localized globals to SSA registers.\n  // FIXME: Should this instead by a run of SROA?\n  // FIXME: We should probably run instcombine and simplify-cfg afterward to\n  // delete control flows that are dead once globals have been folded to\n  // constants.\n  MPM.addPass(createModuleToFunctionPassAdaptor(PromotePass()));\n\n  // Remove any dead arguments exposed by cleanups and constant folding\n  // globals.\n  MPM.addPass(DeadArgumentEliminationPass());\n\n  // Create a small function pass pipeline to cleanup after all the global\n  // optimizations.\n  FunctionPassManager GlobalCleanupPM(DebugLogging);\n  GlobalCleanupPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(GlobalCleanupPM, Level);\n\n  GlobalCleanupPM.addPass(SimplifyCFGPass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(GlobalCleanupPM)));\n\n  // Add all the requested passes for instrumentation PGO, if requested.\n  if (PGOOpt && Phase != ThinOrFullLTOPhase::ThinLTOPostLink &&\n      (PGOOpt->Action == PGOOptions::IRInstr ||\n       PGOOpt->Action == PGOOptions::IRUse)) {\n    addPGOInstrPasses(MPM, Level,\n                      /* RunProfileGen */ PGOOpt->Action == PGOOptions::IRInstr,\n                      /* IsCS */ false, PGOOpt->ProfileFile,\n                      PGOOpt->ProfileRemappingFile);\n    MPM.addPass(PGOIndirectCallPromotion(false, false));\n  }\n  if (PGOOpt && Phase != ThinOrFullLTOPhase::ThinLTOPostLink &&\n      PGOOpt->CSAction == PGOOptions::CSIRInstr)\n    MPM.addPass(PGOInstrumentationGenCreateVar(PGOOpt->CSProfileGenFile));\n\n  // Synthesize function entry counts for non-PGO compilation.\n  if (EnableSyntheticCounts && !PGOOpt)\n    MPM.addPass(SyntheticCountsPropagation());\n\n  MPM.addPass(buildInlinerPipeline(Level, Phase));\n\n  if (EnableMemProfiler && Phase != ThinOrFullLTOPhase::ThinLTOPreLink) {\n    MPM.addPass(createModuleToFunctionPassAdaptor(MemProfilerPass()));\n    MPM.addPass(ModuleMemProfilerPass());\n  }\n\n  return MPM;\n}\n\nModulePassManager\nPassBuilder::buildModuleOptimizationPipeline(OptimizationLevel Level,\n                                             bool LTOPreLink) {\n  ModulePassManager MPM(DebugLogging);\n\n  // Optimize globals now that the module is fully simplified.\n  MPM.addPass(GlobalOptPass());\n  MPM.addPass(GlobalDCEPass());\n\n  // Run partial inlining pass to partially inline functions that have\n  // large bodies.\n  if (RunPartialInlining)\n    MPM.addPass(PartialInlinerPass());\n\n  // Remove avail extern fns and globals definitions since we aren't compiling\n  // an object file for later LTO. For LTO we want to preserve these so they\n  // are eligible for inlining at link-time. Note if they are unreferenced they\n  // will be removed by GlobalDCE later, so this only impacts referenced\n  // available externally globals. Eventually they will be suppressed during\n  // codegen, but eliminating here enables more opportunity for GlobalDCE as it\n  // may make globals referenced by available external functions dead and saves\n  // running remaining passes on the eliminated functions. These should be\n  // preserved during prelinking for link-time inlining decisions.\n  if (!LTOPreLink)\n    MPM.addPass(EliminateAvailableExternallyPass());\n\n  if (EnableOrderFileInstrumentation)\n    MPM.addPass(InstrOrderFilePass());\n\n  // Do RPO function attribute inference across the module to forward-propagate\n  // attributes where applicable.\n  // FIXME: Is this really an optimization rather than a canonicalization?\n  MPM.addPass(ReversePostOrderFunctionAttrsPass());\n\n  // Do a post inline PGO instrumentation and use pass. This is a context\n  // sensitive PGO pass. We don't want to do this in LTOPreLink phrase as\n  // cross-module inline has not been done yet. The context sensitive\n  // instrumentation is after all the inlines are done.\n  if (!LTOPreLink && PGOOpt) {\n    if (PGOOpt->CSAction == PGOOptions::CSIRInstr)\n      addPGOInstrPasses(MPM, Level, /* RunProfileGen */ true,\n                        /* IsCS */ true, PGOOpt->CSProfileGenFile,\n                        PGOOpt->ProfileRemappingFile);\n    else if (PGOOpt->CSAction == PGOOptions::CSIRUse)\n      addPGOInstrPasses(MPM, Level, /* RunProfileGen */ false,\n                        /* IsCS */ true, PGOOpt->ProfileFile,\n                        PGOOpt->ProfileRemappingFile);\n  }\n\n  // Re-require GloblasAA here prior to function passes. This is particularly\n  // useful as the above will have inlined, DCE'ed, and function-attr\n  // propagated everything. We should at this point have a reasonably minimal\n  // and richly annotated call graph. By computing aliasing and mod/ref\n  // information for all local globals here, the late loop passes and notably\n  // the vectorizer will be able to use them to help recognize vectorizable\n  // memory operations.\n  MPM.addPass(RequireAnalysisPass<GlobalsAA, Module>());\n\n  FunctionPassManager OptimizePM(DebugLogging);\n  OptimizePM.addPass(Float2IntPass());\n  OptimizePM.addPass(LowerConstantIntrinsicsPass());\n\n  if (EnableMatrix) {\n    OptimizePM.addPass(LowerMatrixIntrinsicsPass());\n    OptimizePM.addPass(EarlyCSEPass());\n  }\n\n  // FIXME: We need to run some loop optimizations to re-rotate loops after\n  // simplify-cfg and others undo their rotation.\n\n  // Optimize the loop execution. These passes operate on entire loop nests\n  // rather than on each loop in an inside-out manner, and so they are actually\n  // function passes.\n\n  for (auto &C : VectorizerStartEPCallbacks)\n    C(OptimizePM, Level);\n\n  // First rotate loops that may have been un-rotated by prior passes.\n  // Disable header duplication at -Oz.\n  OptimizePM.addPass(createFunctionToLoopPassAdaptor(\n      LoopRotatePass(Level != OptimizationLevel::Oz, LTOPreLink),\n      EnableMSSALoopDependency,\n      /*UseBlockFrequencyInfo=*/false, DebugLogging));\n\n  // Distribute loops to allow partial vectorization.  I.e. isolate dependences\n  // into separate loop that would otherwise inhibit vectorization.  This is\n  // currently only performed for loops marked with the metadata\n  // llvm.loop.distribute=true or when -enable-loop-distribute is specified.\n  OptimizePM.addPass(LoopDistributePass());\n\n  // Populates the VFABI attribute with the scalar-to-vector mappings\n  // from the TargetLibraryInfo.\n  OptimizePM.addPass(InjectTLIMappings());\n\n  // Now run the core loop vectorizer.\n  OptimizePM.addPass(LoopVectorizePass(\n      LoopVectorizeOptions(!PTO.LoopInterleaving, !PTO.LoopVectorization)));\n\n  // Eliminate loads by forwarding stores from the previous iteration to loads\n  // of the current iteration.\n  OptimizePM.addPass(LoopLoadEliminationPass());\n\n  // Cleanup after the loop optimization passes.\n  OptimizePM.addPass(InstCombinePass());\n\n  if (Level.getSpeedupLevel() > 1 && ExtraVectorizerPasses) {\n    // At higher optimization levels, try to clean up any runtime overlap and\n    // alignment checks inserted by the vectorizer. We want to track correlated\n    // runtime checks for two inner loops in the same outer loop, fold any\n    // common computations, hoist loop-invariant aspects out of any outer loop,\n    // and unswitch the runtime checks if possible. Once hoisted, we may have\n    // dead (or speculatable) control flows or more combining opportunities.\n    OptimizePM.addPass(EarlyCSEPass());\n    OptimizePM.addPass(CorrelatedValuePropagationPass());\n    OptimizePM.addPass(InstCombinePass());\n    LoopPassManager LPM(DebugLogging);\n    LPM.addPass(LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap));\n    LPM.addPass(\n        SimpleLoopUnswitchPass(/* NonTrivial */ Level == OptimizationLevel::O3));\n    OptimizePM.addPass(RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function>());\n    OptimizePM.addPass(createFunctionToLoopPassAdaptor(\n        std::move(LPM), EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true,\n        DebugLogging));\n    OptimizePM.addPass(SimplifyCFGPass());\n    OptimizePM.addPass(InstCombinePass());\n  }\n\n  // Now that we've formed fast to execute loop structures, we do further\n  // optimizations. These are run afterward as they might block doing complex\n  // analyses and transforms such as what are needed for loop vectorization.\n\n  // Cleanup after loop vectorization, etc. Simplification passes like CVP and\n  // GVN, loop transforms, and others have already run, so it's now better to\n  // convert to more optimized IR using more aggressive simplify CFG options.\n  // The extra sinking transform can create larger basic blocks, so do this\n  // before SLP vectorization.\n  // FIXME: study whether hoisting and/or sinking of common instructions should\n  //        be delayed until after SLP vectorizer.\n  OptimizePM.addPass(SimplifyCFGPass(SimplifyCFGOptions()\n                                         .forwardSwitchCondToPhi(true)\n                                         .convertSwitchToLookupTable(true)\n                                         .needCanonicalLoops(false)\n                                         .hoistCommonInsts(true)\n                                         .sinkCommonInsts(true)));\n\n  // Optimize parallel scalar instruction chains into SIMD instructions.\n  if (PTO.SLPVectorization) {\n    OptimizePM.addPass(SLPVectorizerPass());\n    if (Level.getSpeedupLevel() > 1 && ExtraVectorizerPasses) {\n      OptimizePM.addPass(EarlyCSEPass());\n    }\n  }\n\n  // Enhance/cleanup vector code.\n  OptimizePM.addPass(VectorCombinePass());\n  OptimizePM.addPass(InstCombinePass());\n\n  // Unroll small loops to hide loop backedge latency and saturate any parallel\n  // execution resources of an out-of-order processor. We also then need to\n  // clean up redundancies and loop invariant code.\n  // FIXME: It would be really good to use a loop-integrated instruction\n  // combiner for cleanup here so that the unrolling and LICM can be pipelined\n  // across the loop nests.\n  // We do UnrollAndJam in a separate LPM to ensure it happens before unroll\n  if (EnableUnrollAndJam && PTO.LoopUnrolling) {\n    OptimizePM.addPass(LoopUnrollAndJamPass(Level.getSpeedupLevel()));\n  }\n  OptimizePM.addPass(LoopUnrollPass(LoopUnrollOptions(\n      Level.getSpeedupLevel(), /*OnlyWhenForced=*/!PTO.LoopUnrolling,\n      PTO.ForgetAllSCEVInLoopUnroll)));\n  OptimizePM.addPass(WarnMissedTransformationsPass());\n  OptimizePM.addPass(InstCombinePass());\n  OptimizePM.addPass(RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function>());\n  OptimizePM.addPass(createFunctionToLoopPassAdaptor(\n      LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap),\n      EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true, DebugLogging));\n\n  // Now that we've vectorized and unrolled loops, we may have more refined\n  // alignment information, try to re-derive it here.\n  OptimizePM.addPass(AlignmentFromAssumptionsPass());\n\n  // Split out cold code. Splitting is done late to avoid hiding context from\n  // other optimizations and inadvertently regressing performance. The tradeoff\n  // is that this has a higher code size cost than splitting early.\n  if (EnableHotColdSplit && !LTOPreLink)\n    MPM.addPass(HotColdSplittingPass());\n\n  // Search the code for similar regions of code. If enough similar regions can\n  // be found where extracting the regions into their own function will decrease\n  // the size of the program, we extract the regions, a deduplicate the\n  // structurally similar regions.\n  if (EnableIROutliner)\n    MPM.addPass(IROutlinerPass());\n\n  // Merge functions if requested.\n  if (PTO.MergeFunctions)\n    MPM.addPass(MergeFunctionsPass());\n\n  // LoopSink pass sinks instructions hoisted by LICM, which serves as a\n  // canonicalization pass that enables other optimizations. As a result,\n  // LoopSink pass needs to be a very late IR pass to avoid undoing LICM\n  // result too early.\n  OptimizePM.addPass(LoopSinkPass());\n\n  // And finally clean up LCSSA form before generating code.\n  OptimizePM.addPass(InstSimplifyPass());\n\n  // This hoists/decomposes div/rem ops. It should run after other sink/hoist\n  // passes to avoid re-sinking, but before SimplifyCFG because it can allow\n  // flattening of blocks.\n  OptimizePM.addPass(DivRemPairsPass());\n\n  // LoopSink (and other loop passes since the last simplifyCFG) might have\n  // resulted in single-entry-single-exit or empty blocks. Clean up the CFG.\n  OptimizePM.addPass(SimplifyCFGPass());\n\n  // Optimize PHIs by speculating around them when profitable. Note that this\n  // pass needs to be run after any PRE or similar pass as it is essentially\n  // inserting redundancies into the program. This even includes SimplifyCFG.\n  OptimizePM.addPass(SpeculateAroundPHIsPass());\n\n  if (PTO.Coroutines)\n    OptimizePM.addPass(CoroCleanupPass());\n\n  // Add the core optimizing pipeline.\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(OptimizePM)));\n\n  for (auto &C : OptimizerLastEPCallbacks)\n    C(MPM, Level);\n\n  if (PTO.CallGraphProfile)\n    MPM.addPass(CGProfilePass());\n\n  // Now we need to do some global optimization transforms.\n  // FIXME: It would seem like these should come first in the optimization\n  // pipeline and maybe be the bottom of the canonicalization pipeline? Weird\n  // ordering here.\n  MPM.addPass(GlobalDCEPass());\n  MPM.addPass(ConstantMergePass());\n\n  return MPM;\n}\n\nModulePassManager\nPassBuilder::buildPerModuleDefaultPipeline(OptimizationLevel Level,\n                                           bool LTOPreLink) {\n  assert(Level != OptimizationLevel::O0 &&\n         \"Must request optimizations for the default pipeline!\");\n\n  ModulePassManager MPM(DebugLogging);\n\n  // Convert @llvm.global.annotations to !annotation metadata.\n  MPM.addPass(Annotation2MetadataPass());\n\n  // Force any function attributes we want the rest of the pipeline to observe.\n  MPM.addPass(ForceFunctionAttrsPass());\n\n  // Apply module pipeline start EP callback.\n  for (auto &C : PipelineStartEPCallbacks)\n    C(MPM, Level);\n\n  if (PGOOpt && PGOOpt->DebugInfoForProfiling)\n    MPM.addPass(createModuleToFunctionPassAdaptor(AddDiscriminatorsPass()));\n\n  // Add the core simplification pipeline.\n  MPM.addPass(buildModuleSimplificationPipeline(\n      Level, LTOPreLink ? ThinOrFullLTOPhase::FullLTOPreLink\n                        : ThinOrFullLTOPhase::None));\n\n  // Now add the optimization pipeline.\n  MPM.addPass(buildModuleOptimizationPipeline(Level, LTOPreLink));\n\n  if (PGOOpt && PGOOpt->PseudoProbeForProfiling)\n    MPM.addPass(PseudoProbeUpdatePass());\n\n  // Emit annotation remarks.\n  addAnnotationRemarksPass(MPM);\n\n  if (LTOPreLink)\n    addRequiredLTOPreLinkPasses(MPM);\n\n  return MPM;\n}\n\nModulePassManager\nPassBuilder::buildThinLTOPreLinkDefaultPipeline(OptimizationLevel Level) {\n  assert(Level != OptimizationLevel::O0 &&\n         \"Must request optimizations for the default pipeline!\");\n\n  ModulePassManager MPM(DebugLogging);\n\n  // Convert @llvm.global.annotations to !annotation metadata.\n  MPM.addPass(Annotation2MetadataPass());\n\n  // Force any function attributes we want the rest of the pipeline to observe.\n  MPM.addPass(ForceFunctionAttrsPass());\n\n  if (PGOOpt && PGOOpt->DebugInfoForProfiling)\n    MPM.addPass(createModuleToFunctionPassAdaptor(AddDiscriminatorsPass()));\n\n  // Apply module pipeline start EP callback.\n  for (auto &C : PipelineStartEPCallbacks)\n    C(MPM, Level);\n\n  // If we are planning to perform ThinLTO later, we don't bloat the code with\n  // unrolling/vectorization/... now. Just simplify the module as much as we\n  // can.\n  MPM.addPass(buildModuleSimplificationPipeline(\n      Level, ThinOrFullLTOPhase::ThinLTOPreLink));\n\n  // Run partial inlining pass to partially inline functions that have\n  // large bodies.\n  // FIXME: It isn't clear whether this is really the right place to run this\n  // in ThinLTO. Because there is another canonicalization and simplification\n  // phase that will run after the thin link, running this here ends up with\n  // less information than will be available later and it may grow functions in\n  // ways that aren't beneficial.\n  if (RunPartialInlining)\n    MPM.addPass(PartialInlinerPass());\n\n  // Reduce the size of the IR as much as possible.\n  MPM.addPass(GlobalOptPass());\n\n  // Module simplification splits coroutines, but does not fully clean up\n  // coroutine intrinsics. To ensure ThinLTO optimization passes don't trip up\n  // on these, we schedule the cleanup here.\n  if (PTO.Coroutines)\n    MPM.addPass(createModuleToFunctionPassAdaptor(CoroCleanupPass()));\n\n  if (PGOOpt && PGOOpt->PseudoProbeForProfiling)\n    MPM.addPass(PseudoProbeUpdatePass());\n\n  // Handle OptimizerLastEPCallbacks added by clang on PreLink. Actual\n  // optimization is going to be done in PostLink stage, but clang can't\n  // add callbacks there in case of in-process ThinLTO called by linker.\n  for (auto &C : OptimizerLastEPCallbacks)\n    C(MPM, Level);\n\n  // Emit annotation remarks.\n  addAnnotationRemarksPass(MPM);\n\n  addRequiredLTOPreLinkPasses(MPM);\n\n  return MPM;\n}\n\nModulePassManager PassBuilder::buildThinLTODefaultPipeline(\n    OptimizationLevel Level, const ModuleSummaryIndex *ImportSummary) {\n  ModulePassManager MPM(DebugLogging);\n\n  // Convert @llvm.global.annotations to !annotation metadata.\n  MPM.addPass(Annotation2MetadataPass());\n\n  if (ImportSummary) {\n    // These passes import type identifier resolutions for whole-program\n    // devirtualization and CFI. They must run early because other passes may\n    // disturb the specific instruction patterns that these passes look for,\n    // creating dependencies on resolutions that may not appear in the summary.\n    //\n    // For example, GVN may transform the pattern assume(type.test) appearing in\n    // two basic blocks into assume(phi(type.test, type.test)), which would\n    // transform a dependency on a WPD resolution into a dependency on a type\n    // identifier resolution for CFI.\n    //\n    // Also, WPD has access to more precise information than ICP and can\n    // devirtualize more effectively, so it should operate on the IR first.\n    //\n    // The WPD and LowerTypeTest passes need to run at -O0 to lower type\n    // metadata and intrinsics.\n    MPM.addPass(WholeProgramDevirtPass(nullptr, ImportSummary));\n    MPM.addPass(LowerTypeTestsPass(nullptr, ImportSummary));\n  }\n\n  if (Level == OptimizationLevel::O0) {\n    // Run a second time to clean up any type tests left behind by WPD for use\n    // in ICP.\n    MPM.addPass(LowerTypeTestsPass(nullptr, nullptr, true));\n    // Drop available_externally and unreferenced globals. This is necessary\n    // with ThinLTO in order to avoid leaving undefined references to dead\n    // globals in the object file.\n    MPM.addPass(EliminateAvailableExternallyPass());\n    MPM.addPass(GlobalDCEPass());\n    return MPM;\n  }\n\n  // Force any function attributes we want the rest of the pipeline to observe.\n  MPM.addPass(ForceFunctionAttrsPass());\n\n  // Add the core simplification pipeline.\n  MPM.addPass(buildModuleSimplificationPipeline(\n      Level, ThinOrFullLTOPhase::ThinLTOPostLink));\n\n  // Now add the optimization pipeline.\n  MPM.addPass(buildModuleOptimizationPipeline(Level));\n\n  // Emit annotation remarks.\n  addAnnotationRemarksPass(MPM);\n\n  return MPM;\n}\n\nModulePassManager\nPassBuilder::buildLTOPreLinkDefaultPipeline(OptimizationLevel Level) {\n  assert(Level != OptimizationLevel::O0 &&\n         \"Must request optimizations for the default pipeline!\");\n  // FIXME: We should use a customized pre-link pipeline!\n  return buildPerModuleDefaultPipeline(Level,\n                                       /* LTOPreLink */ true);\n}\n\nModulePassManager\nPassBuilder::buildLTODefaultPipeline(OptimizationLevel Level,\n                                     ModuleSummaryIndex *ExportSummary) {\n  ModulePassManager MPM(DebugLogging);\n\n  // Convert @llvm.global.annotations to !annotation metadata.\n  MPM.addPass(Annotation2MetadataPass());\n\n  if (Level == OptimizationLevel::O0) {\n    // The WPD and LowerTypeTest passes need to run at -O0 to lower type\n    // metadata and intrinsics.\n    MPM.addPass(WholeProgramDevirtPass(ExportSummary, nullptr));\n    MPM.addPass(LowerTypeTestsPass(ExportSummary, nullptr));\n    // Run a second time to clean up any type tests left behind by WPD for use\n    // in ICP.\n    MPM.addPass(LowerTypeTestsPass(nullptr, nullptr, true));\n\n    // Emit annotation remarks.\n    addAnnotationRemarksPass(MPM);\n\n    return MPM;\n  }\n\n  if (PGOOpt && PGOOpt->Action == PGOOptions::SampleUse) {\n    // Load sample profile before running the LTO optimization pipeline.\n    MPM.addPass(SampleProfileLoaderPass(PGOOpt->ProfileFile,\n                                        PGOOpt->ProfileRemappingFile,\n                                        ThinOrFullLTOPhase::FullLTOPostLink));\n    // Cache ProfileSummaryAnalysis once to avoid the potential need to insert\n    // RequireAnalysisPass for PSI before subsequent non-module passes.\n    MPM.addPass(RequireAnalysisPass<ProfileSummaryAnalysis, Module>());\n  }\n\n  // Remove unused virtual tables to improve the quality of code generated by\n  // whole-program devirtualization and bitset lowering.\n  MPM.addPass(GlobalDCEPass());\n\n  // Force any function attributes we want the rest of the pipeline to observe.\n  MPM.addPass(ForceFunctionAttrsPass());\n\n  // Do basic inference of function attributes from known properties of system\n  // libraries and other oracles.\n  MPM.addPass(InferFunctionAttrsPass());\n\n  if (Level.getSpeedupLevel() > 1) {\n    FunctionPassManager EarlyFPM(DebugLogging);\n    EarlyFPM.addPass(CallSiteSplittingPass());\n    MPM.addPass(createModuleToFunctionPassAdaptor(std::move(EarlyFPM)));\n\n    // Indirect call promotion. This should promote all the targets that are\n    // left by the earlier promotion pass that promotes intra-module targets.\n    // This two-step promotion is to save the compile time. For LTO, it should\n    // produce the same result as if we only do promotion here.\n    MPM.addPass(PGOIndirectCallPromotion(\n        true /* InLTO */, PGOOpt && PGOOpt->Action == PGOOptions::SampleUse));\n    // Propagate constants at call sites into the functions they call.  This\n    // opens opportunities for globalopt (and inlining) by substituting function\n    // pointers passed as arguments to direct uses of functions.\n    MPM.addPass(IPSCCPPass());\n\n    // Attach metadata to indirect call sites indicating the set of functions\n    // they may target at run-time. This should follow IPSCCP.\n    MPM.addPass(CalledValuePropagationPass());\n  }\n\n  // Now deduce any function attributes based in the current code.\n  MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(\n              PostOrderFunctionAttrsPass()));\n\n  // Do RPO function attribute inference across the module to forward-propagate\n  // attributes where applicable.\n  // FIXME: Is this really an optimization rather than a canonicalization?\n  MPM.addPass(ReversePostOrderFunctionAttrsPass());\n\n  // Use in-range annotations on GEP indices to split globals where beneficial.\n  MPM.addPass(GlobalSplitPass());\n\n  // Run whole program optimization of virtual call when the list of callees\n  // is fixed.\n  MPM.addPass(WholeProgramDevirtPass(ExportSummary, nullptr));\n\n  // Stop here at -O1.\n  if (Level == OptimizationLevel::O1) {\n    // The LowerTypeTestsPass needs to run to lower type metadata and the\n    // type.test intrinsics. The pass does nothing if CFI is disabled.\n    MPM.addPass(LowerTypeTestsPass(ExportSummary, nullptr));\n    // Run a second time to clean up any type tests left behind by WPD for use\n    // in ICP (which is performed earlier than this in the regular LTO\n    // pipeline).\n    MPM.addPass(LowerTypeTestsPass(nullptr, nullptr, true));\n\n    // Emit annotation remarks.\n    addAnnotationRemarksPass(MPM);\n\n    return MPM;\n  }\n\n  // Optimize globals to try and fold them into constants.\n  MPM.addPass(GlobalOptPass());\n\n  // Promote any localized globals to SSA registers.\n  MPM.addPass(createModuleToFunctionPassAdaptor(PromotePass()));\n\n  // Linking modules together can lead to duplicate global constant, only\n  // keep one copy of each constant.\n  MPM.addPass(ConstantMergePass());\n\n  // Remove unused arguments from functions.\n  MPM.addPass(DeadArgumentEliminationPass());\n\n  // Reduce the code after globalopt and ipsccp.  Both can open up significant\n  // simplification opportunities, and both can propagate functions through\n  // function pointers.  When this happens, we often have to resolve varargs\n  // calls, etc, so let instcombine do this.\n  FunctionPassManager PeepholeFPM(DebugLogging);\n  if (Level == OptimizationLevel::O3)\n    PeepholeFPM.addPass(AggressiveInstCombinePass());\n  PeepholeFPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(PeepholeFPM, Level);\n\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(PeepholeFPM)));\n\n  // Note: historically, the PruneEH pass was run first to deduce nounwind and\n  // generally clean up exception handling overhead. It isn't clear this is\n  // valuable as the inliner doesn't currently care whether it is inlining an\n  // invoke or a call.\n  // Run the inliner now.\n  MPM.addPass(ModuleInlinerWrapperPass(getInlineParamsFromOptLevel(Level),\n                                       DebugLogging));\n\n  // Optimize globals again after we ran the inliner.\n  MPM.addPass(GlobalOptPass());\n\n  // Garbage collect dead functions.\n  // FIXME: Add ArgumentPromotion pass after once it's ported.\n  MPM.addPass(GlobalDCEPass());\n\n  FunctionPassManager FPM(DebugLogging);\n  // The IPO Passes may leave cruft around. Clean up after them.\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  FPM.addPass(JumpThreadingPass(/*InsertFreezeWhenUnfoldingSelect*/ true));\n\n  // Do a post inline PGO instrumentation and use pass. This is a context\n  // sensitive PGO pass.\n  if (PGOOpt) {\n    if (PGOOpt->CSAction == PGOOptions::CSIRInstr)\n      addPGOInstrPasses(MPM, Level, /* RunProfileGen */ true,\n                        /* IsCS */ true, PGOOpt->CSProfileGenFile,\n                        PGOOpt->ProfileRemappingFile);\n    else if (PGOOpt->CSAction == PGOOptions::CSIRUse)\n      addPGOInstrPasses(MPM, Level, /* RunProfileGen */ false,\n                        /* IsCS */ true, PGOOpt->ProfileFile,\n                        PGOOpt->ProfileRemappingFile);\n  }\n\n  // Break up allocas\n  FPM.addPass(SROA());\n\n  // LTO provides additional opportunities for tailcall elimination due to\n  // link-time inlining, and visibility of nocapture attribute.\n  FPM.addPass(TailCallElimPass());\n\n  // Run a few AA driver optimizations here and now to cleanup the code.\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n\n  MPM.addPass(\n      createModuleToPostOrderCGSCCPassAdaptor(PostOrderFunctionAttrsPass()));\n  // FIXME: here we run IP alias analysis in the legacy PM.\n\n  FunctionPassManager MainFPM;\n\n  MainFPM.addPass(createFunctionToLoopPassAdaptor(\n      LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap)));\n\n  if (RunNewGVN)\n    MainFPM.addPass(NewGVNPass());\n  else\n    MainFPM.addPass(GVN());\n\n  // Remove dead memcpy()'s.\n  MainFPM.addPass(MemCpyOptPass());\n\n  // Nuke dead stores.\n  MainFPM.addPass(DSEPass());\n  MainFPM.addPass(MergedLoadStoreMotionPass());\n\n  // More loops are countable; try to optimize them.\n  if (EnableLoopFlatten && Level.getSpeedupLevel() > 1)\n    MainFPM.addPass(LoopFlattenPass());\n\n  if (EnableConstraintElimination)\n    MainFPM.addPass(ConstraintEliminationPass());\n\n  LoopPassManager LPM(DebugLogging);\n  LPM.addPass(IndVarSimplifyPass());\n  LPM.addPass(LoopDeletionPass());\n  // FIXME: Add loop interchange.\n\n  // Unroll small loops and perform peeling.\n  LPM.addPass(LoopFullUnrollPass(Level.getSpeedupLevel(),\n                                 /* OnlyWhenForced= */ !PTO.LoopUnrolling,\n                                 PTO.ForgetAllSCEVInLoopUnroll));\n  // The loop passes in LPM (LoopFullUnrollPass) do not preserve MemorySSA.\n  // *All* loop passes must preserve it, in order to be able to use it.\n  MainFPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM), /*UseMemorySSA=*/false, /*UseBlockFrequencyInfo=*/true,\n      DebugLogging));\n\n  MainFPM.addPass(LoopDistributePass());\n  MainFPM.addPass(LoopVectorizePass(\n      LoopVectorizeOptions(!PTO.LoopInterleaving, !PTO.LoopVectorization)));\n  // The vectorizer may have significantly shortened a loop body; unroll again.\n  MainFPM.addPass(LoopUnrollPass(LoopUnrollOptions(\n      Level.getSpeedupLevel(), /*OnlyWhenForced=*/!PTO.LoopUnrolling,\n      PTO.ForgetAllSCEVInLoopUnroll)));\n\n  MainFPM.addPass(WarnMissedTransformationsPass());\n\n  MainFPM.addPass(InstCombinePass());\n  MainFPM.addPass(SimplifyCFGPass(SimplifyCFGOptions().hoistCommonInsts(true)));\n  MainFPM.addPass(SCCPPass());\n  MainFPM.addPass(InstCombinePass());\n  MainFPM.addPass(BDCEPass());\n\n  // More scalar chains could be vectorized due to more alias information\n  if (PTO.SLPVectorization) {\n    MainFPM.addPass(SLPVectorizerPass());\n    if (Level.getSpeedupLevel() > 1 && ExtraVectorizerPasses) {\n      MainFPM.addPass(EarlyCSEPass());\n    }\n  }\n\n  MainFPM.addPass(VectorCombinePass()); // Clean up partial vectorization.\n\n  // After vectorization, assume intrinsics may tell us more about pointer\n  // alignments.\n  MainFPM.addPass(AlignmentFromAssumptionsPass());\n\n  // FIXME: Conditionally run LoadCombine here, after it's ported\n  // (in case we still have this pass, given its questionable usefulness).\n\n  MainFPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(MainFPM, Level);\n  MainFPM.addPass(JumpThreadingPass(/*InsertFreezeWhenUnfoldingSelect*/ true));\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(MainFPM)));\n\n  // Create a function that performs CFI checks for cross-DSO calls with\n  // targets in the current module.\n  MPM.addPass(CrossDSOCFIPass());\n\n  // Lower type metadata and the type.test intrinsic. This pass supports\n  // clang's control flow integrity mechanisms (-fsanitize=cfi*) and needs\n  // to be run at link time if CFI is enabled. This pass does nothing if\n  // CFI is disabled.\n  MPM.addPass(LowerTypeTestsPass(ExportSummary, nullptr));\n  // Run a second time to clean up any type tests left behind by WPD for use\n  // in ICP (which is performed earlier than this in the regular LTO pipeline).\n  MPM.addPass(LowerTypeTestsPass(nullptr, nullptr, true));\n\n  // Enable splitting late in the FullLTO post-link pipeline. This is done in\n  // the same stage in the old pass manager (\\ref addLateLTOOptimizationPasses).\n  if (EnableHotColdSplit)\n    MPM.addPass(HotColdSplittingPass());\n\n  // Add late LTO optimization passes.\n  // Delete basic blocks, which optimization passes may have killed.\n  MPM.addPass(createModuleToFunctionPassAdaptor(\n      SimplifyCFGPass(SimplifyCFGOptions().hoistCommonInsts(true))));\n\n  // Drop bodies of available eternally objects to improve GlobalDCE.\n  MPM.addPass(EliminateAvailableExternallyPass());\n\n  // Now that we have optimized the program, discard unreachable functions.\n  MPM.addPass(GlobalDCEPass());\n\n  if (PTO.MergeFunctions)\n    MPM.addPass(MergeFunctionsPass());\n\n  // Emit annotation remarks.\n  addAnnotationRemarksPass(MPM);\n\n  return MPM;\n}\n\nModulePassManager PassBuilder::buildO0DefaultPipeline(OptimizationLevel Level,\n                                                      bool LTOPreLink) {\n  assert(Level == OptimizationLevel::O0 &&\n         \"buildO0DefaultPipeline should only be used with O0\");\n\n  ModulePassManager MPM(DebugLogging);\n\n  if (PGOOpt && (PGOOpt->Action == PGOOptions::IRInstr ||\n                 PGOOpt->Action == PGOOptions::IRUse))\n    addPGOInstrPassesForO0(\n        MPM,\n        /* RunProfileGen */ (PGOOpt->Action == PGOOptions::IRInstr),\n        /* IsCS */ false, PGOOpt->ProfileFile, PGOOpt->ProfileRemappingFile);\n\n  for (auto &C : PipelineStartEPCallbacks)\n    C(MPM, Level);\n  for (auto &C : PipelineEarlySimplificationEPCallbacks)\n    C(MPM, Level);\n\n  // Build a minimal pipeline based on the semantics required by LLVM,\n  // which is just that always inlining occurs. Further, disable generating\n  // lifetime intrinsics to avoid enabling further optimizations during\n  // code generation.\n  // However, we need to insert lifetime intrinsics to avoid invalid access\n  // caused by multithreaded coroutines.\n  MPM.addPass(AlwaysInlinerPass(\n      /*InsertLifetimeIntrinsics=*/PTO.Coroutines));\n\n  if (PTO.MergeFunctions)\n    MPM.addPass(MergeFunctionsPass());\n\n  if (EnableMatrix)\n    MPM.addPass(\n        createModuleToFunctionPassAdaptor(LowerMatrixIntrinsicsPass(true)));\n\n  if (!CGSCCOptimizerLateEPCallbacks.empty()) {\n    CGSCCPassManager CGPM(DebugLogging);\n    for (auto &C : CGSCCOptimizerLateEPCallbacks)\n      C(CGPM, Level);\n    if (!CGPM.isEmpty())\n      MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(std::move(CGPM)));\n  }\n  if (!LateLoopOptimizationsEPCallbacks.empty()) {\n    LoopPassManager LPM(DebugLogging);\n    for (auto &C : LateLoopOptimizationsEPCallbacks)\n      C(LPM, Level);\n    if (!LPM.isEmpty()) {\n      MPM.addPass(createModuleToFunctionPassAdaptor(\n          createFunctionToLoopPassAdaptor(std::move(LPM))));\n    }\n  }\n  if (!LoopOptimizerEndEPCallbacks.empty()) {\n    LoopPassManager LPM(DebugLogging);\n    for (auto &C : LoopOptimizerEndEPCallbacks)\n      C(LPM, Level);\n    if (!LPM.isEmpty()) {\n      MPM.addPass(createModuleToFunctionPassAdaptor(\n          createFunctionToLoopPassAdaptor(std::move(LPM))));\n    }\n  }\n  if (!ScalarOptimizerLateEPCallbacks.empty()) {\n    FunctionPassManager FPM(DebugLogging);\n    for (auto &C : ScalarOptimizerLateEPCallbacks)\n      C(FPM, Level);\n    if (!FPM.isEmpty())\n      MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  }\n  if (!VectorizerStartEPCallbacks.empty()) {\n    FunctionPassManager FPM(DebugLogging);\n    for (auto &C : VectorizerStartEPCallbacks)\n      C(FPM, Level);\n    if (!FPM.isEmpty())\n      MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  }\n\n  if (PTO.Coroutines) {\n    MPM.addPass(createModuleToFunctionPassAdaptor(CoroEarlyPass()));\n\n    CGSCCPassManager CGPM(DebugLogging);\n    CGPM.addPass(CoroSplitPass());\n    CGPM.addPass(createCGSCCToFunctionPassAdaptor(CoroElidePass()));\n    MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(std::move(CGPM)));\n\n    MPM.addPass(createModuleToFunctionPassAdaptor(CoroCleanupPass()));\n  }\n\n  for (auto &C : OptimizerLastEPCallbacks)\n    C(MPM, Level);\n\n  if (LTOPreLink)\n    addRequiredLTOPreLinkPasses(MPM);\n\n  return MPM;\n}\n\nAAManager PassBuilder::buildDefaultAAPipeline() {\n  AAManager AA;\n\n  // The order in which these are registered determines their priority when\n  // being queried.\n\n  // First we register the basic alias analysis that provides the majority of\n  // per-function local AA logic. This is a stateless, on-demand local set of\n  // AA techniques.\n  AA.registerFunctionAnalysis<BasicAA>();\n\n  // Next we query fast, specialized alias analyses that wrap IR-embedded\n  // information about aliasing.\n  AA.registerFunctionAnalysis<ScopedNoAliasAA>();\n  AA.registerFunctionAnalysis<TypeBasedAA>();\n\n  // Add support for querying global aliasing information when available.\n  // Because the `AAManager` is a function analysis and `GlobalsAA` is a module\n  // analysis, all that the `AAManager` can do is query for any *cached*\n  // results from `GlobalsAA` through a readonly proxy.\n  AA.registerModuleAnalysis<GlobalsAA>();\n\n  // Add target-specific alias analyses.\n  if (TM)\n    TM->registerDefaultAliasAnalyses(AA);\n\n  return AA;\n}\n\nstatic Optional<int> parseRepeatPassName(StringRef Name) {\n  if (!Name.consume_front(\"repeat<\") || !Name.consume_back(\">\"))\n    return None;\n  int Count;\n  if (Name.getAsInteger(0, Count) || Count <= 0)\n    return None;\n  return Count;\n}\n\nstatic Optional<int> parseDevirtPassName(StringRef Name) {\n  if (!Name.consume_front(\"devirt<\") || !Name.consume_back(\">\"))\n    return None;\n  int Count;\n  if (Name.getAsInteger(0, Count) || Count < 0)\n    return None;\n  return Count;\n}\n\nstatic bool checkParametrizedPassName(StringRef Name, StringRef PassName) {\n  if (!Name.consume_front(PassName))\n    return false;\n  // normal pass name w/o parameters == default parameters\n  if (Name.empty())\n    return true;\n  return Name.startswith(\"<\") && Name.endswith(\">\");\n}\n\nnamespace {\n\n/// This performs customized parsing of pass name with parameters.\n///\n/// We do not need parametrization of passes in textual pipeline very often,\n/// yet on a rare occasion ability to specify parameters right there can be\n/// useful.\n///\n/// \\p Name - parameterized specification of a pass from a textual pipeline\n/// is a string in a form of :\n///      PassName '<' parameter-list '>'\n///\n/// Parameter list is being parsed by the parser callable argument, \\p Parser,\n/// It takes a string-ref of parameters and returns either StringError or a\n/// parameter list in a form of a custom parameters type, all wrapped into\n/// Expected<> template class.\n///\ntemplate <typename ParametersParseCallableT>\nauto parsePassParameters(ParametersParseCallableT &&Parser, StringRef Name,\n                         StringRef PassName) -> decltype(Parser(StringRef{})) {\n  using ParametersT = typename decltype(Parser(StringRef{}))::value_type;\n\n  StringRef Params = Name;\n  if (!Params.consume_front(PassName)) {\n    assert(false &&\n           \"unable to strip pass name from parametrized pass specification\");\n  }\n  if (Params.empty())\n    return ParametersT{};\n  if (!Params.consume_front(\"<\") || !Params.consume_back(\">\")) {\n    assert(false && \"invalid format for parametrized pass name\");\n  }\n\n  Expected<ParametersT> Result = Parser(Params);\n  assert((Result || Result.template errorIsA<StringError>()) &&\n         \"Pass parameter parser can only return StringErrors.\");\n  return Result;\n}\n\n/// Parser of parameters for LoopUnroll pass.\nExpected<LoopUnrollOptions> parseLoopUnrollOptions(StringRef Params) {\n  LoopUnrollOptions UnrollOpts;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n    int OptLevel = StringSwitch<int>(ParamName)\n                       .Case(\"O0\", 0)\n                       .Case(\"O1\", 1)\n                       .Case(\"O2\", 2)\n                       .Case(\"O3\", 3)\n                       .Default(-1);\n    if (OptLevel >= 0) {\n      UnrollOpts.setOptLevel(OptLevel);\n      continue;\n    }\n    if (ParamName.consume_front(\"full-unroll-max=\")) {\n      int Count;\n      if (ParamName.getAsInteger(0, Count))\n        return make_error<StringError>(\n            formatv(\"invalid LoopUnrollPass parameter '{0}' \", ParamName).str(),\n            inconvertibleErrorCode());\n      UnrollOpts.setFullUnrollMaxCount(Count);\n      continue;\n    }\n\n    bool Enable = !ParamName.consume_front(\"no-\");\n    if (ParamName == \"partial\") {\n      UnrollOpts.setPartial(Enable);\n    } else if (ParamName == \"peeling\") {\n      UnrollOpts.setPeeling(Enable);\n    } else if (ParamName == \"profile-peeling\") {\n      UnrollOpts.setProfileBasedPeeling(Enable);\n    } else if (ParamName == \"runtime\") {\n      UnrollOpts.setRuntime(Enable);\n    } else if (ParamName == \"upperbound\") {\n      UnrollOpts.setUpperBound(Enable);\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid LoopUnrollPass parameter '{0}' \", ParamName).str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return UnrollOpts;\n}\n\nExpected<MemorySanitizerOptions> parseMSanPassOptions(StringRef Params) {\n  MemorySanitizerOptions Result;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n\n    if (ParamName == \"recover\") {\n      Result.Recover = true;\n    } else if (ParamName == \"kernel\") {\n      Result.Kernel = true;\n    } else if (ParamName.consume_front(\"track-origins=\")) {\n      if (ParamName.getAsInteger(0, Result.TrackOrigins))\n        return make_error<StringError>(\n            formatv(\"invalid argument to MemorySanitizer pass track-origins \"\n                    \"parameter: '{0}' \",\n                    ParamName)\n                .str(),\n            inconvertibleErrorCode());\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid MemorySanitizer pass parameter '{0}' \", ParamName)\n              .str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return Result;\n}\n\n/// Parser of parameters for SimplifyCFG pass.\nExpected<SimplifyCFGOptions> parseSimplifyCFGOptions(StringRef Params) {\n  SimplifyCFGOptions Result;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n\n    bool Enable = !ParamName.consume_front(\"no-\");\n    if (ParamName == \"forward-switch-cond\") {\n      Result.forwardSwitchCondToPhi(Enable);\n    } else if (ParamName == \"switch-to-lookup\") {\n      Result.convertSwitchToLookupTable(Enable);\n    } else if (ParamName == \"keep-loops\") {\n      Result.needCanonicalLoops(Enable);\n    } else if (ParamName == \"hoist-common-insts\") {\n      Result.hoistCommonInsts(Enable);\n    } else if (ParamName == \"sink-common-insts\") {\n      Result.sinkCommonInsts(Enable);\n    } else if (Enable && ParamName.consume_front(\"bonus-inst-threshold=\")) {\n      APInt BonusInstThreshold;\n      if (ParamName.getAsInteger(0, BonusInstThreshold))\n        return make_error<StringError>(\n            formatv(\"invalid argument to SimplifyCFG pass bonus-threshold \"\n                    \"parameter: '{0}' \",\n                    ParamName).str(),\n            inconvertibleErrorCode());\n      Result.bonusInstThreshold(BonusInstThreshold.getSExtValue());\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid SimplifyCFG pass parameter '{0}' \", ParamName).str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return Result;\n}\n\n/// Parser of parameters for LoopVectorize pass.\nExpected<LoopVectorizeOptions> parseLoopVectorizeOptions(StringRef Params) {\n  LoopVectorizeOptions Opts;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n\n    bool Enable = !ParamName.consume_front(\"no-\");\n    if (ParamName == \"interleave-forced-only\") {\n      Opts.setInterleaveOnlyWhenForced(Enable);\n    } else if (ParamName == \"vectorize-forced-only\") {\n      Opts.setVectorizeOnlyWhenForced(Enable);\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid LoopVectorize parameter '{0}' \", ParamName).str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return Opts;\n}\n\nExpected<bool> parseLoopUnswitchOptions(StringRef Params) {\n  bool Result = false;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n\n    bool Enable = !ParamName.consume_front(\"no-\");\n    if (ParamName == \"nontrivial\") {\n      Result = Enable;\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid LoopUnswitch pass parameter '{0}' \", ParamName)\n              .str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return Result;\n}\n\nExpected<bool> parseMergedLoadStoreMotionOptions(StringRef Params) {\n  bool Result = false;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n\n    bool Enable = !ParamName.consume_front(\"no-\");\n    if (ParamName == \"split-footer-bb\") {\n      Result = Enable;\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid MergedLoadStoreMotion pass parameter '{0}' \",\n                  ParamName)\n              .str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return Result;\n}\n\nExpected<GVNOptions> parseGVNOptions(StringRef Params) {\n  GVNOptions Result;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n\n    bool Enable = !ParamName.consume_front(\"no-\");\n    if (ParamName == \"pre\") {\n      Result.setPRE(Enable);\n    } else if (ParamName == \"load-pre\") {\n      Result.setLoadPRE(Enable);\n    } else if (ParamName == \"split-backedge-load-pre\") {\n      Result.setLoadPRESplitBackedge(Enable);\n    } else if (ParamName == \"memdep\") {\n      Result.setMemDep(Enable);\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid GVN pass parameter '{0}' \", ParamName).str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return Result;\n}\n\nExpected<StackLifetime::LivenessType>\nparseStackLifetimeOptions(StringRef Params) {\n  StackLifetime::LivenessType Result = StackLifetime::LivenessType::May;\n  while (!Params.empty()) {\n    StringRef ParamName;\n    std::tie(ParamName, Params) = Params.split(';');\n\n    if (ParamName == \"may\") {\n      Result = StackLifetime::LivenessType::May;\n    } else if (ParamName == \"must\") {\n      Result = StackLifetime::LivenessType::Must;\n    } else {\n      return make_error<StringError>(\n          formatv(\"invalid StackLifetime parameter '{0}' \", ParamName).str(),\n          inconvertibleErrorCode());\n    }\n  }\n  return Result;\n}\n\n} // namespace\n\n/// Tests whether a pass name starts with a valid prefix for a default pipeline\n/// alias.\nstatic bool startsWithDefaultPipelineAliasPrefix(StringRef Name) {\n  return Name.startswith(\"default\") || Name.startswith(\"thinlto\") ||\n         Name.startswith(\"lto\");\n}\n\n/// Tests whether registered callbacks will accept a given pass name.\n///\n/// When parsing a pipeline text, the type of the outermost pipeline may be\n/// omitted, in which case the type is automatically determined from the first\n/// pass name in the text. This may be a name that is handled through one of the\n/// callbacks. We check this through the oridinary parsing callbacks by setting\n/// up a dummy PassManager in order to not force the client to also handle this\n/// type of query.\ntemplate <typename PassManagerT, typename CallbacksT>\nstatic bool callbacksAcceptPassName(StringRef Name, CallbacksT &Callbacks) {\n  if (!Callbacks.empty()) {\n    PassManagerT DummyPM;\n    for (auto &CB : Callbacks)\n      if (CB(Name, DummyPM, {}))\n        return true;\n  }\n  return false;\n}\n\ntemplate <typename CallbacksT>\nstatic bool isModulePassName(StringRef Name, CallbacksT &Callbacks) {\n  // Manually handle aliases for pre-configured pipeline fragments.\n  if (startsWithDefaultPipelineAliasPrefix(Name))\n    return DefaultAliasRegex.match(Name);\n\n  // Explicitly handle pass manager names.\n  if (Name == \"module\")\n    return true;\n  if (Name == \"cgscc\")\n    return true;\n  if (Name == \"function\")\n    return true;\n\n  // Explicitly handle custom-parsed pass names.\n  if (parseRepeatPassName(Name))\n    return true;\n\n#define MODULE_PASS(NAME, CREATE_PASS)                                         \\\n  if (Name == NAME)                                                            \\\n    return true;\n#define MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \\\n  if (Name == \"require<\" NAME \">\" || Name == \"invalidate<\" NAME \">\")           \\\n    return true;\n#include \"PassRegistry.def\"\n\n  return callbacksAcceptPassName<ModulePassManager>(Name, Callbacks);\n}\n\ntemplate <typename CallbacksT>\nstatic bool isCGSCCPassName(StringRef Name, CallbacksT &Callbacks) {\n  // Explicitly handle pass manager names.\n  if (Name == \"cgscc\")\n    return true;\n  if (Name == \"function\")\n    return true;\n\n  // Explicitly handle custom-parsed pass names.\n  if (parseRepeatPassName(Name))\n    return true;\n  if (parseDevirtPassName(Name))\n    return true;\n\n#define CGSCC_PASS(NAME, CREATE_PASS)                                          \\\n  if (Name == NAME)                                                            \\\n    return true;\n#define CGSCC_ANALYSIS(NAME, CREATE_PASS)                                      \\\n  if (Name == \"require<\" NAME \">\" || Name == \"invalidate<\" NAME \">\")           \\\n    return true;\n#include \"PassRegistry.def\"\n\n  return callbacksAcceptPassName<CGSCCPassManager>(Name, Callbacks);\n}\n\ntemplate <typename CallbacksT>\nstatic bool isFunctionPassName(StringRef Name, CallbacksT &Callbacks) {\n  // Explicitly handle pass manager names.\n  if (Name == \"function\")\n    return true;\n  if (Name == \"loop\" || Name == \"loop-mssa\")\n    return true;\n\n  // Explicitly handle custom-parsed pass names.\n  if (parseRepeatPassName(Name))\n    return true;\n\n#define FUNCTION_PASS(NAME, CREATE_PASS)                                       \\\n  if (Name == NAME)                                                            \\\n    return true;\n#define FUNCTION_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                   \\\n  if (checkParametrizedPassName(Name, NAME))                                   \\\n    return true;\n#define FUNCTION_ANALYSIS(NAME, CREATE_PASS)                                   \\\n  if (Name == \"require<\" NAME \">\" || Name == \"invalidate<\" NAME \">\")           \\\n    return true;\n#include \"PassRegistry.def\"\n\n  return callbacksAcceptPassName<FunctionPassManager>(Name, Callbacks);\n}\n\ntemplate <typename CallbacksT>\nstatic bool isLoopPassName(StringRef Name, CallbacksT &Callbacks) {\n  // Explicitly handle pass manager names.\n  if (Name == \"loop\" || Name == \"loop-mssa\")\n    return true;\n\n  // Explicitly handle custom-parsed pass names.\n  if (parseRepeatPassName(Name))\n    return true;\n\n#define LOOP_PASS(NAME, CREATE_PASS)                                           \\\n  if (Name == NAME)                                                            \\\n    return true;\n#define LOOP_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                       \\\n  if (checkParametrizedPassName(Name, NAME))                                   \\\n    return true;\n#define LOOP_ANALYSIS(NAME, CREATE_PASS)                                       \\\n  if (Name == \"require<\" NAME \">\" || Name == \"invalidate<\" NAME \">\")           \\\n    return true;\n#include \"PassRegistry.def\"\n\n  return callbacksAcceptPassName<LoopPassManager>(Name, Callbacks);\n}\n\nOptional<std::vector<PassBuilder::PipelineElement>>\nPassBuilder::parsePipelineText(StringRef Text) {\n  std::vector<PipelineElement> ResultPipeline;\n\n  SmallVector<std::vector<PipelineElement> *, 4> PipelineStack = {\n      &ResultPipeline};\n  for (;;) {\n    std::vector<PipelineElement> &Pipeline = *PipelineStack.back();\n    size_t Pos = Text.find_first_of(\",()\");\n    Pipeline.push_back({Text.substr(0, Pos), {}});\n\n    // If we have a single terminating name, we're done.\n    if (Pos == Text.npos)\n      break;\n\n    char Sep = Text[Pos];\n    Text = Text.substr(Pos + 1);\n    if (Sep == ',')\n      // Just a name ending in a comma, continue.\n      continue;\n\n    if (Sep == '(') {\n      // Push the inner pipeline onto the stack to continue processing.\n      PipelineStack.push_back(&Pipeline.back().InnerPipeline);\n      continue;\n    }\n\n    assert(Sep == ')' && \"Bogus separator!\");\n    // When handling the close parenthesis, we greedily consume them to avoid\n    // empty strings in the pipeline.\n    do {\n      // If we try to pop the outer pipeline we have unbalanced parentheses.\n      if (PipelineStack.size() == 1)\n        return None;\n\n      PipelineStack.pop_back();\n    } while (Text.consume_front(\")\"));\n\n    // Check if we've finished parsing.\n    if (Text.empty())\n      break;\n\n    // Otherwise, the end of an inner pipeline always has to be followed by\n    // a comma, and then we can continue.\n    if (!Text.consume_front(\",\"))\n      return None;\n  }\n\n  if (PipelineStack.size() > 1)\n    // Unbalanced paretheses.\n    return None;\n\n  assert(PipelineStack.back() == &ResultPipeline &&\n         \"Wrong pipeline at the bottom of the stack!\");\n  return {std::move(ResultPipeline)};\n}\n\nError PassBuilder::parseModulePass(ModulePassManager &MPM,\n                                   const PipelineElement &E) {\n  auto &Name = E.Name;\n  auto &InnerPipeline = E.InnerPipeline;\n\n  // First handle complex passes like the pass managers which carry pipelines.\n  if (!InnerPipeline.empty()) {\n    if (Name == \"module\") {\n      ModulePassManager NestedMPM(DebugLogging);\n      if (auto Err = parseModulePassPipeline(NestedMPM, InnerPipeline))\n        return Err;\n      MPM.addPass(std::move(NestedMPM));\n      return Error::success();\n    }\n    if (Name == \"cgscc\") {\n      CGSCCPassManager CGPM(DebugLogging);\n      if (auto Err = parseCGSCCPassPipeline(CGPM, InnerPipeline))\n        return Err;\n      MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(std::move(CGPM)));\n      return Error::success();\n    }\n    if (Name == \"function\") {\n      FunctionPassManager FPM(DebugLogging);\n      if (auto Err = parseFunctionPassPipeline(FPM, InnerPipeline))\n        return Err;\n      MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n      return Error::success();\n    }\n    if (auto Count = parseRepeatPassName(Name)) {\n      ModulePassManager NestedMPM(DebugLogging);\n      if (auto Err = parseModulePassPipeline(NestedMPM, InnerPipeline))\n        return Err;\n      MPM.addPass(createRepeatedPass(*Count, std::move(NestedMPM)));\n      return Error::success();\n    }\n\n    for (auto &C : ModulePipelineParsingCallbacks)\n      if (C(Name, MPM, InnerPipeline))\n        return Error::success();\n\n    // Normal passes can't have pipelines.\n    return make_error<StringError>(\n        formatv(\"invalid use of '{0}' pass as module pipeline\", Name).str(),\n        inconvertibleErrorCode());\n    ;\n  }\n\n  // Manually handle aliases for pre-configured pipeline fragments.\n  if (startsWithDefaultPipelineAliasPrefix(Name)) {\n    SmallVector<StringRef, 3> Matches;\n    if (!DefaultAliasRegex.match(Name, &Matches))\n      return make_error<StringError>(\n          formatv(\"unknown default pipeline alias '{0}'\", Name).str(),\n          inconvertibleErrorCode());\n\n    assert(Matches.size() == 3 && \"Must capture two matched strings!\");\n\n    OptimizationLevel L = StringSwitch<OptimizationLevel>(Matches[2])\n                              .Case(\"O0\", OptimizationLevel::O0)\n                              .Case(\"O1\", OptimizationLevel::O1)\n                              .Case(\"O2\", OptimizationLevel::O2)\n                              .Case(\"O3\", OptimizationLevel::O3)\n                              .Case(\"Os\", OptimizationLevel::Os)\n                              .Case(\"Oz\", OptimizationLevel::Oz);\n    if (L == OptimizationLevel::O0 && Matches[1] != \"thinlto\" &&\n        Matches[1] != \"lto\") {\n      MPM.addPass(buildO0DefaultPipeline(L, Matches[1] == \"thinlto-pre-link\" ||\n                                                Matches[1] == \"lto-pre-link\"));\n      return Error::success();\n    }\n\n    // This is consistent with old pass manager invoked via opt, but\n    // inconsistent with clang. Clang doesn't enable loop vectorization\n    // but does enable slp vectorization at Oz.\n    PTO.LoopVectorization =\n        L.getSpeedupLevel() > 1 && L != OptimizationLevel::Oz;\n    PTO.SLPVectorization =\n        L.getSpeedupLevel() > 1 && L != OptimizationLevel::Oz;\n\n    if (Matches[1] == \"default\") {\n      MPM.addPass(buildPerModuleDefaultPipeline(L));\n    } else if (Matches[1] == \"thinlto-pre-link\") {\n      MPM.addPass(buildThinLTOPreLinkDefaultPipeline(L));\n    } else if (Matches[1] == \"thinlto\") {\n      MPM.addPass(buildThinLTODefaultPipeline(L, nullptr));\n    } else if (Matches[1] == \"lto-pre-link\") {\n      MPM.addPass(buildLTOPreLinkDefaultPipeline(L));\n    } else {\n      assert(Matches[1] == \"lto\" && \"Not one of the matched options!\");\n      MPM.addPass(buildLTODefaultPipeline(L, nullptr));\n    }\n    return Error::success();\n  }\n\n  // Finally expand the basic registered passes from the .inc file.\n#define MODULE_PASS(NAME, CREATE_PASS)                                         \\\n  if (Name == NAME) {                                                          \\\n    MPM.addPass(CREATE_PASS);                                                  \\\n    return Error::success();                                                   \\\n  }\n#define MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \\\n  if (Name == \"require<\" NAME \">\") {                                           \\\n    MPM.addPass(                                                               \\\n        RequireAnalysisPass<                                                   \\\n            std::remove_reference<decltype(CREATE_PASS)>::type, Module>());    \\\n    return Error::success();                                                   \\\n  }                                                                            \\\n  if (Name == \"invalidate<\" NAME \">\") {                                        \\\n    MPM.addPass(InvalidateAnalysisPass<                                        \\\n                std::remove_reference<decltype(CREATE_PASS)>::type>());        \\\n    return Error::success();                                                   \\\n  }\n#define CGSCC_PASS(NAME, CREATE_PASS)                                          \\\n  if (Name == NAME) {                                                          \\\n    MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(CREATE_PASS));         \\\n    return Error::success();                                                   \\\n  }\n#define FUNCTION_PASS(NAME, CREATE_PASS)                                       \\\n  if (Name == NAME) {                                                          \\\n    MPM.addPass(createModuleToFunctionPassAdaptor(CREATE_PASS));               \\\n    return Error::success();                                                   \\\n  }\n#define FUNCTION_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                   \\\n  if (checkParametrizedPassName(Name, NAME)) {                                 \\\n    auto Params = parsePassParameters(PARSER, Name, NAME);                     \\\n    if (!Params)                                                               \\\n      return Params.takeError();                                               \\\n    MPM.addPass(createModuleToFunctionPassAdaptor(CREATE_PASS(Params.get()))); \\\n    return Error::success();                                                   \\\n  }\n#define LOOP_PASS(NAME, CREATE_PASS)                                           \\\n  if (Name == NAME) {                                                          \\\n    MPM.addPass(                                                               \\\n        createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(     \\\n            CREATE_PASS, false, false, DebugLogging)));                        \\\n    return Error::success();                                                   \\\n  }\n#define LOOP_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                       \\\n  if (checkParametrizedPassName(Name, NAME)) {                                 \\\n    auto Params = parsePassParameters(PARSER, Name, NAME);                     \\\n    if (!Params)                                                               \\\n      return Params.takeError();                                               \\\n    MPM.addPass(                                                               \\\n        createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(     \\\n            CREATE_PASS(Params.get()), false, false, DebugLogging)));          \\\n    return Error::success();                                                   \\\n  }\n#include \"PassRegistry.def\"\n\n  for (auto &C : ModulePipelineParsingCallbacks)\n    if (C(Name, MPM, InnerPipeline))\n      return Error::success();\n  return make_error<StringError>(\n      formatv(\"unknown module pass '{0}'\", Name).str(),\n      inconvertibleErrorCode());\n}\n\nError PassBuilder::parseCGSCCPass(CGSCCPassManager &CGPM,\n                                  const PipelineElement &E) {\n  auto &Name = E.Name;\n  auto &InnerPipeline = E.InnerPipeline;\n\n  // First handle complex passes like the pass managers which carry pipelines.\n  if (!InnerPipeline.empty()) {\n    if (Name == \"cgscc\") {\n      CGSCCPassManager NestedCGPM(DebugLogging);\n      if (auto Err = parseCGSCCPassPipeline(NestedCGPM, InnerPipeline))\n        return Err;\n      // Add the nested pass manager with the appropriate adaptor.\n      CGPM.addPass(std::move(NestedCGPM));\n      return Error::success();\n    }\n    if (Name == \"function\") {\n      FunctionPassManager FPM(DebugLogging);\n      if (auto Err = parseFunctionPassPipeline(FPM, InnerPipeline))\n        return Err;\n      // Add the nested pass manager with the appropriate adaptor.\n      CGPM.addPass(createCGSCCToFunctionPassAdaptor(std::move(FPM)));\n      return Error::success();\n    }\n    if (auto Count = parseRepeatPassName(Name)) {\n      CGSCCPassManager NestedCGPM(DebugLogging);\n      if (auto Err = parseCGSCCPassPipeline(NestedCGPM, InnerPipeline))\n        return Err;\n      CGPM.addPass(createRepeatedPass(*Count, std::move(NestedCGPM)));\n      return Error::success();\n    }\n    if (auto MaxRepetitions = parseDevirtPassName(Name)) {\n      CGSCCPassManager NestedCGPM(DebugLogging);\n      if (auto Err = parseCGSCCPassPipeline(NestedCGPM, InnerPipeline))\n        return Err;\n      CGPM.addPass(\n          createDevirtSCCRepeatedPass(std::move(NestedCGPM), *MaxRepetitions));\n      return Error::success();\n    }\n\n    for (auto &C : CGSCCPipelineParsingCallbacks)\n      if (C(Name, CGPM, InnerPipeline))\n        return Error::success();\n\n    // Normal passes can't have pipelines.\n    return make_error<StringError>(\n        formatv(\"invalid use of '{0}' pass as cgscc pipeline\", Name).str(),\n        inconvertibleErrorCode());\n  }\n\n// Now expand the basic registered passes from the .inc file.\n#define CGSCC_PASS(NAME, CREATE_PASS)                                          \\\n  if (Name == NAME) {                                                          \\\n    CGPM.addPass(CREATE_PASS);                                                 \\\n    return Error::success();                                                   \\\n  }\n#define CGSCC_ANALYSIS(NAME, CREATE_PASS)                                      \\\n  if (Name == \"require<\" NAME \">\") {                                           \\\n    CGPM.addPass(RequireAnalysisPass<                                          \\\n                 std::remove_reference<decltype(CREATE_PASS)>::type,           \\\n                 LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &,    \\\n                 CGSCCUpdateResult &>());                                      \\\n    return Error::success();                                                   \\\n  }                                                                            \\\n  if (Name == \"invalidate<\" NAME \">\") {                                        \\\n    CGPM.addPass(InvalidateAnalysisPass<                                       \\\n                 std::remove_reference<decltype(CREATE_PASS)>::type>());       \\\n    return Error::success();                                                   \\\n  }\n#define FUNCTION_PASS(NAME, CREATE_PASS)                                       \\\n  if (Name == NAME) {                                                          \\\n    CGPM.addPass(createCGSCCToFunctionPassAdaptor(CREATE_PASS));               \\\n    return Error::success();                                                   \\\n  }\n#define FUNCTION_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                   \\\n  if (checkParametrizedPassName(Name, NAME)) {                                 \\\n    auto Params = parsePassParameters(PARSER, Name, NAME);                     \\\n    if (!Params)                                                               \\\n      return Params.takeError();                                               \\\n    CGPM.addPass(createCGSCCToFunctionPassAdaptor(CREATE_PASS(Params.get()))); \\\n    return Error::success();                                                   \\\n  }\n#define LOOP_PASS(NAME, CREATE_PASS)                                           \\\n  if (Name == NAME) {                                                          \\\n    CGPM.addPass(                                                              \\\n        createCGSCCToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(      \\\n            CREATE_PASS, false, false, DebugLogging)));                        \\\n    return Error::success();                                                   \\\n  }\n#define LOOP_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                       \\\n  if (checkParametrizedPassName(Name, NAME)) {                                 \\\n    auto Params = parsePassParameters(PARSER, Name, NAME);                     \\\n    if (!Params)                                                               \\\n      return Params.takeError();                                               \\\n    CGPM.addPass(                                                              \\\n        createCGSCCToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(      \\\n            CREATE_PASS(Params.get()), false, false, DebugLogging)));          \\\n    return Error::success();                                                   \\\n  }\n#include \"PassRegistry.def\"\n\n  for (auto &C : CGSCCPipelineParsingCallbacks)\n    if (C(Name, CGPM, InnerPipeline))\n      return Error::success();\n  return make_error<StringError>(\n      formatv(\"unknown cgscc pass '{0}'\", Name).str(),\n      inconvertibleErrorCode());\n}\n\nError PassBuilder::parseFunctionPass(FunctionPassManager &FPM,\n                                     const PipelineElement &E) {\n  auto &Name = E.Name;\n  auto &InnerPipeline = E.InnerPipeline;\n\n  // First handle complex passes like the pass managers which carry pipelines.\n  if (!InnerPipeline.empty()) {\n    if (Name == \"function\") {\n      FunctionPassManager NestedFPM(DebugLogging);\n      if (auto Err = parseFunctionPassPipeline(NestedFPM, InnerPipeline))\n        return Err;\n      // Add the nested pass manager with the appropriate adaptor.\n      FPM.addPass(std::move(NestedFPM));\n      return Error::success();\n    }\n    if (Name == \"loop\" || Name == \"loop-mssa\") {\n      LoopPassManager LPM(DebugLogging);\n      if (auto Err = parseLoopPassPipeline(LPM, InnerPipeline))\n        return Err;\n      // Add the nested pass manager with the appropriate adaptor.\n      bool UseMemorySSA = (Name == \"loop-mssa\");\n      bool UseBFI = llvm::any_of(\n          InnerPipeline, [](auto Pipeline) { return Pipeline.Name == \"licm\"; });\n      FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM), UseMemorySSA,\n                                                  UseBFI, DebugLogging));\n      return Error::success();\n    }\n    if (auto Count = parseRepeatPassName(Name)) {\n      FunctionPassManager NestedFPM(DebugLogging);\n      if (auto Err = parseFunctionPassPipeline(NestedFPM, InnerPipeline))\n        return Err;\n      FPM.addPass(createRepeatedPass(*Count, std::move(NestedFPM)));\n      return Error::success();\n    }\n\n    for (auto &C : FunctionPipelineParsingCallbacks)\n      if (C(Name, FPM, InnerPipeline))\n        return Error::success();\n\n    // Normal passes can't have pipelines.\n    return make_error<StringError>(\n        formatv(\"invalid use of '{0}' pass as function pipeline\", Name).str(),\n        inconvertibleErrorCode());\n  }\n\n// Now expand the basic registered passes from the .inc file.\n#define FUNCTION_PASS(NAME, CREATE_PASS)                                       \\\n  if (Name == NAME) {                                                          \\\n    FPM.addPass(CREATE_PASS);                                                  \\\n    return Error::success();                                                   \\\n  }\n#define FUNCTION_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                   \\\n  if (checkParametrizedPassName(Name, NAME)) {                                 \\\n    auto Params = parsePassParameters(PARSER, Name, NAME);                     \\\n    if (!Params)                                                               \\\n      return Params.takeError();                                               \\\n    FPM.addPass(CREATE_PASS(Params.get()));                                    \\\n    return Error::success();                                                   \\\n  }\n#define FUNCTION_ANALYSIS(NAME, CREATE_PASS)                                   \\\n  if (Name == \"require<\" NAME \">\") {                                           \\\n    FPM.addPass(                                                               \\\n        RequireAnalysisPass<                                                   \\\n            std::remove_reference<decltype(CREATE_PASS)>::type, Function>());  \\\n    return Error::success();                                                   \\\n  }                                                                            \\\n  if (Name == \"invalidate<\" NAME \">\") {                                        \\\n    FPM.addPass(InvalidateAnalysisPass<                                        \\\n                std::remove_reference<decltype(CREATE_PASS)>::type>());        \\\n    return Error::success();                                                   \\\n  }\n// FIXME: UseMemorySSA is set to false. Maybe we could do things like:\n//        bool UseMemorySSA = !(\"canon-freeze\" || \"loop-predication\" ||\n//                              \"guard-widening\");\n//        The risk is that it may become obsolete if we're not careful.\n#define LOOP_PASS(NAME, CREATE_PASS)                                           \\\n  if (Name == NAME) {                                                          \\\n    FPM.addPass(createFunctionToLoopPassAdaptor(CREATE_PASS, false, false,     \\\n                                                DebugLogging));                \\\n    return Error::success();                                                   \\\n  }\n#define LOOP_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                       \\\n  if (checkParametrizedPassName(Name, NAME)) {                                 \\\n    auto Params = parsePassParameters(PARSER, Name, NAME);                     \\\n    if (!Params)                                                               \\\n      return Params.takeError();                                               \\\n    FPM.addPass(createFunctionToLoopPassAdaptor(CREATE_PASS(Params.get()),     \\\n                                                false, false, DebugLogging));  \\\n    return Error::success();                                                   \\\n  }\n#include \"PassRegistry.def\"\n\n  for (auto &C : FunctionPipelineParsingCallbacks)\n    if (C(Name, FPM, InnerPipeline))\n      return Error::success();\n  return make_error<StringError>(\n      formatv(\"unknown function pass '{0}'\", Name).str(),\n      inconvertibleErrorCode());\n}\n\nError PassBuilder::parseLoopPass(LoopPassManager &LPM,\n                                 const PipelineElement &E) {\n  StringRef Name = E.Name;\n  auto &InnerPipeline = E.InnerPipeline;\n\n  // First handle complex passes like the pass managers which carry pipelines.\n  if (!InnerPipeline.empty()) {\n    if (Name == \"loop\") {\n      LoopPassManager NestedLPM(DebugLogging);\n      if (auto Err = parseLoopPassPipeline(NestedLPM, InnerPipeline))\n        return Err;\n      // Add the nested pass manager with the appropriate adaptor.\n      LPM.addPass(std::move(NestedLPM));\n      return Error::success();\n    }\n    if (auto Count = parseRepeatPassName(Name)) {\n      LoopPassManager NestedLPM(DebugLogging);\n      if (auto Err = parseLoopPassPipeline(NestedLPM, InnerPipeline))\n        return Err;\n      LPM.addPass(createRepeatedPass(*Count, std::move(NestedLPM)));\n      return Error::success();\n    }\n\n    for (auto &C : LoopPipelineParsingCallbacks)\n      if (C(Name, LPM, InnerPipeline))\n        return Error::success();\n\n    // Normal passes can't have pipelines.\n    return make_error<StringError>(\n        formatv(\"invalid use of '{0}' pass as loop pipeline\", Name).str(),\n        inconvertibleErrorCode());\n  }\n\n// Now expand the basic registered passes from the .inc file.\n#define LOOP_PASS(NAME, CREATE_PASS)                                           \\\n  if (Name == NAME) {                                                          \\\n    LPM.addPass(CREATE_PASS);                                                  \\\n    return Error::success();                                                   \\\n  }\n#define LOOP_PASS_WITH_PARAMS(NAME, CREATE_PASS, PARSER)                       \\\n  if (checkParametrizedPassName(Name, NAME)) {                                 \\\n    auto Params = parsePassParameters(PARSER, Name, NAME);                     \\\n    if (!Params)                                                               \\\n      return Params.takeError();                                               \\\n    LPM.addPass(CREATE_PASS(Params.get()));                                    \\\n    return Error::success();                                                   \\\n  }\n#define LOOP_ANALYSIS(NAME, CREATE_PASS)                                       \\\n  if (Name == \"require<\" NAME \">\") {                                           \\\n    LPM.addPass(RequireAnalysisPass<                                           \\\n                std::remove_reference<decltype(CREATE_PASS)>::type, Loop,      \\\n                LoopAnalysisManager, LoopStandardAnalysisResults &,            \\\n                LPMUpdater &>());                                              \\\n    return Error::success();                                                   \\\n  }                                                                            \\\n  if (Name == \"invalidate<\" NAME \">\") {                                        \\\n    LPM.addPass(InvalidateAnalysisPass<                                        \\\n                std::remove_reference<decltype(CREATE_PASS)>::type>());        \\\n    return Error::success();                                                   \\\n  }\n#include \"PassRegistry.def\"\n\n  for (auto &C : LoopPipelineParsingCallbacks)\n    if (C(Name, LPM, InnerPipeline))\n      return Error::success();\n  return make_error<StringError>(formatv(\"unknown loop pass '{0}'\", Name).str(),\n                                 inconvertibleErrorCode());\n}\n\nbool PassBuilder::parseAAPassName(AAManager &AA, StringRef Name) {\n#define MODULE_ALIAS_ANALYSIS(NAME, CREATE_PASS)                               \\\n  if (Name == NAME) {                                                          \\\n    AA.registerModuleAnalysis<                                                 \\\n        std::remove_reference<decltype(CREATE_PASS)>::type>();                 \\\n    return true;                                                               \\\n  }\n#define FUNCTION_ALIAS_ANALYSIS(NAME, CREATE_PASS)                             \\\n  if (Name == NAME) {                                                          \\\n    AA.registerFunctionAnalysis<                                               \\\n        std::remove_reference<decltype(CREATE_PASS)>::type>();                 \\\n    return true;                                                               \\\n  }\n#include \"PassRegistry.def\"\n\n  for (auto &C : AAParsingCallbacks)\n    if (C(Name, AA))\n      return true;\n  return false;\n}\n\nError PassBuilder::parseLoopPassPipeline(LoopPassManager &LPM,\n                                         ArrayRef<PipelineElement> Pipeline) {\n  for (const auto &Element : Pipeline) {\n    if (auto Err = parseLoopPass(LPM, Element))\n      return Err;\n  }\n  return Error::success();\n}\n\nError PassBuilder::parseFunctionPassPipeline(\n    FunctionPassManager &FPM, ArrayRef<PipelineElement> Pipeline) {\n  for (const auto &Element : Pipeline) {\n    if (auto Err = parseFunctionPass(FPM, Element))\n      return Err;\n  }\n  return Error::success();\n}\n\nError PassBuilder::parseCGSCCPassPipeline(CGSCCPassManager &CGPM,\n                                          ArrayRef<PipelineElement> Pipeline) {\n  for (const auto &Element : Pipeline) {\n    if (auto Err = parseCGSCCPass(CGPM, Element))\n      return Err;\n  }\n  return Error::success();\n}\n\nvoid PassBuilder::crossRegisterProxies(LoopAnalysisManager &LAM,\n                                       FunctionAnalysisManager &FAM,\n                                       CGSCCAnalysisManager &CGAM,\n                                       ModuleAnalysisManager &MAM) {\n  MAM.registerPass([&] { return FunctionAnalysisManagerModuleProxy(FAM); });\n  MAM.registerPass([&] { return CGSCCAnalysisManagerModuleProxy(CGAM); });\n  CGAM.registerPass([&] { return ModuleAnalysisManagerCGSCCProxy(MAM); });\n  FAM.registerPass([&] { return CGSCCAnalysisManagerFunctionProxy(CGAM); });\n  FAM.registerPass([&] { return ModuleAnalysisManagerFunctionProxy(MAM); });\n  FAM.registerPass([&] { return LoopAnalysisManagerFunctionProxy(LAM); });\n  LAM.registerPass([&] { return FunctionAnalysisManagerLoopProxy(FAM); });\n}\n\nError PassBuilder::parseModulePassPipeline(ModulePassManager &MPM,\n                                           ArrayRef<PipelineElement> Pipeline) {\n  for (const auto &Element : Pipeline) {\n    if (auto Err = parseModulePass(MPM, Element))\n      return Err;\n  }\n  return Error::success();\n}\n\n// Primary pass pipeline description parsing routine for a \\c ModulePassManager\n// FIXME: Should this routine accept a TargetMachine or require the caller to\n// pre-populate the analysis managers with target-specific stuff?\nError PassBuilder::parsePassPipeline(ModulePassManager &MPM,\n                                     StringRef PipelineText) {\n  auto Pipeline = parsePipelineText(PipelineText);\n  if (!Pipeline || Pipeline->empty())\n    return make_error<StringError>(\n        formatv(\"invalid pipeline '{0}'\", PipelineText).str(),\n        inconvertibleErrorCode());\n\n  // If the first name isn't at the module layer, wrap the pipeline up\n  // automatically.\n  StringRef FirstName = Pipeline->front().Name;\n\n  if (!isModulePassName(FirstName, ModulePipelineParsingCallbacks)) {\n    if (isCGSCCPassName(FirstName, CGSCCPipelineParsingCallbacks)) {\n      Pipeline = {{\"cgscc\", std::move(*Pipeline)}};\n    } else if (isFunctionPassName(FirstName,\n                                  FunctionPipelineParsingCallbacks)) {\n      Pipeline = {{\"function\", std::move(*Pipeline)}};\n    } else if (isLoopPassName(FirstName, LoopPipelineParsingCallbacks)) {\n      Pipeline = {{\"function\", {{\"loop\", std::move(*Pipeline)}}}};\n    } else {\n      for (auto &C : TopLevelPipelineParsingCallbacks)\n        if (C(MPM, *Pipeline, DebugLogging))\n          return Error::success();\n\n      // Unknown pass or pipeline name!\n      auto &InnerPipeline = Pipeline->front().InnerPipeline;\n      return make_error<StringError>(\n          formatv(\"unknown {0} name '{1}'\",\n                  (InnerPipeline.empty() ? \"pass\" : \"pipeline\"), FirstName)\n              .str(),\n          inconvertibleErrorCode());\n    }\n  }\n\n  if (auto Err = parseModulePassPipeline(MPM, *Pipeline))\n    return Err;\n  return Error::success();\n}\n\n// Primary pass pipeline description parsing routine for a \\c CGSCCPassManager\nError PassBuilder::parsePassPipeline(CGSCCPassManager &CGPM,\n                                     StringRef PipelineText) {\n  auto Pipeline = parsePipelineText(PipelineText);\n  if (!Pipeline || Pipeline->empty())\n    return make_error<StringError>(\n        formatv(\"invalid pipeline '{0}'\", PipelineText).str(),\n        inconvertibleErrorCode());\n\n  StringRef FirstName = Pipeline->front().Name;\n  if (!isCGSCCPassName(FirstName, CGSCCPipelineParsingCallbacks))\n    return make_error<StringError>(\n        formatv(\"unknown cgscc pass '{0}' in pipeline '{1}'\", FirstName,\n                PipelineText)\n            .str(),\n        inconvertibleErrorCode());\n\n  if (auto Err = parseCGSCCPassPipeline(CGPM, *Pipeline))\n    return Err;\n  return Error::success();\n}\n\n// Primary pass pipeline description parsing routine for a \\c\n// FunctionPassManager\nError PassBuilder::parsePassPipeline(FunctionPassManager &FPM,\n                                     StringRef PipelineText) {\n  auto Pipeline = parsePipelineText(PipelineText);\n  if (!Pipeline || Pipeline->empty())\n    return make_error<StringError>(\n        formatv(\"invalid pipeline '{0}'\", PipelineText).str(),\n        inconvertibleErrorCode());\n\n  StringRef FirstName = Pipeline->front().Name;\n  if (!isFunctionPassName(FirstName, FunctionPipelineParsingCallbacks))\n    return make_error<StringError>(\n        formatv(\"unknown function pass '{0}' in pipeline '{1}'\", FirstName,\n                PipelineText)\n            .str(),\n        inconvertibleErrorCode());\n\n  if (auto Err = parseFunctionPassPipeline(FPM, *Pipeline))\n    return Err;\n  return Error::success();\n}\n\n// Primary pass pipeline description parsing routine for a \\c LoopPassManager\nError PassBuilder::parsePassPipeline(LoopPassManager &CGPM,\n                                     StringRef PipelineText) {\n  auto Pipeline = parsePipelineText(PipelineText);\n  if (!Pipeline || Pipeline->empty())\n    return make_error<StringError>(\n        formatv(\"invalid pipeline '{0}'\", PipelineText).str(),\n        inconvertibleErrorCode());\n\n  if (auto Err = parseLoopPassPipeline(CGPM, *Pipeline))\n    return Err;\n\n  return Error::success();\n}\n\nError PassBuilder::parseAAPipeline(AAManager &AA, StringRef PipelineText) {\n  // If the pipeline just consists of the word 'default' just replace the AA\n  // manager with our default one.\n  if (PipelineText == \"default\") {\n    AA = buildDefaultAAPipeline();\n    return Error::success();\n  }\n\n  while (!PipelineText.empty()) {\n    StringRef Name;\n    std::tie(Name, PipelineText) = PipelineText.split(',');\n    if (!parseAAPassName(AA, Name))\n      return make_error<StringError>(\n          formatv(\"unknown alias analysis name '{0}'\", Name).str(),\n          inconvertibleErrorCode());\n  }\n\n  return Error::success();\n}\n\nbool PassBuilder::isAAPassName(StringRef PassName) {\n#define MODULE_ALIAS_ANALYSIS(NAME, CREATE_PASS)                               \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#define FUNCTION_ALIAS_ANALYSIS(NAME, CREATE_PASS)                             \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#include \"PassRegistry.def\"\n  return false;\n}\n\nbool PassBuilder::isAnalysisPassName(StringRef PassName) {\n#define MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#define FUNCTION_ANALYSIS(NAME, CREATE_PASS)                                   \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#define LOOP_ANALYSIS(NAME, CREATE_PASS)                                       \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#define CGSCC_ANALYSIS(NAME, CREATE_PASS)                                      \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#define MODULE_ALIAS_ANALYSIS(NAME, CREATE_PASS)                               \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#define FUNCTION_ALIAS_ANALYSIS(NAME, CREATE_PASS)                             \\\n  if (PassName == NAME)                                                        \\\n    return true;\n#include \"PassRegistry.def\"\n  return false;\n}\n\nstatic void printPassName(StringRef PassName, raw_ostream &OS) {\n  OS << \"  \" << PassName << \"\\n\";\n}\n\nvoid PassBuilder::printPassNames(raw_ostream &OS) {\n  // TODO: print pass descriptions when they are available\n\n  OS << \"Module passes:\\n\";\n#define MODULE_PASS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"Module analyses:\\n\";\n#define MODULE_ANALYSIS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"Module alias analyses:\\n\";\n#define MODULE_ALIAS_ANALYSIS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"CGSCC passes:\\n\";\n#define CGSCC_PASS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"CGSCC analyses:\\n\";\n#define CGSCC_ANALYSIS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"Function passes:\\n\";\n#define FUNCTION_PASS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"Function analyses:\\n\";\n#define FUNCTION_ANALYSIS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"Function alias analyses:\\n\";\n#define FUNCTION_ALIAS_ANALYSIS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"Loop passes:\\n\";\n#define LOOP_PASS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n\n  OS << \"Loop analyses:\\n\";\n#define LOOP_ANALYSIS(NAME, CREATE_PASS) printPassName(NAME, OS);\n#include \"PassRegistry.def\"\n}\n\nvoid PassBuilder::registerParseTopLevelPipelineCallback(\n    const std::function<bool(ModulePassManager &, ArrayRef<PipelineElement>,\n                             bool DebugLogging)> &C) {\n  TopLevelPipelineParsingCallbacks.push_back(C);\n}\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 8, "line": 29}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 29}, "message": "default constructor 'DGEdge<NodeType, EdgeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "reportHash": "c64b8adccfb66ef5d9766c06b75cfce9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 80}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 80}, "message": "default constructor 'DGNode<NodeType, EdgeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "reportHash": "ae771f705dbdb9ac6d0fc5b7d3086f8f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 83}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 83}, "message": "move constructor 'DGNode<NodeType, EdgeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "reportHash": "dfba3f141708b24fd48cd3ac508f474a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 8, "line": 89}, "message": "mark 'noexcept'"}, {"location": {"col": 31, "file": 8, "line": 89}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "reportHash": "bc248212ca323929b8c0a0c9e72a9106", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 181}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 181}, "message": "default constructor 'DirectedGraph<NodeType, EdgeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "reportHash": "4c2cf830d2b9bddc6d48f87198346bfa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 184}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 184}, "message": "move constructor 'DirectedGraph<NodeType, EdgeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "reportHash": "6249831bbb8cf84c5418ca25407177b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 8, "line": 189}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 8, "line": 189}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h", "reportHash": "95a1157c19ef559d85e566f392f4d5f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 54}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 54}, "message": "default constructor 'DDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "6e9750f9bd4937481c42f08e9d327a9f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 57}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 57}, "message": "move constructor 'DDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "eaad0a4c9589294b456298617aa9d53a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 54, "line": 66}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 54, "line": 66}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "41cdcc7836c952417808ad36a2511356", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 93}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 93}, "message": "default constructor 'RootDDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "4a5c3e90ac9fa7e87fdbc181b3b18f60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 95}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 95}, "message": "move constructor 'RootDDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "3e2c6702a6f90eea7870ece7901d9653", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 110}, "message": "default constructor 'SimpleDDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "c151a8a8f76a6f0d9baf110d46e32979", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 113}, "message": "move constructor 'SimpleDDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "9d53f6b4bda2e076395ddc0bc7a6bede", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 54, "line": 122}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 54, "line": 122}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "f59cbbc7dec6a7f2db770defdec60922", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 176}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 176}, "message": "default constructor 'PiBlockDDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "e0d9cbf71072b3843cee53b2d37b7096", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 179}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 179}, "message": "move constructor 'PiBlockDDGNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "b033090e72e1c676883ae53e3c2a7152", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 54, "line": 188}, "message": "mark 'noexcept'"}, {"location": {"col": 19, "file": 54, "line": 188}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "0071fcd4bdd5b578c181740a4ceb03bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 233}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 233}, "message": "move constructor 'DDGEdge' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "6e59197b67d95e81d6b1b6ffa3df183a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 54, "line": 240}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 54, "line": 240}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "5b7e62939cbfcf021a7f1bc5b33dc6cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 269}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 269}, "message": "default constructor 'DependenceGraphInfo<NodeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "6d57d1c063277341bbc524e855fefc9e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 273}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 273}, "message": "move constructor 'DependenceGraphInfo<NodeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "33ecb433ccaf4d27d65d94299e5bcb03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 54, "line": 275}, "message": "mark 'noexcept'"}, {"location": {"col": 11, "file": 54, "line": 275}, "message": "destructor '~DependenceGraphInfo<NodeType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "63110f64f00133a18489560e31af1932", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 324}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 324}, "message": "default constructor 'DataDependenceGraph' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "b5612d9aa3ec336b0ce526d353690c59", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 326}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 326}, "message": "move constructor 'DataDependenceGraph' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDG.h", "reportHash": "3ee4b32f1b6cc8063a5f43f94db44862", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 40}, "message": "default constructor 'DOTGraphTraits' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h", "reportHash": "627d68d62ab7ab80bf2c126de191296a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 57, "line": 103}, "message": "default constructor 'DVEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h", "reportHash": "a5c73152f1a8847dc83875a58c7080cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 57, "line": 982}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 57, "line": 982}, "message": "default constructor 'DependenceAnalysisWrapperPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h", "reportHash": "29e8e8ea2ed39abad64868997327e21a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 58, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 11, "file": 58, "line": 46}, "message": "destructor '~AbstractDependenceGraphBuilder<GraphType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h", "reportHash": "d97277727c28a372e15c51230285628e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 62, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 62, "line": 113}, "message": "move constructor 'IVUsers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/IVUsers.h", "reportHash": "8d67156f99b1459cc18e10ebb4a0d111", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 62, "line": 121}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 62, "line": 121}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/IVUsers.h", "reportHash": "d27b77198b94a6fe12117e5579bdcffc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 62, "line": 173}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 62, "line": 173}, "message": "default constructor 'IVUsersWrapperPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/IVUsers.h", "reportHash": "d12cf7b17d84afe67f3dffd2039403fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 65, "line": 22}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 65, "line": 22}, "message": "default constructor 'InlineSizeEstimatorAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InlineSizeEstimatorAnalysis.h", "reportHash": "f6ea69829835463acd9a531d314854fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 65, "line": 23}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 65, "line": 23}, "message": "move constructor 'InlineSizeEstimatorAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InlineSizeEstimatorAnalysis.h", "reportHash": "3a3718de9219055f3799e87418281241", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 44}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 44}, "message": "move constructor 'ObjCARCAAResult' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h", "reportHash": "635fe82c05a6c001733bd21e45201f06", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 86}, "message": "default constructor 'ObjCARCAAWrapperPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h", "reportHash": "453abc104900595afdd0d8860c06f21a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 112, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 112, "line": 40}, "message": "default constructor 'SafepointIRVerifierPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h", "reportHash": "c2d0bd96b0a42b71d1a0279de0e8c13a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 154, "line": 25}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 154, "line": 25}, "message": "default constructor 'CoroSplitPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Coroutines/CoroSplit.h", "reportHash": "41ae419c2943d3574338c99eb282a5ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 156, "line": 28}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 156, "line": 28}, "message": "default constructor 'ArgumentPromotionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/ArgumentPromotion.h", "reportHash": "1588534491e1f3564993c794699654df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 158, "line": 76}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 158, "line": 76}, "message": "default constructor 'DeadArgumentEliminationPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h", "reportHash": "f11b40596a0cba2ff30d2436a54bf019", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 162, "line": 24}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 162, "line": 24}, "message": "default constructor 'LoopExtractorPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/LoopExtractor.h", "reportHash": "77d8e20d64d5f0a95dd2aae00cc96ef0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 163, "line": 183}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 163, "line": 183}, "message": "default constructor 'ByteArrayBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h", "reportHash": "f974c1e34a1a100dee21e9569a32349c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 163, "line": 208}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 163, "line": 208}, "message": "default constructor 'LowerTypeTestsPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h", "reportHash": "9ba094eee45ada0bfc8a73b5c0f22d24", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 164, "line": 27}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 164, "line": 27}, "message": "default constructor 'SampleProfileLoaderPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h", "reportHash": "f8fb0466019f982458acc2344525e23c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 166, "line": 227}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 166, "line": 227}, "message": "default constructor 'WholeProgramDevirtPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h", "reportHash": "33156f90e7c160d7b948d00a11fe4e7c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 168, "line": 102}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 168, "line": 102}, "message": "default constructor 'AddressSanitizerPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizer.h", "reportHash": "d78919ccad65994a1eb4124c25ebab60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 168, "line": 122}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 168, "line": 122}, "message": "default constructor 'ModuleAddressSanitizerPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizer.h", "reportHash": "cf59f1993dedf6be132e1493f6f530b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 169, "line": 25}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 169, "line": 25}, "message": "default constructor 'ControlHeightReductionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ControlHeightReduction.h", "reportHash": "4ed6e2b7f396cd47c536218a6747cdb5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 170, "line": 23}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 170, "line": 23}, "message": "default constructor 'DataFlowSanitizerPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/DataFlowSanitizer.h", "reportHash": "e075b5eb5400a3e2ec0985de7ec91062", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 171, "line": 22}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 171, "line": 22}, "message": "default constructor 'GCOVProfilerPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/GCOVProfiler.h", "reportHash": "a3c9bdad5b5e53996bdbb9e0cb580809", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 172, "line": 27}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 172, "line": 27}, "message": "default constructor 'HWAddressSanitizerPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/HWAddressSanitizer.h", "reportHash": "508f3fb02291111710fccf63949d8239", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 173, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 173, "line": 37}, "message": "default constructor 'InstrProfiling' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/InstrProfiling.h", "reportHash": "a6095bcfa2f9bcfb6b404e336f1c8729", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 173, "line": 55}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 173, "line": 55}, "message": "default constructor 'PerFunctionProfileData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/InstrProfiling.h", "reportHash": "0ad2942d65600d8c2ae6108a777c812a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 174, "line": 31}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 174, "line": 31}, "message": "default constructor 'MemProfilerPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h", "reportHash": "31db2baf75f655b7a3a826318a1ca85b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 174, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 174, "line": 40}, "message": "default constructor 'ModuleMemProfilerPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h", "reportHash": "00d130e2464b21ec478ed0a96ba55818", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 175, "line": 22}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 175, "line": 22}, "message": "default constructor 'MemorySanitizerOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemorySanitizer.h", "reportHash": "f8fb51da58828a9c78c26655d2aecf55", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 176, "line": 38}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 176, "line": 38}, "message": "default constructor 'PGOInstrumentationGenCreateVar' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h", "reportHash": "0309ca5fa191dbedf55943dcc563de4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 176, "line": 49}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 176, "line": 49}, "message": "default constructor 'PGOInstrumentationGen' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h", "reportHash": "2b3892b081bfeabe3c958461b205eb41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 176, "line": 60}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 176, "line": 60}, "message": "default constructor 'PGOInstrumentationUse' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h", "reportHash": "e5a48337383eb8260158c3f7f609661d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 176, "line": 75}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 176, "line": 75}, "message": "default constructor 'PGOIndirectCallPromotion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h", "reportHash": "baa20fe0bab09cc86ebaec8bd598a64c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 177, "line": 34}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 177, "line": 34}, "message": "default constructor 'ModuleSanitizerCoveragePass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Instrumentation/SanitizerCoverage.h", "reportHash": "902d13c35823cc492bd0d5efba5059bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 178, "line": 31}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 178, "line": 31}, "message": "default constructor 'EarlyCSEPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h", "reportHash": "5b68b664d44533608ed0e4ee7d5cdb26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 180, "line": 30}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 180, "line": 30}, "message": "default constructor 'IndVarSimplifyPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h", "reportHash": "d506fd28e6061d01a0b12d282d42550d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 182, "line": 99}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 182, "line": 99}, "message": "default constructor 'JumpThreadingPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h", "reportHash": "831515774a1cea6c28febc92d5e40d3d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 183, "line": 51}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 183, "line": 51}, "message": "default constructor 'LICMPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h", "reportHash": "865a5873a33975bcbe0f9cb658ed5eb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 185, "line": 25}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 185, "line": 25}, "message": "default constructor 'LoopRotatePass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h", "reportHash": "7f313fc8d7269b3b318689afdc6c5340", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 186, "line": 22}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 186, "line": 22}, "message": "default constructor 'LoopUnrollAndJamPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollAndJamPass.h", "reportHash": "a2da3787e43805609be60ed120b20adc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 187, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 187, "line": 40}, "message": "default constructor 'LoopFullUnrollPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h", "reportHash": "c9f0e070b8ab3c6d825003cd695ae8f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 187, "line": 80}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 187, "line": 80}, "message": "default constructor 'LoopUnrollOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h", "reportHash": "6f999fa09d110b237aa0407fed47ca80", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 187, "line": 139}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 187, "line": 139}, "message": "default constructor 'LoopUnrollPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h", "reportHash": "7141f4f7b5087dda4e62a7f66112e009", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 189, "line": 24}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 189, "line": 24}, "message": "default constructor 'LowerMatrixIntrinsicsPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerMatrixIntrinsics.h", "reportHash": "8cb1c1ed1d7e6559772c9a3228ca8de7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 190, "line": 32}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 190, "line": 32}, "message": "default constructor 'MergedLoadStoreMotionOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h", "reportHash": "8193a464ebe457eab6a22bc3b1839998", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 190, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 190, "line": 46}, "message": "default constructor 'MergedLoadStoreMotionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h", "reportHash": "e9ef3c3a1ef0987e74f10fcd62c33cec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 191, "line": 21}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 191, "line": 21}, "message": "default constructor 'SeparateConstOffsetFromGEPPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h", "reportHash": "9a8c2434f4200c45c54542f1c527d56f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 193, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 193, "line": 37}, "message": "default constructor 'SimplifyCFGPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h", "reportHash": "27fdc894f67bcc4253ff9abae31ea679", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 194, "line": 72}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 194, "line": 72}, "message": "default constructor 'SpeculativeExecutionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h", "reportHash": "0ac69aa0e59972f32e9827de8d970599", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 195, "line": 27}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 195, "line": 27}, "message": "default constructor 'WarnMissedTransformationsPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h", "reportHash": "bae2d6ebfae32db636ebc03da0681a40", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 198, "line": 98}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 198, "line": 98}, "message": "default constructor 'PredicateBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h", "reportHash": "39445ec69d112d81b9819c453b10acd3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 198, "line": 121}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 198, "line": 121}, "message": "default constructor 'PredicateAssume' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h", "reportHash": "baf3fc20a30cf5e1d6b5c4da7300d97e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 198, "line": 134}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 198, "line": 134}, "message": "default constructor 'PredicateWithEdge' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h", "reportHash": "16cbe35bc07087e36e8b442e8a198234", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 198, "line": 154}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 198, "line": 154}, "message": "default constructor 'PredicateBranch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h", "reportHash": "e336b95a3378c3ff12d7af806639edcb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 198, "line": 170}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 198, "line": 170}, "message": "default constructor 'PredicateSwitch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h", "reportHash": "26fa9629a2afb818b0ada27038e91de7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 198, "line": 217}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 198, "line": 217}, "message": "default constructor 'PredicateInfoPrinterLegacyPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h", "reportHash": "6512cdc27f511cf1fbfb496b2b784f1b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 202, "line": 101}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 202, "line": 101}, "message": "default constructor 'LoopVectorizeOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h", "reportHash": "c411b5df973f1daa321b93431b373272", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 202, "line": 140}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 202, "line": 140}, "message": "default constructor 'LoopVectorizePass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h", "reportHash": "c0c8c04f2cd22c4f75df35d5a9a8bc4e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 203, "line": 281}, "message": "mark 'noexcept'"}, {"location": {"col": 24, "file": 203, "line": 281}, "message": "default constructor 'PipelineTuningOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Passes/PassBuilder.cpp", "reportHash": "e43f838bb495252918969e57fd4b0c18", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 203, "line": 443}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 203, "line": 443}, "message": "default constructor 'PassBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Passes/PassBuilder.cpp", "reportHash": "65216c341cace2c01c5936e121b92648", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
