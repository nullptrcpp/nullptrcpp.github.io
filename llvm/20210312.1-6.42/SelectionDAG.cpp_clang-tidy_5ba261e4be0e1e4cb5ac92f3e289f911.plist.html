<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"103": {"id": 103, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "content": "//===- SelectionDAG.cpp - Implement the SelectionDAG data structures ------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This implements the SelectionDAG class.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/CodeGen/SelectionDAG.h\"\n#include \"SDNodeDbgValue.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/Analysis/ProfileSummaryInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/CodeGen/FunctionLoweringInfo.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineConstantPool.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/RuntimeLibcalls.h\"\n#include \"llvm/CodeGen/SelectionDAGAddressAnalysis.h\"\n#include \"llvm/CodeGen/SelectionDAGNodes.h\"\n#include \"llvm/CodeGen/SelectionDAGTargetInfo.h\"\n#include \"llvm/CodeGen/TargetFrameLowering.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/Mutex.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include \"llvm/Transforms/Utils/SizeOpts.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstdlib>\n#include <limits>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\n/// makeVTList - Return an instance of the SDVTList struct initialized with the\n/// specified members.\nstatic SDVTList makeVTList(const EVT *VTs, unsigned NumVTs) {\n  SDVTList Res = {VTs, NumVTs};\n  return Res;\n}\n\n// Default null implementations of the callbacks.\nvoid SelectionDAG::DAGUpdateListener::NodeDeleted(SDNode*, SDNode*) {}\nvoid SelectionDAG::DAGUpdateListener::NodeUpdated(SDNode*) {}\nvoid SelectionDAG::DAGUpdateListener::NodeInserted(SDNode *) {}\n\nvoid SelectionDAG::DAGNodeDeletedListener::anchor() {}\n\n#define DEBUG_TYPE \"selectiondag\"\n\nstatic cl::opt<bool> EnableMemCpyDAGOpt(\"enable-memcpy-dag-opt\",\n       cl::Hidden, cl::init(true),\n       cl::desc(\"Gang up loads and stores generated by inlining of memcpy\"));\n\nstatic cl::opt<int> MaxLdStGlue(\"ldstmemcpy-glue-max\",\n       cl::desc(\"Number limit for gluing ld/st of memcpy.\"),\n       cl::Hidden, cl::init(0));\n\nstatic void NewSDValueDbgMsg(SDValue V, StringRef Msg, SelectionDAG *G) {\n  LLVM_DEBUG(dbgs() << Msg; V.getNode()->dump(G););\n}\n\n//===----------------------------------------------------------------------===//\n//                              ConstantFPSDNode Class\n//===----------------------------------------------------------------------===//\n\n/// isExactlyValue - We don't rely on operator== working on double values, as\n/// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n/// As such, this method can be used to do an exact bit-for-bit comparison of\n/// two floating point values.\nbool ConstantFPSDNode::isExactlyValue(const APFloat& V) const {\n  return getValueAPF().bitwiseIsEqual(V);\n}\n\nbool ConstantFPSDNode::isValueValidForType(EVT VT,\n                                           const APFloat& Val) {\n  assert(VT.isFloatingPoint() && \"Can only convert between FP types\");\n\n  // convert modifies in place, so make a copy.\n  APFloat Val2 = APFloat(Val);\n  bool losesInfo;\n  (void) Val2.convert(SelectionDAG::EVTToAPFloatSemantics(VT),\n                      APFloat::rmNearestTiesToEven,\n                      &losesInfo);\n  return !losesInfo;\n}\n\n//===----------------------------------------------------------------------===//\n//                              ISD Namespace\n//===----------------------------------------------------------------------===//\n\nbool ISD::isConstantSplatVector(const SDNode *N, APInt &SplatVal) {\n  if (N->getOpcode() == ISD::SPLAT_VECTOR) {\n    unsigned EltSize =\n        N->getValueType(0).getVectorElementType().getSizeInBits();\n    if (auto *Op0 = dyn_cast<ConstantSDNode>(N->getOperand(0))) {\n      SplatVal = Op0->getAPIntValue().truncOrSelf(EltSize);\n      return true;\n    }\n  }\n\n  auto *BV = dyn_cast<BuildVectorSDNode>(N);\n  if (!BV)\n    return false;\n\n  APInt SplatUndef;\n  unsigned SplatBitSize;\n  bool HasUndefs;\n  unsigned EltSize = N->getValueType(0).getVectorElementType().getSizeInBits();\n  return BV->isConstantSplat(SplatVal, SplatUndef, SplatBitSize, HasUndefs,\n                             EltSize) &&\n         EltSize == SplatBitSize;\n}\n\n// FIXME: AllOnes and AllZeros duplicate a lot of code. Could these be\n// specializations of the more general isConstantSplatVector()?\n\nbool ISD::isConstantSplatVectorAllOnes(const SDNode *N, bool BuildVectorOnly) {\n  // Look through a bit convert.\n  while (N->getOpcode() == ISD::BITCAST)\n    N = N->getOperand(0).getNode();\n\n  if (!BuildVectorOnly && N->getOpcode() == ISD::SPLAT_VECTOR) {\n    APInt SplatVal;\n    return isConstantSplatVector(N, SplatVal) && SplatVal.isAllOnesValue();\n  }\n\n  if (N->getOpcode() != ISD::BUILD_VECTOR) return false;\n\n  unsigned i = 0, e = N->getNumOperands();\n\n  // Skip over all of the undef values.\n  while (i != e && N->getOperand(i).isUndef())\n    ++i;\n\n  // Do not accept an all-undef vector.\n  if (i == e) return false;\n\n  // Do not accept build_vectors that aren't all constants or which have non-~0\n  // elements. We have to be a bit careful here, as the type of the constant\n  // may not be the same as the type of the vector elements due to type\n  // legalization (the elements are promoted to a legal type for the target and\n  // a vector of a type may be legal when the base element type is not).\n  // We only want to check enough bits to cover the vector elements, because\n  // we care if the resultant vector is all ones, not whether the individual\n  // constants are.\n  SDValue NotZero = N->getOperand(i);\n  unsigned EltSize = N->getValueType(0).getScalarSizeInBits();\n  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(NotZero)) {\n    if (CN->getAPIntValue().countTrailingOnes() < EltSize)\n      return false;\n  } else if (ConstantFPSDNode *CFPN = dyn_cast<ConstantFPSDNode>(NotZero)) {\n    if (CFPN->getValueAPF().bitcastToAPInt().countTrailingOnes() < EltSize)\n      return false;\n  } else\n    return false;\n\n  // Okay, we have at least one ~0 value, check to see if the rest match or are\n  // undefs. Even with the above element type twiddling, this should be OK, as\n  // the same type legalization should have applied to all the elements.\n  for (++i; i != e; ++i)\n    if (N->getOperand(i) != NotZero && !N->getOperand(i).isUndef())\n      return false;\n  return true;\n}\n\nbool ISD::isConstantSplatVectorAllZeros(const SDNode *N, bool BuildVectorOnly) {\n  // Look through a bit convert.\n  while (N->getOpcode() == ISD::BITCAST)\n    N = N->getOperand(0).getNode();\n\n  if (!BuildVectorOnly && N->getOpcode() == ISD::SPLAT_VECTOR) {\n    APInt SplatVal;\n    return isConstantSplatVector(N, SplatVal) && SplatVal.isNullValue();\n  }\n\n  if (N->getOpcode() != ISD::BUILD_VECTOR) return false;\n\n  bool IsAllUndef = true;\n  for (const SDValue &Op : N->op_values()) {\n    if (Op.isUndef())\n      continue;\n    IsAllUndef = false;\n    // Do not accept build_vectors that aren't all constants or which have non-0\n    // elements. We have to be a bit careful here, as the type of the constant\n    // may not be the same as the type of the vector elements due to type\n    // legalization (the elements are promoted to a legal type for the target\n    // and a vector of a type may be legal when the base element type is not).\n    // We only want to check enough bits to cover the vector elements, because\n    // we care if the resultant vector is all zeros, not whether the individual\n    // constants are.\n    unsigned EltSize = N->getValueType(0).getScalarSizeInBits();\n    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Op)) {\n      if (CN->getAPIntValue().countTrailingZeros() < EltSize)\n        return false;\n    } else if (ConstantFPSDNode *CFPN = dyn_cast<ConstantFPSDNode>(Op)) {\n      if (CFPN->getValueAPF().bitcastToAPInt().countTrailingZeros() < EltSize)\n        return false;\n    } else\n      return false;\n  }\n\n  // Do not accept an all-undef vector.\n  if (IsAllUndef)\n    return false;\n  return true;\n}\n\nbool ISD::isBuildVectorAllOnes(const SDNode *N) {\n  return isConstantSplatVectorAllOnes(N, /*BuildVectorOnly*/ true);\n}\n\nbool ISD::isBuildVectorAllZeros(const SDNode *N) {\n  return isConstantSplatVectorAllZeros(N, /*BuildVectorOnly*/ true);\n}\n\nbool ISD::isBuildVectorOfConstantSDNodes(const SDNode *N) {\n  if (N->getOpcode() != ISD::BUILD_VECTOR)\n    return false;\n\n  for (const SDValue &Op : N->op_values()) {\n    if (Op.isUndef())\n      continue;\n    if (!isa<ConstantSDNode>(Op))\n      return false;\n  }\n  return true;\n}\n\nbool ISD::isBuildVectorOfConstantFPSDNodes(const SDNode *N) {\n  if (N->getOpcode() != ISD::BUILD_VECTOR)\n    return false;\n\n  for (const SDValue &Op : N->op_values()) {\n    if (Op.isUndef())\n      continue;\n    if (!isa<ConstantFPSDNode>(Op))\n      return false;\n  }\n  return true;\n}\n\nbool ISD::allOperandsUndef(const SDNode *N) {\n  // Return false if the node has no operands.\n  // This is \"logically inconsistent\" with the definition of \"all\" but\n  // is probably the desired behavior.\n  if (N->getNumOperands() == 0)\n    return false;\n  return all_of(N->op_values(), [](SDValue Op) { return Op.isUndef(); });\n}\n\nbool ISD::matchUnaryPredicate(SDValue Op,\n                              std::function<bool(ConstantSDNode *)> Match,\n                              bool AllowUndefs) {\n  // FIXME: Add support for scalar UNDEF cases?\n  if (auto *Cst = dyn_cast<ConstantSDNode>(Op))\n    return Match(Cst);\n\n  // FIXME: Add support for vector UNDEF cases?\n  if (ISD::BUILD_VECTOR != Op.getOpcode() &&\n      ISD::SPLAT_VECTOR != Op.getOpcode())\n    return false;\n\n  EVT SVT = Op.getValueType().getScalarType();\n  for (unsigned i = 0, e = Op.getNumOperands(); i != e; ++i) {\n    if (AllowUndefs && Op.getOperand(i).isUndef()) {\n      if (!Match(nullptr))\n        return false;\n      continue;\n    }\n\n    auto *Cst = dyn_cast<ConstantSDNode>(Op.getOperand(i));\n    if (!Cst || Cst->getValueType(0) != SVT || !Match(Cst))\n      return false;\n  }\n  return true;\n}\n\nbool ISD::matchBinaryPredicate(\n    SDValue LHS, SDValue RHS,\n    std::function<bool(ConstantSDNode *, ConstantSDNode *)> Match,\n    bool AllowUndefs, bool AllowTypeMismatch) {\n  if (!AllowTypeMismatch && LHS.getValueType() != RHS.getValueType())\n    return false;\n\n  // TODO: Add support for scalar UNDEF cases?\n  if (auto *LHSCst = dyn_cast<ConstantSDNode>(LHS))\n    if (auto *RHSCst = dyn_cast<ConstantSDNode>(RHS))\n      return Match(LHSCst, RHSCst);\n\n  // TODO: Add support for vector UNDEF cases?\n  if (ISD::BUILD_VECTOR != LHS.getOpcode() ||\n      ISD::BUILD_VECTOR != RHS.getOpcode())\n    return false;\n\n  EVT SVT = LHS.getValueType().getScalarType();\n  for (unsigned i = 0, e = LHS.getNumOperands(); i != e; ++i) {\n    SDValue LHSOp = LHS.getOperand(i);\n    SDValue RHSOp = RHS.getOperand(i);\n    bool LHSUndef = AllowUndefs && LHSOp.isUndef();\n    bool RHSUndef = AllowUndefs && RHSOp.isUndef();\n    auto *LHSCst = dyn_cast<ConstantSDNode>(LHSOp);\n    auto *RHSCst = dyn_cast<ConstantSDNode>(RHSOp);\n    if ((!LHSCst && !LHSUndef) || (!RHSCst && !RHSUndef))\n      return false;\n    if (!AllowTypeMismatch && (LHSOp.getValueType() != SVT ||\n                               LHSOp.getValueType() != RHSOp.getValueType()))\n      return false;\n    if (!Match(LHSCst, RHSCst))\n      return false;\n  }\n  return true;\n}\n\nISD::NodeType ISD::getVecReduceBaseOpcode(unsigned VecReduceOpcode) {\n  switch (VecReduceOpcode) {\n  default:\n    llvm_unreachable(\"Expected VECREDUCE opcode\");\n  case ISD::VECREDUCE_FADD:\n  case ISD::VECREDUCE_SEQ_FADD:\n    return ISD::FADD;\n  case ISD::VECREDUCE_FMUL:\n  case ISD::VECREDUCE_SEQ_FMUL:\n    return ISD::FMUL;\n  case ISD::VECREDUCE_ADD:\n    return ISD::ADD;\n  case ISD::VECREDUCE_MUL:\n    return ISD::MUL;\n  case ISD::VECREDUCE_AND:\n    return ISD::AND;\n  case ISD::VECREDUCE_OR:\n    return ISD::OR;\n  case ISD::VECREDUCE_XOR:\n    return ISD::XOR;\n  case ISD::VECREDUCE_SMAX:\n    return ISD::SMAX;\n  case ISD::VECREDUCE_SMIN:\n    return ISD::SMIN;\n  case ISD::VECREDUCE_UMAX:\n    return ISD::UMAX;\n  case ISD::VECREDUCE_UMIN:\n    return ISD::UMIN;\n  case ISD::VECREDUCE_FMAX:\n    return ISD::FMAXNUM;\n  case ISD::VECREDUCE_FMIN:\n    return ISD::FMINNUM;\n  }\n}\n\nbool ISD::isVPOpcode(unsigned Opcode) {\n  switch (Opcode) {\n  default:\n    return false;\n#define BEGIN_REGISTER_VP_SDNODE(SDOPC, ...)                                   \\\n  case ISD::SDOPC:                                                             \\\n    return true;\n#include \"llvm/IR/VPIntrinsics.def\"\n  }\n}\n\n/// The operand position of the vector mask.\nOptional<unsigned> ISD::getVPMaskIdx(unsigned Opcode) {\n  switch (Opcode) {\n  default:\n    return None;\n#define BEGIN_REGISTER_VP_SDNODE(SDOPC, LEGALPOS, TDNAME, MASKPOS, ...)        \\\n  case ISD::SDOPC:                                                             \\\n    return MASKPOS;\n#include \"llvm/IR/VPIntrinsics.def\"\n  }\n}\n\n/// The operand position of the explicit vector length parameter.\nOptional<unsigned> ISD::getVPExplicitVectorLengthIdx(unsigned Opcode) {\n  switch (Opcode) {\n  default:\n    return None;\n#define BEGIN_REGISTER_VP_SDNODE(SDOPC, LEGALPOS, TDNAME, MASKPOS, EVLPOS)     \\\n  case ISD::SDOPC:                                                             \\\n    return EVLPOS;\n#include \"llvm/IR/VPIntrinsics.def\"\n  }\n}\n\nISD::NodeType ISD::getExtForLoadExtType(bool IsFP, ISD::LoadExtType ExtType) {\n  switch (ExtType) {\n  case ISD::EXTLOAD:\n    return IsFP ? ISD::FP_EXTEND : ISD::ANY_EXTEND;\n  case ISD::SEXTLOAD:\n    return ISD::SIGN_EXTEND;\n  case ISD::ZEXTLOAD:\n    return ISD::ZERO_EXTEND;\n  default:\n    break;\n  }\n\n  llvm_unreachable(\"Invalid LoadExtType\");\n}\n\nISD::CondCode ISD::getSetCCSwappedOperands(ISD::CondCode Operation) {\n  // To perform this operation, we just need to swap the L and G bits of the\n  // operation.\n  unsigned OldL = (Operation >> 2) & 1;\n  unsigned OldG = (Operation >> 1) & 1;\n  return ISD::CondCode((Operation & ~6) |  // Keep the N, U, E bits\n                       (OldL << 1) |       // New G bit\n                       (OldG << 2));       // New L bit.\n}\n\nstatic ISD::CondCode getSetCCInverseImpl(ISD::CondCode Op, bool isIntegerLike) {\n  unsigned Operation = Op;\n  if (isIntegerLike)\n    Operation ^= 7;   // Flip L, G, E bits, but not U.\n  else\n    Operation ^= 15;  // Flip all of the condition bits.\n\n  if (Operation > ISD::SETTRUE2)\n    Operation &= ~8;  // Don't let N and U bits get set.\n\n  return ISD::CondCode(Operation);\n}\n\nISD::CondCode ISD::getSetCCInverse(ISD::CondCode Op, EVT Type) {\n  return getSetCCInverseImpl(Op, Type.isInteger());\n}\n\nISD::CondCode ISD::GlobalISel::getSetCCInverse(ISD::CondCode Op,\n                                               bool isIntegerLike) {\n  return getSetCCInverseImpl(Op, isIntegerLike);\n}\n\n/// For an integer comparison, return 1 if the comparison is a signed operation\n/// and 2 if the result is an unsigned comparison. Return zero if the operation\n/// does not depend on the sign of the input (setne and seteq).\nstatic int isSignedOp(ISD::CondCode Opcode) {\n  switch (Opcode) {\n  default: llvm_unreachable(\"Illegal integer setcc operation!\");\n  case ISD::SETEQ:\n  case ISD::SETNE: return 0;\n  case ISD::SETLT:\n  case ISD::SETLE:\n  case ISD::SETGT:\n  case ISD::SETGE: return 1;\n  case ISD::SETULT:\n  case ISD::SETULE:\n  case ISD::SETUGT:\n  case ISD::SETUGE: return 2;\n  }\n}\n\nISD::CondCode ISD::getSetCCOrOperation(ISD::CondCode Op1, ISD::CondCode Op2,\n                                       EVT Type) {\n  bool IsInteger = Type.isInteger();\n  if (IsInteger && (isSignedOp(Op1) | isSignedOp(Op2)) == 3)\n    // Cannot fold a signed integer setcc with an unsigned integer setcc.\n    return ISD::SETCC_INVALID;\n\n  unsigned Op = Op1 | Op2;  // Combine all of the condition bits.\n\n  // If the N and U bits get set, then the resultant comparison DOES suddenly\n  // care about orderedness, and it is true when ordered.\n  if (Op > ISD::SETTRUE2)\n    Op &= ~16;     // Clear the U bit if the N bit is set.\n\n  // Canonicalize illegal integer setcc's.\n  if (IsInteger && Op == ISD::SETUNE)  // e.g. SETUGT | SETULT\n    Op = ISD::SETNE;\n\n  return ISD::CondCode(Op);\n}\n\nISD::CondCode ISD::getSetCCAndOperation(ISD::CondCode Op1, ISD::CondCode Op2,\n                                        EVT Type) {\n  bool IsInteger = Type.isInteger();\n  if (IsInteger && (isSignedOp(Op1) | isSignedOp(Op2)) == 3)\n    // Cannot fold a signed setcc with an unsigned setcc.\n    return ISD::SETCC_INVALID;\n\n  // Combine all of the condition bits.\n  ISD::CondCode Result = ISD::CondCode(Op1 & Op2);\n\n  // Canonicalize illegal integer setcc's.\n  if (IsInteger) {\n    switch (Result) {\n    default: break;\n    case ISD::SETUO : Result = ISD::SETFALSE; break;  // SETUGT & SETULT\n    case ISD::SETOEQ:                                 // SETEQ  & SETU[LG]E\n    case ISD::SETUEQ: Result = ISD::SETEQ   ; break;  // SETUGE & SETULE\n    case ISD::SETOLT: Result = ISD::SETULT  ; break;  // SETULT & SETNE\n    case ISD::SETOGT: Result = ISD::SETUGT  ; break;  // SETUGT & SETNE\n    }\n  }\n\n  return Result;\n}\n\n//===----------------------------------------------------------------------===//\n//                           SDNode Profile Support\n//===----------------------------------------------------------------------===//\n\n/// AddNodeIDOpcode - Add the node opcode to the NodeID data.\nstatic void AddNodeIDOpcode(FoldingSetNodeID &ID, unsigned OpC)  {\n  ID.AddInteger(OpC);\n}\n\n/// AddNodeIDValueTypes - Value type lists are intern'd so we can represent them\n/// solely with their pointer.\nstatic void AddNodeIDValueTypes(FoldingSetNodeID &ID, SDVTList VTList) {\n  ID.AddPointer(VTList.VTs);\n}\n\n/// AddNodeIDOperands - Various routines for adding operands to the NodeID data.\nstatic void AddNodeIDOperands(FoldingSetNodeID &ID,\n                              ArrayRef<SDValue> Ops) {\n  for (auto& Op : Ops) {\n    ID.AddPointer(Op.getNode());\n    ID.AddInteger(Op.getResNo());\n  }\n}\n\n/// AddNodeIDOperands - Various routines for adding operands to the NodeID data.\nstatic void AddNodeIDOperands(FoldingSetNodeID &ID,\n                              ArrayRef<SDUse> Ops) {\n  for (auto& Op : Ops) {\n    ID.AddPointer(Op.getNode());\n    ID.AddInteger(Op.getResNo());\n  }\n}\n\nstatic void AddNodeIDNode(FoldingSetNodeID &ID, unsigned short OpC,\n                          SDVTList VTList, ArrayRef<SDValue> OpList) {\n  AddNodeIDOpcode(ID, OpC);\n  AddNodeIDValueTypes(ID, VTList);\n  AddNodeIDOperands(ID, OpList);\n}\n\n/// If this is an SDNode with special info, add this info to the NodeID data.\nstatic void AddNodeIDCustom(FoldingSetNodeID &ID, const SDNode *N) {\n  switch (N->getOpcode()) {\n  case ISD::TargetExternalSymbol:\n  case ISD::ExternalSymbol:\n  case ISD::MCSymbol:\n    llvm_unreachable(\"Should only be used on nodes with operands\");\n  default: break;  // Normal nodes don't need extra info.\n  case ISD::TargetConstant:\n  case ISD::Constant: {\n    const ConstantSDNode *C = cast<ConstantSDNode>(N);\n    ID.AddPointer(C->getConstantIntValue());\n    ID.AddBoolean(C->isOpaque());\n    break;\n  }\n  case ISD::TargetConstantFP:\n  case ISD::ConstantFP:\n    ID.AddPointer(cast<ConstantFPSDNode>(N)->getConstantFPValue());\n    break;\n  case ISD::TargetGlobalAddress:\n  case ISD::GlobalAddress:\n  case ISD::TargetGlobalTLSAddress:\n  case ISD::GlobalTLSAddress: {\n    const GlobalAddressSDNode *GA = cast<GlobalAddressSDNode>(N);\n    ID.AddPointer(GA->getGlobal());\n    ID.AddInteger(GA->getOffset());\n    ID.AddInteger(GA->getTargetFlags());\n    break;\n  }\n  case ISD::BasicBlock:\n    ID.AddPointer(cast<BasicBlockSDNode>(N)->getBasicBlock());\n    break;\n  case ISD::Register:\n    ID.AddInteger(cast<RegisterSDNode>(N)->getReg());\n    break;\n  case ISD::RegisterMask:\n    ID.AddPointer(cast<RegisterMaskSDNode>(N)->getRegMask());\n    break;\n  case ISD::SRCVALUE:\n    ID.AddPointer(cast<SrcValueSDNode>(N)->getValue());\n    break;\n  case ISD::FrameIndex:\n  case ISD::TargetFrameIndex:\n    ID.AddInteger(cast<FrameIndexSDNode>(N)->getIndex());\n    break;\n  case ISD::LIFETIME_START:\n  case ISD::LIFETIME_END:\n    if (cast<LifetimeSDNode>(N)->hasOffset()) {\n      ID.AddInteger(cast<LifetimeSDNode>(N)->getSize());\n      ID.AddInteger(cast<LifetimeSDNode>(N)->getOffset());\n    }\n    break;\n  case ISD::PSEUDO_PROBE:\n    ID.AddInteger(cast<PseudoProbeSDNode>(N)->getGuid());\n    ID.AddInteger(cast<PseudoProbeSDNode>(N)->getIndex());\n    ID.AddInteger(cast<PseudoProbeSDNode>(N)->getAttributes());\n    break;\n  case ISD::JumpTable:\n  case ISD::TargetJumpTable:\n    ID.AddInteger(cast<JumpTableSDNode>(N)->getIndex());\n    ID.AddInteger(cast<JumpTableSDNode>(N)->getTargetFlags());\n    break;\n  case ISD::ConstantPool:\n  case ISD::TargetConstantPool: {\n    const ConstantPoolSDNode *CP = cast<ConstantPoolSDNode>(N);\n    ID.AddInteger(CP->getAlign().value());\n    ID.AddInteger(CP->getOffset());\n    if (CP->isMachineConstantPoolEntry())\n      CP->getMachineCPVal()->addSelectionDAGCSEId(ID);\n    else\n      ID.AddPointer(CP->getConstVal());\n    ID.AddInteger(CP->getTargetFlags());\n    break;\n  }\n  case ISD::TargetIndex: {\n    const TargetIndexSDNode *TI = cast<TargetIndexSDNode>(N);\n    ID.AddInteger(TI->getIndex());\n    ID.AddInteger(TI->getOffset());\n    ID.AddInteger(TI->getTargetFlags());\n    break;\n  }\n  case ISD::LOAD: {\n    const LoadSDNode *LD = cast<LoadSDNode>(N);\n    ID.AddInteger(LD->getMemoryVT().getRawBits());\n    ID.AddInteger(LD->getRawSubclassData());\n    ID.AddInteger(LD->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::STORE: {\n    const StoreSDNode *ST = cast<StoreSDNode>(N);\n    ID.AddInteger(ST->getMemoryVT().getRawBits());\n    ID.AddInteger(ST->getRawSubclassData());\n    ID.AddInteger(ST->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MLOAD: {\n    const MaskedLoadSDNode *MLD = cast<MaskedLoadSDNode>(N);\n    ID.AddInteger(MLD->getMemoryVT().getRawBits());\n    ID.AddInteger(MLD->getRawSubclassData());\n    ID.AddInteger(MLD->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MSTORE: {\n    const MaskedStoreSDNode *MST = cast<MaskedStoreSDNode>(N);\n    ID.AddInteger(MST->getMemoryVT().getRawBits());\n    ID.AddInteger(MST->getRawSubclassData());\n    ID.AddInteger(MST->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MGATHER: {\n    const MaskedGatherSDNode *MG = cast<MaskedGatherSDNode>(N);\n    ID.AddInteger(MG->getMemoryVT().getRawBits());\n    ID.AddInteger(MG->getRawSubclassData());\n    ID.AddInteger(MG->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MSCATTER: {\n    const MaskedScatterSDNode *MS = cast<MaskedScatterSDNode>(N);\n    ID.AddInteger(MS->getMemoryVT().getRawBits());\n    ID.AddInteger(MS->getRawSubclassData());\n    ID.AddInteger(MS->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::ATOMIC_CMP_SWAP:\n  case ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS:\n  case ISD::ATOMIC_SWAP:\n  case ISD::ATOMIC_LOAD_ADD:\n  case ISD::ATOMIC_LOAD_SUB:\n  case ISD::ATOMIC_LOAD_AND:\n  case ISD::ATOMIC_LOAD_CLR:\n  case ISD::ATOMIC_LOAD_OR:\n  case ISD::ATOMIC_LOAD_XOR:\n  case ISD::ATOMIC_LOAD_NAND:\n  case ISD::ATOMIC_LOAD_MIN:\n  case ISD::ATOMIC_LOAD_MAX:\n  case ISD::ATOMIC_LOAD_UMIN:\n  case ISD::ATOMIC_LOAD_UMAX:\n  case ISD::ATOMIC_LOAD:\n  case ISD::ATOMIC_STORE: {\n    const AtomicSDNode *AT = cast<AtomicSDNode>(N);\n    ID.AddInteger(AT->getMemoryVT().getRawBits());\n    ID.AddInteger(AT->getRawSubclassData());\n    ID.AddInteger(AT->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::PREFETCH: {\n    const MemSDNode *PF = cast<MemSDNode>(N);\n    ID.AddInteger(PF->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::VECTOR_SHUFFLE: {\n    const ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(N);\n    for (unsigned i = 0, e = N->getValueType(0).getVectorNumElements();\n         i != e; ++i)\n      ID.AddInteger(SVN->getMaskElt(i));\n    break;\n  }\n  case ISD::TargetBlockAddress:\n  case ISD::BlockAddress: {\n    const BlockAddressSDNode *BA = cast<BlockAddressSDNode>(N);\n    ID.AddPointer(BA->getBlockAddress());\n    ID.AddInteger(BA->getOffset());\n    ID.AddInteger(BA->getTargetFlags());\n    break;\n  }\n  } // end switch (N->getOpcode())\n\n  // Target specific memory nodes could also have address spaces to check.\n  if (N->isTargetMemoryOpcode())\n    ID.AddInteger(cast<MemSDNode>(N)->getPointerInfo().getAddrSpace());\n}\n\n/// AddNodeIDNode - Generic routine for adding a nodes info to the NodeID\n/// data.\nstatic void AddNodeIDNode(FoldingSetNodeID &ID, const SDNode *N) {\n  AddNodeIDOpcode(ID, N->getOpcode());\n  // Add the return value info.\n  AddNodeIDValueTypes(ID, N->getVTList());\n  // Add the operand info.\n  AddNodeIDOperands(ID, N->ops());\n\n  // Handle SDNode leafs with special info.\n  AddNodeIDCustom(ID, N);\n}\n\n//===----------------------------------------------------------------------===//\n//                              SelectionDAG Class\n//===----------------------------------------------------------------------===//\n\n/// doNotCSE - Return true if CSE should not be performed for this node.\nstatic bool doNotCSE(SDNode *N) {\n  if (N->getValueType(0) == MVT::Glue)\n    return true; // Never CSE anything that produces a flag.\n\n  switch (N->getOpcode()) {\n  default: break;\n  case ISD::HANDLENODE:\n  case ISD::EH_LABEL:\n    return true;   // Never CSE these nodes.\n  }\n\n  // Check that remaining values produced are not flags.\n  for (unsigned i = 1, e = N->getNumValues(); i != e; ++i)\n    if (N->getValueType(i) == MVT::Glue)\n      return true; // Never CSE anything that produces a flag.\n\n  return false;\n}\n\n/// RemoveDeadNodes - This method deletes all unreachable nodes in the\n/// SelectionDAG.\nvoid SelectionDAG::RemoveDeadNodes() {\n  // Create a dummy node (which is not added to allnodes), that adds a reference\n  // to the root node, preventing it from being deleted.\n  HandleSDNode Dummy(getRoot());\n\n  SmallVector<SDNode*, 128> DeadNodes;\n\n  // Add all obviously-dead nodes to the DeadNodes worklist.\n  for (SDNode &Node : allnodes())\n    if (Node.use_empty())\n      DeadNodes.push_back(&Node);\n\n  RemoveDeadNodes(DeadNodes);\n\n  // If the root changed (e.g. it was a dead load, update the root).\n  setRoot(Dummy.getValue());\n}\n\n/// RemoveDeadNodes - This method deletes the unreachable nodes in the\n/// given list, and any nodes that become unreachable as a result.\nvoid SelectionDAG::RemoveDeadNodes(SmallVectorImpl<SDNode *> &DeadNodes) {\n\n  // Process the worklist, deleting the nodes and adding their uses to the\n  // worklist.\n  while (!DeadNodes.empty()) {\n    SDNode *N = DeadNodes.pop_back_val();\n    // Skip to next node if we've already managed to delete the node. This could\n    // happen if replacing a node causes a node previously added to the node to\n    // be deleted.\n    if (N->getOpcode() == ISD::DELETED_NODE)\n      continue;\n\n    for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n      DUL->NodeDeleted(N, nullptr);\n\n    // Take the node out of the appropriate CSE map.\n    RemoveNodeFromCSEMaps(N);\n\n    // Next, brutally remove the operand list.  This is safe to do, as there are\n    // no cycles in the graph.\n    for (SDNode::op_iterator I = N->op_begin(), E = N->op_end(); I != E; ) {\n      SDUse &Use = *I++;\n      SDNode *Operand = Use.getNode();\n      Use.set(SDValue());\n\n      // Now that we removed this operand, see if there are no uses of it left.\n      if (Operand->use_empty())\n        DeadNodes.push_back(Operand);\n    }\n\n    DeallocateNode(N);\n  }\n}\n\nvoid SelectionDAG::RemoveDeadNode(SDNode *N){\n  SmallVector<SDNode*, 16> DeadNodes(1, N);\n\n  // Create a dummy node that adds a reference to the root node, preventing\n  // it from being deleted.  (This matters if the root is an operand of the\n  // dead node.)\n  HandleSDNode Dummy(getRoot());\n\n  RemoveDeadNodes(DeadNodes);\n}\n\nvoid SelectionDAG::DeleteNode(SDNode *N) {\n  // First take this out of the appropriate CSE map.\n  RemoveNodeFromCSEMaps(N);\n\n  // Finally, remove uses due to operands of this node, remove from the\n  // AllNodes list, and delete the node.\n  DeleteNodeNotInCSEMaps(N);\n}\n\nvoid SelectionDAG::DeleteNodeNotInCSEMaps(SDNode *N) {\n  assert(N->getIterator() != AllNodes.begin() &&\n         \"Cannot delete the entry node!\");\n  assert(N->use_empty() && \"Cannot delete a node that is not dead!\");\n\n  // Drop all of the operands and decrement used node's use counts.\n  N->DropOperands();\n\n  DeallocateNode(N);\n}\n\nvoid SDDbgInfo::add(SDDbgValue *V, bool isParameter) {\n  assert(!(V->isVariadic() && isParameter));\n  if (isParameter)\n    ByvalParmDbgValues.push_back(V);\n  else\n    DbgValues.push_back(V);\n  for (const SDNode *Node : V->getSDNodes())\n    if (Node)\n      DbgValMap[Node].push_back(V);\n}\n\nvoid SDDbgInfo::erase(const SDNode *Node) {\n  DbgValMapType::iterator I = DbgValMap.find(Node);\n  if (I == DbgValMap.end())\n    return;\n  for (auto &Val: I->second)\n    Val->setIsInvalidated();\n  DbgValMap.erase(I);\n}\n\nvoid SelectionDAG::DeallocateNode(SDNode *N) {\n  // If we have operands, deallocate them.\n  removeOperands(N);\n\n  NodeAllocator.Deallocate(AllNodes.remove(N));\n\n  // Set the opcode to DELETED_NODE to help catch bugs when node\n  // memory is reallocated.\n  // FIXME: There are places in SDag that have grown a dependency on the opcode\n  // value in the released node.\n  __asan_unpoison_memory_region(&N->NodeType, sizeof(N->NodeType));\n  N->NodeType = ISD::DELETED_NODE;\n\n  // If any of the SDDbgValue nodes refer to this SDNode, invalidate\n  // them and forget about that node.\n  DbgInfo->erase(N);\n}\n\n#ifndef NDEBUG\n/// VerifySDNode - Sanity check the given SDNode.  Aborts if it is invalid.\nstatic void VerifySDNode(SDNode *N) {\n  switch (N->getOpcode()) {\n  default:\n    break;\n  case ISD::BUILD_PAIR: {\n    EVT VT = N->getValueType(0);\n    assert(N->getNumValues() == 1 && \"Too many results!\");\n    assert(!VT.isVector() && (VT.isInteger() || VT.isFloatingPoint()) &&\n           \"Wrong return type!\");\n    assert(N->getNumOperands() == 2 && \"Wrong number of operands!\");\n    assert(N->getOperand(0).getValueType() == N->getOperand(1).getValueType() &&\n           \"Mismatched operand types!\");\n    assert(N->getOperand(0).getValueType().isInteger() == VT.isInteger() &&\n           \"Wrong operand type!\");\n    assert(VT.getSizeInBits() == 2 * N->getOperand(0).getValueSizeInBits() &&\n           \"Wrong return type size\");\n    break;\n  }\n  case ISD::BUILD_VECTOR: {\n    assert(N->getNumValues() == 1 && \"Too many results!\");\n    assert(N->getValueType(0).isVector() && \"Wrong return type!\");\n    assert(N->getNumOperands() == N->getValueType(0).getVectorNumElements() &&\n           \"Wrong number of operands!\");\n    EVT EltVT = N->getValueType(0).getVectorElementType();\n    for (const SDUse &Op : N->ops()) {\n      assert((Op.getValueType() == EltVT ||\n              (EltVT.isInteger() && Op.getValueType().isInteger() &&\n               EltVT.bitsLE(Op.getValueType()))) &&\n             \"Wrong operand type!\");\n      assert(Op.getValueType() == N->getOperand(0).getValueType() &&\n             \"Operands must all have the same type\");\n    }\n    break;\n  }\n  }\n}\n#endif // NDEBUG\n\n/// Insert a newly allocated node into the DAG.\n///\n/// Handles insertion into the all nodes list and CSE map, as well as\n/// verification and other common operations when a new node is allocated.\nvoid SelectionDAG::InsertNode(SDNode *N) {\n  AllNodes.push_back(N);\n#ifndef NDEBUG\n  N->PersistentId = NextPersistentId++;\n  VerifySDNode(N);\n#endif\n  for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n    DUL->NodeInserted(N);\n}\n\n/// RemoveNodeFromCSEMaps - Take the specified node out of the CSE map that\n/// correspond to it.  This is useful when we're about to delete or repurpose\n/// the node.  We don't want future request for structurally identical nodes\n/// to return N anymore.\nbool SelectionDAG::RemoveNodeFromCSEMaps(SDNode *N) {\n  bool Erased = false;\n  switch (N->getOpcode()) {\n  case ISD::HANDLENODE: return false;  // noop.\n  case ISD::CONDCODE:\n    assert(CondCodeNodes[cast<CondCodeSDNode>(N)->get()] &&\n           \"Cond code doesn't exist!\");\n    Erased = CondCodeNodes[cast<CondCodeSDNode>(N)->get()] != nullptr;\n    CondCodeNodes[cast<CondCodeSDNode>(N)->get()] = nullptr;\n    break;\n  case ISD::ExternalSymbol:\n    Erased = ExternalSymbols.erase(cast<ExternalSymbolSDNode>(N)->getSymbol());\n    break;\n  case ISD::TargetExternalSymbol: {\n    ExternalSymbolSDNode *ESN = cast<ExternalSymbolSDNode>(N);\n    Erased = TargetExternalSymbols.erase(std::pair<std::string, unsigned>(\n        ESN->getSymbol(), ESN->getTargetFlags()));\n    break;\n  }\n  case ISD::MCSymbol: {\n    auto *MCSN = cast<MCSymbolSDNode>(N);\n    Erased = MCSymbols.erase(MCSN->getMCSymbol());\n    break;\n  }\n  case ISD::VALUETYPE: {\n    EVT VT = cast<VTSDNode>(N)->getVT();\n    if (VT.isExtended()) {\n      Erased = ExtendedValueTypeNodes.erase(VT);\n    } else {\n      Erased = ValueTypeNodes[VT.getSimpleVT().SimpleTy] != nullptr;\n      ValueTypeNodes[VT.getSimpleVT().SimpleTy] = nullptr;\n    }\n    break;\n  }\n  default:\n    // Remove it from the CSE Map.\n    assert(N->getOpcode() != ISD::DELETED_NODE && \"DELETED_NODE in CSEMap!\");\n    assert(N->getOpcode() != ISD::EntryToken && \"EntryToken in CSEMap!\");\n    Erased = CSEMap.RemoveNode(N);\n    break;\n  }\n#ifndef NDEBUG\n  // Verify that the node was actually in one of the CSE maps, unless it has a\n  // flag result (which cannot be CSE'd) or is one of the special cases that are\n  // not subject to CSE.\n  if (!Erased && N->getValueType(N->getNumValues()-1) != MVT::Glue &&\n      !N->isMachineOpcode() && !doNotCSE(N)) {\n    N->dump(this);\n    dbgs() << \"\\n\";\n    llvm_unreachable(\"Node is not in map!\");\n  }\n#endif\n  return Erased;\n}\n\n/// AddModifiedNodeToCSEMaps - The specified node has been removed from the CSE\n/// maps and modified in place. Add it back to the CSE maps, unless an identical\n/// node already exists, in which case transfer all its users to the existing\n/// node. This transfer can potentially trigger recursive merging.\nvoid\nSelectionDAG::AddModifiedNodeToCSEMaps(SDNode *N) {\n  // For node types that aren't CSE'd, just act as if no identical node\n  // already exists.\n  if (!doNotCSE(N)) {\n    SDNode *Existing = CSEMap.GetOrInsertNode(N);\n    if (Existing != N) {\n      // If there was already an existing matching node, use ReplaceAllUsesWith\n      // to replace the dead one with the existing one.  This can cause\n      // recursive merging of other unrelated nodes down the line.\n      ReplaceAllUsesWith(N, Existing);\n\n      // N is now dead. Inform the listeners and delete it.\n      for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n        DUL->NodeDeleted(N, Existing);\n      DeleteNodeNotInCSEMaps(N);\n      return;\n    }\n  }\n\n  // If the node doesn't already exist, we updated it.  Inform listeners.\n  for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n    DUL->NodeUpdated(N);\n}\n\n/// FindModifiedNodeSlot - Find a slot for the specified node if its operands\n/// were replaced with those specified.  If this node is never memoized,\n/// return null, otherwise return a pointer to the slot it would take.  If a\n/// node already exists with these operands, the slot will be non-null.\nSDNode *SelectionDAG::FindModifiedNodeSlot(SDNode *N, SDValue Op,\n                                           void *&InsertPos) {\n  if (doNotCSE(N))\n    return nullptr;\n\n  SDValue Ops[] = { Op };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, N->getOpcode(), N->getVTList(), Ops);\n  AddNodeIDCustom(ID, N);\n  SDNode *Node = FindNodeOrInsertPos(ID, SDLoc(N), InsertPos);\n  if (Node)\n    Node->intersectFlagsWith(N->getFlags());\n  return Node;\n}\n\n/// FindModifiedNodeSlot - Find a slot for the specified node if its operands\n/// were replaced with those specified.  If this node is never memoized,\n/// return null, otherwise return a pointer to the slot it would take.  If a\n/// node already exists with these operands, the slot will be non-null.\nSDNode *SelectionDAG::FindModifiedNodeSlot(SDNode *N,\n                                           SDValue Op1, SDValue Op2,\n                                           void *&InsertPos) {\n  if (doNotCSE(N))\n    return nullptr;\n\n  SDValue Ops[] = { Op1, Op2 };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, N->getOpcode(), N->getVTList(), Ops);\n  AddNodeIDCustom(ID, N);\n  SDNode *Node = FindNodeOrInsertPos(ID, SDLoc(N), InsertPos);\n  if (Node)\n    Node->intersectFlagsWith(N->getFlags());\n  return Node;\n}\n\n/// FindModifiedNodeSlot - Find a slot for the specified node if its operands\n/// were replaced with those specified.  If this node is never memoized,\n/// return null, otherwise return a pointer to the slot it would take.  If a\n/// node already exists with these operands, the slot will be non-null.\nSDNode *SelectionDAG::FindModifiedNodeSlot(SDNode *N, ArrayRef<SDValue> Ops,\n                                           void *&InsertPos) {\n  if (doNotCSE(N))\n    return nullptr;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, N->getOpcode(), N->getVTList(), Ops);\n  AddNodeIDCustom(ID, N);\n  SDNode *Node = FindNodeOrInsertPos(ID, SDLoc(N), InsertPos);\n  if (Node)\n    Node->intersectFlagsWith(N->getFlags());\n  return Node;\n}\n\nAlign SelectionDAG::getEVTAlign(EVT VT) const {\n  Type *Ty = VT == MVT::iPTR ?\n                   PointerType::get(Type::getInt8Ty(*getContext()), 0) :\n                   VT.getTypeForEVT(*getContext());\n\n  return getDataLayout().getABITypeAlign(Ty);\n}\n\n// EntryNode could meaningfully have debug info if we can find it...\nSelectionDAG::SelectionDAG(const TargetMachine &tm, CodeGenOpt::Level OL)\n    : TM(tm), OptLevel(OL),\n      EntryNode(ISD::EntryToken, 0, DebugLoc(), getVTList(MVT::Other)),\n      Root(getEntryNode()) {\n  InsertNode(&EntryNode);\n  DbgInfo = new SDDbgInfo();\n}\n\nvoid SelectionDAG::init(MachineFunction &NewMF,\n                        OptimizationRemarkEmitter &NewORE,\n                        Pass *PassPtr, const TargetLibraryInfo *LibraryInfo,\n                        LegacyDivergenceAnalysis * Divergence,\n                        ProfileSummaryInfo *PSIin,\n                        BlockFrequencyInfo *BFIin) {\n  MF = &NewMF;\n  SDAGISelPass = PassPtr;\n  ORE = &NewORE;\n  TLI = getSubtarget().getTargetLowering();\n  TSI = getSubtarget().getSelectionDAGInfo();\n  LibInfo = LibraryInfo;\n  Context = &MF->getFunction().getContext();\n  DA = Divergence;\n  PSI = PSIin;\n  BFI = BFIin;\n}\n\nSelectionDAG::~SelectionDAG() {\n  assert(!UpdateListeners && \"Dangling registered DAGUpdateListeners\");\n  allnodes_clear();\n  OperandRecycler.clear(OperandAllocator);\n  delete DbgInfo;\n}\n\nbool SelectionDAG::shouldOptForSize() const {\n  return MF->getFunction().hasOptSize() ||\n      llvm::shouldOptimizeForSize(FLI->MBB->getBasicBlock(), PSI, BFI);\n}\n\nvoid SelectionDAG::allnodes_clear() {\n  assert(&*AllNodes.begin() == &EntryNode);\n  AllNodes.remove(AllNodes.begin());\n  while (!AllNodes.empty())\n    DeallocateNode(&AllNodes.front());\n#ifndef NDEBUG\n  NextPersistentId = 0;\n#endif\n}\n\nSDNode *SelectionDAG::FindNodeOrInsertPos(const FoldingSetNodeID &ID,\n                                          void *&InsertPos) {\n  SDNode *N = CSEMap.FindNodeOrInsertPos(ID, InsertPos);\n  if (N) {\n    switch (N->getOpcode()) {\n    default: break;\n    case ISD::Constant:\n    case ISD::ConstantFP:\n      llvm_unreachable(\"Querying for Constant and ConstantFP nodes requires \"\n                       \"debug location.  Use another overload.\");\n    }\n  }\n  return N;\n}\n\nSDNode *SelectionDAG::FindNodeOrInsertPos(const FoldingSetNodeID &ID,\n                                          const SDLoc &DL, void *&InsertPos) {\n  SDNode *N = CSEMap.FindNodeOrInsertPos(ID, InsertPos);\n  if (N) {\n    switch (N->getOpcode()) {\n    case ISD::Constant:\n    case ISD::ConstantFP:\n      // Erase debug location from the node if the node is used at several\n      // different places. Do not propagate one location to all uses as it\n      // will cause a worse single stepping debugging experience.\n      if (N->getDebugLoc() != DL.getDebugLoc())\n        N->setDebugLoc(DebugLoc());\n      break;\n    default:\n      // When the node's point of use is located earlier in the instruction\n      // sequence than its prior point of use, update its debug info to the\n      // earlier location.\n      if (DL.getIROrder() && DL.getIROrder() < N->getIROrder())\n        N->setDebugLoc(DL.getDebugLoc());\n      break;\n    }\n  }\n  return N;\n}\n\nvoid SelectionDAG::clear() {\n  allnodes_clear();\n  OperandRecycler.clear(OperandAllocator);\n  OperandAllocator.Reset();\n  CSEMap.clear();\n\n  ExtendedValueTypeNodes.clear();\n  ExternalSymbols.clear();\n  TargetExternalSymbols.clear();\n  MCSymbols.clear();\n  SDCallSiteDbgInfo.clear();\n  std::fill(CondCodeNodes.begin(), CondCodeNodes.end(),\n            static_cast<CondCodeSDNode*>(nullptr));\n  std::fill(ValueTypeNodes.begin(), ValueTypeNodes.end(),\n            static_cast<SDNode*>(nullptr));\n\n  EntryNode.UseList = nullptr;\n  InsertNode(&EntryNode);\n  Root = getEntryNode();\n  DbgInfo->clear();\n}\n\nSDValue SelectionDAG::getFPExtendOrRound(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType())\n             ? getNode(ISD::FP_EXTEND, DL, VT, Op)\n             : getNode(ISD::FP_ROUND, DL, VT, Op, getIntPtrConstant(0, DL));\n}\n\nstd::pair<SDValue, SDValue>\nSelectionDAG::getStrictFPExtendOrRound(SDValue Op, SDValue Chain,\n                                       const SDLoc &DL, EVT VT) {\n  assert(!VT.bitsEq(Op.getValueType()) &&\n         \"Strict no-op FP extend/round not allowed.\");\n  SDValue Res =\n      VT.bitsGT(Op.getValueType())\n          ? getNode(ISD::STRICT_FP_EXTEND, DL, {VT, MVT::Other}, {Chain, Op})\n          : getNode(ISD::STRICT_FP_ROUND, DL, {VT, MVT::Other},\n                    {Chain, Op, getIntPtrConstant(0, DL)});\n\n  return std::pair<SDValue, SDValue>(Res, SDValue(Res.getNode(), 1));\n}\n\nSDValue SelectionDAG::getAnyExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType()) ?\n    getNode(ISD::ANY_EXTEND, DL, VT, Op) :\n    getNode(ISD::TRUNCATE, DL, VT, Op);\n}\n\nSDValue SelectionDAG::getSExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType()) ?\n    getNode(ISD::SIGN_EXTEND, DL, VT, Op) :\n    getNode(ISD::TRUNCATE, DL, VT, Op);\n}\n\nSDValue SelectionDAG::getZExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType()) ?\n    getNode(ISD::ZERO_EXTEND, DL, VT, Op) :\n    getNode(ISD::TRUNCATE, DL, VT, Op);\n}\n\nSDValue SelectionDAG::getBoolExtOrTrunc(SDValue Op, const SDLoc &SL, EVT VT,\n                                        EVT OpVT) {\n  if (VT.bitsLE(Op.getValueType()))\n    return getNode(ISD::TRUNCATE, SL, VT, Op);\n\n  TargetLowering::BooleanContent BType = TLI->getBooleanContents(OpVT);\n  return getNode(TLI->getExtendForContent(BType), SL, VT, Op);\n}\n\nSDValue SelectionDAG::getZeroExtendInReg(SDValue Op, const SDLoc &DL, EVT VT) {\n  EVT OpVT = Op.getValueType();\n  assert(VT.isInteger() && OpVT.isInteger() &&\n         \"Cannot getZeroExtendInReg FP types\");\n  assert(VT.isVector() == OpVT.isVector() &&\n         \"getZeroExtendInReg type should be vector iff the operand \"\n         \"type is vector!\");\n  assert((!VT.isVector() ||\n          VT.getVectorElementCount() == OpVT.getVectorElementCount()) &&\n         \"Vector element counts must match in getZeroExtendInReg\");\n  assert(VT.bitsLE(OpVT) && \"Not extending!\");\n  if (OpVT == VT)\n    return Op;\n  APInt Imm = APInt::getLowBitsSet(OpVT.getScalarSizeInBits(),\n                                   VT.getScalarSizeInBits());\n  return getNode(ISD::AND, DL, OpVT, Op, getConstant(Imm, DL, OpVT));\n}\n\nSDValue SelectionDAG::getPtrExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  // Only unsigned pointer semantics are supported right now. In the future this\n  // might delegate to TLI to check pointer signedness.\n  return getZExtOrTrunc(Op, DL, VT);\n}\n\nSDValue SelectionDAG::getPtrExtendInReg(SDValue Op, const SDLoc &DL, EVT VT) {\n  // Only unsigned pointer semantics are supported right now. In the future this\n  // might delegate to TLI to check pointer signedness.\n  return getZeroExtendInReg(Op, DL, VT);\n}\n\n/// getNOT - Create a bitwise NOT operation as (XOR Val, -1).\nSDValue SelectionDAG::getNOT(const SDLoc &DL, SDValue Val, EVT VT) {\n  EVT EltVT = VT.getScalarType();\n  SDValue NegOne =\n    getConstant(APInt::getAllOnesValue(EltVT.getSizeInBits()), DL, VT);\n  return getNode(ISD::XOR, DL, VT, Val, NegOne);\n}\n\nSDValue SelectionDAG::getLogicalNOT(const SDLoc &DL, SDValue Val, EVT VT) {\n  SDValue TrueValue = getBoolConstant(true, DL, VT, VT);\n  return getNode(ISD::XOR, DL, VT, Val, TrueValue);\n}\n\nSDValue SelectionDAG::getBoolConstant(bool V, const SDLoc &DL, EVT VT,\n                                      EVT OpVT) {\n  if (!V)\n    return getConstant(0, DL, VT);\n\n  switch (TLI->getBooleanContents(OpVT)) {\n  case TargetLowering::ZeroOrOneBooleanContent:\n  case TargetLowering::UndefinedBooleanContent:\n    return getConstant(1, DL, VT);\n  case TargetLowering::ZeroOrNegativeOneBooleanContent:\n    return getAllOnesConstant(DL, VT);\n  }\n  llvm_unreachable(\"Unexpected boolean content enum!\");\n}\n\nSDValue SelectionDAG::getConstant(uint64_t Val, const SDLoc &DL, EVT VT,\n                                  bool isT, bool isO) {\n  EVT EltVT = VT.getScalarType();\n  assert((EltVT.getSizeInBits() >= 64 ||\n          (uint64_t)((int64_t)Val >> EltVT.getSizeInBits()) + 1 < 2) &&\n         \"getConstant with a uint64_t value that doesn't fit in the type!\");\n  return getConstant(APInt(EltVT.getSizeInBits(), Val), DL, VT, isT, isO);\n}\n\nSDValue SelectionDAG::getConstant(const APInt &Val, const SDLoc &DL, EVT VT,\n                                  bool isT, bool isO) {\n  return getConstant(*ConstantInt::get(*Context, Val), DL, VT, isT, isO);\n}\n\nSDValue SelectionDAG::getConstant(const ConstantInt &Val, const SDLoc &DL,\n                                  EVT VT, bool isT, bool isO) {\n  assert(VT.isInteger() && \"Cannot create FP integer constant!\");\n\n  EVT EltVT = VT.getScalarType();\n  const ConstantInt *Elt = &Val;\n\n  // In some cases the vector type is legal but the element type is illegal and\n  // needs to be promoted, for example v8i8 on ARM.  In this case, promote the\n  // inserted value (the type does not need to match the vector element type).\n  // Any extra bits introduced will be truncated away.\n  if (VT.isVector() && TLI->getTypeAction(*getContext(), EltVT) ==\n                           TargetLowering::TypePromoteInteger) {\n    EltVT = TLI->getTypeToTransformTo(*getContext(), EltVT);\n    APInt NewVal = Elt->getValue().zextOrTrunc(EltVT.getSizeInBits());\n    Elt = ConstantInt::get(*getContext(), NewVal);\n  }\n  // In other cases the element type is illegal and needs to be expanded, for\n  // example v2i64 on MIPS32. In this case, find the nearest legal type, split\n  // the value into n parts and use a vector type with n-times the elements.\n  // Then bitcast to the type requested.\n  // Legalizing constants too early makes the DAGCombiner's job harder so we\n  // only legalize if the DAG tells us we must produce legal types.\n  else if (NewNodesMustHaveLegalTypes && VT.isVector() &&\n           TLI->getTypeAction(*getContext(), EltVT) ==\n               TargetLowering::TypeExpandInteger) {\n    const APInt &NewVal = Elt->getValue();\n    EVT ViaEltVT = TLI->getTypeToTransformTo(*getContext(), EltVT);\n    unsigned ViaEltSizeInBits = ViaEltVT.getSizeInBits();\n\n    // For scalable vectors, try to use a SPLAT_VECTOR_PARTS node.\n    if (VT.isScalableVector()) {\n      assert(EltVT.getSizeInBits() % ViaEltSizeInBits == 0 &&\n             \"Can only handle an even split!\");\n      unsigned Parts = EltVT.getSizeInBits() / ViaEltSizeInBits;\n\n      SmallVector<SDValue, 2> ScalarParts;\n      for (unsigned i = 0; i != Parts; ++i)\n        ScalarParts.push_back(getConstant(\n            NewVal.lshr(i * ViaEltSizeInBits).trunc(ViaEltSizeInBits), DL,\n            ViaEltVT, isT, isO));\n\n      return getNode(ISD::SPLAT_VECTOR_PARTS, DL, VT, ScalarParts);\n    }\n\n    unsigned ViaVecNumElts = VT.getSizeInBits() / ViaEltSizeInBits;\n    EVT ViaVecVT = EVT::getVectorVT(*getContext(), ViaEltVT, ViaVecNumElts);\n\n    // Check the temporary vector is the correct size. If this fails then\n    // getTypeToTransformTo() probably returned a type whose size (in bits)\n    // isn't a power-of-2 factor of the requested type size.\n    assert(ViaVecVT.getSizeInBits() == VT.getSizeInBits());\n\n    SmallVector<SDValue, 2> EltParts;\n    for (unsigned i = 0; i < ViaVecNumElts / VT.getVectorNumElements(); ++i) {\n      EltParts.push_back(getConstant(\n          NewVal.lshr(i * ViaEltSizeInBits).zextOrTrunc(ViaEltSizeInBits), DL,\n          ViaEltVT, isT, isO));\n    }\n\n    // EltParts is currently in little endian order. If we actually want\n    // big-endian order then reverse it now.\n    if (getDataLayout().isBigEndian())\n      std::reverse(EltParts.begin(), EltParts.end());\n\n    // The elements must be reversed when the element order is different\n    // to the endianness of the elements (because the BITCAST is itself a\n    // vector shuffle in this situation). However, we do not need any code to\n    // perform this reversal because getConstant() is producing a vector\n    // splat.\n    // This situation occurs in MIPS MSA.\n\n    SmallVector<SDValue, 8> Ops;\n    for (unsigned i = 0, e = VT.getVectorNumElements(); i != e; ++i)\n      llvm::append_range(Ops, EltParts);\n\n    SDValue V =\n        getNode(ISD::BITCAST, DL, VT, getBuildVector(ViaVecVT, DL, Ops));\n    return V;\n  }\n\n  assert(Elt->getBitWidth() == EltVT.getSizeInBits() &&\n         \"APInt size does not match type size!\");\n  unsigned Opc = isT ? ISD::TargetConstant : ISD::Constant;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(EltVT), None);\n  ID.AddPointer(Elt);\n  ID.AddBoolean(isO);\n  void *IP = nullptr;\n  SDNode *N = nullptr;\n  if ((N = FindNodeOrInsertPos(ID, DL, IP)))\n    if (!VT.isVector())\n      return SDValue(N, 0);\n\n  if (!N) {\n    N = newSDNode<ConstantSDNode>(isT, isO, Elt, EltVT);\n    CSEMap.InsertNode(N, IP);\n    InsertNode(N);\n    NewSDValueDbgMsg(SDValue(N, 0), \"Creating constant: \", this);\n  }\n\n  SDValue Result(N, 0);\n  if (VT.isScalableVector())\n    Result = getSplatVector(VT, DL, Result);\n  else if (VT.isVector())\n    Result = getSplatBuildVector(VT, DL, Result);\n\n  return Result;\n}\n\nSDValue SelectionDAG::getIntPtrConstant(uint64_t Val, const SDLoc &DL,\n                                        bool isTarget) {\n  return getConstant(Val, DL, TLI->getPointerTy(getDataLayout()), isTarget);\n}\n\nSDValue SelectionDAG::getShiftAmountConstant(uint64_t Val, EVT VT,\n                                             const SDLoc &DL, bool LegalTypes) {\n  assert(VT.isInteger() && \"Shift amount is not an integer type!\");\n  EVT ShiftVT = TLI->getShiftAmountTy(VT, getDataLayout(), LegalTypes);\n  return getConstant(Val, DL, ShiftVT);\n}\n\nSDValue SelectionDAG::getVectorIdxConstant(uint64_t Val, const SDLoc &DL,\n                                           bool isTarget) {\n  return getConstant(Val, DL, TLI->getVectorIdxTy(getDataLayout()), isTarget);\n}\n\nSDValue SelectionDAG::getConstantFP(const APFloat &V, const SDLoc &DL, EVT VT,\n                                    bool isTarget) {\n  return getConstantFP(*ConstantFP::get(*getContext(), V), DL, VT, isTarget);\n}\n\nSDValue SelectionDAG::getConstantFP(const ConstantFP &V, const SDLoc &DL,\n                                    EVT VT, bool isTarget) {\n  assert(VT.isFloatingPoint() && \"Cannot create integer FP constant!\");\n\n  EVT EltVT = VT.getScalarType();\n\n  // Do the map lookup using the actual bit pattern for the floating point\n  // value, so that we don't have problems with 0.0 comparing equal to -0.0, and\n  // we don't have issues with SNANs.\n  unsigned Opc = isTarget ? ISD::TargetConstantFP : ISD::ConstantFP;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(EltVT), None);\n  ID.AddPointer(&V);\n  void *IP = nullptr;\n  SDNode *N = nullptr;\n  if ((N = FindNodeOrInsertPos(ID, DL, IP)))\n    if (!VT.isVector())\n      return SDValue(N, 0);\n\n  if (!N) {\n    N = newSDNode<ConstantFPSDNode>(isTarget, &V, EltVT);\n    CSEMap.InsertNode(N, IP);\n    InsertNode(N);\n  }\n\n  SDValue Result(N, 0);\n  if (VT.isScalableVector())\n    Result = getSplatVector(VT, DL, Result);\n  else if (VT.isVector())\n    Result = getSplatBuildVector(VT, DL, Result);\n  NewSDValueDbgMsg(Result, \"Creating fp constant: \", this);\n  return Result;\n}\n\nSDValue SelectionDAG::getConstantFP(double Val, const SDLoc &DL, EVT VT,\n                                    bool isTarget) {\n  EVT EltVT = VT.getScalarType();\n  if (EltVT == MVT::f32)\n    return getConstantFP(APFloat((float)Val), DL, VT, isTarget);\n  else if (EltVT == MVT::f64)\n    return getConstantFP(APFloat(Val), DL, VT, isTarget);\n  else if (EltVT == MVT::f80 || EltVT == MVT::f128 || EltVT == MVT::ppcf128 ||\n           EltVT == MVT::f16 || EltVT == MVT::bf16) {\n    bool Ignored;\n    APFloat APF = APFloat(Val);\n    APF.convert(EVTToAPFloatSemantics(EltVT), APFloat::rmNearestTiesToEven,\n                &Ignored);\n    return getConstantFP(APF, DL, VT, isTarget);\n  } else\n    llvm_unreachable(\"Unsupported type in getConstantFP\");\n}\n\nSDValue SelectionDAG::getGlobalAddress(const GlobalValue *GV, const SDLoc &DL,\n                                       EVT VT, int64_t Offset, bool isTargetGA,\n                                       unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTargetGA) &&\n         \"Cannot set target flags on target-independent globals\");\n\n  // Truncate (with sign-extension) the offset value to the pointer size.\n  unsigned BitWidth = getDataLayout().getPointerTypeSizeInBits(GV->getType());\n  if (BitWidth < 64)\n    Offset = SignExtend64(Offset, BitWidth);\n\n  unsigned Opc;\n  if (GV->isThreadLocal())\n    Opc = isTargetGA ? ISD::TargetGlobalTLSAddress : ISD::GlobalTLSAddress;\n  else\n    Opc = isTargetGA ? ISD::TargetGlobalAddress : ISD::GlobalAddress;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddPointer(GV);\n  ID.AddInteger(Offset);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<GlobalAddressSDNode>(\n      Opc, DL.getIROrder(), DL.getDebugLoc(), GV, VT, Offset, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n    InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getFrameIndex(int FI, EVT VT, bool isTarget) {\n  unsigned Opc = isTarget ? ISD::TargetFrameIndex : ISD::FrameIndex;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(FI);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<FrameIndexSDNode>(FI, VT, isTarget);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getJumpTable(int JTI, EVT VT, bool isTarget,\n                                   unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTarget) &&\n         \"Cannot set target flags on target-independent jump tables\");\n  unsigned Opc = isTarget ? ISD::TargetJumpTable : ISD::JumpTable;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(JTI);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<JumpTableSDNode>(JTI, VT, isTarget, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getConstantPool(const Constant *C, EVT VT,\n                                      MaybeAlign Alignment, int Offset,\n                                      bool isTarget, unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTarget) &&\n         \"Cannot set target flags on target-independent globals\");\n  if (!Alignment)\n    Alignment = shouldOptForSize()\n                    ? getDataLayout().getABITypeAlign(C->getType())\n                    : getDataLayout().getPrefTypeAlign(C->getType());\n  unsigned Opc = isTarget ? ISD::TargetConstantPool : ISD::ConstantPool;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(Alignment->value());\n  ID.AddInteger(Offset);\n  ID.AddPointer(C);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<ConstantPoolSDNode>(isTarget, C, VT, Offset, *Alignment,\n                                          TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new constant pool: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getConstantPool(MachineConstantPoolValue *C, EVT VT,\n                                      MaybeAlign Alignment, int Offset,\n                                      bool isTarget, unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTarget) &&\n         \"Cannot set target flags on target-independent globals\");\n  if (!Alignment)\n    Alignment = getDataLayout().getPrefTypeAlign(C->getType());\n  unsigned Opc = isTarget ? ISD::TargetConstantPool : ISD::ConstantPool;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(Alignment->value());\n  ID.AddInteger(Offset);\n  C->addSelectionDAGCSEId(ID);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<ConstantPoolSDNode>(isTarget, C, VT, Offset, *Alignment,\n                                          TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getTargetIndex(int Index, EVT VT, int64_t Offset,\n                                     unsigned TargetFlags) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::TargetIndex, getVTList(VT), None);\n  ID.AddInteger(Index);\n  ID.AddInteger(Offset);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<TargetIndexSDNode>(Index, VT, Offset, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getBasicBlock(MachineBasicBlock *MBB) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::BasicBlock, getVTList(MVT::Other), None);\n  ID.AddPointer(MBB);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<BasicBlockSDNode>(MBB);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getValueType(EVT VT) {\n  if (VT.isSimple() && (unsigned)VT.getSimpleVT().SimpleTy >=\n      ValueTypeNodes.size())\n    ValueTypeNodes.resize(VT.getSimpleVT().SimpleTy+1);\n\n  SDNode *&N = VT.isExtended() ?\n    ExtendedValueTypeNodes[VT] : ValueTypeNodes[VT.getSimpleVT().SimpleTy];\n\n  if (N) return SDValue(N, 0);\n  N = newSDNode<VTSDNode>(VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getExternalSymbol(const char *Sym, EVT VT) {\n  SDNode *&N = ExternalSymbols[Sym];\n  if (N) return SDValue(N, 0);\n  N = newSDNode<ExternalSymbolSDNode>(false, Sym, 0, VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getMCSymbol(MCSymbol *Sym, EVT VT) {\n  SDNode *&N = MCSymbols[Sym];\n  if (N)\n    return SDValue(N, 0);\n  N = newSDNode<MCSymbolSDNode>(Sym, VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getTargetExternalSymbol(const char *Sym, EVT VT,\n                                              unsigned TargetFlags) {\n  SDNode *&N =\n      TargetExternalSymbols[std::pair<std::string, unsigned>(Sym, TargetFlags)];\n  if (N) return SDValue(N, 0);\n  N = newSDNode<ExternalSymbolSDNode>(true, Sym, TargetFlags, VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getCondCode(ISD::CondCode Cond) {\n  if ((unsigned)Cond >= CondCodeNodes.size())\n    CondCodeNodes.resize(Cond+1);\n\n  if (!CondCodeNodes[Cond]) {\n    auto *N = newSDNode<CondCodeSDNode>(Cond);\n    CondCodeNodes[Cond] = N;\n    InsertNode(N);\n  }\n\n  return SDValue(CondCodeNodes[Cond], 0);\n}\n\n/// Swaps the values of N1 and N2. Swaps all indices in the shuffle mask M that\n/// point at N1 to point at N2 and indices that point at N2 to point at N1.\nstatic void commuteShuffle(SDValue &N1, SDValue &N2, MutableArrayRef<int> M) {\n  std::swap(N1, N2);\n  ShuffleVectorSDNode::commuteMask(M);\n}\n\nSDValue SelectionDAG::getVectorShuffle(EVT VT, const SDLoc &dl, SDValue N1,\n                                       SDValue N2, ArrayRef<int> Mask) {\n  assert(VT.getVectorNumElements() == Mask.size() &&\n           \"Must have the same number of vector elements as mask elements!\");\n  assert(VT == N1.getValueType() && VT == N2.getValueType() &&\n         \"Invalid VECTOR_SHUFFLE\");\n\n  // Canonicalize shuffle undef, undef -> undef\n  if (N1.isUndef() && N2.isUndef())\n    return getUNDEF(VT);\n\n  // Validate that all indices in Mask are within the range of the elements\n  // input to the shuffle.\n  int NElts = Mask.size();\n  assert(llvm::all_of(Mask,\n                      [&](int M) { return M < (NElts * 2) && M >= -1; }) &&\n         \"Index out of range\");\n\n  // Copy the mask so we can do any needed cleanup.\n  SmallVector<int, 8> MaskVec(Mask.begin(), Mask.end());\n\n  // Canonicalize shuffle v, v -> v, undef\n  if (N1 == N2) {\n    N2 = getUNDEF(VT);\n    for (int i = 0; i != NElts; ++i)\n      if (MaskVec[i] >= NElts) MaskVec[i] -= NElts;\n  }\n\n  // Canonicalize shuffle undef, v -> v, undef.  Commute the shuffle mask.\n  if (N1.isUndef())\n    commuteShuffle(N1, N2, MaskVec);\n\n  if (TLI->hasVectorBlend()) {\n    // If shuffling a splat, try to blend the splat instead. We do this here so\n    // that even when this arises during lowering we don't have to re-handle it.\n    auto BlendSplat = [&](BuildVectorSDNode *BV, int Offset) {\n      BitVector UndefElements;\n      SDValue Splat = BV->getSplatValue(&UndefElements);\n      if (!Splat)\n        return;\n\n      for (int i = 0; i < NElts; ++i) {\n        if (MaskVec[i] < Offset || MaskVec[i] >= (Offset + NElts))\n          continue;\n\n        // If this input comes from undef, mark it as such.\n        if (UndefElements[MaskVec[i] - Offset]) {\n          MaskVec[i] = -1;\n          continue;\n        }\n\n        // If we can blend a non-undef lane, use that instead.\n        if (!UndefElements[i])\n          MaskVec[i] = i + Offset;\n      }\n    };\n    if (auto *N1BV = dyn_cast<BuildVectorSDNode>(N1))\n      BlendSplat(N1BV, 0);\n    if (auto *N2BV = dyn_cast<BuildVectorSDNode>(N2))\n      BlendSplat(N2BV, NElts);\n  }\n\n  // Canonicalize all index into lhs, -> shuffle lhs, undef\n  // Canonicalize all index into rhs, -> shuffle rhs, undef\n  bool AllLHS = true, AllRHS = true;\n  bool N2Undef = N2.isUndef();\n  for (int i = 0; i != NElts; ++i) {\n    if (MaskVec[i] >= NElts) {\n      if (N2Undef)\n        MaskVec[i] = -1;\n      else\n        AllLHS = false;\n    } else if (MaskVec[i] >= 0) {\n      AllRHS = false;\n    }\n  }\n  if (AllLHS && AllRHS)\n    return getUNDEF(VT);\n  if (AllLHS && !N2Undef)\n    N2 = getUNDEF(VT);\n  if (AllRHS) {\n    N1 = getUNDEF(VT);\n    commuteShuffle(N1, N2, MaskVec);\n  }\n  // Reset our undef status after accounting for the mask.\n  N2Undef = N2.isUndef();\n  // Re-check whether both sides ended up undef.\n  if (N1.isUndef() && N2Undef)\n    return getUNDEF(VT);\n\n  // If Identity shuffle return that node.\n  bool Identity = true, AllSame = true;\n  for (int i = 0; i != NElts; ++i) {\n    if (MaskVec[i] >= 0 && MaskVec[i] != i) Identity = false;\n    if (MaskVec[i] != MaskVec[0]) AllSame = false;\n  }\n  if (Identity && NElts)\n    return N1;\n\n  // Shuffling a constant splat doesn't change the result.\n  if (N2Undef) {\n    SDValue V = N1;\n\n    // Look through any bitcasts. We check that these don't change the number\n    // (and size) of elements and just changes their types.\n    while (V.getOpcode() == ISD::BITCAST)\n      V = V->getOperand(0);\n\n    // A splat should always show up as a build vector node.\n    if (auto *BV = dyn_cast<BuildVectorSDNode>(V)) {\n      BitVector UndefElements;\n      SDValue Splat = BV->getSplatValue(&UndefElements);\n      // If this is a splat of an undef, shuffling it is also undef.\n      if (Splat && Splat.isUndef())\n        return getUNDEF(VT);\n\n      bool SameNumElts =\n          V.getValueType().getVectorNumElements() == VT.getVectorNumElements();\n\n      // We only have a splat which can skip shuffles if there is a splatted\n      // value and no undef lanes rearranged by the shuffle.\n      if (Splat && UndefElements.none()) {\n        // Splat of <x, x, ..., x>, return <x, x, ..., x>, provided that the\n        // number of elements match or the value splatted is a zero constant.\n        if (SameNumElts)\n          return N1;\n        if (auto *C = dyn_cast<ConstantSDNode>(Splat))\n          if (C->isNullValue())\n            return N1;\n      }\n\n      // If the shuffle itself creates a splat, build the vector directly.\n      if (AllSame && SameNumElts) {\n        EVT BuildVT = BV->getValueType(0);\n        const SDValue &Splatted = BV->getOperand(MaskVec[0]);\n        SDValue NewBV = getSplatBuildVector(BuildVT, dl, Splatted);\n\n        // We may have jumped through bitcasts, so the type of the\n        // BUILD_VECTOR may not match the type of the shuffle.\n        if (BuildVT != VT)\n          NewBV = getNode(ISD::BITCAST, dl, VT, NewBV);\n        return NewBV;\n      }\n    }\n  }\n\n  FoldingSetNodeID ID;\n  SDValue Ops[2] = { N1, N2 };\n  AddNodeIDNode(ID, ISD::VECTOR_SHUFFLE, getVTList(VT), Ops);\n  for (int i = 0; i != NElts; ++i)\n    ID.AddInteger(MaskVec[i]);\n\n  void* IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  // Allocate the mask array for the node out of the BumpPtrAllocator, since\n  // SDNode doesn't have access to it.  This memory will be \"leaked\" when\n  // the node is deallocated, but recovered when the NodeAllocator is released.\n  int *MaskAlloc = OperandAllocator.Allocate<int>(NElts);\n  llvm::copy(MaskVec, MaskAlloc);\n\n  auto *N = newSDNode<ShuffleVectorSDNode>(VT, dl.getIROrder(),\n                                           dl.getDebugLoc(), MaskAlloc);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getCommutedVectorShuffle(const ShuffleVectorSDNode &SV) {\n  EVT VT = SV.getValueType(0);\n  SmallVector<int, 8> MaskVec(SV.getMask().begin(), SV.getMask().end());\n  ShuffleVectorSDNode::commuteMask(MaskVec);\n\n  SDValue Op0 = SV.getOperand(0);\n  SDValue Op1 = SV.getOperand(1);\n  return getVectorShuffle(VT, SDLoc(&SV), Op1, Op0, MaskVec);\n}\n\nSDValue SelectionDAG::getRegister(unsigned RegNo, EVT VT) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::Register, getVTList(VT), None);\n  ID.AddInteger(RegNo);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<RegisterSDNode>(RegNo, VT);\n  N->SDNodeBits.IsDivergent = TLI->isSDNodeSourceOfDivergence(N, FLI, DA);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getRegisterMask(const uint32_t *RegMask) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::RegisterMask, getVTList(MVT::Untyped), None);\n  ID.AddPointer(RegMask);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<RegisterMaskSDNode>(RegMask);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getEHLabel(const SDLoc &dl, SDValue Root,\n                                 MCSymbol *Label) {\n  return getLabelNode(ISD::EH_LABEL, dl, Root, Label);\n}\n\nSDValue SelectionDAG::getLabelNode(unsigned Opcode, const SDLoc &dl,\n                                   SDValue Root, MCSymbol *Label) {\n  FoldingSetNodeID ID;\n  SDValue Ops[] = { Root };\n  AddNodeIDNode(ID, Opcode, getVTList(MVT::Other), Ops);\n  ID.AddPointer(Label);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N =\n      newSDNode<LabelSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(), Label);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getBlockAddress(const BlockAddress *BA, EVT VT,\n                                      int64_t Offset, bool isTarget,\n                                      unsigned TargetFlags) {\n  unsigned Opc = isTarget ? ISD::TargetBlockAddress : ISD::BlockAddress;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddPointer(BA);\n  ID.AddInteger(Offset);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<BlockAddressSDNode>(Opc, VT, BA, Offset, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getSrcValue(const Value *V) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::SRCVALUE, getVTList(MVT::Other), None);\n  ID.AddPointer(V);\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<SrcValueSDNode>(V);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getMDNode(const MDNode *MD) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MDNODE_SDNODE, getVTList(MVT::Other), None);\n  ID.AddPointer(MD);\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<MDNodeSDNode>(MD);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getBitcast(EVT VT, SDValue V) {\n  if (VT == V.getValueType())\n    return V;\n\n  return getNode(ISD::BITCAST, SDLoc(V), VT, V);\n}\n\nSDValue SelectionDAG::getAddrSpaceCast(const SDLoc &dl, EVT VT, SDValue Ptr,\n                                       unsigned SrcAS, unsigned DestAS) {\n  SDValue Ops[] = {Ptr};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::ADDRSPACECAST, getVTList(VT), Ops);\n  ID.AddInteger(SrcAS);\n  ID.AddInteger(DestAS);\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<AddrSpaceCastSDNode>(dl.getIROrder(), dl.getDebugLoc(),\n                                           VT, SrcAS, DestAS);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getFreeze(SDValue V) {\n  return getNode(ISD::FREEZE, SDLoc(V), V.getValueType(), V);\n}\n\n/// getShiftAmountOperand - Return the specified value casted to\n/// the target's desired shift amount type.\nSDValue SelectionDAG::getShiftAmountOperand(EVT LHSTy, SDValue Op) {\n  EVT OpTy = Op.getValueType();\n  EVT ShTy = TLI->getShiftAmountTy(LHSTy, getDataLayout());\n  if (OpTy == ShTy || OpTy.isVector()) return Op;\n\n  return getZExtOrTrunc(Op, SDLoc(Op), ShTy);\n}\n\nSDValue SelectionDAG::expandVAArg(SDNode *Node) {\n  SDLoc dl(Node);\n  const TargetLowering &TLI = getTargetLoweringInfo();\n  const Value *V = cast<SrcValueSDNode>(Node->getOperand(2))->getValue();\n  EVT VT = Node->getValueType(0);\n  SDValue Tmp1 = Node->getOperand(0);\n  SDValue Tmp2 = Node->getOperand(1);\n  const MaybeAlign MA(Node->getConstantOperandVal(3));\n\n  SDValue VAListLoad = getLoad(TLI.getPointerTy(getDataLayout()), dl, Tmp1,\n                               Tmp2, MachinePointerInfo(V));\n  SDValue VAList = VAListLoad;\n\n  if (MA && *MA > TLI.getMinStackArgumentAlignment()) {\n    VAList = getNode(ISD::ADD, dl, VAList.getValueType(), VAList,\n                     getConstant(MA->value() - 1, dl, VAList.getValueType()));\n\n    VAList =\n        getNode(ISD::AND, dl, VAList.getValueType(), VAList,\n                getConstant(-(int64_t)MA->value(), dl, VAList.getValueType()));\n  }\n\n  // Increment the pointer, VAList, to the next vaarg\n  Tmp1 = getNode(ISD::ADD, dl, VAList.getValueType(), VAList,\n                 getConstant(getDataLayout().getTypeAllocSize(\n                                               VT.getTypeForEVT(*getContext())),\n                             dl, VAList.getValueType()));\n  // Store the incremented VAList to the legalized pointer\n  Tmp1 =\n      getStore(VAListLoad.getValue(1), dl, Tmp1, Tmp2, MachinePointerInfo(V));\n  // Load the actual argument out of the pointer VAList\n  return getLoad(VT, dl, Tmp1, VAList, MachinePointerInfo());\n}\n\nSDValue SelectionDAG::expandVACopy(SDNode *Node) {\n  SDLoc dl(Node);\n  const TargetLowering &TLI = getTargetLoweringInfo();\n  // This defaults to loading a pointer from the input and storing it to the\n  // output, returning the chain.\n  const Value *VD = cast<SrcValueSDNode>(Node->getOperand(3))->getValue();\n  const Value *VS = cast<SrcValueSDNode>(Node->getOperand(4))->getValue();\n  SDValue Tmp1 =\n      getLoad(TLI.getPointerTy(getDataLayout()), dl, Node->getOperand(0),\n              Node->getOperand(2), MachinePointerInfo(VS));\n  return getStore(Tmp1.getValue(1), dl, Tmp1, Node->getOperand(1),\n                  MachinePointerInfo(VD));\n}\n\nAlign SelectionDAG::getReducedAlign(EVT VT, bool UseABI) {\n  const DataLayout &DL = getDataLayout();\n  Type *Ty = VT.getTypeForEVT(*getContext());\n  Align RedAlign = UseABI ? DL.getABITypeAlign(Ty) : DL.getPrefTypeAlign(Ty);\n\n  if (TLI->isTypeLegal(VT) || !VT.isVector())\n    return RedAlign;\n\n  const TargetFrameLowering *TFI = MF->getSubtarget().getFrameLowering();\n  const Align StackAlign = TFI->getStackAlign();\n\n  // See if we can choose a smaller ABI alignment in cases where it's an\n  // illegal vector type that will get broken down.\n  if (RedAlign > StackAlign) {\n    EVT IntermediateVT;\n    MVT RegisterVT;\n    unsigned NumIntermediates;\n    TLI->getVectorTypeBreakdown(*getContext(), VT, IntermediateVT,\n                                NumIntermediates, RegisterVT);\n    Ty = IntermediateVT.getTypeForEVT(*getContext());\n    Align RedAlign2 = UseABI ? DL.getABITypeAlign(Ty) : DL.getPrefTypeAlign(Ty);\n    if (RedAlign2 < RedAlign)\n      RedAlign = RedAlign2;\n  }\n\n  return RedAlign;\n}\n\nSDValue SelectionDAG::CreateStackTemporary(TypeSize Bytes, Align Alignment) {\n  MachineFrameInfo &MFI = MF->getFrameInfo();\n  const TargetFrameLowering *TFI = MF->getSubtarget().getFrameLowering();\n  int StackID = 0;\n  if (Bytes.isScalable())\n    StackID = TFI->getStackIDForScalableVectors();\n  // The stack id gives an indication of whether the object is scalable or\n  // not, so it's safe to pass in the minimum size here.\n  int FrameIdx = MFI.CreateStackObject(Bytes.getKnownMinSize(), Alignment,\n                                       false, nullptr, StackID);\n  return getFrameIndex(FrameIdx, TLI->getFrameIndexTy(getDataLayout()));\n}\n\nSDValue SelectionDAG::CreateStackTemporary(EVT VT, unsigned minAlign) {\n  Type *Ty = VT.getTypeForEVT(*getContext());\n  Align StackAlign =\n      std::max(getDataLayout().getPrefTypeAlign(Ty), Align(minAlign));\n  return CreateStackTemporary(VT.getStoreSize(), StackAlign);\n}\n\nSDValue SelectionDAG::CreateStackTemporary(EVT VT1, EVT VT2) {\n  TypeSize VT1Size = VT1.getStoreSize();\n  TypeSize VT2Size = VT2.getStoreSize();\n  assert(VT1Size.isScalable() == VT2Size.isScalable() &&\n         \"Don't know how to choose the maximum size when creating a stack \"\n         \"temporary\");\n  TypeSize Bytes =\n      VT1Size.getKnownMinSize() > VT2Size.getKnownMinSize() ? VT1Size : VT2Size;\n\n  Type *Ty1 = VT1.getTypeForEVT(*getContext());\n  Type *Ty2 = VT2.getTypeForEVT(*getContext());\n  const DataLayout &DL = getDataLayout();\n  Align Align = std::max(DL.getPrefTypeAlign(Ty1), DL.getPrefTypeAlign(Ty2));\n  return CreateStackTemporary(Bytes, Align);\n}\n\nSDValue SelectionDAG::FoldSetCC(EVT VT, SDValue N1, SDValue N2,\n                                ISD::CondCode Cond, const SDLoc &dl) {\n  EVT OpVT = N1.getValueType();\n\n  // These setcc operations always fold.\n  switch (Cond) {\n  default: break;\n  case ISD::SETFALSE:\n  case ISD::SETFALSE2: return getBoolConstant(false, dl, VT, OpVT);\n  case ISD::SETTRUE:\n  case ISD::SETTRUE2: return getBoolConstant(true, dl, VT, OpVT);\n\n  case ISD::SETOEQ:\n  case ISD::SETOGT:\n  case ISD::SETOGE:\n  case ISD::SETOLT:\n  case ISD::SETOLE:\n  case ISD::SETONE:\n  case ISD::SETO:\n  case ISD::SETUO:\n  case ISD::SETUEQ:\n  case ISD::SETUNE:\n    assert(!OpVT.isInteger() && \"Illegal setcc for integer!\");\n    break;\n  }\n\n  if (OpVT.isInteger()) {\n    // For EQ and NE, we can always pick a value for the undef to make the\n    // predicate pass or fail, so we can return undef.\n    // Matches behavior in llvm::ConstantFoldCompareInstruction.\n    // icmp eq/ne X, undef -> undef.\n    if ((N1.isUndef() || N2.isUndef()) &&\n        (Cond == ISD::SETEQ || Cond == ISD::SETNE))\n      return getUNDEF(VT);\n\n    // If both operands are undef, we can return undef for int comparison.\n    // icmp undef, undef -> undef.\n    if (N1.isUndef() && N2.isUndef())\n      return getUNDEF(VT);\n\n    // icmp X, X -> true/false\n    // icmp X, undef -> true/false because undef could be X.\n    if (N1 == N2)\n      return getBoolConstant(ISD::isTrueWhenEqual(Cond), dl, VT, OpVT);\n  }\n\n  if (ConstantSDNode *N2C = dyn_cast<ConstantSDNode>(N2)) {\n    const APInt &C2 = N2C->getAPIntValue();\n    if (ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1)) {\n      const APInt &C1 = N1C->getAPIntValue();\n\n      switch (Cond) {\n      default: llvm_unreachable(\"Unknown integer setcc!\");\n      case ISD::SETEQ:  return getBoolConstant(C1 == C2, dl, VT, OpVT);\n      case ISD::SETNE:  return getBoolConstant(C1 != C2, dl, VT, OpVT);\n      case ISD::SETULT: return getBoolConstant(C1.ult(C2), dl, VT, OpVT);\n      case ISD::SETUGT: return getBoolConstant(C1.ugt(C2), dl, VT, OpVT);\n      case ISD::SETULE: return getBoolConstant(C1.ule(C2), dl, VT, OpVT);\n      case ISD::SETUGE: return getBoolConstant(C1.uge(C2), dl, VT, OpVT);\n      case ISD::SETLT:  return getBoolConstant(C1.slt(C2), dl, VT, OpVT);\n      case ISD::SETGT:  return getBoolConstant(C1.sgt(C2), dl, VT, OpVT);\n      case ISD::SETLE:  return getBoolConstant(C1.sle(C2), dl, VT, OpVT);\n      case ISD::SETGE:  return getBoolConstant(C1.sge(C2), dl, VT, OpVT);\n      }\n    }\n  }\n\n  auto *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n  auto *N2CFP = dyn_cast<ConstantFPSDNode>(N2);\n\n  if (N1CFP && N2CFP) {\n    APFloat::cmpResult R = N1CFP->getValueAPF().compare(N2CFP->getValueAPF());\n    switch (Cond) {\n    default: break;\n    case ISD::SETEQ:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOEQ: return getBoolConstant(R==APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETNE:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETONE: return getBoolConstant(R==APFloat::cmpGreaterThan ||\n                                             R==APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    case ISD::SETLT:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOLT: return getBoolConstant(R==APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    case ISD::SETGT:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOGT: return getBoolConstant(R==APFloat::cmpGreaterThan, dl,\n                                             VT, OpVT);\n    case ISD::SETLE:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOLE: return getBoolConstant(R==APFloat::cmpLessThan ||\n                                             R==APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETGE:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOGE: return getBoolConstant(R==APFloat::cmpGreaterThan ||\n                                         R==APFloat::cmpEqual, dl, VT, OpVT);\n    case ISD::SETO:   return getBoolConstant(R!=APFloat::cmpUnordered, dl, VT,\n                                             OpVT);\n    case ISD::SETUO:  return getBoolConstant(R==APFloat::cmpUnordered, dl, VT,\n                                             OpVT);\n    case ISD::SETUEQ: return getBoolConstant(R==APFloat::cmpUnordered ||\n                                             R==APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETUNE: return getBoolConstant(R!=APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETULT: return getBoolConstant(R==APFloat::cmpUnordered ||\n                                             R==APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    case ISD::SETUGT: return getBoolConstant(R==APFloat::cmpGreaterThan ||\n                                             R==APFloat::cmpUnordered, dl, VT,\n                                             OpVT);\n    case ISD::SETULE: return getBoolConstant(R!=APFloat::cmpGreaterThan, dl,\n                                             VT, OpVT);\n    case ISD::SETUGE: return getBoolConstant(R!=APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    }\n  } else if (N1CFP && OpVT.isSimple() && !N2.isUndef()) {\n    // Ensure that the constant occurs on the RHS.\n    ISD::CondCode SwappedCond = ISD::getSetCCSwappedOperands(Cond);\n    if (!TLI->isCondCodeLegal(SwappedCond, OpVT.getSimpleVT()))\n      return SDValue();\n    return getSetCC(dl, VT, N2, N1, SwappedCond);\n  } else if ((N2CFP && N2CFP->getValueAPF().isNaN()) ||\n             (OpVT.isFloatingPoint() && (N1.isUndef() || N2.isUndef()))) {\n    // If an operand is known to be a nan (or undef that could be a nan), we can\n    // fold it.\n    // Choosing NaN for the undef will always make unordered comparison succeed\n    // and ordered comparison fails.\n    // Matches behavior in llvm::ConstantFoldCompareInstruction.\n    switch (ISD::getUnorderedFlavor(Cond)) {\n    default:\n      llvm_unreachable(\"Unknown flavor!\");\n    case 0: // Known false.\n      return getBoolConstant(false, dl, VT, OpVT);\n    case 1: // Known true.\n      return getBoolConstant(true, dl, VT, OpVT);\n    case 2: // Undefined.\n      return getUNDEF(VT);\n    }\n  }\n\n  // Could not fold it.\n  return SDValue();\n}\n\n/// See if the specified operand can be simplified with the knowledge that only\n/// the bits specified by DemandedBits are used.\n/// TODO: really we should be making this into the DAG equivalent of\n/// SimplifyMultipleUseDemandedBits and not generate any new nodes.\nSDValue SelectionDAG::GetDemandedBits(SDValue V, const APInt &DemandedBits) {\n  EVT VT = V.getValueType();\n\n  if (VT.isScalableVector())\n    return SDValue();\n\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return GetDemandedBits(V, DemandedBits, DemandedElts);\n}\n\n/// See if the specified operand can be simplified with the knowledge that only\n/// the bits specified by DemandedBits are used in the elements specified by\n/// DemandedElts.\n/// TODO: really we should be making this into the DAG equivalent of\n/// SimplifyMultipleUseDemandedBits and not generate any new nodes.\nSDValue SelectionDAG::GetDemandedBits(SDValue V, const APInt &DemandedBits,\n                                      const APInt &DemandedElts) {\n  switch (V.getOpcode()) {\n  default:\n    return TLI->SimplifyMultipleUseDemandedBits(V, DemandedBits, DemandedElts,\n                                                *this, 0);\n  case ISD::Constant: {\n    const APInt &CVal = cast<ConstantSDNode>(V)->getAPIntValue();\n    APInt NewVal = CVal & DemandedBits;\n    if (NewVal != CVal)\n      return getConstant(NewVal, SDLoc(V), V.getValueType());\n    break;\n  }\n  case ISD::SRL:\n    // Only look at single-use SRLs.\n    if (!V.getNode()->hasOneUse())\n      break;\n    if (auto *RHSC = dyn_cast<ConstantSDNode>(V.getOperand(1))) {\n      // See if we can recursively simplify the LHS.\n      unsigned Amt = RHSC->getZExtValue();\n\n      // Watch out for shift count overflow though.\n      if (Amt >= DemandedBits.getBitWidth())\n        break;\n      APInt SrcDemandedBits = DemandedBits << Amt;\n      if (SDValue SimplifyLHS =\n              GetDemandedBits(V.getOperand(0), SrcDemandedBits))\n        return getNode(ISD::SRL, SDLoc(V), V.getValueType(), SimplifyLHS,\n                       V.getOperand(1));\n    }\n    break;\n  }\n  return SDValue();\n}\n\n/// SignBitIsZero - Return true if the sign bit of Op is known to be zero.  We\n/// use this predicate to simplify operations downstream.\nbool SelectionDAG::SignBitIsZero(SDValue Op, unsigned Depth) const {\n  unsigned BitWidth = Op.getScalarValueSizeInBits();\n  return MaskedValueIsZero(Op, APInt::getSignMask(BitWidth), Depth);\n}\n\n/// MaskedValueIsZero - Return true if 'V & Mask' is known to be zero.  We use\n/// this predicate to simplify operations downstream.  Mask is known to be zero\n/// for bits that V cannot have.\nbool SelectionDAG::MaskedValueIsZero(SDValue V, const APInt &Mask,\n                                     unsigned Depth) const {\n  return Mask.isSubsetOf(computeKnownBits(V, Depth).Zero);\n}\n\n/// MaskedValueIsZero - Return true if 'V & Mask' is known to be zero in\n/// DemandedElts.  We use this predicate to simplify operations downstream.\n/// Mask is known to be zero for bits that V cannot have.\nbool SelectionDAG::MaskedValueIsZero(SDValue V, const APInt &Mask,\n                                     const APInt &DemandedElts,\n                                     unsigned Depth) const {\n  return Mask.isSubsetOf(computeKnownBits(V, DemandedElts, Depth).Zero);\n}\n\n/// MaskedValueIsAllOnes - Return true if '(Op & Mask) == Mask'.\nbool SelectionDAG::MaskedValueIsAllOnes(SDValue V, const APInt &Mask,\n                                        unsigned Depth) const {\n  return Mask.isSubsetOf(computeKnownBits(V, Depth).One);\n}\n\n/// isSplatValue - Return true if the vector V has the same value\n/// across all DemandedElts. For scalable vectors it does not make\n/// sense to specify which elements are demanded or undefined, therefore\n/// they are simply ignored.\nbool SelectionDAG::isSplatValue(SDValue V, const APInt &DemandedElts,\n                                APInt &UndefElts, unsigned Depth) {\n  EVT VT = V.getValueType();\n  assert(VT.isVector() && \"Vector type expected\");\n\n  if (!VT.isScalableVector() && !DemandedElts)\n    return false; // No demanded elts, better to assume we don't know anything.\n\n  if (Depth >= MaxRecursionDepth)\n    return false; // Limit search depth.\n\n  // Deal with some common cases here that work for both fixed and scalable\n  // vector types.\n  switch (V.getOpcode()) {\n  case ISD::SPLAT_VECTOR:\n    UndefElts = V.getOperand(0).isUndef()\n                    ? APInt::getAllOnesValue(DemandedElts.getBitWidth())\n                    : APInt(DemandedElts.getBitWidth(), 0);\n    return true;\n  case ISD::ADD:\n  case ISD::SUB:\n  case ISD::AND: \n  case ISD::XOR:\n  case ISD::OR: {\n    APInt UndefLHS, UndefRHS;\n    SDValue LHS = V.getOperand(0);\n    SDValue RHS = V.getOperand(1);\n    if (isSplatValue(LHS, DemandedElts, UndefLHS, Depth + 1) &&\n        isSplatValue(RHS, DemandedElts, UndefRHS, Depth + 1)) {\n      UndefElts = UndefLHS | UndefRHS;\n      return true;\n    }\n    break;\n  }\n  case ISD::TRUNCATE:\n  case ISD::SIGN_EXTEND:\n  case ISD::ZERO_EXTEND:\n    return isSplatValue(V.getOperand(0), DemandedElts, UndefElts, Depth + 1);\n  }\n\n  // We don't support other cases than those above for scalable vectors at\n  // the moment.\n  if (VT.isScalableVector())\n    return false;\n\n  unsigned NumElts = VT.getVectorNumElements();\n  assert(NumElts == DemandedElts.getBitWidth() && \"Vector size mismatch\");\n  UndefElts = APInt::getNullValue(NumElts);\n\n  switch (V.getOpcode()) {\n  case ISD::BUILD_VECTOR: {\n    SDValue Scl;\n    for (unsigned i = 0; i != NumElts; ++i) {\n      SDValue Op = V.getOperand(i);\n      if (Op.isUndef()) {\n        UndefElts.setBit(i);\n        continue;\n      }\n      if (!DemandedElts[i])\n        continue;\n      if (Scl && Scl != Op)\n        return false;\n      Scl = Op;\n    }\n    return true;\n  }\n  case ISD::VECTOR_SHUFFLE: {\n    // Check if this is a shuffle node doing a splat.\n    // TODO: Do we need to handle shuffle(splat, undef, mask)?\n    int SplatIndex = -1;\n    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(V)->getMask();\n    for (int i = 0; i != (int)NumElts; ++i) {\n      int M = Mask[i];\n      if (M < 0) {\n        UndefElts.setBit(i);\n        continue;\n      }\n      if (!DemandedElts[i])\n        continue;\n      if (0 <= SplatIndex && SplatIndex != M)\n        return false;\n      SplatIndex = M;\n    }\n    return true;\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = V.getOperand(0);\n    uint64_t Idx = V.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt UndefSrcElts;\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n    if (isSplatValue(Src, DemandedSrcElts, UndefSrcElts, Depth + 1)) {\n      UndefElts = UndefSrcElts.extractBits(NumElts, Idx);\n      return true;\n    }\n    break;\n  }\n  }\n\n  return false;\n}\n\n/// Helper wrapper to main isSplatValue function.\nbool SelectionDAG::isSplatValue(SDValue V, bool AllowUndefs) {\n  EVT VT = V.getValueType();\n  assert(VT.isVector() && \"Vector type expected\");\n\n  APInt UndefElts;\n  APInt DemandedElts;\n\n  // For now we don't support this with scalable vectors.\n  if (!VT.isScalableVector())\n    DemandedElts = APInt::getAllOnesValue(VT.getVectorNumElements());\n  return isSplatValue(V, DemandedElts, UndefElts) &&\n         (AllowUndefs || !UndefElts);\n}\n\nSDValue SelectionDAG::getSplatSourceVector(SDValue V, int &SplatIdx) {\n  V = peekThroughExtractSubvectors(V);\n\n  EVT VT = V.getValueType();\n  unsigned Opcode = V.getOpcode();\n  switch (Opcode) {\n  default: {\n    APInt UndefElts;\n    APInt DemandedElts;\n\n    if (!VT.isScalableVector())\n      DemandedElts = APInt::getAllOnesValue(VT.getVectorNumElements());\n\n    if (isSplatValue(V, DemandedElts, UndefElts)) {\n      if (VT.isScalableVector()) {\n        // DemandedElts and UndefElts are ignored for scalable vectors, since\n        // the only supported cases are SPLAT_VECTOR nodes.\n        SplatIdx = 0;\n      } else {\n        // Handle case where all demanded elements are UNDEF.\n        if (DemandedElts.isSubsetOf(UndefElts)) {\n          SplatIdx = 0;\n          return getUNDEF(VT);\n        }\n        SplatIdx = (UndefElts & DemandedElts).countTrailingOnes();\n      }\n      return V;\n    }\n    break;\n  }\n  case ISD::SPLAT_VECTOR:\n    SplatIdx = 0;\n    return V;\n  case ISD::VECTOR_SHUFFLE: {\n    if (VT.isScalableVector())\n      return SDValue();\n\n    // Check if this is a shuffle node doing a splat.\n    // TODO - remove this and rely purely on SelectionDAG::isSplatValue,\n    // getTargetVShiftNode currently struggles without the splat source.\n    auto *SVN = cast<ShuffleVectorSDNode>(V);\n    if (!SVN->isSplat())\n      break;\n    int Idx = SVN->getSplatIndex();\n    int NumElts = V.getValueType().getVectorNumElements();\n    SplatIdx = Idx % NumElts;\n    return V.getOperand(Idx / NumElts);\n  }\n  }\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::getSplatValue(SDValue V) {\n  int SplatIdx;\n  if (SDValue SrcVector = getSplatSourceVector(V, SplatIdx))\n    return getNode(ISD::EXTRACT_VECTOR_ELT, SDLoc(V),\n                   SrcVector.getValueType().getScalarType(), SrcVector,\n                   getVectorIdxConstant(SplatIdx, SDLoc(V)));\n  return SDValue();\n}\n\nconst APInt *\nSelectionDAG::getValidShiftAmountConstant(SDValue V,\n                                          const APInt &DemandedElts) const {\n  assert((V.getOpcode() == ISD::SHL || V.getOpcode() == ISD::SRL ||\n          V.getOpcode() == ISD::SRA) &&\n         \"Unknown shift node\");\n  unsigned BitWidth = V.getScalarValueSizeInBits();\n  if (ConstantSDNode *SA = isConstOrConstSplat(V.getOperand(1), DemandedElts)) {\n    // Shifting more than the bitwidth is not valid.\n    const APInt &ShAmt = SA->getAPIntValue();\n    if (ShAmt.ult(BitWidth))\n      return &ShAmt;\n  }\n  return nullptr;\n}\n\nconst APInt *SelectionDAG::getValidMinimumShiftAmountConstant(\n    SDValue V, const APInt &DemandedElts) const {\n  assert((V.getOpcode() == ISD::SHL || V.getOpcode() == ISD::SRL ||\n          V.getOpcode() == ISD::SRA) &&\n         \"Unknown shift node\");\n  if (const APInt *ValidAmt = getValidShiftAmountConstant(V, DemandedElts))\n    return ValidAmt;\n  unsigned BitWidth = V.getScalarValueSizeInBits();\n  auto *BV = dyn_cast<BuildVectorSDNode>(V.getOperand(1));\n  if (!BV)\n    return nullptr;\n  const APInt *MinShAmt = nullptr;\n  for (unsigned i = 0, e = BV->getNumOperands(); i != e; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    auto *SA = dyn_cast<ConstantSDNode>(BV->getOperand(i));\n    if (!SA)\n      return nullptr;\n    // Shifting more than the bitwidth is not valid.\n    const APInt &ShAmt = SA->getAPIntValue();\n    if (ShAmt.uge(BitWidth))\n      return nullptr;\n    if (MinShAmt && MinShAmt->ule(ShAmt))\n      continue;\n    MinShAmt = &ShAmt;\n  }\n  return MinShAmt;\n}\n\nconst APInt *SelectionDAG::getValidMaximumShiftAmountConstant(\n    SDValue V, const APInt &DemandedElts) const {\n  assert((V.getOpcode() == ISD::SHL || V.getOpcode() == ISD::SRL ||\n          V.getOpcode() == ISD::SRA) &&\n         \"Unknown shift node\");\n  if (const APInt *ValidAmt = getValidShiftAmountConstant(V, DemandedElts))\n    return ValidAmt;\n  unsigned BitWidth = V.getScalarValueSizeInBits();\n  auto *BV = dyn_cast<BuildVectorSDNode>(V.getOperand(1));\n  if (!BV)\n    return nullptr;\n  const APInt *MaxShAmt = nullptr;\n  for (unsigned i = 0, e = BV->getNumOperands(); i != e; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    auto *SA = dyn_cast<ConstantSDNode>(BV->getOperand(i));\n    if (!SA)\n      return nullptr;\n    // Shifting more than the bitwidth is not valid.\n    const APInt &ShAmt = SA->getAPIntValue();\n    if (ShAmt.uge(BitWidth))\n      return nullptr;\n    if (MaxShAmt && MaxShAmt->uge(ShAmt))\n      continue;\n    MaxShAmt = &ShAmt;\n  }\n  return MaxShAmt;\n}\n\n/// Determine which bits of Op are known to be either zero or one and return\n/// them in Known. For vectors, the known bits are those that are shared by\n/// every vector element.\nKnownBits SelectionDAG::computeKnownBits(SDValue Op, unsigned Depth) const {\n  EVT VT = Op.getValueType();\n\n  // TOOD: Until we have a plan for how to represent demanded elements for\n  // scalable vectors, we can just bail out for now.\n  if (Op.getValueType().isScalableVector()) {\n    unsigned BitWidth = Op.getScalarValueSizeInBits();\n    return KnownBits(BitWidth);\n  }\n\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return computeKnownBits(Op, DemandedElts, Depth);\n}\n\n/// Determine which bits of Op are known to be either zero or one and return\n/// them in Known. The DemandedElts argument allows us to only collect the known\n/// bits that are shared by the requested vector elements.\nKnownBits SelectionDAG::computeKnownBits(SDValue Op, const APInt &DemandedElts,\n                                         unsigned Depth) const {\n  unsigned BitWidth = Op.getScalarValueSizeInBits();\n\n  KnownBits Known(BitWidth);   // Don't know anything.\n\n  // TOOD: Until we have a plan for how to represent demanded elements for\n  // scalable vectors, we can just bail out for now.\n  if (Op.getValueType().isScalableVector())\n    return Known;\n\n  if (auto *C = dyn_cast<ConstantSDNode>(Op)) {\n    // We know all of the bits for a constant!\n    return KnownBits::makeConstant(C->getAPIntValue());\n  }\n  if (auto *C = dyn_cast<ConstantFPSDNode>(Op)) {\n    // We know all of the bits for a constant fp!\n    return KnownBits::makeConstant(C->getValueAPF().bitcastToAPInt());\n  }\n\n  if (Depth >= MaxRecursionDepth)\n    return Known;  // Limit search depth.\n\n  KnownBits Known2;\n  unsigned NumElts = DemandedElts.getBitWidth();\n  assert((!Op.getValueType().isVector() ||\n          NumElts == Op.getValueType().getVectorNumElements()) &&\n         \"Unexpected vector size\");\n\n  if (!DemandedElts)\n    return Known;  // No demanded elts, better to assume we don't know anything.\n\n  unsigned Opcode = Op.getOpcode();\n  switch (Opcode) {\n  case ISD::BUILD_VECTOR:\n    // Collect the known bits that are shared by every demanded vector element.\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    for (unsigned i = 0, e = Op.getNumOperands(); i != e; ++i) {\n      if (!DemandedElts[i])\n        continue;\n\n      SDValue SrcOp = Op.getOperand(i);\n      Known2 = computeKnownBits(SrcOp, Depth + 1);\n\n      // BUILD_VECTOR can implicitly truncate sources, we must handle this.\n      if (SrcOp.getValueSizeInBits() != BitWidth) {\n        assert(SrcOp.getValueSizeInBits() > BitWidth &&\n               \"Expected BUILD_VECTOR implicit truncation\");\n        Known2 = Known2.trunc(BitWidth);\n      }\n\n      // Known bits are the values that are shared by every demanded element.\n      Known = KnownBits::commonBits(Known, Known2);\n\n      // If we don't know any bits, early out.\n      if (Known.isUnknown())\n        break;\n    }\n    break;\n  case ISD::VECTOR_SHUFFLE: {\n    // Collect the known bits that are shared by every vector element referenced\n    // by the shuffle.\n    APInt DemandedLHS(NumElts, 0), DemandedRHS(NumElts, 0);\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    const ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(Op);\n    assert(NumElts == SVN->getMask().size() && \"Unexpected vector size\");\n    for (unsigned i = 0; i != NumElts; ++i) {\n      if (!DemandedElts[i])\n        continue;\n\n      int M = SVN->getMaskElt(i);\n      if (M < 0) {\n        // For UNDEF elements, we don't know anything about the common state of\n        // the shuffle result.\n        Known.resetAll();\n        DemandedLHS.clearAllBits();\n        DemandedRHS.clearAllBits();\n        break;\n      }\n\n      if ((unsigned)M < NumElts)\n        DemandedLHS.setBit((unsigned)M % NumElts);\n      else\n        DemandedRHS.setBit((unsigned)M % NumElts);\n    }\n    // Known bits are the values that are shared by every demanded element.\n    if (!!DemandedLHS) {\n      SDValue LHS = Op.getOperand(0);\n      Known2 = computeKnownBits(LHS, DemandedLHS, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    // If we don't know any bits, early out.\n    if (Known.isUnknown())\n      break;\n    if (!!DemandedRHS) {\n      SDValue RHS = Op.getOperand(1);\n      Known2 = computeKnownBits(RHS, DemandedRHS, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    // Split DemandedElts and test each of the demanded subvectors.\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    EVT SubVectorVT = Op.getOperand(0).getValueType();\n    unsigned NumSubVectorElts = SubVectorVT.getVectorNumElements();\n    unsigned NumSubVectors = Op.getNumOperands();\n    for (unsigned i = 0; i != NumSubVectors; ++i) {\n      APInt DemandedSub = DemandedElts.lshr(i * NumSubVectorElts);\n      DemandedSub = DemandedSub.trunc(NumSubVectorElts);\n      if (!!DemandedSub) {\n        SDValue Sub = Op.getOperand(i);\n        Known2 = computeKnownBits(Sub, DemandedSub, Depth + 1);\n        Known = KnownBits::commonBits(Known, Known2);\n      }\n      // If we don't know any bits, early out.\n      if (Known.isUnknown())\n        break;\n    }\n    break;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Demand any elements from the subvector and the remainder from the src its\n    // inserted into.\n    SDValue Src = Op.getOperand(0);\n    SDValue Sub = Op.getOperand(1);\n    uint64_t Idx = Op.getConstantOperandVal(2);\n    unsigned NumSubElts = Sub.getValueType().getVectorNumElements();\n    APInt DemandedSubElts = DemandedElts.extractBits(NumSubElts, Idx);\n    APInt DemandedSrcElts = DemandedElts;\n    DemandedSrcElts.insertBits(APInt::getNullValue(NumSubElts), Idx);\n\n    Known.One.setAllBits();\n    Known.Zero.setAllBits();\n    if (!!DemandedSubElts) {\n      Known = computeKnownBits(Sub, DemandedSubElts, Depth + 1);\n      if (Known.isUnknown())\n        break; // early-out.\n    }\n    if (!!DemandedSrcElts) {\n      Known2 = computeKnownBits(Src, DemandedSrcElts, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = Op.getOperand(0);\n    // Bail until we can represent demanded elements for scalable vectors.\n    if (Src.getValueType().isScalableVector())\n      break;\n    uint64_t Idx = Op.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n    Known = computeKnownBits(Src, DemandedSrcElts, Depth + 1);\n    break;\n  }\n  case ISD::SCALAR_TO_VECTOR: {\n    // We know about scalar_to_vector as much as we know about it source,\n    // which becomes the first element of otherwise unknown vector.\n    if (DemandedElts != 1)\n      break;\n\n    SDValue N0 = Op.getOperand(0);\n    Known = computeKnownBits(N0, Depth + 1);\n    if (N0.getValueSizeInBits() != BitWidth)\n      Known = Known.trunc(BitWidth);\n\n    break;\n  }\n  case ISD::BITCAST: {\n    SDValue N0 = Op.getOperand(0);\n    EVT SubVT = N0.getValueType();\n    unsigned SubBitWidth = SubVT.getScalarSizeInBits();\n\n    // Ignore bitcasts from unsupported types.\n    if (!(SubVT.isInteger() || SubVT.isFloatingPoint()))\n      break;\n\n    // Fast handling of 'identity' bitcasts.\n    if (BitWidth == SubBitWidth) {\n      Known = computeKnownBits(N0, DemandedElts, Depth + 1);\n      break;\n    }\n\n    bool IsLE = getDataLayout().isLittleEndian();\n\n    // Bitcast 'small element' vector to 'large element' scalar/vector.\n    if ((BitWidth % SubBitWidth) == 0) {\n      assert(N0.getValueType().isVector() && \"Expected bitcast from vector\");\n\n      // Collect known bits for the (larger) output by collecting the known\n      // bits from each set of sub elements and shift these into place.\n      // We need to separately call computeKnownBits for each set of\n      // sub elements as the knownbits for each is likely to be different.\n      unsigned SubScale = BitWidth / SubBitWidth;\n      APInt SubDemandedElts(NumElts * SubScale, 0);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SubDemandedElts.setBit(i * SubScale);\n\n      for (unsigned i = 0; i != SubScale; ++i) {\n        Known2 = computeKnownBits(N0, SubDemandedElts.shl(i),\n                         Depth + 1);\n        unsigned Shifts = IsLE ? i : SubScale - 1 - i;\n        Known.One |= Known2.One.zext(BitWidth).shl(SubBitWidth * Shifts);\n        Known.Zero |= Known2.Zero.zext(BitWidth).shl(SubBitWidth * Shifts);\n      }\n    }\n\n    // Bitcast 'large element' scalar/vector to 'small element' vector.\n    if ((SubBitWidth % BitWidth) == 0) {\n      assert(Op.getValueType().isVector() && \"Expected bitcast to vector\");\n\n      // Collect known bits for the (smaller) output by collecting the known\n      // bits from the overlapping larger input elements and extracting the\n      // sub sections we actually care about.\n      unsigned SubScale = SubBitWidth / BitWidth;\n      APInt SubDemandedElts(NumElts / SubScale, 0);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SubDemandedElts.setBit(i / SubScale);\n\n      Known2 = computeKnownBits(N0, SubDemandedElts, Depth + 1);\n\n      Known.Zero.setAllBits(); Known.One.setAllBits();\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i]) {\n          unsigned Shifts = IsLE ? i : NumElts - 1 - i;\n          unsigned Offset = (Shifts % SubScale) * BitWidth;\n          Known.One &= Known2.One.lshr(Offset).trunc(BitWidth);\n          Known.Zero &= Known2.Zero.lshr(Offset).trunc(BitWidth);\n          // If we don't know any bits, early out.\n          if (Known.isUnknown())\n            break;\n        }\n    }\n    break;\n  }\n  case ISD::AND:\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    Known &= Known2;\n    break;\n  case ISD::OR:\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    Known |= Known2;\n    break;\n  case ISD::XOR:\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    Known ^= Known2;\n    break;\n  case ISD::MUL: {\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = KnownBits::computeForMul(Known, Known2);\n    break;\n  }\n  case ISD::UDIV: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::udiv(Known, Known2);\n    break;\n  }\n  case ISD::SELECT:\n  case ISD::VSELECT:\n    Known = computeKnownBits(Op.getOperand(2), DemandedElts, Depth+1);\n    // If we don't know any bits, early out.\n    if (Known.isUnknown())\n      break;\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth+1);\n\n    // Only known if known in both the LHS and RHS.\n    Known = KnownBits::commonBits(Known, Known2);\n    break;\n  case ISD::SELECT_CC:\n    Known = computeKnownBits(Op.getOperand(3), DemandedElts, Depth+1);\n    // If we don't know any bits, early out.\n    if (Known.isUnknown())\n      break;\n    Known2 = computeKnownBits(Op.getOperand(2), DemandedElts, Depth+1);\n\n    // Only known if known in both the LHS and RHS.\n    Known = KnownBits::commonBits(Known, Known2);\n    break;\n  case ISD::SMULO:\n  case ISD::UMULO:\n  case ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS:\n    if (Op.getResNo() != 1)\n      break;\n    // The boolean result conforms to getBooleanContents.\n    // If we know the result of a setcc has the top bits zero, use this info.\n    // We know that we have an integer-based boolean since these operations\n    // are only available for integer.\n    if (TLI->getBooleanContents(Op.getValueType().isVector(), false) ==\n            TargetLowering::ZeroOrOneBooleanContent &&\n        BitWidth > 1)\n      Known.Zero.setBitsFrom(1);\n    break;\n  case ISD::SETCC:\n  case ISD::STRICT_FSETCC:\n  case ISD::STRICT_FSETCCS: {\n    unsigned OpNo = Op->isStrictFPOpcode() ? 1 : 0;\n    // If we know the result of a setcc has the top bits zero, use this info.\n    if (TLI->getBooleanContents(Op.getOperand(OpNo).getValueType()) ==\n            TargetLowering::ZeroOrOneBooleanContent &&\n        BitWidth > 1)\n      Known.Zero.setBitsFrom(1);\n    break;\n  }\n  case ISD::SHL:\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::shl(Known, Known2);\n\n    // Minimum shift low bits are known zero.\n    if (const APInt *ShMinAmt =\n            getValidMinimumShiftAmountConstant(Op, DemandedElts))\n      Known.Zero.setLowBits(ShMinAmt->getZExtValue());\n    break;\n  case ISD::SRL:\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::lshr(Known, Known2);\n\n    // Minimum shift high bits are known zero.\n    if (const APInt *ShMinAmt =\n            getValidMinimumShiftAmountConstant(Op, DemandedElts))\n      Known.Zero.setHighBits(ShMinAmt->getZExtValue());\n    break;\n  case ISD::SRA:\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::ashr(Known, Known2);\n    // TODO: Add minimum shift high known sign bits.\n    break;\n  case ISD::FSHL:\n  case ISD::FSHR:\n    if (ConstantSDNode *C = isConstOrConstSplat(Op.getOperand(2), DemandedElts)) {\n      unsigned Amt = C->getAPIntValue().urem(BitWidth);\n\n      // For fshl, 0-shift returns the 1st arg.\n      // For fshr, 0-shift returns the 2nd arg.\n      if (Amt == 0) {\n        Known = computeKnownBits(Op.getOperand(Opcode == ISD::FSHL ? 0 : 1),\n                                 DemandedElts, Depth + 1);\n        break;\n      }\n\n      // fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW)))\n      // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW))\n      Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n      Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n      if (Opcode == ISD::FSHL) {\n        Known.One <<= Amt;\n        Known.Zero <<= Amt;\n        Known2.One.lshrInPlace(BitWidth - Amt);\n        Known2.Zero.lshrInPlace(BitWidth - Amt);\n      } else {\n        Known.One <<= BitWidth - Amt;\n        Known.Zero <<= BitWidth - Amt;\n        Known2.One.lshrInPlace(Amt);\n        Known2.Zero.lshrInPlace(Amt);\n      }\n      Known.One |= Known2.One;\n      Known.Zero |= Known2.Zero;\n    }\n    break;\n  case ISD::SIGN_EXTEND_INREG: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    EVT EVT = cast<VTSDNode>(Op.getOperand(1))->getVT();\n    Known = Known.sextInReg(EVT.getScalarSizeInBits());\n    break;\n  }\n  case ISD::CTTZ:\n  case ISD::CTTZ_ZERO_UNDEF: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If we have a known 1, its position is our upper bound.\n    unsigned PossibleTZ = Known2.countMaxTrailingZeros();\n    unsigned LowBits = Log2_32(PossibleTZ) + 1;\n    Known.Zero.setBitsFrom(LowBits);\n    break;\n  }\n  case ISD::CTLZ:\n  case ISD::CTLZ_ZERO_UNDEF: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If we have a known 1, its position is our upper bound.\n    unsigned PossibleLZ = Known2.countMaxLeadingZeros();\n    unsigned LowBits = Log2_32(PossibleLZ) + 1;\n    Known.Zero.setBitsFrom(LowBits);\n    break;\n  }\n  case ISD::CTPOP: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If we know some of the bits are zero, they can't be one.\n    unsigned PossibleOnes = Known2.countMaxPopulation();\n    Known.Zero.setBitsFrom(Log2_32(PossibleOnes) + 1);\n    break;\n  }\n  case ISD::PARITY: {\n    // Parity returns 0 everywhere but the LSB.\n    Known.Zero.setBitsFrom(1);\n    break;\n  }\n  case ISD::LOAD: {\n    LoadSDNode *LD = cast<LoadSDNode>(Op);\n    const Constant *Cst = TLI->getTargetConstantFromLoad(LD);\n    if (ISD::isNON_EXTLoad(LD) && Cst) {\n      // Determine any common known bits from the loaded constant pool value.\n      Type *CstTy = Cst->getType();\n      if ((NumElts * BitWidth) == CstTy->getPrimitiveSizeInBits()) {\n        // If its a vector splat, then we can (quickly) reuse the scalar path.\n        // NOTE: We assume all elements match and none are UNDEF.\n        if (CstTy->isVectorTy()) {\n          if (const Constant *Splat = Cst->getSplatValue()) {\n            Cst = Splat;\n            CstTy = Cst->getType();\n          }\n        }\n        // TODO - do we need to handle different bitwidths?\n        if (CstTy->isVectorTy() && BitWidth == CstTy->getScalarSizeInBits()) {\n          // Iterate across all vector elements finding common known bits.\n          Known.One.setAllBits();\n          Known.Zero.setAllBits();\n          for (unsigned i = 0; i != NumElts; ++i) {\n            if (!DemandedElts[i])\n              continue;\n            if (Constant *Elt = Cst->getAggregateElement(i)) {\n              if (auto *CInt = dyn_cast<ConstantInt>(Elt)) {\n                const APInt &Value = CInt->getValue();\n                Known.One &= Value;\n                Known.Zero &= ~Value;\n                continue;\n              }\n              if (auto *CFP = dyn_cast<ConstantFP>(Elt)) {\n                APInt Value = CFP->getValueAPF().bitcastToAPInt();\n                Known.One &= Value;\n                Known.Zero &= ~Value;\n                continue;\n              }\n            }\n            Known.One.clearAllBits();\n            Known.Zero.clearAllBits();\n            break;\n          }\n        } else if (BitWidth == CstTy->getPrimitiveSizeInBits()) {\n          if (auto *CInt = dyn_cast<ConstantInt>(Cst)) {\n            Known = KnownBits::makeConstant(CInt->getValue());\n          } else if (auto *CFP = dyn_cast<ConstantFP>(Cst)) {\n            Known =\n                KnownBits::makeConstant(CFP->getValueAPF().bitcastToAPInt());\n          }\n        }\n      }\n    } else if (ISD::isZEXTLoad(Op.getNode()) && Op.getResNo() == 0) {\n      // If this is a ZEXTLoad and we are looking at the loaded value.\n      EVT VT = LD->getMemoryVT();\n      unsigned MemBits = VT.getScalarSizeInBits();\n      Known.Zero.setBitsFrom(MemBits);\n    } else if (const MDNode *Ranges = LD->getRanges()) {\n      if (LD->getExtensionType() == ISD::NON_EXTLOAD)\n        computeKnownBitsFromRangeMetadata(*Ranges, Known);\n    }\n    break;\n  }\n  case ISD::ZERO_EXTEND_VECTOR_INREG: {\n    EVT InVT = Op.getOperand(0).getValueType();\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InVT.getVectorNumElements());\n    Known = computeKnownBits(Op.getOperand(0), InDemandedElts, Depth + 1);\n    Known = Known.zext(BitWidth);\n    break;\n  }\n  case ISD::ZERO_EXTEND: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known.zext(BitWidth);\n    break;\n  }\n  case ISD::SIGN_EXTEND_VECTOR_INREG: {\n    EVT InVT = Op.getOperand(0).getValueType();\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InVT.getVectorNumElements());\n    Known = computeKnownBits(Op.getOperand(0), InDemandedElts, Depth + 1);\n    // If the sign bit is known to be zero or one, then sext will extend\n    // it to the top bits, else it will just zext.\n    Known = Known.sext(BitWidth);\n    break;\n  }\n  case ISD::SIGN_EXTEND: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If the sign bit is known to be zero or one, then sext will extend\n    // it to the top bits, else it will just zext.\n    Known = Known.sext(BitWidth);\n    break;\n  }\n  case ISD::ANY_EXTEND_VECTOR_INREG: {\n    EVT InVT = Op.getOperand(0).getValueType();\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InVT.getVectorNumElements());\n    Known = computeKnownBits(Op.getOperand(0), InDemandedElts, Depth + 1);\n    Known = Known.anyext(BitWidth);\n    break;\n  }\n  case ISD::ANY_EXTEND: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known.anyext(BitWidth);\n    break;\n  }\n  case ISD::TRUNCATE: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known.trunc(BitWidth);\n    break;\n  }\n  case ISD::AssertZext: {\n    EVT VT = cast<VTSDNode>(Op.getOperand(1))->getVT();\n    APInt InMask = APInt::getLowBitsSet(BitWidth, VT.getSizeInBits());\n    Known = computeKnownBits(Op.getOperand(0), Depth+1);\n    Known.Zero |= (~InMask);\n    Known.One  &= (~Known.Zero);\n    break;\n  }\n  case ISD::AssertAlign: {\n    unsigned LogOfAlign = Log2(cast<AssertAlignSDNode>(Op)->getAlign());\n    assert(LogOfAlign != 0);\n    // If a node is guaranteed to be aligned, set low zero bits accordingly as\n    // well as clearing one bits.\n    Known.Zero.setLowBits(LogOfAlign);\n    Known.One.clearLowBits(LogOfAlign);\n    break;\n  }\n  case ISD::FGETSIGN:\n    // All bits are zero except the low bit.\n    Known.Zero.setBitsFrom(1);\n    break;\n  case ISD::USUBO:\n  case ISD::SSUBO:\n    if (Op.getResNo() == 1) {\n      // If we know the result of a setcc has the top bits zero, use this info.\n      if (TLI->getBooleanContents(Op.getOperand(0).getValueType()) ==\n              TargetLowering::ZeroOrOneBooleanContent &&\n          BitWidth > 1)\n        Known.Zero.setBitsFrom(1);\n      break;\n    }\n    LLVM_FALLTHROUGH;\n  case ISD::SUB:\n  case ISD::SUBC: {\n    assert(Op.getResNo() == 0 &&\n           \"We only compute knownbits for the difference here.\");\n\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::computeForAddSub(/* Add */ false, /* NSW */ false,\n                                        Known, Known2);\n    break;\n  }\n  case ISD::UADDO:\n  case ISD::SADDO:\n  case ISD::ADDCARRY:\n    if (Op.getResNo() == 1) {\n      // If we know the result of a setcc has the top bits zero, use this info.\n      if (TLI->getBooleanContents(Op.getOperand(0).getValueType()) ==\n              TargetLowering::ZeroOrOneBooleanContent &&\n          BitWidth > 1)\n        Known.Zero.setBitsFrom(1);\n      break;\n    }\n    LLVM_FALLTHROUGH;\n  case ISD::ADD:\n  case ISD::ADDC:\n  case ISD::ADDE: {\n    assert(Op.getResNo() == 0 && \"We only compute knownbits for the sum here.\");\n\n    // With ADDE and ADDCARRY, a carry bit may be added in.\n    KnownBits Carry(1);\n    if (Opcode == ISD::ADDE)\n      // Can't track carry from glue, set carry to unknown.\n      Carry.resetAll();\n    else if (Opcode == ISD::ADDCARRY)\n      // TODO: Compute known bits for the carry operand. Not sure if it is worth\n      // the trouble (how often will we find a known carry bit). And I haven't\n      // tested this very much yet, but something like this might work:\n      //   Carry = computeKnownBits(Op.getOperand(2), DemandedElts, Depth + 1);\n      //   Carry = Carry.zextOrTrunc(1, false);\n      Carry.resetAll();\n    else\n      Carry.setAllZero();\n\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::computeForAddCarry(Known, Known2, Carry);\n    break;\n  }\n  case ISD::SREM: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::srem(Known, Known2);\n    break;\n  }\n  case ISD::UREM: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::urem(Known, Known2);\n    break;\n  }\n  case ISD::EXTRACT_ELEMENT: {\n    Known = computeKnownBits(Op.getOperand(0), Depth+1);\n    const unsigned Index = Op.getConstantOperandVal(1);\n    const unsigned EltBitWidth = Op.getValueSizeInBits();\n\n    // Remove low part of known bits mask\n    Known.Zero = Known.Zero.getHiBits(Known.getBitWidth() - Index * EltBitWidth);\n    Known.One = Known.One.getHiBits(Known.getBitWidth() - Index * EltBitWidth);\n\n    // Remove high part of known bit mask\n    Known = Known.trunc(EltBitWidth);\n    break;\n  }\n  case ISD::EXTRACT_VECTOR_ELT: {\n    SDValue InVec = Op.getOperand(0);\n    SDValue EltNo = Op.getOperand(1);\n    EVT VecVT = InVec.getValueType();\n    // computeKnownBits not yet implemented for scalable vectors.\n    if (VecVT.isScalableVector())\n      break;\n    const unsigned EltBitWidth = VecVT.getScalarSizeInBits();\n    const unsigned NumSrcElts = VecVT.getVectorNumElements();\n\n    // If BitWidth > EltBitWidth the value is anyext:ed. So we do not know\n    // anything about the extended bits.\n    if (BitWidth > EltBitWidth)\n      Known = Known.trunc(EltBitWidth);\n\n    // If we know the element index, just demand that vector element, else for\n    // an unknown element index, ignore DemandedElts and demand them all.\n    APInt DemandedSrcElts = APInt::getAllOnesValue(NumSrcElts);\n    auto *ConstEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (ConstEltNo && ConstEltNo->getAPIntValue().ult(NumSrcElts))\n      DemandedSrcElts =\n          APInt::getOneBitSet(NumSrcElts, ConstEltNo->getZExtValue());\n\n    Known = computeKnownBits(InVec, DemandedSrcElts, Depth + 1);\n    if (BitWidth > EltBitWidth)\n      Known = Known.anyext(BitWidth);\n    break;\n  }\n  case ISD::INSERT_VECTOR_ELT: {\n    // If we know the element index, split the demand between the\n    // source vector and the inserted element, otherwise assume we need\n    // the original demanded vector elements and the value.\n    SDValue InVec = Op.getOperand(0);\n    SDValue InVal = Op.getOperand(1);\n    SDValue EltNo = Op.getOperand(2);\n    bool DemandedVal = true;\n    APInt DemandedVecElts = DemandedElts;\n    auto *CEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (CEltNo && CEltNo->getAPIntValue().ult(NumElts)) {\n      unsigned EltIdx = CEltNo->getZExtValue();\n      DemandedVal = !!DemandedElts[EltIdx];\n      DemandedVecElts.clearBit(EltIdx);\n    }\n    Known.One.setAllBits();\n    Known.Zero.setAllBits();\n    if (DemandedVal) {\n      Known2 = computeKnownBits(InVal, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2.zextOrTrunc(BitWidth));\n    }\n    if (!!DemandedVecElts) {\n      Known2 = computeKnownBits(InVec, DemandedVecElts, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case ISD::BITREVERSE: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known2.reverseBits();\n    break;\n  }\n  case ISD::BSWAP: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known2.byteSwap();\n    break;\n  }\n  case ISD::ABS: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known2.abs();\n    break;\n  }\n  case ISD::USUBSAT: {\n    // The result of usubsat will never be larger than the LHS.\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known.Zero.setHighBits(Known2.countMinLeadingZeros());\n    break;\n  }\n  case ISD::UMIN: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::umin(Known, Known2);\n    break;\n  }\n  case ISD::UMAX: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::umax(Known, Known2);\n    break;\n  }\n  case ISD::SMIN:\n  case ISD::SMAX: {\n    // If we have a clamp pattern, we know that the number of sign bits will be\n    // the minimum of the clamp min/max range.\n    bool IsMax = (Opcode == ISD::SMAX);\n    ConstantSDNode *CstLow = nullptr, *CstHigh = nullptr;\n    if ((CstLow = isConstOrConstSplat(Op.getOperand(1), DemandedElts)))\n      if (Op.getOperand(0).getOpcode() == (IsMax ? ISD::SMIN : ISD::SMAX))\n        CstHigh =\n            isConstOrConstSplat(Op.getOperand(0).getOperand(1), DemandedElts);\n    if (CstLow && CstHigh) {\n      if (!IsMax)\n        std::swap(CstLow, CstHigh);\n\n      const APInt &ValueLow = CstLow->getAPIntValue();\n      const APInt &ValueHigh = CstHigh->getAPIntValue();\n      if (ValueLow.sle(ValueHigh)) {\n        unsigned LowSignBits = ValueLow.getNumSignBits();\n        unsigned HighSignBits = ValueHigh.getNumSignBits();\n        unsigned MinSignBits = std::min(LowSignBits, HighSignBits);\n        if (ValueLow.isNegative() && ValueHigh.isNegative()) {\n          Known.One.setHighBits(MinSignBits);\n          break;\n        }\n        if (ValueLow.isNonNegative() && ValueHigh.isNonNegative()) {\n          Known.Zero.setHighBits(MinSignBits);\n          break;\n        }\n      }\n    }\n\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    if (IsMax)\n      Known = KnownBits::smax(Known, Known2);\n    else\n      Known = KnownBits::smin(Known, Known2);\n    break;\n  }\n  case ISD::FrameIndex:\n  case ISD::TargetFrameIndex:\n    TLI->computeKnownBitsForFrameIndex(cast<FrameIndexSDNode>(Op)->getIndex(),\n                                       Known, getMachineFunction());\n    break;\n\n  default:\n    if (Opcode < ISD::BUILTIN_OP_END)\n      break;\n    LLVM_FALLTHROUGH;\n  case ISD::INTRINSIC_WO_CHAIN:\n  case ISD::INTRINSIC_W_CHAIN:\n  case ISD::INTRINSIC_VOID:\n    // Allow the target to implement this method for its nodes.\n    TLI->computeKnownBitsForTargetNode(Op, Known, DemandedElts, *this, Depth);\n    break;\n  }\n\n  assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n  return Known;\n}\n\nSelectionDAG::OverflowKind SelectionDAG::computeOverflowKind(SDValue N0,\n                                                             SDValue N1) const {\n  // X + 0 never overflow\n  if (isNullConstant(N1))\n    return OFK_Never;\n\n  KnownBits N1Known = computeKnownBits(N1);\n  if (N1Known.Zero.getBoolValue()) {\n    KnownBits N0Known = computeKnownBits(N0);\n\n    bool overflow;\n    (void)N0Known.getMaxValue().uadd_ov(N1Known.getMaxValue(), overflow);\n    if (!overflow)\n      return OFK_Never;\n  }\n\n  // mulhi + 1 never overflow\n  if (N0.getOpcode() == ISD::UMUL_LOHI && N0.getResNo() == 1 &&\n      (N1Known.getMaxValue() & 0x01) == N1Known.getMaxValue())\n    return OFK_Never;\n\n  if (N1.getOpcode() == ISD::UMUL_LOHI && N1.getResNo() == 1) {\n    KnownBits N0Known = computeKnownBits(N0);\n\n    if ((N0Known.getMaxValue() & 0x01) == N0Known.getMaxValue())\n      return OFK_Never;\n  }\n\n  return OFK_Sometime;\n}\n\nbool SelectionDAG::isKnownToBeAPowerOfTwo(SDValue Val) const {\n  EVT OpVT = Val.getValueType();\n  unsigned BitWidth = OpVT.getScalarSizeInBits();\n\n  // Is the constant a known power of 2?\n  if (ConstantSDNode *Const = dyn_cast<ConstantSDNode>(Val))\n    return Const->getAPIntValue().zextOrTrunc(BitWidth).isPowerOf2();\n\n  // A left-shift of a constant one will have exactly one bit set because\n  // shifting the bit off the end is undefined.\n  if (Val.getOpcode() == ISD::SHL) {\n    auto *C = isConstOrConstSplat(Val.getOperand(0));\n    if (C && C->getAPIntValue() == 1)\n      return true;\n  }\n\n  // Similarly, a logical right-shift of a constant sign-bit will have exactly\n  // one bit set.\n  if (Val.getOpcode() == ISD::SRL) {\n    auto *C = isConstOrConstSplat(Val.getOperand(0));\n    if (C && C->getAPIntValue().isSignMask())\n      return true;\n  }\n\n  // Are all operands of a build vector constant powers of two?\n  if (Val.getOpcode() == ISD::BUILD_VECTOR)\n    if (llvm::all_of(Val->ops(), [BitWidth](SDValue E) {\n          if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(E))\n            return C->getAPIntValue().zextOrTrunc(BitWidth).isPowerOf2();\n          return false;\n        }))\n      return true;\n\n  // More could be done here, though the above checks are enough\n  // to handle some common cases.\n\n  // Fall back to computeKnownBits to catch other known cases.\n  KnownBits Known = computeKnownBits(Val);\n  return (Known.countMaxPopulation() == 1) && (Known.countMinPopulation() == 1);\n}\n\nunsigned SelectionDAG::ComputeNumSignBits(SDValue Op, unsigned Depth) const {\n  EVT VT = Op.getValueType();\n\n  // TODO: Assume we don't know anything for now.\n  if (VT.isScalableVector())\n    return 1;\n\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return ComputeNumSignBits(Op, DemandedElts, Depth);\n}\n\nunsigned SelectionDAG::ComputeNumSignBits(SDValue Op, const APInt &DemandedElts,\n                                          unsigned Depth) const {\n  EVT VT = Op.getValueType();\n  assert((VT.isInteger() || VT.isFloatingPoint()) && \"Invalid VT!\");\n  unsigned VTBits = VT.getScalarSizeInBits();\n  unsigned NumElts = DemandedElts.getBitWidth();\n  unsigned Tmp, Tmp2;\n  unsigned FirstAnswer = 1;\n\n  if (auto *C = dyn_cast<ConstantSDNode>(Op)) {\n    const APInt &Val = C->getAPIntValue();\n    return Val.getNumSignBits();\n  }\n\n  if (Depth >= MaxRecursionDepth)\n    return 1;  // Limit search depth.\n\n  if (!DemandedElts || VT.isScalableVector())\n    return 1;  // No demanded elts, better to assume we don't know anything.\n\n  unsigned Opcode = Op.getOpcode();\n  switch (Opcode) {\n  default: break;\n  case ISD::AssertSext:\n    Tmp = cast<VTSDNode>(Op.getOperand(1))->getVT().getSizeInBits();\n    return VTBits-Tmp+1;\n  case ISD::AssertZext:\n    Tmp = cast<VTSDNode>(Op.getOperand(1))->getVT().getSizeInBits();\n    return VTBits-Tmp;\n\n  case ISD::BUILD_VECTOR:\n    Tmp = VTBits;\n    for (unsigned i = 0, e = Op.getNumOperands(); (i < e) && (Tmp > 1); ++i) {\n      if (!DemandedElts[i])\n        continue;\n\n      SDValue SrcOp = Op.getOperand(i);\n      Tmp2 = ComputeNumSignBits(SrcOp, Depth + 1);\n\n      // BUILD_VECTOR can implicitly truncate sources, we must handle this.\n      if (SrcOp.getValueSizeInBits() != VTBits) {\n        assert(SrcOp.getValueSizeInBits() > VTBits &&\n               \"Expected BUILD_VECTOR implicit truncation\");\n        unsigned ExtraBits = SrcOp.getValueSizeInBits() - VTBits;\n        Tmp2 = (Tmp2 > ExtraBits ? Tmp2 - ExtraBits : 1);\n      }\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    return Tmp;\n\n  case ISD::VECTOR_SHUFFLE: {\n    // Collect the minimum number of sign bits that are shared by every vector\n    // element referenced by the shuffle.\n    APInt DemandedLHS(NumElts, 0), DemandedRHS(NumElts, 0);\n    const ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(Op);\n    assert(NumElts == SVN->getMask().size() && \"Unexpected vector size\");\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int M = SVN->getMaskElt(i);\n      if (!DemandedElts[i])\n        continue;\n      // For UNDEF elements, we don't know anything about the common state of\n      // the shuffle result.\n      if (M < 0)\n        return 1;\n      if ((unsigned)M < NumElts)\n        DemandedLHS.setBit((unsigned)M % NumElts);\n      else\n        DemandedRHS.setBit((unsigned)M % NumElts);\n    }\n    Tmp = std::numeric_limits<unsigned>::max();\n    if (!!DemandedLHS)\n      Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedLHS, Depth + 1);\n    if (!!DemandedRHS) {\n      Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedRHS, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    // If we don't know anything, early out and try computeKnownBits fall-back.\n    if (Tmp == 1)\n      break;\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n\n  case ISD::BITCAST: {\n    SDValue N0 = Op.getOperand(0);\n    EVT SrcVT = N0.getValueType();\n    unsigned SrcBits = SrcVT.getScalarSizeInBits();\n\n    // Ignore bitcasts from unsupported types..\n    if (!(SrcVT.isInteger() || SrcVT.isFloatingPoint()))\n      break;\n\n    // Fast handling of 'identity' bitcasts.\n    if (VTBits == SrcBits)\n      return ComputeNumSignBits(N0, DemandedElts, Depth + 1);\n\n    bool IsLE = getDataLayout().isLittleEndian();\n\n    // Bitcast 'large element' scalar/vector to 'small element' vector.\n    if ((SrcBits % VTBits) == 0) {\n      assert(VT.isVector() && \"Expected bitcast to vector\");\n\n      unsigned Scale = SrcBits / VTBits;\n      APInt SrcDemandedElts(NumElts / Scale, 0);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SrcDemandedElts.setBit(i / Scale);\n\n      // Fast case - sign splat can be simply split across the small elements.\n      Tmp = ComputeNumSignBits(N0, SrcDemandedElts, Depth + 1);\n      if (Tmp == SrcBits)\n        return VTBits;\n\n      // Slow case - determine how far the sign extends into each sub-element.\n      Tmp2 = VTBits;\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i]) {\n          unsigned SubOffset = i % Scale;\n          SubOffset = (IsLE ? ((Scale - 1) - SubOffset) : SubOffset);\n          SubOffset = SubOffset * VTBits;\n          if (Tmp <= SubOffset)\n            return 1;\n          Tmp2 = std::min(Tmp2, Tmp - SubOffset);\n        }\n      return Tmp2;\n    }\n    break;\n  }\n\n  case ISD::SIGN_EXTEND:\n    Tmp = VTBits - Op.getOperand(0).getScalarValueSizeInBits();\n    return ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth+1) + Tmp;\n  case ISD::SIGN_EXTEND_INREG:\n    // Max of the input and what this extends.\n    Tmp = cast<VTSDNode>(Op.getOperand(1))->getVT().getScalarSizeInBits();\n    Tmp = VTBits-Tmp+1;\n    Tmp2 = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth+1);\n    return std::max(Tmp, Tmp2);\n  case ISD::SIGN_EXTEND_VECTOR_INREG: {\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(SrcVT.getVectorNumElements());\n    Tmp = VTBits - SrcVT.getScalarSizeInBits();\n    return ComputeNumSignBits(Src, DemandedSrcElts, Depth+1) + Tmp;\n  }\n  case ISD::SRA:\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // SRA X, C -> adds C sign bits.\n    if (const APInt *ShAmt =\n            getValidMinimumShiftAmountConstant(Op, DemandedElts))\n      Tmp = std::min<uint64_t>(Tmp + ShAmt->getZExtValue(), VTBits);\n    return Tmp;\n  case ISD::SHL:\n    if (const APInt *ShAmt =\n            getValidMaximumShiftAmountConstant(Op, DemandedElts)) {\n      // shl destroys sign bits, ensure it doesn't shift out all sign bits.\n      Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n      if (ShAmt->ult(Tmp))\n        return Tmp - ShAmt->getZExtValue();\n    }\n    break;\n  case ISD::AND:\n  case ISD::OR:\n  case ISD::XOR:    // NOT is handled here.\n    // Logical binary ops preserve the number of sign bits at the worst.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth+1);\n    if (Tmp != 1) {\n      Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth+1);\n      FirstAnswer = std::min(Tmp, Tmp2);\n      // We computed what we know about the sign bits as our first\n      // answer. Now proceed to the generic code that uses\n      // computeKnownBits, and pick whichever answer is better.\n    }\n    break;\n\n  case ISD::SELECT:\n  case ISD::VSELECT:\n    Tmp = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth+1);\n    if (Tmp == 1) return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(2), DemandedElts, Depth+1);\n    return std::min(Tmp, Tmp2);\n  case ISD::SELECT_CC:\n    Tmp = ComputeNumSignBits(Op.getOperand(2), DemandedElts, Depth+1);\n    if (Tmp == 1) return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(3), DemandedElts, Depth+1);\n    return std::min(Tmp, Tmp2);\n\n  case ISD::SMIN:\n  case ISD::SMAX: {\n    // If we have a clamp pattern, we know that the number of sign bits will be\n    // the minimum of the clamp min/max range.\n    bool IsMax = (Opcode == ISD::SMAX);\n    ConstantSDNode *CstLow = nullptr, *CstHigh = nullptr;\n    if ((CstLow = isConstOrConstSplat(Op.getOperand(1), DemandedElts)))\n      if (Op.getOperand(0).getOpcode() == (IsMax ? ISD::SMIN : ISD::SMAX))\n        CstHigh =\n            isConstOrConstSplat(Op.getOperand(0).getOperand(1), DemandedElts);\n    if (CstLow && CstHigh) {\n      if (!IsMax)\n        std::swap(CstLow, CstHigh);\n      if (CstLow->getAPIntValue().sle(CstHigh->getAPIntValue())) {\n        Tmp = CstLow->getAPIntValue().getNumSignBits();\n        Tmp2 = CstHigh->getAPIntValue().getNumSignBits();\n        return std::min(Tmp, Tmp2);\n      }\n    }\n\n    // Fallback - just get the minimum number of sign bits of the operands.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1)\n      return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    return std::min(Tmp, Tmp2);\n  }\n  case ISD::UMIN:\n  case ISD::UMAX:\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1)\n      return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    return std::min(Tmp, Tmp2);\n  case ISD::SADDO:\n  case ISD::UADDO:\n  case ISD::SSUBO:\n  case ISD::USUBO:\n  case ISD::SMULO:\n  case ISD::UMULO:\n    if (Op.getResNo() != 1)\n      break;\n    // The boolean result conforms to getBooleanContents.  Fall through.\n    // If setcc returns 0/-1, all bits are sign bits.\n    // We know that we have an integer-based boolean since these operations\n    // are only available for integer.\n    if (TLI->getBooleanContents(VT.isVector(), false) ==\n        TargetLowering::ZeroOrNegativeOneBooleanContent)\n      return VTBits;\n    break;\n  case ISD::SETCC:\n  case ISD::STRICT_FSETCC:\n  case ISD::STRICT_FSETCCS: {\n    unsigned OpNo = Op->isStrictFPOpcode() ? 1 : 0;\n    // If setcc returns 0/-1, all bits are sign bits.\n    if (TLI->getBooleanContents(Op.getOperand(OpNo).getValueType()) ==\n        TargetLowering::ZeroOrNegativeOneBooleanContent)\n      return VTBits;\n    break;\n  }\n  case ISD::ROTL:\n  case ISD::ROTR:\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    // If we're rotating an 0/-1 value, then it stays an 0/-1 value.\n    if (Tmp == VTBits)\n      return VTBits;\n\n    if (ConstantSDNode *C =\n            isConstOrConstSplat(Op.getOperand(1), DemandedElts)) {\n      unsigned RotAmt = C->getAPIntValue().urem(VTBits);\n\n      // Handle rotate right by N like a rotate left by 32-N.\n      if (Opcode == ISD::ROTR)\n        RotAmt = (VTBits - RotAmt) % VTBits;\n\n      // If we aren't rotating out all of the known-in sign bits, return the\n      // number that are left.  This handles rotl(sext(x), 1) for example.\n      if (Tmp > (RotAmt + 1)) return (Tmp - RotAmt);\n    }\n    break;\n  case ISD::ADD:\n  case ISD::ADDC:\n    // Add can have at most one carry bit.  Thus we know that the output\n    // is, at worst, one more bit than the inputs.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1) return 1; // Early out.\n\n    // Special case decrementing a value (ADD X, -1):\n    if (ConstantSDNode *CRHS =\n            isConstOrConstSplat(Op.getOperand(1), DemandedElts))\n      if (CRHS->isAllOnesValue()) {\n        KnownBits Known =\n            computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n        // If the input is known to be 0 or 1, the output is 0/-1, which is all\n        // sign bits set.\n        if ((Known.Zero | 1).isAllOnesValue())\n          return VTBits;\n\n        // If we are subtracting one from a positive number, there is no carry\n        // out of the result.\n        if (Known.isNonNegative())\n          return Tmp;\n      }\n\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    if (Tmp2 == 1) return 1; // Early out.\n    return std::min(Tmp, Tmp2) - 1;\n  case ISD::SUB:\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    if (Tmp2 == 1) return 1; // Early out.\n\n    // Handle NEG.\n    if (ConstantSDNode *CLHS =\n            isConstOrConstSplat(Op.getOperand(0), DemandedElts))\n      if (CLHS->isNullValue()) {\n        KnownBits Known =\n            computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n        // If the input is known to be 0 or 1, the output is 0/-1, which is all\n        // sign bits set.\n        if ((Known.Zero | 1).isAllOnesValue())\n          return VTBits;\n\n        // If the input is known to be positive (the sign bit is known clear),\n        // the output of the NEG has the same number of sign bits as the input.\n        if (Known.isNonNegative())\n          return Tmp2;\n\n        // Otherwise, we treat this like a SUB.\n      }\n\n    // Sub can have at most one carry bit.  Thus we know that the output\n    // is, at worst, one more bit than the inputs.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1) return 1; // Early out.\n    return std::min(Tmp, Tmp2) - 1;\n  case ISD::MUL: {\n    // The output of the Mul can be at most twice the valid bits in the inputs.\n    unsigned SignBitsOp0 = ComputeNumSignBits(Op.getOperand(0), Depth + 1);\n    if (SignBitsOp0 == 1)\n      break;\n    unsigned SignBitsOp1 = ComputeNumSignBits(Op.getOperand(1), Depth + 1);\n    if (SignBitsOp1 == 1)\n      break;\n    unsigned OutValidBits =\n        (VTBits - SignBitsOp0 + 1) + (VTBits - SignBitsOp1 + 1);\n    return OutValidBits > VTBits ? 1 : VTBits - OutValidBits + 1;\n  }\n  case ISD::SREM:\n    // The sign bit is the LHS's sign bit, except when the result of the\n    // remainder is zero. The magnitude of the result should be less than or\n    // equal to the magnitude of the LHS. Therefore, the result should have\n    // at least as many sign bits as the left hand side.\n    return ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n  case ISD::TRUNCATE: {\n    // Check if the sign bits of source go down as far as the truncated value.\n    unsigned NumSrcBits = Op.getOperand(0).getScalarValueSizeInBits();\n    unsigned NumSrcSignBits = ComputeNumSignBits(Op.getOperand(0), Depth + 1);\n    if (NumSrcSignBits > (NumSrcBits - VTBits))\n      return NumSrcSignBits - (NumSrcBits - VTBits);\n    break;\n  }\n  case ISD::EXTRACT_ELEMENT: {\n    const int KnownSign = ComputeNumSignBits(Op.getOperand(0), Depth+1);\n    const int BitWidth = Op.getValueSizeInBits();\n    const int Items = Op.getOperand(0).getValueSizeInBits() / BitWidth;\n\n    // Get reverse index (starting from 1), Op1 value indexes elements from\n    // little end. Sign starts at big end.\n    const int rIndex = Items - 1 - Op.getConstantOperandVal(1);\n\n    // If the sign portion ends in our element the subtraction gives correct\n    // result. Otherwise it gives either negative or > bitwidth result\n    return std::max(std::min(KnownSign - rIndex * BitWidth, BitWidth), 0);\n  }\n  case ISD::INSERT_VECTOR_ELT: {\n    // If we know the element index, split the demand between the\n    // source vector and the inserted element, otherwise assume we need\n    // the original demanded vector elements and the value.\n    SDValue InVec = Op.getOperand(0);\n    SDValue InVal = Op.getOperand(1);\n    SDValue EltNo = Op.getOperand(2);\n    bool DemandedVal = true;\n    APInt DemandedVecElts = DemandedElts;\n    auto *CEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (CEltNo && CEltNo->getAPIntValue().ult(NumElts)) {\n      unsigned EltIdx = CEltNo->getZExtValue();\n      DemandedVal = !!DemandedElts[EltIdx];\n      DemandedVecElts.clearBit(EltIdx);\n    }\n    Tmp = std::numeric_limits<unsigned>::max();\n    if (DemandedVal) {\n      // TODO - handle implicit truncation of inserted elements.\n      if (InVal.getScalarValueSizeInBits() != VTBits)\n        break;\n      Tmp2 = ComputeNumSignBits(InVal, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    if (!!DemandedVecElts) {\n      Tmp2 = ComputeNumSignBits(InVec, DemandedVecElts, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n  case ISD::EXTRACT_VECTOR_ELT: {\n    SDValue InVec = Op.getOperand(0);\n    SDValue EltNo = Op.getOperand(1);\n    EVT VecVT = InVec.getValueType();\n    // ComputeNumSignBits not yet implemented for scalable vectors.\n    if (VecVT.isScalableVector())\n      break;\n    const unsigned BitWidth = Op.getValueSizeInBits();\n    const unsigned EltBitWidth = Op.getOperand(0).getScalarValueSizeInBits();\n    const unsigned NumSrcElts = VecVT.getVectorNumElements();\n\n    // If BitWidth > EltBitWidth the value is anyext:ed, and we do not know\n    // anything about sign bits. But if the sizes match we can derive knowledge\n    // about sign bits from the vector operand.\n    if (BitWidth != EltBitWidth)\n      break;\n\n    // If we know the element index, just demand that vector element, else for\n    // an unknown element index, ignore DemandedElts and demand them all.\n    APInt DemandedSrcElts = APInt::getAllOnesValue(NumSrcElts);\n    auto *ConstEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (ConstEltNo && ConstEltNo->getAPIntValue().ult(NumSrcElts))\n      DemandedSrcElts =\n          APInt::getOneBitSet(NumSrcElts, ConstEltNo->getZExtValue());\n\n    return ComputeNumSignBits(InVec, DemandedSrcElts, Depth + 1);\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = Op.getOperand(0);\n    // Bail until we can represent demanded elements for scalable vectors.\n    if (Src.getValueType().isScalableVector())\n      break;\n    uint64_t Idx = Op.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n    return ComputeNumSignBits(Src, DemandedSrcElts, Depth + 1);\n  }\n  case ISD::CONCAT_VECTORS: {\n    // Determine the minimum number of sign bits across all demanded\n    // elts of the input vectors. Early out if the result is already 1.\n    Tmp = std::numeric_limits<unsigned>::max();\n    EVT SubVectorVT = Op.getOperand(0).getValueType();\n    unsigned NumSubVectorElts = SubVectorVT.getVectorNumElements();\n    unsigned NumSubVectors = Op.getNumOperands();\n    for (unsigned i = 0; (i < NumSubVectors) && (Tmp > 1); ++i) {\n      APInt DemandedSub = DemandedElts.lshr(i * NumSubVectorElts);\n      DemandedSub = DemandedSub.trunc(NumSubVectorElts);\n      if (!DemandedSub)\n        continue;\n      Tmp2 = ComputeNumSignBits(Op.getOperand(i), DemandedSub, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Demand any elements from the subvector and the remainder from the src its\n    // inserted into.\n    SDValue Src = Op.getOperand(0);\n    SDValue Sub = Op.getOperand(1);\n    uint64_t Idx = Op.getConstantOperandVal(2);\n    unsigned NumSubElts = Sub.getValueType().getVectorNumElements();\n    APInt DemandedSubElts = DemandedElts.extractBits(NumSubElts, Idx);\n    APInt DemandedSrcElts = DemandedElts;\n    DemandedSrcElts.insertBits(APInt::getNullValue(NumSubElts), Idx);\n\n    Tmp = std::numeric_limits<unsigned>::max();\n    if (!!DemandedSubElts) {\n      Tmp = ComputeNumSignBits(Sub, DemandedSubElts, Depth + 1);\n      if (Tmp == 1)\n        return 1; // early-out\n    }\n    if (!!DemandedSrcElts) {\n      Tmp2 = ComputeNumSignBits(Src, DemandedSrcElts, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n  }\n\n  // If we are looking at the loaded value of the SDNode.\n  if (Op.getResNo() == 0) {\n    // Handle LOADX separately here. EXTLOAD case will fallthrough.\n    if (LoadSDNode *LD = dyn_cast<LoadSDNode>(Op)) {\n      unsigned ExtType = LD->getExtensionType();\n      switch (ExtType) {\n      default: break;\n      case ISD::SEXTLOAD: // e.g. i16->i32 = '17' bits known.\n        Tmp = LD->getMemoryVT().getScalarSizeInBits();\n        return VTBits - Tmp + 1;\n      case ISD::ZEXTLOAD: // e.g. i16->i32 = '16' bits known.\n        Tmp = LD->getMemoryVT().getScalarSizeInBits();\n        return VTBits - Tmp;\n      case ISD::NON_EXTLOAD:\n        if (const Constant *Cst = TLI->getTargetConstantFromLoad(LD)) {\n          // We only need to handle vectors - computeKnownBits should handle\n          // scalar cases.\n          Type *CstTy = Cst->getType();\n          if (CstTy->isVectorTy() &&\n              (NumElts * VTBits) == CstTy->getPrimitiveSizeInBits()) {\n            Tmp = VTBits;\n            for (unsigned i = 0; i != NumElts; ++i) {\n              if (!DemandedElts[i])\n                continue;\n              if (Constant *Elt = Cst->getAggregateElement(i)) {\n                if (auto *CInt = dyn_cast<ConstantInt>(Elt)) {\n                  const APInt &Value = CInt->getValue();\n                  Tmp = std::min(Tmp, Value.getNumSignBits());\n                  continue;\n                }\n                if (auto *CFP = dyn_cast<ConstantFP>(Elt)) {\n                  APInt Value = CFP->getValueAPF().bitcastToAPInt();\n                  Tmp = std::min(Tmp, Value.getNumSignBits());\n                  continue;\n                }\n              }\n              // Unknown type. Conservatively assume no bits match sign bit.\n              return 1;\n            }\n            return Tmp;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  // Allow the target to implement this method for its nodes.\n  if (Opcode >= ISD::BUILTIN_OP_END ||\n      Opcode == ISD::INTRINSIC_WO_CHAIN ||\n      Opcode == ISD::INTRINSIC_W_CHAIN ||\n      Opcode == ISD::INTRINSIC_VOID) {\n    unsigned NumBits =\n        TLI->ComputeNumSignBitsForTargetNode(Op, DemandedElts, *this, Depth);\n    if (NumBits > 1)\n      FirstAnswer = std::max(FirstAnswer, NumBits);\n  }\n\n  // Finally, if we can prove that the top bits of the result are 0's or 1's,\n  // use this information.\n  KnownBits Known = computeKnownBits(Op, DemandedElts, Depth);\n\n  APInt Mask;\n  if (Known.isNonNegative()) {        // sign bit is 0\n    Mask = Known.Zero;\n  } else if (Known.isNegative()) {  // sign bit is 1;\n    Mask = Known.One;\n  } else {\n    // Nothing known.\n    return FirstAnswer;\n  }\n\n  // Okay, we know that the sign bit in Mask is set.  Use CLO to determine\n  // the number of identical bits in the top of the input value.\n  Mask <<= Mask.getBitWidth()-VTBits;\n  return std::max(FirstAnswer, Mask.countLeadingOnes());\n}\n\nbool SelectionDAG::isBaseWithConstantOffset(SDValue Op) const {\n  if ((Op.getOpcode() != ISD::ADD && Op.getOpcode() != ISD::OR) ||\n      !isa<ConstantSDNode>(Op.getOperand(1)))\n    return false;\n\n  if (Op.getOpcode() == ISD::OR &&\n      !MaskedValueIsZero(Op.getOperand(0), Op.getConstantOperandAPInt(1)))\n    return false;\n\n  return true;\n}\n\nbool SelectionDAG::isKnownNeverNaN(SDValue Op, bool SNaN, unsigned Depth) const {\n  // If we're told that NaNs won't happen, assume they won't.\n  if (getTarget().Options.NoNaNsFPMath || Op->getFlags().hasNoNaNs())\n    return true;\n\n  if (Depth >= MaxRecursionDepth)\n    return false; // Limit search depth.\n\n  // TODO: Handle vectors.\n  // If the value is a constant, we can obviously see if it is a NaN or not.\n  if (const ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(Op)) {\n    return !C->getValueAPF().isNaN() ||\n           (SNaN && !C->getValueAPF().isSignaling());\n  }\n\n  unsigned Opcode = Op.getOpcode();\n  switch (Opcode) {\n  case ISD::FADD:\n  case ISD::FSUB:\n  case ISD::FMUL:\n  case ISD::FDIV:\n  case ISD::FREM:\n  case ISD::FSIN:\n  case ISD::FCOS: {\n    if (SNaN)\n      return true;\n    // TODO: Need isKnownNeverInfinity\n    return false;\n  }\n  case ISD::FCANONICALIZE:\n  case ISD::FEXP:\n  case ISD::FEXP2:\n  case ISD::FTRUNC:\n  case ISD::FFLOOR:\n  case ISD::FCEIL:\n  case ISD::FROUND:\n  case ISD::FROUNDEVEN:\n  case ISD::FRINT:\n  case ISD::FNEARBYINT: {\n    if (SNaN)\n      return true;\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  case ISD::FABS:\n  case ISD::FNEG:\n  case ISD::FCOPYSIGN: {\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  case ISD::SELECT:\n    return isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(2), SNaN, Depth + 1);\n  case ISD::FP_EXTEND:\n  case ISD::FP_ROUND: {\n    if (SNaN)\n      return true;\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  case ISD::SINT_TO_FP:\n  case ISD::UINT_TO_FP:\n    return true;\n  case ISD::FMA:\n  case ISD::FMAD: {\n    if (SNaN)\n      return true;\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(2), SNaN, Depth + 1);\n  }\n  case ISD::FSQRT: // Need is known positive\n  case ISD::FLOG:\n  case ISD::FLOG2:\n  case ISD::FLOG10:\n  case ISD::FPOWI:\n  case ISD::FPOW: {\n    if (SNaN)\n      return true;\n    // TODO: Refine on operand\n    return false;\n  }\n  case ISD::FMINNUM:\n  case ISD::FMAXNUM: {\n    // Only one needs to be known not-nan, since it will be returned if the\n    // other ends up being one.\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1) ||\n           isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1);\n  }\n  case ISD::FMINNUM_IEEE:\n  case ISD::FMAXNUM_IEEE: {\n    if (SNaN)\n      return true;\n    // This can return a NaN if either operand is an sNaN, or if both operands\n    // are NaN.\n    return (isKnownNeverNaN(Op.getOperand(0), false, Depth + 1) &&\n            isKnownNeverSNaN(Op.getOperand(1), Depth + 1)) ||\n           (isKnownNeverNaN(Op.getOperand(1), false, Depth + 1) &&\n            isKnownNeverSNaN(Op.getOperand(0), Depth + 1));\n  }\n  case ISD::FMINIMUM:\n  case ISD::FMAXIMUM: {\n    // TODO: Does this quiet or return the origina NaN as-is?\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1);\n  }\n  case ISD::EXTRACT_VECTOR_ELT: {\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  default:\n    if (Opcode >= ISD::BUILTIN_OP_END ||\n        Opcode == ISD::INTRINSIC_WO_CHAIN ||\n        Opcode == ISD::INTRINSIC_W_CHAIN ||\n        Opcode == ISD::INTRINSIC_VOID) {\n      return TLI->isKnownNeverNaNForTargetNode(Op, *this, SNaN, Depth);\n    }\n\n    return false;\n  }\n}\n\nbool SelectionDAG::isKnownNeverZeroFloat(SDValue Op) const {\n  assert(Op.getValueType().isFloatingPoint() &&\n         \"Floating point type expected\");\n\n  // If the value is a constant, we can obviously see if it is a zero or not.\n  // TODO: Add BuildVector support.\n  if (const ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(Op))\n    return !C->isZero();\n  return false;\n}\n\nbool SelectionDAG::isKnownNeverZero(SDValue Op) const {\n  assert(!Op.getValueType().isFloatingPoint() &&\n         \"Floating point types unsupported - use isKnownNeverZeroFloat\");\n\n  // If the value is a constant, we can obviously see if it is a zero or not.\n  if (ISD::matchUnaryPredicate(\n          Op, [](ConstantSDNode *C) { return !C->isNullValue(); }))\n    return true;\n\n  // TODO: Recognize more cases here.\n  switch (Op.getOpcode()) {\n  default: break;\n  case ISD::OR:\n    if (isKnownNeverZero(Op.getOperand(1)) ||\n        isKnownNeverZero(Op.getOperand(0)))\n      return true;\n    break;\n  }\n\n  return false;\n}\n\nbool SelectionDAG::isEqualTo(SDValue A, SDValue B) const {\n  // Check the obvious case.\n  if (A == B) return true;\n\n  // For for negative and positive zero.\n  if (const ConstantFPSDNode *CA = dyn_cast<ConstantFPSDNode>(A))\n    if (const ConstantFPSDNode *CB = dyn_cast<ConstantFPSDNode>(B))\n      if (CA->isZero() && CB->isZero()) return true;\n\n  // Otherwise they may not be equal.\n  return false;\n}\n\n// FIXME: unify with llvm::haveNoCommonBitsSet.\n// FIXME: could also handle masked merge pattern (X & ~M) op (Y & M)\nbool SelectionDAG::haveNoCommonBitsSet(SDValue A, SDValue B) const {\n  assert(A.getValueType() == B.getValueType() &&\n         \"Values must have the same type\");\n  return (computeKnownBits(A).Zero | computeKnownBits(B).Zero).isAllOnesValue();\n}\n\nstatic SDValue FoldBUILD_VECTOR(const SDLoc &DL, EVT VT,\n                                ArrayRef<SDValue> Ops,\n                                SelectionDAG &DAG) {\n  int NumOps = Ops.size();\n  assert(NumOps != 0 && \"Can't build an empty vector!\");\n  assert(!VT.isScalableVector() &&\n         \"BUILD_VECTOR cannot be used with scalable types\");\n  assert(VT.getVectorNumElements() == (unsigned)NumOps &&\n         \"Incorrect element count in BUILD_VECTOR!\");\n\n  // BUILD_VECTOR of UNDEFs is UNDEF.\n  if (llvm::all_of(Ops, [](SDValue Op) { return Op.isUndef(); }))\n    return DAG.getUNDEF(VT);\n\n  // BUILD_VECTOR of seq extract/insert from the same vector + type is Identity.\n  SDValue IdentitySrc;\n  bool IsIdentity = true;\n  for (int i = 0; i != NumOps; ++i) {\n    if (Ops[i].getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n        Ops[i].getOperand(0).getValueType() != VT ||\n        (IdentitySrc && Ops[i].getOperand(0) != IdentitySrc) ||\n        !isa<ConstantSDNode>(Ops[i].getOperand(1)) ||\n        cast<ConstantSDNode>(Ops[i].getOperand(1))->getAPIntValue() != i) {\n      IsIdentity = false;\n      break;\n    }\n    IdentitySrc = Ops[i].getOperand(0);\n  }\n  if (IsIdentity)\n    return IdentitySrc;\n\n  return SDValue();\n}\n\n/// Try to simplify vector concatenation to an input value, undef, or build\n/// vector.\nstatic SDValue foldCONCAT_VECTORS(const SDLoc &DL, EVT VT,\n                                  ArrayRef<SDValue> Ops,\n                                  SelectionDAG &DAG) {\n  assert(!Ops.empty() && \"Can't concatenate an empty list of vectors!\");\n  assert(llvm::all_of(Ops,\n                      [Ops](SDValue Op) {\n                        return Ops[0].getValueType() == Op.getValueType();\n                      }) &&\n         \"Concatenation of vectors with inconsistent value types!\");\n  assert((Ops[0].getValueType().getVectorElementCount() * Ops.size()) ==\n             VT.getVectorElementCount() &&\n         \"Incorrect element count in vector concatenation!\");\n\n  if (Ops.size() == 1)\n    return Ops[0];\n\n  // Concat of UNDEFs is UNDEF.\n  if (llvm::all_of(Ops, [](SDValue Op) { return Op.isUndef(); }))\n    return DAG.getUNDEF(VT);\n\n  // Scan the operands and look for extract operations from a single source\n  // that correspond to insertion at the same location via this concatenation:\n  // concat (extract X, 0*subvec_elts), (extract X, 1*subvec_elts), ...\n  SDValue IdentitySrc;\n  bool IsIdentity = true;\n  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {\n    SDValue Op = Ops[i];\n    unsigned IdentityIndex = i * Op.getValueType().getVectorMinNumElements();\n    if (Op.getOpcode() != ISD::EXTRACT_SUBVECTOR ||\n        Op.getOperand(0).getValueType() != VT ||\n        (IdentitySrc && Op.getOperand(0) != IdentitySrc) ||\n        Op.getConstantOperandVal(1) != IdentityIndex) {\n      IsIdentity = false;\n      break;\n    }\n    assert((!IdentitySrc || IdentitySrc == Op.getOperand(0)) &&\n           \"Unexpected identity source vector for concat of extracts\");\n    IdentitySrc = Op.getOperand(0);\n  }\n  if (IsIdentity) {\n    assert(IdentitySrc && \"Failed to set source vector of extracts\");\n    return IdentitySrc;\n  }\n\n  // The code below this point is only designed to work for fixed width\n  // vectors, so we bail out for now.\n  if (VT.isScalableVector())\n    return SDValue();\n\n  // A CONCAT_VECTOR with all UNDEF/BUILD_VECTOR operands can be\n  // simplified to one big BUILD_VECTOR.\n  // FIXME: Add support for SCALAR_TO_VECTOR as well.\n  EVT SVT = VT.getScalarType();\n  SmallVector<SDValue, 16> Elts;\n  for (SDValue Op : Ops) {\n    EVT OpVT = Op.getValueType();\n    if (Op.isUndef())\n      Elts.append(OpVT.getVectorNumElements(), DAG.getUNDEF(SVT));\n    else if (Op.getOpcode() == ISD::BUILD_VECTOR)\n      Elts.append(Op->op_begin(), Op->op_end());\n    else\n      return SDValue();\n  }\n\n  // BUILD_VECTOR requires all inputs to be of the same type, find the\n  // maximum type and extend them all.\n  for (SDValue Op : Elts)\n    SVT = (SVT.bitsLT(Op.getValueType()) ? Op.getValueType() : SVT);\n\n  if (SVT.bitsGT(VT.getScalarType())) {\n    for (SDValue &Op : Elts) {\n      if (Op.isUndef())\n        Op = DAG.getUNDEF(SVT);\n      else\n        Op = DAG.getTargetLoweringInfo().isZExtFree(Op.getValueType(), SVT)\n                 ? DAG.getZExtOrTrunc(Op, DL, SVT)\n                 : DAG.getSExtOrTrunc(Op, DL, SVT);\n    }\n  }\n\n  SDValue V = DAG.getBuildVector(VT, DL, Elts);\n  NewSDValueDbgMsg(V, \"New node fold concat vectors: \", &DAG);\n  return V;\n}\n\n/// Gets or creates the specified node.\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opcode, getVTList(VT), None);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(),\n                              getVTList(VT));\n  CSEMap.InsertNode(N, IP);\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue Operand) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, Operand, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue Operand, const SDNodeFlags Flags) {\n  assert(Operand.getOpcode() != ISD::DELETED_NODE &&\n         \"Operand is DELETED_NODE!\");\n  // Constant fold unary operations with an integer constant operand. Even\n  // opaque constant will be folded, because the folding of unary operations\n  // doesn't create new constants with different values. Nevertheless, the\n  // opaque flag is preserved during folding to prevent future folding with\n  // other constants.\n  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Operand)) {\n    const APInt &Val = C->getAPIntValue();\n    switch (Opcode) {\n    default: break;\n    case ISD::SIGN_EXTEND:\n      return getConstant(Val.sextOrTrunc(VT.getSizeInBits()), DL, VT,\n                         C->isTargetOpcode(), C->isOpaque());\n    case ISD::TRUNCATE:\n      if (C->isOpaque())\n        break;\n      LLVM_FALLTHROUGH;\n    case ISD::ANY_EXTEND:\n    case ISD::ZERO_EXTEND:\n      return getConstant(Val.zextOrTrunc(VT.getSizeInBits()), DL, VT,\n                         C->isTargetOpcode(), C->isOpaque());\n    case ISD::UINT_TO_FP:\n    case ISD::SINT_TO_FP: {\n      APFloat apf(EVTToAPFloatSemantics(VT),\n                  APInt::getNullValue(VT.getSizeInBits()));\n      (void)apf.convertFromAPInt(Val,\n                                 Opcode==ISD::SINT_TO_FP,\n                                 APFloat::rmNearestTiesToEven);\n      return getConstantFP(apf, DL, VT);\n    }\n    case ISD::BITCAST:\n      if (VT == MVT::f16 && C->getValueType(0) == MVT::i16)\n        return getConstantFP(APFloat(APFloat::IEEEhalf(), Val), DL, VT);\n      if (VT == MVT::f32 && C->getValueType(0) == MVT::i32)\n        return getConstantFP(APFloat(APFloat::IEEEsingle(), Val), DL, VT);\n      if (VT == MVT::f64 && C->getValueType(0) == MVT::i64)\n        return getConstantFP(APFloat(APFloat::IEEEdouble(), Val), DL, VT);\n      if (VT == MVT::f128 && C->getValueType(0) == MVT::i128)\n        return getConstantFP(APFloat(APFloat::IEEEquad(), Val), DL, VT);\n      break;\n    case ISD::ABS:\n      return getConstant(Val.abs(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::BITREVERSE:\n      return getConstant(Val.reverseBits(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::BSWAP:\n      return getConstant(Val.byteSwap(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::CTPOP:\n      return getConstant(Val.countPopulation(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::CTLZ:\n    case ISD::CTLZ_ZERO_UNDEF:\n      return getConstant(Val.countLeadingZeros(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::CTTZ:\n    case ISD::CTTZ_ZERO_UNDEF:\n      return getConstant(Val.countTrailingZeros(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::FP16_TO_FP: {\n      bool Ignored;\n      APFloat FPV(APFloat::IEEEhalf(),\n                  (Val.getBitWidth() == 16) ? Val : Val.trunc(16));\n\n      // This can return overflow, underflow, or inexact; we don't care.\n      // FIXME need to be more flexible about rounding mode.\n      (void)FPV.convert(EVTToAPFloatSemantics(VT),\n                        APFloat::rmNearestTiesToEven, &Ignored);\n      return getConstantFP(FPV, DL, VT);\n    }\n    }\n  }\n\n  // Constant fold unary operations with a floating point constant operand.\n  if (ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(Operand)) {\n    APFloat V = C->getValueAPF();    // make copy\n    switch (Opcode) {\n    case ISD::FNEG:\n      V.changeSign();\n      return getConstantFP(V, DL, VT);\n    case ISD::FABS:\n      V.clearSign();\n      return getConstantFP(V, DL, VT);\n    case ISD::FCEIL: {\n      APFloat::opStatus fs = V.roundToIntegral(APFloat::rmTowardPositive);\n      if (fs == APFloat::opOK || fs == APFloat::opInexact)\n        return getConstantFP(V, DL, VT);\n      break;\n    }\n    case ISD::FTRUNC: {\n      APFloat::opStatus fs = V.roundToIntegral(APFloat::rmTowardZero);\n      if (fs == APFloat::opOK || fs == APFloat::opInexact)\n        return getConstantFP(V, DL, VT);\n      break;\n    }\n    case ISD::FFLOOR: {\n      APFloat::opStatus fs = V.roundToIntegral(APFloat::rmTowardNegative);\n      if (fs == APFloat::opOK || fs == APFloat::opInexact)\n        return getConstantFP(V, DL, VT);\n      break;\n    }\n    case ISD::FP_EXTEND: {\n      bool ignored;\n      // This can return overflow, underflow, or inexact; we don't care.\n      // FIXME need to be more flexible about rounding mode.\n      (void)V.convert(EVTToAPFloatSemantics(VT),\n                      APFloat::rmNearestTiesToEven, &ignored);\n      return getConstantFP(V, DL, VT);\n    }\n    case ISD::FP_TO_SINT:\n    case ISD::FP_TO_UINT: {\n      bool ignored;\n      APSInt IntVal(VT.getSizeInBits(), Opcode == ISD::FP_TO_UINT);\n      // FIXME need to be more flexible about rounding mode.\n      APFloat::opStatus s =\n          V.convertToInteger(IntVal, APFloat::rmTowardZero, &ignored);\n      if (s == APFloat::opInvalidOp) // inexact is OK, in fact usual\n        break;\n      return getConstant(IntVal, DL, VT);\n    }\n    case ISD::BITCAST:\n      if (VT == MVT::i16 && C->getValueType(0) == MVT::f16)\n        return getConstant((uint16_t)V.bitcastToAPInt().getZExtValue(), DL, VT);\n      else if (VT == MVT::i32 && C->getValueType(0) == MVT::f32)\n        return getConstant((uint32_t)V.bitcastToAPInt().getZExtValue(), DL, VT);\n      else if (VT == MVT::i64 && C->getValueType(0) == MVT::f64)\n        return getConstant(V.bitcastToAPInt().getZExtValue(), DL, VT);\n      break;\n    case ISD::FP_TO_FP16: {\n      bool Ignored;\n      // This can return overflow, underflow, or inexact; we don't care.\n      // FIXME need to be more flexible about rounding mode.\n      (void)V.convert(APFloat::IEEEhalf(),\n                      APFloat::rmNearestTiesToEven, &Ignored);\n      return getConstant(V.bitcastToAPInt().getZExtValue(), DL, VT);\n    }\n    }\n  }\n\n  // Constant fold unary operations with a vector integer or float operand.\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(Operand)) {\n    if (BV->isConstant()) {\n      switch (Opcode) {\n      default:\n        // FIXME: Entirely reasonable to perform folding of other unary\n        // operations here as the need arises.\n        break;\n      case ISD::FNEG:\n      case ISD::FABS:\n      case ISD::FCEIL:\n      case ISD::FTRUNC:\n      case ISD::FFLOOR:\n      case ISD::FP_EXTEND:\n      case ISD::FP_TO_SINT:\n      case ISD::FP_TO_UINT:\n      case ISD::TRUNCATE:\n      case ISD::ANY_EXTEND:\n      case ISD::ZERO_EXTEND:\n      case ISD::SIGN_EXTEND:\n      case ISD::UINT_TO_FP:\n      case ISD::SINT_TO_FP:\n      case ISD::ABS:\n      case ISD::BITREVERSE:\n      case ISD::BSWAP:\n      case ISD::CTLZ:\n      case ISD::CTLZ_ZERO_UNDEF:\n      case ISD::CTTZ:\n      case ISD::CTTZ_ZERO_UNDEF:\n      case ISD::CTPOP: {\n        SDValue Ops = { Operand };\n        if (SDValue Fold = FoldConstantVectorArithmetic(Opcode, DL, VT, Ops))\n          return Fold;\n      }\n      }\n    }\n  }\n\n  unsigned OpOpcode = Operand.getNode()->getOpcode();\n  switch (Opcode) {\n  case ISD::FREEZE:\n    assert(VT == Operand.getValueType() && \"Unexpected VT!\");\n    break;\n  case ISD::TokenFactor:\n  case ISD::MERGE_VALUES:\n  case ISD::CONCAT_VECTORS:\n    return Operand;         // Factor, merge or concat of one node?  No need.\n  case ISD::BUILD_VECTOR: {\n    // Attempt to simplify BUILD_VECTOR.\n    SDValue Ops[] = {Operand};\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::FP_ROUND: llvm_unreachable(\"Invalid method to make FP_ROUND node\");\n  case ISD::FP_EXTEND:\n    assert(VT.isFloatingPoint() &&\n           Operand.getValueType().isFloatingPoint() && \"Invalid FP cast!\");\n    if (Operand.getValueType() == VT) return Operand;  // noop conversion.\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n            Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid fpext node, dst < src!\");\n    if (Operand.isUndef())\n      return getUNDEF(VT);\n    break;\n  case ISD::FP_TO_SINT:\n  case ISD::FP_TO_UINT:\n    if (Operand.isUndef())\n      return getUNDEF(VT);\n    break;\n  case ISD::SINT_TO_FP:\n  case ISD::UINT_TO_FP:\n    // [us]itofp(undef) = 0, because the result value is bounded.\n    if (Operand.isUndef())\n      return getConstantFP(0.0, DL, VT);\n    break;\n  case ISD::SIGN_EXTEND:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid SIGN_EXTEND!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"SIGN_EXTEND result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop extension\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid sext node, dst < src!\");\n    if (OpOpcode == ISD::SIGN_EXTEND || OpOpcode == ISD::ZERO_EXTEND)\n      return getNode(OpOpcode, DL, VT, Operand.getOperand(0));\n    else if (OpOpcode == ISD::UNDEF)\n      // sext(undef) = 0, because the top bits will all be the same.\n      return getConstant(0, DL, VT);\n    break;\n  case ISD::ZERO_EXTEND:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid ZERO_EXTEND!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"ZERO_EXTEND result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop extension\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid zext node, dst < src!\");\n    if (OpOpcode == ISD::ZERO_EXTEND)   // (zext (zext x)) -> (zext x)\n      return getNode(ISD::ZERO_EXTEND, DL, VT, Operand.getOperand(0));\n    else if (OpOpcode == ISD::UNDEF)\n      // zext(undef) = 0, because the top bits will be zero.\n      return getConstant(0, DL, VT);\n    break;\n  case ISD::ANY_EXTEND:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid ANY_EXTEND!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"ANY_EXTEND result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop extension\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid anyext node, dst < src!\");\n\n    if (OpOpcode == ISD::ZERO_EXTEND || OpOpcode == ISD::SIGN_EXTEND ||\n        OpOpcode == ISD::ANY_EXTEND)\n      // (ext (zext x)) -> (zext x)  and  (ext (sext x)) -> (sext x)\n      return getNode(OpOpcode, DL, VT, Operand.getOperand(0));\n    else if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n\n    // (ext (trunc x)) -> x\n    if (OpOpcode == ISD::TRUNCATE) {\n      SDValue OpOp = Operand.getOperand(0);\n      if (OpOp.getValueType() == VT) {\n        transferDbgValues(Operand, OpOp);\n        return OpOp;\n      }\n    }\n    break;\n  case ISD::TRUNCATE:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid TRUNCATE!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"TRUNCATE result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop truncate\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsGT(VT) &&\n           \"Invalid truncate node, src < dst!\");\n    if (OpOpcode == ISD::TRUNCATE)\n      return getNode(ISD::TRUNCATE, DL, VT, Operand.getOperand(0));\n    if (OpOpcode == ISD::ZERO_EXTEND || OpOpcode == ISD::SIGN_EXTEND ||\n        OpOpcode == ISD::ANY_EXTEND) {\n      // If the source is smaller than the dest, we still need an extend.\n      if (Operand.getOperand(0).getValueType().getScalarType()\n            .bitsLT(VT.getScalarType()))\n        return getNode(OpOpcode, DL, VT, Operand.getOperand(0));\n      if (Operand.getOperand(0).getValueType().bitsGT(VT))\n        return getNode(ISD::TRUNCATE, DL, VT, Operand.getOperand(0));\n      return Operand.getOperand(0);\n    }\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::ANY_EXTEND_VECTOR_INREG:\n  case ISD::ZERO_EXTEND_VECTOR_INREG:\n  case ISD::SIGN_EXTEND_VECTOR_INREG:\n    assert(VT.isVector() && \"This DAG node is restricted to vector types.\");\n    assert(Operand.getValueType().bitsLE(VT) &&\n           \"The input must be the same size or smaller than the result.\");\n    assert(VT.getVectorNumElements() <\n             Operand.getValueType().getVectorNumElements() &&\n           \"The destination vector type must have fewer lanes than the input.\");\n    break;\n  case ISD::ABS:\n    assert(VT.isInteger() && VT == Operand.getValueType() &&\n           \"Invalid ABS!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::BSWAP:\n    assert(VT.isInteger() && VT == Operand.getValueType() &&\n           \"Invalid BSWAP!\");\n    assert((VT.getScalarSizeInBits() % 16 == 0) &&\n           \"BSWAP types must be a multiple of 16 bits!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::BITREVERSE:\n    assert(VT.isInteger() && VT == Operand.getValueType() &&\n           \"Invalid BITREVERSE!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::BITCAST:\n    // Basic sanity checking.\n    assert(VT.getSizeInBits() == Operand.getValueSizeInBits() &&\n           \"Cannot BITCAST between types of different sizes!\");\n    if (VT == Operand.getValueType()) return Operand;  // noop conversion.\n    if (OpOpcode == ISD::BITCAST)  // bitconv(bitconv(x)) -> bitconv(x)\n      return getNode(ISD::BITCAST, DL, VT, Operand.getOperand(0));\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::SCALAR_TO_VECTOR:\n    assert(VT.isVector() && !Operand.getValueType().isVector() &&\n           (VT.getVectorElementType() == Operand.getValueType() ||\n            (VT.getVectorElementType().isInteger() &&\n             Operand.getValueType().isInteger() &&\n             VT.getVectorElementType().bitsLE(Operand.getValueType()))) &&\n           \"Illegal SCALAR_TO_VECTOR node!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    // scalar_to_vector(extract_vector_elt V, 0) -> V, top bits are undefined.\n    if (OpOpcode == ISD::EXTRACT_VECTOR_ELT &&\n        isa<ConstantSDNode>(Operand.getOperand(1)) &&\n        Operand.getConstantOperandVal(1) == 0 &&\n        Operand.getOperand(0).getValueType() == VT)\n      return Operand.getOperand(0);\n    break;\n  case ISD::FNEG:\n    // Negation of an unknown bag of bits is still completely undefined.\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n\n    if (OpOpcode == ISD::FNEG)  // --X -> X\n      return Operand.getOperand(0);\n    break;\n  case ISD::FABS:\n    if (OpOpcode == ISD::FNEG)  // abs(-X) -> abs(X)\n      return getNode(ISD::FABS, DL, VT, Operand.getOperand(0));\n    break;\n  case ISD::VSCALE:\n    assert(VT == Operand.getValueType() && \"Unexpected VT!\");\n    break;\n  case ISD::CTPOP:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return Operand;\n    break;\n  case ISD::CTLZ:\n  case ISD::CTTZ:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return getNOT(DL, Operand, Operand.getValueType());\n    break;\n  case ISD::VECREDUCE_SMIN:\n  case ISD::VECREDUCE_UMAX:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return getNode(ISD::VECREDUCE_OR, DL, VT, Operand);\n    break;\n  case ISD::VECREDUCE_SMAX:\n  case ISD::VECREDUCE_UMIN:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return getNode(ISD::VECREDUCE_AND, DL, VT, Operand);\n    break;\n  }\n\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = {Operand};\n  if (VT != MVT::Glue) { // Don't CSE flag producing nodes\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      E->intersectFlagsWith(Flags);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    N->setFlags(Flags);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nstatic llvm::Optional<APInt> FoldValue(unsigned Opcode, const APInt &C1,\n                                       const APInt &C2) {\n  switch (Opcode) {\n  case ISD::ADD:  return C1 + C2;\n  case ISD::SUB:  return C1 - C2;\n  case ISD::MUL:  return C1 * C2;\n  case ISD::AND:  return C1 & C2;\n  case ISD::OR:   return C1 | C2;\n  case ISD::XOR:  return C1 ^ C2;\n  case ISD::SHL:  return C1 << C2;\n  case ISD::SRL:  return C1.lshr(C2);\n  case ISD::SRA:  return C1.ashr(C2);\n  case ISD::ROTL: return C1.rotl(C2);\n  case ISD::ROTR: return C1.rotr(C2);\n  case ISD::SMIN: return C1.sle(C2) ? C1 : C2;\n  case ISD::SMAX: return C1.sge(C2) ? C1 : C2;\n  case ISD::UMIN: return C1.ule(C2) ? C1 : C2;\n  case ISD::UMAX: return C1.uge(C2) ? C1 : C2;\n  case ISD::SADDSAT: return C1.sadd_sat(C2);\n  case ISD::UADDSAT: return C1.uadd_sat(C2);\n  case ISD::SSUBSAT: return C1.ssub_sat(C2);\n  case ISD::USUBSAT: return C1.usub_sat(C2);\n  case ISD::UDIV:\n    if (!C2.getBoolValue())\n      break;\n    return C1.udiv(C2);\n  case ISD::UREM:\n    if (!C2.getBoolValue())\n      break;\n    return C1.urem(C2);\n  case ISD::SDIV:\n    if (!C2.getBoolValue())\n      break;\n    return C1.sdiv(C2);\n  case ISD::SREM:\n    if (!C2.getBoolValue())\n      break;\n    return C1.srem(C2);\n  }\n  return llvm::None;\n}\n\nSDValue SelectionDAG::FoldSymbolOffset(unsigned Opcode, EVT VT,\n                                       const GlobalAddressSDNode *GA,\n                                       const SDNode *N2) {\n  if (GA->getOpcode() != ISD::GlobalAddress)\n    return SDValue();\n  if (!TLI->isOffsetFoldingLegal(GA))\n    return SDValue();\n  auto *C2 = dyn_cast<ConstantSDNode>(N2);\n  if (!C2)\n    return SDValue();\n  int64_t Offset = C2->getSExtValue();\n  switch (Opcode) {\n  case ISD::ADD: break;\n  case ISD::SUB: Offset = -uint64_t(Offset); break;\n  default: return SDValue();\n  }\n  return getGlobalAddress(GA->getGlobal(), SDLoc(C2), VT,\n                          GA->getOffset() + uint64_t(Offset));\n}\n\nbool SelectionDAG::isUndef(unsigned Opcode, ArrayRef<SDValue> Ops) {\n  switch (Opcode) {\n  case ISD::SDIV:\n  case ISD::UDIV:\n  case ISD::SREM:\n  case ISD::UREM: {\n    // If a divisor is zero/undef or any element of a divisor vector is\n    // zero/undef, the whole op is undef.\n    assert(Ops.size() == 2 && \"Div/rem should have 2 operands\");\n    SDValue Divisor = Ops[1];\n    if (Divisor.isUndef() || isNullConstant(Divisor))\n      return true;\n\n    return ISD::isBuildVectorOfConstantSDNodes(Divisor.getNode()) &&\n           llvm::any_of(Divisor->op_values(),\n                        [](SDValue V) { return V.isUndef() ||\n                                        isNullConstant(V); });\n    // TODO: Handle signed overflow.\n  }\n  // TODO: Handle oversized shifts.\n  default:\n    return false;\n  }\n}\n\nSDValue SelectionDAG::FoldConstantArithmetic(unsigned Opcode, const SDLoc &DL,\n                                             EVT VT, ArrayRef<SDValue> Ops) {\n  // If the opcode is a target-specific ISD node, there's nothing we can\n  // do here and the operand rules may not line up with the below, so\n  // bail early.\n  if (Opcode >= ISD::BUILTIN_OP_END)\n    return SDValue();\n\n  // For now, the array Ops should only contain two values.\n  // This enforcement will be removed once this function is merged with\n  // FoldConstantVectorArithmetic\n  if (Ops.size() != 2)\n    return SDValue();\n\n  if (isUndef(Opcode, Ops))\n    return getUNDEF(VT);\n\n  SDNode *N1 = Ops[0].getNode();\n  SDNode *N2 = Ops[1].getNode();\n\n  // Handle the case of two scalars.\n  if (auto *C1 = dyn_cast<ConstantSDNode>(N1)) {\n    if (auto *C2 = dyn_cast<ConstantSDNode>(N2)) {\n      if (C1->isOpaque() || C2->isOpaque())\n        return SDValue();\n\n      Optional<APInt> FoldAttempt =\n          FoldValue(Opcode, C1->getAPIntValue(), C2->getAPIntValue());\n      if (!FoldAttempt)\n        return SDValue();\n\n      SDValue Folded = getConstant(FoldAttempt.getValue(), DL, VT);\n      assert((!Folded || !VT.isVector()) &&\n             \"Can't fold vectors ops with scalar operands\");\n      return Folded;\n    }\n  }\n\n  // fold (add Sym, c) -> Sym+c\n  if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(N1))\n    return FoldSymbolOffset(Opcode, VT, GA, N2);\n  if (TLI->isCommutativeBinOp(Opcode))\n    if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(N2))\n      return FoldSymbolOffset(Opcode, VT, GA, N1);\n\n  // TODO: All the folds below are performed lane-by-lane and assume a fixed\n  // vector width, however we should be able to do constant folds involving\n  // splat vector nodes too.\n  if (VT.isScalableVector())\n    return SDValue();\n\n  // For fixed width vectors, extract each constant element and fold them\n  // individually. Either input may be an undef value.\n  auto *BV1 = dyn_cast<BuildVectorSDNode>(N1);\n  if (!BV1 && !N1->isUndef())\n    return SDValue();\n  auto *BV2 = dyn_cast<BuildVectorSDNode>(N2);\n  if (!BV2 && !N2->isUndef())\n    return SDValue();\n  // If both operands are undef, that's handled the same way as scalars.\n  if (!BV1 && !BV2)\n    return SDValue();\n\n  assert((!BV1 || !BV2 || BV1->getNumOperands() == BV2->getNumOperands()) &&\n         \"Vector binop with different number of elements in operands?\");\n\n  EVT SVT = VT.getScalarType();\n  EVT LegalSVT = SVT;\n  if (NewNodesMustHaveLegalTypes && LegalSVT.isInteger()) {\n    LegalSVT = TLI->getTypeToTransformTo(*getContext(), LegalSVT);\n    if (LegalSVT.bitsLT(SVT))\n      return SDValue();\n  }\n  SmallVector<SDValue, 4> Outputs;\n  unsigned NumOps = BV1 ? BV1->getNumOperands() : BV2->getNumOperands();\n  for (unsigned I = 0; I != NumOps; ++I) {\n    SDValue V1 = BV1 ? BV1->getOperand(I) : getUNDEF(SVT);\n    SDValue V2 = BV2 ? BV2->getOperand(I) : getUNDEF(SVT);\n    if (SVT.isInteger()) {\n      if (V1->getValueType(0).bitsGT(SVT))\n        V1 = getNode(ISD::TRUNCATE, DL, SVT, V1);\n      if (V2->getValueType(0).bitsGT(SVT))\n        V2 = getNode(ISD::TRUNCATE, DL, SVT, V2);\n    }\n\n    if (V1->getValueType(0) != SVT || V2->getValueType(0) != SVT)\n      return SDValue();\n\n    // Fold one vector element.\n    SDValue ScalarResult = getNode(Opcode, DL, SVT, V1, V2);\n    if (LegalSVT != SVT)\n      ScalarResult = getNode(ISD::SIGN_EXTEND, DL, LegalSVT, ScalarResult);\n\n    // Scalar folding only succeeded if the result is a constant or UNDEF.\n    if (!ScalarResult.isUndef() && ScalarResult.getOpcode() != ISD::Constant &&\n        ScalarResult.getOpcode() != ISD::ConstantFP)\n      return SDValue();\n    Outputs.push_back(ScalarResult);\n  }\n\n  assert(VT.getVectorNumElements() == Outputs.size() &&\n         \"Vector size mismatch!\");\n\n  // We may have a vector type but a scalar result. Create a splat.\n  Outputs.resize(VT.getVectorNumElements(), Outputs.back());\n\n  // Build a big vector out of the scalar elements we generated.\n  return getBuildVector(VT, SDLoc(), Outputs);\n}\n\n// TODO: Merge with FoldConstantArithmetic\nSDValue SelectionDAG::FoldConstantVectorArithmetic(unsigned Opcode,\n                                                   const SDLoc &DL, EVT VT,\n                                                   ArrayRef<SDValue> Ops,\n                                                   const SDNodeFlags Flags) {\n  // If the opcode is a target-specific ISD node, there's nothing we can\n  // do here and the operand rules may not line up with the below, so\n  // bail early.\n  if (Opcode >= ISD::BUILTIN_OP_END)\n    return SDValue();\n\n  if (isUndef(Opcode, Ops))\n    return getUNDEF(VT);\n\n  // We can only fold vectors - maybe merge with FoldConstantArithmetic someday?\n  if (!VT.isVector())\n    return SDValue();\n\n  // TODO: All the folds below are performed lane-by-lane and assume a fixed\n  // vector width, however we should be able to do constant folds involving\n  // splat vector nodes too.\n  if (VT.isScalableVector())\n    return SDValue();\n\n  // From this point onwards all vectors are assumed to be fixed width.\n  unsigned NumElts = VT.getVectorNumElements();\n\n  auto IsScalarOrSameVectorSize = [&](const SDValue &Op) {\n    return !Op.getValueType().isVector() ||\n           Op.getValueType().getVectorNumElements() == NumElts;\n  };\n\n  auto IsConstantBuildVectorOrUndef = [&](const SDValue &Op) {\n    BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(Op);\n    return (Op.isUndef()) || (Op.getOpcode() == ISD::CONDCODE) ||\n           (BV && BV->isConstant());\n  };\n\n  // All operands must be vector types with the same number of elements as\n  // the result type and must be either UNDEF or a build vector of constant\n  // or UNDEF scalars.\n  if (!llvm::all_of(Ops, IsConstantBuildVectorOrUndef) ||\n      !llvm::all_of(Ops, IsScalarOrSameVectorSize))\n    return SDValue();\n\n  // If we are comparing vectors, then the result needs to be a i1 boolean\n  // that is then sign-extended back to the legal result type.\n  EVT SVT = (Opcode == ISD::SETCC ? MVT::i1 : VT.getScalarType());\n\n  // Find legal integer scalar type for constant promotion and\n  // ensure that its scalar size is at least as large as source.\n  EVT LegalSVT = VT.getScalarType();\n  if (NewNodesMustHaveLegalTypes && LegalSVT.isInteger()) {\n    LegalSVT = TLI->getTypeToTransformTo(*getContext(), LegalSVT);\n    if (LegalSVT.bitsLT(VT.getScalarType()))\n      return SDValue();\n  }\n\n  // Constant fold each scalar lane separately.\n  SmallVector<SDValue, 4> ScalarResults;\n  for (unsigned i = 0; i != NumElts; i++) {\n    SmallVector<SDValue, 4> ScalarOps;\n    for (SDValue Op : Ops) {\n      EVT InSVT = Op.getValueType().getScalarType();\n      BuildVectorSDNode *InBV = dyn_cast<BuildVectorSDNode>(Op);\n      if (!InBV) {\n        // We've checked that this is UNDEF or a constant of some kind.\n        if (Op.isUndef())\n          ScalarOps.push_back(getUNDEF(InSVT));\n        else\n          ScalarOps.push_back(Op);\n        continue;\n      }\n\n      SDValue ScalarOp = InBV->getOperand(i);\n      EVT ScalarVT = ScalarOp.getValueType();\n\n      // Build vector (integer) scalar operands may need implicit\n      // truncation - do this before constant folding.\n      if (ScalarVT.isInteger() && ScalarVT.bitsGT(InSVT))\n        ScalarOp = getNode(ISD::TRUNCATE, DL, InSVT, ScalarOp);\n\n      ScalarOps.push_back(ScalarOp);\n    }\n\n    // Constant fold the scalar operands.\n    SDValue ScalarResult = getNode(Opcode, DL, SVT, ScalarOps, Flags);\n\n    // Legalize the (integer) scalar constant if necessary.\n    if (LegalSVT != SVT)\n      ScalarResult = getNode(ISD::SIGN_EXTEND, DL, LegalSVT, ScalarResult);\n\n    // Scalar folding only succeeded if the result is a constant or UNDEF.\n    if (!ScalarResult.isUndef() && ScalarResult.getOpcode() != ISD::Constant &&\n        ScalarResult.getOpcode() != ISD::ConstantFP)\n      return SDValue();\n    ScalarResults.push_back(ScalarResult);\n  }\n\n  SDValue V = getBuildVector(VT, DL, ScalarResults);\n  NewSDValueDbgMsg(V, \"New node fold constant vector: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::foldConstantFPMath(unsigned Opcode, const SDLoc &DL,\n                                         EVT VT, SDValue N1, SDValue N2) {\n  // TODO: We don't do any constant folding for strict FP opcodes here, but we\n  //       should. That will require dealing with a potentially non-default\n  //       rounding mode, checking the \"opStatus\" return value from the APFloat\n  //       math calculations, and possibly other variations.\n  auto *N1CFP = dyn_cast<ConstantFPSDNode>(N1.getNode());\n  auto *N2CFP = dyn_cast<ConstantFPSDNode>(N2.getNode());\n  if (N1CFP && N2CFP) {\n    APFloat C1 = N1CFP->getValueAPF(), C2 = N2CFP->getValueAPF();\n    switch (Opcode) {\n    case ISD::FADD:\n      C1.add(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FSUB:\n      C1.subtract(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FMUL:\n      C1.multiply(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FDIV:\n      C1.divide(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FREM:\n      C1.mod(C2);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FCOPYSIGN:\n      C1.copySign(C2);\n      return getConstantFP(C1, DL, VT);\n    default: break;\n    }\n  }\n  if (N1CFP && Opcode == ISD::FP_ROUND) {\n    APFloat C1 = N1CFP->getValueAPF();    // make copy\n    bool Unused;\n    // This can return overflow, underflow, or inexact; we don't care.\n    // FIXME need to be more flexible about rounding mode.\n    (void) C1.convert(EVTToAPFloatSemantics(VT), APFloat::rmNearestTiesToEven,\n                      &Unused);\n    return getConstantFP(C1, DL, VT);\n  }\n\n  switch (Opcode) {\n  case ISD::FSUB:\n    // -0.0 - undef --> undef (consistent with \"fneg undef\")\n    if (N1CFP && N1CFP->getValueAPF().isNegZero() && N2.isUndef())\n      return getUNDEF(VT);\n    LLVM_FALLTHROUGH;\n\n  case ISD::FADD:\n  case ISD::FMUL:\n  case ISD::FDIV:\n  case ISD::FREM:\n    // If both operands are undef, the result is undef. If 1 operand is undef,\n    // the result is NaN. This should match the behavior of the IR optimizer.\n    if (N1.isUndef() && N2.isUndef())\n      return getUNDEF(VT);\n    if (N1.isUndef() || N2.isUndef())\n      return getConstantFP(APFloat::getNaN(EVTToAPFloatSemantics(VT)), DL, VT);\n  }\n  return SDValue();\n}\n\nSDValue SelectionDAG::getAssertAlign(const SDLoc &DL, SDValue Val, Align A) {\n  assert(Val.getValueType().isInteger() && \"Invalid AssertAlign!\");\n\n  // There's no need to assert on a byte-aligned pointer. All pointers are at\n  // least byte aligned.\n  if (A == Align(1))\n    return Val;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::AssertAlign, getVTList(Val.getValueType()), {Val});\n  ID.AddInteger(A.value());\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<AssertAlignSDNode>(DL.getIROrder(), DL.getDebugLoc(),\n                                         Val.getValueType(), A);\n  createOperands(N, {Val});\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, N1, N2, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, const SDNodeFlags Flags) {\n  assert(N1.getOpcode() != ISD::DELETED_NODE &&\n         N2.getOpcode() != ISD::DELETED_NODE &&\n         \"Operand is DELETED_NODE!\");\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  ConstantSDNode *N2C = dyn_cast<ConstantSDNode>(N2);\n  ConstantFPSDNode *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n  ConstantFPSDNode *N2CFP = dyn_cast<ConstantFPSDNode>(N2);\n\n  // Canonicalize constant to RHS if commutative.\n  if (TLI->isCommutativeBinOp(Opcode)) {\n    if (N1C && !N2C) {\n      std::swap(N1C, N2C);\n      std::swap(N1, N2);\n    } else if (N1CFP && !N2CFP) {\n      std::swap(N1CFP, N2CFP);\n      std::swap(N1, N2);\n    }\n  }\n\n  switch (Opcode) {\n  default: break;\n  case ISD::TokenFactor:\n    assert(VT == MVT::Other && N1.getValueType() == MVT::Other &&\n           N2.getValueType() == MVT::Other && \"Invalid token factor!\");\n    // Fold trivial token factors.\n    if (N1.getOpcode() == ISD::EntryToken) return N2;\n    if (N2.getOpcode() == ISD::EntryToken) return N1;\n    if (N1 == N2) return N1;\n    break;\n  case ISD::BUILD_VECTOR: {\n    // Attempt to simplify BUILD_VECTOR.\n    SDValue Ops[] = {N1, N2};\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    SDValue Ops[] = {N1, N2};\n    if (SDValue V = foldCONCAT_VECTORS(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::AND:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    // (X & 0) -> 0.  This commonly occurs when legalizing i64 values, so it's\n    // worth handling here.\n    if (N2C && N2C->isNullValue())\n      return N2;\n    if (N2C && N2C->isAllOnesValue())  // X & -1 -> X\n      return N1;\n    break;\n  case ISD::OR:\n  case ISD::XOR:\n  case ISD::ADD:\n  case ISD::SUB:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    // (X ^|+- 0) -> X.  This commonly occurs when legalizing i64 values, so\n    // it's worth handling here.\n    if (N2C && N2C->isNullValue())\n      return N1;\n    if ((Opcode == ISD::ADD || Opcode == ISD::SUB) && VT.isVector() &&\n        VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::XOR, DL, VT, N1, N2);\n    break;\n  case ISD::MUL:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::AND, DL, VT, N1, N2);\n    if (N2C && (N1.getOpcode() == ISD::VSCALE) && Flags.hasNoSignedWrap()) {\n      const APInt &MulImm = N1->getConstantOperandAPInt(0);\n      const APInt &N2CImm = N2C->getAPIntValue();\n      return getVScale(DL, VT, MulImm * N2CImm);\n    }\n    break;\n  case ISD::UDIV:\n  case ISD::UREM:\n  case ISD::MULHU:\n  case ISD::MULHS:\n  case ISD::SDIV:\n  case ISD::SREM:\n  case ISD::SADDSAT:\n  case ISD::SSUBSAT:\n  case ISD::UADDSAT:\n  case ISD::USUBSAT:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1) {\n      // fold (add_sat x, y) -> (or x, y) for bool types.\n      if (Opcode == ISD::SADDSAT || Opcode == ISD::UADDSAT)\n        return getNode(ISD::OR, DL, VT, N1, N2);\n      // fold (sub_sat x, y) -> (and x, ~y) for bool types.\n      if (Opcode == ISD::SSUBSAT || Opcode == ISD::USUBSAT)\n        return getNode(ISD::AND, DL, VT, N1, getNOT(DL, N2, VT));\n    }\n    break;\n  case ISD::SMIN:\n  case ISD::UMAX:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::OR, DL, VT, N1, N2);\n    break;\n  case ISD::SMAX:\n  case ISD::UMIN:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::AND, DL, VT, N1, N2);\n    break;\n  case ISD::FADD:\n  case ISD::FSUB:\n  case ISD::FMUL:\n  case ISD::FDIV:\n  case ISD::FREM:\n    assert(VT.isFloatingPoint() && \"This operator only applies to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (SDValue V = simplifyFPBinop(Opcode, N1, N2, Flags))\n      return V;\n    break;\n  case ISD::FCOPYSIGN:   // N1 and result must match.  N1/N2 need not match.\n    assert(N1.getValueType() == VT &&\n           N1.getValueType().isFloatingPoint() &&\n           N2.getValueType().isFloatingPoint() &&\n           \"Invalid FCOPYSIGN!\");\n    break;\n  case ISD::SHL:\n    if (N2C && (N1.getOpcode() == ISD::VSCALE) && Flags.hasNoSignedWrap()) {\n      const APInt &MulImm = N1->getConstantOperandAPInt(0);\n      const APInt &ShiftImm = N2C->getAPIntValue();\n      return getVScale(DL, VT, MulImm << ShiftImm);\n    }\n    LLVM_FALLTHROUGH;\n  case ISD::SRA:\n  case ISD::SRL:\n    if (SDValue V = simplifyShift(N1, N2))\n      return V;\n    LLVM_FALLTHROUGH;\n  case ISD::ROTL:\n  case ISD::ROTR:\n    assert(VT == N1.getValueType() &&\n           \"Shift operators return type must be the same as their first arg\");\n    assert(VT.isInteger() && N2.getValueType().isInteger() &&\n           \"Shifts only work on integers\");\n    assert((!VT.isVector() || VT == N2.getValueType()) &&\n           \"Vector shift amounts must be in the same as their first arg\");\n    // Verify that the shift amount VT is big enough to hold valid shift\n    // amounts.  This catches things like trying to shift an i1024 value by an\n    // i8, which is easy to fall into in generic code that uses\n    // TLI.getShiftAmount().\n    assert(N2.getValueType().getScalarSizeInBits() >=\n               Log2_32_Ceil(VT.getScalarSizeInBits()) &&\n           \"Invalid use of small shift amount with oversized value!\");\n\n    // Always fold shifts of i1 values so the code generator doesn't need to\n    // handle them.  Since we know the size of the shift has to be less than the\n    // size of the value, the shift/rotate count is guaranteed to be zero.\n    if (VT == MVT::i1)\n      return N1;\n    if (N2C && N2C->isNullValue())\n      return N1;\n    break;\n  case ISD::FP_ROUND:\n    assert(VT.isFloatingPoint() &&\n           N1.getValueType().isFloatingPoint() &&\n           VT.bitsLE(N1.getValueType()) &&\n           N2C && (N2C->getZExtValue() == 0 || N2C->getZExtValue() == 1) &&\n           \"Invalid FP_ROUND!\");\n    if (N1.getValueType() == VT) return N1;  // noop conversion.\n    break;\n  case ISD::AssertSext:\n  case ISD::AssertZext: {\n    EVT EVT = cast<VTSDNode>(N2)->getVT();\n    assert(VT == N1.getValueType() && \"Not an inreg extend!\");\n    assert(VT.isInteger() && EVT.isInteger() &&\n           \"Cannot *_EXTEND_INREG FP types\");\n    assert(!EVT.isVector() &&\n           \"AssertSExt/AssertZExt type should be the vector element type \"\n           \"rather than the vector type!\");\n    assert(EVT.bitsLE(VT.getScalarType()) && \"Not extending!\");\n    if (VT.getScalarType() == EVT) return N1; // noop assertion.\n    break;\n  }\n  case ISD::SIGN_EXTEND_INREG: {\n    EVT EVT = cast<VTSDNode>(N2)->getVT();\n    assert(VT == N1.getValueType() && \"Not an inreg extend!\");\n    assert(VT.isInteger() && EVT.isInteger() &&\n           \"Cannot *_EXTEND_INREG FP types\");\n    assert(EVT.isVector() == VT.isVector() &&\n           \"SIGN_EXTEND_INREG type should be vector iff the operand \"\n           \"type is vector!\");\n    assert((!EVT.isVector() ||\n            EVT.getVectorElementCount() == VT.getVectorElementCount()) &&\n           \"Vector element counts must match in SIGN_EXTEND_INREG\");\n    assert(EVT.bitsLE(VT) && \"Not extending!\");\n    if (EVT == VT) return N1;  // Not actually extending\n\n    auto SignExtendInReg = [&](APInt Val, llvm::EVT ConstantVT) {\n      unsigned FromBits = EVT.getScalarSizeInBits();\n      Val <<= Val.getBitWidth() - FromBits;\n      Val.ashrInPlace(Val.getBitWidth() - FromBits);\n      return getConstant(Val, DL, ConstantVT);\n    };\n\n    if (N1C) {\n      const APInt &Val = N1C->getAPIntValue();\n      return SignExtendInReg(Val, VT);\n    }\n    if (ISD::isBuildVectorOfConstantSDNodes(N1.getNode())) {\n      SmallVector<SDValue, 8> Ops;\n      llvm::EVT OpVT = N1.getOperand(0).getValueType();\n      for (int i = 0, e = VT.getVectorNumElements(); i != e; ++i) {\n        SDValue Op = N1.getOperand(i);\n        if (Op.isUndef()) {\n          Ops.push_back(getUNDEF(OpVT));\n          continue;\n        }\n        ConstantSDNode *C = cast<ConstantSDNode>(Op);\n        APInt Val = C->getAPIntValue();\n        Ops.push_back(SignExtendInReg(Val, OpVT));\n      }\n      return getBuildVector(VT, DL, Ops);\n    }\n    break;\n  }\n  case ISD::EXTRACT_VECTOR_ELT:\n    assert(VT.getSizeInBits() >= N1.getValueType().getScalarSizeInBits() &&\n           \"The result of EXTRACT_VECTOR_ELT must be at least as wide as the \\\n             element type of the vector.\");\n\n    // Extract from an undefined value or using an undefined index is undefined.\n    if (N1.isUndef() || N2.isUndef())\n      return getUNDEF(VT);\n\n    // EXTRACT_VECTOR_ELT of out-of-bounds element is an UNDEF for fixed length\n    // vectors. For scalable vectors we will provide appropriate support for\n    // dealing with arbitrary indices.\n    if (N2C && N1.getValueType().isFixedLengthVector() &&\n        N2C->getAPIntValue().uge(N1.getValueType().getVectorNumElements()))\n      return getUNDEF(VT);\n\n    // EXTRACT_VECTOR_ELT of CONCAT_VECTORS is often formed while lowering is\n    // expanding copies of large vectors from registers. This only works for\n    // fixed length vectors, since we need to know the exact number of\n    // elements.\n    if (N2C && N1.getOperand(0).getValueType().isFixedLengthVector() &&\n        N1.getOpcode() == ISD::CONCAT_VECTORS && N1.getNumOperands() > 0) {\n      unsigned Factor =\n        N1.getOperand(0).getValueType().getVectorNumElements();\n      return getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT,\n                     N1.getOperand(N2C->getZExtValue() / Factor),\n                     getVectorIdxConstant(N2C->getZExtValue() % Factor, DL));\n    }\n\n    // EXTRACT_VECTOR_ELT of BUILD_VECTOR or SPLAT_VECTOR is often formed while\n    // lowering is expanding large vector constants.\n    if (N2C && (N1.getOpcode() == ISD::BUILD_VECTOR ||\n                N1.getOpcode() == ISD::SPLAT_VECTOR)) {\n      assert((N1.getOpcode() != ISD::BUILD_VECTOR ||\n              N1.getValueType().isFixedLengthVector()) &&\n             \"BUILD_VECTOR used for scalable vectors\");\n      unsigned Index =\n          N1.getOpcode() == ISD::BUILD_VECTOR ? N2C->getZExtValue() : 0;\n      SDValue Elt = N1.getOperand(Index);\n\n      if (VT != Elt.getValueType())\n        // If the vector element type is not legal, the BUILD_VECTOR operands\n        // are promoted and implicitly truncated, and the result implicitly\n        // extended. Make that explicit here.\n        Elt = getAnyExtOrTrunc(Elt, DL, VT);\n\n      return Elt;\n    }\n\n    // EXTRACT_VECTOR_ELT of INSERT_VECTOR_ELT is often formed when vector\n    // operations are lowered to scalars.\n    if (N1.getOpcode() == ISD::INSERT_VECTOR_ELT) {\n      // If the indices are the same, return the inserted element else\n      // if the indices are known different, extract the element from\n      // the original vector.\n      SDValue N1Op2 = N1.getOperand(2);\n      ConstantSDNode *N1Op2C = dyn_cast<ConstantSDNode>(N1Op2);\n\n      if (N1Op2C && N2C) {\n        if (N1Op2C->getZExtValue() == N2C->getZExtValue()) {\n          if (VT == N1.getOperand(1).getValueType())\n            return N1.getOperand(1);\n          else\n            return getSExtOrTrunc(N1.getOperand(1), DL, VT);\n        }\n\n        return getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT, N1.getOperand(0), N2);\n      }\n    }\n\n    // EXTRACT_VECTOR_ELT of v1iX EXTRACT_SUBVECTOR could be formed\n    // when vector types are scalarized and v1iX is legal.\n    // vextract (v1iX extract_subvector(vNiX, Idx)) -> vextract(vNiX,Idx).\n    // Here we are completely ignoring the extract element index (N2),\n    // which is fine for fixed width vectors, since any index other than 0\n    // is undefined anyway. However, this cannot be ignored for scalable\n    // vectors - in theory we could support this, but we don't want to do this\n    // without a profitability check.\n    if (N1.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        N1.getValueType().isFixedLengthVector() &&\n        N1.getValueType().getVectorNumElements() == 1) {\n      return getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT, N1.getOperand(0),\n                     N1.getOperand(1));\n    }\n    break;\n  case ISD::EXTRACT_ELEMENT:\n    assert(N2C && (unsigned)N2C->getZExtValue() < 2 && \"Bad EXTRACT_ELEMENT!\");\n    assert(!N1.getValueType().isVector() && !VT.isVector() &&\n           (N1.getValueType().isInteger() == VT.isInteger()) &&\n           N1.getValueType() != VT &&\n           \"Wrong types for EXTRACT_ELEMENT!\");\n\n    // EXTRACT_ELEMENT of BUILD_PAIR is often formed while legalize is expanding\n    // 64-bit integers into 32-bit parts.  Instead of building the extract of\n    // the BUILD_PAIR, only to have legalize rip it apart, just do it now.\n    if (N1.getOpcode() == ISD::BUILD_PAIR)\n      return N1.getOperand(N2C->getZExtValue());\n\n    // EXTRACT_ELEMENT of a constant int is also very common.\n    if (N1C) {\n      unsigned ElementSize = VT.getSizeInBits();\n      unsigned Shift = ElementSize * N2C->getZExtValue();\n      const APInt &Val = N1C->getAPIntValue();\n      return getConstant(Val.extractBits(ElementSize, Shift), DL, VT);\n    }\n    break;\n  case ISD::EXTRACT_SUBVECTOR:\n    EVT N1VT = N1.getValueType();\n    assert(VT.isVector() && N1VT.isVector() &&\n           \"Extract subvector VTs must be vectors!\");\n    assert(VT.getVectorElementType() == N1VT.getVectorElementType() &&\n           \"Extract subvector VTs must have the same element type!\");\n    assert((VT.isFixedLengthVector() || N1VT.isScalableVector()) &&\n           \"Cannot extract a scalable vector from a fixed length vector!\");\n    assert((VT.isScalableVector() != N1VT.isScalableVector() ||\n            VT.getVectorMinNumElements() <= N1VT.getVectorMinNumElements()) &&\n           \"Extract subvector must be from larger vector to smaller vector!\");\n    assert(N2C && \"Extract subvector index must be a constant\");\n    assert((VT.isScalableVector() != N1VT.isScalableVector() ||\n            (VT.getVectorMinNumElements() + N2C->getZExtValue()) <=\n                N1VT.getVectorMinNumElements()) &&\n           \"Extract subvector overflow!\");\n    assert(N2C->getAPIntValue().getBitWidth() ==\n               TLI->getVectorIdxTy(getDataLayout()).getFixedSizeInBits() &&\n           \"Constant index for EXTRACT_SUBVECTOR has an invalid size\");\n\n    // Trivial extraction.\n    if (VT == N1VT)\n      return N1;\n\n    // EXTRACT_SUBVECTOR of an UNDEF is an UNDEF.\n    if (N1.isUndef())\n      return getUNDEF(VT);\n\n    // EXTRACT_SUBVECTOR of CONCAT_VECTOR can be simplified if the pieces of\n    // the concat have the same type as the extract.\n    if (N1.getOpcode() == ISD::CONCAT_VECTORS && N1.getNumOperands() > 0 &&\n        VT == N1.getOperand(0).getValueType()) {\n      unsigned Factor = VT.getVectorMinNumElements();\n      return N1.getOperand(N2C->getZExtValue() / Factor);\n    }\n\n    // EXTRACT_SUBVECTOR of INSERT_SUBVECTOR is often created\n    // during shuffle legalization.\n    if (N1.getOpcode() == ISD::INSERT_SUBVECTOR && N2 == N1.getOperand(2) &&\n        VT == N1.getOperand(1).getValueType())\n      return N1.getOperand(1);\n    break;\n  }\n\n  // Perform trivial constant folding.\n  if (SDValue SV = FoldConstantArithmetic(Opcode, DL, VT, {N1, N2}))\n    return SV;\n\n  if (SDValue V = foldConstantFPMath(Opcode, DL, VT, N1, N2))\n    return V;\n\n  // Canonicalize an UNDEF to the RHS, even over a constant.\n  if (N1.isUndef()) {\n    if (TLI->isCommutativeBinOp(Opcode)) {\n      std::swap(N1, N2);\n    } else {\n      switch (Opcode) {\n      case ISD::SIGN_EXTEND_INREG:\n      case ISD::SUB:\n        return getUNDEF(VT);     // fold op(undef, arg2) -> undef\n      case ISD::UDIV:\n      case ISD::SDIV:\n      case ISD::UREM:\n      case ISD::SREM:\n      case ISD::SSUBSAT:\n      case ISD::USUBSAT:\n        return getConstant(0, DL, VT);    // fold op(undef, arg2) -> 0\n      }\n    }\n  }\n\n  // Fold a bunch of operators when the RHS is undef.\n  if (N2.isUndef()) {\n    switch (Opcode) {\n    case ISD::XOR:\n      if (N1.isUndef())\n        // Handle undef ^ undef -> 0 special case. This is a common\n        // idiom (misuse).\n        return getConstant(0, DL, VT);\n      LLVM_FALLTHROUGH;\n    case ISD::ADD:\n    case ISD::SUB:\n    case ISD::UDIV:\n    case ISD::SDIV:\n    case ISD::UREM:\n    case ISD::SREM:\n      return getUNDEF(VT);       // fold op(arg1, undef) -> undef\n    case ISD::MUL:\n    case ISD::AND:\n    case ISD::SSUBSAT:\n    case ISD::USUBSAT:\n      return getConstant(0, DL, VT);  // fold op(arg1, undef) -> 0\n    case ISD::OR:\n    case ISD::SADDSAT:\n    case ISD::UADDSAT:\n      return getAllOnesConstant(DL, VT);\n    }\n  }\n\n  // Memoize this node if possible.\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = {N1, N2};\n  if (VT != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      E->intersectFlagsWith(Flags);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    N->setFlags(Flags);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, N1, N2, N3, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3,\n                              const SDNodeFlags Flags) {\n  assert(N1.getOpcode() != ISD::DELETED_NODE &&\n         N2.getOpcode() != ISD::DELETED_NODE &&\n         N3.getOpcode() != ISD::DELETED_NODE &&\n         \"Operand is DELETED_NODE!\");\n  // Perform various simplifications.\n  switch (Opcode) {\n  case ISD::FMA: {\n    assert(VT.isFloatingPoint() && \"This operator only applies to FP types!\");\n    assert(N1.getValueType() == VT && N2.getValueType() == VT &&\n           N3.getValueType() == VT && \"FMA types must match!\");\n    ConstantFPSDNode *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n    ConstantFPSDNode *N2CFP = dyn_cast<ConstantFPSDNode>(N2);\n    ConstantFPSDNode *N3CFP = dyn_cast<ConstantFPSDNode>(N3);\n    if (N1CFP && N2CFP && N3CFP) {\n      APFloat  V1 = N1CFP->getValueAPF();\n      const APFloat &V2 = N2CFP->getValueAPF();\n      const APFloat &V3 = N3CFP->getValueAPF();\n      V1.fusedMultiplyAdd(V2, V3, APFloat::rmNearestTiesToEven);\n      return getConstantFP(V1, DL, VT);\n    }\n    break;\n  }\n  case ISD::BUILD_VECTOR: {\n    // Attempt to simplify BUILD_VECTOR.\n    SDValue Ops[] = {N1, N2, N3};\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    SDValue Ops[] = {N1, N2, N3};\n    if (SDValue V = foldCONCAT_VECTORS(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::SETCC: {\n    assert(VT.isInteger() && \"SETCC result type must be an integer!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           \"SETCC operands must have the same type!\");\n    assert(VT.isVector() == N1.getValueType().isVector() &&\n           \"SETCC type should be vector iff the operand type is vector!\");\n    assert((!VT.isVector() || VT.getVectorElementCount() ==\n                                  N1.getValueType().getVectorElementCount()) &&\n           \"SETCC vector element counts must match!\");\n    // Use FoldSetCC to simplify SETCC's.\n    if (SDValue V = FoldSetCC(VT, N1, N2, cast<CondCodeSDNode>(N3)->get(), DL))\n      return V;\n    // Vector constant folding.\n    SDValue Ops[] = {N1, N2, N3};\n    if (SDValue V = FoldConstantVectorArithmetic(Opcode, DL, VT, Ops)) {\n      NewSDValueDbgMsg(V, \"New node vector constant folding: \", this);\n      return V;\n    }\n    break;\n  }\n  case ISD::SELECT:\n  case ISD::VSELECT:\n    if (SDValue V = simplifySelect(N1, N2, N3))\n      return V;\n    break;\n  case ISD::VECTOR_SHUFFLE:\n    llvm_unreachable(\"should use getVectorShuffle constructor!\");\n  case ISD::INSERT_VECTOR_ELT: {\n    ConstantSDNode *N3C = dyn_cast<ConstantSDNode>(N3);\n    // INSERT_VECTOR_ELT into out-of-bounds element is an UNDEF, except\n    // for scalable vectors where we will generate appropriate code to\n    // deal with out-of-bounds cases correctly.\n    if (N3C && N1.getValueType().isFixedLengthVector() &&\n        N3C->getZExtValue() >= N1.getValueType().getVectorNumElements())\n      return getUNDEF(VT);\n\n    // Undefined index can be assumed out-of-bounds, so that's UNDEF too.\n    if (N3.isUndef())\n      return getUNDEF(VT);\n\n    // If the inserted element is an UNDEF, just use the input vector.\n    if (N2.isUndef())\n      return N1;\n\n    break;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Inserting undef into undef is still undef.\n    if (N1.isUndef() && N2.isUndef())\n      return getUNDEF(VT);\n\n    EVT N2VT = N2.getValueType();\n    assert(VT == N1.getValueType() &&\n           \"Dest and insert subvector source types must match!\");\n    assert(VT.isVector() && N2VT.isVector() &&\n           \"Insert subvector VTs must be vectors!\");\n    assert((VT.isScalableVector() || N2VT.isFixedLengthVector()) &&\n           \"Cannot insert a scalable vector into a fixed length vector!\");\n    assert((VT.isScalableVector() != N2VT.isScalableVector() ||\n            VT.getVectorMinNumElements() >= N2VT.getVectorMinNumElements()) &&\n           \"Insert subvector must be from smaller vector to larger vector!\");\n    assert(isa<ConstantSDNode>(N3) &&\n           \"Insert subvector index must be constant\");\n    assert((VT.isScalableVector() != N2VT.isScalableVector() ||\n            (N2VT.getVectorMinNumElements() +\n             cast<ConstantSDNode>(N3)->getZExtValue()) <=\n                VT.getVectorMinNumElements()) &&\n           \"Insert subvector overflow!\");\n    assert(cast<ConstantSDNode>(N3)->getAPIntValue().getBitWidth() ==\n               TLI->getVectorIdxTy(getDataLayout()).getFixedSizeInBits() &&\n           \"Constant index for INSERT_SUBVECTOR has an invalid size\");\n\n    // Trivial insertion.\n    if (VT == N2VT)\n      return N2;\n\n    // If this is an insert of an extracted vector into an undef vector, we\n    // can just use the input to the extract.\n    if (N1.isUndef() && N2.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        N2.getOperand(1) == N3 && N2.getOperand(0).getValueType() == VT)\n      return N2.getOperand(0);\n    break;\n  }\n  case ISD::BITCAST:\n    // Fold bit_convert nodes from a type to themselves.\n    if (N1.getValueType() == VT)\n      return N1;\n    break;\n  }\n\n  // Memoize node if it doesn't produce a flag.\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = {N1, N2, N3};\n  if (VT != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      E->intersectFlagsWith(Flags);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    N->setFlags(Flags);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4) {\n  SDValue Ops[] = { N1, N2, N3, N4 };\n  return getNode(Opcode, DL, VT, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4,\n                              SDValue N5) {\n  SDValue Ops[] = { N1, N2, N3, N4, N5 };\n  return getNode(Opcode, DL, VT, Ops);\n}\n\n/// getStackArgumentTokenFactor - Compute a TokenFactor to force all\n/// the incoming stack arguments to be loaded from the stack.\nSDValue SelectionDAG::getStackArgumentTokenFactor(SDValue Chain) {\n  SmallVector<SDValue, 8> ArgChains;\n\n  // Include the original chain at the beginning of the list. When this is\n  // used by target LowerCall hooks, this helps legalize find the\n  // CALLSEQ_BEGIN node.\n  ArgChains.push_back(Chain);\n\n  // Add a chain value for each stack argument.\n  for (SDNode::use_iterator U = getEntryNode().getNode()->use_begin(),\n       UE = getEntryNode().getNode()->use_end(); U != UE; ++U)\n    if (LoadSDNode *L = dyn_cast<LoadSDNode>(*U))\n      if (FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(L->getBasePtr()))\n        if (FI->getIndex() < 0)\n          ArgChains.push_back(SDValue(L, 1));\n\n  // Build a tokenfactor for all the chains.\n  return getNode(ISD::TokenFactor, SDLoc(Chain), MVT::Other, ArgChains);\n}\n\n/// getMemsetValue - Vectorized representation of the memset value\n/// operand.\nstatic SDValue getMemsetValue(SDValue Value, EVT VT, SelectionDAG &DAG,\n                              const SDLoc &dl) {\n  assert(!Value.isUndef());\n\n  unsigned NumBits = VT.getScalarSizeInBits();\n  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Value)) {\n    assert(C->getAPIntValue().getBitWidth() == 8);\n    APInt Val = APInt::getSplat(NumBits, C->getAPIntValue());\n    if (VT.isInteger()) {\n      bool IsOpaque = VT.getSizeInBits() > 64 ||\n          !DAG.getTargetLoweringInfo().isLegalStoreImmediate(C->getSExtValue());\n      return DAG.getConstant(Val, dl, VT, false, IsOpaque);\n    }\n    return DAG.getConstantFP(APFloat(DAG.EVTToAPFloatSemantics(VT), Val), dl,\n                             VT);\n  }\n\n  assert(Value.getValueType() == MVT::i8 && \"memset with non-byte fill value?\");\n  EVT IntVT = VT.getScalarType();\n  if (!IntVT.isInteger())\n    IntVT = EVT::getIntegerVT(*DAG.getContext(), IntVT.getSizeInBits());\n\n  Value = DAG.getNode(ISD::ZERO_EXTEND, dl, IntVT, Value);\n  if (NumBits > 8) {\n    // Use a multiplication with 0x010101... to extend the input to the\n    // required length.\n    APInt Magic = APInt::getSplat(NumBits, APInt(8, 0x01));\n    Value = DAG.getNode(ISD::MUL, dl, IntVT, Value,\n                        DAG.getConstant(Magic, dl, IntVT));\n  }\n\n  if (VT != Value.getValueType() && !VT.isInteger())\n    Value = DAG.getBitcast(VT.getScalarType(), Value);\n  if (VT != Value.getValueType())\n    Value = DAG.getSplatBuildVector(VT, dl, Value);\n\n  return Value;\n}\n\n/// getMemsetStringVal - Similar to getMemsetValue. Except this is only\n/// used when a memcpy is turned into a memset when the source is a constant\n/// string ptr.\nstatic SDValue getMemsetStringVal(EVT VT, const SDLoc &dl, SelectionDAG &DAG,\n                                  const TargetLowering &TLI,\n                                  const ConstantDataArraySlice &Slice) {\n  // Handle vector with all elements zero.\n  if (Slice.Array == nullptr) {\n    if (VT.isInteger())\n      return DAG.getConstant(0, dl, VT);\n    else if (VT == MVT::f32 || VT == MVT::f64 || VT == MVT::f128)\n      return DAG.getConstantFP(0.0, dl, VT);\n    else if (VT.isVector()) {\n      unsigned NumElts = VT.getVectorNumElements();\n      MVT EltVT = (VT.getVectorElementType() == MVT::f32) ? MVT::i32 : MVT::i64;\n      return DAG.getNode(ISD::BITCAST, dl, VT,\n                         DAG.getConstant(0, dl,\n                                         EVT::getVectorVT(*DAG.getContext(),\n                                                          EltVT, NumElts)));\n    } else\n      llvm_unreachable(\"Expected type!\");\n  }\n\n  assert(!VT.isVector() && \"Can't handle vector type here!\");\n  unsigned NumVTBits = VT.getSizeInBits();\n  unsigned NumVTBytes = NumVTBits / 8;\n  unsigned NumBytes = std::min(NumVTBytes, unsigned(Slice.Length));\n\n  APInt Val(NumVTBits, 0);\n  if (DAG.getDataLayout().isLittleEndian()) {\n    for (unsigned i = 0; i != NumBytes; ++i)\n      Val |= (uint64_t)(unsigned char)Slice[i] << i*8;\n  } else {\n    for (unsigned i = 0; i != NumBytes; ++i)\n      Val |= (uint64_t)(unsigned char)Slice[i] << (NumVTBytes-i-1)*8;\n  }\n\n  // If the \"cost\" of materializing the integer immediate is less than the cost\n  // of a load, then it is cost effective to turn the load into the immediate.\n  Type *Ty = VT.getTypeForEVT(*DAG.getContext());\n  if (TLI.shouldConvertConstantLoadToIntImm(Val, Ty))\n    return DAG.getConstant(Val, dl, VT);\n  return SDValue(nullptr, 0);\n}\n\nSDValue SelectionDAG::getMemBasePlusOffset(SDValue Base, TypeSize Offset,\n                                           const SDLoc &DL,\n                                           const SDNodeFlags Flags) {\n  EVT VT = Base.getValueType();\n  SDValue Index;\n\n  if (Offset.isScalable())\n    Index = getVScale(DL, Base.getValueType(),\n                      APInt(Base.getValueSizeInBits().getFixedSize(),\n                            Offset.getKnownMinSize()));\n  else\n    Index = getConstant(Offset.getFixedSize(), DL, VT);\n\n  return getMemBasePlusOffset(Base, Index, DL, Flags);\n}\n\nSDValue SelectionDAG::getMemBasePlusOffset(SDValue Ptr, SDValue Offset,\n                                           const SDLoc &DL,\n                                           const SDNodeFlags Flags) {\n  assert(Offset.getValueType().isInteger());\n  EVT BasePtrVT = Ptr.getValueType();\n  return getNode(ISD::ADD, DL, BasePtrVT, Ptr, Offset, Flags);\n}\n\n/// Returns true if memcpy source is constant data.\nstatic bool isMemSrcFromConstant(SDValue Src, ConstantDataArraySlice &Slice) {\n  uint64_t SrcDelta = 0;\n  GlobalAddressSDNode *G = nullptr;\n  if (Src.getOpcode() == ISD::GlobalAddress)\n    G = cast<GlobalAddressSDNode>(Src);\n  else if (Src.getOpcode() == ISD::ADD &&\n           Src.getOperand(0).getOpcode() == ISD::GlobalAddress &&\n           Src.getOperand(1).getOpcode() == ISD::Constant) {\n    G = cast<GlobalAddressSDNode>(Src.getOperand(0));\n    SrcDelta = cast<ConstantSDNode>(Src.getOperand(1))->getZExtValue();\n  }\n  if (!G)\n    return false;\n\n  return getConstantDataArrayInfo(G->getGlobal(), Slice, 8,\n                                  SrcDelta + G->getOffset());\n}\n\nstatic bool shouldLowerMemFuncForSize(const MachineFunction &MF,\n                                      SelectionDAG &DAG) {\n  // On Darwin, -Os means optimize for size without hurting performance, so\n  // only really optimize for size when -Oz (MinSize) is used.\n  if (MF.getTarget().getTargetTriple().isOSDarwin())\n    return MF.getFunction().hasMinSize();\n  return DAG.shouldOptForSize();\n}\n\nstatic void chainLoadsAndStoresForMemcpy(SelectionDAG &DAG, const SDLoc &dl,\n                          SmallVector<SDValue, 32> &OutChains, unsigned From,\n                          unsigned To, SmallVector<SDValue, 16> &OutLoadChains,\n                          SmallVector<SDValue, 16> &OutStoreChains) {\n  assert(OutLoadChains.size() && \"Missing loads in memcpy inlining\");\n  assert(OutStoreChains.size() && \"Missing stores in memcpy inlining\");\n  SmallVector<SDValue, 16> GluedLoadChains;\n  for (unsigned i = From; i < To; ++i) {\n    OutChains.push_back(OutLoadChains[i]);\n    GluedLoadChains.push_back(OutLoadChains[i]);\n  }\n\n  // Chain for all loads.\n  SDValue LoadToken = DAG.getNode(ISD::TokenFactor, dl, MVT::Other,\n                                  GluedLoadChains);\n\n  for (unsigned i = From; i < To; ++i) {\n    StoreSDNode *ST = dyn_cast<StoreSDNode>(OutStoreChains[i]);\n    SDValue NewStore = DAG.getTruncStore(LoadToken, dl, ST->getValue(),\n                                  ST->getBasePtr(), ST->getMemoryVT(),\n                                  ST->getMemOperand());\n    OutChains.push_back(NewStore);\n  }\n}\n\nstatic SDValue getMemcpyLoadsAndStores(SelectionDAG &DAG, const SDLoc &dl,\n                                       SDValue Chain, SDValue Dst, SDValue Src,\n                                       uint64_t Size, Align Alignment,\n                                       bool isVol, bool AlwaysInline,\n                                       MachinePointerInfo DstPtrInfo,\n                                       MachinePointerInfo SrcPtrInfo) {\n  // Turn a memcpy of undef to nop.\n  // FIXME: We need to honor volatile even is Src is undef.\n  if (Src.isUndef())\n    return Chain;\n\n  // Expand memcpy to a series of load and store ops if the size operand falls\n  // below a certain threshold.\n  // TODO: In the AlwaysInline case, if the size is big then generate a loop\n  // rather than maybe a humongous number of loads and stores.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  const DataLayout &DL = DAG.getDataLayout();\n  LLVMContext &C = *DAG.getContext();\n  std::vector<EVT> MemOps;\n  bool DstAlignCanChange = false;\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineFrameInfo &MFI = MF.getFrameInfo();\n  bool OptSize = shouldLowerMemFuncForSize(MF, DAG);\n  FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Dst);\n  if (FI && !MFI.isFixedObjectIndex(FI->getIndex()))\n    DstAlignCanChange = true;\n  MaybeAlign SrcAlign = DAG.InferPtrAlign(Src);\n  if (!SrcAlign || Alignment > *SrcAlign)\n    SrcAlign = Alignment;\n  assert(SrcAlign && \"SrcAlign must be set\");\n  ConstantDataArraySlice Slice;\n  // If marked as volatile, perform a copy even when marked as constant.\n  bool CopyFromConstant = !isVol && isMemSrcFromConstant(Src, Slice);\n  bool isZeroConstant = CopyFromConstant && Slice.Array == nullptr;\n  unsigned Limit = AlwaysInline ? ~0U : TLI.getMaxStoresPerMemcpy(OptSize);\n  const MemOp Op = isZeroConstant\n                       ? MemOp::Set(Size, DstAlignCanChange, Alignment,\n                                    /*IsZeroMemset*/ true, isVol)\n                       : MemOp::Copy(Size, DstAlignCanChange, Alignment,\n                                     *SrcAlign, isVol, CopyFromConstant);\n  if (!TLI.findOptimalMemOpLowering(\n          MemOps, Limit, Op, DstPtrInfo.getAddrSpace(),\n          SrcPtrInfo.getAddrSpace(), MF.getFunction().getAttributes()))\n    return SDValue();\n\n  if (DstAlignCanChange) {\n    Type *Ty = MemOps[0].getTypeForEVT(C);\n    Align NewAlign = DL.getABITypeAlign(Ty);\n\n    // Don't promote to an alignment that would require dynamic stack\n    // realignment.\n    const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();\n    if (!TRI->needsStackRealignment(MF))\n      while (NewAlign > Alignment && DL.exceedsNaturalStackAlignment(NewAlign))\n        NewAlign = NewAlign / 2;\n\n    if (NewAlign > Alignment) {\n      // Give the stack frame object a larger alignment if needed.\n      if (MFI.getObjectAlign(FI->getIndex()) < NewAlign)\n        MFI.setObjectAlignment(FI->getIndex(), NewAlign);\n      Alignment = NewAlign;\n    }\n  }\n\n  MachineMemOperand::Flags MMOFlags =\n      isVol ? MachineMemOperand::MOVolatile : MachineMemOperand::MONone;\n  SmallVector<SDValue, 16> OutLoadChains;\n  SmallVector<SDValue, 16> OutStoreChains;\n  SmallVector<SDValue, 32> OutChains;\n  unsigned NumMemOps = MemOps.size();\n  uint64_t SrcOff = 0, DstOff = 0;\n  for (unsigned i = 0; i != NumMemOps; ++i) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    SDValue Value, Store;\n\n    if (VTSize > Size) {\n      // Issuing an unaligned load / store pair  that overlaps with the previous\n      // pair. Adjust the offset accordingly.\n      assert(i == NumMemOps-1 && i != 0);\n      SrcOff -= VTSize - Size;\n      DstOff -= VTSize - Size;\n    }\n\n    if (CopyFromConstant &&\n        (isZeroConstant || (VT.isInteger() && !VT.isVector()))) {\n      // It's unlikely a store of a vector immediate can be done in a single\n      // instruction. It would require a load from a constantpool first.\n      // We only handle zero vectors here.\n      // FIXME: Handle other cases where store of vector immediate is done in\n      // a single instruction.\n      ConstantDataArraySlice SubSlice;\n      if (SrcOff < Slice.Length) {\n        SubSlice = Slice;\n        SubSlice.move(SrcOff);\n      } else {\n        // This is an out-of-bounds access and hence UB. Pretend we read zero.\n        SubSlice.Array = nullptr;\n        SubSlice.Offset = 0;\n        SubSlice.Length = VTSize;\n      }\n      Value = getMemsetStringVal(VT, dl, DAG, TLI, SubSlice);\n      if (Value.getNode()) {\n        Store = DAG.getStore(\n            Chain, dl, Value,\n            DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n            DstPtrInfo.getWithOffset(DstOff), Alignment, MMOFlags);\n        OutChains.push_back(Store);\n      }\n    }\n\n    if (!Store.getNode()) {\n      // The type might not be legal for the target.  This should only happen\n      // if the type is smaller than a legal type, as on PPC, so the right\n      // thing to do is generate a LoadExt/StoreTrunc pair.  These simplify\n      // to Load/Store if NVT==VT.\n      // FIXME does the case above also need this?\n      EVT NVT = TLI.getTypeToTransformTo(C, VT);\n      assert(NVT.bitsGE(VT));\n\n      bool isDereferenceable =\n        SrcPtrInfo.getWithOffset(SrcOff).isDereferenceable(VTSize, C, DL);\n      MachineMemOperand::Flags SrcMMOFlags = MMOFlags;\n      if (isDereferenceable)\n        SrcMMOFlags |= MachineMemOperand::MODereferenceable;\n\n      Value = DAG.getExtLoad(\n          ISD::EXTLOAD, dl, NVT, Chain,\n          DAG.getMemBasePlusOffset(Src, TypeSize::Fixed(SrcOff), dl),\n          SrcPtrInfo.getWithOffset(SrcOff), VT,\n          commonAlignment(*SrcAlign, SrcOff), SrcMMOFlags);\n      OutLoadChains.push_back(Value.getValue(1));\n\n      Store = DAG.getTruncStore(\n          Chain, dl, Value,\n          DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n          DstPtrInfo.getWithOffset(DstOff), VT, Alignment, MMOFlags);\n      OutStoreChains.push_back(Store);\n    }\n    SrcOff += VTSize;\n    DstOff += VTSize;\n    Size -= VTSize;\n  }\n\n  unsigned GluedLdStLimit = MaxLdStGlue == 0 ?\n                                TLI.getMaxGluedStoresPerMemcpy() : MaxLdStGlue;\n  unsigned NumLdStInMemcpy = OutStoreChains.size();\n\n  if (NumLdStInMemcpy) {\n    // It may be that memcpy might be converted to memset if it's memcpy\n    // of constants. In such a case, we won't have loads and stores, but\n    // just stores. In the absence of loads, there is nothing to gang up.\n    if ((GluedLdStLimit <= 1) || !EnableMemCpyDAGOpt) {\n      // If target does not care, just leave as it.\n      for (unsigned i = 0; i < NumLdStInMemcpy; ++i) {\n        OutChains.push_back(OutLoadChains[i]);\n        OutChains.push_back(OutStoreChains[i]);\n      }\n    } else {\n      // Ld/St less than/equal limit set by target.\n      if (NumLdStInMemcpy <= GluedLdStLimit) {\n          chainLoadsAndStoresForMemcpy(DAG, dl, OutChains, 0,\n                                        NumLdStInMemcpy, OutLoadChains,\n                                        OutStoreChains);\n      } else {\n        unsigned NumberLdChain =  NumLdStInMemcpy / GluedLdStLimit;\n        unsigned RemainingLdStInMemcpy = NumLdStInMemcpy % GluedLdStLimit;\n        unsigned GlueIter = 0;\n\n        for (unsigned cnt = 0; cnt < NumberLdChain; ++cnt) {\n          unsigned IndexFrom = NumLdStInMemcpy - GlueIter - GluedLdStLimit;\n          unsigned IndexTo   = NumLdStInMemcpy - GlueIter;\n\n          chainLoadsAndStoresForMemcpy(DAG, dl, OutChains, IndexFrom, IndexTo,\n                                       OutLoadChains, OutStoreChains);\n          GlueIter += GluedLdStLimit;\n        }\n\n        // Residual ld/st.\n        if (RemainingLdStInMemcpy) {\n          chainLoadsAndStoresForMemcpy(DAG, dl, OutChains, 0,\n                                        RemainingLdStInMemcpy, OutLoadChains,\n                                        OutStoreChains);\n        }\n      }\n    }\n  }\n  return DAG.getNode(ISD::TokenFactor, dl, MVT::Other, OutChains);\n}\n\nstatic SDValue getMemmoveLoadsAndStores(SelectionDAG &DAG, const SDLoc &dl,\n                                        SDValue Chain, SDValue Dst, SDValue Src,\n                                        uint64_t Size, Align Alignment,\n                                        bool isVol, bool AlwaysInline,\n                                        MachinePointerInfo DstPtrInfo,\n                                        MachinePointerInfo SrcPtrInfo) {\n  // Turn a memmove of undef to nop.\n  // FIXME: We need to honor volatile even is Src is undef.\n  if (Src.isUndef())\n    return Chain;\n\n  // Expand memmove to a series of load and store ops if the size operand falls\n  // below a certain threshold.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  const DataLayout &DL = DAG.getDataLayout();\n  LLVMContext &C = *DAG.getContext();\n  std::vector<EVT> MemOps;\n  bool DstAlignCanChange = false;\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineFrameInfo &MFI = MF.getFrameInfo();\n  bool OptSize = shouldLowerMemFuncForSize(MF, DAG);\n  FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Dst);\n  if (FI && !MFI.isFixedObjectIndex(FI->getIndex()))\n    DstAlignCanChange = true;\n  MaybeAlign SrcAlign = DAG.InferPtrAlign(Src);\n  if (!SrcAlign || Alignment > *SrcAlign)\n    SrcAlign = Alignment;\n  assert(SrcAlign && \"SrcAlign must be set\");\n  unsigned Limit = AlwaysInline ? ~0U : TLI.getMaxStoresPerMemmove(OptSize);\n  if (!TLI.findOptimalMemOpLowering(\n          MemOps, Limit,\n          MemOp::Copy(Size, DstAlignCanChange, Alignment, *SrcAlign,\n                      /*IsVolatile*/ true),\n          DstPtrInfo.getAddrSpace(), SrcPtrInfo.getAddrSpace(),\n          MF.getFunction().getAttributes()))\n    return SDValue();\n\n  if (DstAlignCanChange) {\n    Type *Ty = MemOps[0].getTypeForEVT(C);\n    Align NewAlign = DL.getABITypeAlign(Ty);\n    if (NewAlign > Alignment) {\n      // Give the stack frame object a larger alignment if needed.\n      if (MFI.getObjectAlign(FI->getIndex()) < NewAlign)\n        MFI.setObjectAlignment(FI->getIndex(), NewAlign);\n      Alignment = NewAlign;\n    }\n  }\n\n  MachineMemOperand::Flags MMOFlags =\n      isVol ? MachineMemOperand::MOVolatile : MachineMemOperand::MONone;\n  uint64_t SrcOff = 0, DstOff = 0;\n  SmallVector<SDValue, 8> LoadValues;\n  SmallVector<SDValue, 8> LoadChains;\n  SmallVector<SDValue, 8> OutChains;\n  unsigned NumMemOps = MemOps.size();\n  for (unsigned i = 0; i < NumMemOps; i++) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    SDValue Value;\n\n    bool isDereferenceable =\n      SrcPtrInfo.getWithOffset(SrcOff).isDereferenceable(VTSize, C, DL);\n    MachineMemOperand::Flags SrcMMOFlags = MMOFlags;\n    if (isDereferenceable)\n      SrcMMOFlags |= MachineMemOperand::MODereferenceable;\n\n    Value =\n        DAG.getLoad(VT, dl, Chain,\n                    DAG.getMemBasePlusOffset(Src, TypeSize::Fixed(SrcOff), dl),\n                    SrcPtrInfo.getWithOffset(SrcOff), *SrcAlign, SrcMMOFlags);\n    LoadValues.push_back(Value);\n    LoadChains.push_back(Value.getValue(1));\n    SrcOff += VTSize;\n  }\n  Chain = DAG.getNode(ISD::TokenFactor, dl, MVT::Other, LoadChains);\n  OutChains.clear();\n  for (unsigned i = 0; i < NumMemOps; i++) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    SDValue Store;\n\n    Store =\n        DAG.getStore(Chain, dl, LoadValues[i],\n                     DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n                     DstPtrInfo.getWithOffset(DstOff), Alignment, MMOFlags);\n    OutChains.push_back(Store);\n    DstOff += VTSize;\n  }\n\n  return DAG.getNode(ISD::TokenFactor, dl, MVT::Other, OutChains);\n}\n\n/// Lower the call to 'memset' intrinsic function into a series of store\n/// operations.\n///\n/// \\param DAG Selection DAG where lowered code is placed.\n/// \\param dl Link to corresponding IR location.\n/// \\param Chain Control flow dependency.\n/// \\param Dst Pointer to destination memory location.\n/// \\param Src Value of byte to write into the memory.\n/// \\param Size Number of bytes to write.\n/// \\param Alignment Alignment of the destination in bytes.\n/// \\param isVol True if destination is volatile.\n/// \\param DstPtrInfo IR information on the memory pointer.\n/// \\returns New head in the control flow, if lowering was successful, empty\n/// SDValue otherwise.\n///\n/// The function tries to replace 'llvm.memset' intrinsic with several store\n/// operations and value calculation code. This is usually profitable for small\n/// memory size.\nstatic SDValue getMemsetStores(SelectionDAG &DAG, const SDLoc &dl,\n                               SDValue Chain, SDValue Dst, SDValue Src,\n                               uint64_t Size, Align Alignment, bool isVol,\n                               MachinePointerInfo DstPtrInfo) {\n  // Turn a memset of undef to nop.\n  // FIXME: We need to honor volatile even is Src is undef.\n  if (Src.isUndef())\n    return Chain;\n\n  // Expand memset to a series of load/store ops if the size operand\n  // falls below a certain threshold.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  std::vector<EVT> MemOps;\n  bool DstAlignCanChange = false;\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineFrameInfo &MFI = MF.getFrameInfo();\n  bool OptSize = shouldLowerMemFuncForSize(MF, DAG);\n  FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Dst);\n  if (FI && !MFI.isFixedObjectIndex(FI->getIndex()))\n    DstAlignCanChange = true;\n  bool IsZeroVal =\n    isa<ConstantSDNode>(Src) && cast<ConstantSDNode>(Src)->isNullValue();\n  if (!TLI.findOptimalMemOpLowering(\n          MemOps, TLI.getMaxStoresPerMemset(OptSize),\n          MemOp::Set(Size, DstAlignCanChange, Alignment, IsZeroVal, isVol),\n          DstPtrInfo.getAddrSpace(), ~0u, MF.getFunction().getAttributes()))\n    return SDValue();\n\n  if (DstAlignCanChange) {\n    Type *Ty = MemOps[0].getTypeForEVT(*DAG.getContext());\n    Align NewAlign = DAG.getDataLayout().getABITypeAlign(Ty);\n    if (NewAlign > Alignment) {\n      // Give the stack frame object a larger alignment if needed.\n      if (MFI.getObjectAlign(FI->getIndex()) < NewAlign)\n        MFI.setObjectAlignment(FI->getIndex(), NewAlign);\n      Alignment = NewAlign;\n    }\n  }\n\n  SmallVector<SDValue, 8> OutChains;\n  uint64_t DstOff = 0;\n  unsigned NumMemOps = MemOps.size();\n\n  // Find the largest store and generate the bit pattern for it.\n  EVT LargestVT = MemOps[0];\n  for (unsigned i = 1; i < NumMemOps; i++)\n    if (MemOps[i].bitsGT(LargestVT))\n      LargestVT = MemOps[i];\n  SDValue MemSetValue = getMemsetValue(Src, LargestVT, DAG, dl);\n\n  for (unsigned i = 0; i < NumMemOps; i++) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    if (VTSize > Size) {\n      // Issuing an unaligned load / store pair  that overlaps with the previous\n      // pair. Adjust the offset accordingly.\n      assert(i == NumMemOps-1 && i != 0);\n      DstOff -= VTSize - Size;\n    }\n\n    // If this store is smaller than the largest store see whether we can get\n    // the smaller value for free with a truncate.\n    SDValue Value = MemSetValue;\n    if (VT.bitsLT(LargestVT)) {\n      if (!LargestVT.isVector() && !VT.isVector() &&\n          TLI.isTruncateFree(LargestVT, VT))\n        Value = DAG.getNode(ISD::TRUNCATE, dl, VT, MemSetValue);\n      else\n        Value = getMemsetValue(Src, VT, DAG, dl);\n    }\n    assert(Value.getValueType() == VT && \"Value with wrong type.\");\n    SDValue Store = DAG.getStore(\n        Chain, dl, Value,\n        DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n        DstPtrInfo.getWithOffset(DstOff), Alignment,\n        isVol ? MachineMemOperand::MOVolatile : MachineMemOperand::MONone);\n    OutChains.push_back(Store);\n    DstOff += VT.getSizeInBits() / 8;\n    Size -= VTSize;\n  }\n\n  return DAG.getNode(ISD::TokenFactor, dl, MVT::Other, OutChains);\n}\n\nstatic void checkAddrSpaceIsValidForLibcall(const TargetLowering *TLI,\n                                            unsigned AS) {\n  // Lowering memcpy / memset / memmove intrinsics to calls is only valid if all\n  // pointer operands can be losslessly bitcasted to pointers of address space 0\n  if (AS != 0 && !TLI->getTargetMachine().isNoopAddrSpaceCast(AS, 0)) {\n    report_fatal_error(\"cannot lower memory intrinsic in address space \" +\n                       Twine(AS));\n  }\n}\n\nSDValue SelectionDAG::getMemcpy(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                                SDValue Src, SDValue Size, Align Alignment,\n                                bool isVol, bool AlwaysInline, bool isTailCall,\n                                MachinePointerInfo DstPtrInfo,\n                                MachinePointerInfo SrcPtrInfo) {\n  // Check to see if we should lower the memcpy to loads and stores first.\n  // For cases within the target-specified limits, this is the best choice.\n  ConstantSDNode *ConstantSize = dyn_cast<ConstantSDNode>(Size);\n  if (ConstantSize) {\n    // Memcpy with size zero? Just return the original chain.\n    if (ConstantSize->isNullValue())\n      return Chain;\n\n    SDValue Result = getMemcpyLoadsAndStores(\n        *this, dl, Chain, Dst, Src, ConstantSize->getZExtValue(), Alignment,\n        isVol, false, DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  // Then check to see if we should lower the memcpy with target-specific\n  // code. If the target chooses to do this, this is the next best.\n  if (TSI) {\n    SDValue Result = TSI->EmitTargetCodeForMemcpy(\n        *this, dl, Chain, Dst, Src, Size, Alignment, isVol, AlwaysInline,\n        DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  // If we really need inline code and the target declined to provide it,\n  // use a (potentially long) sequence of loads and stores.\n  if (AlwaysInline) {\n    assert(ConstantSize && \"AlwaysInline requires a constant size!\");\n    return getMemcpyLoadsAndStores(*this, dl, Chain, Dst, Src,\n                                   ConstantSize->getZExtValue(), Alignment,\n                                   isVol, true, DstPtrInfo, SrcPtrInfo);\n  }\n\n  checkAddrSpaceIsValidForLibcall(TLI, DstPtrInfo.getAddrSpace());\n  checkAddrSpaceIsValidForLibcall(TLI, SrcPtrInfo.getAddrSpace());\n\n  // FIXME: If the memcpy is volatile (isVol), lowering it to a plain libc\n  // memcpy is not guaranteed to be safe. libc memcpys aren't required to\n  // respect volatile, so they may do things like read or write memory\n  // beyond the given memory regions. But fixing this isn't easy, and most\n  // people don't care.\n\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = Type::getInt8PtrTy(*getContext());\n  Entry.Node = Dst; Args.push_back(Entry);\n  Entry.Node = Src; Args.push_back(Entry);\n\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Size; Args.push_back(Entry);\n  // FIXME: pass in SDLoc\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(RTLIB::MEMCPY),\n                    Dst.getValueType().getTypeForEVT(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(RTLIB::MEMCPY),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue,SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomicMemcpy(SDValue Chain, const SDLoc &dl,\n                                      SDValue Dst, unsigned DstAlign,\n                                      SDValue Src, unsigned SrcAlign,\n                                      SDValue Size, Type *SizeTy,\n                                      unsigned ElemSz, bool isTailCall,\n                                      MachinePointerInfo DstPtrInfo,\n                                      MachinePointerInfo SrcPtrInfo) {\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Dst;\n  Args.push_back(Entry);\n\n  Entry.Node = Src;\n  Args.push_back(Entry);\n\n  Entry.Ty = SizeTy;\n  Entry.Node = Size;\n  Args.push_back(Entry);\n\n  RTLIB::Libcall LibraryCall =\n      RTLIB::getMEMCPY_ELEMENT_UNORDERED_ATOMIC(ElemSz);\n  if (LibraryCall == RTLIB::UNKNOWN_LIBCALL)\n    report_fatal_error(\"Unsupported element size\");\n\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(LibraryCall),\n                    Type::getVoidTy(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(LibraryCall),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue, SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getMemmove(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                                 SDValue Src, SDValue Size, Align Alignment,\n                                 bool isVol, bool isTailCall,\n                                 MachinePointerInfo DstPtrInfo,\n                                 MachinePointerInfo SrcPtrInfo) {\n  // Check to see if we should lower the memmove to loads and stores first.\n  // For cases within the target-specified limits, this is the best choice.\n  ConstantSDNode *ConstantSize = dyn_cast<ConstantSDNode>(Size);\n  if (ConstantSize) {\n    // Memmove with size zero? Just return the original chain.\n    if (ConstantSize->isNullValue())\n      return Chain;\n\n    SDValue Result = getMemmoveLoadsAndStores(\n        *this, dl, Chain, Dst, Src, ConstantSize->getZExtValue(), Alignment,\n        isVol, false, DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  // Then check to see if we should lower the memmove with target-specific\n  // code. If the target chooses to do this, this is the next best.\n  if (TSI) {\n    SDValue Result =\n        TSI->EmitTargetCodeForMemmove(*this, dl, Chain, Dst, Src, Size,\n                                      Alignment, isVol, DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  checkAddrSpaceIsValidForLibcall(TLI, DstPtrInfo.getAddrSpace());\n  checkAddrSpaceIsValidForLibcall(TLI, SrcPtrInfo.getAddrSpace());\n\n  // FIXME: If the memmove is volatile, lowering it to plain libc memmove may\n  // not be safe.  See memcpy above for more details.\n\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = Type::getInt8PtrTy(*getContext());\n  Entry.Node = Dst; Args.push_back(Entry);\n  Entry.Node = Src; Args.push_back(Entry);\n\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Size; Args.push_back(Entry);\n  // FIXME:  pass in SDLoc\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(RTLIB::MEMMOVE),\n                    Dst.getValueType().getTypeForEVT(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(RTLIB::MEMMOVE),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue,SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomicMemmove(SDValue Chain, const SDLoc &dl,\n                                       SDValue Dst, unsigned DstAlign,\n                                       SDValue Src, unsigned SrcAlign,\n                                       SDValue Size, Type *SizeTy,\n                                       unsigned ElemSz, bool isTailCall,\n                                       MachinePointerInfo DstPtrInfo,\n                                       MachinePointerInfo SrcPtrInfo) {\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Dst;\n  Args.push_back(Entry);\n\n  Entry.Node = Src;\n  Args.push_back(Entry);\n\n  Entry.Ty = SizeTy;\n  Entry.Node = Size;\n  Args.push_back(Entry);\n\n  RTLIB::Libcall LibraryCall =\n      RTLIB::getMEMMOVE_ELEMENT_UNORDERED_ATOMIC(ElemSz);\n  if (LibraryCall == RTLIB::UNKNOWN_LIBCALL)\n    report_fatal_error(\"Unsupported element size\");\n\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(LibraryCall),\n                    Type::getVoidTy(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(LibraryCall),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue, SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getMemset(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                                SDValue Src, SDValue Size, Align Alignment,\n                                bool isVol, bool isTailCall,\n                                MachinePointerInfo DstPtrInfo) {\n  // Check to see if we should lower the memset to stores first.\n  // For cases within the target-specified limits, this is the best choice.\n  ConstantSDNode *ConstantSize = dyn_cast<ConstantSDNode>(Size);\n  if (ConstantSize) {\n    // Memset with size zero? Just return the original chain.\n    if (ConstantSize->isNullValue())\n      return Chain;\n\n    SDValue Result = getMemsetStores(*this, dl, Chain, Dst, Src,\n                                     ConstantSize->getZExtValue(), Alignment,\n                                     isVol, DstPtrInfo);\n\n    if (Result.getNode())\n      return Result;\n  }\n\n  // Then check to see if we should lower the memset with target-specific\n  // code. If the target chooses to do this, this is the next best.\n  if (TSI) {\n    SDValue Result = TSI->EmitTargetCodeForMemset(\n        *this, dl, Chain, Dst, Src, Size, Alignment, isVol, DstPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  checkAddrSpaceIsValidForLibcall(TLI, DstPtrInfo.getAddrSpace());\n\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Node = Dst; Entry.Ty = Type::getInt8PtrTy(*getContext());\n  Args.push_back(Entry);\n  Entry.Node = Src;\n  Entry.Ty = Src.getValueType().getTypeForEVT(*getContext());\n  Args.push_back(Entry);\n  Entry.Node = Size;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Args.push_back(Entry);\n\n  // FIXME: pass in SDLoc\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(RTLIB::MEMSET),\n                    Dst.getValueType().getTypeForEVT(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(RTLIB::MEMSET),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue,SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomicMemset(SDValue Chain, const SDLoc &dl,\n                                      SDValue Dst, unsigned DstAlign,\n                                      SDValue Value, SDValue Size, Type *SizeTy,\n                                      unsigned ElemSz, bool isTailCall,\n                                      MachinePointerInfo DstPtrInfo) {\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Dst;\n  Args.push_back(Entry);\n\n  Entry.Ty = Type::getInt8Ty(*getContext());\n  Entry.Node = Value;\n  Args.push_back(Entry);\n\n  Entry.Ty = SizeTy;\n  Entry.Node = Size;\n  Args.push_back(Entry);\n\n  RTLIB::Libcall LibraryCall =\n      RTLIB::getMEMSET_ELEMENT_UNORDERED_ATOMIC(ElemSz);\n  if (LibraryCall == RTLIB::UNKNOWN_LIBCALL)\n    report_fatal_error(\"Unsupported element size\");\n\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(LibraryCall),\n                    Type::getVoidTy(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(LibraryCall),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue, SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                                SDVTList VTList, ArrayRef<SDValue> Ops,\n                                MachineMemOperand *MMO) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(MemVT.getRawBits());\n  AddNodeIDNode(ID, Opcode, VTList, Ops);\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void* IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<AtomicSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n\n  auto *N = newSDNode<AtomicSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(),\n                                    VTList, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getAtomicCmpSwap(unsigned Opcode, const SDLoc &dl,\n                                       EVT MemVT, SDVTList VTs, SDValue Chain,\n                                       SDValue Ptr, SDValue Cmp, SDValue Swp,\n                                       MachineMemOperand *MMO) {\n  assert(Opcode == ISD::ATOMIC_CMP_SWAP ||\n         Opcode == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS);\n  assert(Cmp.getValueType() == Swp.getValueType() && \"Invalid Atomic Op Types\");\n\n  SDValue Ops[] = {Chain, Ptr, Cmp, Swp};\n  return getAtomic(Opcode, dl, MemVT, VTs, Ops, MMO);\n}\n\nSDValue SelectionDAG::getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                                SDValue Chain, SDValue Ptr, SDValue Val,\n                                MachineMemOperand *MMO) {\n  assert((Opcode == ISD::ATOMIC_LOAD_ADD ||\n          Opcode == ISD::ATOMIC_LOAD_SUB ||\n          Opcode == ISD::ATOMIC_LOAD_AND ||\n          Opcode == ISD::ATOMIC_LOAD_CLR ||\n          Opcode == ISD::ATOMIC_LOAD_OR ||\n          Opcode == ISD::ATOMIC_LOAD_XOR ||\n          Opcode == ISD::ATOMIC_LOAD_NAND ||\n          Opcode == ISD::ATOMIC_LOAD_MIN ||\n          Opcode == ISD::ATOMIC_LOAD_MAX ||\n          Opcode == ISD::ATOMIC_LOAD_UMIN ||\n          Opcode == ISD::ATOMIC_LOAD_UMAX ||\n          Opcode == ISD::ATOMIC_LOAD_FADD ||\n          Opcode == ISD::ATOMIC_LOAD_FSUB ||\n          Opcode == ISD::ATOMIC_SWAP ||\n          Opcode == ISD::ATOMIC_STORE) &&\n         \"Invalid Atomic Op\");\n\n  EVT VT = Val.getValueType();\n\n  SDVTList VTs = Opcode == ISD::ATOMIC_STORE ? getVTList(MVT::Other) :\n                                               getVTList(VT, MVT::Other);\n  SDValue Ops[] = {Chain, Ptr, Val};\n  return getAtomic(Opcode, dl, MemVT, VTs, Ops, MMO);\n}\n\nSDValue SelectionDAG::getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                                EVT VT, SDValue Chain, SDValue Ptr,\n                                MachineMemOperand *MMO) {\n  assert(Opcode == ISD::ATOMIC_LOAD && \"Invalid Atomic Op\");\n\n  SDVTList VTs = getVTList(VT, MVT::Other);\n  SDValue Ops[] = {Chain, Ptr};\n  return getAtomic(Opcode, dl, MemVT, VTs, Ops, MMO);\n}\n\n/// getMergeValues - Create a MERGE_VALUES node from the given operands.\nSDValue SelectionDAG::getMergeValues(ArrayRef<SDValue> Ops, const SDLoc &dl) {\n  if (Ops.size() == 1)\n    return Ops[0];\n\n  SmallVector<EVT, 4> VTs;\n  VTs.reserve(Ops.size());\n  for (const SDValue &Op : Ops)\n    VTs.push_back(Op.getValueType());\n  return getNode(ISD::MERGE_VALUES, dl, getVTList(VTs), Ops);\n}\n\nSDValue SelectionDAG::getMemIntrinsicNode(\n    unsigned Opcode, const SDLoc &dl, SDVTList VTList, ArrayRef<SDValue> Ops,\n    EVT MemVT, MachinePointerInfo PtrInfo, Align Alignment,\n    MachineMemOperand::Flags Flags, uint64_t Size, const AAMDNodes &AAInfo) {\n  if (!Size && MemVT.isScalableVector())\n    Size = MemoryLocation::UnknownSize;\n  else if (!Size)\n    Size = MemVT.getStoreSize();\n\n  MachineFunction &MF = getMachineFunction();\n  MachineMemOperand *MMO =\n      MF.getMachineMemOperand(PtrInfo, Flags, Size, Alignment, AAInfo);\n\n  return getMemIntrinsicNode(Opcode, dl, VTList, Ops, MemVT, MMO);\n}\n\nSDValue SelectionDAG::getMemIntrinsicNode(unsigned Opcode, const SDLoc &dl,\n                                          SDVTList VTList,\n                                          ArrayRef<SDValue> Ops, EVT MemVT,\n                                          MachineMemOperand *MMO) {\n  assert((Opcode == ISD::INTRINSIC_VOID ||\n          Opcode == ISD::INTRINSIC_W_CHAIN ||\n          Opcode == ISD::PREFETCH ||\n          ((int)Opcode <= std::numeric_limits<int>::max() &&\n           (int)Opcode >= ISD::FIRST_TARGET_MEMORY_OPCODE)) &&\n         \"Opcode is not a memory-accessing opcode!\");\n\n  // Memoize the node unless it returns a flag.\n  MemIntrinsicSDNode *N;\n  if (VTList.VTs[VTList.NumVTs-1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    ID.AddInteger(getSyntheticNodeSubclassData<MemIntrinsicSDNode>(\n        Opcode, dl.getIROrder(), VTList, MemVT, MMO));\n    ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n      cast<MemIntrinsicSDNode>(E)->refineAlignment(MMO);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<MemIntrinsicSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(),\n                                      VTList, MemVT, MMO);\n    createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<MemIntrinsicSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(),\n                                      VTList, MemVT, MMO);\n    createOperands(N, Ops);\n  }\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getLifetimeNode(bool IsStart, const SDLoc &dl,\n                                      SDValue Chain, int FrameIndex,\n                                      int64_t Size, int64_t Offset) {\n  const unsigned Opcode = IsStart ? ISD::LIFETIME_START : ISD::LIFETIME_END;\n  const auto VTs = getVTList(MVT::Other);\n  SDValue Ops[2] = {\n      Chain,\n      getFrameIndex(FrameIndex,\n                    getTargetLoweringInfo().getFrameIndexTy(getDataLayout()),\n                    true)};\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opcode, VTs, Ops);\n  ID.AddInteger(FrameIndex);\n  ID.AddInteger(Size);\n  ID.AddInteger(Offset);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  LifetimeSDNode *N = newSDNode<LifetimeSDNode>(\n      Opcode, dl.getIROrder(), dl.getDebugLoc(), VTs, Size, Offset);\n  createOperands(N, Ops);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getPseudoProbeNode(const SDLoc &Dl, SDValue Chain,\n                                         uint64_t Guid, uint64_t Index,\n                                         uint32_t Attr) {\n  const unsigned Opcode = ISD::PSEUDO_PROBE;\n  const auto VTs = getVTList(MVT::Other);\n  SDValue Ops[] = {Chain};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opcode, VTs, Ops);\n  ID.AddInteger(Guid);\n  ID.AddInteger(Index);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, Dl, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<PseudoProbeSDNode>(\n      Opcode, Dl.getIROrder(), Dl.getDebugLoc(), VTs, Guid, Index, Attr);\n  createOperands(N, Ops);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\n/// InferPointerInfo - If the specified ptr/offset is a frame index, infer a\n/// MachinePointerInfo record from it.  This is particularly useful because the\n/// code generator has many cases where it doesn't bother passing in a\n/// MachinePointerInfo to getLoad or getStore when it has \"FI+Cst\".\nstatic MachinePointerInfo InferPointerInfo(const MachinePointerInfo &Info,\n                                           SelectionDAG &DAG, SDValue Ptr,\n                                           int64_t Offset = 0) {\n  // If this is FI+Offset, we can model it.\n  if (const FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Ptr))\n    return MachinePointerInfo::getFixedStack(DAG.getMachineFunction(),\n                                             FI->getIndex(), Offset);\n\n  // If this is (FI+Offset1)+Offset2, we can model it.\n  if (Ptr.getOpcode() != ISD::ADD ||\n      !isa<ConstantSDNode>(Ptr.getOperand(1)) ||\n      !isa<FrameIndexSDNode>(Ptr.getOperand(0)))\n    return Info;\n\n  int FI = cast<FrameIndexSDNode>(Ptr.getOperand(0))->getIndex();\n  return MachinePointerInfo::getFixedStack(\n      DAG.getMachineFunction(), FI,\n      Offset + cast<ConstantSDNode>(Ptr.getOperand(1))->getSExtValue());\n}\n\n/// InferPointerInfo - If the specified ptr/offset is a frame index, infer a\n/// MachinePointerInfo record from it.  This is particularly useful because the\n/// code generator has many cases where it doesn't bother passing in a\n/// MachinePointerInfo to getLoad or getStore when it has \"FI+Cst\".\nstatic MachinePointerInfo InferPointerInfo(const MachinePointerInfo &Info,\n                                           SelectionDAG &DAG, SDValue Ptr,\n                                           SDValue OffsetOp) {\n  // If the 'Offset' value isn't a constant, we can't handle this.\n  if (ConstantSDNode *OffsetNode = dyn_cast<ConstantSDNode>(OffsetOp))\n    return InferPointerInfo(Info, DAG, Ptr, OffsetNode->getSExtValue());\n  if (OffsetOp.isUndef())\n    return InferPointerInfo(Info, DAG, Ptr);\n  return Info;\n}\n\nSDValue SelectionDAG::getLoad(ISD::MemIndexedMode AM, ISD::LoadExtType ExtType,\n                              EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, SDValue Offset,\n                              MachinePointerInfo PtrInfo, EVT MemVT,\n                              Align Alignment,\n                              MachineMemOperand::Flags MMOFlags,\n                              const AAMDNodes &AAInfo, const MDNode *Ranges) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n\n  MMOFlags |= MachineMemOperand::MOLoad;\n  assert((MMOFlags & MachineMemOperand::MOStore) == 0);\n  // If we don't have a PtrInfo, infer the trivial frame index case to simplify\n  // clients.\n  if (PtrInfo.V.isNull())\n    PtrInfo = InferPointerInfo(PtrInfo, *this, Ptr, Offset);\n\n  uint64_t Size = MemoryLocation::getSizeOrUnknown(MemVT.getStoreSize());\n  MachineFunction &MF = getMachineFunction();\n  MachineMemOperand *MMO = MF.getMachineMemOperand(PtrInfo, MMOFlags, Size,\n                                                   Alignment, AAInfo, Ranges);\n  return getLoad(AM, ExtType, VT, dl, Chain, Ptr, Offset, MemVT, MMO);\n}\n\nSDValue SelectionDAG::getLoad(ISD::MemIndexedMode AM, ISD::LoadExtType ExtType,\n                              EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, SDValue Offset, EVT MemVT,\n                              MachineMemOperand *MMO) {\n  if (VT == MemVT) {\n    ExtType = ISD::NON_EXTLOAD;\n  } else if (ExtType == ISD::NON_EXTLOAD) {\n    assert(VT == MemVT && \"Non-extending load from different memory type!\");\n  } else {\n    // Extending load.\n    assert(MemVT.getScalarType().bitsLT(VT.getScalarType()) &&\n           \"Should only be an extending load, not truncating!\");\n    assert(VT.isInteger() == MemVT.isInteger() &&\n           \"Cannot convert from FP to Int or Int -> FP!\");\n    assert(VT.isVector() == MemVT.isVector() &&\n           \"Cannot use an ext load to convert to or from a vector!\");\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() == MemVT.getVectorElementCount()) &&\n           \"Cannot use an ext load to change the number of vector elements!\");\n  }\n\n  bool Indexed = AM != ISD::UNINDEXED;\n  assert((Indexed || Offset.isUndef()) && \"Unindexed load with an offset!\");\n\n  SDVTList VTs = Indexed ?\n    getVTList(VT, Ptr.getValueType(), MVT::Other) : getVTList(VT, MVT::Other);\n  SDValue Ops[] = { Chain, Ptr, Offset };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::LOAD, VTs, Ops);\n  ID.AddInteger(MemVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<LoadSDNode>(\n      dl.getIROrder(), VTs, AM, ExtType, MemVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<LoadSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<LoadSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs, AM,\n                                  ExtType, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getLoad(EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, MachinePointerInfo PtrInfo,\n                              MaybeAlign Alignment,\n                              MachineMemOperand::Flags MMOFlags,\n                              const AAMDNodes &AAInfo, const MDNode *Ranges) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ISD::NON_EXTLOAD, VT, dl, Chain, Ptr, Undef,\n                 PtrInfo, VT, Alignment, MMOFlags, AAInfo, Ranges);\n}\n\nSDValue SelectionDAG::getLoad(EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, MachineMemOperand *MMO) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ISD::NON_EXTLOAD, VT, dl, Chain, Ptr, Undef,\n                 VT, MMO);\n}\n\nSDValue SelectionDAG::getExtLoad(ISD::LoadExtType ExtType, const SDLoc &dl,\n                                 EVT VT, SDValue Chain, SDValue Ptr,\n                                 MachinePointerInfo PtrInfo, EVT MemVT,\n                                 MaybeAlign Alignment,\n                                 MachineMemOperand::Flags MMOFlags,\n                                 const AAMDNodes &AAInfo) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ExtType, VT, dl, Chain, Ptr, Undef, PtrInfo,\n                 MemVT, Alignment, MMOFlags, AAInfo);\n}\n\nSDValue SelectionDAG::getExtLoad(ISD::LoadExtType ExtType, const SDLoc &dl,\n                                 EVT VT, SDValue Chain, SDValue Ptr, EVT MemVT,\n                                 MachineMemOperand *MMO) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ExtType, VT, dl, Chain, Ptr, Undef,\n                 MemVT, MMO);\n}\n\nSDValue SelectionDAG::getIndexedLoad(SDValue OrigLoad, const SDLoc &dl,\n                                     SDValue Base, SDValue Offset,\n                                     ISD::MemIndexedMode AM) {\n  LoadSDNode *LD = cast<LoadSDNode>(OrigLoad);\n  assert(LD->getOffset().isUndef() && \"Load is already a indexed load!\");\n  // Don't propagate the invariant or dereferenceable flags.\n  auto MMOFlags =\n      LD->getMemOperand()->getFlags() &\n      ~(MachineMemOperand::MOInvariant | MachineMemOperand::MODereferenceable);\n  return getLoad(AM, LD->getExtensionType(), OrigLoad.getValueType(), dl,\n                 LD->getChain(), Base, Offset, LD->getPointerInfo(),\n                 LD->getMemoryVT(), LD->getAlign(), MMOFlags, LD->getAAInfo());\n}\n\nSDValue SelectionDAG::getStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                               SDValue Ptr, MachinePointerInfo PtrInfo,\n                               Align Alignment,\n                               MachineMemOperand::Flags MMOFlags,\n                               const AAMDNodes &AAInfo) {\n  assert(Chain.getValueType() == MVT::Other && \"Invalid chain type\");\n\n  MMOFlags |= MachineMemOperand::MOStore;\n  assert((MMOFlags & MachineMemOperand::MOLoad) == 0);\n\n  if (PtrInfo.V.isNull())\n    PtrInfo = InferPointerInfo(PtrInfo, *this, Ptr);\n\n  MachineFunction &MF = getMachineFunction();\n  uint64_t Size =\n      MemoryLocation::getSizeOrUnknown(Val.getValueType().getStoreSize());\n  MachineMemOperand *MMO =\n      MF.getMachineMemOperand(PtrInfo, MMOFlags, Size, Alignment, AAInfo);\n  return getStore(Chain, dl, Val, Ptr, MMO);\n}\n\nSDValue SelectionDAG::getStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                               SDValue Ptr, MachineMemOperand *MMO) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n  EVT VT = Val.getValueType();\n  SDVTList VTs = getVTList(MVT::Other);\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  SDValue Ops[] = { Chain, Val, Ptr, Undef };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::STORE, VTs, Ops);\n  ID.AddInteger(VT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<StoreSDNode>(\n      dl.getIROrder(), VTs, ISD::UNINDEXED, false, VT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<StoreSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<StoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs,\n                                   ISD::UNINDEXED, false, VT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                                    SDValue Ptr, MachinePointerInfo PtrInfo,\n                                    EVT SVT, Align Alignment,\n                                    MachineMemOperand::Flags MMOFlags,\n                                    const AAMDNodes &AAInfo) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n\n  MMOFlags |= MachineMemOperand::MOStore;\n  assert((MMOFlags & MachineMemOperand::MOLoad) == 0);\n\n  if (PtrInfo.V.isNull())\n    PtrInfo = InferPointerInfo(PtrInfo, *this, Ptr);\n\n  MachineFunction &MF = getMachineFunction();\n  MachineMemOperand *MMO = MF.getMachineMemOperand(\n      PtrInfo, MMOFlags, MemoryLocation::getSizeOrUnknown(SVT.getStoreSize()),\n      Alignment, AAInfo);\n  return getTruncStore(Chain, dl, Val, Ptr, SVT, MMO);\n}\n\nSDValue SelectionDAG::getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                                    SDValue Ptr, EVT SVT,\n                                    MachineMemOperand *MMO) {\n  EVT VT = Val.getValueType();\n\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n  if (VT == SVT)\n    return getStore(Chain, dl, Val, Ptr, MMO);\n\n  assert(SVT.getScalarType().bitsLT(VT.getScalarType()) &&\n         \"Should only be a truncating store, not extending!\");\n  assert(VT.isInteger() == SVT.isInteger() &&\n         \"Can't do FP-INT conversion!\");\n  assert(VT.isVector() == SVT.isVector() &&\n         \"Cannot use trunc store to convert to or from a vector!\");\n  assert((!VT.isVector() ||\n          VT.getVectorElementCount() == SVT.getVectorElementCount()) &&\n         \"Cannot use trunc store to change the number of vector elements!\");\n\n  SDVTList VTs = getVTList(MVT::Other);\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  SDValue Ops[] = { Chain, Val, Ptr, Undef };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::STORE, VTs, Ops);\n  ID.AddInteger(SVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<StoreSDNode>(\n      dl.getIROrder(), VTs, ISD::UNINDEXED, true, SVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<StoreSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<StoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs,\n                                   ISD::UNINDEXED, true, SVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getIndexedStore(SDValue OrigStore, const SDLoc &dl,\n                                      SDValue Base, SDValue Offset,\n                                      ISD::MemIndexedMode AM) {\n  StoreSDNode *ST = cast<StoreSDNode>(OrigStore);\n  assert(ST->getOffset().isUndef() && \"Store is already a indexed store!\");\n  SDVTList VTs = getVTList(Base.getValueType(), MVT::Other);\n  SDValue Ops[] = { ST->getChain(), ST->getValue(), Base, Offset };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::STORE, VTs, Ops);\n  ID.AddInteger(ST->getMemoryVT().getRawBits());\n  ID.AddInteger(ST->getRawSubclassData());\n  ID.AddInteger(ST->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<StoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs, AM,\n                                   ST->isTruncatingStore(), ST->getMemoryVT(),\n                                   ST->getMemOperand());\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getMaskedLoad(EVT VT, const SDLoc &dl, SDValue Chain,\n                                    SDValue Base, SDValue Offset, SDValue Mask,\n                                    SDValue PassThru, EVT MemVT,\n                                    MachineMemOperand *MMO,\n                                    ISD::MemIndexedMode AM,\n                                    ISD::LoadExtType ExtTy, bool isExpanding) {\n  bool Indexed = AM != ISD::UNINDEXED;\n  assert((Indexed || Offset.isUndef()) &&\n         \"Unindexed masked load with an offset!\");\n  SDVTList VTs = Indexed ? getVTList(VT, Base.getValueType(), MVT::Other)\n                         : getVTList(VT, MVT::Other);\n  SDValue Ops[] = {Chain, Base, Offset, Mask, PassThru};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MLOAD, VTs, Ops);\n  ID.AddInteger(MemVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedLoadSDNode>(\n      dl.getIROrder(), VTs, AM, ExtTy, isExpanding, MemVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedLoadSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<MaskedLoadSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs,\n                                        AM, ExtTy, isExpanding, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getIndexedMaskedLoad(SDValue OrigLoad, const SDLoc &dl,\n                                           SDValue Base, SDValue Offset,\n                                           ISD::MemIndexedMode AM) {\n  MaskedLoadSDNode *LD = cast<MaskedLoadSDNode>(OrigLoad);\n  assert(LD->getOffset().isUndef() && \"Masked load is already a indexed load!\");\n  return getMaskedLoad(OrigLoad.getValueType(), dl, LD->getChain(), Base,\n                       Offset, LD->getMask(), LD->getPassThru(),\n                       LD->getMemoryVT(), LD->getMemOperand(), AM,\n                       LD->getExtensionType(), LD->isExpandingLoad());\n}\n\nSDValue SelectionDAG::getMaskedStore(SDValue Chain, const SDLoc &dl,\n                                     SDValue Val, SDValue Base, SDValue Offset,\n                                     SDValue Mask, EVT MemVT,\n                                     MachineMemOperand *MMO,\n                                     ISD::MemIndexedMode AM, bool IsTruncating,\n                                     bool IsCompressing) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n  bool Indexed = AM != ISD::UNINDEXED;\n  assert((Indexed || Offset.isUndef()) &&\n         \"Unindexed masked store with an offset!\");\n  SDVTList VTs = Indexed ? getVTList(Base.getValueType(), MVT::Other)\n                         : getVTList(MVT::Other);\n  SDValue Ops[] = {Chain, Val, Base, Offset, Mask};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MSTORE, VTs, Ops);\n  ID.AddInteger(MemVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedStoreSDNode>(\n      dl.getIROrder(), VTs, AM, IsTruncating, IsCompressing, MemVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedStoreSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N =\n      newSDNode<MaskedStoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs, AM,\n                                   IsTruncating, IsCompressing, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getIndexedMaskedStore(SDValue OrigStore, const SDLoc &dl,\n                                            SDValue Base, SDValue Offset,\n                                            ISD::MemIndexedMode AM) {\n  MaskedStoreSDNode *ST = cast<MaskedStoreSDNode>(OrigStore);\n  assert(ST->getOffset().isUndef() &&\n         \"Masked store is already a indexed store!\");\n  return getMaskedStore(ST->getChain(), dl, ST->getValue(), Base, Offset,\n                        ST->getMask(), ST->getMemoryVT(), ST->getMemOperand(),\n                        AM, ST->isTruncatingStore(), ST->isCompressingStore());\n}\n\nSDValue SelectionDAG::getMaskedGather(SDVTList VTs, EVT VT, const SDLoc &dl,\n                                      ArrayRef<SDValue> Ops,\n                                      MachineMemOperand *MMO,\n                                      ISD::MemIndexType IndexType,\n                                      ISD::LoadExtType ExtTy) {\n  assert(Ops.size() == 6 && \"Incompatible number of operands\");\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MGATHER, VTs, Ops);\n  ID.AddInteger(VT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedGatherSDNode>(\n      dl.getIROrder(), VTs, VT, MMO, IndexType, ExtTy));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedGatherSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n\n  IndexType = TLI->getCanonicalIndexType(IndexType, VT, Ops[4]);\n  auto *N = newSDNode<MaskedGatherSDNode>(dl.getIROrder(), dl.getDebugLoc(),\n                                          VTs, VT, MMO, IndexType, ExtTy);\n  createOperands(N, Ops);\n\n  assert(N->getPassThru().getValueType() == N->getValueType(0) &&\n         \"Incompatible type of the PassThru value in MaskedGatherSDNode\");\n  assert(N->getMask().getValueType().getVectorElementCount() ==\n             N->getValueType(0).getVectorElementCount() &&\n         \"Vector width mismatch between mask and data\");\n  assert(N->getIndex().getValueType().getVectorElementCount().isScalable() ==\n             N->getValueType(0).getVectorElementCount().isScalable() &&\n         \"Scalable flags of index and data do not match\");\n  assert(ElementCount::isKnownGE(\n             N->getIndex().getValueType().getVectorElementCount(),\n             N->getValueType(0).getVectorElementCount()) &&\n         \"Vector width mismatch between index and data\");\n  assert(isa<ConstantSDNode>(N->getScale()) &&\n         cast<ConstantSDNode>(N->getScale())->getAPIntValue().isPowerOf2() &&\n         \"Scale should be a constant power of 2\");\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getMaskedScatter(SDVTList VTs, EVT VT, const SDLoc &dl,\n                                       ArrayRef<SDValue> Ops,\n                                       MachineMemOperand *MMO,\n                                       ISD::MemIndexType IndexType,\n                                       bool IsTrunc) {\n  assert(Ops.size() == 6 && \"Incompatible number of operands\");\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MSCATTER, VTs, Ops);\n  ID.AddInteger(VT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedScatterSDNode>(\n      dl.getIROrder(), VTs, VT, MMO, IndexType, IsTrunc));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedScatterSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n\n  IndexType = TLI->getCanonicalIndexType(IndexType, VT, Ops[4]);\n  auto *N = newSDNode<MaskedScatterSDNode>(dl.getIROrder(), dl.getDebugLoc(),\n                                           VTs, VT, MMO, IndexType, IsTrunc);\n  createOperands(N, Ops);\n\n  assert(N->getMask().getValueType().getVectorElementCount() ==\n             N->getValue().getValueType().getVectorElementCount() &&\n         \"Vector width mismatch between mask and data\");\n  assert(\n      N->getIndex().getValueType().getVectorElementCount().isScalable() ==\n          N->getValue().getValueType().getVectorElementCount().isScalable() &&\n      \"Scalable flags of index and data do not match\");\n  assert(ElementCount::isKnownGE(\n             N->getIndex().getValueType().getVectorElementCount(),\n             N->getValue().getValueType().getVectorElementCount()) &&\n         \"Vector width mismatch between index and data\");\n  assert(isa<ConstantSDNode>(N->getScale()) &&\n         cast<ConstantSDNode>(N->getScale())->getAPIntValue().isPowerOf2() &&\n         \"Scale should be a constant power of 2\");\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::simplifySelect(SDValue Cond, SDValue T, SDValue F) {\n  // select undef, T, F --> T (if T is a constant), otherwise F\n  // select, ?, undef, F --> F\n  // select, ?, T, undef --> T\n  if (Cond.isUndef())\n    return isConstantValueOfAnyType(T) ? T : F;\n  if (T.isUndef())\n    return F;\n  if (F.isUndef())\n    return T;\n\n  // select true, T, F --> T\n  // select false, T, F --> F\n  if (auto *CondC = dyn_cast<ConstantSDNode>(Cond))\n    return CondC->isNullValue() ? F : T;\n\n  // TODO: This should simplify VSELECT with constant condition using something\n  // like this (but check boolean contents to be complete?):\n  //  if (ISD::isBuildVectorAllOnes(Cond.getNode()))\n  //    return T;\n  //  if (ISD::isBuildVectorAllZeros(Cond.getNode()))\n  //    return F;\n\n  // select ?, T, T --> T\n  if (T == F)\n    return T;\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::simplifyShift(SDValue X, SDValue Y) {\n  // shift undef, Y --> 0 (can always assume that the undef value is 0)\n  if (X.isUndef())\n    return getConstant(0, SDLoc(X.getNode()), X.getValueType());\n  // shift X, undef --> undef (because it may shift by the bitwidth)\n  if (Y.isUndef())\n    return getUNDEF(X.getValueType());\n\n  // shift 0, Y --> 0\n  // shift X, 0 --> X\n  if (isNullOrNullSplat(X) || isNullOrNullSplat(Y))\n    return X;\n\n  // shift X, C >= bitwidth(X) --> undef\n  // All vector elements must be too big (or undef) to avoid partial undefs.\n  auto isShiftTooBig = [X](ConstantSDNode *Val) {\n    return !Val || Val->getAPIntValue().uge(X.getScalarValueSizeInBits());\n  };\n  if (ISD::matchUnaryPredicate(Y, isShiftTooBig, true))\n    return getUNDEF(X.getValueType());\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::simplifyFPBinop(unsigned Opcode, SDValue X, SDValue Y,\n                                      SDNodeFlags Flags) {\n  // If this operation has 'nnan' or 'ninf' and at least 1 disallowed operand\n  // (an undef operand can be chosen to be Nan/Inf), then the result of this\n  // operation is poison. That result can be relaxed to undef.\n  ConstantFPSDNode *XC = isConstOrConstSplatFP(X, /* AllowUndefs */ true);\n  ConstantFPSDNode *YC = isConstOrConstSplatFP(Y, /* AllowUndefs */ true);\n  bool HasNan = (XC && XC->getValueAPF().isNaN()) ||\n                (YC && YC->getValueAPF().isNaN());\n  bool HasInf = (XC && XC->getValueAPF().isInfinity()) ||\n                (YC && YC->getValueAPF().isInfinity());\n\n  if (Flags.hasNoNaNs() && (HasNan || X.isUndef() || Y.isUndef()))\n    return getUNDEF(X.getValueType());\n\n  if (Flags.hasNoInfs() && (HasInf || X.isUndef() || Y.isUndef()))\n    return getUNDEF(X.getValueType());\n\n  if (!YC)\n    return SDValue();\n\n  // X + -0.0 --> X\n  if (Opcode == ISD::FADD)\n    if (YC->getValueAPF().isNegZero())\n      return X;\n\n  // X - +0.0 --> X\n  if (Opcode == ISD::FSUB)\n    if (YC->getValueAPF().isPosZero())\n      return X;\n\n  // X * 1.0 --> X\n  // X / 1.0 --> X\n  if (Opcode == ISD::FMUL || Opcode == ISD::FDIV)\n    if (YC->getValueAPF().isExactlyValue(1.0))\n      return X;\n\n  // X * 0.0 --> 0.0\n  if (Opcode == ISD::FMUL && Flags.hasNoNaNs() && Flags.hasNoSignedZeros())\n    if (YC->getValueAPF().isZero())\n      return getConstantFP(0.0, SDLoc(Y), Y.getValueType());\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::getVAArg(EVT VT, const SDLoc &dl, SDValue Chain,\n                               SDValue Ptr, SDValue SV, unsigned Align) {\n  SDValue Ops[] = { Chain, Ptr, SV, getTargetConstant(Align, dl, MVT::i32) };\n  return getNode(ISD::VAARG, dl, getVTList(VT, MVT::Other), Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              ArrayRef<SDUse> Ops) {\n  switch (Ops.size()) {\n  case 0: return getNode(Opcode, DL, VT);\n  case 1: return getNode(Opcode, DL, VT, static_cast<const SDValue>(Ops[0]));\n  case 2: return getNode(Opcode, DL, VT, Ops[0], Ops[1]);\n  case 3: return getNode(Opcode, DL, VT, Ops[0], Ops[1], Ops[2]);\n  default: break;\n  }\n\n  // Copy from an SDUse array into an SDValue array for use with\n  // the regular getNode logic.\n  SmallVector<SDValue, 8> NewOps(Ops.begin(), Ops.end());\n  return getNode(Opcode, DL, VT, NewOps);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              ArrayRef<SDValue> Ops) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, Ops, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              ArrayRef<SDValue> Ops, const SDNodeFlags Flags) {\n  unsigned NumOps = Ops.size();\n  switch (NumOps) {\n  case 0: return getNode(Opcode, DL, VT);\n  case 1: return getNode(Opcode, DL, VT, Ops[0], Flags);\n  case 2: return getNode(Opcode, DL, VT, Ops[0], Ops[1], Flags);\n  case 3: return getNode(Opcode, DL, VT, Ops[0], Ops[1], Ops[2], Flags);\n  default: break;\n  }\n\n#ifndef NDEBUG\n  for (auto &Op : Ops)\n    assert(Op.getOpcode() != ISD::DELETED_NODE &&\n           \"Operand is DELETED_NODE!\");\n#endif\n\n  switch (Opcode) {\n  default: break;\n  case ISD::BUILD_VECTOR:\n    // Attempt to simplify BUILD_VECTOR.\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  case ISD::CONCAT_VECTORS:\n    if (SDValue V = foldCONCAT_VECTORS(DL, VT, Ops, *this))\n      return V;\n    break;\n  case ISD::SELECT_CC:\n    assert(NumOps == 5 && \"SELECT_CC takes 5 operands!\");\n    assert(Ops[0].getValueType() == Ops[1].getValueType() &&\n           \"LHS and RHS of condition must have same type!\");\n    assert(Ops[2].getValueType() == Ops[3].getValueType() &&\n           \"True and False arms of SelectCC must have same type!\");\n    assert(Ops[2].getValueType() == VT &&\n           \"select_cc node must be of same type as true and false value!\");\n    break;\n  case ISD::BR_CC:\n    assert(NumOps == 5 && \"BR_CC takes 5 operands!\");\n    assert(Ops[2].getValueType() == Ops[3].getValueType() &&\n           \"LHS/RHS of comparison should match types!\");\n    break;\n  }\n\n  // Memoize nodes.\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n\n  if (VT != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n      return SDValue(E, 0);\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  N->setFlags(Flags);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL,\n                              ArrayRef<EVT> ResultTys, ArrayRef<SDValue> Ops) {\n  return getNode(Opcode, DL, getVTList(ResultTys), Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              ArrayRef<SDValue> Ops) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VTList, Ops, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              ArrayRef<SDValue> Ops, const SDNodeFlags Flags) {\n  if (VTList.NumVTs == 1)\n    return getNode(Opcode, DL, VTList.VTs[0], Ops);\n\n#ifndef NDEBUG\n  for (auto &Op : Ops)\n    assert(Op.getOpcode() != ISD::DELETED_NODE &&\n           \"Operand is DELETED_NODE!\");\n#endif\n\n  switch (Opcode) {\n  case ISD::STRICT_FP_EXTEND:\n    assert(VTList.NumVTs == 2 && Ops.size() == 2 &&\n           \"Invalid STRICT_FP_EXTEND!\");\n    assert(VTList.VTs[0].isFloatingPoint() &&\n           Ops[1].getValueType().isFloatingPoint() && \"Invalid FP cast!\");\n    assert(VTList.VTs[0].isVector() == Ops[1].getValueType().isVector() &&\n           \"STRICT_FP_EXTEND result type should be vector iff the operand \"\n           \"type is vector!\");\n    assert((!VTList.VTs[0].isVector() ||\n            VTList.VTs[0].getVectorNumElements() ==\n            Ops[1].getValueType().getVectorNumElements()) &&\n           \"Vector element count mismatch!\");\n    assert(Ops[1].getValueType().bitsLT(VTList.VTs[0]) &&\n           \"Invalid fpext node, dst <= src!\");\n    break;\n  case ISD::STRICT_FP_ROUND:\n    assert(VTList.NumVTs == 2 && Ops.size() == 3 && \"Invalid STRICT_FP_ROUND!\");\n    assert(VTList.VTs[0].isVector() == Ops[1].getValueType().isVector() &&\n           \"STRICT_FP_ROUND result type should be vector iff the operand \"\n           \"type is vector!\");\n    assert((!VTList.VTs[0].isVector() ||\n            VTList.VTs[0].getVectorNumElements() ==\n            Ops[1].getValueType().getVectorNumElements()) &&\n           \"Vector element count mismatch!\");\n    assert(VTList.VTs[0].isFloatingPoint() &&\n           Ops[1].getValueType().isFloatingPoint() &&\n           VTList.VTs[0].bitsLT(Ops[1].getValueType()) &&\n           isa<ConstantSDNode>(Ops[2]) &&\n           (cast<ConstantSDNode>(Ops[2])->getZExtValue() == 0 ||\n            cast<ConstantSDNode>(Ops[2])->getZExtValue() == 1) &&\n           \"Invalid STRICT_FP_ROUND!\");\n    break;\n#if 0\n  // FIXME: figure out how to safely handle things like\n  // int foo(int x) { return 1 << (x & 255); }\n  // int bar() { return foo(256); }\n  case ISD::SRA_PARTS:\n  case ISD::SRL_PARTS:\n  case ISD::SHL_PARTS:\n    if (N3.getOpcode() == ISD::SIGN_EXTEND_INREG &&\n        cast<VTSDNode>(N3.getOperand(1))->getVT() != MVT::i1)\n      return getNode(Opcode, DL, VT, N1, N2, N3.getOperand(0));\n    else if (N3.getOpcode() == ISD::AND)\n      if (ConstantSDNode *AndRHS = dyn_cast<ConstantSDNode>(N3.getOperand(1))) {\n        // If the and is only masking out bits that cannot effect the shift,\n        // eliminate the and.\n        unsigned NumBits = VT.getScalarSizeInBits()*2;\n        if ((AndRHS->getValue() & (NumBits-1)) == NumBits-1)\n          return getNode(Opcode, DL, VT, N1, N2, N3.getOperand(0));\n      }\n    break;\n#endif\n  }\n\n  // Memoize the node unless it returns a flag.\n  SDNode *N;\n  if (VTList.VTs[VTList.NumVTs-1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n      return SDValue(E, 0);\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTList);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTList);\n    createOperands(N, Ops);\n  }\n\n  N->setFlags(Flags);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL,\n                              SDVTList VTList) {\n  return getNode(Opcode, DL, VTList, None);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1) {\n  SDValue Ops[] = { N1 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2) {\n  SDValue Ops[] = { N1, N2 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2, SDValue N3) {\n  SDValue Ops[] = { N1, N2, N3 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4) {\n  SDValue Ops[] = { N1, N2, N3, N4 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4,\n                              SDValue N5) {\n  SDValue Ops[] = { N1, N2, N3, N4, N5 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT) {\n  return makeVTList(SDNode::getValueTypeList(VT), 1);\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT1, EVT VT2) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(2U);\n  ID.AddInteger(VT1.getRawBits());\n  ID.AddInteger(VT2.getRawBits());\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(2);\n    Array[0] = VT1;\n    Array[1] = VT2;\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, 2);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT1, EVT VT2, EVT VT3) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(3U);\n  ID.AddInteger(VT1.getRawBits());\n  ID.AddInteger(VT2.getRawBits());\n  ID.AddInteger(VT3.getRawBits());\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(3);\n    Array[0] = VT1;\n    Array[1] = VT2;\n    Array[2] = VT3;\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, 3);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT1, EVT VT2, EVT VT3, EVT VT4) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(4U);\n  ID.AddInteger(VT1.getRawBits());\n  ID.AddInteger(VT2.getRawBits());\n  ID.AddInteger(VT3.getRawBits());\n  ID.AddInteger(VT4.getRawBits());\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(4);\n    Array[0] = VT1;\n    Array[1] = VT2;\n    Array[2] = VT3;\n    Array[3] = VT4;\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, 4);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\nSDVTList SelectionDAG::getVTList(ArrayRef<EVT> VTs) {\n  unsigned NumVTs = VTs.size();\n  FoldingSetNodeID ID;\n  ID.AddInteger(NumVTs);\n  for (unsigned index = 0; index < NumVTs; index++) {\n    ID.AddInteger(VTs[index].getRawBits());\n  }\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(NumVTs);\n    llvm::copy(VTs, Array);\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, NumVTs);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\n\n/// UpdateNodeOperands - *Mutate* the specified node in-place to have the\n/// specified operands.  If the resultant node already exists in the DAG,\n/// this does not modify the specified node, instead it returns the node that\n/// already exists.  If the resultant node does not exist in the DAG, the\n/// input node is returned.  As a degenerate case, if you specify the same\n/// input operands as the node already has, the input node is returned.\nSDNode *SelectionDAG::UpdateNodeOperands(SDNode *N, SDValue Op) {\n  assert(N->getNumOperands() == 1 && \"Update with wrong number of operands\");\n\n  // Check to see if there is no change.\n  if (Op == N->getOperand(0)) return N;\n\n  // See if the modified node already exists.\n  void *InsertPos = nullptr;\n  if (SDNode *Existing = FindModifiedNodeSlot(N, Op, InsertPos))\n    return Existing;\n\n  // Nope it doesn't.  Remove the node from its current place in the maps.\n  if (InsertPos)\n    if (!RemoveNodeFromCSEMaps(N))\n      InsertPos = nullptr;\n\n  // Now we update the operands.\n  N->OperandList[0].set(Op);\n\n  updateDivergence(N);\n  // If this gets put into a CSE map, add it.\n  if (InsertPos) CSEMap.InsertNode(N, InsertPos);\n  return N;\n}\n\nSDNode *SelectionDAG::UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2) {\n  assert(N->getNumOperands() == 2 && \"Update with wrong number of operands\");\n\n  // Check to see if there is no change.\n  if (Op1 == N->getOperand(0) && Op2 == N->getOperand(1))\n    return N;   // No operands changed, just return the input node.\n\n  // See if the modified node already exists.\n  void *InsertPos = nullptr;\n  if (SDNode *Existing = FindModifiedNodeSlot(N, Op1, Op2, InsertPos))\n    return Existing;\n\n  // Nope it doesn't.  Remove the node from its current place in the maps.\n  if (InsertPos)\n    if (!RemoveNodeFromCSEMaps(N))\n      InsertPos = nullptr;\n\n  // Now we update the operands.\n  if (N->OperandList[0] != Op1)\n    N->OperandList[0].set(Op1);\n  if (N->OperandList[1] != Op2)\n    N->OperandList[1].set(Op2);\n\n  updateDivergence(N);\n  // If this gets put into a CSE map, add it.\n  if (InsertPos) CSEMap.InsertNode(N, InsertPos);\n  return N;\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2, SDValue Op3) {\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return UpdateNodeOperands(N, Ops);\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\n                   SDValue Op3, SDValue Op4) {\n  SDValue Ops[] = { Op1, Op2, Op3, Op4 };\n  return UpdateNodeOperands(N, Ops);\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\n                   SDValue Op3, SDValue Op4, SDValue Op5) {\n  SDValue Ops[] = { Op1, Op2, Op3, Op4, Op5 };\n  return UpdateNodeOperands(N, Ops);\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, ArrayRef<SDValue> Ops) {\n  unsigned NumOps = Ops.size();\n  assert(N->getNumOperands() == NumOps &&\n         \"Update with wrong number of operands\");\n\n  // If no operands changed just return the input node.\n  if (std::equal(Ops.begin(), Ops.end(), N->op_begin()))\n    return N;\n\n  // See if the modified node already exists.\n  void *InsertPos = nullptr;\n  if (SDNode *Existing = FindModifiedNodeSlot(N, Ops, InsertPos))\n    return Existing;\n\n  // Nope it doesn't.  Remove the node from its current place in the maps.\n  if (InsertPos)\n    if (!RemoveNodeFromCSEMaps(N))\n      InsertPos = nullptr;\n\n  // Now we update the operands.\n  for (unsigned i = 0; i != NumOps; ++i)\n    if (N->OperandList[i] != Ops[i])\n      N->OperandList[i].set(Ops[i]);\n\n  updateDivergence(N);\n  // If this gets put into a CSE map, add it.\n  if (InsertPos) CSEMap.InsertNode(N, InsertPos);\n  return N;\n}\n\n/// DropOperands - Release the operands and set this node to have\n/// zero operands.\nvoid SDNode::DropOperands() {\n  // Unlike the code in MorphNodeTo that does this, we don't need to\n  // watch for dead nodes here.\n  for (op_iterator I = op_begin(), E = op_end(); I != E; ) {\n    SDUse &Use = *I++;\n    Use.set(SDValue());\n  }\n}\n\nvoid SelectionDAG::setNodeMemRefs(MachineSDNode *N,\n                                  ArrayRef<MachineMemOperand *> NewMemRefs) {\n  if (NewMemRefs.empty()) {\n    N->clearMemRefs();\n    return;\n  }\n\n  // Check if we can avoid allocating by storing a single reference directly.\n  if (NewMemRefs.size() == 1) {\n    N->MemRefs = NewMemRefs[0];\n    N->NumMemRefs = 1;\n    return;\n  }\n\n  MachineMemOperand **MemRefsBuffer =\n      Allocator.template Allocate<MachineMemOperand *>(NewMemRefs.size());\n  llvm::copy(NewMemRefs, MemRefsBuffer);\n  N->MemRefs = MemRefsBuffer;\n  N->NumMemRefs = static_cast<int>(NewMemRefs.size());\n}\n\n/// SelectNodeTo - These are wrappers around MorphNodeTo that accept a\n/// machine opcode.\n///\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT) {\n  SDVTList VTs = getVTList(VT);\n  return SelectNodeTo(N, MachineOpc, VTs, None);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, SDValue Op1) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, SDValue Op1,\n                                   SDValue Op2) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, SDValue Op1,\n                                   SDValue Op2, SDValue Op3) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT);\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2, ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  return SelectNodeTo(N, MachineOpc, VTs, None);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2, EVT VT3,\n                                   ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2,\n                                   SDValue Op1, SDValue Op2) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  SDValue Ops[] = { Op1, Op2 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   SDVTList VTs,ArrayRef<SDValue> Ops) {\n  SDNode *New = MorphNodeTo(N, ~MachineOpc, VTs, Ops);\n  // Reset the NodeID to -1.\n  New->setNodeId(-1);\n  if (New != N) {\n    ReplaceAllUsesWith(N, New);\n    RemoveDeadNode(N);\n  }\n  return New;\n}\n\n/// UpdateSDLocOnMergeSDNode - If the opt level is -O0 then it throws away\n/// the line number information on the merged node since it is not possible to\n/// preserve the information that operation is associated with multiple lines.\n/// This will make the debugger working better at -O0, were there is a higher\n/// probability having other instructions associated with that line.\n///\n/// For IROrder, we keep the smaller of the two\nSDNode *SelectionDAG::UpdateSDLocOnMergeSDNode(SDNode *N, const SDLoc &OLoc) {\n  DebugLoc NLoc = N->getDebugLoc();\n  if (NLoc && OptLevel == CodeGenOpt::None && OLoc.getDebugLoc() != NLoc) {\n    N->setDebugLoc(DebugLoc());\n  }\n  unsigned Order = std::min(N->getIROrder(), OLoc.getIROrder());\n  N->setIROrder(Order);\n  return N;\n}\n\n/// MorphNodeTo - This *mutates* the specified node to have the specified\n/// return type, opcode, and operands.\n///\n/// Note that MorphNodeTo returns the resultant node.  If there is already a\n/// node of the specified opcode and operands, it returns that node instead of\n/// the current one.  Note that the SDLoc need not be the same.\n///\n/// Using MorphNodeTo is faster than creating a new node and swapping it in\n/// with ReplaceAllUsesWith both because it often avoids allocating a new\n/// node, and because it doesn't require CSE recalculation for any of\n/// the node's users.\n///\n/// However, note that MorphNodeTo recursively deletes dead nodes from the DAG.\n/// As a consequence it isn't appropriate to use from within the DAG combiner or\n/// the legalizer which maintain worklists that would need to be updated when\n/// deleting things.\nSDNode *SelectionDAG::MorphNodeTo(SDNode *N, unsigned Opc,\n                                  SDVTList VTs, ArrayRef<SDValue> Ops) {\n  // If an identical node already exists, use it.\n  void *IP = nullptr;\n  if (VTs.VTs[VTs.NumVTs-1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opc, VTs, Ops);\n    if (SDNode *ON = FindNodeOrInsertPos(ID, SDLoc(N), IP))\n      return UpdateSDLocOnMergeSDNode(ON, SDLoc(N));\n  }\n\n  if (!RemoveNodeFromCSEMaps(N))\n    IP = nullptr;\n\n  // Start the morphing.\n  N->NodeType = Opc;\n  N->ValueList = VTs.VTs;\n  N->NumValues = VTs.NumVTs;\n\n  // Clear the operands list, updating used nodes to remove this from their\n  // use list.  Keep track of any operands that become dead as a result.\n  SmallPtrSet<SDNode*, 16> DeadNodeSet;\n  for (SDNode::op_iterator I = N->op_begin(), E = N->op_end(); I != E; ) {\n    SDUse &Use = *I++;\n    SDNode *Used = Use.getNode();\n    Use.set(SDValue());\n    if (Used->use_empty())\n      DeadNodeSet.insert(Used);\n  }\n\n  // For MachineNode, initialize the memory references information.\n  if (MachineSDNode *MN = dyn_cast<MachineSDNode>(N))\n    MN->clearMemRefs();\n\n  // Swap for an appropriately sized array from the recycler.\n  removeOperands(N);\n  createOperands(N, Ops);\n\n  // Delete any nodes that are still dead after adding the uses for the\n  // new operands.\n  if (!DeadNodeSet.empty()) {\n    SmallVector<SDNode *, 16> DeadNodes;\n    for (SDNode *N : DeadNodeSet)\n      if (N->use_empty())\n        DeadNodes.push_back(N);\n    RemoveDeadNodes(DeadNodes);\n  }\n\n  if (IP)\n    CSEMap.InsertNode(N, IP);   // Memoize the new node.\n  return N;\n}\n\nSDNode* SelectionDAG::mutateStrictFPToFP(SDNode *Node) {\n  unsigned OrigOpc = Node->getOpcode();\n  unsigned NewOpc;\n  switch (OrigOpc) {\n  default:\n    llvm_unreachable(\"mutateStrictFPToFP called with unexpected opcode!\");\n#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n  case ISD::STRICT_##DAGN: NewOpc = ISD::DAGN; break;\n#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n  case ISD::STRICT_##DAGN: NewOpc = ISD::SETCC; break;\n#include \"llvm/IR/ConstrainedOps.def\"\n  }\n\n  assert(Node->getNumValues() == 2 && \"Unexpected number of results!\");\n\n  // We're taking this node out of the chain, so we need to re-link things.\n  SDValue InputChain = Node->getOperand(0);\n  SDValue OutputChain = SDValue(Node, 1);\n  ReplaceAllUsesOfValueWith(OutputChain, InputChain);\n\n  SmallVector<SDValue, 3> Ops;\n  for (unsigned i = 1, e = Node->getNumOperands(); i != e; ++i)\n    Ops.push_back(Node->getOperand(i));\n\n  SDVTList VTs = getVTList(Node->getValueType(0));\n  SDNode *Res = MorphNodeTo(Node, NewOpc, VTs, Ops);\n\n  // MorphNodeTo can operate in two ways: if an existing node with the\n  // specified operands exists, it can just return it.  Otherwise, it\n  // updates the node in place to have the requested operands.\n  if (Res == Node) {\n    // If we updated the node in place, reset the node ID.  To the isel,\n    // this should be just like a newly allocated machine node.\n    Res->setNodeId(-1);\n  } else {\n    ReplaceAllUsesWith(Node, Res);\n    RemoveDeadNode(Node);\n  }\n\n  return Res;\n}\n\n/// getMachineNode - These are used for target selectors to create a new node\n/// with specified return type(s), MachineInstr opcode, and operands.\n///\n/// Note that getMachineNode returns the resultant node.  If there is already a\n/// node of the specified opcode and operands, it returns that node instead of\n/// the current one.\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT) {\n  SDVTList VTs = getVTList(VT);\n  return getMachineNode(Opcode, dl, VTs, None);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, SDValue Op1) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, SDValue Op1, SDValue Op2) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, SDValue Op1, SDValue Op2,\n                                            SDValue Op3) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, SDValue Op1,\n                                            SDValue Op2) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  SDValue Ops[] = { Op1, Op2 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, SDValue Op1,\n                                            SDValue Op2, SDValue Op3) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2,\n                                            ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, EVT VT3,\n                                            SDValue Op1, SDValue Op2) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  SDValue Ops[] = { Op1, Op2 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, EVT VT3,\n                                            SDValue Op1, SDValue Op2,\n                                            SDValue Op3) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, EVT VT3,\n                                            ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            ArrayRef<EVT> ResultTys,\n                                            ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(ResultTys);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &DL,\n                                            SDVTList VTs,\n                                            ArrayRef<SDValue> Ops) {\n  bool DoCSE = VTs.VTs[VTs.NumVTs-1] != MVT::Glue;\n  MachineSDNode *N;\n  void *IP = nullptr;\n\n  if (DoCSE) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, ~Opcode, VTs, Ops);\n    IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      return cast<MachineSDNode>(UpdateSDLocOnMergeSDNode(E, DL));\n    }\n  }\n\n  // Allocate a new MachineSDNode.\n  N = newSDNode<MachineSDNode>(~Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n  createOperands(N, Ops);\n\n  if (DoCSE)\n    CSEMap.InsertNode(N, IP);\n\n  InsertNode(N);\n  NewSDValueDbgMsg(SDValue(N, 0), \"Creating new machine node: \", this);\n  return N;\n}\n\n/// getTargetExtractSubreg - A convenience function for creating\n/// TargetOpcode::EXTRACT_SUBREG nodes.\nSDValue SelectionDAG::getTargetExtractSubreg(int SRIdx, const SDLoc &DL, EVT VT,\n                                             SDValue Operand) {\n  SDValue SRIdxVal = getTargetConstant(SRIdx, DL, MVT::i32);\n  SDNode *Subreg = getMachineNode(TargetOpcode::EXTRACT_SUBREG, DL,\n                                  VT, Operand, SRIdxVal);\n  return SDValue(Subreg, 0);\n}\n\n/// getTargetInsertSubreg - A convenience function for creating\n/// TargetOpcode::INSERT_SUBREG nodes.\nSDValue SelectionDAG::getTargetInsertSubreg(int SRIdx, const SDLoc &DL, EVT VT,\n                                            SDValue Operand, SDValue Subreg) {\n  SDValue SRIdxVal = getTargetConstant(SRIdx, DL, MVT::i32);\n  SDNode *Result = getMachineNode(TargetOpcode::INSERT_SUBREG, DL,\n                                  VT, Operand, Subreg, SRIdxVal);\n  return SDValue(Result, 0);\n}\n\n/// getNodeIfExists - Get the specified node if it's already available, or\n/// else return NULL.\nSDNode *SelectionDAG::getNodeIfExists(unsigned Opcode, SDVTList VTList,\n                                      ArrayRef<SDValue> Ops) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNodeIfExists(Opcode, VTList, Ops, Flags);\n}\n\nSDNode *SelectionDAG::getNodeIfExists(unsigned Opcode, SDVTList VTList,\n                                      ArrayRef<SDValue> Ops,\n                                      const SDNodeFlags Flags) {\n  if (VTList.VTs[VTList.NumVTs - 1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, SDLoc(), IP)) {\n      E->intersectFlagsWith(Flags);\n      return E;\n    }\n  }\n  return nullptr;\n}\n\n/// doesNodeExist - Check if a node exists without modifying its flags.\nbool SelectionDAG::doesNodeExist(unsigned Opcode, SDVTList VTList,\n                                 ArrayRef<SDValue> Ops) {\n  if (VTList.VTs[VTList.NumVTs - 1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    void *IP = nullptr;\n    if (FindNodeOrInsertPos(ID, SDLoc(), IP))\n      return true;\n  }\n  return false;\n}\n\n/// getDbgValue - Creates a SDDbgValue node.\n///\n/// SDNode\nSDDbgValue *SelectionDAG::getDbgValue(DIVariable *Var, DIExpression *Expr,\n                                      SDNode *N, unsigned R, bool IsIndirect,\n                                      const DebugLoc &DL, unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, SDDbgOperand::fromNode(N, R), N, IsIndirect, DL, O,\n                 /*IsVariadic=*/false);\n}\n\n/// Constant\nSDDbgValue *SelectionDAG::getConstantDbgValue(DIVariable *Var,\n                                              DIExpression *Expr,\n                                              const Value *C,\n                                              const DebugLoc &DL, unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc()) SDDbgValue(\n      Var, Expr, SDDbgOperand::fromConst(C), {}, /*IsIndirect=*/false, DL, O,\n      /*IsVariadic=*/false);\n}\n\n/// FrameIndex\nSDDbgValue *SelectionDAG::getFrameIndexDbgValue(DIVariable *Var,\n                                                DIExpression *Expr, unsigned FI,\n                                                bool IsIndirect,\n                                                const DebugLoc &DL,\n                                                unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return getFrameIndexDbgValue(Var, Expr, FI, {}, IsIndirect, DL, O);\n}\n\n/// FrameIndex with dependencies\nSDDbgValue *SelectionDAG::getFrameIndexDbgValue(DIVariable *Var,\n                                                DIExpression *Expr, unsigned FI,\n                                                ArrayRef<SDNode *> Dependencies,\n                                                bool IsIndirect,\n                                                const DebugLoc &DL,\n                                                unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, SDDbgOperand::fromFrameIdx(FI), Dependencies,\n                 IsIndirect, DL, O,\n                 /*IsVariadic=*/false);\n}\n\n/// VReg\nSDDbgValue *SelectionDAG::getVRegDbgValue(DIVariable *Var, DIExpression *Expr,\n                                          unsigned VReg, bool IsIndirect,\n                                          const DebugLoc &DL, unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, SDDbgOperand::fromVReg(VReg), {}, IsIndirect, DL, O,\n                 /*IsVariadic=*/false);\n}\n\nSDDbgValue *SelectionDAG::getDbgValueList(DIVariable *Var, DIExpression *Expr,\n                                          ArrayRef<SDDbgOperand> Locs,\n                                          ArrayRef<SDNode *> Dependencies,\n                                          bool IsIndirect, const DebugLoc &DL,\n                                          unsigned O, bool IsVariadic) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, Locs, Dependencies, IsIndirect, DL, O, IsVariadic);\n}\n\nvoid SelectionDAG::transferDbgValues(SDValue From, SDValue To,\n                                     unsigned OffsetInBits, unsigned SizeInBits,\n                                     bool InvalidateDbg) {\n  SDNode *FromNode = From.getNode();\n  SDNode *ToNode = To.getNode();\n  assert(FromNode && ToNode && \"Can't modify dbg values\");\n\n  // PR35338\n  // TODO: assert(From != To && \"Redundant dbg value transfer\");\n  // TODO: assert(FromNode != ToNode && \"Intranode dbg value transfer\");\n  if (From == To || FromNode == ToNode)\n    return;\n\n  if (!FromNode->getHasDebugValue())\n    return;\n\n  SDDbgOperand FromLocOp =\n      SDDbgOperand::fromNode(From.getNode(), From.getResNo());\n  SDDbgOperand ToLocOp = SDDbgOperand::fromNode(To.getNode(), To.getResNo());\n\n  SmallVector<SDDbgValue *, 2> ClonedDVs;\n  for (SDDbgValue *Dbg : GetDbgValues(FromNode)) {\n    if (Dbg->isInvalidated())\n      continue;\n\n    // TODO: assert(!Dbg->isInvalidated() && \"Transfer of invalid dbg value\");\n\n    // Create a new location ops vector that is equal to the old vector, but\n    // with each instance of FromLocOp replaced with ToLocOp.\n    bool Changed = false;\n    auto NewLocOps = Dbg->copyLocationOps();\n    std::replace_if(\n        NewLocOps.begin(), NewLocOps.end(),\n        [&Changed, FromLocOp](const SDDbgOperand &Op) {\n          bool Match = Op == FromLocOp;\n          Changed |= Match;\n          return Match;\n        },\n        ToLocOp);\n    // Ignore this SDDbgValue if we didn't find a matching location.\n    if (!Changed)\n      continue;\n\n    DIVariable *Var = Dbg->getVariable();\n    auto *Expr = Dbg->getExpression();\n    // If a fragment is requested, update the expression.\n    if (SizeInBits) {\n      // When splitting a larger (e.g., sign-extended) value whose\n      // lower bits are described with an SDDbgValue, do not attempt\n      // to transfer the SDDbgValue to the upper bits.\n      if (auto FI = Expr->getFragmentInfo())\n        if (OffsetInBits + SizeInBits > FI->SizeInBits)\n          continue;\n      auto Fragment = DIExpression::createFragmentExpression(Expr, OffsetInBits,\n                                                             SizeInBits);\n      if (!Fragment)\n        continue;\n      Expr = *Fragment;\n    }\n\n    auto NewDependencies = Dbg->copySDNodes();\n    std::replace(NewDependencies.begin(), NewDependencies.end(), FromNode,\n                 ToNode);\n    // Clone the SDDbgValue and move it to To.\n    SDDbgValue *Clone = getDbgValueList(\n        Var, Expr, NewLocOps, NewDependencies, Dbg->isIndirect(),\n        Dbg->getDebugLoc(), std::max(ToNode->getIROrder(), Dbg->getOrder()),\n        Dbg->isVariadic());\n    ClonedDVs.push_back(Clone);\n\n    if (InvalidateDbg) {\n      // Invalidate value and indicate the SDDbgValue should not be emitted.\n      Dbg->setIsInvalidated();\n      Dbg->setIsEmitted();\n    }\n  }\n\n  for (SDDbgValue *Dbg : ClonedDVs) {\n    assert(is_contained(Dbg->getSDNodes(), ToNode) &&\n           \"Transferred DbgValues should depend on the new SDNode\");\n    AddDbgValue(Dbg, false);\n  }\n}\n\nvoid SelectionDAG::salvageDebugInfo(SDNode &N) {\n  if (!N.getHasDebugValue())\n    return;\n\n  SmallVector<SDDbgValue *, 2> ClonedDVs;\n  for (auto DV : GetDbgValues(&N)) {\n    if (DV->isInvalidated())\n      continue;\n    switch (N.getOpcode()) {\n    default:\n      break;\n    case ISD::ADD:\n      SDValue N0 = N.getOperand(0);\n      SDValue N1 = N.getOperand(1);\n      if (!isConstantIntBuildVectorOrConstantInt(N0) &&\n          isConstantIntBuildVectorOrConstantInt(N1)) {\n        uint64_t Offset = N.getConstantOperandVal(1);\n\n        // Rewrite an ADD constant node into a DIExpression. Since we are\n        // performing arithmetic to compute the variable's *value* in the\n        // DIExpression, we need to mark the expression with a\n        // DW_OP_stack_value.\n        auto *DIExpr = DV->getExpression();\n        auto NewLocOps = DV->copyLocationOps();\n        bool Changed = false;\n        for (size_t i = 0; i < NewLocOps.size(); ++i) {\n          // We're not given a ResNo to compare against because the whole\n          // node is going away. We know that any ISD::ADD only has one\n          // result, so we can assume any node match is using the result.\n          if (NewLocOps[i].getKind() != SDDbgOperand::SDNODE ||\n              NewLocOps[i].getSDNode() != &N)\n            continue;\n          NewLocOps[i] = SDDbgOperand::fromNode(N0.getNode(), N0.getResNo());\n          SmallVector<uint64_t, 3> ExprOps;\n          DIExpression::appendOffset(ExprOps, Offset);\n          DIExpr = DIExpression::appendOpsToArg(DIExpr, ExprOps, i, true);\n          Changed = true;\n        }\n        (void)Changed;\n        assert(Changed && \"Salvage target doesn't use N\");\n\n        auto NewDependencies = DV->copySDNodes();\n        std::replace(NewDependencies.begin(), NewDependencies.end(), &N,\n                     N0.getNode());\n        SDDbgValue *Clone = getDbgValueList(DV->getVariable(), DIExpr,\n                                            NewLocOps, NewDependencies,\n                                            DV->isIndirect(), DV->getDebugLoc(),\n                                            DV->getOrder(), DV->isVariadic());\n        ClonedDVs.push_back(Clone);\n        DV->setIsInvalidated();\n        DV->setIsEmitted();\n        LLVM_DEBUG(dbgs() << \"SALVAGE: Rewriting\";\n                   N0.getNode()->dumprFull(this);\n                   dbgs() << \" into \" << *DIExpr << '\\n');\n      }\n    }\n  }\n\n  for (SDDbgValue *Dbg : ClonedDVs) {\n    assert(!Dbg->getSDNodes().empty() &&\n           \"Salvaged DbgValue should depend on a new SDNode\");\n    AddDbgValue(Dbg, false);\n  }\n}\n\n/// Creates a SDDbgLabel node.\nSDDbgLabel *SelectionDAG::getDbgLabel(DILabel *Label,\n                                      const DebugLoc &DL, unsigned O) {\n  assert(cast<DILabel>(Label)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc()) SDDbgLabel(Label, DL, O);\n}\n\nnamespace {\n\n/// RAUWUpdateListener - Helper for ReplaceAllUsesWith - When the node\n/// pointed to by a use iterator is deleted, increment the use iterator\n/// so that it doesn't dangle.\n///\nclass RAUWUpdateListener : public SelectionDAG::DAGUpdateListener {\n  SDNode::use_iterator &UI;\n  SDNode::use_iterator &UE;\n\n  void NodeDeleted(SDNode *N, SDNode *E) override {\n    // Increment the iterator as needed.\n    while (UI != UE && N == *UI)\n      ++UI;\n  }\n\npublic:\n  RAUWUpdateListener(SelectionDAG &d,\n                     SDNode::use_iterator &ui,\n                     SDNode::use_iterator &ue)\n    : SelectionDAG::DAGUpdateListener(d), UI(ui), UE(ue) {}\n};\n\n} // end anonymous namespace\n\n/// ReplaceAllUsesWith - Modify anything using 'From' to use 'To' instead.\n/// This can cause recursive merging of nodes in the DAG.\n///\n/// This version assumes From has a single result value.\n///\nvoid SelectionDAG::ReplaceAllUsesWith(SDValue FromN, SDValue To) {\n  SDNode *From = FromN.getNode();\n  assert(From->getNumValues() == 1 && FromN.getResNo() == 0 &&\n         \"Cannot replace with this method!\");\n  assert(From != To.getNode() && \"Cannot replace uses of with self\");\n\n  // Preserve Debug Values\n  transferDbgValues(FromN, To);\n\n  // Iterate over all the existing uses of From. New uses will be added\n  // to the beginning of the use list, which we avoid visiting.\n  // This specifically avoids visiting uses of From that arise while the\n  // replacement is happening, because any such uses would be the result\n  // of CSE: If an existing node looks like From after one of its operands\n  // is replaced by To, we don't want to replace of all its users with To\n  // too. See PR3018 for more info.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this\n    // happens the uses are usually next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      SDUse &Use = UI.getUse();\n      ++UI;\n      Use.set(To);\n      if (To->isDivergent() != From->isDivergent())\n        updateDivergence(User);\n    } while (UI != UE && *UI == User);\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (FromN == getRoot())\n    setRoot(To);\n}\n\n/// ReplaceAllUsesWith - Modify anything using 'From' to use 'To' instead.\n/// This can cause recursive merging of nodes in the DAG.\n///\n/// This version assumes that for each value of From, there is a\n/// corresponding value in To in the same position with the same type.\n///\nvoid SelectionDAG::ReplaceAllUsesWith(SDNode *From, SDNode *To) {\n#ifndef NDEBUG\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n    assert((!From->hasAnyUseOfValue(i) ||\n            From->getValueType(i) == To->getValueType(i)) &&\n           \"Cannot use this version of ReplaceAllUsesWith!\");\n#endif\n\n  // Handle the trivial case.\n  if (From == To)\n    return;\n\n  // Preserve Debug Info. Only do this if there's a use.\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n    if (From->hasAnyUseOfValue(i)) {\n      assert((i < To->getNumValues()) && \"Invalid To location\");\n      transferDbgValues(SDValue(From, i), SDValue(To, i));\n    }\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this\n    // happens the uses are usually next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      SDUse &Use = UI.getUse();\n      ++UI;\n      Use.setNode(To);\n      if (To->isDivergent() != From->isDivergent())\n        updateDivergence(User);\n    } while (UI != UE && *UI == User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot().getNode())\n    setRoot(SDValue(To, getRoot().getResNo()));\n}\n\n/// ReplaceAllUsesWith - Modify anything using 'From' to use 'To' instead.\n/// This can cause recursive merging of nodes in the DAG.\n///\n/// This version can replace From with any result values.  To must match the\n/// number and types of values returned by From.\nvoid SelectionDAG::ReplaceAllUsesWith(SDNode *From, const SDValue *To) {\n  if (From->getNumValues() == 1)  // Handle the simple case efficiently.\n    return ReplaceAllUsesWith(SDValue(From, 0), To[0]);\n\n  // Preserve Debug Info.\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n    transferDbgValues(SDValue(From, i), To[i]);\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this happens the\n    // uses are usually next to each other in the list.  To help reduce the\n    // number of CSE and divergence recomputations, process all the uses of this\n    // user that we can find this way.\n    bool To_IsDivergent = false;\n    do {\n      SDUse &Use = UI.getUse();\n      const SDValue &ToOp = To[Use.getResNo()];\n      ++UI;\n      Use.set(ToOp);\n      To_IsDivergent |= ToOp->isDivergent();\n    } while (UI != UE && *UI == User);\n\n    if (To_IsDivergent != From->isDivergent())\n      updateDivergence(User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot().getNode())\n    setRoot(SDValue(To[getRoot().getResNo()]));\n}\n\n/// ReplaceAllUsesOfValueWith - Replace any uses of From with To, leaving\n/// uses of other values produced by From.getNode() alone.  The Deleted\n/// vector is handled the same way as for ReplaceAllUsesWith.\nvoid SelectionDAG::ReplaceAllUsesOfValueWith(SDValue From, SDValue To){\n  // Handle the really simple, really trivial case efficiently.\n  if (From == To) return;\n\n  // Handle the simple, trivial, case efficiently.\n  if (From.getNode()->getNumValues() == 1) {\n    ReplaceAllUsesWith(From, To);\n    return;\n  }\n\n  // Preserve Debug Info.\n  transferDbgValues(From, To);\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From.getNode()->use_begin(),\n                       UE = From.getNode()->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n    bool UserRemovedFromCSEMaps = false;\n\n    // A user can appear in a use list multiple times, and when this\n    // happens the uses are usually next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      SDUse &Use = UI.getUse();\n\n      // Skip uses of different values from the same node.\n      if (Use.getResNo() != From.getResNo()) {\n        ++UI;\n        continue;\n      }\n\n      // If this node hasn't been modified yet, it's still in the CSE maps,\n      // so remove its old self from the CSE maps.\n      if (!UserRemovedFromCSEMaps) {\n        RemoveNodeFromCSEMaps(User);\n        UserRemovedFromCSEMaps = true;\n      }\n\n      ++UI;\n      Use.set(To);\n      if (To->isDivergent() != From->isDivergent())\n        updateDivergence(User);\n    } while (UI != UE && *UI == User);\n    // We are iterating over all uses of the From node, so if a use\n    // doesn't use the specific value, no changes are made.\n    if (!UserRemovedFromCSEMaps)\n      continue;\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot())\n    setRoot(To);\n}\n\nnamespace {\n\n  /// UseMemo - This class is used by SelectionDAG::ReplaceAllUsesOfValuesWith\n  /// to record information about a use.\n  struct UseMemo {\n    SDNode *User;\n    unsigned Index;\n    SDUse *Use;\n  };\n\n  /// operator< - Sort Memos by User.\n  bool operator<(const UseMemo &L, const UseMemo &R) {\n    return (intptr_t)L.User < (intptr_t)R.User;\n  }\n\n} // end anonymous namespace\n\nbool SelectionDAG::calculateDivergence(SDNode *N) {\n  if (TLI->isSDNodeAlwaysUniform(N)) {\n    assert(!TLI->isSDNodeSourceOfDivergence(N, FLI, DA) &&\n           \"Conflicting divergence information!\");\n    return false;\n  }\n  if (TLI->isSDNodeSourceOfDivergence(N, FLI, DA))\n    return true;\n  for (auto &Op : N->ops()) {\n    if (Op.Val.getValueType() != MVT::Other && Op.getNode()->isDivergent())\n      return true;\n  }\n  return false;\n}\n\nvoid SelectionDAG::updateDivergence(SDNode *N) {\n  SmallVector<SDNode *, 16> Worklist(1, N);\n  do {\n    N = Worklist.pop_back_val();\n    bool IsDivergent = calculateDivergence(N);\n    if (N->SDNodeBits.IsDivergent != IsDivergent) {\n      N->SDNodeBits.IsDivergent = IsDivergent;\n      llvm::append_range(Worklist, N->uses());\n    }\n  } while (!Worklist.empty());\n}\n\nvoid SelectionDAG::CreateTopologicalOrder(std::vector<SDNode *> &Order) {\n  DenseMap<SDNode *, unsigned> Degree;\n  Order.reserve(AllNodes.size());\n  for (auto &N : allnodes()) {\n    unsigned NOps = N.getNumOperands();\n    Degree[&N] = NOps;\n    if (0 == NOps)\n      Order.push_back(&N);\n  }\n  for (size_t I = 0; I != Order.size(); ++I) {\n    SDNode *N = Order[I];\n    for (auto U : N->uses()) {\n      unsigned &UnsortedOps = Degree[U];\n      if (0 == --UnsortedOps)\n        Order.push_back(U);\n    }\n  }\n}\n\n#ifndef NDEBUG\nvoid SelectionDAG::VerifyDAGDiverence() {\n  std::vector<SDNode *> TopoOrder;\n  CreateTopologicalOrder(TopoOrder);\n  for (auto *N : TopoOrder) {\n    assert(calculateDivergence(N) == N->isDivergent() &&\n           \"Divergence bit inconsistency detected\");\n  }\n}\n#endif\n\n/// ReplaceAllUsesOfValuesWith - Replace any uses of From with To, leaving\n/// uses of other values produced by From.getNode() alone.  The same value\n/// may appear in both the From and To list.  The Deleted vector is\n/// handled the same way as for ReplaceAllUsesWith.\nvoid SelectionDAG::ReplaceAllUsesOfValuesWith(const SDValue *From,\n                                              const SDValue *To,\n                                              unsigned Num){\n  // Handle the simple, trivial case efficiently.\n  if (Num == 1)\n    return ReplaceAllUsesOfValueWith(*From, *To);\n\n  transferDbgValues(*From, *To);\n\n  // Read up all the uses and make records of them. This helps\n  // processing new uses that are introduced during the\n  // replacement process.\n  SmallVector<UseMemo, 4> Uses;\n  for (unsigned i = 0; i != Num; ++i) {\n    unsigned FromResNo = From[i].getResNo();\n    SDNode *FromNode = From[i].getNode();\n    for (SDNode::use_iterator UI = FromNode->use_begin(),\n         E = FromNode->use_end(); UI != E; ++UI) {\n      SDUse &Use = UI.getUse();\n      if (Use.getResNo() == FromResNo) {\n        UseMemo Memo = { *UI, i, &Use };\n        Uses.push_back(Memo);\n      }\n    }\n  }\n\n  // Sort the uses, so that all the uses from a given User are together.\n  llvm::sort(Uses);\n\n  for (unsigned UseIndex = 0, UseIndexEnd = Uses.size();\n       UseIndex != UseIndexEnd; ) {\n    // We know that this user uses some value of From.  If it is the right\n    // value, update it.\n    SDNode *User = Uses[UseIndex].User;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // The Uses array is sorted, so all the uses for a given User\n    // are next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      unsigned i = Uses[UseIndex].Index;\n      SDUse &Use = *Uses[UseIndex].Use;\n      ++UseIndex;\n\n      Use.set(To[i]);\n    } while (UseIndex != UseIndexEnd && Uses[UseIndex].User == User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n}\n\n/// AssignTopologicalOrder - Assign a unique node id for each node in the DAG\n/// based on their topological order. It returns the maximum id and a vector\n/// of the SDNodes* in assigned order by reference.\nunsigned SelectionDAG::AssignTopologicalOrder() {\n  unsigned DAGSize = 0;\n\n  // SortedPos tracks the progress of the algorithm. Nodes before it are\n  // sorted, nodes after it are unsorted. When the algorithm completes\n  // it is at the end of the list.\n  allnodes_iterator SortedPos = allnodes_begin();\n\n  // Visit all the nodes. Move nodes with no operands to the front of\n  // the list immediately. Annotate nodes that do have operands with their\n  // operand count. Before we do this, the Node Id fields of the nodes\n  // may contain arbitrary values. After, the Node Id fields for nodes\n  // before SortedPos will contain the topological sort index, and the\n  // Node Id fields for nodes At SortedPos and after will contain the\n  // count of outstanding operands.\n  for (allnodes_iterator I = allnodes_begin(),E = allnodes_end(); I != E; ) {\n    SDNode *N = &*I++;\n    checkForCycles(N, this);\n    unsigned Degree = N->getNumOperands();\n    if (Degree == 0) {\n      // A node with no uses, add it to the result array immediately.\n      N->setNodeId(DAGSize++);\n      allnodes_iterator Q(N);\n      if (Q != SortedPos)\n        SortedPos = AllNodes.insert(SortedPos, AllNodes.remove(Q));\n      assert(SortedPos != AllNodes.end() && \"Overran node list\");\n      ++SortedPos;\n    } else {\n      // Temporarily use the Node Id as scratch space for the degree count.\n      N->setNodeId(Degree);\n    }\n  }\n\n  // Visit all the nodes. As we iterate, move nodes into sorted order,\n  // such that by the time the end is reached all nodes will be sorted.\n  for (SDNode &Node : allnodes()) {\n    SDNode *N = &Node;\n    checkForCycles(N, this);\n    // N is in sorted position, so all its uses have one less operand\n    // that needs to be sorted.\n    for (SDNode *P : N->uses()) {\n      unsigned Degree = P->getNodeId();\n      assert(Degree != 0 && \"Invalid node degree\");\n      --Degree;\n      if (Degree == 0) {\n        // All of P's operands are sorted, so P may sorted now.\n        P->setNodeId(DAGSize++);\n        if (P->getIterator() != SortedPos)\n          SortedPos = AllNodes.insert(SortedPos, AllNodes.remove(P));\n        assert(SortedPos != AllNodes.end() && \"Overran node list\");\n        ++SortedPos;\n      } else {\n        // Update P's outstanding operand count.\n        P->setNodeId(Degree);\n      }\n    }\n    if (Node.getIterator() == SortedPos) {\n#ifndef NDEBUG\n      allnodes_iterator I(N);\n      SDNode *S = &*++I;\n      dbgs() << \"Overran sorted position:\\n\";\n      S->dumprFull(this); dbgs() << \"\\n\";\n      dbgs() << \"Checking if this is due to cycles\\n\";\n      checkForCycles(this, true);\n#endif\n      llvm_unreachable(nullptr);\n    }\n  }\n\n  assert(SortedPos == AllNodes.end() &&\n         \"Topological sort incomplete!\");\n  assert(AllNodes.front().getOpcode() == ISD::EntryToken &&\n         \"First node in topological sort is not the entry token!\");\n  assert(AllNodes.front().getNodeId() == 0 &&\n         \"First node in topological sort has non-zero id!\");\n  assert(AllNodes.front().getNumOperands() == 0 &&\n         \"First node in topological sort has operands!\");\n  assert(AllNodes.back().getNodeId() == (int)DAGSize-1 &&\n         \"Last node in topologic sort has unexpected id!\");\n  assert(AllNodes.back().use_empty() &&\n         \"Last node in topologic sort has users!\");\n  assert(DAGSize == allnodes_size() && \"Node count mismatch!\");\n  return DAGSize;\n}\n\n/// AddDbgValue - Add a dbg_value SDNode. If SD is non-null that means the\n/// value is produced by SD.\nvoid SelectionDAG::AddDbgValue(SDDbgValue *DB, bool isParameter) {\n  for (SDNode *SD : DB->getSDNodes()) {\n    if (!SD)\n      continue;\n    assert(DbgInfo->getSDDbgValues(SD).empty() || SD->getHasDebugValue());\n    SD->setHasDebugValue(true);\n  }\n  DbgInfo->add(DB, isParameter);\n}\n\nvoid SelectionDAG::AddDbgLabel(SDDbgLabel *DB) { DbgInfo->add(DB); }\n\nSDValue SelectionDAG::makeEquivalentMemoryOrdering(SDValue OldChain,\n                                                   SDValue NewMemOpChain) {\n  assert(isa<MemSDNode>(NewMemOpChain) && \"Expected a memop node\");\n  assert(NewMemOpChain.getValueType() == MVT::Other && \"Expected a token VT\");\n  // The new memory operation must have the same position as the old load in\n  // terms of memory dependency. Create a TokenFactor for the old load and new\n  // memory operation and update uses of the old load's output chain to use that\n  // TokenFactor.\n  if (OldChain == NewMemOpChain || OldChain.use_empty())\n    return NewMemOpChain;\n\n  SDValue TokenFactor = getNode(ISD::TokenFactor, SDLoc(OldChain), MVT::Other,\n                                OldChain, NewMemOpChain);\n  ReplaceAllUsesOfValueWith(OldChain, TokenFactor);\n  UpdateNodeOperands(TokenFactor.getNode(), OldChain, NewMemOpChain);\n  return TokenFactor;\n}\n\nSDValue SelectionDAG::makeEquivalentMemoryOrdering(LoadSDNode *OldLoad,\n                                                   SDValue NewMemOp) {\n  assert(isa<MemSDNode>(NewMemOp.getNode()) && \"Expected a memop node\");\n  SDValue OldChain = SDValue(OldLoad, 1);\n  SDValue NewMemOpChain = NewMemOp.getValue(1);\n  return makeEquivalentMemoryOrdering(OldChain, NewMemOpChain);\n}\n\nSDValue SelectionDAG::getSymbolFunctionGlobalAddress(SDValue Op,\n                                                     Function **OutFunction) {\n  assert(isa<ExternalSymbolSDNode>(Op) && \"Node should be an ExternalSymbol\");\n\n  auto *Symbol = cast<ExternalSymbolSDNode>(Op)->getSymbol();\n  auto *Module = MF->getFunction().getParent();\n  auto *Function = Module->getFunction(Symbol);\n\n  if (OutFunction != nullptr)\n      *OutFunction = Function;\n\n  if (Function != nullptr) {\n    auto PtrTy = TLI->getPointerTy(getDataLayout(), Function->getAddressSpace());\n    return getGlobalAddress(Function, SDLoc(Op), PtrTy);\n  }\n\n  std::string ErrorStr;\n  raw_string_ostream ErrorFormatter(ErrorStr);\n\n  ErrorFormatter << \"Undefined external symbol \";\n  ErrorFormatter << '\"' << Symbol << '\"';\n  ErrorFormatter.flush();\n\n  report_fatal_error(ErrorStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                              SDNode Class\n//===----------------------------------------------------------------------===//\n\nbool llvm::isNullConstant(SDValue V) {\n  ConstantSDNode *Const = dyn_cast<ConstantSDNode>(V);\n  return Const != nullptr && Const->isNullValue();\n}\n\nbool llvm::isNullFPConstant(SDValue V) {\n  ConstantFPSDNode *Const = dyn_cast<ConstantFPSDNode>(V);\n  return Const != nullptr && Const->isZero() && !Const->isNegative();\n}\n\nbool llvm::isAllOnesConstant(SDValue V) {\n  ConstantSDNode *Const = dyn_cast<ConstantSDNode>(V);\n  return Const != nullptr && Const->isAllOnesValue();\n}\n\nbool llvm::isOneConstant(SDValue V) {\n  ConstantSDNode *Const = dyn_cast<ConstantSDNode>(V);\n  return Const != nullptr && Const->isOne();\n}\n\nSDValue llvm::peekThroughBitcasts(SDValue V) {\n  while (V.getOpcode() == ISD::BITCAST)\n    V = V.getOperand(0);\n  return V;\n}\n\nSDValue llvm::peekThroughOneUseBitcasts(SDValue V) {\n  while (V.getOpcode() == ISD::BITCAST && V.getOperand(0).hasOneUse())\n    V = V.getOperand(0);\n  return V;\n}\n\nSDValue llvm::peekThroughExtractSubvectors(SDValue V) {\n  while (V.getOpcode() == ISD::EXTRACT_SUBVECTOR)\n    V = V.getOperand(0);\n  return V;\n}\n\nbool llvm::isBitwiseNot(SDValue V, bool AllowUndefs) {\n  if (V.getOpcode() != ISD::XOR)\n    return false;\n  V = peekThroughBitcasts(V.getOperand(1));\n  unsigned NumBits = V.getScalarValueSizeInBits();\n  ConstantSDNode *C =\n      isConstOrConstSplat(V, AllowUndefs, /*AllowTruncation*/ true);\n  return C && (C->getAPIntValue().countTrailingOnes() >= NumBits);\n}\n\nConstantSDNode *llvm::isConstOrConstSplat(SDValue N, bool AllowUndefs,\n                                          bool AllowTruncation) {\n  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N))\n    return CN;\n\n  // SplatVectors can truncate their operands. Ignore that case here unless\n  // AllowTruncation is set.\n  if (N->getOpcode() == ISD::SPLAT_VECTOR) {\n    EVT VecEltVT = N->getValueType(0).getVectorElementType();\n    if (auto *CN = dyn_cast<ConstantSDNode>(N->getOperand(0))) {\n      EVT CVT = CN->getValueType(0);\n      assert(CVT.bitsGE(VecEltVT) && \"Illegal splat_vector element extension\");\n      if (AllowTruncation || CVT == VecEltVT)\n        return CN;\n    }\n  }\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantSDNode *CN = BV->getConstantSplatNode(&UndefElements);\n\n    // BuildVectors can truncate their operands. Ignore that case here unless\n    // AllowTruncation is set.\n    if (CN && (UndefElements.none() || AllowUndefs)) {\n      EVT CVT = CN->getValueType(0);\n      EVT NSVT = N.getValueType().getScalarType();\n      assert(CVT.bitsGE(NSVT) && \"Illegal build vector element extension\");\n      if (AllowTruncation || (CVT == NSVT))\n        return CN;\n    }\n  }\n\n  return nullptr;\n}\n\nConstantSDNode *llvm::isConstOrConstSplat(SDValue N, const APInt &DemandedElts,\n                                          bool AllowUndefs,\n                                          bool AllowTruncation) {\n  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N))\n    return CN;\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantSDNode *CN = BV->getConstantSplatNode(DemandedElts, &UndefElements);\n\n    // BuildVectors can truncate their operands. Ignore that case here unless\n    // AllowTruncation is set.\n    if (CN && (UndefElements.none() || AllowUndefs)) {\n      EVT CVT = CN->getValueType(0);\n      EVT NSVT = N.getValueType().getScalarType();\n      assert(CVT.bitsGE(NSVT) && \"Illegal build vector element extension\");\n      if (AllowTruncation || (CVT == NSVT))\n        return CN;\n    }\n  }\n\n  return nullptr;\n}\n\nConstantFPSDNode *llvm::isConstOrConstSplatFP(SDValue N, bool AllowUndefs) {\n  if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(N))\n    return CN;\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantFPSDNode *CN = BV->getConstantFPSplatNode(&UndefElements);\n    if (CN && (UndefElements.none() || AllowUndefs))\n      return CN;\n  }\n\n  if (N.getOpcode() == ISD::SPLAT_VECTOR)\n    if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(N.getOperand(0)))\n      return CN;\n\n  return nullptr;\n}\n\nConstantFPSDNode *llvm::isConstOrConstSplatFP(SDValue N,\n                                              const APInt &DemandedElts,\n                                              bool AllowUndefs) {\n  if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(N))\n    return CN;\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantFPSDNode *CN =\n        BV->getConstantFPSplatNode(DemandedElts, &UndefElements);\n    if (CN && (UndefElements.none() || AllowUndefs))\n      return CN;\n  }\n\n  return nullptr;\n}\n\nbool llvm::isNullOrNullSplat(SDValue N, bool AllowUndefs) {\n  // TODO: may want to use peekThroughBitcast() here.\n  ConstantSDNode *C = isConstOrConstSplat(N, AllowUndefs);\n  return C && C->isNullValue();\n}\n\nbool llvm::isOneOrOneSplat(SDValue N, bool AllowUndefs) {\n  // TODO: may want to use peekThroughBitcast() here.\n  unsigned BitWidth = N.getScalarValueSizeInBits();\n  ConstantSDNode *C = isConstOrConstSplat(N, AllowUndefs);\n  return C && C->isOne() && C->getValueSizeInBits(0) == BitWidth;\n}\n\nbool llvm::isAllOnesOrAllOnesSplat(SDValue N, bool AllowUndefs) {\n  N = peekThroughBitcasts(N);\n  unsigned BitWidth = N.getScalarValueSizeInBits();\n  ConstantSDNode *C = isConstOrConstSplat(N, AllowUndefs);\n  return C && C->isAllOnesValue() && C->getValueSizeInBits(0) == BitWidth;\n}\n\nHandleSDNode::~HandleSDNode() {\n  DropOperands();\n}\n\nGlobalAddressSDNode::GlobalAddressSDNode(unsigned Opc, unsigned Order,\n                                         const DebugLoc &DL,\n                                         const GlobalValue *GA, EVT VT,\n                                         int64_t o, unsigned TF)\n    : SDNode(Opc, Order, DL, getSDVTList(VT)), Offset(o), TargetFlags(TF) {\n  TheGlobal = GA;\n}\n\nAddrSpaceCastSDNode::AddrSpaceCastSDNode(unsigned Order, const DebugLoc &dl,\n                                         EVT VT, unsigned SrcAS,\n                                         unsigned DestAS)\n    : SDNode(ISD::ADDRSPACECAST, Order, dl, getSDVTList(VT)),\n      SrcAddrSpace(SrcAS), DestAddrSpace(DestAS) {}\n\nMemSDNode::MemSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl,\n                     SDVTList VTs, EVT memvt, MachineMemOperand *mmo)\n    : SDNode(Opc, Order, dl, VTs), MemoryVT(memvt), MMO(mmo) {\n  MemSDNodeBits.IsVolatile = MMO->isVolatile();\n  MemSDNodeBits.IsNonTemporal = MMO->isNonTemporal();\n  MemSDNodeBits.IsDereferenceable = MMO->isDereferenceable();\n  MemSDNodeBits.IsInvariant = MMO->isInvariant();\n\n  // We check here that the size of the memory operand fits within the size of\n  // the MMO. This is because the MMO might indicate only a possible address\n  // range instead of specifying the affected memory addresses precisely.\n  // TODO: Make MachineMemOperands aware of scalable vectors.\n  assert(memvt.getStoreSize().getKnownMinSize() <= MMO->getSize() &&\n         \"Size mismatch!\");\n}\n\n/// Profile - Gather unique data for the node.\n///\nvoid SDNode::Profile(FoldingSetNodeID &ID) const {\n  AddNodeIDNode(ID, this);\n}\n\nnamespace {\n\n  struct EVTArray {\n    std::vector<EVT> VTs;\n\n    EVTArray() {\n      VTs.reserve(MVT::LAST_VALUETYPE);\n      for (unsigned i = 0; i < MVT::LAST_VALUETYPE; ++i)\n        VTs.push_back(MVT((MVT::SimpleValueType)i));\n    }\n  };\n\n} // end anonymous namespace\n\nstatic ManagedStatic<std::set<EVT, EVT::compareRawBits>> EVTs;\nstatic ManagedStatic<EVTArray> SimpleVTArray;\nstatic ManagedStatic<sys::SmartMutex<true>> VTMutex;\n\n/// getValueTypeList - Return a pointer to the specified value type.\n///\nconst EVT *SDNode::getValueTypeList(EVT VT) {\n  if (VT.isExtended()) {\n    sys::SmartScopedLock<true> Lock(*VTMutex);\n    return &(*EVTs->insert(VT).first);\n  } else {\n    assert(VT.getSimpleVT() < MVT::LAST_VALUETYPE &&\n           \"Value type out of range!\");\n    return &SimpleVTArray->VTs[VT.getSimpleVT().SimpleTy];\n  }\n}\n\n/// hasNUsesOfValue - Return true if there are exactly NUSES uses of the\n/// indicated value.  This method ignores uses of other values defined by this\n/// operation.\nbool SDNode::hasNUsesOfValue(unsigned NUses, unsigned Value) const {\n  assert(Value < getNumValues() && \"Bad value!\");\n\n  // TODO: Only iterate over uses of a given value of the node\n  for (SDNode::use_iterator UI = use_begin(), E = use_end(); UI != E; ++UI) {\n    if (UI.getUse().getResNo() == Value) {\n      if (NUses == 0)\n        return false;\n      --NUses;\n    }\n  }\n\n  // Found exactly the right number of uses?\n  return NUses == 0;\n}\n\n/// hasAnyUseOfValue - Return true if there are any use of the indicated\n/// value. This method ignores uses of other values defined by this operation.\nbool SDNode::hasAnyUseOfValue(unsigned Value) const {\n  assert(Value < getNumValues() && \"Bad value!\");\n\n  for (SDNode::use_iterator UI = use_begin(), E = use_end(); UI != E; ++UI)\n    if (UI.getUse().getResNo() == Value)\n      return true;\n\n  return false;\n}\n\n/// isOnlyUserOf - Return true if this node is the only use of N.\nbool SDNode::isOnlyUserOf(const SDNode *N) const {\n  bool Seen = false;\n  for (SDNode::use_iterator I = N->use_begin(), E = N->use_end(); I != E; ++I) {\n    SDNode *User = *I;\n    if (User == this)\n      Seen = true;\n    else\n      return false;\n  }\n\n  return Seen;\n}\n\n/// Return true if the only users of N are contained in Nodes.\nbool SDNode::areOnlyUsersOf(ArrayRef<const SDNode *> Nodes, const SDNode *N) {\n  bool Seen = false;\n  for (SDNode::use_iterator I = N->use_begin(), E = N->use_end(); I != E; ++I) {\n    SDNode *User = *I;\n    if (llvm::is_contained(Nodes, User))\n      Seen = true;\n    else\n      return false;\n  }\n\n  return Seen;\n}\n\n/// isOperand - Return true if this node is an operand of N.\nbool SDValue::isOperandOf(const SDNode *N) const {\n  return is_contained(N->op_values(), *this);\n}\n\nbool SDNode::isOperandOf(const SDNode *N) const {\n  return any_of(N->op_values(),\n                [this](SDValue Op) { return this == Op.getNode(); });\n}\n\n/// reachesChainWithoutSideEffects - Return true if this operand (which must\n/// be a chain) reaches the specified operand without crossing any\n/// side-effecting instructions on any chain path.  In practice, this looks\n/// through token factors and non-volatile loads.  In order to remain efficient,\n/// this only looks a couple of nodes in, it does not do an exhaustive search.\n///\n/// Note that we only need to examine chains when we're searching for\n/// side-effects; SelectionDAG requires that all side-effects are represented\n/// by chains, even if another operand would force a specific ordering. This\n/// constraint is necessary to allow transformations like splitting loads.\nbool SDValue::reachesChainWithoutSideEffects(SDValue Dest,\n                                             unsigned Depth) const {\n  if (*this == Dest) return true;\n\n  // Don't search too deeply, we just want to be able to see through\n  // TokenFactor's etc.\n  if (Depth == 0) return false;\n\n  // If this is a token factor, all inputs to the TF happen in parallel.\n  if (getOpcode() == ISD::TokenFactor) {\n    // First, try a shallow search.\n    if (is_contained((*this)->ops(), Dest)) {\n      // We found the chain we want as an operand of this TokenFactor.\n      // Essentially, we reach the chain without side-effects if we could\n      // serialize the TokenFactor into a simple chain of operations with\n      // Dest as the last operation. This is automatically true if the\n      // chain has one use: there are no other ordering constraints.\n      // If the chain has more than one use, we give up: some other\n      // use of Dest might force a side-effect between Dest and the current\n      // node.\n      if (Dest.hasOneUse())\n        return true;\n    }\n    // Next, try a deep search: check whether every operand of the TokenFactor\n    // reaches Dest.\n    return llvm::all_of((*this)->ops(), [=](SDValue Op) {\n      return Op.reachesChainWithoutSideEffects(Dest, Depth - 1);\n    });\n  }\n\n  // Loads don't have side effects, look through them.\n  if (LoadSDNode *Ld = dyn_cast<LoadSDNode>(*this)) {\n    if (Ld->isUnordered())\n      return Ld->getChain().reachesChainWithoutSideEffects(Dest, Depth-1);\n  }\n  return false;\n}\n\nbool SDNode::hasPredecessor(const SDNode *N) const {\n  SmallPtrSet<const SDNode *, 32> Visited;\n  SmallVector<const SDNode *, 16> Worklist;\n  Worklist.push_back(this);\n  return hasPredecessorHelper(N, Visited, Worklist);\n}\n\nvoid SDNode::intersectFlagsWith(const SDNodeFlags Flags) {\n  this->Flags.intersectWith(Flags);\n}\n\nSDValue\nSelectionDAG::matchBinOpReduction(SDNode *Extract, ISD::NodeType &BinOp,\n                                  ArrayRef<ISD::NodeType> CandidateBinOps,\n                                  bool AllowPartials) {\n  // The pattern must end in an extract from index 0.\n  if (Extract->getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n      !isNullConstant(Extract->getOperand(1)))\n    return SDValue();\n\n  // Match against one of the candidate binary ops.\n  SDValue Op = Extract->getOperand(0);\n  if (llvm::none_of(CandidateBinOps, [Op](ISD::NodeType BinOp) {\n        return Op.getOpcode() == unsigned(BinOp);\n      }))\n    return SDValue();\n\n  // Floating-point reductions may require relaxed constraints on the final step\n  // of the reduction because they may reorder intermediate operations.\n  unsigned CandidateBinOp = Op.getOpcode();\n  if (Op.getValueType().isFloatingPoint()) {\n    SDNodeFlags Flags = Op->getFlags();\n    switch (CandidateBinOp) {\n    case ISD::FADD:\n      if (!Flags.hasNoSignedZeros() || !Flags.hasAllowReassociation())\n        return SDValue();\n      break;\n    default:\n      llvm_unreachable(\"Unhandled FP opcode for binop reduction\");\n    }\n  }\n\n  // Matching failed - attempt to see if we did enough stages that a partial\n  // reduction from a subvector is possible.\n  auto PartialReduction = [&](SDValue Op, unsigned NumSubElts) {\n    if (!AllowPartials || !Op)\n      return SDValue();\n    EVT OpVT = Op.getValueType();\n    EVT OpSVT = OpVT.getScalarType();\n    EVT SubVT = EVT::getVectorVT(*getContext(), OpSVT, NumSubElts);\n    if (!TLI->isExtractSubvectorCheap(SubVT, OpVT, 0))\n      return SDValue();\n    BinOp = (ISD::NodeType)CandidateBinOp;\n    return getNode(ISD::EXTRACT_SUBVECTOR, SDLoc(Op), SubVT, Op,\n                   getVectorIdxConstant(0, SDLoc(Op)));\n  };\n\n  // At each stage, we're looking for something that looks like:\n  // %s = shufflevector <8 x i32> %op, <8 x i32> undef,\n  //                    <8 x i32> <i32 2, i32 3, i32 undef, i32 undef,\n  //                               i32 undef, i32 undef, i32 undef, i32 undef>\n  // %a = binop <8 x i32> %op, %s\n  // Where the mask changes according to the stage. E.g. for a 3-stage pyramid,\n  // we expect something like:\n  // <4,5,6,7,u,u,u,u>\n  // <2,3,u,u,u,u,u,u>\n  // <1,u,u,u,u,u,u,u>\n  // While a partial reduction match would be:\n  // <2,3,u,u,u,u,u,u>\n  // <1,u,u,u,u,u,u,u>\n  unsigned Stages = Log2_32(Op.getValueType().getVectorNumElements());\n  SDValue PrevOp;\n  for (unsigned i = 0; i < Stages; ++i) {\n    unsigned MaskEnd = (1 << i);\n\n    if (Op.getOpcode() != CandidateBinOp)\n      return PartialReduction(PrevOp, MaskEnd);\n\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    ShuffleVectorSDNode *Shuffle = dyn_cast<ShuffleVectorSDNode>(Op0);\n    if (Shuffle) {\n      Op = Op1;\n    } else {\n      Shuffle = dyn_cast<ShuffleVectorSDNode>(Op1);\n      Op = Op0;\n    }\n\n    // The first operand of the shuffle should be the same as the other operand\n    // of the binop.\n    if (!Shuffle || Shuffle->getOperand(0) != Op)\n      return PartialReduction(PrevOp, MaskEnd);\n\n    // Verify the shuffle has the expected (at this stage of the pyramid) mask.\n    for (int Index = 0; Index < (int)MaskEnd; ++Index)\n      if (Shuffle->getMaskElt(Index) != (int)(MaskEnd + Index))\n        return PartialReduction(PrevOp, MaskEnd);\n\n    PrevOp = Op;\n  }\n\n  // Handle subvector reductions, which tend to appear after the shuffle\n  // reduction stages.\n  while (Op.getOpcode() == CandidateBinOp) {\n    unsigned NumElts = Op.getValueType().getVectorNumElements();\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    if (Op0.getOpcode() != ISD::EXTRACT_SUBVECTOR ||\n        Op1.getOpcode() != ISD::EXTRACT_SUBVECTOR ||\n        Op0.getOperand(0) != Op1.getOperand(0))\n      break;\n    SDValue Src = Op0.getOperand(0);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    if (NumSrcElts != (2 * NumElts))\n      break;\n    if (!(Op0.getConstantOperandAPInt(1) == 0 &&\n          Op1.getConstantOperandAPInt(1) == NumElts) &&\n        !(Op1.getConstantOperandAPInt(1) == 0 &&\n          Op0.getConstantOperandAPInt(1) == NumElts))\n      break;\n    Op = Src;\n  }\n\n  BinOp = (ISD::NodeType)CandidateBinOp;\n  return Op;\n}\n\nSDValue SelectionDAG::UnrollVectorOp(SDNode *N, unsigned ResNE) {\n  assert(N->getNumValues() == 1 &&\n         \"Can't unroll a vector with multiple results!\");\n\n  EVT VT = N->getValueType(0);\n  unsigned NE = VT.getVectorNumElements();\n  EVT EltVT = VT.getVectorElementType();\n  SDLoc dl(N);\n\n  SmallVector<SDValue, 8> Scalars;\n  SmallVector<SDValue, 4> Operands(N->getNumOperands());\n\n  // If ResNE is 0, fully unroll the vector op.\n  if (ResNE == 0)\n    ResNE = NE;\n  else if (NE > ResNE)\n    NE = ResNE;\n\n  unsigned i;\n  for (i= 0; i != NE; ++i) {\n    for (unsigned j = 0, e = N->getNumOperands(); j != e; ++j) {\n      SDValue Operand = N->getOperand(j);\n      EVT OperandVT = Operand.getValueType();\n      if (OperandVT.isVector()) {\n        // A vector operand; extract a single element.\n        EVT OperandEltVT = OperandVT.getVectorElementType();\n        Operands[j] = getNode(ISD::EXTRACT_VECTOR_ELT, dl, OperandEltVT,\n                              Operand, getVectorIdxConstant(i, dl));\n      } else {\n        // A scalar operand; just use it as is.\n        Operands[j] = Operand;\n      }\n    }\n\n    switch (N->getOpcode()) {\n    default: {\n      Scalars.push_back(getNode(N->getOpcode(), dl, EltVT, Operands,\n                                N->getFlags()));\n      break;\n    }\n    case ISD::VSELECT:\n      Scalars.push_back(getNode(ISD::SELECT, dl, EltVT, Operands));\n      break;\n    case ISD::SHL:\n    case ISD::SRA:\n    case ISD::SRL:\n    case ISD::ROTL:\n    case ISD::ROTR:\n      Scalars.push_back(getNode(N->getOpcode(), dl, EltVT, Operands[0],\n                               getShiftAmountOperand(Operands[0].getValueType(),\n                                                     Operands[1])));\n      break;\n    case ISD::SIGN_EXTEND_INREG: {\n      EVT ExtVT = cast<VTSDNode>(Operands[1])->getVT().getVectorElementType();\n      Scalars.push_back(getNode(N->getOpcode(), dl, EltVT,\n                                Operands[0],\n                                getValueType(ExtVT)));\n    }\n    }\n  }\n\n  for (; i < ResNE; ++i)\n    Scalars.push_back(getUNDEF(EltVT));\n\n  EVT VecVT = EVT::getVectorVT(*getContext(), EltVT, ResNE);\n  return getBuildVector(VecVT, dl, Scalars);\n}\n\nstd::pair<SDValue, SDValue> SelectionDAG::UnrollVectorOverflowOp(\n    SDNode *N, unsigned ResNE) {\n  unsigned Opcode = N->getOpcode();\n  assert((Opcode == ISD::UADDO || Opcode == ISD::SADDO ||\n          Opcode == ISD::USUBO || Opcode == ISD::SSUBO ||\n          Opcode == ISD::UMULO || Opcode == ISD::SMULO) &&\n         \"Expected an overflow opcode\");\n\n  EVT ResVT = N->getValueType(0);\n  EVT OvVT = N->getValueType(1);\n  EVT ResEltVT = ResVT.getVectorElementType();\n  EVT OvEltVT = OvVT.getVectorElementType();\n  SDLoc dl(N);\n\n  // If ResNE is 0, fully unroll the vector op.\n  unsigned NE = ResVT.getVectorNumElements();\n  if (ResNE == 0)\n    ResNE = NE;\n  else if (NE > ResNE)\n    NE = ResNE;\n\n  SmallVector<SDValue, 8> LHSScalars;\n  SmallVector<SDValue, 8> RHSScalars;\n  ExtractVectorElements(N->getOperand(0), LHSScalars, 0, NE);\n  ExtractVectorElements(N->getOperand(1), RHSScalars, 0, NE);\n\n  EVT SVT = TLI->getSetCCResultType(getDataLayout(), *getContext(), ResEltVT);\n  SDVTList VTs = getVTList(ResEltVT, SVT);\n  SmallVector<SDValue, 8> ResScalars;\n  SmallVector<SDValue, 8> OvScalars;\n  for (unsigned i = 0; i < NE; ++i) {\n    SDValue Res = getNode(Opcode, dl, VTs, LHSScalars[i], RHSScalars[i]);\n    SDValue Ov =\n        getSelect(dl, OvEltVT, Res.getValue(1),\n                  getBoolConstant(true, dl, OvEltVT, ResVT),\n                  getConstant(0, dl, OvEltVT));\n\n    ResScalars.push_back(Res);\n    OvScalars.push_back(Ov);\n  }\n\n  ResScalars.append(ResNE - NE, getUNDEF(ResEltVT));\n  OvScalars.append(ResNE - NE, getUNDEF(OvEltVT));\n\n  EVT NewResVT = EVT::getVectorVT(*getContext(), ResEltVT, ResNE);\n  EVT NewOvVT = EVT::getVectorVT(*getContext(), OvEltVT, ResNE);\n  return std::make_pair(getBuildVector(NewResVT, dl, ResScalars),\n                        getBuildVector(NewOvVT, dl, OvScalars));\n}\n\nbool SelectionDAG::areNonVolatileConsecutiveLoads(LoadSDNode *LD,\n                                                  LoadSDNode *Base,\n                                                  unsigned Bytes,\n                                                  int Dist) const {\n  if (LD->isVolatile() || Base->isVolatile())\n    return false;\n  // TODO: probably too restrictive for atomics, revisit\n  if (!LD->isSimple())\n    return false;\n  if (LD->isIndexed() || Base->isIndexed())\n    return false;\n  if (LD->getChain() != Base->getChain())\n    return false;\n  EVT VT = LD->getValueType(0);\n  if (VT.getSizeInBits() / 8 != Bytes)\n    return false;\n\n  auto BaseLocDecomp = BaseIndexOffset::match(Base, *this);\n  auto LocDecomp = BaseIndexOffset::match(LD, *this);\n\n  int64_t Offset = 0;\n  if (BaseLocDecomp.equalBaseIndex(LocDecomp, *this, Offset))\n    return (Dist * Bytes == Offset);\n  return false;\n}\n\n/// InferPtrAlignment - Infer alignment of a load / store address. Return None\n/// if it cannot be inferred.\nMaybeAlign SelectionDAG::InferPtrAlign(SDValue Ptr) const {\n  // If this is a GlobalAddress + cst, return the alignment.\n  const GlobalValue *GV = nullptr;\n  int64_t GVOffset = 0;\n  if (TLI->isGAPlusOffset(Ptr.getNode(), GV, GVOffset)) {\n    unsigned PtrWidth = getDataLayout().getPointerTypeSizeInBits(GV->getType());\n    KnownBits Known(PtrWidth);\n    llvm::computeKnownBits(GV, Known, getDataLayout());\n    unsigned AlignBits = Known.countMinTrailingZeros();\n    if (AlignBits)\n      return commonAlignment(Align(1ull << std::min(31U, AlignBits)), GVOffset);\n  }\n\n  // If this is a direct reference to a stack slot, use information about the\n  // stack slot's alignment.\n  int FrameIdx = INT_MIN;\n  int64_t FrameOffset = 0;\n  if (FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Ptr)) {\n    FrameIdx = FI->getIndex();\n  } else if (isBaseWithConstantOffset(Ptr) &&\n             isa<FrameIndexSDNode>(Ptr.getOperand(0))) {\n    // Handle FI+Cst\n    FrameIdx = cast<FrameIndexSDNode>(Ptr.getOperand(0))->getIndex();\n    FrameOffset = Ptr.getConstantOperandVal(1);\n  }\n\n  if (FrameIdx != INT_MIN) {\n    const MachineFrameInfo &MFI = getMachineFunction().getFrameInfo();\n    return commonAlignment(MFI.getObjectAlign(FrameIdx), FrameOffset);\n  }\n\n  return None;\n}\n\n/// GetSplitDestVTs - Compute the VTs needed for the low/hi parts of a type\n/// which is split (or expanded) into two not necessarily identical pieces.\nstd::pair<EVT, EVT> SelectionDAG::GetSplitDestVTs(const EVT &VT) const {\n  // Currently all types are split in half.\n  EVT LoVT, HiVT;\n  if (!VT.isVector())\n    LoVT = HiVT = TLI->getTypeToTransformTo(*getContext(), VT);\n  else\n    LoVT = HiVT = VT.getHalfNumVectorElementsVT(*getContext());\n\n  return std::make_pair(LoVT, HiVT);\n}\n\n/// GetDependentSplitDestVTs - Compute the VTs needed for the low/hi parts of a\n/// type, dependent on an enveloping VT that has been split into two identical\n/// pieces. Sets the HiIsEmpty flag when hi type has zero storage size.\nstd::pair<EVT, EVT>\nSelectionDAG::GetDependentSplitDestVTs(const EVT &VT, const EVT &EnvVT,\n                                       bool *HiIsEmpty) const {\n  EVT EltTp = VT.getVectorElementType();\n  // Examples:\n  //   custom VL=8  with enveloping VL=8/8 yields 8/0 (hi empty)\n  //   custom VL=9  with enveloping VL=8/8 yields 8/1\n  //   custom VL=10 with enveloping VL=8/8 yields 8/2\n  //   etc.\n  ElementCount VTNumElts = VT.getVectorElementCount();\n  ElementCount EnvNumElts = EnvVT.getVectorElementCount();\n  assert(VTNumElts.isScalable() == EnvNumElts.isScalable() &&\n         \"Mixing fixed width and scalable vectors when enveloping a type\");\n  EVT LoVT, HiVT;\n  if (VTNumElts.getKnownMinValue() > EnvNumElts.getKnownMinValue()) {\n    LoVT = EnvVT;\n    HiVT = EVT::getVectorVT(*getContext(), EltTp, VTNumElts - EnvNumElts);\n    *HiIsEmpty = false;\n  } else {\n    // Flag that hi type has zero storage size, but return split envelop type\n    // (this would be easier if vector types with zero elements were allowed).\n    LoVT = EVT::getVectorVT(*getContext(), EltTp, VTNumElts);\n    HiVT = EnvVT;\n    *HiIsEmpty = true;\n  }\n  return std::make_pair(LoVT, HiVT);\n}\n\n/// SplitVector - Split the vector with EXTRACT_SUBVECTOR and return the\n/// low/high part.\nstd::pair<SDValue, SDValue>\nSelectionDAG::SplitVector(const SDValue &N, const SDLoc &DL, const EVT &LoVT,\n                          const EVT &HiVT) {\n  assert(LoVT.isScalableVector() == HiVT.isScalableVector() &&\n         LoVT.isScalableVector() == N.getValueType().isScalableVector() &&\n         \"Splitting vector with an invalid mixture of fixed and scalable \"\n         \"vector types\");\n  assert(LoVT.getVectorMinNumElements() + HiVT.getVectorMinNumElements() <=\n             N.getValueType().getVectorMinNumElements() &&\n         \"More vector elements requested than available!\");\n  SDValue Lo, Hi;\n  Lo =\n      getNode(ISD::EXTRACT_SUBVECTOR, DL, LoVT, N, getVectorIdxConstant(0, DL));\n  // For scalable vectors it is safe to use LoVT.getVectorMinNumElements()\n  // (rather than having to use ElementCount), because EXTRACT_SUBVECTOR scales\n  // IDX with the runtime scaling factor of the result vector type. For\n  // fixed-width result vectors, that runtime scaling factor is 1.\n  Hi = getNode(ISD::EXTRACT_SUBVECTOR, DL, HiVT, N,\n               getVectorIdxConstant(LoVT.getVectorMinNumElements(), DL));\n  return std::make_pair(Lo, Hi);\n}\n\n/// Widen the vector up to the next power of two using INSERT_SUBVECTOR.\nSDValue SelectionDAG::WidenVector(const SDValue &N, const SDLoc &DL) {\n  EVT VT = N.getValueType();\n  EVT WideVT = EVT::getVectorVT(*getContext(), VT.getVectorElementType(),\n                                NextPowerOf2(VT.getVectorNumElements()));\n  return getNode(ISD::INSERT_SUBVECTOR, DL, WideVT, getUNDEF(WideVT), N,\n                 getVectorIdxConstant(0, DL));\n}\n\nvoid SelectionDAG::ExtractVectorElements(SDValue Op,\n                                         SmallVectorImpl<SDValue> &Args,\n                                         unsigned Start, unsigned Count,\n                                         EVT EltVT) {\n  EVT VT = Op.getValueType();\n  if (Count == 0)\n    Count = VT.getVectorNumElements();\n  if (EltVT == EVT())\n    EltVT = VT.getVectorElementType();\n  SDLoc SL(Op);\n  for (unsigned i = Start, e = Start + Count; i != e; ++i) {\n    Args.push_back(getNode(ISD::EXTRACT_VECTOR_ELT, SL, EltVT, Op,\n                           getVectorIdxConstant(i, SL)));\n  }\n}\n\n// getAddressSpace - Return the address space this GlobalAddress belongs to.\nunsigned GlobalAddressSDNode::getAddressSpace() const {\n  return getGlobal()->getType()->getAddressSpace();\n}\n\nType *ConstantPoolSDNode::getType() const {\n  if (isMachineConstantPoolEntry())\n    return Val.MachineCPVal->getType();\n  return Val.ConstVal->getType();\n}\n\nbool BuildVectorSDNode::isConstantSplat(APInt &SplatValue, APInt &SplatUndef,\n                                        unsigned &SplatBitSize,\n                                        bool &HasAnyUndefs,\n                                        unsigned MinSplatBits,\n                                        bool IsBigEndian) const {\n  EVT VT = getValueType(0);\n  assert(VT.isVector() && \"Expected a vector type\");\n  unsigned VecWidth = VT.getSizeInBits();\n  if (MinSplatBits > VecWidth)\n    return false;\n\n  // FIXME: The widths are based on this node's type, but build vectors can\n  // truncate their operands.\n  SplatValue = APInt(VecWidth, 0);\n  SplatUndef = APInt(VecWidth, 0);\n\n  // Get the bits. Bits with undefined values (when the corresponding element\n  // of the vector is an ISD::UNDEF value) are set in SplatUndef and cleared\n  // in SplatValue. If any of the values are not constant, give up and return\n  // false.\n  unsigned int NumOps = getNumOperands();\n  assert(NumOps > 0 && \"isConstantSplat has 0-size build vector\");\n  unsigned EltWidth = VT.getScalarSizeInBits();\n\n  for (unsigned j = 0; j < NumOps; ++j) {\n    unsigned i = IsBigEndian ? NumOps - 1 - j : j;\n    SDValue OpVal = getOperand(i);\n    unsigned BitPos = j * EltWidth;\n\n    if (OpVal.isUndef())\n      SplatUndef.setBits(BitPos, BitPos + EltWidth);\n    else if (auto *CN = dyn_cast<ConstantSDNode>(OpVal))\n      SplatValue.insertBits(CN->getAPIntValue().zextOrTrunc(EltWidth), BitPos);\n    else if (auto *CN = dyn_cast<ConstantFPSDNode>(OpVal))\n      SplatValue.insertBits(CN->getValueAPF().bitcastToAPInt(), BitPos);\n    else\n      return false;\n  }\n\n  // The build_vector is all constants or undefs. Find the smallest element\n  // size that splats the vector.\n  HasAnyUndefs = (SplatUndef != 0);\n\n  // FIXME: This does not work for vectors with elements less than 8 bits.\n  while (VecWidth > 8) {\n    unsigned HalfSize = VecWidth / 2;\n    APInt HighValue = SplatValue.lshr(HalfSize).trunc(HalfSize);\n    APInt LowValue = SplatValue.trunc(HalfSize);\n    APInt HighUndef = SplatUndef.lshr(HalfSize).trunc(HalfSize);\n    APInt LowUndef = SplatUndef.trunc(HalfSize);\n\n    // If the two halves do not match (ignoring undef bits), stop here.\n    if ((HighValue & ~LowUndef) != (LowValue & ~HighUndef) ||\n        MinSplatBits > HalfSize)\n      break;\n\n    SplatValue = HighValue | LowValue;\n    SplatUndef = HighUndef & LowUndef;\n\n    VecWidth = HalfSize;\n  }\n\n  SplatBitSize = VecWidth;\n  return true;\n}\n\nSDValue BuildVectorSDNode::getSplatValue(const APInt &DemandedElts,\n                                         BitVector *UndefElements) const {\n  unsigned NumOps = getNumOperands();\n  if (UndefElements) {\n    UndefElements->clear();\n    UndefElements->resize(NumOps);\n  }\n  assert(NumOps == DemandedElts.getBitWidth() && \"Unexpected vector size\");\n  if (!DemandedElts)\n    return SDValue();\n  SDValue Splatted;\n  for (unsigned i = 0; i != NumOps; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    SDValue Op = getOperand(i);\n    if (Op.isUndef()) {\n      if (UndefElements)\n        (*UndefElements)[i] = true;\n    } else if (!Splatted) {\n      Splatted = Op;\n    } else if (Splatted != Op) {\n      return SDValue();\n    }\n  }\n\n  if (!Splatted) {\n    unsigned FirstDemandedIdx = DemandedElts.countTrailingZeros();\n    assert(getOperand(FirstDemandedIdx).isUndef() &&\n           \"Can only have a splat without a constant for all undefs.\");\n    return getOperand(FirstDemandedIdx);\n  }\n\n  return Splatted;\n}\n\nSDValue BuildVectorSDNode::getSplatValue(BitVector *UndefElements) const {\n  APInt DemandedElts = APInt::getAllOnesValue(getNumOperands());\n  return getSplatValue(DemandedElts, UndefElements);\n}\n\nbool BuildVectorSDNode::getRepeatedSequence(const APInt &DemandedElts,\n                                            SmallVectorImpl<SDValue> &Sequence,\n                                            BitVector *UndefElements) const {\n  unsigned NumOps = getNumOperands();\n  Sequence.clear();\n  if (UndefElements) {\n    UndefElements->clear();\n    UndefElements->resize(NumOps);\n  }\n  assert(NumOps == DemandedElts.getBitWidth() && \"Unexpected vector size\");\n  if (!DemandedElts || NumOps < 2 || !isPowerOf2_32(NumOps))\n    return false;\n\n  // Set the undefs even if we don't find a sequence (like getSplatValue).\n  if (UndefElements)\n    for (unsigned I = 0; I != NumOps; ++I)\n      if (DemandedElts[I] && getOperand(I).isUndef())\n        (*UndefElements)[I] = true;\n\n  // Iteratively widen the sequence length looking for repetitions.\n  for (unsigned SeqLen = 1; SeqLen < NumOps; SeqLen *= 2) {\n    Sequence.append(SeqLen, SDValue());\n    for (unsigned I = 0; I != NumOps; ++I) {\n      if (!DemandedElts[I])\n        continue;\n      SDValue &SeqOp = Sequence[I % SeqLen];\n      SDValue Op = getOperand(I);\n      if (Op.isUndef()) {\n        if (!SeqOp)\n          SeqOp = Op;\n        continue;\n      }\n      if (SeqOp && !SeqOp.isUndef() && SeqOp != Op) {\n        Sequence.clear();\n        break;\n      }\n      SeqOp = Op;\n    }\n    if (!Sequence.empty())\n      return true;\n  }\n\n  assert(Sequence.empty() && \"Failed to empty non-repeating sequence pattern\");\n  return false;\n}\n\nbool BuildVectorSDNode::getRepeatedSequence(SmallVectorImpl<SDValue> &Sequence,\n                                            BitVector *UndefElements) const {\n  APInt DemandedElts = APInt::getAllOnesValue(getNumOperands());\n  return getRepeatedSequence(DemandedElts, Sequence, UndefElements);\n}\n\nConstantSDNode *\nBuildVectorSDNode::getConstantSplatNode(const APInt &DemandedElts,\n                                        BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantSDNode>(\n      getSplatValue(DemandedElts, UndefElements));\n}\n\nConstantSDNode *\nBuildVectorSDNode::getConstantSplatNode(BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantSDNode>(getSplatValue(UndefElements));\n}\n\nConstantFPSDNode *\nBuildVectorSDNode::getConstantFPSplatNode(const APInt &DemandedElts,\n                                          BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantFPSDNode>(\n      getSplatValue(DemandedElts, UndefElements));\n}\n\nConstantFPSDNode *\nBuildVectorSDNode::getConstantFPSplatNode(BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantFPSDNode>(getSplatValue(UndefElements));\n}\n\nint32_t\nBuildVectorSDNode::getConstantFPSplatPow2ToLog2Int(BitVector *UndefElements,\n                                                   uint32_t BitWidth) const {\n  if (ConstantFPSDNode *CN =\n          dyn_cast_or_null<ConstantFPSDNode>(getSplatValue(UndefElements))) {\n    bool IsExact;\n    APSInt IntVal(BitWidth);\n    const APFloat &APF = CN->getValueAPF();\n    if (APF.convertToInteger(IntVal, APFloat::rmTowardZero, &IsExact) !=\n            APFloat::opOK ||\n        !IsExact)\n      return -1;\n\n    return IntVal.exactLogBase2();\n  }\n  return -1;\n}\n\nbool BuildVectorSDNode::isConstant() const {\n  for (const SDValue &Op : op_values()) {\n    unsigned Opc = Op.getOpcode();\n    if (Opc != ISD::UNDEF && Opc != ISD::Constant && Opc != ISD::ConstantFP)\n      return false;\n  }\n  return true;\n}\n\nbool ShuffleVectorSDNode::isSplatMask(const int *Mask, EVT VT) {\n  // Find the first non-undef value in the shuffle mask.\n  unsigned i, e;\n  for (i = 0, e = VT.getVectorNumElements(); i != e && Mask[i] < 0; ++i)\n    /* search */;\n\n  // If all elements are undefined, this shuffle can be considered a splat\n  // (although it should eventually get simplified away completely).\n  if (i == e)\n    return true;\n\n  // Make sure all remaining elements are either undef or the same as the first\n  // non-undef value.\n  for (int Idx = Mask[i]; i != e; ++i)\n    if (Mask[i] >= 0 && Mask[i] != Idx)\n      return false;\n  return true;\n}\n\n// Returns the SDNode if it is a constant integer BuildVector\n// or constant integer.\nSDNode *SelectionDAG::isConstantIntBuildVectorOrConstantInt(SDValue N) const {\n  if (isa<ConstantSDNode>(N))\n    return N.getNode();\n  if (ISD::isBuildVectorOfConstantSDNodes(N.getNode()))\n    return N.getNode();\n  // Treat a GlobalAddress supporting constant offset folding as a\n  // constant integer.\n  if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(N))\n    if (GA->getOpcode() == ISD::GlobalAddress &&\n        TLI->isOffsetFoldingLegal(GA))\n      return GA;\n  if ((N.getOpcode() == ISD::SPLAT_VECTOR) &&\n      isa<ConstantSDNode>(N.getOperand(0)))\n    return N.getNode();\n  return nullptr;\n}\n\n// Returns the SDNode if it is a constant float BuildVector\n// or constant float.\nSDNode *SelectionDAG::isConstantFPBuildVectorOrConstantFP(SDValue N) const {\n  if (isa<ConstantFPSDNode>(N))\n    return N.getNode();\n\n  if (ISD::isBuildVectorOfConstantFPSDNodes(N.getNode()))\n    return N.getNode();\n\n  return nullptr;\n}\n\nvoid SelectionDAG::createOperands(SDNode *Node, ArrayRef<SDValue> Vals) {\n  assert(!Node->OperandList && \"Node already has operands\");\n  assert(SDNode::getMaxNumOperands() >= Vals.size() &&\n         \"too many operands to fit into SDNode\");\n  SDUse *Ops = OperandRecycler.allocate(\n      ArrayRecycler<SDUse>::Capacity::get(Vals.size()), OperandAllocator);\n\n  bool IsDivergent = false;\n  for (unsigned I = 0; I != Vals.size(); ++I) {\n    Ops[I].setUser(Node);\n    Ops[I].setInitial(Vals[I]);\n    if (Ops[I].Val.getValueType() != MVT::Other) // Skip Chain. It does not carry divergence.\n      IsDivergent |= Ops[I].getNode()->isDivergent();\n  }\n  Node->NumOperands = Vals.size();\n  Node->OperandList = Ops;\n  if (!TLI->isSDNodeAlwaysUniform(Node)) {\n    IsDivergent |= TLI->isSDNodeSourceOfDivergence(Node, FLI, DA);\n    Node->SDNodeBits.IsDivergent = IsDivergent;\n  }\n  checkForCycles(Node);\n}\n\nSDValue SelectionDAG::getTokenFactor(const SDLoc &DL,\n                                     SmallVectorImpl<SDValue> &Vals) {\n  size_t Limit = SDNode::getMaxNumOperands();\n  while (Vals.size() > Limit) {\n    unsigned SliceIdx = Vals.size() - Limit;\n    auto ExtractedTFs = ArrayRef<SDValue>(Vals).slice(SliceIdx, Limit);\n    SDValue NewTF = getNode(ISD::TokenFactor, DL, MVT::Other, ExtractedTFs);\n    Vals.erase(Vals.begin() + SliceIdx, Vals.end());\n    Vals.emplace_back(NewTF);\n  }\n  return getNode(ISD::TokenFactor, DL, MVT::Other, Vals);\n}\n\nSDValue SelectionDAG::getNeutralElement(unsigned Opcode, const SDLoc &DL,\n                                        EVT VT, SDNodeFlags Flags) {\n  switch (Opcode) {\n  default:\n    return SDValue();\n  case ISD::ADD:\n  case ISD::OR:\n  case ISD::XOR:\n  case ISD::UMAX:\n    return getConstant(0, DL, VT);\n  case ISD::MUL:\n    return getConstant(1, DL, VT);\n  case ISD::AND:\n  case ISD::UMIN:\n    return getAllOnesConstant(DL, VT);\n  case ISD::SMAX:\n    return getConstant(APInt::getSignedMinValue(VT.getSizeInBits()), DL, VT);\n  case ISD::SMIN:\n    return getConstant(APInt::getSignedMaxValue(VT.getSizeInBits()), DL, VT);\n  case ISD::FADD:\n    return getConstantFP(-0.0, DL, VT);\n  case ISD::FMUL:\n    return getConstantFP(1.0, DL, VT);\n  case ISD::FMINNUM:\n  case ISD::FMAXNUM: {\n    // Neutral element for fminnum is NaN, Inf or FLT_MAX, depending on FMF.\n    const fltSemantics &Semantics = EVTToAPFloatSemantics(VT);\n    APFloat NeutralAF = !Flags.hasNoNaNs() ? APFloat::getQNaN(Semantics) :\n                        !Flags.hasNoInfs() ? APFloat::getInf(Semantics) :\n                        APFloat::getLargest(Semantics);\n    if (Opcode == ISD::FMAXNUM)\n      NeutralAF.changeSign();\n\n    return getConstantFP(NeutralAF, DL, VT);\n  }\n  }\n}\n\n#ifndef NDEBUG\nstatic void checkForCyclesHelper(const SDNode *N,\n                                 SmallPtrSetImpl<const SDNode*> &Visited,\n                                 SmallPtrSetImpl<const SDNode*> &Checked,\n                                 const llvm::SelectionDAG *DAG) {\n  // If this node has already been checked, don't check it again.\n  if (Checked.count(N))\n    return;\n\n  // If a node has already been visited on this depth-first walk, reject it as\n  // a cycle.\n  if (!Visited.insert(N).second) {\n    errs() << \"Detected cycle in SelectionDAG\\n\";\n    dbgs() << \"Offending node:\\n\";\n    N->dumprFull(DAG); dbgs() << \"\\n\";\n    abort();\n  }\n\n  for (const SDValue &Op : N->op_values())\n    checkForCyclesHelper(Op.getNode(), Visited, Checked, DAG);\n\n  Checked.insert(N);\n  Visited.erase(N);\n}\n#endif\n\nvoid llvm::checkForCycles(const llvm::SDNode *N,\n                          const llvm::SelectionDAG *DAG,\n                          bool force) {\n#ifndef NDEBUG\n  bool check = force;\n#ifdef EXPENSIVE_CHECKS\n  check = true;\n#endif  // EXPENSIVE_CHECKS\n  if (check) {\n    assert(N && \"Checking nonexistent SDNode\");\n    SmallPtrSet<const SDNode*, 32> visited;\n    SmallPtrSet<const SDNode*, 32> checked;\n    checkForCyclesHelper(N, visited, checked, DAG);\n  }\n#endif  // !NDEBUG\n}\n\nvoid llvm::checkForCycles(const llvm::SelectionDAG *DAG, bool force) {\n  checkForCycles(DAG->getRoot().getNode(), DAG, force);\n}\n"}}, "reports": [{"events": [{"location": {"col": 5, "file": 103, "line": 9445}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 103, "line": 9445}, "message": "default constructor 'EVTArray' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "b9f22e58b22845625772b77e9856c5af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
