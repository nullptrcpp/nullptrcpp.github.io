<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "content": "//===- BugReporterVisitors.h - Generate PathDiagnostics ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file declares BugReporterVisitors, which are used to generate enhanced\n//  diagnostic traces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTERVISITORS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTERVISITORS_H\n\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n\nnamespace clang {\n\nclass BinaryOperator;\nclass CFGBlock;\nclass DeclRefExpr;\nclass Expr;\nclass Stmt;\n\nnamespace ento {\n\nclass PathSensitiveBugReport;\nclass BugReporterContext;\nclass ExplodedNode;\nclass MemRegion;\nclass PathDiagnosticPiece;\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\n/// BugReporterVisitors are used to add custom diagnostics along a path.\nclass BugReporterVisitor : public llvm::FoldingSetNode {\npublic:\n  BugReporterVisitor() = default;\n  BugReporterVisitor(const BugReporterVisitor &) = default;\n  BugReporterVisitor(BugReporterVisitor &&) {}\n  virtual ~BugReporterVisitor();\n\n  /// Return a diagnostic piece which should be associated with the\n  /// given node.\n  /// Note that this function does *not* get run on the very last node\n  /// of the report, as the PathDiagnosticPiece associated with the\n  /// last node should be unique.\n  /// Use \\ref getEndPath to customize the note associated with the report\n  /// end instead.\n  ///\n  /// The last parameter can be used to register a new visitor with the given\n  /// BugReport while processing a node.\n  virtual PathDiagnosticPieceRef VisitNode(const ExplodedNode *Succ,\n                                           BugReporterContext &BRC,\n                                           PathSensitiveBugReport &BR) = 0;\n\n  /// Last function called on the visitor, no further calls to VisitNode\n  /// would follow.\n  virtual void finalizeVisitor(BugReporterContext &BRC,\n                               const ExplodedNode *EndPathNode,\n                               PathSensitiveBugReport &BR);\n\n  /// Provide custom definition for the final diagnostic piece on the\n  /// path - the piece, which is displayed before the path is expanded.\n  ///\n  /// NOTE that this function can be implemented on at most one used visitor,\n  /// and otherwise it crahes at runtime.\n  virtual PathDiagnosticPieceRef getEndPath(BugReporterContext &BRC,\n                                            const ExplodedNode *N,\n                                            PathSensitiveBugReport &BR);\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const = 0;\n\n  /// Generates the default final diagnostic piece.\n  static PathDiagnosticPieceRef\n  getDefaultEndPath(const BugReporterContext &BRC, const ExplodedNode *N,\n                    const PathSensitiveBugReport &BR);\n};\n\nnamespace bugreporter {\n\n/// Specifies the type of tracking for an expression.\nenum class TrackingKind {\n  /// Default tracking kind -- specifies that as much information should be\n  /// gathered about the tracked expression value as possible.\n  Thorough,\n  /// Specifies that a more moderate tracking should be used for the expression\n  /// value. This will essentially make sure that functions relevant to the it\n  /// aren't pruned, but otherwise relies on the user reading the code or\n  /// following the arrows.\n  Condition\n};\n\n/// Attempts to add visitors to track expression value back to its point of\n/// origin.\n///\n/// \\param N A node \"downstream\" from the evaluation of the statement.\n/// \\param E The expression value which we are tracking\n/// \\param R The bug report to which visitors should be attached.\n/// \\param EnableNullFPSuppression Whether we should employ false positive\n///         suppression (inlined defensive checks, returned null).\n///\n/// \\return Whether or not the function was able to add visitors for this\n///         statement. Note that returning \\c true does not actually imply\n///         that any visitors were added.\nbool trackExpressionValue(const ExplodedNode *N, const Expr *E,\n                          PathSensitiveBugReport &R,\n                          TrackingKind TKind = TrackingKind::Thorough,\n                          bool EnableNullFPSuppression = true);\n\nconst Expr *getDerefExpr(const Stmt *S);\n\n} // namespace bugreporter\n\n/// Finds last store into the given region,\n/// which is different from a given symbolic value.\nclass FindLastStoreBRVisitor final : public BugReporterVisitor {\n  const MemRegion *R;\n  SVal V;\n  bool Satisfied = false;\n\n  /// If the visitor is tracking the value directly responsible for the\n  /// bug, we are going to employ false positive suppression.\n  bool EnableNullFPSuppression;\n\n  using TrackingKind = bugreporter::TrackingKind;\n  TrackingKind TKind;\n  const StackFrameContext *OriginSFC;\n\npublic:\n  /// \\param V We're searching for the store where \\c R received this value.\n  /// \\param R The region we're tracking.\n  /// \\param TKind May limit the amount of notes added to the bug report.\n  /// \\param OriginSFC Only adds notes when the last store happened in a\n  ///        different stackframe to this one. Disregarded if the tracking kind\n  ///        is thorough.\n  ///        This is useful, because for non-tracked regions, notes about\n  ///        changes to its value in a nested stackframe could be pruned, and\n  ///        this visitor can prevent that without polluting the bugpath too\n  ///        much.\n  FindLastStoreBRVisitor(KnownSVal V, const MemRegion *R,\n                         bool InEnableNullFPSuppression, TrackingKind TKind,\n                         const StackFrameContext *OriginSFC = nullptr)\n      : R(R), V(V), EnableNullFPSuppression(InEnableNullFPSuppression),\n        TKind(TKind), OriginSFC(OriginSFC) {\n    assert(R);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n};\n\nclass TrackConstraintBRVisitor final : public BugReporterVisitor {\n  DefinedSVal Constraint;\n  bool Assumption;\n  bool IsSatisfied = false;\n  bool IsZeroCheck;\n\n  /// We should start tracking from the last node along the path in which the\n  /// value is constrained.\n  bool IsTrackingTurnedOn = false;\n\npublic:\n  TrackConstraintBRVisitor(DefinedSVal constraint, bool assumption)\n      : Constraint(constraint), Assumption(assumption),\n        IsZeroCheck(!Assumption && Constraint.getAs<Loc>()) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  /// Return the tag associated with this visitor.  This tag will be used\n  /// to make all PathDiagnosticPieces created by this visitor.\n  static const char *getTag();\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\nprivate:\n  /// Checks if the constraint is valid in the current state.\n  bool isUnderconstrained(const ExplodedNode *N) const;\n};\n\n/// \\class NilReceiverBRVisitor\n/// Prints path notes when a message is sent to a nil receiver.\nclass NilReceiverBRVisitor final : public BugReporterVisitor {\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    static int x = 0;\n    ID.AddPointer(&x);\n  }\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\n  /// If the statement is a message send expression with nil receiver, returns\n  /// the receiver expression. Returns NULL otherwise.\n  static const Expr *getNilReceiver(const Stmt *S, const ExplodedNode *N);\n};\n\n/// Visitor that tries to report interesting diagnostics from conditions.\nclass ConditionBRVisitor final : public BugReporterVisitor {\n  // FIXME: constexpr initialization isn't supported by MSVC2013.\n  constexpr static llvm::StringLiteral GenericTrueMessage =\n      \"Assuming the condition is true\";\n  constexpr static llvm::StringLiteral GenericFalseMessage =\n      \"Assuming the condition is false\";\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    static int x = 0;\n    ID.AddPointer(&x);\n  }\n\n  /// Return the tag associated with this visitor.  This tag will be used\n  /// to make all PathDiagnosticPieces created by this visitor.\n  static const char *getTag();\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\n  PathDiagnosticPieceRef VisitNodeImpl(const ExplodedNode *N,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &BR);\n\n  PathDiagnosticPieceRef\n  VisitTerminator(const Stmt *Term, const ExplodedNode *N,\n                  const CFGBlock *SrcBlk, const CFGBlock *DstBlk,\n                  PathSensitiveBugReport &R, BugReporterContext &BRC);\n\n  PathDiagnosticPieceRef VisitTrueTest(const Expr *Cond,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &R,\n                                       const ExplodedNode *N, bool TookTrue);\n\n  PathDiagnosticPieceRef VisitTrueTest(const Expr *Cond, const DeclRefExpr *DR,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &R,\n                                       const ExplodedNode *N, bool TookTrue,\n                                       bool IsAssuming);\n\n  PathDiagnosticPieceRef\n  VisitTrueTest(const Expr *Cond, const BinaryOperator *BExpr,\n                BugReporterContext &BRC, PathSensitiveBugReport &R,\n                const ExplodedNode *N, bool TookTrue, bool IsAssuming);\n\n  PathDiagnosticPieceRef VisitTrueTest(const Expr *Cond, const MemberExpr *ME,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &R,\n                                       const ExplodedNode *N, bool TookTrue,\n                                       bool IsAssuming);\n\n  PathDiagnosticPieceRef\n  VisitConditionVariable(StringRef LhsString, const Expr *CondVarExpr,\n                         BugReporterContext &BRC, PathSensitiveBugReport &R,\n                         const ExplodedNode *N, bool TookTrue);\n\n  /// Tries to print the value of the given expression.\n  ///\n  /// \\param CondVarExpr The expression to print its value.\n  /// \\param Out The stream to print.\n  /// \\param N The node where we encountered the condition.\n  /// \\param TookTrue Whether we took the \\c true branch of the condition.\n  ///\n  /// \\return Whether the print was successful. (The printing is successful if\n  ///         we model the value and we could obtain it.)\n  bool printValue(const Expr *CondVarExpr, raw_ostream &Out,\n                  const ExplodedNode *N, bool TookTrue, bool IsAssuming);\n\n  bool patternMatch(const Expr *Ex,\n                    const Expr *ParentEx,\n                    raw_ostream &Out,\n                    BugReporterContext &BRC,\n                    PathSensitiveBugReport &R,\n                    const ExplodedNode *N,\n                    Optional<bool> &prunable,\n                    bool IsSameFieldName);\n\n  static bool isPieceMessageGeneric(const PathDiagnosticPiece *Piece);\n};\n\n/// Suppress reports that might lead to known false positives.\n///\n/// Currently this suppresses reports based on locations of bugs.\nclass LikelyFalsePositiveSuppressionBRVisitor final\n    : public BugReporterVisitor {\npublic:\n  static void *getTag() {\n    static int Tag = 0;\n    return static_cast<void *>(&Tag);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    ID.AddPointer(getTag());\n  }\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *, BugReporterContext &,\n                                   PathSensitiveBugReport &) override {\n    return nullptr;\n  }\n\n  void finalizeVisitor(BugReporterContext &BRC, const ExplodedNode *N,\n                       PathSensitiveBugReport &BR) override;\n};\n\n/// When a region containing undefined value or '0' value is passed\n/// as an argument in a call, marks the call as interesting.\n///\n/// As a result, BugReporter will not prune the path through the function even\n/// if the region's contents are not modified/accessed by the call.\nclass UndefOrNullArgVisitor final : public BugReporterVisitor {\n  /// The interesting memory region this visitor is tracking.\n  const MemRegion *R;\n\npublic:\n  UndefOrNullArgVisitor(const MemRegion *InR) : R(InR) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    static int Tag = 0;\n    ID.AddPointer(&Tag);\n    ID.AddPointer(R);\n  }\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n};\n\nclass SuppressInlineDefensiveChecksVisitor final : public BugReporterVisitor {\n  /// The symbolic value for which we are tracking constraints.\n  /// This value is constrained to null in the end of path.\n  DefinedSVal V;\n\n  /// Track if we found the node where the constraint was first added.\n  bool IsSatisfied = false;\n\n  /// Since the visitors can be registered on nodes previous to the last\n  /// node in the BugReport, but the path traversal always starts with the last\n  /// node, the visitor invariant (that we start with a node in which V is null)\n  /// might not hold when node visitation starts. We are going to start tracking\n  /// from the last node in which the value is null.\n  bool IsTrackingTurnedOn = false;\n\npublic:\n  SuppressInlineDefensiveChecksVisitor(DefinedSVal Val, const ExplodedNode *N);\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  /// Return the tag associated with this visitor.  This tag will be used\n  /// to make all PathDiagnosticPieces created by this visitor.\n  static const char *getTag();\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *Succ,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n};\n\n/// The bug visitor will walk all the nodes in a path and collect all the\n/// constraints. When it reaches the root node, will create a refutation\n/// manager and check if the constraints are satisfiable\nclass FalsePositiveRefutationBRVisitor final : public BugReporterVisitor {\nprivate:\n  /// Holds the constraints in a given path\n  ConstraintMap Constraints;\n\npublic:\n  FalsePositiveRefutationBRVisitor();\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\n  void finalizeVisitor(BugReporterContext &BRC, const ExplodedNode *EndPathNode,\n                       PathSensitiveBugReport &BR) override;\n  void addConstraints(const ExplodedNode *N,\n                      bool OverwriteConstraintsOnExistingSyms);\n};\n\n/// The visitor detects NoteTags and displays the event notes they contain.\nclass TagVisitor : public BugReporterVisitor {\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &R) override;\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTERVISITORS_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/Checker.h", "content": "//== Checker.h - Registration mechanism for checkers -------------*- C++ -*--=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines Checker, used to create and register checkers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_CHECKER_H\n#define LLVM_CLANG_STATICANALYZER_CORE_CHECKER_H\n\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/Support/Casting.h\"\n\nnamespace clang {\nnamespace ento {\n  class BugReporter;\n\nnamespace check {\n\ntemplate <typename DECL>\nclass ASTDecl {\n  template <typename CHECKER>\n  static void _checkDecl(void *checker, const Decl *D, AnalysisManager& mgr,\n                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkASTDecl(cast<DECL>(D), mgr, BR);\n  }\n\n  static bool _handlesDecl(const Decl *D) {\n    return isa<DECL>(D);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForDecl(CheckerManager::CheckDeclFunc(checker,\n                                                       _checkDecl<CHECKER>),\n                         _handlesDecl);\n  }\n};\n\nclass ASTCodeBody {\n  template <typename CHECKER>\n  static void _checkBody(void *checker, const Decl *D, AnalysisManager& mgr,\n                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkASTCodeBody(D, mgr, BR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBody(CheckerManager::CheckDeclFunc(checker,\n                                                       _checkBody<CHECKER>));\n  }\n};\n\nclass EndOfTranslationUnit {\n  template <typename CHECKER>\n  static void _checkEndOfTranslationUnit(void *checker,\n                                         const TranslationUnitDecl *TU,\n                                         AnalysisManager& mgr,\n                                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkEndOfTranslationUnit(TU, mgr, BR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr){\n    mgr._registerForEndOfTranslationUnit(\n                              CheckerManager::CheckEndOfTranslationUnit(checker,\n                                          _checkEndOfTranslationUnit<CHECKER>));\n  }\n};\n\ntemplate <typename STMT>\nclass PreStmt {\n  template <typename CHECKER>\n  static void _checkStmt(void *checker, const Stmt *S, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreStmt(cast<STMT>(S), C);\n  }\n\n  static bool _handlesStmt(const Stmt *S) {\n    return isa<STMT>(S);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreStmt(CheckerManager::CheckStmtFunc(checker,\n                                                          _checkStmt<CHECKER>),\n                            _handlesStmt);\n  }\n};\n\ntemplate <typename STMT>\nclass PostStmt {\n  template <typename CHECKER>\n  static void _checkStmt(void *checker, const Stmt *S, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostStmt(cast<STMT>(S), C);\n  }\n\n  static bool _handlesStmt(const Stmt *S) {\n    return isa<STMT>(S);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostStmt(CheckerManager::CheckStmtFunc(checker,\n                                                           _checkStmt<CHECKER>),\n                             _handlesStmt);\n  }\n};\n\nclass PreObjCMessage {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreObjCMessage(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreObjCMessage(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass ObjCMessageNil {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkObjCMessageNil(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForObjCMessageNil(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass PostObjCMessage {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostObjCMessage(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostObjCMessage(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass PreCall {\n  template <typename CHECKER>\n  static void _checkCall(void *checker, const CallEvent &msg,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreCall(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreCall(\n     CheckerManager::CheckCallFunc(checker, _checkCall<CHECKER>));\n  }\n};\n\nclass PostCall {\n  template <typename CHECKER>\n  static void _checkCall(void *checker, const CallEvent &msg,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostCall(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostCall(\n     CheckerManager::CheckCallFunc(checker, _checkCall<CHECKER>));\n  }\n};\n\nclass Location {\n  template <typename CHECKER>\n  static void _checkLocation(void *checker,\n                             const SVal &location, bool isLoad, const Stmt *S,\n                             CheckerContext &C) {\n    ((const CHECKER *)checker)->checkLocation(location, isLoad, S, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForLocation(\n           CheckerManager::CheckLocationFunc(checker, _checkLocation<CHECKER>));\n  }\n};\n\nclass Bind {\n  template <typename CHECKER>\n  static void _checkBind(void *checker,\n                         const SVal &location, const SVal &val, const Stmt *S,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkBind(location, val, S, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBind(\n           CheckerManager::CheckBindFunc(checker, _checkBind<CHECKER>));\n  }\n};\n\nclass EndAnalysis {\n  template <typename CHECKER>\n  static void _checkEndAnalysis(void *checker, ExplodedGraph &G,\n                                BugReporter &BR, ExprEngine &Eng) {\n    ((const CHECKER *)checker)->checkEndAnalysis(G, BR, Eng);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEndAnalysis(\n     CheckerManager::CheckEndAnalysisFunc(checker, _checkEndAnalysis<CHECKER>));\n  }\n};\n\nclass BeginFunction {\n  template <typename CHECKER>\n  static void _checkBeginFunction(void *checker, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkBeginFunction(C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBeginFunction(CheckerManager::CheckBeginFunctionFunc(\n        checker, _checkBeginFunction<CHECKER>));\n  }\n};\n\nclass EndFunction {\n  template <typename CHECKER>\n  static void _checkEndFunction(void *checker, const ReturnStmt *RS,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkEndFunction(RS, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEndFunction(\n     CheckerManager::CheckEndFunctionFunc(checker, _checkEndFunction<CHECKER>));\n  }\n};\n\nclass BranchCondition {\n  template <typename CHECKER>\n  static void _checkBranchCondition(void *checker, const Stmt *Condition,\n                                    CheckerContext & C) {\n    ((const CHECKER *)checker)->checkBranchCondition(Condition, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBranchCondition(\n      CheckerManager::CheckBranchConditionFunc(checker,\n                                               _checkBranchCondition<CHECKER>));\n  }\n};\n\nclass NewAllocator {\n  template <typename CHECKER>\n  static void _checkNewAllocator(void *checker, const CXXAllocatorCall &Call,\n                                 CheckerContext &C) {\n    ((const CHECKER *)checker)->checkNewAllocator(Call, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForNewAllocator(\n        CheckerManager::CheckNewAllocatorFunc(checker,\n                                              _checkNewAllocator<CHECKER>));\n  }\n};\n\nclass LiveSymbols {\n  template <typename CHECKER>\n  static void _checkLiveSymbols(void *checker, ProgramStateRef state,\n                                SymbolReaper &SR) {\n    ((const CHECKER *)checker)->checkLiveSymbols(state, SR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForLiveSymbols(\n     CheckerManager::CheckLiveSymbolsFunc(checker, _checkLiveSymbols<CHECKER>));\n  }\n};\n\nclass DeadSymbols {\n  template <typename CHECKER>\n  static void _checkDeadSymbols(void *checker,\n                                SymbolReaper &SR, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkDeadSymbols(SR, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForDeadSymbols(\n     CheckerManager::CheckDeadSymbolsFunc(checker, _checkDeadSymbols<CHECKER>));\n  }\n};\n\nclass RegionChanges {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkRegionChanges(void *checker,\n                      ProgramStateRef state,\n                      const InvalidatedSymbols *invalidated,\n                      ArrayRef<const MemRegion *> Explicits,\n                      ArrayRef<const MemRegion *> Regions,\n                      const LocationContext *LCtx,\n                      const CallEvent *Call) {\n    return ((const CHECKER *) checker)->checkRegionChanges(state, invalidated,\n                                                           Explicits, Regions,\n                                                           LCtx, Call);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForRegionChanges(\n          CheckerManager::CheckRegionChangesFunc(checker,\n                                                 _checkRegionChanges<CHECKER>));\n  }\n};\n\nclass PointerEscape {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkPointerEscape(void *Checker,\n                     ProgramStateRef State,\n                     const InvalidatedSymbols &Escaped,\n                     const CallEvent *Call,\n                     PointerEscapeKind Kind,\n                     RegionAndSymbolInvalidationTraits *ETraits) {\n\n    if (!ETraits)\n      return ((const CHECKER *)Checker)->checkPointerEscape(State,\n                                                            Escaped,\n                                                            Call,\n                                                            Kind);\n\n    InvalidatedSymbols RegularEscape;\n    for (InvalidatedSymbols::const_iterator I = Escaped.begin(),\n                                            E = Escaped.end(); I != E; ++I)\n      if (!ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_PreserveContents) &&\n          !ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_SuppressEscape))\n        RegularEscape.insert(*I);\n\n    if (RegularEscape.empty())\n      return State;\n\n    return ((const CHECKER *)Checker)->checkPointerEscape(State,\n                                                          RegularEscape,\n                                                          Call,\n                                                          Kind);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPointerEscape(\n          CheckerManager::CheckPointerEscapeFunc(checker,\n                                                _checkPointerEscape<CHECKER>));\n  }\n};\n\nclass ConstPointerEscape {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkConstPointerEscape(void *Checker,\n                      ProgramStateRef State,\n                      const InvalidatedSymbols &Escaped,\n                      const CallEvent *Call,\n                      PointerEscapeKind Kind,\n                      RegionAndSymbolInvalidationTraits *ETraits) {\n\n    if (!ETraits)\n      return State;\n\n    InvalidatedSymbols ConstEscape;\n    for (InvalidatedSymbols::const_iterator I = Escaped.begin(),\n                                            E = Escaped.end(); I != E; ++I)\n      if (ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_PreserveContents) &&\n          !ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_SuppressEscape))\n        ConstEscape.insert(*I);\n\n    if (ConstEscape.empty())\n      return State;\n\n    return ((const CHECKER *)Checker)->checkConstPointerEscape(State,\n                                                               ConstEscape,\n                                                               Call,\n                                                               Kind);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPointerEscape(\n      CheckerManager::CheckPointerEscapeFunc(checker,\n                                            _checkConstPointerEscape<CHECKER>));\n  }\n};\n\n\ntemplate <typename EVENT>\nclass Event {\n  template <typename CHECKER>\n  static void _checkEvent(void *checker, const void *event) {\n    ((const CHECKER *)checker)->checkEvent(*(const EVENT *)event);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerListenerForEvent<EVENT>(\n                 CheckerManager::CheckEventFunc(checker, _checkEvent<CHECKER>));\n  }\n};\n\n} // end check namespace\n\nnamespace eval {\n\nclass Assume {\n  template <typename CHECKER>\n  static ProgramStateRef _evalAssume(void *checker,\n                                         ProgramStateRef state,\n                                         const SVal &cond,\n                                         bool assumption) {\n    return ((const CHECKER *)checker)->evalAssume(state, cond, assumption);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEvalAssume(\n                 CheckerManager::EvalAssumeFunc(checker, _evalAssume<CHECKER>));\n  }\n};\n\nclass Call {\n  template <typename CHECKER>\n  static bool _evalCall(void *checker, const CallEvent &Call,\n                        CheckerContext &C) {\n    return ((const CHECKER *)checker)->evalCall(Call, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEvalCall(\n                     CheckerManager::EvalCallFunc(checker, _evalCall<CHECKER>));\n  }\n};\n\n} // end eval namespace\n\nclass CheckerBase : public ProgramPointTag {\n  CheckerNameRef Name;\n  friend class ::clang::ento::CheckerManager;\n\npublic:\n  StringRef getTagDescription() const override;\n  CheckerNameRef getCheckerName() const;\n\n  /// See CheckerManager::runCheckersForPrintState.\n  virtual void printState(raw_ostream &Out, ProgramStateRef State,\n                          const char *NL, const char *Sep) const { }\n};\n\n/// Dump checker name to stream.\nraw_ostream& operator<<(raw_ostream &Out, const CheckerBase &Checker);\n\n/// Tag that can use a checker name as a message provider\n/// (see SimpleProgramPointTag).\nclass CheckerProgramPointTag : public SimpleProgramPointTag {\npublic:\n  CheckerProgramPointTag(StringRef CheckerName, StringRef Msg);\n  CheckerProgramPointTag(const CheckerBase *Checker, StringRef Msg);\n};\n\ntemplate <typename CHECK1, typename... CHECKs>\nclass Checker : public CHECK1, public CHECKs..., public CheckerBase {\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    CHECK1::_register(checker, mgr);\n    Checker<CHECKs...>::_register(checker, mgr);\n  }\n};\n\ntemplate <typename CHECK1>\nclass Checker<CHECK1> : public CHECK1, public CheckerBase {\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    CHECK1::_register(checker, mgr);\n  }\n};\n\ntemplate <typename EVENT>\nclass EventDispatcher {\n  CheckerManager *Mgr;\npublic:\n  EventDispatcher() : Mgr(nullptr) { }\n\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerDispatcherForEvent<EVENT>();\n    static_cast<EventDispatcher<EVENT> *>(checker)->Mgr = &mgr;\n  }\n\n  void dispatchEvent(const EVENT &event) const {\n    Mgr->_dispatchEvent(event);\n  }\n};\n\n/// We dereferenced a location that may be null.\nstruct ImplicitNullDerefEvent {\n  SVal Location;\n  bool IsLoad;\n  ExplodedNode *SinkNode;\n  BugReporter *BR;\n  // When true, the dereference is in the source code directly. When false, the\n  // dereference might happen later (for example pointer passed to a parameter\n  // that is marked with nonnull attribute.)\n  bool IsDirectDereference;\n\n  static int Tag;\n};\n\n/// A helper class which wraps a boolean value set to false by default.\n///\n/// This class should behave exactly like 'bool' except that it doesn't need to\n/// be explicitly initialized.\nstruct DefaultBool {\n  bool val;\n  DefaultBool() : val(false) {}\n  /*implicit*/ operator bool&() { return val; }\n  /*implicit*/ operator const bool&() const { return val; }\n  DefaultBool &operator=(bool b) { val = b; return *this; }\n};\n\n} // end ento namespace\n\n} // end clang namespace\n\n#endif\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h", "content": "//===- CallEvent.h - Wrapper for all function and method calls --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file This file defines CallEvent and its subclasses, which represent path-\n/// sensitive instances of different kinds of function and method calls\n/// (C, C++, and Objective-C).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <limits>\n#include <utility>\n\nnamespace clang {\n\nclass LocationContext;\nclass ProgramPoint;\nclass ProgramPointTag;\nclass StackFrameContext;\n\nnamespace ento {\n\nenum CallEventKind {\n  CE_Function,\n  CE_CXXMember,\n  CE_CXXMemberOperator,\n  CE_CXXDestructor,\n  CE_BEG_CXX_INSTANCE_CALLS = CE_CXXMember,\n  CE_END_CXX_INSTANCE_CALLS = CE_CXXDestructor,\n  CE_CXXConstructor,\n  CE_CXXInheritedConstructor,\n  CE_BEG_CXX_CONSTRUCTOR_CALLS = CE_CXXConstructor,\n  CE_END_CXX_CONSTRUCTOR_CALLS = CE_CXXInheritedConstructor,\n  CE_CXXAllocator,\n  CE_CXXDeallocator,\n  CE_BEG_FUNCTION_CALLS = CE_Function,\n  CE_END_FUNCTION_CALLS = CE_CXXDeallocator,\n  CE_Block,\n  CE_ObjCMessage\n};\n\nclass CallEvent;\nclass CallDescription;\n\ntemplate<typename T = CallEvent>\nclass CallEventRef : public IntrusiveRefCntPtr<const T> {\npublic:\n  CallEventRef(const T *Call) : IntrusiveRefCntPtr<const T>(Call) {}\n  CallEventRef(const CallEventRef &Orig) : IntrusiveRefCntPtr<const T>(Orig) {}\n\n  CallEventRef<T> cloneWithState(ProgramStateRef State) const {\n    return this->get()->template cloneWithState<T>(State);\n  }\n\n  // Allow implicit conversions to a superclass type, since CallEventRef\n  // behaves like a pointer-to-const.\n  template <typename SuperT>\n  operator CallEventRef<SuperT> () const {\n    return this->get();\n  }\n};\n\n/// \\class RuntimeDefinition\n/// Defines the runtime definition of the called function.\n///\n/// Encapsulates the information we have about which Decl will be used\n/// when the call is executed on the given path. When dealing with dynamic\n/// dispatch, the information is based on DynamicTypeInfo and might not be\n/// precise.\nclass RuntimeDefinition {\n  /// The Declaration of the function which could be called at runtime.\n  /// NULL if not available.\n  const Decl *D = nullptr;\n\n  /// The region representing an object (ObjC/C++) on which the method is\n  /// called. With dynamic dispatch, the method definition depends on the\n  /// runtime type of this object. NULL when the DynamicTypeInfo is\n  /// precise.\n  const MemRegion *R = nullptr;\n\npublic:\n  RuntimeDefinition() = default;\n  RuntimeDefinition(const Decl *InD): D(InD) {}\n  RuntimeDefinition(const Decl *InD, const MemRegion *InR): D(InD), R(InR) {}\n\n  const Decl *getDecl() { return D; }\n\n  /// Check if the definition we have is precise.\n  /// If not, it is possible that the call dispatches to another definition at\n  /// execution time.\n  bool mayHaveOtherDefinitions() { return R != nullptr; }\n\n  /// When other definitions are possible, returns the region whose runtime type\n  /// determines the method definition.\n  const MemRegion *getDispatchRegion() { return R; }\n};\n\n/// Represents an abstract call to a function or method along a\n/// particular path.\n///\n/// CallEvents are created through the factory methods of CallEventManager.\n///\n/// CallEvents should always be cheap to create and destroy. In order for\n/// CallEventManager to be able to re-use CallEvent-sized memory blocks,\n/// subclasses of CallEvent may not add any data members to the base class.\n/// Use the \"Data\" and \"Location\" fields instead.\nclass CallEvent {\npublic:\n  using Kind = CallEventKind;\n\nprivate:\n  ProgramStateRef State;\n  const LocationContext *LCtx;\n  llvm::PointerUnion<const Expr *, const Decl *> Origin;\n\nprotected:\n  // This is user data for subclasses.\n  const void *Data;\n\n  // This is user data for subclasses.\n  // This should come right before RefCount, so that the two fields can be\n  // packed together on LP64 platforms.\n  SourceLocation Location;\n\nprivate:\n  template <typename T> friend struct llvm::IntrusiveRefCntPtrInfo;\n\n  mutable unsigned RefCount = 0;\n\n  void Retain() const { ++RefCount; }\n  void Release() const;\n\nprotected:\n  friend class CallEventManager;\n\n  CallEvent(const Expr *E, ProgramStateRef state, const LocationContext *lctx)\n      : State(std::move(state)), LCtx(lctx), Origin(E) {}\n\n  CallEvent(const Decl *D, ProgramStateRef state, const LocationContext *lctx)\n      : State(std::move(state)), LCtx(lctx), Origin(D) {}\n\n  // DO NOT MAKE PUBLIC\n  CallEvent(const CallEvent &Original)\n      : State(Original.State), LCtx(Original.LCtx), Origin(Original.Origin),\n        Data(Original.Data), Location(Original.Location) {}\n\n  /// Copies this CallEvent, with vtable intact, into a new block of memory.\n  virtual void cloneTo(void *Dest) const = 0;\n\n  /// Get the value of arbitrary expressions at this point in the path.\n  SVal getSVal(const Stmt *S) const {\n    return getState()->getSVal(S, getLocationContext());\n  }\n\n  using ValueList = SmallVectorImpl<SVal>;\n\n  /// Used to specify non-argument regions that will be invalidated as a\n  /// result of this call.\n  virtual void getExtraInvalidatedValues(ValueList &Values,\n                 RegionAndSymbolInvalidationTraits *ETraits) const {}\n\npublic:\n  CallEvent &operator=(const CallEvent &) = delete;\n  virtual ~CallEvent() = default;\n\n  /// Returns the kind of call this is.\n  virtual Kind getKind() const = 0;\n  virtual StringRef getKindAsString() const = 0;\n\n  /// Returns the declaration of the function or method that will be\n  /// called. May be null.\n  virtual const Decl *getDecl() const {\n    return Origin.dyn_cast<const Decl *>();\n  }\n\n  /// The state in which the call is being evaluated.\n  const ProgramStateRef &getState() const {\n    return State;\n  }\n\n  /// The context in which the call is being evaluated.\n  const LocationContext *getLocationContext() const {\n    return LCtx;\n  }\n\n  /// Returns the definition of the function or method that will be\n  /// called.\n  virtual RuntimeDefinition getRuntimeDefinition() const = 0;\n\n  /// Returns the expression whose value will be the result of this call.\n  /// May be null.\n  virtual const Expr *getOriginExpr() const {\n    return Origin.dyn_cast<const Expr *>();\n  }\n\n  /// Returns the number of arguments (explicit and implicit).\n  ///\n  /// Note that this may be greater than the number of parameters in the\n  /// callee's declaration, and that it may include arguments not written in\n  /// the source.\n  virtual unsigned getNumArgs() const = 0;\n\n  /// Returns true if the callee is known to be from a system header.\n  bool isInSystemHeader() const {\n    const Decl *D = getDecl();\n    if (!D)\n      return false;\n\n    SourceLocation Loc = D->getLocation();\n    if (Loc.isValid()) {\n      const SourceManager &SM =\n        getState()->getStateManager().getContext().getSourceManager();\n      return SM.isInSystemHeader(D->getLocation());\n    }\n\n    // Special case for implicitly-declared global operator new/delete.\n    // These should be considered system functions.\n    if (const auto *FD = dyn_cast<FunctionDecl>(D))\n      return FD->isOverloadedOperator() && FD->isImplicit() && FD->isGlobal();\n\n    return false;\n  }\n\n  /// Returns true if the CallEvent is a call to a function that matches\n  /// the CallDescription.\n  ///\n  /// Note that this function is not intended to be used to match Obj-C method\n  /// calls.\n  bool isCalled(const CallDescription &CD) const;\n\n  /// Returns true whether the CallEvent is any of the CallDescriptions supplied\n  /// as a parameter.\n  template <typename FirstCallDesc, typename... CallDescs>\n  bool isCalled(const FirstCallDesc &First, const CallDescs &... Rest) const {\n    return isCalled(First) || isCalled(Rest...);\n  }\n\n  /// Returns a source range for the entire call, suitable for\n  /// outputting in diagnostics.\n  virtual SourceRange getSourceRange() const {\n    return getOriginExpr()->getSourceRange();\n  }\n\n  /// Returns the value of a given argument at the time of the call.\n  virtual SVal getArgSVal(unsigned Index) const;\n\n  /// Returns the expression associated with a given argument.\n  /// May be null if this expression does not appear in the source.\n  virtual const Expr *getArgExpr(unsigned Index) const { return nullptr; }\n\n  /// Returns the source range for errors associated with this argument.\n  ///\n  /// May be invalid if the argument is not written in the source.\n  virtual SourceRange getArgSourceRange(unsigned Index) const;\n\n  /// Returns the result type, adjusted for references.\n  QualType getResultType() const;\n\n  /// Returns the return value of the call.\n  ///\n  /// This should only be called if the CallEvent was created using a state in\n  /// which the return value has already been bound to the origin expression.\n  SVal getReturnValue() const;\n\n  /// Returns true if the type of any of the non-null arguments satisfies\n  /// the condition.\n  bool hasNonNullArgumentsWithType(bool (*Condition)(QualType)) const;\n\n  /// Returns true if any of the arguments appear to represent callbacks.\n  bool hasNonZeroCallbackArg() const;\n\n  /// Returns true if any of the arguments is void*.\n  bool hasVoidPointerToNonConstArg() const;\n\n  /// Returns true if any of the arguments are known to escape to long-\n  /// term storage, even if this method will not modify them.\n  // NOTE: The exact semantics of this are still being defined!\n  // We don't really want a list of hardcoded exceptions in the long run,\n  // but we don't want duplicated lists of known APIs in the short term either.\n  virtual bool argumentsMayEscape() const {\n    return hasNonZeroCallbackArg();\n  }\n\n  /// Returns true if the callee is an externally-visible function in the\n  /// top-level namespace, such as \\c malloc.\n  ///\n  /// You can use this call to determine that a particular function really is\n  /// a library function and not, say, a C++ member function with the same name.\n  ///\n  /// If a name is provided, the function must additionally match the given\n  /// name.\n  ///\n  /// Note that this deliberately excludes C++ library functions in the \\c std\n  /// namespace, but will include C library functions accessed through the\n  /// \\c std namespace. This also does not check if the function is declared\n  /// as 'extern \"C\"', or if it uses C++ name mangling.\n  // FIXME: Add a helper for checking namespaces.\n  // FIXME: Move this down to AnyFunctionCall once checkers have more\n  // precise callbacks.\n  bool isGlobalCFunction(StringRef SpecificName = StringRef()) const;\n\n  /// Returns the name of the callee, if its name is a simple identifier.\n  ///\n  /// Note that this will fail for Objective-C methods, blocks, and C++\n  /// overloaded operators. The former is named by a Selector rather than a\n  /// simple identifier, and the latter two do not have names.\n  // FIXME: Move this down to AnyFunctionCall once checkers have more\n  // precise callbacks.\n  const IdentifierInfo *getCalleeIdentifier() const {\n    const auto *ND = dyn_cast_or_null<NamedDecl>(getDecl());\n    if (!ND)\n      return nullptr;\n    return ND->getIdentifier();\n  }\n\n  /// Returns an appropriate ProgramPoint for this call.\n  ProgramPoint getProgramPoint(bool IsPreVisit = false,\n                               const ProgramPointTag *Tag = nullptr) const;\n\n  /// Returns a new state with all argument regions invalidated.\n  ///\n  /// This accepts an alternate state in case some processing has already\n  /// occurred.\n  ProgramStateRef invalidateRegions(unsigned BlockCount,\n                                    ProgramStateRef Orig = nullptr) const;\n\n  using FrameBindingTy = std::pair<SVal, SVal>;\n  using BindingsTy = SmallVectorImpl<FrameBindingTy>;\n\n  /// Populates the given SmallVector with the bindings in the callee's stack\n  /// frame at the start of this call.\n  virtual void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                            BindingsTy &Bindings) const = 0;\n\n  /// Returns a copy of this CallEvent, but using the given state.\n  template <typename T>\n  CallEventRef<T> cloneWithState(ProgramStateRef NewState) const;\n\n  /// Returns a copy of this CallEvent, but using the given state.\n  CallEventRef<> cloneWithState(ProgramStateRef NewState) const {\n    return cloneWithState<CallEvent>(NewState);\n  }\n\n  /// Returns true if this is a statement is a function or method call\n  /// of some kind.\n  static bool isCallStmt(const Stmt *S);\n\n  /// Returns the result type of a function or method declaration.\n  ///\n  /// This will return a null QualType if the result type cannot be determined.\n  static QualType getDeclaredResultType(const Decl *D);\n\n  /// Returns true if the given decl is known to be variadic.\n  ///\n  /// \\p D must not be null.\n  static bool isVariadic(const Decl *D);\n\n  /// Returns AnalysisDeclContext for the callee stack frame.\n  /// Currently may fail; returns null on failure.\n  AnalysisDeclContext *getCalleeAnalysisDeclContext() const;\n\n  /// Returns the callee stack frame. That stack frame will only be entered\n  /// during analysis if the call is inlined, but it may still be useful\n  /// in intermediate calculations even if the call isn't inlined.\n  /// May fail; returns null on failure.\n  const StackFrameContext *getCalleeStackFrame(unsigned BlockCount) const;\n\n  /// Returns memory location for a parameter variable within the callee stack\n  /// frame. The behavior is undefined if the block count is different from the\n  /// one that is there when call happens. May fail; returns null on failure.\n  const ParamVarRegion *getParameterLocation(unsigned Index,\n                                             unsigned BlockCount) const;\n\n  /// Returns true if on the current path, the argument was constructed by\n  /// calling a C++ constructor over it. This is an internal detail of the\n  /// analysis which doesn't necessarily represent the program semantics:\n  /// if we are supposed to construct an argument directly, we may still\n  /// not do that because we don't know how (i.e., construction context is\n  /// unavailable in the CFG or not supported by the analyzer).\n  bool isArgumentConstructedDirectly(unsigned Index) const {\n    // This assumes that the object was not yet removed from the state.\n    return ExprEngine::getObjectUnderConstruction(\n        getState(), {getOriginExpr(), Index}, getLocationContext()).hasValue();\n  }\n\n  /// Some calls have parameter numbering mismatched from argument numbering.\n  /// This function converts an argument index to the corresponding\n  /// parameter index. Returns None is the argument doesn't correspond\n  /// to any parameter variable.\n  virtual Optional<unsigned>\n  getAdjustedParameterIndex(unsigned ASTArgumentIndex) const {\n    return ASTArgumentIndex;\n  }\n\n  /// Some call event sub-classes conveniently adjust mismatching AST indices\n  /// to match parameter indices. This function converts an argument index\n  /// as understood by CallEvent to the argument index as understood by the AST.\n  virtual unsigned getASTArgumentIndex(unsigned CallArgumentIndex) const {\n    return CallArgumentIndex;\n  }\n\n  /// Returns the construction context of the call, if it is a C++ constructor\n  /// call or a call of a function returning a C++ class instance. Otherwise\n  /// return nullptr.\n  const ConstructionContext *getConstructionContext() const;\n\n  /// If the call returns a C++ record type then the region of its return value\n  /// can be retrieved from its construction context.\n  Optional<SVal> getReturnValueUnderConstruction() const;\n\n  // Iterator access to formal parameters and their types.\nprivate:\n  struct GetTypeFn {\n    QualType operator()(ParmVarDecl *PD) const { return PD->getType(); }\n  };\n\npublic:\n  /// Return call's formal parameters.\n  ///\n  /// Remember that the number of formal parameters may not match the number\n  /// of arguments for all calls. However, the first parameter will always\n  /// correspond with the argument value returned by \\c getArgSVal(0).\n  virtual ArrayRef<ParmVarDecl *> parameters() const = 0;\n\n  using param_type_iterator =\n      llvm::mapped_iterator<ArrayRef<ParmVarDecl *>::iterator, GetTypeFn>;\n\n  /// Returns an iterator over the types of the call's formal parameters.\n  ///\n  /// This uses the callee decl found by default name lookup rather than the\n  /// definition because it represents a public interface, and probably has\n  /// more annotations.\n  param_type_iterator param_type_begin() const {\n    return llvm::map_iterator(parameters().begin(), GetTypeFn());\n  }\n  /// \\sa param_type_begin()\n  param_type_iterator param_type_end() const {\n    return llvm::map_iterator(parameters().end(), GetTypeFn());\n  }\n\n  // For debugging purposes only\n  void dump(raw_ostream &Out) const;\n  void dump() const;\n};\n\n/// Represents a call to any sort of function that might have a\n/// FunctionDecl.\nclass AnyFunctionCall : public CallEvent {\nprotected:\n  AnyFunctionCall(const Expr *E, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : CallEvent(E, St, LCtx) {}\n  AnyFunctionCall(const Decl *D, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : CallEvent(D, St, LCtx) {}\n  AnyFunctionCall(const AnyFunctionCall &Other) = default;\n\npublic:\n  // This function is overridden by subclasses, but they must return\n  // a FunctionDecl.\n  const FunctionDecl *getDecl() const override {\n    return cast<FunctionDecl>(CallEvent::getDecl());\n  }\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  bool argumentsMayEscape() const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  ArrayRef<ParmVarDecl *> parameters() const override;\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() >= CE_BEG_FUNCTION_CALLS &&\n           CA->getKind() <= CE_END_FUNCTION_CALLS;\n  }\n};\n\n/// Represents a C function or static C++ member function call.\n///\n/// Example: \\c fun()\nclass SimpleFunctionCall : public AnyFunctionCall {\n  friend class CallEventManager;\n\nprotected:\n  SimpleFunctionCall(const CallExpr *CE, ProgramStateRef St,\n                     const LocationContext *LCtx)\n      : AnyFunctionCall(CE, St, LCtx) {}\n  SimpleFunctionCall(const SimpleFunctionCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) SimpleFunctionCall(*this);\n  }\n\npublic:\n  const CallExpr *getOriginExpr() const override {\n    return cast<CallExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const FunctionDecl *getDecl() const override;\n\n  unsigned getNumArgs() const override { return getOriginExpr()->getNumArgs(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  Kind getKind() const override { return CE_Function; }\n  StringRef getKindAsString() const override { return \"SimpleFunctionCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_Function;\n  }\n};\n\n/// Represents a call to a block.\n///\n/// Example: <tt>^{ statement-body }()</tt>\nclass BlockCall : public CallEvent {\n  friend class CallEventManager;\n\nprotected:\n  BlockCall(const CallExpr *CE, ProgramStateRef St,\n            const LocationContext *LCtx)\n      : CallEvent(CE, St, LCtx) {}\n  BlockCall(const BlockCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) BlockCall(*this); }\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\npublic:\n  const CallExpr *getOriginExpr() const override {\n    return cast<CallExpr>(CallEvent::getOriginExpr());\n  }\n\n  unsigned getNumArgs() const override { return getOriginExpr()->getNumArgs(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  /// Returns the region associated with this instance of the block.\n  ///\n  /// This may be NULL if the block's origin is unknown.\n  const BlockDataRegion *getBlockRegion() const;\n\n  const BlockDecl *getDecl() const override {\n    const BlockDataRegion *BR = getBlockRegion();\n    if (!BR)\n      return nullptr;\n    return BR->getDecl();\n  }\n\n  bool isConversionFromLambda() const {\n    const BlockDecl *BD = getDecl();\n    if (!BD)\n      return false;\n\n    return BD->isConversionFromLambda();\n  }\n\n  /// For a block converted from a C++ lambda, returns the block\n  /// VarRegion for the variable holding the captured C++ lambda record.\n  const VarRegion *getRegionStoringCapturedLambda() const {\n    assert(isConversionFromLambda());\n    const BlockDataRegion *BR = getBlockRegion();\n    assert(BR && \"Block converted from lambda must have a block region\");\n\n    auto I = BR->referenced_vars_begin();\n    assert(I != BR->referenced_vars_end());\n\n    return I.getCapturedRegion();\n  }\n\n  RuntimeDefinition getRuntimeDefinition() const override {\n    if (!isConversionFromLambda())\n      return RuntimeDefinition(getDecl());\n\n    // Clang converts lambdas to blocks with an implicit user-defined\n    // conversion operator method on the lambda record that looks (roughly)\n    // like:\n    //\n    // typedef R(^block_type)(P1, P2, ...);\n    // operator block_type() const {\n    //   auto Lambda = *this;\n    //   return ^(P1 p1, P2 p2, ...){\n    //     /* return Lambda(p1, p2, ...); */\n    //   };\n    // }\n    //\n    // Here R is the return type of the lambda and P1, P2, ... are\n    // its parameter types. 'Lambda' is a fake VarDecl captured by the block\n    // that is initialized to a copy of the lambda.\n    //\n    // Sema leaves the body of a lambda-converted block empty (it is\n    // produced by CodeGen), so we can't analyze it directly. Instead, we skip\n    // the block body and analyze the operator() method on the captured lambda.\n    const VarDecl *LambdaVD = getRegionStoringCapturedLambda()->getDecl();\n    const CXXRecordDecl *LambdaDecl = LambdaVD->getType()->getAsCXXRecordDecl();\n    CXXMethodDecl* LambdaCallOperator = LambdaDecl->getLambdaCallOperator();\n\n    return RuntimeDefinition(LambdaCallOperator);\n  }\n\n  bool argumentsMayEscape() const override {\n    return true;\n  }\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  ArrayRef<ParmVarDecl *> parameters() const override;\n\n  Kind getKind() const override { return CE_Block; }\n  StringRef getKindAsString() const override { return \"BlockCall\"; }\n\n  static bool classof(const CallEvent *CA) { return CA->getKind() == CE_Block; }\n};\n\n/// Represents a non-static C++ member function call, no matter how\n/// it is written.\nclass CXXInstanceCall : public AnyFunctionCall {\nprotected:\n  CXXInstanceCall(const CallExpr *CE, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : AnyFunctionCall(CE, St, LCtx) {}\n  CXXInstanceCall(const FunctionDecl *D, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : AnyFunctionCall(D, St, LCtx) {}\n  CXXInstanceCall(const CXXInstanceCall &Other) = default;\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\npublic:\n  /// Returns the expression representing the implicit 'this' object.\n  virtual const Expr *getCXXThisExpr() const { return nullptr; }\n\n  /// Returns the value of the implicit 'this' object.\n  virtual SVal getCXXThisVal() const;\n\n  const FunctionDecl *getDecl() const override;\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() >= CE_BEG_CXX_INSTANCE_CALLS &&\n           CA->getKind() <= CE_END_CXX_INSTANCE_CALLS;\n  }\n};\n\n/// Represents a non-static C++ member function call.\n///\n/// Example: \\c obj.fun()\nclass CXXMemberCall : public CXXInstanceCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXMemberCall(const CXXMemberCallExpr *CE, ProgramStateRef St,\n                const LocationContext *LCtx)\n      : CXXInstanceCall(CE, St, LCtx) {}\n  CXXMemberCall(const CXXMemberCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) CXXMemberCall(*this); }\n\npublic:\n  const CXXMemberCallExpr *getOriginExpr() const override {\n    return cast<CXXMemberCallExpr>(CXXInstanceCall::getOriginExpr());\n  }\n\n  unsigned getNumArgs() const override {\n    if (const CallExpr *CE = getOriginExpr())\n      return CE->getNumArgs();\n    return 0;\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  const Expr *getCXXThisExpr() const override;\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  Kind getKind() const override { return CE_CXXMember; }\n  StringRef getKindAsString() const override { return \"CXXMemberCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXMember;\n  }\n};\n\n/// Represents a C++ overloaded operator call where the operator is\n/// implemented as a non-static member function.\n///\n/// Example: <tt>iter + 1</tt>\nclass CXXMemberOperatorCall : public CXXInstanceCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXMemberOperatorCall(const CXXOperatorCallExpr *CE, ProgramStateRef St,\n                        const LocationContext *LCtx)\n      : CXXInstanceCall(CE, St, LCtx) {}\n  CXXMemberOperatorCall(const CXXMemberOperatorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) CXXMemberOperatorCall(*this);\n  }\n\npublic:\n  const CXXOperatorCallExpr *getOriginExpr() const override {\n    return cast<CXXOperatorCallExpr>(CXXInstanceCall::getOriginExpr());\n  }\n\n  unsigned getNumArgs() const override {\n    return getOriginExpr()->getNumArgs() - 1;\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index + 1);\n  }\n\n  const Expr *getCXXThisExpr() const override;\n\n  Kind getKind() const override { return CE_CXXMemberOperator; }\n  StringRef getKindAsString() const override { return \"CXXMemberOperatorCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXMemberOperator;\n  }\n\n  Optional<unsigned>\n  getAdjustedParameterIndex(unsigned ASTArgumentIndex) const override {\n    // For member operator calls argument 0 on the expression corresponds\n    // to implicit this-parameter on the declaration.\n    return (ASTArgumentIndex > 0) ? Optional<unsigned>(ASTArgumentIndex - 1)\n                                  : None;\n  }\n\n  unsigned getASTArgumentIndex(unsigned CallArgumentIndex) const override {\n    // For member operator calls argument 0 on the expression corresponds\n    // to implicit this-parameter on the declaration.\n    return CallArgumentIndex + 1;\n  }\n\n  OverloadedOperatorKind getOverloadedOperator() const {\n    return getOriginExpr()->getOperator();\n  }\n};\n\n/// Represents an implicit call to a C++ destructor.\n///\n/// This can occur at the end of a scope (for automatic objects), at the end\n/// of a full-expression (for temporaries), or as part of a delete.\nclass CXXDestructorCall : public CXXInstanceCall {\n  friend class CallEventManager;\n\nprotected:\n  using DtorDataTy = llvm::PointerIntPair<const MemRegion *, 1, bool>;\n\n  /// Creates an implicit destructor.\n  ///\n  /// \\param DD The destructor that will be called.\n  /// \\param Trigger The statement whose completion causes this destructor call.\n  /// \\param Target The object region to be destructed.\n  /// \\param St The path-sensitive state at this point in the program.\n  /// \\param LCtx The location context at this point in the program.\n  CXXDestructorCall(const CXXDestructorDecl *DD, const Stmt *Trigger,\n                    const MemRegion *Target, bool IsBaseDestructor,\n                    ProgramStateRef St, const LocationContext *LCtx)\n      : CXXInstanceCall(DD, St, LCtx) {\n    Data = DtorDataTy(Target, IsBaseDestructor).getOpaqueValue();\n    Location = Trigger->getEndLoc();\n  }\n\n  CXXDestructorCall(const CXXDestructorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {new (Dest) CXXDestructorCall(*this);}\n\npublic:\n  SourceRange getSourceRange() const override { return Location; }\n  unsigned getNumArgs() const override { return 0; }\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  /// Returns the value of the implicit 'this' object.\n  SVal getCXXThisVal() const override;\n\n  /// Returns true if this is a call to a base class destructor.\n  bool isBaseDestructor() const {\n    return DtorDataTy::getFromOpaqueValue(Data).getInt();\n  }\n\n  Kind getKind() const override { return CE_CXXDestructor; }\n  StringRef getKindAsString() const override { return \"CXXDestructorCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXDestructor;\n  }\n};\n\n/// Represents any constructor invocation. This includes regular constructors\n/// and inherited constructors.\nclass AnyCXXConstructorCall : public AnyFunctionCall {\nprotected:\n  AnyCXXConstructorCall(const Expr *E, const MemRegion *Target,\n                        ProgramStateRef St, const LocationContext *LCtx)\n      : AnyFunctionCall(E, St, LCtx) {\n    assert(E && (isa<CXXConstructExpr>(E) || isa<CXXInheritedCtorInitExpr>(E)));\n    // Target may be null when the region is unknown.\n    Data = Target;\n  }\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\npublic:\n  /// Returns the value of the implicit 'this' object.\n  SVal getCXXThisVal() const;\n\n  static bool classof(const CallEvent *Call) {\n    return Call->getKind() >= CE_BEG_CXX_CONSTRUCTOR_CALLS &&\n           Call->getKind() <= CE_END_CXX_CONSTRUCTOR_CALLS;\n  }\n};\n\n/// Represents a call to a C++ constructor.\n///\n/// Example: \\c T(1)\nclass CXXConstructorCall : public AnyCXXConstructorCall {\n  friend class CallEventManager;\n\nprotected:\n  /// Creates a constructor call.\n  ///\n  /// \\param CE The constructor expression as written in the source.\n  /// \\param Target The region where the object should be constructed. If NULL,\n  ///               a new symbolic region will be used.\n  /// \\param St The path-sensitive state at this point in the program.\n  /// \\param LCtx The location context at this point in the program.\n  CXXConstructorCall(const CXXConstructExpr *CE, const MemRegion *Target,\n                     ProgramStateRef St, const LocationContext *LCtx)\n      : AnyCXXConstructorCall(CE, Target, St, LCtx) {}\n\n  CXXConstructorCall(const CXXConstructorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) CXXConstructorCall(*this); }\n\npublic:\n  const CXXConstructExpr *getOriginExpr() const override {\n    return cast<CXXConstructExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const CXXConstructorDecl *getDecl() const override {\n    return getOriginExpr()->getConstructor();\n  }\n\n  unsigned getNumArgs() const override { return getOriginExpr()->getNumArgs(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  Kind getKind() const override { return CE_CXXConstructor; }\n  StringRef getKindAsString() const override { return \"CXXConstructorCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXConstructor;\n  }\n};\n\n/// Represents a call to a C++ inherited constructor.\n///\n/// Example: \\c class T : public S { using S::S; }; T(1);\n///\n// Note, it is difficult to model the parameters. This is one of the reasons\n// why we skip analysis of inheriting constructors as top-level functions.\n// CXXInheritedCtorInitExpr doesn't take arguments and doesn't model parameter\n// initialization because there is none: the arguments in the outer\n// CXXConstructExpr directly initialize the parameters of the base class\n// constructor, and no copies are made. (Making a copy of the parameter is\n// incorrect, at least if it's done in an observable way.) The derived class\n// constructor doesn't even exist in the formal model.\n/// E.g., in:\n///\n/// struct X { X *p = this; ~X() {} };\n/// struct A { A(X x) : b(x.p == &x) {} bool b; };\n/// struct B : A { using A::A; };\n/// B b = X{};\n///\n/// ... b.b is initialized to true.\nclass CXXInheritedConstructorCall : public AnyCXXConstructorCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXInheritedConstructorCall(const CXXInheritedCtorInitExpr *CE,\n                              const MemRegion *Target, ProgramStateRef St,\n                              const LocationContext *LCtx)\n      : AnyCXXConstructorCall(CE, Target, St, LCtx) {}\n\n  CXXInheritedConstructorCall(const CXXInheritedConstructorCall &Other) =\n      default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) CXXInheritedConstructorCall(*this);\n  }\n\npublic:\n  const CXXInheritedCtorInitExpr *getOriginExpr() const override {\n    return cast<CXXInheritedCtorInitExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const CXXConstructorDecl *getDecl() const override {\n    return getOriginExpr()->getConstructor();\n  }\n\n  /// Obtain the stack frame of the inheriting constructor. Argument expressions\n  /// can be found on the call site of that stack frame.\n  const StackFrameContext *getInheritingStackFrame() const;\n\n  /// Obtain the CXXConstructExpr for the sub-class that inherited the current\n  /// constructor (possibly indirectly). It's the statement that contains\n  /// argument expressions.\n  const CXXConstructExpr *getInheritingConstructor() const {\n    return cast<CXXConstructExpr>(getInheritingStackFrame()->getCallSite());\n  }\n\n  unsigned getNumArgs() const override {\n    return getInheritingConstructor()->getNumArgs();\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getInheritingConstructor()->getArg(Index);\n  }\n\n  SVal getArgSVal(unsigned Index) const override {\n    return getState()->getSVal(\n        getArgExpr(Index),\n        getInheritingStackFrame()->getParent()->getStackFrame());\n  }\n\n  Kind getKind() const override { return CE_CXXInheritedConstructor; }\n  StringRef getKindAsString() const override {\n    return \"CXXInheritedConstructorCall\";\n  }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXInheritedConstructor;\n  }\n};\n\n/// Represents the memory allocation call in a C++ new-expression.\n///\n/// This is a call to \"operator new\".\nclass CXXAllocatorCall : public AnyFunctionCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXAllocatorCall(const CXXNewExpr *E, ProgramStateRef St,\n                   const LocationContext *LCtx)\n      : AnyFunctionCall(E, St, LCtx) {}\n  CXXAllocatorCall(const CXXAllocatorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) CXXAllocatorCall(*this); }\n\npublic:\n  const CXXNewExpr *getOriginExpr() const override {\n    return cast<CXXNewExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const FunctionDecl *getDecl() const override {\n    return getOriginExpr()->getOperatorNew();\n  }\n\n  SVal getObjectUnderConstruction() const {\n    return ExprEngine::getObjectUnderConstruction(getState(), getOriginExpr(),\n                                                  getLocationContext())\n        .getValue();\n  }\n\n  /// Number of non-placement arguments to the call. It is equal to 2 for\n  /// C++17 aligned operator new() calls that have alignment implicitly\n  /// passed as the second argument, and to 1 for other operator new() calls.\n  unsigned getNumImplicitArgs() const {\n    return getOriginExpr()->passAlignment() ? 2 : 1;\n  }\n\n  unsigned getNumArgs() const override {\n    return getOriginExpr()->getNumPlacementArgs() + getNumImplicitArgs();\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    // The first argument of an allocator call is the size of the allocation.\n    if (Index < getNumImplicitArgs())\n      return nullptr;\n    return getOriginExpr()->getPlacementArg(Index - getNumImplicitArgs());\n  }\n\n  /// Number of placement arguments to the operator new() call. For example,\n  /// standard std::nothrow operator new and standard placement new both have\n  /// 1 implicit argument (size) and 1 placement argument, while regular\n  /// operator new() has 1 implicit argument and 0 placement arguments.\n  const Expr *getPlacementArgExpr(unsigned Index) const {\n    return getOriginExpr()->getPlacementArg(Index);\n  }\n\n  Kind getKind() const override { return CE_CXXAllocator; }\n  StringRef getKindAsString() const override { return \"CXXAllocatorCall\"; }\n\n  static bool classof(const CallEvent *CE) {\n    return CE->getKind() == CE_CXXAllocator;\n  }\n};\n\n/// Represents the memory deallocation call in a C++ delete-expression.\n///\n/// This is a call to \"operator delete\".\n// FIXME: CXXDeleteExpr isn't present for custom delete operators, or even for\n// some those that are in the standard library, like the no-throw or align_val\n// versions.\n// Some pointers:\n// http://lists.llvm.org/pipermail/cfe-dev/2020-April/065080.html\n// clang/test/Analysis/cxx-dynamic-memory-analysis-order.cpp\n// clang/unittests/StaticAnalyzer/CallEventTest.cpp\nclass CXXDeallocatorCall : public AnyFunctionCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXDeallocatorCall(const CXXDeleteExpr *E, ProgramStateRef St,\n                     const LocationContext *LCtx)\n      : AnyFunctionCall(E, St, LCtx) {}\n  CXXDeallocatorCall(const CXXDeallocatorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) CXXDeallocatorCall(*this);\n  }\n\npublic:\n  const CXXDeleteExpr *getOriginExpr() const override {\n    return cast<CXXDeleteExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const FunctionDecl *getDecl() const override {\n    return getOriginExpr()->getOperatorDelete();\n  }\n\n  unsigned getNumArgs() const override { return getDecl()->getNumParams(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    // CXXDeleteExpr's only have a single argument.\n    return getOriginExpr()->getArgument();\n  }\n\n  Kind getKind() const override { return CE_CXXDeallocator; }\n  StringRef getKindAsString() const override { return \"CXXDeallocatorCall\"; }\n\n  static bool classof(const CallEvent *CE) {\n    return CE->getKind() == CE_CXXDeallocator;\n  }\n};\n\n/// Represents the ways an Objective-C message send can occur.\n//\n// Note to maintainers: OCM_Message should always be last, since it does not\n// need to fit in the Data field's low bits.\nenum ObjCMessageKind {\n  OCM_PropertyAccess,\n  OCM_Subscript,\n  OCM_Message\n};\n\n/// Represents any expression that calls an Objective-C method.\n///\n/// This includes all of the kinds listed in ObjCMessageKind.\nclass ObjCMethodCall : public CallEvent {\n  friend class CallEventManager;\n\n  const PseudoObjectExpr *getContainingPseudoObjectExpr() const;\n\nprotected:\n  ObjCMethodCall(const ObjCMessageExpr *Msg, ProgramStateRef St,\n                 const LocationContext *LCtx)\n      : CallEvent(Msg, St, LCtx) {\n    Data = nullptr;\n  }\n\n  ObjCMethodCall(const ObjCMethodCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) ObjCMethodCall(*this); }\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\n  /// Check if the selector may have multiple definitions (may have overrides).\n  virtual bool canBeOverridenInSubclass(ObjCInterfaceDecl *IDecl,\n                                        Selector Sel) const;\n\npublic:\n  const ObjCMessageExpr *getOriginExpr() const override {\n    return cast<ObjCMessageExpr>(CallEvent::getOriginExpr());\n  }\n\n  const ObjCMethodDecl *getDecl() const override {\n    return getOriginExpr()->getMethodDecl();\n  }\n\n  unsigned getNumArgs() const override {\n    return getOriginExpr()->getNumArgs();\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  bool isInstanceMessage() const {\n    return getOriginExpr()->isInstanceMessage();\n  }\n\n  ObjCMethodFamily getMethodFamily() const {\n    return getOriginExpr()->getMethodFamily();\n  }\n\n  Selector getSelector() const {\n    return getOriginExpr()->getSelector();\n  }\n\n  SourceRange getSourceRange() const override;\n\n  /// Returns the value of the receiver at the time of this call.\n  SVal getReceiverSVal() const;\n\n  /// Get the interface for the receiver.\n  ///\n  /// This works whether this is an instance message or a class message.\n  /// However, it currently just uses the static type of the receiver.\n  const ObjCInterfaceDecl *getReceiverInterface() const {\n    return getOriginExpr()->getReceiverInterface();\n  }\n\n  /// Checks if the receiver refers to 'self' or 'super'.\n  bool isReceiverSelfOrSuper() const;\n\n  /// Returns how the message was written in the source (property access,\n  /// subscript, or explicit message send).\n  ObjCMessageKind getMessageKind() const;\n\n  /// Returns true if this property access or subscript is a setter (has the\n  /// form of an assignment).\n  bool isSetter() const {\n    switch (getMessageKind()) {\n    case OCM_Message:\n      llvm_unreachable(\"This is not a pseudo-object access!\");\n    case OCM_PropertyAccess:\n      return getNumArgs() > 0;\n    case OCM_Subscript:\n      return getNumArgs() > 1;\n    }\n    llvm_unreachable(\"Unknown message kind\");\n  }\n\n  // Returns the property accessed by this method, either explicitly via\n  // property syntax or implicitly via a getter or setter method. Returns\n  // nullptr if the call is not a prooperty access.\n  const ObjCPropertyDecl *getAccessedProperty() const;\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  bool argumentsMayEscape() const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  ArrayRef<ParmVarDecl*> parameters() const override;\n\n  Kind getKind() const override { return CE_ObjCMessage; }\n  StringRef getKindAsString() const override { return \"ObjCMethodCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_ObjCMessage;\n  }\n};\n\nenum CallDescriptionFlags : int {\n  /// Describes a C standard function that is sometimes implemented as a macro\n  /// that expands to a compiler builtin with some __builtin prefix.\n  /// The builtin may as well have a few extra arguments on top of the requested\n  /// number of arguments.\n  CDF_MaybeBuiltin = 1 << 0,\n};\n\n/// This class represents a description of a function call using the number of\n/// arguments and the name of the function.\nclass CallDescription {\n  friend CallEvent;\n\n  mutable IdentifierInfo *II = nullptr;\n  mutable bool IsLookupDone = false;\n  // The list of the qualified names used to identify the specified CallEvent,\n  // e.g. \"{a, b}\" represent the qualified names, like \"a::b\".\n  std::vector<const char *> QualifiedName;\n  Optional<unsigned> RequiredArgs;\n  Optional<size_t> RequiredParams;\n  int Flags;\n\n  // A constructor helper.\n  static Optional<size_t> readRequiredParams(Optional<unsigned> RequiredArgs,\n                                             Optional<size_t> RequiredParams) {\n    if (RequiredParams)\n      return RequiredParams;\n    if (RequiredArgs)\n      return static_cast<size_t>(*RequiredArgs);\n    return None;\n  }\n\npublic:\n  /// Constructs a CallDescription object.\n  ///\n  /// @param QualifiedName The list of the name qualifiers of the function that\n  /// will be matched. The user is allowed to skip any of the qualifiers.\n  /// For example, {\"std\", \"basic_string\", \"c_str\"} would match both\n  /// std::basic_string<...>::c_str() and std::__1::basic_string<...>::c_str().\n  ///\n  /// @param RequiredArgs The number of arguments that is expected to match a\n  /// call. Omit this parameter to match every occurrence of call with a given\n  /// name regardless the number of arguments.\n  CallDescription(int Flags, ArrayRef<const char *> QualifiedName,\n                  Optional<unsigned> RequiredArgs = None,\n                  Optional<size_t> RequiredParams = None)\n      : QualifiedName(QualifiedName), RequiredArgs(RequiredArgs),\n        RequiredParams(readRequiredParams(RequiredArgs, RequiredParams)),\n        Flags(Flags) {}\n\n  /// Construct a CallDescription with default flags.\n  CallDescription(ArrayRef<const char *> QualifiedName,\n                  Optional<unsigned> RequiredArgs = None,\n                  Optional<size_t> RequiredParams = None)\n      : CallDescription(0, QualifiedName, RequiredArgs, RequiredParams) {}\n\n  /// Get the name of the function that this object matches.\n  StringRef getFunctionName() const { return QualifiedName.back(); }\n};\n\n/// An immutable map from CallDescriptions to arbitrary data. Provides a unified\n/// way for checkers to react on function calls.\ntemplate <typename T> class CallDescriptionMap {\n  // Some call descriptions aren't easily hashable (eg., the ones with qualified\n  // names in which some sections are omitted), so let's put them\n  // in a simple vector and use linear lookup.\n  // TODO: Implement an actual map for fast lookup for \"hashable\" call\n  // descriptions (eg., the ones for C functions that just match the name).\n  std::vector<std::pair<CallDescription, T>> LinearMap;\n\npublic:\n  CallDescriptionMap(\n      std::initializer_list<std::pair<CallDescription, T>> &&List)\n      : LinearMap(List) {}\n\n  ~CallDescriptionMap() = default;\n\n  // These maps are usually stored once per checker, so let's make sure\n  // we don't do redundant copies.\n  CallDescriptionMap(const CallDescriptionMap &) = delete;\n  CallDescriptionMap &operator=(const CallDescription &) = delete;\n\n  const T *lookup(const CallEvent &Call) const {\n    // Slow path: linear lookup.\n    // TODO: Implement some sort of fast path.\n    for (const std::pair<CallDescription, T> &I : LinearMap)\n      if (Call.isCalled(I.first))\n        return &I.second;\n\n    return nullptr;\n  }\n};\n\n/// Manages the lifetime of CallEvent objects.\n///\n/// CallEventManager provides a way to create arbitrary CallEvents \"on the\n/// stack\" as if they were value objects by keeping a cache of CallEvent-sized\n/// memory blocks. The CallEvents created by CallEventManager are only valid\n/// for the lifetime of the OwnedCallEvent that holds them; right now these\n/// objects cannot be copied and ownership cannot be transferred.\nclass CallEventManager {\n  friend class CallEvent;\n\n  llvm::BumpPtrAllocator &Alloc;\n  SmallVector<void *, 8> Cache;\n\n  using CallEventTemplateTy = SimpleFunctionCall;\n\n  void reclaim(const void *Memory) {\n    Cache.push_back(const_cast<void *>(Memory));\n  }\n\n  /// Returns memory that can be initialized as a CallEvent.\n  void *allocate() {\n    if (Cache.empty())\n      return Alloc.Allocate<CallEventTemplateTy>();\n    else\n      return Cache.pop_back_val();\n  }\n\n  template <typename T, typename Arg>\n  T *create(Arg A, ProgramStateRef St, const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A, St, LCtx);\n  }\n\n  template <typename T, typename Arg1, typename Arg2>\n  T *create(Arg1 A1, Arg2 A2, ProgramStateRef St, const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A1, A2, St, LCtx);\n  }\n\n  template <typename T, typename Arg1, typename Arg2, typename Arg3>\n  T *create(Arg1 A1, Arg2 A2, Arg3 A3, ProgramStateRef St,\n            const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A1, A2, A3, St, LCtx);\n  }\n\n  template <typename T, typename Arg1, typename Arg2, typename Arg3,\n            typename Arg4>\n  T *create(Arg1 A1, Arg2 A2, Arg3 A3, Arg4 A4, ProgramStateRef St,\n            const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A1, A2, A3, A4, St, LCtx);\n  }\n\npublic:\n  CallEventManager(llvm::BumpPtrAllocator &alloc) : Alloc(alloc) {}\n\n  /// Gets an outside caller given a callee context.\n  CallEventRef<>\n  getCaller(const StackFrameContext *CalleeCtx, ProgramStateRef State);\n\n  /// Gets a call event for a function call, Objective-C method call,\n  /// or a 'new' call.\n  CallEventRef<>\n  getCall(const Stmt *S, ProgramStateRef State,\n          const LocationContext *LC);\n\n  CallEventRef<>\n  getSimpleCall(const CallExpr *E, ProgramStateRef State,\n                const LocationContext *LCtx);\n\n  CallEventRef<ObjCMethodCall>\n  getObjCMethodCall(const ObjCMessageExpr *E, ProgramStateRef State,\n                    const LocationContext *LCtx) {\n    return create<ObjCMethodCall>(E, State, LCtx);\n  }\n\n  CallEventRef<CXXConstructorCall>\n  getCXXConstructorCall(const CXXConstructExpr *E, const MemRegion *Target,\n                        ProgramStateRef State, const LocationContext *LCtx) {\n    return create<CXXConstructorCall>(E, Target, State, LCtx);\n  }\n\n  CallEventRef<CXXInheritedConstructorCall>\n  getCXXInheritedConstructorCall(const CXXInheritedCtorInitExpr *E,\n                                 const MemRegion *Target, ProgramStateRef State,\n                                 const LocationContext *LCtx) {\n    return create<CXXInheritedConstructorCall>(E, Target, State, LCtx);\n  }\n\n  CallEventRef<CXXDestructorCall>\n  getCXXDestructorCall(const CXXDestructorDecl *DD, const Stmt *Trigger,\n                       const MemRegion *Target, bool IsBase,\n                       ProgramStateRef State, const LocationContext *LCtx) {\n    return create<CXXDestructorCall>(DD, Trigger, Target, IsBase, State, LCtx);\n  }\n\n  CallEventRef<CXXAllocatorCall>\n  getCXXAllocatorCall(const CXXNewExpr *E, ProgramStateRef State,\n                      const LocationContext *LCtx) {\n    return create<CXXAllocatorCall>(E, State, LCtx);\n  }\n\n  CallEventRef<CXXDeallocatorCall>\n  getCXXDeallocatorCall(const CXXDeleteExpr *E, ProgramStateRef State,\n                        const LocationContext *LCtx) {\n    return create<CXXDeallocatorCall>(E, State, LCtx);\n  }\n};\n\ntemplate <typename T>\nCallEventRef<T> CallEvent::cloneWithState(ProgramStateRef NewState) const {\n  assert(isa<T>(*this) && \"Cloning to unrelated type\");\n  static_assert(sizeof(T) == sizeof(CallEvent),\n                \"Subclasses may not add fields\");\n\n  if (NewState == State)\n    return cast<T>(this);\n\n  CallEventManager &Mgr = State->getStateManager().getCallEventManager();\n  T *Copy = static_cast<T *>(Mgr.allocate());\n  cloneTo(Copy);\n  assert(Copy->getKind() == this->getKind() && \"Bad copy\");\n\n  Copy->State = NewState;\n  return Copy;\n}\n\ninline void CallEvent::Release() const {\n  assert(RefCount > 0 && \"Reference count is already zero.\");\n  --RefCount;\n\n  if (RefCount > 0)\n    return;\n\n  CallEventManager &Mgr = State->getStateManager().getCallEventManager();\n  Mgr.reclaim(this);\n\n  this->~CallEvent();\n}\n\n} // namespace ento\n\n} // namespace clang\n\nnamespace llvm {\n\n// Support isa<>, cast<>, and dyn_cast<> for CallEventRef.\ntemplate<class T> struct simplify_type< clang::ento::CallEventRef<T>> {\n  using SimpleType = const T *;\n\n  static SimpleType\n  getSimplifiedValue(clang::ento::CallEventRef<T> Val) {\n    return Val.get();\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h", "content": "//===- ExplodedGraph.h - Local, Path-Sens. \"Exploded Graph\" -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the template classes ExplodedNode and ExplodedGraph,\n//  which represent a path-sensitive, intra-procedural \"exploded graph.\"\n//  See \"Precise interprocedural dataflow analysis via graph reachability\"\n//  by Reps, Horwitz, and Sagiv\n//  (http://portal.acm.org/citation.cfm?id=199462) for the definition of an\n//  exploded graph.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H\n\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Analysis/Support/BumpVector.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass CFG;\nclass Decl;\nclass Expr;\nclass ParentMap;\nclass Stmt;\n\nnamespace ento {\n\nclass ExplodedGraph;\n\n//===----------------------------------------------------------------------===//\n// ExplodedGraph \"implementation\" classes.  These classes are not typed to\n// contain a specific kind of state.  Typed-specialized versions are defined\n// on top of these classes.\n//===----------------------------------------------------------------------===//\n\n// ExplodedNode is not constified all over the engine because we need to add\n// successors to it at any time after creating it.\n\nclass ExplodedNode : public llvm::FoldingSetNode {\n  friend class BranchNodeBuilder;\n  friend class CoreEngine;\n  friend class EndOfFunctionNodeBuilder;\n  friend class ExplodedGraph;\n  friend class IndirectGotoNodeBuilder;\n  friend class NodeBuilder;\n  friend class SwitchNodeBuilder;\n\n  /// Efficiently stores a list of ExplodedNodes, or an optional flag.\n  ///\n  /// NodeGroup provides opaque storage for a list of ExplodedNodes, optimizing\n  /// for the case when there is only one node in the group. This is a fairly\n  /// common case in an ExplodedGraph, where most nodes have only one\n  /// predecessor and many have only one successor. It can also be used to\n  /// store a flag rather than a node list, which ExplodedNode uses to mark\n  /// whether a node is a sink. If the flag is set, the group is implicitly\n  /// empty and no nodes may be added.\n  class NodeGroup {\n    // Conceptually a discriminated union. If the low bit is set, the node is\n    // a sink. If the low bit is not set, the pointer refers to the storage\n    // for the nodes in the group.\n    // This is not a PointerIntPair in order to keep the storage type opaque.\n    uintptr_t P;\n\n  public:\n    NodeGroup(bool Flag = false) : P(Flag) {\n      assert(getFlag() == Flag);\n    }\n\n    ExplodedNode * const *begin() const;\n\n    ExplodedNode * const *end() const;\n\n    unsigned size() const;\n\n    bool empty() const { return P == 0 || getFlag() != 0; }\n\n    /// Adds a node to the list.\n    ///\n    /// The group must not have been created with its flag set.\n    void addNode(ExplodedNode *N, ExplodedGraph &G);\n\n    /// Replaces the single node in this group with a new node.\n    ///\n    /// Note that this should only be used when you know the group was not\n    /// created with its flag set, and that the group is empty or contains\n    /// only a single node.\n    void replaceNode(ExplodedNode *node);\n\n    /// Returns whether this group was created with its flag set.\n    bool getFlag() const {\n      return (P & 1);\n    }\n  };\n\n  /// Location - The program location (within a function body) associated\n  ///  with this node.\n  const ProgramPoint Location;\n\n  /// State - The state associated with this node.\n  ProgramStateRef State;\n\n  /// Preds - The predecessors of this node.\n  NodeGroup Preds;\n\n  /// Succs - The successors of this node.\n  NodeGroup Succs;\n\n  int64_t Id;\n\npublic:\n  explicit ExplodedNode(const ProgramPoint &loc, ProgramStateRef state,\n                        int64_t Id, bool IsSink)\n      : Location(loc), State(std::move(state)), Succs(IsSink), Id(Id) {\n    assert(isSink() == IsSink);\n  }\n\n  /// getLocation - Returns the edge associated with the given node.\n  ProgramPoint getLocation() const { return Location; }\n\n  const LocationContext *getLocationContext() const {\n    return getLocation().getLocationContext();\n  }\n\n  const StackFrameContext *getStackFrame() const {\n    return getLocation().getStackFrame();\n  }\n\n  const Decl &getCodeDecl() const { return *getLocationContext()->getDecl(); }\n\n  CFG &getCFG() const { return *getLocationContext()->getCFG(); }\n\n  const CFGBlock *getCFGBlock() const;\n\n  const ParentMap &getParentMap() const {\n    return getLocationContext()->getParentMap();\n  }\n\n  template <typename T>\n  T &getAnalysis() const {\n    return *getLocationContext()->getAnalysis<T>();\n  }\n\n  const ProgramStateRef &getState() const { return State; }\n\n  template <typename T>\n  Optional<T> getLocationAs() const LLVM_LVALUE_FUNCTION {\n    return Location.getAs<T>();\n  }\n\n  /// Get the value of an arbitrary expression at this node.\n  SVal getSVal(const Stmt *S) const {\n    return getState()->getSVal(S, getLocationContext());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ProgramPoint &Loc,\n                      const ProgramStateRef &state,\n                      bool IsSink) {\n    ID.Add(Loc);\n    ID.AddPointer(state.get());\n    ID.AddBoolean(IsSink);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    // We avoid copy constructors by not using accessors.\n    Profile(ID, Location, State, isSink());\n  }\n\n  /// addPredeccessor - Adds a predecessor to the current node, and\n  ///  in tandem add this node as a successor of the other node.\n  void addPredecessor(ExplodedNode *V, ExplodedGraph &G);\n\n  unsigned succ_size() const { return Succs.size(); }\n  unsigned pred_size() const { return Preds.size(); }\n  bool succ_empty() const { return Succs.empty(); }\n  bool pred_empty() const { return Preds.empty(); }\n\n  bool isSink() const { return Succs.getFlag(); }\n\n  bool hasSinglePred() const {\n    return (pred_size() == 1);\n  }\n\n  ExplodedNode *getFirstPred() {\n    return pred_empty() ? nullptr : *(pred_begin());\n  }\n\n  const ExplodedNode *getFirstPred() const {\n    return const_cast<ExplodedNode*>(this)->getFirstPred();\n  }\n\n  ExplodedNode *getFirstSucc() {\n    return succ_empty() ? nullptr : *(succ_begin());\n  }\n\n  const ExplodedNode *getFirstSucc() const {\n    return const_cast<ExplodedNode*>(this)->getFirstSucc();\n  }\n\n  // Iterators over successor and predecessor vertices.\n  using succ_iterator = ExplodedNode * const *;\n  using succ_range = llvm::iterator_range<succ_iterator>;\n\n  using const_succ_iterator = const ExplodedNode * const *;\n  using const_succ_range = llvm::iterator_range<const_succ_iterator>;\n\n  using pred_iterator = ExplodedNode * const *;\n  using pred_range = llvm::iterator_range<pred_iterator>;\n\n  using const_pred_iterator = const ExplodedNode * const *;\n  using const_pred_range = llvm::iterator_range<const_pred_iterator>;\n\n  pred_iterator pred_begin() { return Preds.begin(); }\n  pred_iterator pred_end() { return Preds.end(); }\n  pred_range preds() { return {Preds.begin(), Preds.end()}; }\n\n  const_pred_iterator pred_begin() const {\n    return const_cast<ExplodedNode*>(this)->pred_begin();\n  }\n  const_pred_iterator pred_end() const {\n    return const_cast<ExplodedNode*>(this)->pred_end();\n  }\n  const_pred_range preds() const { return {Preds.begin(), Preds.end()}; }\n\n  succ_iterator succ_begin() { return Succs.begin(); }\n  succ_iterator succ_end() { return Succs.end(); }\n  succ_range succs() { return {Succs.begin(), Succs.end()}; }\n\n  const_succ_iterator succ_begin() const {\n    return const_cast<ExplodedNode*>(this)->succ_begin();\n  }\n  const_succ_iterator succ_end() const {\n    return const_cast<ExplodedNode*>(this)->succ_end();\n  }\n  const_succ_range succs() const { return {Succs.begin(), Succs.end()}; }\n\n  int64_t getID() const { return Id; }\n\n  /// The node is trivial if it has only one successor, only one predecessor,\n  /// it's predecessor has only one successor,\n  /// and its program state is the same as the program state of the previous\n  /// node.\n  /// Trivial nodes may be skipped while printing exploded graph.\n  bool isTrivial() const;\n\n  /// If the node's program point corresponds to a statement, retrieve that\n  /// statement. Useful for figuring out where to put a warning or a note.\n  /// If the statement belongs to a body-farmed definition,\n  /// retrieve the call site for that definition.\n  const Stmt *getStmtForDiagnostics() const;\n\n  /// Find the next statement that was executed on this node's execution path.\n  /// Useful for explaining control flow that follows the current node.\n  /// If the statement belongs to a body-farmed definition, retrieve the\n  /// call site for that definition.\n  const Stmt *getNextStmtForDiagnostics() const;\n\n  /// Find the statement that was executed immediately before this node.\n  /// Useful when the node corresponds to a CFG block entrance.\n  /// If the statement belongs to a body-farmed definition, retrieve the\n  /// call site for that definition.\n  const Stmt *getPreviousStmtForDiagnostics() const;\n\n  /// Find the statement that was executed at or immediately before this node.\n  /// Useful when any nearby statement will do.\n  /// If the statement belongs to a body-farmed definition, retrieve the\n  /// call site for that definition.\n  const Stmt *getCurrentOrPreviousStmtForDiagnostics() const;\n\nprivate:\n  void replaceSuccessor(ExplodedNode *node) { Succs.replaceNode(node); }\n  void replacePredecessor(ExplodedNode *node) { Preds.replaceNode(node); }\n};\n\nusing InterExplodedGraphMap =\n    llvm::DenseMap<const ExplodedNode *, const ExplodedNode *>;\n\nclass ExplodedGraph {\nprotected:\n  friend class CoreEngine;\n\n  // Type definitions.\n  using NodeVector = std::vector<ExplodedNode *>;\n\n  /// The roots of the simulation graph. Usually there will be only\n  /// one, but clients are free to establish multiple subgraphs within a single\n  /// SimulGraph. Moreover, these subgraphs can often merge when paths from\n  /// different roots reach the same state at the same program location.\n  NodeVector Roots;\n\n  /// The nodes in the simulation graph which have been\n  /// specially marked as the endpoint of an abstract simulation path.\n  NodeVector EndNodes;\n\n  /// Nodes - The nodes in the graph.\n  llvm::FoldingSet<ExplodedNode> Nodes;\n\n  /// BVC - Allocator and context for allocating nodes and their predecessor\n  /// and successor groups.\n  BumpVectorContext BVC;\n\n  /// NumNodes - The number of nodes in the graph.\n  int64_t NumNodes = 0;\n\n  /// A list of recently allocated nodes that can potentially be recycled.\n  NodeVector ChangedNodes;\n\n  /// A list of nodes that can be reused.\n  NodeVector FreeNodes;\n\n  /// Determines how often nodes are reclaimed.\n  ///\n  /// If this is 0, nodes will never be reclaimed.\n  unsigned ReclaimNodeInterval = 0;\n\n  /// Counter to determine when to reclaim nodes.\n  unsigned ReclaimCounter;\n\npublic:\n  ExplodedGraph();\n  ~ExplodedGraph();\n\n  /// Retrieve the node associated with a (Location,State) pair,\n  ///  where the 'Location' is a ProgramPoint in the CFG.  If no node for\n  ///  this pair exists, it is created. IsNew is set to true if\n  ///  the node was freshly created.\n  ExplodedNode *getNode(const ProgramPoint &L, ProgramStateRef State,\n                        bool IsSink = false,\n                        bool* IsNew = nullptr);\n\n  /// Create a node for a (Location, State) pair,\n  ///  but don't store it for deduplication later.  This\n  ///  is useful when copying an already completed\n  ///  ExplodedGraph for further processing.\n  ExplodedNode *createUncachedNode(const ProgramPoint &L,\n    ProgramStateRef State,\n    int64_t Id,\n    bool IsSink = false);\n\n  std::unique_ptr<ExplodedGraph> MakeEmptyGraph() const {\n    return std::make_unique<ExplodedGraph>();\n  }\n\n  /// addRoot - Add an untyped node to the set of roots.\n  ExplodedNode *addRoot(ExplodedNode *V) {\n    Roots.push_back(V);\n    return V;\n  }\n\n  /// addEndOfPath - Add an untyped node to the set of EOP nodes.\n  ExplodedNode *addEndOfPath(ExplodedNode *V) {\n    EndNodes.push_back(V);\n    return V;\n  }\n\n  unsigned num_roots() const { return Roots.size(); }\n  unsigned num_eops() const { return EndNodes.size(); }\n\n  bool empty() const { return NumNodes == 0; }\n  unsigned size() const { return NumNodes; }\n\n  void reserve(unsigned NodeCount) { Nodes.reserve(NodeCount); }\n\n  // Iterators.\n  using NodeTy = ExplodedNode;\n  using AllNodesTy = llvm::FoldingSet<ExplodedNode>;\n  using roots_iterator = NodeVector::iterator;\n  using const_roots_iterator = NodeVector::const_iterator;\n  using eop_iterator = NodeVector::iterator;\n  using const_eop_iterator = NodeVector::const_iterator;\n  using node_iterator = AllNodesTy::iterator;\n  using const_node_iterator = AllNodesTy::const_iterator;\n\n  node_iterator nodes_begin() { return Nodes.begin(); }\n\n  node_iterator nodes_end() { return Nodes.end(); }\n\n  const_node_iterator nodes_begin() const { return Nodes.begin(); }\n\n  const_node_iterator nodes_end() const { return Nodes.end(); }\n\n  roots_iterator roots_begin() { return Roots.begin(); }\n\n  roots_iterator roots_end() { return Roots.end(); }\n\n  const_roots_iterator roots_begin() const { return Roots.begin(); }\n\n  const_roots_iterator roots_end() const { return Roots.end(); }\n\n  eop_iterator eop_begin() { return EndNodes.begin(); }\n\n  eop_iterator eop_end() { return EndNodes.end(); }\n\n  const_eop_iterator eop_begin() const { return EndNodes.begin(); }\n\n  const_eop_iterator eop_end() const { return EndNodes.end(); }\n\n  llvm::BumpPtrAllocator & getAllocator() { return BVC.getAllocator(); }\n  BumpVectorContext &getNodeAllocator() { return BVC; }\n\n  using NodeMap = llvm::DenseMap<const ExplodedNode *, ExplodedNode *>;\n\n  /// Creates a trimmed version of the graph that only contains paths leading\n  /// to the given nodes.\n  ///\n  /// \\param Nodes The nodes which must appear in the final graph. Presumably\n  ///              these are end-of-path nodes (i.e. they have no successors).\n  /// \\param[out] ForwardMap A optional map from nodes in this graph to nodes in\n  ///                        the returned graph.\n  /// \\param[out] InverseMap An optional map from nodes in the returned graph to\n  ///                        nodes in this graph.\n  /// \\returns The trimmed graph\n  std::unique_ptr<ExplodedGraph>\n  trim(ArrayRef<const NodeTy *> Nodes,\n       InterExplodedGraphMap *ForwardMap = nullptr,\n       InterExplodedGraphMap *InverseMap = nullptr) const;\n\n  /// Enable tracking of recently allocated nodes for potential reclamation\n  /// when calling reclaimRecentlyAllocatedNodes().\n  void enableNodeReclamation(unsigned Interval) {\n    ReclaimCounter = ReclaimNodeInterval = Interval;\n  }\n\n  /// Reclaim \"uninteresting\" nodes created since the last time this method\n  /// was called.\n  void reclaimRecentlyAllocatedNodes();\n\n  /// Returns true if nodes for the given expression kind are always\n  ///        kept around.\n  static bool isInterestingLValueExpr(const Expr *Ex);\n\nprivate:\n  bool shouldCollect(const ExplodedNode *node);\n  void collectNode(ExplodedNode *node);\n};\n\nclass ExplodedNodeSet {\n  using ImplTy = llvm::SmallSetVector<ExplodedNode *, 4>;\n  ImplTy Impl;\n\npublic:\n  ExplodedNodeSet(ExplodedNode *N) {\n    assert(N && !static_cast<ExplodedNode*>(N)->isSink());\n    Impl.insert(N);\n  }\n\n  ExplodedNodeSet() = default;\n\n  void Add(ExplodedNode *N) {\n    if (N && !static_cast<ExplodedNode*>(N)->isSink()) Impl.insert(N);\n  }\n\n  using iterator = ImplTy::iterator;\n  using const_iterator = ImplTy::const_iterator;\n\n  unsigned size() const { return Impl.size();  }\n  bool empty()    const { return Impl.empty(); }\n  bool erase(ExplodedNode *N) { return Impl.remove(N); }\n\n  void clear() { Impl.clear(); }\n\n  void insert(const ExplodedNodeSet &S) {\n    assert(&S != this);\n    if (empty())\n      Impl = S.Impl;\n    else\n      Impl.insert(S.begin(), S.end());\n  }\n\n  iterator begin() { return Impl.begin(); }\n  iterator end() { return Impl.end(); }\n\n  const_iterator begin() const { return Impl.begin(); }\n  const_iterator end() const { return Impl.end(); }\n};\n\n} // namespace ento\n\n} // namespace clang\n\n// GraphTraits\n\nnamespace llvm {\n  template <> struct GraphTraits<clang::ento::ExplodedGraph *> {\n    using GraphTy = clang::ento::ExplodedGraph *;\n    using NodeRef = clang::ento::ExplodedNode *;\n    using ChildIteratorType = clang::ento::ExplodedNode::succ_iterator;\n    using nodes_iterator = llvm::df_iterator<GraphTy>;\n\n    static NodeRef getEntryNode(const GraphTy G) {\n      return *G->roots_begin();\n    }\n\n    static bool predecessorOfTrivial(NodeRef N) {\n      return N->succ_size() == 1 && N->getFirstSucc()->isTrivial();\n    }\n\n    static ChildIteratorType child_begin(NodeRef N) {\n      if (predecessorOfTrivial(N))\n        return child_begin(*N->succ_begin());\n      return N->succ_begin();\n    }\n\n    static ChildIteratorType child_end(NodeRef N) {\n      if (predecessorOfTrivial(N))\n        return child_end(N->getFirstSucc());\n      return N->succ_end();\n    }\n\n    static nodes_iterator nodes_begin(const GraphTy G) {\n      return df_begin(G);\n    }\n\n    static nodes_iterator nodes_end(const GraphTy G) {\n      return df_end(G);\n    }\n  };\n} // namespace llvm\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h", "content": "//===- ExprEngine.h - Path-Sensitive Expression-Level Dataflow --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines a meta-engine for path-sensitive dataflow analysis that\n//  is built on CoreEngine, but provides the boilerplate to execute transfer\n//  functions and build the ExplodedGraph at the expression level.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPRENGINE_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPRENGINE_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"clang/Analysis/DomainSpecific/ObjCNoReturn.h\"\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/AnalysisManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/FunctionSummary.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/Store.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/WorkList.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include <cassert>\n#include <utility>\n\nnamespace clang {\n\nclass AnalysisDeclContextManager;\nclass AnalyzerOptions;\nclass ASTContext;\nclass CFGBlock;\nclass CFGElement;\nclass ConstructionContext;\nclass CXXBindTemporaryExpr;\nclass CXXCatchStmt;\nclass CXXConstructExpr;\nclass CXXDeleteExpr;\nclass CXXNewExpr;\nclass CXXThisExpr;\nclass Decl;\nclass DeclStmt;\nclass GCCAsmStmt;\nclass LambdaExpr;\nclass LocationContext;\nclass MaterializeTemporaryExpr;\nclass MSAsmStmt;\nclass NamedDecl;\nclass ObjCAtSynchronizedStmt;\nclass ObjCForCollectionStmt;\nclass ObjCIvarRefExpr;\nclass ObjCMessageExpr;\nclass ReturnStmt;\nclass Stmt;\n\nnamespace cross_tu {\n\nclass CrossTranslationUnitContext;\n\n} // namespace cross_tu\n\nnamespace ento {\n\nclass AnalysisManager;\nclass BasicValueFactory;\nclass BlockCounter;\nclass BranchNodeBuilder;\nclass CallEvent;\nclass CheckerManager;\nclass ConstraintManager;\nclass CXXTempObjectRegion;\nclass EndOfFunctionNodeBuilder;\nclass ExplodedNodeSet;\nclass ExplodedNode;\nclass IndirectGotoNodeBuilder;\nclass MemRegion;\nstruct NodeBuilderContext;\nclass NodeBuilderWithSinks;\nclass ProgramState;\nclass ProgramStateManager;\nclass RegionAndSymbolInvalidationTraits;\nclass SymbolManager;\nclass SwitchNodeBuilder;\n\n/// Hints for figuring out of a call should be inlined during evalCall().\nstruct EvalCallOptions {\n  /// This call is a constructor or a destructor for which we do not currently\n  /// compute the this-region correctly.\n  bool IsCtorOrDtorWithImproperlyModeledTargetRegion = false;\n\n  /// This call is a constructor or a destructor for a single element within\n  /// an array, a part of array construction or destruction.\n  bool IsArrayCtorOrDtor = false;\n\n  /// This call is a constructor or a destructor of a temporary value.\n  bool IsTemporaryCtorOrDtor = false;\n\n  /// This call is a constructor for a temporary that is lifetime-extended\n  /// by binding it to a reference-type field within an aggregate,\n  /// for example 'A { const C &c; }; A a = { C() };'\n  bool IsTemporaryLifetimeExtendedViaAggregate = false;\n\n  /// This call is a pre-C++17 elidable constructor that we failed to elide\n  /// because we failed to compute the target region into which\n  /// this constructor would have been ultimately elided. Analysis that\n  /// we perform in this case is still correct but it behaves differently,\n  /// as if copy elision is disabled.\n  bool IsElidableCtorThatHasNotBeenElided = false;\n\n  EvalCallOptions() {}\n};\n\nclass ExprEngine {\n  void anchor();\n\npublic:\n  /// The modes of inlining, which override the default analysis-wide settings.\n  enum InliningModes {\n    /// Follow the default settings for inlining callees.\n    Inline_Regular = 0,\n\n    /// Do minimal inlining of callees.\n    Inline_Minimal = 0x1\n  };\n\nprivate:\n  cross_tu::CrossTranslationUnitContext &CTU;\n\n  AnalysisManager &AMgr;\n\n  AnalysisDeclContextManager &AnalysisDeclContexts;\n\n  CoreEngine Engine;\n\n  /// G - the simulation graph.\n  ExplodedGraph &G;\n\n  /// StateMgr - Object that manages the data for all created states.\n  ProgramStateManager StateMgr;\n\n  /// SymMgr - Object that manages the symbol information.\n  SymbolManager &SymMgr;\n\n  /// MRMgr - MemRegionManager object that creates memory regions.\n  MemRegionManager &MRMgr;\n\n  /// svalBuilder - SValBuilder object that creates SVals from expressions.\n  SValBuilder &svalBuilder;\n\n  unsigned int currStmtIdx = 0;\n  const NodeBuilderContext *currBldrCtx = nullptr;\n\n  /// Helper object to determine if an Objective-C message expression\n  /// implicitly never returns.\n  ObjCNoReturn ObjCNoRet;\n\n  /// The BugReporter associated with this engine.  It is important that\n  /// this object be placed at the very end of member variables so that its\n  /// destructor is called before the rest of the ExprEngine is destroyed.\n  PathSensitiveBugReporter BR;\n\n  /// The functions which have been analyzed through inlining. This is owned by\n  /// AnalysisConsumer. It can be null.\n  SetOfConstDecls *VisitedCallees;\n\n  /// The flag, which specifies the mode of inlining for the engine.\n  InliningModes HowToInline;\n\npublic:\n  ExprEngine(cross_tu::CrossTranslationUnitContext &CTU, AnalysisManager &mgr,\n             SetOfConstDecls *VisitedCalleesIn,\n             FunctionSummariesTy *FS, InliningModes HowToInlineIn);\n\n  virtual ~ExprEngine() = default;\n\n  /// Returns true if there is still simulation state on the worklist.\n  bool ExecuteWorkList(const LocationContext *L, unsigned Steps = 150000) {\n    return Engine.ExecuteWorkList(L, Steps, nullptr);\n  }\n\n  /// Execute the work list with an initial state. Nodes that reaches the exit\n  /// of the function are added into the Dst set, which represent the exit\n  /// state of the function call. Returns true if there is still simulation\n  /// state on the worklist.\n  bool ExecuteWorkListWithInitialState(const LocationContext *L, unsigned Steps,\n                                       ProgramStateRef InitState,\n                                       ExplodedNodeSet &Dst) {\n    return Engine.ExecuteWorkListWithInitialState(L, Steps, InitState, Dst);\n  }\n\n  /// getContext - Return the ASTContext associated with this analysis.\n  ASTContext &getContext() const { return AMgr.getASTContext(); }\n\n  AnalysisManager &getAnalysisManager() { return AMgr; }\n\n  AnalysisDeclContextManager &getAnalysisDeclContextManager() {\n    return AMgr.getAnalysisDeclContextManager();\n  }\n\n  CheckerManager &getCheckerManager() const {\n    return *AMgr.getCheckerManager();\n  }\n\n  SValBuilder &getSValBuilder() { return svalBuilder; }\n\n  BugReporter &getBugReporter() { return BR; }\n\n  cross_tu::CrossTranslationUnitContext *\n  getCrossTranslationUnitContext() {\n    return &CTU;\n  }\n\n  const NodeBuilderContext &getBuilderContext() {\n    assert(currBldrCtx);\n    return *currBldrCtx;\n  }\n\n  const Stmt *getStmt() const;\n\n  void GenerateAutoTransition(ExplodedNode *N);\n  void enqueueEndOfPath(ExplodedNodeSet &S);\n  void GenerateCallExitNode(ExplodedNode *N);\n\n\n  /// Dump graph to the specified filename.\n  /// If filename is empty, generate a temporary one.\n  /// \\return The filename the graph is written into.\n  std::string DumpGraph(bool trim = false, StringRef Filename=\"\");\n\n  /// Dump the graph consisting of the given nodes to a specified filename.\n  /// Generate a temporary filename if it's not provided.\n  /// \\return The filename the graph is written into.\n  std::string DumpGraph(ArrayRef<const ExplodedNode *> Nodes,\n                        StringRef Filename = \"\");\n\n  /// Visualize the ExplodedGraph created by executing the simulation.\n  void ViewGraph(bool trim = false);\n\n  /// Visualize a trimmed ExplodedGraph that only contains paths to the given\n  /// nodes.\n  void ViewGraph(ArrayRef<const ExplodedNode *> Nodes);\n\n  /// getInitialState - Return the initial state used for the root vertex\n  ///  in the ExplodedGraph.\n  ProgramStateRef getInitialState(const LocationContext *InitLoc);\n\n  ExplodedGraph &getGraph() { return G; }\n  const ExplodedGraph &getGraph() const { return G; }\n\n  /// Run the analyzer's garbage collection - remove dead symbols and\n  /// bindings from the state.\n  ///\n  /// Checkers can participate in this process with two callbacks:\n  /// \\c checkLiveSymbols and \\c checkDeadSymbols. See the CheckerDocumentation\n  /// class for more information.\n  ///\n  /// \\param Node The predecessor node, from which the processing should start.\n  /// \\param Out The returned set of output nodes.\n  /// \\param ReferenceStmt The statement which is about to be processed.\n  ///        Everything needed for this statement should be considered live.\n  ///        A null statement means that everything in child LocationContexts\n  ///        is dead.\n  /// \\param LC The location context of the \\p ReferenceStmt. A null location\n  ///        context means that we have reached the end of analysis and that\n  ///        all statements and local variables should be considered dead.\n  /// \\param DiagnosticStmt Used as a location for any warnings that should\n  ///        occur while removing the dead (e.g. leaks). By default, the\n  ///        \\p ReferenceStmt is used.\n  /// \\param K Denotes whether this is a pre- or post-statement purge. This\n  ///        must only be ProgramPoint::PostStmtPurgeDeadSymbolsKind if an\n  ///        entire location context is being cleared, in which case the\n  ///        \\p ReferenceStmt must either be a ReturnStmt or \\c NULL. Otherwise,\n  ///        it must be ProgramPoint::PreStmtPurgeDeadSymbolsKind (the default)\n  ///        and \\p ReferenceStmt must be valid (non-null).\n  void removeDead(ExplodedNode *Node, ExplodedNodeSet &Out,\n            const Stmt *ReferenceStmt, const LocationContext *LC,\n            const Stmt *DiagnosticStmt = nullptr,\n            ProgramPoint::Kind K = ProgramPoint::PreStmtPurgeDeadSymbolsKind);\n\n  /// processCFGElement - Called by CoreEngine. Used to generate new successor\n  ///  nodes by processing the 'effects' of a CFG element.\n  void processCFGElement(const CFGElement E, ExplodedNode *Pred,\n                         unsigned StmtIdx, NodeBuilderContext *Ctx);\n\n  void ProcessStmt(const Stmt *S, ExplodedNode *Pred);\n\n  void ProcessLoopExit(const Stmt* S, ExplodedNode *Pred);\n\n  void ProcessInitializer(const CFGInitializer I, ExplodedNode *Pred);\n\n  void ProcessImplicitDtor(const CFGImplicitDtor D, ExplodedNode *Pred);\n\n  void ProcessNewAllocator(const CXXNewExpr *NE, ExplodedNode *Pred);\n\n  void ProcessAutomaticObjDtor(const CFGAutomaticObjDtor D,\n                               ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessDeleteDtor(const CFGDeleteDtor D,\n                         ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessBaseDtor(const CFGBaseDtor D,\n                       ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessMemberDtor(const CFGMemberDtor D,\n                         ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessTemporaryDtor(const CFGTemporaryDtor D,\n                            ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// Called by CoreEngine when processing the entrance of a CFGBlock.\n  void processCFGBlockEntrance(const BlockEdge &L,\n                               NodeBuilderWithSinks &nodeBuilder,\n                               ExplodedNode *Pred);\n\n  /// ProcessBranch - Called by CoreEngine.  Used to generate successor\n  ///  nodes by processing the 'effects' of a branch condition.\n  void processBranch(const Stmt *Condition,\n                     NodeBuilderContext& BuilderCtx,\n                     ExplodedNode *Pred,\n                     ExplodedNodeSet &Dst,\n                     const CFGBlock *DstT,\n                     const CFGBlock *DstF);\n\n  /// Called by CoreEngine.\n  /// Used to generate successor nodes for temporary destructors depending\n  /// on whether the corresponding constructor was visited.\n  void processCleanupTemporaryBranch(const CXXBindTemporaryExpr *BTE,\n                                     NodeBuilderContext &BldCtx,\n                                     ExplodedNode *Pred, ExplodedNodeSet &Dst,\n                                     const CFGBlock *DstT,\n                                     const CFGBlock *DstF);\n\n  /// Called by CoreEngine.  Used to processing branching behavior\n  /// at static initializers.\n  void processStaticInitializer(const DeclStmt *DS,\n                                NodeBuilderContext& BuilderCtx,\n                                ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst,\n                                const CFGBlock *DstT,\n                                const CFGBlock *DstF);\n\n  /// processIndirectGoto - Called by CoreEngine.  Used to generate successor\n  ///  nodes by processing the 'effects' of a computed goto jump.\n  void processIndirectGoto(IndirectGotoNodeBuilder& builder);\n\n  /// ProcessSwitch - Called by CoreEngine.  Used to generate successor\n  ///  nodes by processing the 'effects' of a switch statement.\n  void processSwitch(SwitchNodeBuilder& builder);\n\n  /// Called by CoreEngine.  Used to notify checkers that processing a\n  /// function has begun. Called for both inlined and and top-level functions.\n  void processBeginOfFunction(NodeBuilderContext &BC,\n                              ExplodedNode *Pred, ExplodedNodeSet &Dst,\n                              const BlockEdge &L);\n\n  /// Called by CoreEngine.  Used to notify checkers that processing a\n  /// function has ended. Called for both inlined and and top-level functions.\n  void processEndOfFunction(NodeBuilderContext& BC,\n                            ExplodedNode *Pred,\n                            const ReturnStmt *RS = nullptr);\n\n  /// Remove dead bindings/symbols before exiting a function.\n  void removeDeadOnEndOfFunction(NodeBuilderContext& BC,\n                                 ExplodedNode *Pred,\n                                 ExplodedNodeSet &Dst);\n\n  /// Generate the entry node of the callee.\n  void processCallEnter(NodeBuilderContext& BC, CallEnter CE,\n                        ExplodedNode *Pred);\n\n  /// Generate the sequence of nodes that simulate the call exit and the post\n  /// visit for CallExpr.\n  void processCallExit(ExplodedNode *Pred);\n\n  /// Called by CoreEngine when the analysis worklist has terminated.\n  void processEndWorklist();\n\n  /// evalAssume - Callback function invoked by the ConstraintManager when\n  ///  making assumptions about state values.\n  ProgramStateRef processAssume(ProgramStateRef state, SVal cond,\n                                bool assumption);\n\n  /// processRegionChanges - Called by ProgramStateManager whenever a change is made\n  ///  to the store. Used to update checkers that track region values.\n  ProgramStateRef\n  processRegionChanges(ProgramStateRef state,\n                       const InvalidatedSymbols *invalidated,\n                       ArrayRef<const MemRegion *> ExplicitRegions,\n                       ArrayRef<const MemRegion *> Regions,\n                       const LocationContext *LCtx,\n                       const CallEvent *Call);\n\n  inline ProgramStateRef\n  processRegionChange(ProgramStateRef state,\n                      const MemRegion* MR,\n                      const LocationContext *LCtx) {\n    return processRegionChanges(state, nullptr, MR, MR, LCtx, nullptr);\n  }\n\n  /// printJson - Called by ProgramStateManager to print checker-specific data.\n  void printJson(raw_ostream &Out, ProgramStateRef State,\n                 const LocationContext *LCtx, const char *NL,\n                 unsigned int Space, bool IsDot) const;\n\n  ProgramStateManager &getStateManager() { return StateMgr; }\n\n  StoreManager &getStoreManager() { return StateMgr.getStoreManager(); }\n\n  ConstraintManager &getConstraintManager() {\n    return StateMgr.getConstraintManager();\n  }\n\n  // FIXME: Remove when we migrate over to just using SValBuilder.\n  BasicValueFactory &getBasicVals() {\n    return StateMgr.getBasicVals();\n  }\n\n  SymbolManager &getSymbolManager() { return SymMgr; }\n  MemRegionManager &getRegionManager() { return MRMgr; }\n\n  NoteTag::Factory &getNoteTags() { return Engine.getNoteTags(); }\n\n\n  // Functions for external checking of whether we have unfinished work\n  bool wasBlocksExhausted() const { return Engine.wasBlocksExhausted(); }\n  bool hasEmptyWorkList() const { return !Engine.getWorkList()->hasWork(); }\n  bool hasWorkRemaining() const { return Engine.hasWorkRemaining(); }\n\n  const CoreEngine &getCoreEngine() const { return Engine; }\n\npublic:\n  /// Visit - Transfer function logic for all statements.  Dispatches to\n  ///  other functions that handle specific kinds of statements.\n  void Visit(const Stmt *S, ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// VisitArraySubscriptExpr - Transfer function for array accesses.\n  void VisitArraySubscriptExpr(const ArraySubscriptExpr *Ex,\n                               ExplodedNode *Pred,\n                               ExplodedNodeSet &Dst);\n\n  /// VisitGCCAsmStmt - Transfer function logic for inline asm.\n  void VisitGCCAsmStmt(const GCCAsmStmt *A, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitMSAsmStmt - Transfer function logic for MS inline asm.\n  void VisitMSAsmStmt(const MSAsmStmt *A, ExplodedNode *Pred,\n                      ExplodedNodeSet &Dst);\n\n  /// VisitBlockExpr - Transfer function logic for BlockExprs.\n  void VisitBlockExpr(const BlockExpr *BE, ExplodedNode *Pred,\n                      ExplodedNodeSet &Dst);\n\n  /// VisitLambdaExpr - Transfer function logic for LambdaExprs.\n  void VisitLambdaExpr(const LambdaExpr *LE, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitBinaryOperator - Transfer function logic for binary operators.\n  void VisitBinaryOperator(const BinaryOperator* B, ExplodedNode *Pred,\n                           ExplodedNodeSet &Dst);\n\n\n  /// VisitCall - Transfer function for function calls.\n  void VisitCallExpr(const CallExpr *CE, ExplodedNode *Pred,\n                     ExplodedNodeSet &Dst);\n\n  /// VisitCast - Transfer function logic for all casts (implicit and explicit).\n  void VisitCast(const CastExpr *CastE, const Expr *Ex, ExplodedNode *Pred,\n                 ExplodedNodeSet &Dst);\n\n  /// VisitCompoundLiteralExpr - Transfer function logic for compound literals.\n  void VisitCompoundLiteralExpr(const CompoundLiteralExpr *CL,\n                                ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// Transfer function logic for DeclRefExprs and BlockDeclRefExprs.\n  void VisitCommonDeclRefExpr(const Expr *DR, const NamedDecl *D,\n                              ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// VisitDeclStmt - Transfer function logic for DeclStmts.\n  void VisitDeclStmt(const DeclStmt *DS, ExplodedNode *Pred,\n                     ExplodedNodeSet &Dst);\n\n  /// VisitGuardedExpr - Transfer function logic for ?, __builtin_choose\n  void VisitGuardedExpr(const Expr *Ex, const Expr *L, const Expr *R,\n                        ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  void VisitInitListExpr(const InitListExpr *E, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\n  /// VisitLogicalExpr - Transfer function logic for '&&', '||'\n  void VisitLogicalExpr(const BinaryOperator* B, ExplodedNode *Pred,\n                        ExplodedNodeSet &Dst);\n\n  /// VisitMemberExpr - Transfer function for member expressions.\n  void VisitMemberExpr(const MemberExpr *M, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitAtomicExpr - Transfer function for builtin atomic expressions\n  void VisitAtomicExpr(const AtomicExpr *E, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// Transfer function logic for ObjCAtSynchronizedStmts.\n  void VisitObjCAtSynchronizedStmt(const ObjCAtSynchronizedStmt *S,\n                                   ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// Transfer function logic for computing the lvalue of an Objective-C ivar.\n  void VisitLvalObjCIvarRefExpr(const ObjCIvarRefExpr *DR, ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst);\n\n  /// VisitObjCForCollectionStmt - Transfer function logic for\n  ///  ObjCForCollectionStmt.\n  void VisitObjCForCollectionStmt(const ObjCForCollectionStmt *S,\n                                  ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  void VisitObjCMessage(const ObjCMessageExpr *ME, ExplodedNode *Pred,\n                        ExplodedNodeSet &Dst);\n\n  /// VisitReturnStmt - Transfer function logic for return statements.\n  void VisitReturnStmt(const ReturnStmt *R, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitOffsetOfExpr - Transfer function for offsetof.\n  void VisitOffsetOfExpr(const OffsetOfExpr *Ex, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\n  /// VisitUnaryExprOrTypeTraitExpr - Transfer function for sizeof.\n  void VisitUnaryExprOrTypeTraitExpr(const UnaryExprOrTypeTraitExpr *Ex,\n                                     ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// VisitUnaryOperator - Transfer function logic for unary operators.\n  void VisitUnaryOperator(const UnaryOperator* B, ExplodedNode *Pred,\n                          ExplodedNodeSet &Dst);\n\n  /// Handle ++ and -- (both pre- and post-increment).\n  void VisitIncrementDecrementOperator(const UnaryOperator* U,\n                                       ExplodedNode *Pred,\n                                       ExplodedNodeSet &Dst);\n\n  void VisitCXXBindTemporaryExpr(const CXXBindTemporaryExpr *BTE,\n                                 ExplodedNodeSet &PreVisit,\n                                 ExplodedNodeSet &Dst);\n\n  void VisitCXXCatchStmt(const CXXCatchStmt *CS, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\n  void VisitCXXThisExpr(const CXXThisExpr *TE, ExplodedNode *Pred,\n                        ExplodedNodeSet & Dst);\n\n  void VisitCXXConstructExpr(const CXXConstructExpr *E, ExplodedNode *Pred,\n                             ExplodedNodeSet &Dst);\n\n  void VisitCXXInheritedCtorInitExpr(const CXXInheritedCtorInitExpr *E,\n                                     ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  void VisitCXXDestructor(QualType ObjectType, const MemRegion *Dest,\n                          const Stmt *S, bool IsBaseDtor,\n                          ExplodedNode *Pred, ExplodedNodeSet &Dst,\n                          EvalCallOptions &Options);\n\n  void VisitCXXNewAllocatorCall(const CXXNewExpr *CNE,\n                                ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst);\n\n  void VisitCXXNewExpr(const CXXNewExpr *CNE, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  void VisitCXXDeleteExpr(const CXXDeleteExpr *CDE, ExplodedNode *Pred,\n                          ExplodedNodeSet &Dst);\n\n  /// Create a C++ temporary object for an rvalue.\n  void CreateCXXTemporaryObject(const MaterializeTemporaryExpr *ME,\n                                ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst);\n\n  /// evalEagerlyAssumeBinOpBifurcation - Given the nodes in 'Src', eagerly assume symbolic\n  ///  expressions of the form 'x != 0' and generate new nodes (stored in Dst)\n  ///  with those assumptions.\n  void evalEagerlyAssumeBinOpBifurcation(ExplodedNodeSet &Dst, ExplodedNodeSet &Src,\n                         const Expr *Ex);\n\n  static std::pair<const ProgramPointTag *, const ProgramPointTag *>\n    geteagerlyAssumeBinOpBifurcationTags();\n\n  SVal evalMinus(SVal X) {\n    return X.isValid() ? svalBuilder.evalMinus(X.castAs<NonLoc>()) : X;\n  }\n\n  SVal evalComplement(SVal X) {\n    return X.isValid() ? svalBuilder.evalComplement(X.castAs<NonLoc>()) : X;\n  }\n\n  ProgramStateRef handleLValueBitCast(ProgramStateRef state, const Expr *Ex,\n                                      const LocationContext *LCtx, QualType T,\n                                      QualType ExTy, const CastExpr *CastE,\n                                      StmtNodeBuilder &Bldr,\n                                      ExplodedNode *Pred);\n\n  ProgramStateRef handleLVectorSplat(ProgramStateRef state,\n                                     const LocationContext *LCtx,\n                                     const CastExpr *CastE,\n                                     StmtNodeBuilder &Bldr,\n                                     ExplodedNode *Pred);\n\n  void handleUOExtension(ExplodedNodeSet::iterator I,\n                         const UnaryOperator* U,\n                         StmtNodeBuilder &Bldr);\n\npublic:\n  SVal evalBinOp(ProgramStateRef state, BinaryOperator::Opcode op,\n                 NonLoc L, NonLoc R, QualType T) {\n    return svalBuilder.evalBinOpNN(state, op, L, R, T);\n  }\n\n  SVal evalBinOp(ProgramStateRef state, BinaryOperator::Opcode op,\n                 NonLoc L, SVal R, QualType T) {\n    return R.isValid() ? svalBuilder.evalBinOpNN(state, op, L,\n                                                 R.castAs<NonLoc>(), T) : R;\n  }\n\n  SVal evalBinOp(ProgramStateRef ST, BinaryOperator::Opcode Op,\n                 SVal LHS, SVal RHS, QualType T) {\n    return svalBuilder.evalBinOp(ST, Op, LHS, RHS, T);\n  }\n\n  /// By looking at a certain item that may be potentially part of an object's\n  /// ConstructionContext, retrieve such object's location. A particular\n  /// statement can be transparently passed as \\p Item in most cases.\n  static Optional<SVal>\n  getObjectUnderConstruction(ProgramStateRef State,\n                             const ConstructionContextItem &Item,\n                             const LocationContext *LC);\n\n  /// Call PointerEscape callback when a value escapes as a result of bind.\n  ProgramStateRef processPointerEscapedOnBind(\n      ProgramStateRef State, ArrayRef<std::pair<SVal, SVal>> LocAndVals,\n      const LocationContext *LCtx, PointerEscapeKind Kind,\n      const CallEvent *Call);\n\n  /// Call PointerEscape callback when a value escapes as a result of\n  /// region invalidation.\n  /// \\param[in] ITraits Specifies invalidation traits for regions/symbols.\n  ProgramStateRef notifyCheckersOfPointerEscape(\n                           ProgramStateRef State,\n                           const InvalidatedSymbols *Invalidated,\n                           ArrayRef<const MemRegion *> ExplicitRegions,\n                           const CallEvent *Call,\n                           RegionAndSymbolInvalidationTraits &ITraits);\n\nprivate:\n  /// evalBind - Handle the semantics of binding a value to a specific location.\n  ///  This method is used by evalStore, VisitDeclStmt, and others.\n  void evalBind(ExplodedNodeSet &Dst, const Stmt *StoreE, ExplodedNode *Pred,\n                SVal location, SVal Val, bool atDeclInit = false,\n                const ProgramPoint *PP = nullptr);\n\n  ProgramStateRef\n  processPointerEscapedOnBind(ProgramStateRef State,\n                              SVal Loc, SVal Val,\n                              const LocationContext *LCtx);\n\n  /// A simple wrapper when you only need to notify checkers of pointer-escape\n  /// of some values.\n  ProgramStateRef escapeValues(ProgramStateRef State, ArrayRef<SVal> Vs,\n                               PointerEscapeKind K,\n                               const CallEvent *Call = nullptr) const;\n\npublic:\n  // FIXME: 'tag' should be removed, and a LocationContext should be used\n  // instead.\n  // FIXME: Comment on the meaning of the arguments, when 'St' may not\n  // be the same as Pred->state, and when 'location' may not be the\n  // same as state->getLValue(Ex).\n  /// Simulate a read of the result of Ex.\n  void evalLoad(ExplodedNodeSet &Dst,\n                const Expr *NodeEx,  /* Eventually will be a CFGStmt */\n                const Expr *BoundExpr,\n                ExplodedNode *Pred,\n                ProgramStateRef St,\n                SVal location,\n                const ProgramPointTag *tag = nullptr,\n                QualType LoadTy = QualType());\n\n  // FIXME: 'tag' should be removed, and a LocationContext should be used\n  // instead.\n  void evalStore(ExplodedNodeSet &Dst, const Expr *AssignE, const Expr *StoreE,\n                 ExplodedNode *Pred, ProgramStateRef St, SVal TargetLV, SVal Val,\n                 const ProgramPointTag *tag = nullptr);\n\n  /// Return the CFG element corresponding to the worklist element\n  /// that is currently being processed by ExprEngine.\n  CFGElement getCurrentCFGElement() {\n    return (*currBldrCtx->getBlock())[currStmtIdx];\n  }\n\n  /// Create a new state in which the call return value is binded to the\n  /// call origin expression.\n  ProgramStateRef bindReturnValue(const CallEvent &Call,\n                                  const LocationContext *LCtx,\n                                  ProgramStateRef State);\n\n  /// Evaluate a call, running pre- and post-call checkers and allowing checkers\n  /// to be responsible for handling the evaluation of the call itself.\n  void evalCall(ExplodedNodeSet &Dst, ExplodedNode *Pred,\n                const CallEvent &Call);\n\n  /// Default implementation of call evaluation.\n  void defaultEvalCall(NodeBuilder &B, ExplodedNode *Pred,\n                       const CallEvent &Call,\n                       const EvalCallOptions &CallOpts = {});\n\n  /// Find location of the object that is being constructed by a given\n  /// constructor. This should ideally always succeed but due to not being\n  /// fully implemented it sometimes indicates that it failed via its\n  /// out-parameter CallOpts; in such cases a fake temporary region is\n  /// returned, which is better than nothing but does not represent\n  /// the actual behavior of the program.\n  SVal computeObjectUnderConstruction(\n      const Expr *E, ProgramStateRef State, const LocationContext *LCtx,\n      const ConstructionContext *CC, EvalCallOptions &CallOpts);\n\n  /// Update the program state with all the path-sensitive information\n  /// that's necessary to perform construction of an object with a given\n  /// syntactic construction context. V and CallOpts have to be obtained from\n  /// computeObjectUnderConstruction() invoked with the same set of\n  /// the remaining arguments (E, State, LCtx, CC).\n  ProgramStateRef updateObjectsUnderConstruction(\n      SVal V, const Expr *E, ProgramStateRef State, const LocationContext *LCtx,\n      const ConstructionContext *CC, const EvalCallOptions &CallOpts);\n\n  /// A convenient wrapper around computeObjectUnderConstruction\n  /// and updateObjectsUnderConstruction.\n  std::pair<ProgramStateRef, SVal> handleConstructionContext(\n      const Expr *E, ProgramStateRef State, const LocationContext *LCtx,\n      const ConstructionContext *CC, EvalCallOptions &CallOpts) {\n    SVal V = computeObjectUnderConstruction(E, State, LCtx, CC, CallOpts);\n    return std::make_pair(\n        updateObjectsUnderConstruction(V, E, State, LCtx, CC, CallOpts), V);\n  }\n\nprivate:\n  ProgramStateRef finishArgumentConstruction(ProgramStateRef State,\n                                             const CallEvent &Call);\n  void finishArgumentConstruction(ExplodedNodeSet &Dst, ExplodedNode *Pred,\n                                  const CallEvent &Call);\n\n  void evalLoadCommon(ExplodedNodeSet &Dst,\n                      const Expr *NodeEx,  /* Eventually will be a CFGStmt */\n                      const Expr *BoundEx,\n                      ExplodedNode *Pred,\n                      ProgramStateRef St,\n                      SVal location,\n                      const ProgramPointTag *tag,\n                      QualType LoadTy);\n\n  void evalLocation(ExplodedNodeSet &Dst,\n                    const Stmt *NodeEx, /* This will eventually be a CFGStmt */\n                    const Stmt *BoundEx,\n                    ExplodedNode *Pred,\n                    ProgramStateRef St,\n                    SVal location,\n                    bool isLoad);\n\n  /// Count the stack depth and determine if the call is recursive.\n  void examineStackFrames(const Decl *D, const LocationContext *LCtx,\n                          bool &IsRecursive, unsigned &StackDepth);\n\n  enum CallInlinePolicy {\n    CIP_Allowed,\n    CIP_DisallowedOnce,\n    CIP_DisallowedAlways\n  };\n\n  /// See if a particular call should be inlined, by only looking\n  /// at the call event and the current state of analysis.\n  CallInlinePolicy mayInlineCallKind(const CallEvent &Call,\n                                     const ExplodedNode *Pred,\n                                     AnalyzerOptions &Opts,\n                                     const EvalCallOptions &CallOpts);\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should always inline simply because it's small enough.\n  /// Apart from \"small\" functions, we also have \"large\" functions\n  /// (cf. isLarge()), some of which are huge (cf. isHuge()), and we classify\n  /// the remaining functions as \"medium\".\n  bool isSmall(AnalysisDeclContext *ADC) const;\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should inline carefully because it looks pretty large.\n  bool isLarge(AnalysisDeclContext *ADC) const;\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should never inline because it's legit gigantic.\n  bool isHuge(AnalysisDeclContext *ADC) const;\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should inline, just by looking at the declaration of the function.\n  bool mayInlineDecl(AnalysisDeclContext *ADC) const;\n\n  /// Checks our policies and decides weither the given call should be inlined.\n  bool shouldInlineCall(const CallEvent &Call, const Decl *D,\n                        const ExplodedNode *Pred,\n                        const EvalCallOptions &CallOpts = {});\n\n  bool inlineCall(const CallEvent &Call, const Decl *D, NodeBuilder &Bldr,\n                  ExplodedNode *Pred, ProgramStateRef State);\n\n  /// Conservatively evaluate call by invalidating regions and binding\n  /// a conjured return value.\n  void conservativeEvalCall(const CallEvent &Call, NodeBuilder &Bldr,\n                            ExplodedNode *Pred, ProgramStateRef State);\n\n  /// Either inline or process the call conservatively (or both), based\n  /// on DynamicDispatchBifurcation data.\n  void BifurcateCall(const MemRegion *BifurReg,\n                     const CallEvent &Call, const Decl *D, NodeBuilder &Bldr,\n                     ExplodedNode *Pred);\n\n  bool replayWithoutInlining(ExplodedNode *P, const LocationContext *CalleeLC);\n\n  /// Models a trivial copy or move constructor or trivial assignment operator\n  /// call with a simple bind.\n  void performTrivialCopy(NodeBuilder &Bldr, ExplodedNode *Pred,\n                          const CallEvent &Call);\n\n  /// If the value of the given expression \\p InitWithAdjustments is a NonLoc,\n  /// copy it into a new temporary object region, and replace the value of the\n  /// expression with that.\n  ///\n  /// If \\p Result is provided, the new region will be bound to this expression\n  /// instead of \\p InitWithAdjustments.\n  ///\n  /// Returns the temporary region with adjustments into the optional\n  /// OutRegionWithAdjustments out-parameter if a new region was indeed needed,\n  /// otherwise sets it to nullptr.\n  ProgramStateRef createTemporaryRegionIfNeeded(\n      ProgramStateRef State, const LocationContext *LC,\n      const Expr *InitWithAdjustments, const Expr *Result = nullptr,\n      const SubRegion **OutRegionWithAdjustments = nullptr);\n\n  /// Returns a region representing the first element of a (possibly\n  /// multi-dimensional) array, for the purposes of element construction or\n  /// destruction.\n  ///\n  /// On return, \\p Ty will be set to the base type of the array.\n  ///\n  /// If the type is not an array type at all, the original value is returned.\n  /// Otherwise the \"IsArray\" flag is set.\n  static SVal makeZeroElementRegion(ProgramStateRef State, SVal LValue,\n                                    QualType &Ty, bool &IsArray);\n\n  /// For a DeclStmt or CXXInitCtorInitializer, walk backward in the current CFG\n  /// block to find the constructor expression that directly constructed into\n  /// the storage for this statement. Returns null if the constructor for this\n  /// statement created a temporary object region rather than directly\n  /// constructing into an existing region.\n  const CXXConstructExpr *findDirectConstructorForCurrentCFGElement();\n\n  /// Common code that handles either a CXXConstructExpr or a\n  /// CXXInheritedCtorInitExpr.\n  void handleConstructor(const Expr *E, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\npublic:\n  /// Note whether this loop has any more iteratios to model. These methods are\n  /// essentially an interface for a GDM trait. Further reading in\n  /// ExprEngine::VisitObjCForCollectionStmt().\n  LLVM_NODISCARD static ProgramStateRef\n  setWhetherHasMoreIteration(ProgramStateRef State,\n                             const ObjCForCollectionStmt *O,\n                             const LocationContext *LC, bool HasMoreIteraton);\n\n  LLVM_NODISCARD static ProgramStateRef\n  removeIterationState(ProgramStateRef State, const ObjCForCollectionStmt *O,\n                       const LocationContext *LC);\n\n  LLVM_NODISCARD static bool hasMoreIteration(ProgramStateRef State,\n                                              const ObjCForCollectionStmt *O,\n                                              const LocationContext *LC);\nprivate:\n  /// Store the location of a C++ object corresponding to a statement\n  /// until the statement is actually encountered. For example, if a DeclStmt\n  /// has CXXConstructExpr as its initializer, the object would be considered\n  /// to be \"under construction\" between CXXConstructExpr and DeclStmt.\n  /// This allows, among other things, to keep bindings to variable's fields\n  /// made within the constructor alive until its declaration actually\n  /// goes into scope.\n  static ProgramStateRef\n  addObjectUnderConstruction(ProgramStateRef State,\n                             const ConstructionContextItem &Item,\n                             const LocationContext *LC, SVal V);\n\n  /// Mark the object sa fully constructed, cleaning up the state trait\n  /// that tracks objects under construction.\n  static ProgramStateRef\n  finishObjectConstruction(ProgramStateRef State,\n                           const ConstructionContextItem &Item,\n                           const LocationContext *LC);\n\n  /// If the given expression corresponds to a temporary that was used for\n  /// passing into an elidable copy/move constructor and that constructor\n  /// was actually elided, track that we also need to elide the destructor.\n  static ProgramStateRef elideDestructor(ProgramStateRef State,\n                                         const CXXBindTemporaryExpr *BTE,\n                                         const LocationContext *LC);\n\n  /// Stop tracking the destructor that corresponds to an elided constructor.\n  static ProgramStateRef\n  cleanupElidedDestructor(ProgramStateRef State,\n                          const CXXBindTemporaryExpr *BTE,\n                          const LocationContext *LC);\n\n  /// Returns true if the given expression corresponds to a temporary that\n  /// was constructed for passing into an elidable copy/move constructor\n  /// and that constructor was actually elided.\n  static bool isDestructorElided(ProgramStateRef State,\n                                 const CXXBindTemporaryExpr *BTE,\n                                 const LocationContext *LC);\n\n  /// Check if all objects under construction have been fully constructed\n  /// for the given context range (including FromLC, not including ToLC).\n  /// This is useful for assertions. Also checks if elided destructors\n  /// were cleaned up.\n  static bool areAllObjectsFullyConstructed(ProgramStateRef State,\n                                            const LocationContext *FromLC,\n                                            const LocationContext *ToLC);\n};\n\n/// Traits for storing the call processing policy inside GDM.\n/// The GDM stores the corresponding CallExpr pointer.\n// FIXME: This does not use the nice trait macros because it must be accessible\n// from multiple translation units.\nstruct ReplayWithoutInlining{};\ntemplate <>\nstruct ProgramStateTrait<ReplayWithoutInlining> :\n  public ProgramStatePartialTrait<const void*> {\n  static void *GDMIndex();\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPRENGINE_H\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "content": "//===- SymbolManager.h - Management of Symbolic Values ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines SymbolManager, a class that manages symbolic values\n//  created for use by ExprEngine and related classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/StoreRef.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n\nnamespace clang {\n\nclass ASTContext;\nclass Stmt;\n\nnamespace ento {\n\nclass BasicValueFactory;\nclass StoreManager;\n\n///A symbol representing the value stored at a MemRegion.\nclass SymbolRegionValue : public SymbolData {\n  const TypedValueRegion *R;\n\npublic:\n  SymbolRegionValue(SymbolID sym, const TypedValueRegion *r)\n      : SymbolData(SymbolRegionValueKind, sym), R(r) {\n    assert(r);\n    assert(isValidTypeForSymbol(r->getValueType()));\n  }\n\n  const TypedValueRegion* getRegion() const { return R; }\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const TypedValueRegion* R) {\n    profile.AddInteger((unsigned) SymbolRegionValueKind);\n    profile.AddPointer(R);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, R);\n  }\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n  const MemRegion *getOriginRegion() const override { return getRegion(); }\n\n  QualType getType() const override;\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolRegionValueKind;\n  }\n};\n\n/// A symbol representing the result of an expression in the case when we do\n/// not know anything about what the expression is.\nclass SymbolConjured : public SymbolData {\n  const Stmt *S;\n  QualType T;\n  unsigned Count;\n  const LocationContext *LCtx;\n  const void *SymbolTag;\n\npublic:\n  SymbolConjured(SymbolID sym, const Stmt *s, const LocationContext *lctx,\n                 QualType t, unsigned count, const void *symbolTag)\n      : SymbolData(SymbolConjuredKind, sym), S(s), T(t), Count(count),\n        LCtx(lctx), SymbolTag(symbolTag) {\n    // FIXME: 's' might be a nullptr if we're conducting invalidation\n    // that was caused by a destructor call on a temporary object,\n    // which has no statement associated with it.\n    // Due to this, we might be creating the same invalidation symbol for\n    // two different invalidation passes (for two different temporaries).\n    assert(lctx);\n    assert(isValidTypeForSymbol(t));\n  }\n\n  const Stmt *getStmt() const { return S; }\n  unsigned getCount() const { return Count; }\n  const void *getTag() const { return SymbolTag; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const Stmt *S,\n                      QualType T, unsigned Count, const LocationContext *LCtx,\n                      const void *SymbolTag) {\n    profile.AddInteger((unsigned) SymbolConjuredKind);\n    profile.AddPointer(S);\n    profile.AddPointer(LCtx);\n    profile.Add(T);\n    profile.AddInteger(Count);\n    profile.AddPointer(SymbolTag);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, S, T, Count, LCtx, SymbolTag);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolConjuredKind;\n  }\n};\n\n/// A symbol representing the value of a MemRegion whose parent region has\n/// symbolic value.\nclass SymbolDerived : public SymbolData {\n  SymbolRef parentSymbol;\n  const TypedValueRegion *R;\n\npublic:\n  SymbolDerived(SymbolID sym, SymbolRef parent, const TypedValueRegion *r)\n      : SymbolData(SymbolDerivedKind, sym), parentSymbol(parent), R(r) {\n    assert(parent);\n    assert(r);\n    assert(isValidTypeForSymbol(r->getValueType()));\n  }\n\n  SymbolRef getParentSymbol() const { return parentSymbol; }\n  const TypedValueRegion *getRegion() const { return R; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n  const MemRegion *getOriginRegion() const override { return getRegion(); }\n\n  static void Profile(llvm::FoldingSetNodeID& profile, SymbolRef parent,\n                      const TypedValueRegion *r) {\n    profile.AddInteger((unsigned) SymbolDerivedKind);\n    profile.AddPointer(r);\n    profile.AddPointer(parent);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, parentSymbol, R);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolDerivedKind;\n  }\n};\n\n/// SymbolExtent - Represents the extent (size in bytes) of a bounded region.\n///  Clients should not ask the SymbolManager for a region's extent. Always use\n///  SubRegion::getExtent instead -- the value returned may not be a symbol.\nclass SymbolExtent : public SymbolData {\n  const SubRegion *R;\n\npublic:\n  SymbolExtent(SymbolID sym, const SubRegion *r)\n      : SymbolData(SymbolExtentKind, sym), R(r) {\n    assert(r);\n  }\n\n  const SubRegion *getRegion() const { return R; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const SubRegion *R) {\n    profile.AddInteger((unsigned) SymbolExtentKind);\n    profile.AddPointer(R);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, R);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolExtentKind;\n  }\n};\n\n/// SymbolMetadata - Represents path-dependent metadata about a specific region.\n///  Metadata symbols remain live as long as they are marked as in use before\n///  dead-symbol sweeping AND their associated regions are still alive.\n///  Intended for use by checkers.\nclass SymbolMetadata : public SymbolData {\n  const MemRegion* R;\n  const Stmt *S;\n  QualType T;\n  const LocationContext *LCtx;\n  unsigned Count;\n  const void *Tag;\n\npublic:\n  SymbolMetadata(SymbolID sym, const MemRegion* r, const Stmt *s, QualType t,\n                 const LocationContext *LCtx, unsigned count, const void *tag)\n      : SymbolData(SymbolMetadataKind, sym), R(r), S(s), T(t), LCtx(LCtx),\n        Count(count), Tag(tag) {\n      assert(r);\n      assert(s);\n      assert(isValidTypeForSymbol(t));\n      assert(LCtx);\n      assert(tag);\n    }\n\n  const MemRegion *getRegion() const { return R; }\n  const Stmt *getStmt() const { return S; }\n  const LocationContext *getLocationContext() const { return LCtx; }\n  unsigned getCount() const { return Count; }\n  const void *getTag() const { return Tag; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const MemRegion *R,\n                      const Stmt *S, QualType T, const LocationContext *LCtx,\n                      unsigned Count, const void *Tag) {\n    profile.AddInteger((unsigned) SymbolMetadataKind);\n    profile.AddPointer(R);\n    profile.AddPointer(S);\n    profile.Add(T);\n    profile.AddPointer(LCtx);\n    profile.AddInteger(Count);\n    profile.AddPointer(Tag);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, R, S, T, LCtx, Count, Tag);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolMetadataKind;\n  }\n};\n\n/// Represents a cast expression.\nclass SymbolCast : public SymExpr {\n  const SymExpr *Operand;\n\n  /// Type of the operand.\n  QualType FromTy;\n\n  /// The type of the result.\n  QualType ToTy;\n\npublic:\n  SymbolCast(const SymExpr *In, QualType From, QualType To)\n      : SymExpr(SymbolCastKind), Operand(In), FromTy(From), ToTy(To) {\n    assert(In);\n    assert(isValidTypeForSymbol(From));\n    // FIXME: GenericTaintChecker creates symbols of void type.\n    // Otherwise, 'To' should also be a valid type.\n  }\n\n  unsigned computeComplexity() const override {\n    if (Complexity == 0)\n      Complexity = 1 + Operand->computeComplexity();\n    return Complexity;\n  }\n\n  QualType getType() const override { return ToTy; }\n\n  const SymExpr *getOperand() const { return Operand; }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& ID,\n                      const SymExpr *In, QualType From, QualType To) {\n    ID.AddInteger((unsigned) SymbolCastKind);\n    ID.AddPointer(In);\n    ID.Add(From);\n    ID.Add(To);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) override {\n    Profile(ID, Operand, FromTy, ToTy);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolCastKind;\n  }\n};\n\n/// Represents a symbolic expression involving a binary operator\nclass BinarySymExpr : public SymExpr {\n  BinaryOperator::Opcode Op;\n  QualType T;\n\nprotected:\n  BinarySymExpr(Kind k, BinaryOperator::Opcode op, QualType t)\n      : SymExpr(k), Op(op), T(t) {\n    assert(classof(this));\n    // Binary expressions are results of arithmetic. Pointer arithmetic is not\n    // handled by binary expressions, but it is instead handled by applying\n    // sub-regions to regions.\n    assert(isValidTypeForSymbol(t) && !Loc::isLocType(t));\n  }\n\npublic:\n  // FIXME: We probably need to make this out-of-line to avoid redundant\n  // generation of virtual functions.\n  QualType getType() const override { return T; }\n\n  BinaryOperator::Opcode getOpcode() const { return Op; }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    Kind k = SE->getKind();\n    return k >= BEGIN_BINARYSYMEXPRS && k <= END_BINARYSYMEXPRS;\n  }\n\nprotected:\n  static unsigned computeOperandComplexity(const SymExpr *Value) {\n    return Value->computeComplexity();\n  }\n  static unsigned computeOperandComplexity(const llvm::APSInt &Value) {\n    return 1;\n  }\n\n  static const llvm::APSInt *getPointer(const llvm::APSInt &Value) {\n    return &Value;\n  }\n  static const SymExpr *getPointer(const SymExpr *Value) { return Value; }\n\n  static void dumpToStreamImpl(raw_ostream &os, const SymExpr *Value);\n  static void dumpToStreamImpl(raw_ostream &os, const llvm::APSInt &Value);\n  static void dumpToStreamImpl(raw_ostream &os, BinaryOperator::Opcode op);\n};\n\n/// Template implementation for all binary symbolic expressions\ntemplate <class LHSTYPE, class RHSTYPE, SymExpr::Kind ClassKind>\nclass BinarySymExprImpl : public BinarySymExpr {\n  LHSTYPE LHS;\n  RHSTYPE RHS;\n\npublic:\n  BinarySymExprImpl(LHSTYPE lhs, BinaryOperator::Opcode op, RHSTYPE rhs,\n                    QualType t)\n      : BinarySymExpr(ClassKind, op, t), LHS(lhs), RHS(rhs) {\n    assert(getPointer(lhs));\n    assert(getPointer(rhs));\n  }\n\n  void dumpToStream(raw_ostream &os) const override {\n    dumpToStreamImpl(os, LHS);\n    dumpToStreamImpl(os, getOpcode());\n    dumpToStreamImpl(os, RHS);\n  }\n\n  LHSTYPE getLHS() const { return LHS; }\n  RHSTYPE getRHS() const { return RHS; }\n\n  unsigned computeComplexity() const override {\n    if (Complexity == 0)\n      Complexity =\n          computeOperandComplexity(RHS) + computeOperandComplexity(LHS);\n    return Complexity;\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, LHSTYPE lhs,\n                      BinaryOperator::Opcode op, RHSTYPE rhs, QualType t) {\n    ID.AddInteger((unsigned)ClassKind);\n    ID.AddPointer(getPointer(lhs));\n    ID.AddInteger(op);\n    ID.AddPointer(getPointer(rhs));\n    ID.Add(t);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) override {\n    Profile(ID, LHS, getOpcode(), RHS, getType());\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) { return SE->getKind() == ClassKind; }\n};\n\n/// Represents a symbolic expression like 'x' + 3.\nusing SymIntExpr = BinarySymExprImpl<const SymExpr *, const llvm::APSInt &,\n                                     SymExpr::Kind::SymIntExprKind>;\n\n/// Represents a symbolic expression like 3 - 'x'.\nusing IntSymExpr = BinarySymExprImpl<const llvm::APSInt &, const SymExpr *,\n                                     SymExpr::Kind::IntSymExprKind>;\n\n/// Represents a symbolic expression like 'x' + 'y'.\nusing SymSymExpr = BinarySymExprImpl<const SymExpr *, const SymExpr *,\n                                     SymExpr::Kind::SymSymExprKind>;\n\nclass SymbolManager {\n  using DataSetTy = llvm::FoldingSet<SymExpr>;\n  using SymbolDependTy =\n      llvm::DenseMap<SymbolRef, std::unique_ptr<SymbolRefSmallVectorTy>>;\n\n  DataSetTy DataSet;\n\n  /// Stores the extra dependencies between symbols: the data should be kept\n  /// alive as long as the key is live.\n  SymbolDependTy SymbolDependencies;\n\n  unsigned SymbolCounter = 0;\n  llvm::BumpPtrAllocator& BPAlloc;\n  BasicValueFactory &BV;\n  ASTContext &Ctx;\n\npublic:\n  SymbolManager(ASTContext &ctx, BasicValueFactory &bv,\n                llvm::BumpPtrAllocator& bpalloc)\n      : SymbolDependencies(16), BPAlloc(bpalloc), BV(bv), Ctx(ctx) {}\n\n  static bool canSymbolicate(QualType T);\n\n  /// Make a unique symbol for MemRegion R according to its kind.\n  const SymbolRegionValue* getRegionValueSymbol(const TypedValueRegion* R);\n\n  const SymbolConjured* conjureSymbol(const Stmt *E,\n                                      const LocationContext *LCtx,\n                                      QualType T,\n                                      unsigned VisitCount,\n                                      const void *SymbolTag = nullptr);\n\n  const SymbolConjured* conjureSymbol(const Expr *E,\n                                      const LocationContext *LCtx,\n                                      unsigned VisitCount,\n                                      const void *SymbolTag = nullptr) {\n    return conjureSymbol(E, LCtx, E->getType(), VisitCount, SymbolTag);\n  }\n\n  const SymbolDerived *getDerivedSymbol(SymbolRef parentSymbol,\n                                        const TypedValueRegion *R);\n\n  const SymbolExtent *getExtentSymbol(const SubRegion *R);\n\n  /// Creates a metadata symbol associated with a specific region.\n  ///\n  /// VisitCount can be used to differentiate regions corresponding to\n  /// different loop iterations, thus, making the symbol path-dependent.\n  const SymbolMetadata *getMetadataSymbol(const MemRegion *R, const Stmt *S,\n                                          QualType T,\n                                          const LocationContext *LCtx,\n                                          unsigned VisitCount,\n                                          const void *SymbolTag = nullptr);\n\n  const SymbolCast* getCastSymbol(const SymExpr *Operand,\n                                  QualType From, QualType To);\n\n  const SymIntExpr *getSymIntExpr(const SymExpr *lhs, BinaryOperator::Opcode op,\n                                  const llvm::APSInt& rhs, QualType t);\n\n  const SymIntExpr *getSymIntExpr(const SymExpr &lhs, BinaryOperator::Opcode op,\n                                  const llvm::APSInt& rhs, QualType t) {\n    return getSymIntExpr(&lhs, op, rhs, t);\n  }\n\n  const IntSymExpr *getIntSymExpr(const llvm::APSInt& lhs,\n                                  BinaryOperator::Opcode op,\n                                  const SymExpr *rhs, QualType t);\n\n  const SymSymExpr *getSymSymExpr(const SymExpr *lhs, BinaryOperator::Opcode op,\n                                  const SymExpr *rhs, QualType t);\n\n  QualType getType(const SymExpr *SE) const {\n    return SE->getType();\n  }\n\n  /// Add artificial symbol dependency.\n  ///\n  /// The dependent symbol should stay alive as long as the primary is alive.\n  void addSymbolDependency(const SymbolRef Primary, const SymbolRef Dependent);\n\n  const SymbolRefSmallVectorTy *getDependentSymbols(const SymbolRef Primary);\n\n  ASTContext &getContext() { return Ctx; }\n  BasicValueFactory &getBasicVals() { return BV; }\n};\n\n/// A class responsible for cleaning up unused symbols.\nclass SymbolReaper {\n  enum SymbolStatus {\n    NotProcessed,\n    HaveMarkedDependents\n  };\n\n  using SymbolSetTy = llvm::DenseSet<SymbolRef>;\n  using SymbolMapTy = llvm::DenseMap<SymbolRef, SymbolStatus>;\n  using RegionSetTy = llvm::DenseSet<const MemRegion *>;\n\n  SymbolMapTy TheLiving;\n  SymbolSetTy MetadataInUse;\n\n  RegionSetTy RegionRoots;\n\n  const StackFrameContext *LCtx;\n  const Stmt *Loc;\n  SymbolManager& SymMgr;\n  StoreRef reapedStore;\n  llvm::DenseMap<const MemRegion *, unsigned> includedRegionCache;\n\npublic:\n  /// Construct a reaper object, which removes everything which is not\n  /// live before we execute statement s in the given location context.\n  ///\n  /// If the statement is NULL, everything is this and parent contexts is\n  /// considered live.\n  /// If the stack frame context is NULL, everything on stack is considered\n  /// dead.\n  SymbolReaper(const StackFrameContext *Ctx, const Stmt *s,\n               SymbolManager &symmgr, StoreManager &storeMgr)\n      : LCtx(Ctx), Loc(s), SymMgr(symmgr), reapedStore(nullptr, storeMgr) {}\n\n  const LocationContext *getLocationContext() const { return LCtx; }\n\n  bool isLive(SymbolRef sym);\n  bool isLiveRegion(const MemRegion *region);\n  bool isLive(const Expr *ExprVal, const LocationContext *LCtx) const;\n  bool isLive(const VarRegion *VR, bool includeStoreBindings = false) const;\n\n  /// Unconditionally marks a symbol as live.\n  ///\n  /// This should never be\n  /// used by checkers, only by the state infrastructure such as the store and\n  /// environment. Checkers should instead use metadata symbols and markInUse.\n  void markLive(SymbolRef sym);\n\n  /// Marks a symbol as important to a checker.\n  ///\n  /// For metadata symbols,\n  /// this will keep the symbol alive as long as its associated region is also\n  /// live. For other symbols, this has no effect; checkers are not permitted\n  /// to influence the life of other symbols. This should be used before any\n  /// symbol marking has occurred, i.e. in the MarkLiveSymbols callback.\n  void markInUse(SymbolRef sym);\n\n  using region_iterator = RegionSetTy::const_iterator;\n\n  region_iterator region_begin() const { return RegionRoots.begin(); }\n  region_iterator region_end() const { return RegionRoots.end(); }\n\n  /// Returns whether or not a symbol has been confirmed dead.\n  ///\n  /// This should only be called once all marking of dead symbols has completed.\n  /// (For checkers, this means only in the checkDeadSymbols callback.)\n  bool isDead(SymbolRef sym) {\n    return !isLive(sym);\n  }\n\n  void markLive(const MemRegion *region);\n  void markElementIndicesLive(const MemRegion *region);\n\n  /// Set to the value of the symbolic store after\n  /// StoreManager::removeDeadBindings has been called.\n  void setReapedStore(StoreRef st) { reapedStore = st; }\n\nprivate:\n  /// Mark the symbols dependent on the input symbol as live.\n  void markDependentsLive(SymbolRef sym);\n};\n\nclass SymbolVisitor {\nprotected:\n  ~SymbolVisitor() = default;\n\npublic:\n  SymbolVisitor() = default;\n  SymbolVisitor(const SymbolVisitor &) = default;\n  SymbolVisitor(SymbolVisitor &&) {}\n\n  /// A visitor method invoked by ProgramStateManager::scanReachableSymbols.\n  ///\n  /// The method returns \\c true if symbols should continue be scanned and \\c\n  /// false otherwise.\n  virtual bool VisitSymbol(SymbolRef sym) = 0;\n  virtual bool VisitMemRegion(const MemRegion *) { return true; }\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h", "content": "//==--- RetainCountChecker.h - Checks for leaks and other issues -*- C++ -*--//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the methods for RetainCountChecker, which implements\n//  a reference count checker for Core Foundation and Cocoa on (Mac OS X).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_STATICANALYZER_CHECKERS_RETAINCOUNTCHECKER_H\n#define LLVM_CLANG_LIB_STATICANALYZER_CHECKERS_RETAINCOUNTCHECKER_H\n\n#include \"clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h\"\n#include \"RetainCountDiagnostics.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/ParentMap.h\"\n#include \"clang/Analysis/DomainSpecific/CocoaConventions.h\"\n#include \"clang/Analysis/PathDiagnostic.h\"\n#include \"clang/Analysis/RetainSummaryManager.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Analysis/SelectorExtras.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableList.h\"\n#include \"llvm/ADT/ImmutableMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include <cstdarg>\n#include <utility>\n\nnamespace clang {\nnamespace ento {\nnamespace retaincountchecker {\n\n/// Metadata on reference.\nclass RefVal {\npublic:\n  enum Kind {\n    Owned = 0, // Owning reference.\n    NotOwned,  // Reference is not owned by still valid (not freed).\n    Released,  // Object has been released.\n    ReturnedOwned, // Returned object passes ownership to caller.\n    ReturnedNotOwned, // Return object does not pass ownership to caller.\n    ERROR_START,\n    ErrorDeallocNotOwned, // -dealloc called on non-owned object.\n    ErrorUseAfterRelease, // Object used after released.\n    ErrorReleaseNotOwned, // Release of an object that was not owned.\n    ERROR_LEAK_START,\n    ErrorLeak,  // A memory leak due to excessive reference counts.\n    ErrorLeakReturned, // A memory leak due to the returning method not having\n                       // the correct naming conventions.\n    ErrorOverAutorelease,\n    ErrorReturnedNotOwned\n  };\n\n  /// Tracks how an object referenced by an ivar has been used.\n  ///\n  /// This accounts for us not knowing if an arbitrary ivar is supposed to be\n  /// stored at +0 or +1.\n  enum class IvarAccessHistory {\n    None,\n    AccessedDirectly,\n    ReleasedAfterDirectAccess\n  };\n\nprivate:\n  /// The number of outstanding retains.\n  unsigned Cnt;\n  /// The number of outstanding autoreleases.\n  unsigned ACnt;\n  /// The (static) type of the object at the time we started tracking it.\n  QualType T;\n\n  /// The current state of the object.\n  ///\n  /// See the RefVal::Kind enum for possible values.\n  unsigned RawKind : 5;\n\n  /// The kind of object being tracked (CF or ObjC or OSObject), if known.\n  ///\n  /// See the ObjKind enum for possible values.\n  unsigned RawObjectKind : 3;\n\n  /// True if the current state and/or retain count may turn out to not be the\n  /// best possible approximation of the reference counting state.\n  ///\n  /// If true, the checker may decide to throw away (\"override\") this state\n  /// in favor of something else when it sees the object being used in new ways.\n  ///\n  /// This setting should not be propagated to state derived from this state.\n  /// Once we start deriving new states, it would be inconsistent to override\n  /// them.\n  unsigned RawIvarAccessHistory : 2;\n\n  RefVal(Kind k, ObjKind o, unsigned cnt, unsigned acnt, QualType t,\n         IvarAccessHistory IvarAccess)\n    : Cnt(cnt), ACnt(acnt), T(t), RawKind(static_cast<unsigned>(k)),\n      RawObjectKind(static_cast<unsigned>(o)),\n      RawIvarAccessHistory(static_cast<unsigned>(IvarAccess)) {\n    assert(getKind() == k && \"not enough bits for the kind\");\n    assert(getObjKind() == o && \"not enough bits for the object kind\");\n    assert(getIvarAccessHistory() == IvarAccess && \"not enough bits\");\n  }\n\npublic:\n  Kind getKind() const { return static_cast<Kind>(RawKind); }\n\n  ObjKind getObjKind() const {\n    return static_cast<ObjKind>(RawObjectKind);\n  }\n\n  unsigned getCount() const { return Cnt; }\n  unsigned getAutoreleaseCount() const { return ACnt; }\n  unsigned getCombinedCounts() const { return Cnt + ACnt; }\n  void clearCounts() {\n    Cnt = 0;\n    ACnt = 0;\n  }\n  void setCount(unsigned i) {\n    Cnt = i;\n  }\n  void setAutoreleaseCount(unsigned i) {\n    ACnt = i;\n  }\n\n  QualType getType() const { return T; }\n\n  /// Returns what the analyzer knows about direct accesses to a particular\n  /// instance variable.\n  ///\n  /// If the object with this refcount wasn't originally from an Objective-C\n  /// ivar region, this should always return IvarAccessHistory::None.\n  IvarAccessHistory getIvarAccessHistory() const {\n    return static_cast<IvarAccessHistory>(RawIvarAccessHistory);\n  }\n\n  bool isOwned() const {\n    return getKind() == Owned;\n  }\n\n  bool isNotOwned() const {\n    return getKind() == NotOwned;\n  }\n\n  bool isReturnedOwned() const {\n    return getKind() == ReturnedOwned;\n  }\n\n  bool isReturnedNotOwned() const {\n    return getKind() == ReturnedNotOwned;\n  }\n\n  /// Create a state for an object whose lifetime is the responsibility of the\n  /// current function, at least partially.\n  ///\n  /// Most commonly, this is an owned object with a retain count of +1.\n  static RefVal makeOwned(ObjKind o, QualType t) {\n    return RefVal(Owned, o, /*Count=*/1, 0, t, IvarAccessHistory::None);\n  }\n\n  /// Create a state for an object whose lifetime is not the responsibility of\n  /// the current function.\n  ///\n  /// Most commonly, this is an unowned object with a retain count of +0.\n  static RefVal makeNotOwned(ObjKind o, QualType t) {\n    return RefVal(NotOwned, o, /*Count=*/0, 0, t, IvarAccessHistory::None);\n  }\n\n  RefVal operator-(size_t i) const {\n    return RefVal(getKind(), getObjKind(), getCount() - i,\n                  getAutoreleaseCount(), getType(), getIvarAccessHistory());\n  }\n\n  RefVal operator+(size_t i) const {\n    return RefVal(getKind(), getObjKind(), getCount() + i,\n                  getAutoreleaseCount(), getType(), getIvarAccessHistory());\n  }\n\n  RefVal operator^(Kind k) const {\n    return RefVal(k, getObjKind(), getCount(), getAutoreleaseCount(),\n                  getType(), getIvarAccessHistory());\n  }\n\n  RefVal autorelease() const {\n    return RefVal(getKind(), getObjKind(), getCount(), getAutoreleaseCount()+1,\n                  getType(), getIvarAccessHistory());\n  }\n\n  RefVal withIvarAccess() const {\n    assert(getIvarAccessHistory() == IvarAccessHistory::None);\n    return RefVal(getKind(), getObjKind(), getCount(), getAutoreleaseCount(),\n                  getType(), IvarAccessHistory::AccessedDirectly);\n  }\n\n  RefVal releaseViaIvar() const {\n    assert(getIvarAccessHistory() == IvarAccessHistory::AccessedDirectly);\n    return RefVal(getKind(), getObjKind(), getCount(), getAutoreleaseCount(),\n                  getType(), IvarAccessHistory::ReleasedAfterDirectAccess);\n  }\n\n  // Comparison, profiling, and pretty-printing.\n  bool hasSameState(const RefVal &X) const {\n    return getKind() == X.getKind() && Cnt == X.Cnt && ACnt == X.ACnt &&\n           getIvarAccessHistory() == X.getIvarAccessHistory();\n  }\n\n  bool operator==(const RefVal& X) const {\n    return T == X.T && hasSameState(X) && getObjKind() == X.getObjKind();\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.Add(T);\n    ID.AddInteger(RawKind);\n    ID.AddInteger(Cnt);\n    ID.AddInteger(ACnt);\n    ID.AddInteger(RawObjectKind);\n    ID.AddInteger(RawIvarAccessHistory);\n  }\n\n  void print(raw_ostream &Out) const;\n};\n\nclass RetainCountChecker\n  : public Checker< check::Bind,\n                    check::DeadSymbols,\n                    check::BeginFunction,\n                    check::EndFunction,\n                    check::PostStmt<BlockExpr>,\n                    check::PostStmt<CastExpr>,\n                    check::PostStmt<ObjCArrayLiteral>,\n                    check::PostStmt<ObjCDictionaryLiteral>,\n                    check::PostStmt<ObjCBoxedExpr>,\n                    check::PostStmt<ObjCIvarRefExpr>,\n                    check::PostCall,\n                    check::RegionChanges,\n                    eval::Assume,\n                    eval::Call > {\n\npublic:\n  std::unique_ptr<RefCountBug> UseAfterRelease;\n  std::unique_ptr<RefCountBug> ReleaseNotOwned;\n  std::unique_ptr<RefCountBug> DeallocNotOwned;\n  std::unique_ptr<RefCountBug> FreeNotOwned;\n  std::unique_ptr<RefCountBug> OverAutorelease;\n  std::unique_ptr<RefCountBug> ReturnNotOwnedForOwned;\n  std::unique_ptr<RefCountBug> LeakWithinFunction;\n  std::unique_ptr<RefCountBug> LeakAtReturn;\n\n  mutable std::unique_ptr<RetainSummaryManager> Summaries;\n\n  static std::unique_ptr<CheckerProgramPointTag> DeallocSentTag;\n  static std::unique_ptr<CheckerProgramPointTag> CastFailTag;\n\n  /// Track Objective-C and CoreFoundation objects.\n  bool TrackObjCAndCFObjects = false;\n\n  /// Track sublcasses of OSObject.\n  bool TrackOSObjects = false;\n\n  /// Track initial parameters (for the entry point) for NS/CF objects.\n  bool TrackNSCFStartParam = false;\n\n  RetainCountChecker() {};\n\n  RetainSummaryManager &getSummaryManager(ASTContext &Ctx) const {\n    if (!Summaries)\n      Summaries.reset(\n          new RetainSummaryManager(Ctx, TrackObjCAndCFObjects, TrackOSObjects));\n    return *Summaries;\n  }\n\n  RetainSummaryManager &getSummaryManager(CheckerContext &C) const {\n    return getSummaryManager(C.getASTContext());\n  }\n\n  void printState(raw_ostream &Out, ProgramStateRef State,\n                  const char *NL, const char *Sep) const override;\n\n  void checkBind(SVal loc, SVal val, const Stmt *S, CheckerContext &C) const;\n  void checkPostStmt(const BlockExpr *BE, CheckerContext &C) const;\n  void checkPostStmt(const CastExpr *CE, CheckerContext &C) const;\n\n  void checkPostStmt(const ObjCArrayLiteral *AL, CheckerContext &C) const;\n  void checkPostStmt(const ObjCDictionaryLiteral *DL, CheckerContext &C) const;\n  void checkPostStmt(const ObjCBoxedExpr *BE, CheckerContext &C) const;\n\n  void checkPostStmt(const ObjCIvarRefExpr *IRE, CheckerContext &C) const;\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\n  void checkSummary(const RetainSummary &Summ, const CallEvent &Call,\n                    CheckerContext &C) const;\n\n  void processSummaryOfInlined(const RetainSummary &Summ,\n                               const CallEvent &Call,\n                               CheckerContext &C) const;\n\n  bool evalCall(const CallEvent &Call, CheckerContext &C) const;\n\n  ProgramStateRef evalAssume(ProgramStateRef state, SVal Cond,\n                                 bool Assumption) const;\n\n  ProgramStateRef\n  checkRegionChanges(ProgramStateRef state,\n                     const InvalidatedSymbols *invalidated,\n                     ArrayRef<const MemRegion *> ExplicitRegions,\n                     ArrayRef<const MemRegion *> Regions,\n                     const LocationContext* LCtx,\n                     const CallEvent *Call) const;\n\n  ExplodedNode* checkReturnWithRetEffect(const ReturnStmt *S, CheckerContext &C,\n                                ExplodedNode *Pred, RetEffect RE, RefVal X,\n                                SymbolRef Sym, ProgramStateRef state) const;\n\n  void checkDeadSymbols(SymbolReaper &SymReaper, CheckerContext &C) const;\n  void checkBeginFunction(CheckerContext &C) const;\n  void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n\n  ProgramStateRef updateSymbol(ProgramStateRef state, SymbolRef sym,\n                               RefVal V, ArgEffect E, RefVal::Kind &hasErr,\n                               CheckerContext &C) const;\n\n  const RefCountBug &errorKindToBugKind(RefVal::Kind ErrorKind,\n                                        SymbolRef Sym) const;\n\n  void processNonLeakError(ProgramStateRef St, SourceRange ErrorRange,\n                           RefVal::Kind ErrorKind, SymbolRef Sym,\n                           CheckerContext &C) const;\n\n  void processObjCLiterals(CheckerContext &C, const Expr *Ex) const;\n\n  ProgramStateRef handleSymbolDeath(ProgramStateRef state,\n                                    SymbolRef sid, RefVal V,\n                                    SmallVectorImpl<SymbolRef> &Leaked) const;\n\n  ProgramStateRef\n  handleAutoreleaseCounts(ProgramStateRef state, ExplodedNode *Pred,\n                          const ProgramPointTag *Tag, CheckerContext &Ctx,\n                          SymbolRef Sym,\n                          RefVal V,\n                          const ReturnStmt *S=nullptr) const;\n\n  ExplodedNode *processLeaks(ProgramStateRef state,\n                             SmallVectorImpl<SymbolRef> &Leaked,\n                             CheckerContext &Ctx,\n                             ExplodedNode *Pred = nullptr) const;\n\n  static const CheckerProgramPointTag &getDeallocSentTag() {\n    return *DeallocSentTag;\n  }\n\n  static const CheckerProgramPointTag &getCastFailTag() { return *CastFailTag; }\n\nprivate:\n  /// Perform the necessary checks and state adjustments at the end of the\n  /// function.\n  /// \\p S Return statement, may be null.\n  ExplodedNode * processReturn(const ReturnStmt *S, CheckerContext &C) const;\n};\n\n//===----------------------------------------------------------------------===//\n// RefBindings - State used to track object reference counts.\n//===----------------------------------------------------------------------===//\n\nconst RefVal *getRefBinding(ProgramStateRef State, SymbolRef Sym);\n\n/// Returns true if this stack frame is for an Objective-C method that is a\n/// property getter or setter whose body has been synthesized by the analyzer.\ninline bool isSynthesizedAccessor(const StackFrameContext *SFC) {\n  auto Method = dyn_cast_or_null<ObjCMethodDecl>(SFC->getDecl());\n  if (!Method || !Method->isPropertyAccessor())\n    return false;\n\n  return SFC->getAnalysisDeclContext()->isBodyAutosynthesized();\n}\n\n} // end namespace retaincountchecker\n} // end namespace ento\n} // end namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 49, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 49, "line": 48}, "message": "move constructor 'BugReporterVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "1a05a114209ac37f30036d8464269736", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 49, "line": 379}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 49, "line": 379}, "message": "default constructor 'FalsePositiveRefutationBRVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "27d4dd0dc048240beda6635e8078c4e5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 539}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 539}, "message": "default constructor 'EventDispatcher<EVENT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/Checker.h", "reportHash": "fd421f89e8eb5fe0205ffbe49271bc7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 572}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 572}, "message": "default constructor 'DefaultBool' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/Checker.h", "reportHash": "dfbaa24b8224be384ad61f230a3f1145", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 52, "line": 1303}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 52, "line": 1303}, "message": "destructor '~CallDescriptionMap<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h", "reportHash": "222ff672bdaeff45b5b4f957fcc01714", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 54, "line": 91}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 54, "line": 91}, "message": "default constructor 'NodeGroup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h", "reportHash": "c66e8c35d2440fbf2ef86758badb7041", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 346}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 346}, "message": "default constructor 'ExplodedGraph' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h", "reportHash": "9baaecc91a7b0a4f0483789345bc17cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 124}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 124}, "message": "default constructor 'EvalCallOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h", "reportHash": "c9d8be3ff9ca2fcf00aa81e8535cdb78", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 58, "line": 593}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 58, "line": 593}, "message": "move constructor 'SymbolVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "e291add75f114e5455cc39782fa47e97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 278}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 278}, "message": "default constructor 'RetainCountChecker' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h", "reportHash": "ece573e82afe35c51490819464be8374", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
