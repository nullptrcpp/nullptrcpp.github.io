<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Sequence.h", "content": "//===- Sequence.h - Utility for producing sequences of values ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This routine provides some synthesis utilities to produce sequences of\n/// values. The names are intentionally kept very short as they tend to occur\n/// in common and widely used contexts.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SEQUENCE_H\n#define LLVM_ADT_SEQUENCE_H\n\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\ntemplate <typename ValueT>\nclass value_sequence_iterator\n    : public iterator_facade_base<value_sequence_iterator<ValueT>,\n                                  std::random_access_iterator_tag,\n                                  const ValueT> {\n  using BaseT = typename value_sequence_iterator::iterator_facade_base;\n\n  ValueT Value;\n\npublic:\n  using difference_type = typename BaseT::difference_type;\n  using reference = typename BaseT::reference;\n\n  value_sequence_iterator() = default;\n  value_sequence_iterator(const value_sequence_iterator &) = default;\n  value_sequence_iterator(value_sequence_iterator &&Arg)\n      : Value(std::move(Arg.Value)) {}\n  value_sequence_iterator &operator=(const value_sequence_iterator &Arg) {\n    Value = Arg.Value;\n    return *this;\n  }\n\n  template <typename U, typename Enabler = decltype(ValueT(std::declval<U>()))>\n  value_sequence_iterator(U &&Value) : Value(std::forward<U>(Value)) {}\n\n  value_sequence_iterator &operator+=(difference_type N) {\n    Value += N;\n    return *this;\n  }\n  value_sequence_iterator &operator-=(difference_type N) {\n    Value -= N;\n    return *this;\n  }\n  using BaseT::operator-;\n  difference_type operator-(const value_sequence_iterator &RHS) const {\n    return Value - RHS.Value;\n  }\n\n  bool operator==(const value_sequence_iterator &RHS) const {\n    return Value == RHS.Value;\n  }\n  bool operator<(const value_sequence_iterator &RHS) const {\n    return Value < RHS.Value;\n  }\n\n  reference operator*() const { return Value; }\n};\n\n} // end namespace detail\n\ntemplate <typename ValueT>\niterator_range<detail::value_sequence_iterator<ValueT>> seq(ValueT Begin,\n                                                            ValueT End) {\n  return make_range(detail::value_sequence_iterator<ValueT>(Begin),\n                    detail::value_sequence_iterator<ValueT>(End));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SEQUENCE_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "content": "//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the generic AliasAnalysis interface, which is used as the\n// common interface used by all clients of alias analysis information, and\n// implemented by all alias analysis implementations.  Mod/Ref information is\n// also captured by this interface.\n//\n// Implementations of this interface must implement the various virtual methods,\n// which automatically provides functionality for the entire suite of client\n// APIs.\n//\n// This API identifies memory regions with the MemoryLocation class. The pointer\n// component specifies the base memory address of the region. The Size specifies\n// the maximum size (in address units) of the memory region, or\n// MemoryLocation::UnknownSize if the size is not known. The TBAA tag\n// identifies the \"type\" of the memory reference; see the\n// TypeBasedAliasAnalysis class for details.\n//\n// Some non-obvious details include:\n//  - Pointers that point to two completely different objects in memory never\n//    alias, regardless of the value of the Size component.\n//  - NoAlias doesn't imply inequal pointers. The most obvious example of this\n//    is two pointers to constant memory. Even if they are equal, constant\n//    memory is never stored to, so there will never be any dependencies.\n//    In this and other situations, the pointers may be both NoAlias and\n//    MustAlias at the same time. The current API can only return one result,\n//    though this is rarely a problem in practice.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_ALIASANALYSIS_H\n#define LLVM_ANALYSIS_ALIASANALYSIS_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <vector>\n\nnamespace llvm {\n\nclass AnalysisUsage;\nclass AtomicCmpXchgInst;\nclass BasicAAResult;\nclass BasicBlock;\nclass CatchPadInst;\nclass CatchReturnInst;\nclass DominatorTree;\nclass FenceInst;\nclass Function;\nclass InvokeInst;\nclass PreservedAnalyses;\nclass TargetLibraryInfo;\nclass Value;\n\n/// The possible results of an alias query.\n///\n/// These results are always computed between two MemoryLocation objects as\n/// a query to some alias analysis.\n///\n/// Note that these are unscoped enumerations because we would like to support\n/// implicitly testing a result for the existence of any possible aliasing with\n/// a conversion to bool, but an \"enum class\" doesn't support this. The\n/// canonical names from the literature are suffixed and unique anyways, and so\n/// they serve as global constants in LLVM for these results.\n///\n/// See docs/AliasAnalysis.html for more information on the specific meanings\n/// of these values.\nenum AliasResult : uint8_t {\n  /// The two locations do not alias at all.\n  ///\n  /// This value is arranged to convert to false, while all other values\n  /// convert to true. This allows a boolean context to convert the result to\n  /// a binary flag indicating whether there is the possibility of aliasing.\n  NoAlias = 0,\n  /// The two locations may or may not alias. This is the least precise result.\n  MayAlias,\n  /// The two locations alias, but only due to a partial overlap.\n  PartialAlias,\n  /// The two locations precisely alias each other.\n  MustAlias,\n};\n\n/// << operator for AliasResult.\nraw_ostream &operator<<(raw_ostream &OS, AliasResult AR);\n\n/// Flags indicating whether a memory access modifies or references memory.\n///\n/// This is no access at all, a modification, a reference, or both\n/// a modification and a reference. These are specifically structured such that\n/// they form a three bit matrix and bit-tests for 'mod' or 'ref' or 'must'\n/// work with any of the possible values.\nenum class ModRefInfo : uint8_t {\n  /// Must is provided for completeness, but no routines will return only\n  /// Must today. See definition of Must below.\n  Must = 0,\n  /// The access may reference the value stored in memory,\n  /// a mustAlias relation was found, and no mayAlias or partialAlias found.\n  MustRef = 1,\n  /// The access may modify the value stored in memory,\n  /// a mustAlias relation was found, and no mayAlias or partialAlias found.\n  MustMod = 2,\n  /// The access may reference, modify or both the value stored in memory,\n  /// a mustAlias relation was found, and no mayAlias or partialAlias found.\n  MustModRef = MustRef | MustMod,\n  /// The access neither references nor modifies the value stored in memory.\n  NoModRef = 4,\n  /// The access may reference the value stored in memory.\n  Ref = NoModRef | MustRef,\n  /// The access may modify the value stored in memory.\n  Mod = NoModRef | MustMod,\n  /// The access may reference and may modify the value stored in memory.\n  ModRef = Ref | Mod,\n\n  /// About Must:\n  /// Must is set in a best effort manner.\n  /// We usually do not try our best to infer Must, instead it is merely\n  /// another piece of \"free\" information that is presented when available.\n  /// Must set means there was certainly a MustAlias found. For calls,\n  /// where multiple arguments are checked (argmemonly), this translates to\n  /// only MustAlias or NoAlias was found.\n  /// Must is not set for RAR accesses, even if the two locations must\n  /// alias. The reason is that two read accesses translate to an early return\n  /// of NoModRef. An additional alias check to set Must may be\n  /// expensive. Other cases may also not set Must(e.g. callCapturesBefore).\n  /// We refer to Must being *set* when the most significant bit is *cleared*.\n  /// Conversely we *clear* Must information by *setting* the Must bit to 1.\n};\n\nLLVM_NODISCARD inline bool isNoModRef(const ModRefInfo MRI) {\n  return (static_cast<int>(MRI) & static_cast<int>(ModRefInfo::MustModRef)) ==\n         static_cast<int>(ModRefInfo::Must);\n}\nLLVM_NODISCARD inline bool isModOrRefSet(const ModRefInfo MRI) {\n  return static_cast<int>(MRI) & static_cast<int>(ModRefInfo::MustModRef);\n}\nLLVM_NODISCARD inline bool isModAndRefSet(const ModRefInfo MRI) {\n  return (static_cast<int>(MRI) & static_cast<int>(ModRefInfo::MustModRef)) ==\n         static_cast<int>(ModRefInfo::MustModRef);\n}\nLLVM_NODISCARD inline bool isModSet(const ModRefInfo MRI) {\n  return static_cast<int>(MRI) & static_cast<int>(ModRefInfo::MustMod);\n}\nLLVM_NODISCARD inline bool isRefSet(const ModRefInfo MRI) {\n  return static_cast<int>(MRI) & static_cast<int>(ModRefInfo::MustRef);\n}\nLLVM_NODISCARD inline bool isMustSet(const ModRefInfo MRI) {\n  return !(static_cast<int>(MRI) & static_cast<int>(ModRefInfo::NoModRef));\n}\n\nLLVM_NODISCARD inline ModRefInfo setMod(const ModRefInfo MRI) {\n  return ModRefInfo(static_cast<int>(MRI) |\n                    static_cast<int>(ModRefInfo::MustMod));\n}\nLLVM_NODISCARD inline ModRefInfo setRef(const ModRefInfo MRI) {\n  return ModRefInfo(static_cast<int>(MRI) |\n                    static_cast<int>(ModRefInfo::MustRef));\n}\nLLVM_NODISCARD inline ModRefInfo setMust(const ModRefInfo MRI) {\n  return ModRefInfo(static_cast<int>(MRI) &\n                    static_cast<int>(ModRefInfo::MustModRef));\n}\nLLVM_NODISCARD inline ModRefInfo setModAndRef(const ModRefInfo MRI) {\n  return ModRefInfo(static_cast<int>(MRI) |\n                    static_cast<int>(ModRefInfo::MustModRef));\n}\nLLVM_NODISCARD inline ModRefInfo clearMod(const ModRefInfo MRI) {\n  return ModRefInfo(static_cast<int>(MRI) & static_cast<int>(ModRefInfo::Ref));\n}\nLLVM_NODISCARD inline ModRefInfo clearRef(const ModRefInfo MRI) {\n  return ModRefInfo(static_cast<int>(MRI) & static_cast<int>(ModRefInfo::Mod));\n}\nLLVM_NODISCARD inline ModRefInfo clearMust(const ModRefInfo MRI) {\n  return ModRefInfo(static_cast<int>(MRI) |\n                    static_cast<int>(ModRefInfo::NoModRef));\n}\nLLVM_NODISCARD inline ModRefInfo unionModRef(const ModRefInfo MRI1,\n                                             const ModRefInfo MRI2) {\n  return ModRefInfo(static_cast<int>(MRI1) | static_cast<int>(MRI2));\n}\nLLVM_NODISCARD inline ModRefInfo intersectModRef(const ModRefInfo MRI1,\n                                                 const ModRefInfo MRI2) {\n  return ModRefInfo(static_cast<int>(MRI1) & static_cast<int>(MRI2));\n}\n\n/// The locations at which a function might access memory.\n///\n/// These are primarily used in conjunction with the \\c AccessKind bits to\n/// describe both the nature of access and the locations of access for a\n/// function call.\nenum FunctionModRefLocation {\n  /// Base case is no access to memory.\n  FMRL_Nowhere = 0,\n  /// Access to memory via argument pointers.\n  FMRL_ArgumentPointees = 8,\n  /// Memory that is inaccessible via LLVM IR.\n  FMRL_InaccessibleMem = 16,\n  /// Access to any memory.\n  FMRL_Anywhere = 32 | FMRL_InaccessibleMem | FMRL_ArgumentPointees\n};\n\n/// Summary of how a function affects memory in the program.\n///\n/// Loads from constant globals are not considered memory accesses for this\n/// interface. Also, functions may freely modify stack space local to their\n/// invocation without having to report it through these interfaces.\nenum FunctionModRefBehavior {\n  /// This function does not perform any non-local loads or stores to memory.\n  ///\n  /// This property corresponds to the GCC 'const' attribute.\n  /// This property corresponds to the LLVM IR 'readnone' attribute.\n  /// This property corresponds to the IntrNoMem LLVM intrinsic flag.\n  FMRB_DoesNotAccessMemory =\n      FMRL_Nowhere | static_cast<int>(ModRefInfo::NoModRef),\n\n  /// The only memory references in this function (if it has any) are\n  /// non-volatile loads from objects pointed to by its pointer-typed\n  /// arguments, with arbitrary offsets.\n  ///\n  /// This property corresponds to the combination of the IntrReadMem\n  /// and IntrArgMemOnly LLVM intrinsic flags.\n  FMRB_OnlyReadsArgumentPointees =\n      FMRL_ArgumentPointees | static_cast<int>(ModRefInfo::Ref),\n\n  /// The only memory references in this function (if it has any) are\n  /// non-volatile stores from objects pointed to by its pointer-typed\n  /// arguments, with arbitrary offsets.\n  ///\n  /// This property corresponds to the combination of the IntrWriteMem\n  /// and IntrArgMemOnly LLVM intrinsic flags.\n  FMRB_OnlyWritesArgumentPointees =\n      FMRL_ArgumentPointees | static_cast<int>(ModRefInfo::Mod),\n\n  /// The only memory references in this function (if it has any) are\n  /// non-volatile loads and stores from objects pointed to by its\n  /// pointer-typed arguments, with arbitrary offsets.\n  ///\n  /// This property corresponds to the IntrArgMemOnly LLVM intrinsic flag.\n  FMRB_OnlyAccessesArgumentPointees =\n      FMRL_ArgumentPointees | static_cast<int>(ModRefInfo::ModRef),\n\n  /// The only memory references in this function (if it has any) are\n  /// reads of memory that is otherwise inaccessible via LLVM IR.\n  ///\n  /// This property corresponds to the LLVM IR inaccessiblememonly attribute.\n  FMRB_OnlyReadsInaccessibleMem =\n      FMRL_InaccessibleMem | static_cast<int>(ModRefInfo::Ref),\n\n  /// The only memory references in this function (if it has any) are\n  /// writes to memory that is otherwise inaccessible via LLVM IR.\n  ///\n  /// This property corresponds to the LLVM IR inaccessiblememonly attribute.\n  FMRB_OnlyWritesInaccessibleMem =\n      FMRL_InaccessibleMem | static_cast<int>(ModRefInfo::Mod),\n\n  /// The only memory references in this function (if it has any) are\n  /// references of memory that is otherwise inaccessible via LLVM IR.\n  ///\n  /// This property corresponds to the LLVM IR inaccessiblememonly attribute.\n  FMRB_OnlyAccessesInaccessibleMem =\n      FMRL_InaccessibleMem | static_cast<int>(ModRefInfo::ModRef),\n\n  /// The function may perform non-volatile loads from objects pointed\n  /// to by its pointer-typed arguments, with arbitrary offsets, and\n  /// it may also perform loads of memory that is otherwise\n  /// inaccessible via LLVM IR.\n  ///\n  /// This property corresponds to the LLVM IR\n  /// inaccessiblemem_or_argmemonly attribute.\n  FMRB_OnlyReadsInaccessibleOrArgMem = FMRL_InaccessibleMem |\n                                       FMRL_ArgumentPointees |\n                                       static_cast<int>(ModRefInfo::Ref),\n\n  /// The function may perform non-volatile stores to objects pointed\n  /// to by its pointer-typed arguments, with arbitrary offsets, and\n  /// it may also perform stores of memory that is otherwise\n  /// inaccessible via LLVM IR.\n  ///\n  /// This property corresponds to the LLVM IR\n  /// inaccessiblemem_or_argmemonly attribute.\n  FMRB_OnlyWritesInaccessibleOrArgMem = FMRL_InaccessibleMem |\n                                        FMRL_ArgumentPointees |\n                                        static_cast<int>(ModRefInfo::Mod),\n\n  /// The function may perform non-volatile loads and stores of objects\n  /// pointed to by its pointer-typed arguments, with arbitrary offsets, and\n  /// it may also perform loads and stores of memory that is otherwise\n  /// inaccessible via LLVM IR.\n  ///\n  /// This property corresponds to the LLVM IR\n  /// inaccessiblemem_or_argmemonly attribute.\n  FMRB_OnlyAccessesInaccessibleOrArgMem = FMRL_InaccessibleMem |\n                                          FMRL_ArgumentPointees |\n                                          static_cast<int>(ModRefInfo::ModRef),\n\n  /// This function does not perform any non-local stores or volatile loads,\n  /// but may read from any memory location.\n  ///\n  /// This property corresponds to the GCC 'pure' attribute.\n  /// This property corresponds to the LLVM IR 'readonly' attribute.\n  /// This property corresponds to the IntrReadMem LLVM intrinsic flag.\n  FMRB_OnlyReadsMemory = FMRL_Anywhere | static_cast<int>(ModRefInfo::Ref),\n\n  // This function does not read from memory anywhere, but may write to any\n  // memory location.\n  //\n  // This property corresponds to the LLVM IR 'writeonly' attribute.\n  // This property corresponds to the IntrWriteMem LLVM intrinsic flag.\n  FMRB_OnlyWritesMemory = FMRL_Anywhere | static_cast<int>(ModRefInfo::Mod),\n\n  /// This indicates that the function could not be classified into one of the\n  /// behaviors above.\n  FMRB_UnknownModRefBehavior =\n      FMRL_Anywhere | static_cast<int>(ModRefInfo::ModRef)\n};\n\n// Wrapper method strips bits significant only in FunctionModRefBehavior,\n// to obtain a valid ModRefInfo. The benefit of using the wrapper is that if\n// ModRefInfo enum changes, the wrapper can be updated to & with the new enum\n// entry with all bits set to 1.\nLLVM_NODISCARD inline ModRefInfo\ncreateModRefInfo(const FunctionModRefBehavior FMRB) {\n  return ModRefInfo(FMRB & static_cast<int>(ModRefInfo::ModRef));\n}\n\n/// This class stores info we want to provide to or retain within an alias\n/// query. By default, the root query is stateless and starts with a freshly\n/// constructed info object. Specific alias analyses can use this query info to\n/// store per-query state that is important for recursive or nested queries to\n/// avoid recomputing. To enable preserving this state across multiple queries\n/// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.\n/// The information stored in an `AAQueryInfo` is currently limitted to the\n/// caches used by BasicAA, but can further be extended to fit other AA needs.\nclass AAQueryInfo {\n  /// Storage for estimated relative offsets between two partially aliased\n  /// values. Used to optimize out redundant parts of loads/stores (in GVN/DSE).\n  /// These users cannot process quite complicated addresses (e.g. GEPs with\n  /// non-constant offsets). Used by BatchAAResults only.\n  bool CacheOffsets = false;\n  SmallDenseMap<std::pair<std::pair<const Value *, const Value *>,\n                          std::pair<uint64_t, uint64_t>>,\n                int64_t, 4>\n      ClobberOffsets;\n\npublic:\n  using LocPair = std::pair<MemoryLocation, MemoryLocation>;\n  struct CacheEntry {\n    AliasResult Result;\n    /// Number of times a NoAlias assumption has been used.\n    /// 0 for assumptions that have not been used, -1 for definitive results.\n    int NumAssumptionUses;\n    /// Whether this is a definitive (non-assumption) result.\n    bool isDefinitive() const { return NumAssumptionUses < 0; }\n  };\n  using AliasCacheT = SmallDenseMap<LocPair, CacheEntry, 8>;\n  AliasCacheT AliasCache;\n\n  using IsCapturedCacheT = SmallDenseMap<const Value *, bool, 8>;\n  IsCapturedCacheT IsCapturedCache;\n\n  /// Query depth used to distinguish recursive queries.\n  unsigned Depth = 0;\n\n  /// How many active NoAlias assumption uses there are.\n  int NumAssumptionUses = 0;\n\n  /// Location pairs for which an assumption based result is currently stored.\n  /// Used to remove all potentially incorrect results from the cache if an\n  /// assumption is disproven.\n  SmallVector<AAQueryInfo::LocPair, 4> AssumptionBasedResults;\n\n  AAQueryInfo(bool CacheOffsets = false)\n      : CacheOffsets(CacheOffsets), ClobberOffsets(), AliasCache(),\n        IsCapturedCache() {}\n\n  /// Create a new AAQueryInfo based on this one, but with the cache cleared.\n  /// This is used for recursive queries across phis, where cache results may\n  /// not be valid.\n  AAQueryInfo withEmptyCache() {\n    AAQueryInfo NewAAQI;\n    NewAAQI.Depth = Depth;\n    return NewAAQI;\n  }\n\n  Optional<int64_t> getClobberOffset(const Value *Ptr1, const Value *Ptr2,\n                                     uint64_t Size1, uint64_t Size2) const {\n    assert(CacheOffsets && \"Clobber offset cached in batch mode only!\");\n    const bool Swapped = Ptr1 > Ptr2;\n    if (Swapped) {\n      std::swap(Ptr1, Ptr2);\n      std::swap(Size1, Size2);\n    }\n    const auto IOff = ClobberOffsets.find({{Ptr1, Ptr2}, {Size1, Size2}});\n    if (IOff != ClobberOffsets.end())\n      return Swapped ? -IOff->second : IOff->second;\n    return None;\n  }\n\n  void setClobberOffset(const Value *Ptr1, const Value *Ptr2, uint64_t Size1,\n                        uint64_t Size2, int64_t Offset) {\n    // Cache offset for batch mode only.\n    if (!CacheOffsets)\n      return;\n    if (Ptr1 > Ptr2) {\n      std::swap(Ptr1, Ptr2);\n      std::swap(Size1, Size2);\n      Offset = -Offset;\n    }\n    ClobberOffsets[{{Ptr1, Ptr2}, {Size1, Size2}}] = Offset;\n  }\n};\n\nclass BatchAAResults;\n\nclass AAResults {\npublic:\n  // Make these results default constructable and movable. We have to spell\n  // these out because MSVC won't synthesize them.\n  AAResults(const TargetLibraryInfo &TLI) : TLI(TLI) {}\n  AAResults(AAResults &&Arg);\n  ~AAResults();\n\n  /// Register a specific AA result.\n  template <typename AAResultT> void addAAResult(AAResultT &AAResult) {\n    // FIXME: We should use a much lighter weight system than the usual\n    // polymorphic pattern because we don't own AAResult. It should\n    // ideally involve two pointers and no separate allocation.\n    AAs.emplace_back(new Model<AAResultT>(AAResult, *this));\n  }\n\n  /// Register a function analysis ID that the results aggregation depends on.\n  ///\n  /// This is used in the new pass manager to implement the invalidation logic\n  /// where we must invalidate the results aggregation if any of our component\n  /// analyses become invalid.\n  void addAADependencyID(AnalysisKey *ID) { AADeps.push_back(ID); }\n\n  /// Handle invalidation events in the new pass manager.\n  ///\n  /// The aggregation is invalidated if any of the underlying analyses is\n  /// invalidated.\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &Inv);\n\n  //===--------------------------------------------------------------------===//\n  /// \\name Alias Queries\n  /// @{\n\n  /// The main low level interface to the alias analysis implementation.\n  /// Returns an AliasResult indicating whether the two pointers are aliased to\n  /// each other. This is the interface that must be implemented by specific\n  /// alias analysis implementations.\n  AliasResult alias(const MemoryLocation &LocA, const MemoryLocation &LocB);\n\n  /// A convenience wrapper around the primary \\c alias interface.\n  AliasResult alias(const Value *V1, LocationSize V1Size, const Value *V2,\n                    LocationSize V2Size) {\n    return alias(MemoryLocation(V1, V1Size), MemoryLocation(V2, V2Size));\n  }\n\n  /// A convenience wrapper around the primary \\c alias interface.\n  AliasResult alias(const Value *V1, const Value *V2) {\n    return alias(MemoryLocation::getBeforeOrAfter(V1),\n                 MemoryLocation::getBeforeOrAfter(V2));\n  }\n\n  /// A trivial helper function to check to see if the specified pointers are\n  /// no-alias.\n  bool isNoAlias(const MemoryLocation &LocA, const MemoryLocation &LocB) {\n    return alias(LocA, LocB) == NoAlias;\n  }\n\n  /// A convenience wrapper around the \\c isNoAlias helper interface.\n  bool isNoAlias(const Value *V1, LocationSize V1Size, const Value *V2,\n                 LocationSize V2Size) {\n    return isNoAlias(MemoryLocation(V1, V1Size), MemoryLocation(V2, V2Size));\n  }\n\n  /// A convenience wrapper around the \\c isNoAlias helper interface.\n  bool isNoAlias(const Value *V1, const Value *V2) {\n    return isNoAlias(MemoryLocation::getBeforeOrAfter(V1),\n                     MemoryLocation::getBeforeOrAfter(V2));\n  }\n\n  /// A trivial helper function to check to see if the specified pointers are\n  /// must-alias.\n  bool isMustAlias(const MemoryLocation &LocA, const MemoryLocation &LocB) {\n    return alias(LocA, LocB) == MustAlias;\n  }\n\n  /// A convenience wrapper around the \\c isMustAlias helper interface.\n  bool isMustAlias(const Value *V1, const Value *V2) {\n    return alias(V1, LocationSize::precise(1), V2, LocationSize::precise(1)) ==\n           MustAlias;\n  }\n\n  /// Checks whether the given location points to constant memory, or if\n  /// \\p OrLocal is true whether it points to a local alloca.\n  bool pointsToConstantMemory(const MemoryLocation &Loc, bool OrLocal = false);\n\n  /// A convenience wrapper around the primary \\c pointsToConstantMemory\n  /// interface.\n  bool pointsToConstantMemory(const Value *P, bool OrLocal = false) {\n    return pointsToConstantMemory(MemoryLocation::getBeforeOrAfter(P), OrLocal);\n  }\n\n  /// @}\n  //===--------------------------------------------------------------------===//\n  /// \\name Simple mod/ref information\n  /// @{\n\n  /// Get the ModRef info associated with a pointer argument of a call. The\n  /// result's bits are set to indicate the allowed aliasing ModRef kinds. Note\n  /// that these bits do not necessarily account for the overall behavior of\n  /// the function, but rather only provide additional per-argument\n  /// information. This never sets ModRefInfo::Must.\n  ModRefInfo getArgModRefInfo(const CallBase *Call, unsigned ArgIdx);\n\n  /// Return the behavior of the given call site.\n  FunctionModRefBehavior getModRefBehavior(const CallBase *Call);\n\n  /// Return the behavior when calling the given function.\n  FunctionModRefBehavior getModRefBehavior(const Function *F);\n\n  /// Checks if the specified call is known to never read or write memory.\n  ///\n  /// Note that if the call only reads from known-constant memory, it is also\n  /// legal to return true. Also, calls that unwind the stack are legal for\n  /// this predicate.\n  ///\n  /// Many optimizations (such as CSE and LICM) can be performed on such calls\n  /// without worrying about aliasing properties, and many calls have this\n  /// property (e.g. calls to 'sin' and 'cos').\n  ///\n  /// This property corresponds to the GCC 'const' attribute.\n  bool doesNotAccessMemory(const CallBase *Call) {\n    return getModRefBehavior(Call) == FMRB_DoesNotAccessMemory;\n  }\n\n  /// Checks if the specified function is known to never read or write memory.\n  ///\n  /// Note that if the function only reads from known-constant memory, it is\n  /// also legal to return true. Also, function that unwind the stack are legal\n  /// for this predicate.\n  ///\n  /// Many optimizations (such as CSE and LICM) can be performed on such calls\n  /// to such functions without worrying about aliasing properties, and many\n  /// functions have this property (e.g. 'sin' and 'cos').\n  ///\n  /// This property corresponds to the GCC 'const' attribute.\n  bool doesNotAccessMemory(const Function *F) {\n    return getModRefBehavior(F) == FMRB_DoesNotAccessMemory;\n  }\n\n  /// Checks if the specified call is known to only read from non-volatile\n  /// memory (or not access memory at all).\n  ///\n  /// Calls that unwind the stack are legal for this predicate.\n  ///\n  /// This property allows many common optimizations to be performed in the\n  /// absence of interfering store instructions, such as CSE of strlen calls.\n  ///\n  /// This property corresponds to the GCC 'pure' attribute.\n  bool onlyReadsMemory(const CallBase *Call) {\n    return onlyReadsMemory(getModRefBehavior(Call));\n  }\n\n  /// Checks if the specified function is known to only read from non-volatile\n  /// memory (or not access memory at all).\n  ///\n  /// Functions that unwind the stack are legal for this predicate.\n  ///\n  /// This property allows many common optimizations to be performed in the\n  /// absence of interfering store instructions, such as CSE of strlen calls.\n  ///\n  /// This property corresponds to the GCC 'pure' attribute.\n  bool onlyReadsMemory(const Function *F) {\n    return onlyReadsMemory(getModRefBehavior(F));\n  }\n\n  /// Checks if functions with the specified behavior are known to only read\n  /// from non-volatile memory (or not access memory at all).\n  static bool onlyReadsMemory(FunctionModRefBehavior MRB) {\n    return !isModSet(createModRefInfo(MRB));\n  }\n\n  /// Checks if functions with the specified behavior are known to only write\n  /// memory (or not access memory at all).\n  static bool doesNotReadMemory(FunctionModRefBehavior MRB) {\n    return !isRefSet(createModRefInfo(MRB));\n  }\n\n  /// Checks if functions with the specified behavior are known to read and\n  /// write at most from objects pointed to by their pointer-typed arguments\n  /// (with arbitrary offsets).\n  static bool onlyAccessesArgPointees(FunctionModRefBehavior MRB) {\n    return !((unsigned)MRB & FMRL_Anywhere & ~FMRL_ArgumentPointees);\n  }\n\n  /// Checks if functions with the specified behavior are known to potentially\n  /// read or write from objects pointed to be their pointer-typed arguments\n  /// (with arbitrary offsets).\n  static bool doesAccessArgPointees(FunctionModRefBehavior MRB) {\n    return isModOrRefSet(createModRefInfo(MRB)) &&\n           ((unsigned)MRB & FMRL_ArgumentPointees);\n  }\n\n  /// Checks if functions with the specified behavior are known to read and\n  /// write at most from memory that is inaccessible from LLVM IR.\n  static bool onlyAccessesInaccessibleMem(FunctionModRefBehavior MRB) {\n    return !((unsigned)MRB & FMRL_Anywhere & ~FMRL_InaccessibleMem);\n  }\n\n  /// Checks if functions with the specified behavior are known to potentially\n  /// read or write from memory that is inaccessible from LLVM IR.\n  static bool doesAccessInaccessibleMem(FunctionModRefBehavior MRB) {\n    return isModOrRefSet(createModRefInfo(MRB)) &&\n             ((unsigned)MRB & FMRL_InaccessibleMem);\n  }\n\n  /// Checks if functions with the specified behavior are known to read and\n  /// write at most from memory that is inaccessible from LLVM IR or objects\n  /// pointed to by their pointer-typed arguments (with arbitrary offsets).\n  static bool onlyAccessesInaccessibleOrArgMem(FunctionModRefBehavior MRB) {\n    return !((unsigned)MRB & FMRL_Anywhere &\n             ~(FMRL_InaccessibleMem | FMRL_ArgumentPointees));\n  }\n\n  /// getModRefInfo (for call sites) - Return information about whether\n  /// a particular call site modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const CallBase *Call, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for call sites) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const CallBase *Call, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(Call, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for loads) - Return information about whether\n  /// a particular load modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const LoadInst *L, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for loads) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const LoadInst *L, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(L, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for stores) - Return information about whether\n  /// a particular store modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const StoreInst *S, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for stores) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const StoreInst *S, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(S, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for fences) - Return information about whether\n  /// a particular store modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const FenceInst *S, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for fences) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const FenceInst *S, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(S, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for cmpxchges) - Return information about whether\n  /// a particular cmpxchg modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const AtomicCmpXchgInst *CX,\n                           const MemoryLocation &Loc);\n\n  /// getModRefInfo (for cmpxchges) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const AtomicCmpXchgInst *CX, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(CX, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for atomicrmws) - Return information about whether\n  /// a particular atomicrmw modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const AtomicRMWInst *RMW, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for atomicrmws) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const AtomicRMWInst *RMW, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(RMW, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for va_args) - Return information about whether\n  /// a particular va_arg modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const VAArgInst *I, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for va_args) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const VAArgInst *I, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(I, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for catchpads) - Return information about whether\n  /// a particular catchpad modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const CatchPadInst *I, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for catchpads) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const CatchPadInst *I, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(I, MemoryLocation(P, Size));\n  }\n\n  /// getModRefInfo (for catchrets) - Return information about whether\n  /// a particular catchret modifies or reads the specified memory location.\n  ModRefInfo getModRefInfo(const CatchReturnInst *I, const MemoryLocation &Loc);\n\n  /// getModRefInfo (for catchrets) - A convenience wrapper.\n  ModRefInfo getModRefInfo(const CatchReturnInst *I, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(I, MemoryLocation(P, Size));\n  }\n\n  /// Check whether or not an instruction may read or write the optionally\n  /// specified memory location.\n  ///\n  ///\n  /// An instruction that doesn't read or write memory may be trivially LICM'd\n  /// for example.\n  ///\n  /// For function calls, this delegates to the alias-analysis specific\n  /// call-site mod-ref behavior queries. Otherwise it delegates to the specific\n  /// helpers above.\n  ModRefInfo getModRefInfo(const Instruction *I,\n                           const Optional<MemoryLocation> &OptLoc) {\n    AAQueryInfo AAQIP;\n    return getModRefInfo(I, OptLoc, AAQIP);\n  }\n\n  /// A convenience wrapper for constructing the memory location.\n  ModRefInfo getModRefInfo(const Instruction *I, const Value *P,\n                           LocationSize Size) {\n    return getModRefInfo(I, MemoryLocation(P, Size));\n  }\n\n  /// Return information about whether a call and an instruction may refer to\n  /// the same memory locations.\n  ModRefInfo getModRefInfo(Instruction *I, const CallBase *Call);\n\n  /// Return information about whether two call sites may refer to the same set\n  /// of memory locations. See the AA documentation for details:\n  ///   http://llvm.org/docs/AliasAnalysis.html#ModRefInfo\n  ModRefInfo getModRefInfo(const CallBase *Call1, const CallBase *Call2);\n\n  /// Return information about whether a particular call site modifies\n  /// or reads the specified memory location \\p MemLoc before instruction \\p I\n  /// in a BasicBlock.\n  /// Early exits in callCapturesBefore may lead to ModRefInfo::Must not being\n  /// set.\n  ModRefInfo callCapturesBefore(const Instruction *I,\n                                const MemoryLocation &MemLoc, DominatorTree *DT);\n\n  /// A convenience wrapper to synthesize a memory location.\n  ModRefInfo callCapturesBefore(const Instruction *I, const Value *P,\n                                LocationSize Size, DominatorTree *DT) {\n    return callCapturesBefore(I, MemoryLocation(P, Size), DT);\n  }\n\n  /// @}\n  //===--------------------------------------------------------------------===//\n  /// \\name Higher level methods for querying mod/ref information.\n  /// @{\n\n  /// Check if it is possible for execution of the specified basic block to\n  /// modify the location Loc.\n  bool canBasicBlockModify(const BasicBlock &BB, const MemoryLocation &Loc);\n\n  /// A convenience wrapper synthesizing a memory location.\n  bool canBasicBlockModify(const BasicBlock &BB, const Value *P,\n                           LocationSize Size) {\n    return canBasicBlockModify(BB, MemoryLocation(P, Size));\n  }\n\n  /// Check if it is possible for the execution of the specified instructions\n  /// to mod\\ref (according to the mode) the location Loc.\n  ///\n  /// The instructions to consider are all of the instructions in the range of\n  /// [I1,I2] INCLUSIVE. I1 and I2 must be in the same basic block.\n  bool canInstructionRangeModRef(const Instruction &I1, const Instruction &I2,\n                                 const MemoryLocation &Loc,\n                                 const ModRefInfo Mode);\n\n  /// A convenience wrapper synthesizing a memory location.\n  bool canInstructionRangeModRef(const Instruction &I1, const Instruction &I2,\n                                 const Value *Ptr, LocationSize Size,\n                                 const ModRefInfo Mode) {\n    return canInstructionRangeModRef(I1, I2, MemoryLocation(Ptr, Size), Mode);\n  }\n\nprivate:\n  AliasResult alias(const MemoryLocation &LocA, const MemoryLocation &LocB,\n                    AAQueryInfo &AAQI);\n  bool pointsToConstantMemory(const MemoryLocation &Loc, AAQueryInfo &AAQI,\n                              bool OrLocal = false);\n  ModRefInfo getModRefInfo(Instruction *I, const CallBase *Call2,\n                           AAQueryInfo &AAQIP);\n  ModRefInfo getModRefInfo(const CallBase *Call, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const CallBase *Call1, const CallBase *Call2,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const VAArgInst *V, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const LoadInst *L, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const StoreInst *S, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const FenceInst *S, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const AtomicCmpXchgInst *CX,\n                           const MemoryLocation &Loc, AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const AtomicRMWInst *RMW, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const CatchPadInst *I, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const CatchReturnInst *I, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI);\n  ModRefInfo getModRefInfo(const Instruction *I,\n                           const Optional<MemoryLocation> &OptLoc,\n                           AAQueryInfo &AAQIP);\n\n  class Concept;\n\n  template <typename T> class Model;\n\n  template <typename T> friend class AAResultBase;\n\n  const TargetLibraryInfo &TLI;\n\n  std::vector<std::unique_ptr<Concept>> AAs;\n\n  std::vector<AnalysisKey *> AADeps;\n\n  friend class BatchAAResults;\n};\n\n/// This class is a wrapper over an AAResults, and it is intended to be used\n/// only when there are no IR changes inbetween queries. BatchAAResults is\n/// reusing the same `AAQueryInfo` to preserve the state across queries,\n/// esentially making AA work in \"batch mode\". The internal state cannot be\n/// cleared, so to go \"out-of-batch-mode\", the user must either use AAResults,\n/// or create a new BatchAAResults.\nclass BatchAAResults {\n  AAResults &AA;\n  AAQueryInfo AAQI;\n\npublic:\n  BatchAAResults(AAResults &AAR, bool CacheOffsets = false)\n      : AA(AAR), AAQI(CacheOffsets) {}\n  AliasResult alias(const MemoryLocation &LocA, const MemoryLocation &LocB) {\n    return AA.alias(LocA, LocB, AAQI);\n  }\n  bool pointsToConstantMemory(const MemoryLocation &Loc, bool OrLocal = false) {\n    return AA.pointsToConstantMemory(Loc, AAQI, OrLocal);\n  }\n  ModRefInfo getModRefInfo(const CallBase *Call, const MemoryLocation &Loc) {\n    return AA.getModRefInfo(Call, Loc, AAQI);\n  }\n  ModRefInfo getModRefInfo(const CallBase *Call1, const CallBase *Call2) {\n    return AA.getModRefInfo(Call1, Call2, AAQI);\n  }\n  ModRefInfo getModRefInfo(const Instruction *I,\n                           const Optional<MemoryLocation> &OptLoc) {\n    return AA.getModRefInfo(I, OptLoc, AAQI);\n  }\n  ModRefInfo getModRefInfo(Instruction *I, const CallBase *Call2) {\n    return AA.getModRefInfo(I, Call2, AAQI);\n  }\n  ModRefInfo getArgModRefInfo(const CallBase *Call, unsigned ArgIdx) {\n    return AA.getArgModRefInfo(Call, ArgIdx);\n  }\n  FunctionModRefBehavior getModRefBehavior(const CallBase *Call) {\n    return AA.getModRefBehavior(Call);\n  }\n  bool isMustAlias(const MemoryLocation &LocA, const MemoryLocation &LocB) {\n    return alias(LocA, LocB) == MustAlias;\n  }\n  bool isMustAlias(const Value *V1, const Value *V2) {\n    return alias(MemoryLocation(V1, LocationSize::precise(1)),\n                 MemoryLocation(V2, LocationSize::precise(1))) == MustAlias;\n  }\n  Optional<int64_t> getClobberOffset(const MemoryLocation &LocA,\n                                     const MemoryLocation &LocB) const;\n};\n\n/// Temporary typedef for legacy code that uses a generic \\c AliasAnalysis\n/// pointer or reference.\nusing AliasAnalysis = AAResults;\n\n/// A private abstract base class describing the concept of an individual alias\n/// analysis implementation.\n///\n/// This interface is implemented by any \\c Model instantiation. It is also the\n/// interface which a type used to instantiate the model must provide.\n///\n/// All of these methods model methods by the same name in the \\c\n/// AAResults class. Only differences and specifics to how the\n/// implementations are called are documented here.\nclass AAResults::Concept {\npublic:\n  virtual ~Concept() = 0;\n\n  /// An update API used internally by the AAResults to provide\n  /// a handle back to the top level aggregation.\n  virtual void setAAResults(AAResults *NewAAR) = 0;\n\n  //===--------------------------------------------------------------------===//\n  /// \\name Alias Queries\n  /// @{\n\n  /// The main low level interface to the alias analysis implementation.\n  /// Returns an AliasResult indicating whether the two pointers are aliased to\n  /// each other. This is the interface that must be implemented by specific\n  /// alias analysis implementations.\n  virtual AliasResult alias(const MemoryLocation &LocA,\n                            const MemoryLocation &LocB, AAQueryInfo &AAQI) = 0;\n\n  /// Checks whether the given location points to constant memory, or if\n  /// \\p OrLocal is true whether it points to a local alloca.\n  virtual bool pointsToConstantMemory(const MemoryLocation &Loc,\n                                      AAQueryInfo &AAQI, bool OrLocal) = 0;\n\n  /// @}\n  //===--------------------------------------------------------------------===//\n  /// \\name Simple mod/ref information\n  /// @{\n\n  /// Get the ModRef info associated with a pointer argument of a callsite. The\n  /// result's bits are set to indicate the allowed aliasing ModRef kinds. Note\n  /// that these bits do not necessarily account for the overall behavior of\n  /// the function, but rather only provide additional per-argument\n  /// information.\n  virtual ModRefInfo getArgModRefInfo(const CallBase *Call,\n                                      unsigned ArgIdx) = 0;\n\n  /// Return the behavior of the given call site.\n  virtual FunctionModRefBehavior getModRefBehavior(const CallBase *Call) = 0;\n\n  /// Return the behavior when calling the given function.\n  virtual FunctionModRefBehavior getModRefBehavior(const Function *F) = 0;\n\n  /// getModRefInfo (for call sites) - Return information about whether\n  /// a particular call site modifies or reads the specified memory location.\n  virtual ModRefInfo getModRefInfo(const CallBase *Call,\n                                   const MemoryLocation &Loc,\n                                   AAQueryInfo &AAQI) = 0;\n\n  /// Return information about whether two call sites may refer to the same set\n  /// of memory locations. See the AA documentation for details:\n  ///   http://llvm.org/docs/AliasAnalysis.html#ModRefInfo\n  virtual ModRefInfo getModRefInfo(const CallBase *Call1, const CallBase *Call2,\n                                   AAQueryInfo &AAQI) = 0;\n\n  /// @}\n};\n\n/// A private class template which derives from \\c Concept and wraps some other\n/// type.\n///\n/// This models the concept by directly forwarding each interface point to the\n/// wrapped type which must implement a compatible interface. This provides\n/// a type erased binding.\ntemplate <typename AAResultT> class AAResults::Model final : public Concept {\n  AAResultT &Result;\n\npublic:\n  explicit Model(AAResultT &Result, AAResults &AAR) : Result(Result) {\n    Result.setAAResults(&AAR);\n  }\n  ~Model() override = default;\n\n  void setAAResults(AAResults *NewAAR) override { Result.setAAResults(NewAAR); }\n\n  AliasResult alias(const MemoryLocation &LocA, const MemoryLocation &LocB,\n                    AAQueryInfo &AAQI) override {\n    return Result.alias(LocA, LocB, AAQI);\n  }\n\n  bool pointsToConstantMemory(const MemoryLocation &Loc, AAQueryInfo &AAQI,\n                              bool OrLocal) override {\n    return Result.pointsToConstantMemory(Loc, AAQI, OrLocal);\n  }\n\n  ModRefInfo getArgModRefInfo(const CallBase *Call, unsigned ArgIdx) override {\n    return Result.getArgModRefInfo(Call, ArgIdx);\n  }\n\n  FunctionModRefBehavior getModRefBehavior(const CallBase *Call) override {\n    return Result.getModRefBehavior(Call);\n  }\n\n  FunctionModRefBehavior getModRefBehavior(const Function *F) override {\n    return Result.getModRefBehavior(F);\n  }\n\n  ModRefInfo getModRefInfo(const CallBase *Call, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI) override {\n    return Result.getModRefInfo(Call, Loc, AAQI);\n  }\n\n  ModRefInfo getModRefInfo(const CallBase *Call1, const CallBase *Call2,\n                           AAQueryInfo &AAQI) override {\n    return Result.getModRefInfo(Call1, Call2, AAQI);\n  }\n};\n\n/// A CRTP-driven \"mixin\" base class to help implement the function alias\n/// analysis results concept.\n///\n/// Because of the nature of many alias analysis implementations, they often\n/// only implement a subset of the interface. This base class will attempt to\n/// implement the remaining portions of the interface in terms of simpler forms\n/// of the interface where possible, and otherwise provide conservatively\n/// correct fallback implementations.\n///\n/// Implementors of an alias analysis should derive from this CRTP, and then\n/// override specific methods that they wish to customize. There is no need to\n/// use virtual anywhere, the CRTP base class does static dispatch to the\n/// derived type passed into it.\ntemplate <typename DerivedT> class AAResultBase {\n  // Expose some parts of the interface only to the AAResults::Model\n  // for wrapping. Specifically, this allows the model to call our\n  // setAAResults method without exposing it as a fully public API.\n  friend class AAResults::Model<DerivedT>;\n\n  /// A pointer to the AAResults object that this AAResult is\n  /// aggregated within. May be null if not aggregated.\n  AAResults *AAR = nullptr;\n\n  /// Helper to dispatch calls back through the derived type.\n  DerivedT &derived() { return static_cast<DerivedT &>(*this); }\n\n  /// A setter for the AAResults pointer, which is used to satisfy the\n  /// AAResults::Model contract.\n  void setAAResults(AAResults *NewAAR) { AAR = NewAAR; }\n\nprotected:\n  /// This proxy class models a common pattern where we delegate to either the\n  /// top-level \\c AAResults aggregation if one is registered, or to the\n  /// current result if none are registered.\n  class AAResultsProxy {\n    AAResults *AAR;\n    DerivedT &CurrentResult;\n\n  public:\n    AAResultsProxy(AAResults *AAR, DerivedT &CurrentResult)\n        : AAR(AAR), CurrentResult(CurrentResult) {}\n\n    AliasResult alias(const MemoryLocation &LocA, const MemoryLocation &LocB,\n                      AAQueryInfo &AAQI) {\n      return AAR ? AAR->alias(LocA, LocB, AAQI)\n                 : CurrentResult.alias(LocA, LocB, AAQI);\n    }\n\n    bool pointsToConstantMemory(const MemoryLocation &Loc, AAQueryInfo &AAQI,\n                                bool OrLocal) {\n      return AAR ? AAR->pointsToConstantMemory(Loc, AAQI, OrLocal)\n                 : CurrentResult.pointsToConstantMemory(Loc, AAQI, OrLocal);\n    }\n\n    ModRefInfo getArgModRefInfo(const CallBase *Call, unsigned ArgIdx) {\n      return AAR ? AAR->getArgModRefInfo(Call, ArgIdx)\n                 : CurrentResult.getArgModRefInfo(Call, ArgIdx);\n    }\n\n    FunctionModRefBehavior getModRefBehavior(const CallBase *Call) {\n      return AAR ? AAR->getModRefBehavior(Call)\n                 : CurrentResult.getModRefBehavior(Call);\n    }\n\n    FunctionModRefBehavior getModRefBehavior(const Function *F) {\n      return AAR ? AAR->getModRefBehavior(F) : CurrentResult.getModRefBehavior(F);\n    }\n\n    ModRefInfo getModRefInfo(const CallBase *Call, const MemoryLocation &Loc,\n                             AAQueryInfo &AAQI) {\n      return AAR ? AAR->getModRefInfo(Call, Loc, AAQI)\n                 : CurrentResult.getModRefInfo(Call, Loc, AAQI);\n    }\n\n    ModRefInfo getModRefInfo(const CallBase *Call1, const CallBase *Call2,\n                             AAQueryInfo &AAQI) {\n      return AAR ? AAR->getModRefInfo(Call1, Call2, AAQI)\n                 : CurrentResult.getModRefInfo(Call1, Call2, AAQI);\n    }\n  };\n\n  explicit AAResultBase() = default;\n\n  // Provide all the copy and move constructors so that derived types aren't\n  // constrained.\n  AAResultBase(const AAResultBase &Arg) {}\n  AAResultBase(AAResultBase &&Arg) {}\n\n  /// Get a proxy for the best AA result set to query at this time.\n  ///\n  /// When this result is part of a larger aggregation, this will proxy to that\n  /// aggregation. When this result is used in isolation, it will just delegate\n  /// back to the derived class's implementation.\n  ///\n  /// Note that callers of this need to take considerable care to not cause\n  /// performance problems when they use this routine, in the case of a large\n  /// number of alias analyses being aggregated, it can be expensive to walk\n  /// back across the chain.\n  AAResultsProxy getBestAAResults() { return AAResultsProxy(AAR, derived()); }\n\npublic:\n  AliasResult alias(const MemoryLocation &LocA, const MemoryLocation &LocB,\n                    AAQueryInfo &AAQI) {\n    return MayAlias;\n  }\n\n  bool pointsToConstantMemory(const MemoryLocation &Loc, AAQueryInfo &AAQI,\n                              bool OrLocal) {\n    return false;\n  }\n\n  ModRefInfo getArgModRefInfo(const CallBase *Call, unsigned ArgIdx) {\n    return ModRefInfo::ModRef;\n  }\n\n  FunctionModRefBehavior getModRefBehavior(const CallBase *Call) {\n    return FMRB_UnknownModRefBehavior;\n  }\n\n  FunctionModRefBehavior getModRefBehavior(const Function *F) {\n    return FMRB_UnknownModRefBehavior;\n  }\n\n  ModRefInfo getModRefInfo(const CallBase *Call, const MemoryLocation &Loc,\n                           AAQueryInfo &AAQI) {\n    return ModRefInfo::ModRef;\n  }\n\n  ModRefInfo getModRefInfo(const CallBase *Call1, const CallBase *Call2,\n                           AAQueryInfo &AAQI) {\n    return ModRefInfo::ModRef;\n  }\n};\n\n/// Return true if this pointer is returned by a noalias function.\nbool isNoAliasCall(const Value *V);\n\n/// Return true if this pointer refers to a distinct and identifiable object.\n/// This returns true for:\n///    Global Variables and Functions (but not Global Aliases)\n///    Allocas\n///    ByVal and NoAlias Arguments\n///    NoAlias returns (e.g. calls to malloc)\n///\nbool isIdentifiedObject(const Value *V);\n\n/// Return true if V is umabigously identified at the function-level.\n/// Different IdentifiedFunctionLocals can't alias.\n/// Further, an IdentifiedFunctionLocal can not alias with any function\n/// arguments other than itself, which is not necessarily true for\n/// IdentifiedObjects.\nbool isIdentifiedFunctionLocal(const Value *V);\n\n/// A manager for alias analyses.\n///\n/// This class can have analyses registered with it and when run, it will run\n/// all of them and aggregate their results into single AA results interface\n/// that dispatches across all of the alias analysis results available.\n///\n/// Note that the order in which analyses are registered is very significant.\n/// That is the order in which the results will be aggregated and queried.\n///\n/// This manager effectively wraps the AnalysisManager for registering alias\n/// analyses. When you register your alias analysis with this manager, it will\n/// ensure the analysis itself is registered with its AnalysisManager.\n///\n/// The result of this analysis is only invalidated if one of the particular\n/// aggregated AA results end up being invalidated. This removes the need to\n/// explicitly preserve the results of `AAManager`. Note that analyses should no\n/// longer be registered once the `AAManager` is run.\nclass AAManager : public AnalysisInfoMixin<AAManager> {\npublic:\n  using Result = AAResults;\n\n  /// Register a specific AA result.\n  template <typename AnalysisT> void registerFunctionAnalysis() {\n    ResultGetters.push_back(&getFunctionAAResultImpl<AnalysisT>);\n  }\n\n  /// Register a specific AA result.\n  template <typename AnalysisT> void registerModuleAnalysis() {\n    ResultGetters.push_back(&getModuleAAResultImpl<AnalysisT>);\n  }\n\n  Result run(Function &F, FunctionAnalysisManager &AM);\n\nprivate:\n  friend AnalysisInfoMixin<AAManager>;\n\n  static AnalysisKey Key;\n\n  SmallVector<void (*)(Function &F, FunctionAnalysisManager &AM,\n                       AAResults &AAResults),\n              4> ResultGetters;\n\n  template <typename AnalysisT>\n  static void getFunctionAAResultImpl(Function &F,\n                                      FunctionAnalysisManager &AM,\n                                      AAResults &AAResults) {\n    AAResults.addAAResult(AM.template getResult<AnalysisT>(F));\n    AAResults.addAADependencyID(AnalysisT::ID());\n  }\n\n  template <typename AnalysisT>\n  static void getModuleAAResultImpl(Function &F, FunctionAnalysisManager &AM,\n                                    AAResults &AAResults) {\n    auto &MAMProxy = AM.getResult<ModuleAnalysisManagerFunctionProxy>(F);\n    if (auto *R =\n            MAMProxy.template getCachedResult<AnalysisT>(*F.getParent())) {\n      AAResults.addAAResult(*R);\n      MAMProxy\n          .template registerOuterAnalysisInvalidation<AnalysisT, AAManager>();\n    }\n  }\n};\n\n/// A wrapper pass to provide the legacy pass manager access to a suitably\n/// prepared AAResults object.\nclass AAResultsWrapperPass : public FunctionPass {\n  std::unique_ptr<AAResults> AAR;\n\npublic:\n  static char ID;\n\n  AAResultsWrapperPass();\n\n  AAResults &getAAResults() { return *AAR; }\n  const AAResults &getAAResults() const { return *AAR; }\n\n  bool runOnFunction(Function &F) override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n\n/// A wrapper pass for external alias analyses. This just squirrels away the\n/// callback used to run any analyses and register their results.\nstruct ExternalAAWrapperPass : ImmutablePass {\n  using CallbackT = std::function<void(Pass &, Function &, AAResults &)>;\n\n  CallbackT CB;\n\n  static char ID;\n\n  ExternalAAWrapperPass();\n\n  explicit ExternalAAWrapperPass(CallbackT CB);\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.setPreservesAll();\n  }\n};\n\nFunctionPass *createAAResultsWrapperPass();\n\n/// A wrapper pass around a callback which can be used to populate the\n/// AAResults in the AAResultsWrapperPass from an external AA.\n///\n/// The callback provided here will be used each time we prepare an AAResults\n/// object, and will receive a reference to the function wrapper pass, the\n/// function, and the AAResults object to populate. This should be used when\n/// setting up a custom pass pipeline to inject a hook into the AA results.\nImmutablePass *createExternalAAWrapperPass(\n    std::function<void(Pass &, Function &, AAResults &)> Callback);\n\n/// A helper for the legacy pass manager to create a \\c AAResults\n/// object populated to the best of our ability for a particular function when\n/// inside of a \\c ModulePass or a \\c CallGraphSCCPass.\n///\n/// If a \\c ModulePass or a \\c CallGraphSCCPass calls \\p\n/// createLegacyPMAAResults, it also needs to call \\p addUsedAAAnalyses in \\p\n/// getAnalysisUsage.\nAAResults createLegacyPMAAResults(Pass &P, Function &F, BasicAAResult &BAR);\n\n/// A helper for the legacy pass manager to populate \\p AU to add uses to make\n/// sure the analyses required by \\p createLegacyPMAAResults are available.\nvoid getAAResultsAnalysisUsage(AnalysisUsage &AU);\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_ALIASANALYSIS_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "content": "//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares routines for folding instructions into simpler forms\n// that do not require creating new instructions.  This does constant folding\n// (\"add i32 1, 1\" -> \"2\") but can also handle non-constant operands, either\n// returning a constant (\"and i32 %x, 0\" -> \"0\") or an already existing value\n// (\"and i32 %x, %x\" -> \"%x\").  If the simplification is also an instruction\n// then it dominates the original instruction.\n//\n// These routines implicitly resolve undef uses. The easiest way to be safe when\n// using these routines to obtain simplified values for existing instructions is\n// to always replace all uses of the instructions with the resulting simplified\n// values. This will prevent other code from seeing the same undef uses and\n// resolving them to different values.\n//\n// These routines are designed to tolerate moderately incomplete IR, such as\n// instructions that are not connected to basic blocks yet. However, they do\n// require that all the IR that they encounter be valid. In particular, they\n// require that all non-constant values be defined in the same function, and the\n// same call context of that function (and not split between caller and callee\n// contexts of a directly recursive call, for example).\n//\n// Additionally, these routines can't simplify to the instructions that are not\n// def-reachable, meaning we can't just scan the basic block for instructions\n// to simplify to.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_INSTRUCTIONSIMPLIFY_H\n#define LLVM_ANALYSIS_INSTRUCTIONSIMPLIFY_H\n\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Operator.h\"\n\nnamespace llvm {\n\ntemplate <typename T, typename... TArgs> class AnalysisManager;\ntemplate <class T> class ArrayRef;\nclass AssumptionCache;\nclass BinaryOperator;\nclass CallBase;\nclass DataLayout;\nclass DominatorTree;\nclass Function;\nstruct LoopStandardAnalysisResults;\nclass MDNode;\nclass OptimizationRemarkEmitter;\nclass Pass;\ntemplate <class T, unsigned n> class SmallSetVector;\nclass TargetLibraryInfo;\nclass Type;\nclass Value;\n\n/// InstrInfoQuery provides an interface to query additional information for\n/// instructions like metadata or keywords like nsw, which provides conservative\n/// results if the users specified it is safe to use.\nstruct InstrInfoQuery {\n  InstrInfoQuery(bool UMD) : UseInstrInfo(UMD) {}\n  InstrInfoQuery() : UseInstrInfo(true) {}\n  bool UseInstrInfo = true;\n\n  MDNode *getMetadata(const Instruction *I, unsigned KindID) const {\n    if (UseInstrInfo)\n      return I->getMetadata(KindID);\n    return nullptr;\n  }\n\n  template <class InstT> bool hasNoUnsignedWrap(const InstT *Op) const {\n    if (UseInstrInfo)\n      return Op->hasNoUnsignedWrap();\n    return false;\n  }\n\n  template <class InstT> bool hasNoSignedWrap(const InstT *Op) const {\n    if (UseInstrInfo)\n      return Op->hasNoSignedWrap();\n    return false;\n  }\n\n  bool isExact(const BinaryOperator *Op) const {\n    if (UseInstrInfo && isa<PossiblyExactOperator>(Op))\n      return cast<PossiblyExactOperator>(Op)->isExact();\n    return false;\n  }\n};\n\nstruct SimplifyQuery {\n  const DataLayout &DL;\n  const TargetLibraryInfo *TLI = nullptr;\n  const DominatorTree *DT = nullptr;\n  AssumptionCache *AC = nullptr;\n  const Instruction *CxtI = nullptr;\n\n  // Wrapper to query additional information for instructions like metadata or\n  // keywords like nsw, which provides conservative results if those cannot\n  // be safely used.\n  const InstrInfoQuery IIQ;\n\n  /// Controls whether simplifications are allowed to constrain the range of\n  /// possible values for uses of undef. If it is false, simplifications are not\n  /// allowed to assume a particular value for a use of undef for example.\n  bool CanUseUndef = true;\n\n  SimplifyQuery(const DataLayout &DL, const Instruction *CXTI = nullptr)\n      : DL(DL), CxtI(CXTI) {}\n\n  SimplifyQuery(const DataLayout &DL, const TargetLibraryInfo *TLI,\n                const DominatorTree *DT = nullptr,\n                AssumptionCache *AC = nullptr,\n                const Instruction *CXTI = nullptr, bool UseInstrInfo = true,\n                bool CanUseUndef = true)\n      : DL(DL), TLI(TLI), DT(DT), AC(AC), CxtI(CXTI), IIQ(UseInstrInfo),\n        CanUseUndef(CanUseUndef) {}\n  SimplifyQuery getWithInstruction(Instruction *I) const {\n    SimplifyQuery Copy(*this);\n    Copy.CxtI = I;\n    return Copy;\n  }\n  SimplifyQuery getWithoutUndef() const {\n    SimplifyQuery Copy(*this);\n    Copy.CanUseUndef = false;\n    return Copy;\n  }\n\n  /// If CanUseUndef is true, returns whether \\p V is undef.\n  /// Otherwise always return false.\n  bool isUndefValue(Value *V) const {\n    if (!CanUseUndef)\n      return false;\n    return isa<UndefValue>(V);\n  }\n};\n\n// NOTE: the explicit multiple argument versions of these functions are\n// deprecated.\n// Please use the SimplifyQuery versions in new code.\n\n/// Given operand for an FNeg, fold the result or return null.\nValue *SimplifyFNegInst(Value *Op, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an Add, fold the result or return null.\nValue *SimplifyAddInst(Value *LHS, Value *RHS, bool isNSW, bool isNUW,\n                       const SimplifyQuery &Q);\n\n/// Given operands for a Sub, fold the result or return null.\nValue *SimplifySubInst(Value *LHS, Value *RHS, bool isNSW, bool isNUW,\n                       const SimplifyQuery &Q);\n\n/// Given operands for an FAdd, fold the result or return null.\nValue *SimplifyFAddInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an FSub, fold the result or return null.\nValue *SimplifyFSubInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an FMul, fold the result or return null.\nValue *SimplifyFMulInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for the multiplication of a FMA, fold the result or return\n/// null. In contrast to SimplifyFMulInst, this function will not perform\n/// simplifications whose unrounded results differ when rounded to the argument\n/// type.\nValue *SimplifyFMAFMul(Value *LHS, Value *RHS, FastMathFlags FMF,\n                       const SimplifyQuery &Q);\n\n/// Given operands for a Mul, fold the result or return null.\nValue *SimplifyMulInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an SDiv, fold the result or return null.\nValue *SimplifySDivInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for a UDiv, fold the result or return null.\nValue *SimplifyUDivInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an FDiv, fold the result or return null.\nValue *SimplifyFDivInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an SRem, fold the result or return null.\nValue *SimplifySRemInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for a URem, fold the result or return null.\nValue *SimplifyURemInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an FRem, fold the result or return null.\nValue *SimplifyFRemInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for a Shl, fold the result or return null.\nValue *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,\n                       const SimplifyQuery &Q);\n\n/// Given operands for a LShr, fold the result or return null.\nValue *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,\n                        const SimplifyQuery &Q);\n\n/// Given operands for a AShr, fold the result or return nulll.\nValue *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an And, fold the result or return null.\nValue *SimplifyAndInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an Or, fold the result or return null.\nValue *SimplifyOrInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an Xor, fold the result or return null.\nValue *SimplifyXorInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an ICmpInst, fold the result or return null.\nValue *SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an FCmpInst, fold the result or return null.\nValue *SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                        FastMathFlags FMF, const SimplifyQuery &Q);\n\n/// Given operands for a SelectInst, fold the result or return null.\nValue *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,\n                          const SimplifyQuery &Q);\n\n/// Given operands for a GetElementPtrInst, fold the result or return null.\nValue *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,\n                       const SimplifyQuery &Q);\n\n/// Given operands for an InsertValueInst, fold the result or return null.\nValue *SimplifyInsertValueInst(Value *Agg, Value *Val, ArrayRef<unsigned> Idxs,\n                               const SimplifyQuery &Q);\n\n/// Given operands for an InsertElement, fold the result or return null.\nValue *SimplifyInsertElementInst(Value *Vec, Value *Elt, Value *Idx,\n                                 const SimplifyQuery &Q);\n\n/// Given operands for an ExtractValueInst, fold the result or return null.\nValue *SimplifyExtractValueInst(Value *Agg, ArrayRef<unsigned> Idxs,\n                                const SimplifyQuery &Q);\n\n/// Given operands for an ExtractElementInst, fold the result or return null.\nValue *SimplifyExtractElementInst(Value *Vec, Value *Idx,\n                                  const SimplifyQuery &Q);\n\n/// Given operands for a CastInst, fold the result or return null.\nValue *SimplifyCastInst(unsigned CastOpc, Value *Op, Type *Ty,\n                        const SimplifyQuery &Q);\n\n/// Given operands for a ShuffleVectorInst, fold the result or return null.\n/// See class ShuffleVectorInst for a description of the mask representation.\nValue *SimplifyShuffleVectorInst(Value *Op0, Value *Op1, ArrayRef<int> Mask,\n                                 Type *RetTy, const SimplifyQuery &Q);\n\n//=== Helper functions for higher up the class hierarchy.\n\n/// Given operands for a CmpInst, fold the result or return null.\nValue *SimplifyCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                       const SimplifyQuery &Q);\n\n/// Given operand for a UnaryOperator, fold the result or return null.\nValue *SimplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q);\n\n/// Given operand for a UnaryOperator, fold the result or return null.\n/// Try to use FastMathFlags when folding the result.\nValue *SimplifyUnOp(unsigned Opcode, Value *Op, FastMathFlags FMF,\n                    const SimplifyQuery &Q);\n\n/// Given operands for a BinaryOperator, fold the result or return null.\nValue *SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                     const SimplifyQuery &Q);\n\n/// Given operands for a BinaryOperator, fold the result or return null.\n/// Try to use FastMathFlags when folding the result.\nValue *SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                     FastMathFlags FMF, const SimplifyQuery &Q);\n\n/// Given a callsite, fold the result or return null.\nValue *SimplifyCall(CallBase *Call, const SimplifyQuery &Q);\n\n/// Given an operand for a Freeze, see if we can fold the result.\n/// If not, this returns null.\nValue *SimplifyFreezeInst(Value *Op, const SimplifyQuery &Q);\n\n/// See if we can compute a simplified version of this instruction. If not,\n/// return null.\nValue *SimplifyInstruction(Instruction *I, const SimplifyQuery &Q,\n                           OptimizationRemarkEmitter *ORE = nullptr);\n\n/// See if V simplifies when its operand Op is replaced with RepOp. If not,\n/// return null.\n/// AllowRefinement specifies whether the simplification can be a refinement,\n/// or whether it needs to be strictly identical.\nValue *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,\n                              const SimplifyQuery &Q, bool AllowRefinement);\n\n/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.\n///\n/// This first performs a normal RAUW of I with SimpleV. It then recursively\n/// attempts to simplify those users updated by the operation. The 'I'\n/// instruction must not be equal to the simplified value 'SimpleV'.\n/// If UnsimplifiedUsers is provided, instructions that could not be simplified\n/// are added to it.\n///\n/// The function returns true if any simplifications were performed.\nbool replaceAndRecursivelySimplify(\n    Instruction *I, Value *SimpleV, const TargetLibraryInfo *TLI = nullptr,\n    const DominatorTree *DT = nullptr, AssumptionCache *AC = nullptr,\n    SmallSetVector<Instruction *, 8> *UnsimplifiedUsers = nullptr);\n\n// These helper functions return a SimplifyQuery structure that contains as\n// many of the optional analysis we use as are currently valid.  This is the\n// strongly preferred way of constructing SimplifyQuery in passes.\nconst SimplifyQuery getBestSimplifyQuery(Pass &, Function &);\ntemplate <class T, class... TArgs>\nconst SimplifyQuery getBestSimplifyQuery(AnalysisManager<T, TArgs...> &,\n                                         Function &);\nconst SimplifyQuery getBestSimplifyQuery(LoopStandardAnalysisResults &,\n                                         const DataLayout &);\n} // end namespace llvm\n\n#endif\n\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h", "content": "//===- llvm/Analysis/LoopNestAnalysis.h -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file defines the interface for the loop nest analysis.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_LOOPNESTANALYSIS_H\n#define LLVM_ANALYSIS_LOOPNESTANALYSIS_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n\nnamespace llvm {\n\nusing LoopVectorTy = SmallVector<Loop *, 8>;\nclass LPMUpdater;\n\n/// This class represents a loop nest and can be used to query its properties.\nclass LoopNest {\npublic:\n  /// Construct a loop nest rooted by loop \\p Root.\n  LoopNest(Loop &Root, ScalarEvolution &SE);\n\n  LoopNest() = delete;\n  LoopNest &operator=(const LoopNest &) = delete;\n\n  /// Construct a LoopNest object.\n  static std::unique_ptr<LoopNest> getLoopNest(Loop &Root, ScalarEvolution &SE);\n\n  /// Return true if the given loops \\p OuterLoop and \\p InnerLoop are\n  /// perfectly nested with respect to each other, and false otherwise.\n  /// Example:\n  /// \\code\n  ///   for(i)\n  ///     for(j)\n  ///       for(k)\n  /// \\endcode\n  /// arePerfectlyNested(loop_i, loop_j, SE) would return true.\n  /// arePerfectlyNested(loop_j, loop_k, SE) would return true.\n  /// arePerfectlyNested(loop_i, loop_k, SE) would return false.\n  static bool arePerfectlyNested(const Loop &OuterLoop, const Loop &InnerLoop,\n                                 ScalarEvolution &SE);\n\n  /// Return the maximum nesting depth of the loop nest rooted by loop \\p Root.\n  /// For example given the loop nest:\n  /// \\code\n  ///   for(i)     // loop at level 1 and Root of the nest\n  ///     for(j)   // loop at level 2\n  ///       <code>\n  ///       for(k) // loop at level 3\n  /// \\endcode\n  /// getMaxPerfectDepth(Loop_i) would return 2.\n  static unsigned getMaxPerfectDepth(const Loop &Root, ScalarEvolution &SE);\n\n  /// Recursivelly traverse all empty 'single successor' basic blocks of \\p From\n  /// (if there are any). Return the last basic block found or \\p End if it was\n  /// reached during the search.\n  static const BasicBlock &skipEmptyBlockUntil(const BasicBlock *From,\n                                               const BasicBlock *End);\n\n  /// Return the outermost loop in the loop nest.\n  Loop &getOutermostLoop() const { return *Loops.front(); }\n\n  /// Return the innermost loop in the loop nest if the nest has only one\n  /// innermost loop, and a nullptr otherwise.\n  /// Note: the innermost loop returned is not necessarily perfectly nested.\n  Loop *getInnermostLoop() const {\n    if (Loops.size() == 1)\n      return Loops.back();\n\n    // The loops in the 'Loops' vector have been collected in breadth first\n    // order, therefore if the last 2 loops in it have the same nesting depth\n    // there isn't a unique innermost loop in the nest.\n    Loop *LastLoop = Loops.back();\n    auto SecondLastLoopIter = ++Loops.rbegin();\n    return (LastLoop->getLoopDepth() == (*SecondLastLoopIter)->getLoopDepth())\n               ? nullptr\n               : LastLoop;\n  }\n\n  /// Return the loop at the given \\p Index.\n  Loop *getLoop(unsigned Index) const {\n    assert(Index < Loops.size() && \"Index is out of bounds\");\n    return Loops[Index];\n  }\n\n  /// Return the number of loops in the nest.\n  size_t getNumLoops() const { return Loops.size(); }\n\n  /// Get the loops in the nest.\n  ArrayRef<Loop *> getLoops() const { return Loops; }\n\n  /// Retrieve a vector of perfect loop nests contained in the current loop\n  /// nest. For example, given the following  nest containing 4 loops, this\n  /// member function would return {{L1,L2},{L3,L4}}.\n  /// \\code\n  ///   for(i) // L1\n  ///     for(j) // L2\n  ///       <code>\n  ///       for(k) // L3\n  ///         for(l) // L4\n  /// \\endcode\n  SmallVector<LoopVectorTy, 4> getPerfectLoops(ScalarEvolution &SE) const;\n\n  /// Return the loop nest depth (i.e. the loop depth of the 'deepest' loop)\n  /// For example given the loop nest:\n  /// \\code\n  ///   for(i)      // loop at level 1 and Root of the nest\n  ///     for(j1)   // loop at level 2\n  ///       for(k)  // loop at level 3\n  ///     for(j2)   // loop at level 2\n  /// \\endcode\n  /// getNestDepth() would return 3.\n  unsigned getNestDepth() const {\n    int NestDepth =\n        Loops.back()->getLoopDepth() - Loops.front()->getLoopDepth() + 1;\n    assert(NestDepth > 0 && \"Expecting NestDepth to be at least 1\");\n    return NestDepth;\n  }\n\n  /// Return the maximum perfect nesting depth.\n  unsigned getMaxPerfectDepth() const { return MaxPerfectDepth; }\n\n  /// Return true if all loops in the loop nest are in simplify form.\n  bool areAllLoopsSimplifyForm() const {\n    return all_of(Loops, [](const Loop *L) { return L->isLoopSimplifyForm(); });\n  }\n\n  /// Return true if all loops in the loop nest are in rotated form.\n  bool areAllLoopsRotatedForm() const {\n    return all_of(Loops, [](const Loop *L) { return L->isRotatedForm(); });\n  }\n\n  /// Return the function to which the loop-nest belongs.\n  Function *getParent() const {\n    return Loops.front()->getHeader()->getParent();\n  }\n\n  StringRef getName() const { return Loops.front()->getName(); }\n\nprotected:\n  const unsigned MaxPerfectDepth; // maximum perfect nesting depth level.\n  LoopVectorTy Loops; // the loops in the nest (in breadth first order).\n};\n\nraw_ostream &operator<<(raw_ostream &, const LoopNest &);\n\n/// This analysis provides information for a loop nest. The analysis runs on\n/// demand and can be initiated via AM.getResult<LoopNestAnalysis>.\nclass LoopNestAnalysis : public AnalysisInfoMixin<LoopNestAnalysis> {\n  friend AnalysisInfoMixin<LoopNestAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  using Result = LoopNest;\n  Result run(Loop &L, LoopAnalysisManager &AM, LoopStandardAnalysisResults &AR);\n};\n\n/// Printer pass for the \\c LoopNest results.\nclass LoopNestPrinterPass : public PassInfoMixin<LoopNestPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit LoopNestPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n};\n\n} // namespace llvm\n\n#endif // LLVM_ANALYSIS_LOOPNESTANALYSIS_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopPass.h", "content": "//===- LoopPass.h - LoopPass class ----------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines LoopPass class. All loop optimization\n// and transformation passes are derived from LoopPass.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_LOOPPASS_H\n#define LLVM_ANALYSIS_LOOPPASS_H\n\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/IR/LegacyPassManagers.h\"\n#include \"llvm/Pass.h\"\n#include <deque>\n\nnamespace llvm {\n\nclass LPPassManager;\nclass Function;\n\nclass LoopPass : public Pass {\npublic:\n  explicit LoopPass(char &pid) : Pass(PT_Loop, pid) {}\n\n  /// getPrinterPass - Get a pass to print the function corresponding\n  /// to a Loop.\n  Pass *createPrinterPass(raw_ostream &O,\n                          const std::string &Banner) const override;\n\n  // runOnLoop - This method should be implemented by the subclass to perform\n  // whatever action is necessary for the specified Loop.\n  virtual bool runOnLoop(Loop *L, LPPassManager &LPM) = 0;\n\n  using llvm::Pass::doInitialization;\n  using llvm::Pass::doFinalization;\n\n  // Initialization and finalization hooks.\n  virtual bool doInitialization(Loop *L, LPPassManager &LPM) {\n    return false;\n  }\n\n  // Finalization hook does not supply Loop because at this time\n  // loop nest is completely different.\n  virtual bool doFinalization() { return false; }\n\n  // Check if this pass is suitable for the current LPPassManager, if\n  // available. This pass P is not suitable for a LPPassManager if P\n  // is not preserving higher level analysis info used by other\n  // LPPassManager passes. In such case, pop LPPassManager from the\n  // stack. This will force assignPassManager() to create new\n  // LPPassManger as expected.\n  void preparePassManager(PMStack &PMS) override;\n\n  /// Assign pass manager to manage this pass\n  void assignPassManager(PMStack &PMS, PassManagerType PMT) override;\n\n  ///  Return what kind of Pass Manager can manage this pass.\n  PassManagerType getPotentialPassManagerType() const override {\n    return PMT_LoopPassManager;\n  }\n\nprotected:\n  /// Optional passes call this function to check whether the pass should be\n  /// skipped. This is the case when Attribute::OptimizeNone is set or when\n  /// optimization bisect is over the limit.\n  bool skipLoop(const Loop *L) const;\n};\n\nclass LPPassManager : public FunctionPass, public PMDataManager {\npublic:\n  static char ID;\n  explicit LPPassManager();\n\n  /// run - Execute all of the passes scheduled for execution.  Keep track of\n  /// whether any of the passes modifies the module, and if so, return true.\n  bool runOnFunction(Function &F) override;\n\n  /// Pass Manager itself does not invalidate any analysis info.\n  // LPPassManager needs LoopInfo.\n  void getAnalysisUsage(AnalysisUsage &Info) const override;\n\n  StringRef getPassName() const override { return \"Loop Pass Manager\"; }\n\n  PMDataManager *getAsPMDataManager() override { return this; }\n  Pass *getAsPass() override { return this; }\n\n  /// Print passes managed by this manager\n  void dumpPassStructure(unsigned Offset) override;\n\n  LoopPass *getContainedPass(unsigned N) {\n    assert(N < PassVector.size() && \"Pass number out of range!\");\n    LoopPass *LP = static_cast<LoopPass *>(PassVector[N]);\n    return LP;\n  }\n\n  PassManagerType getPassManagerType() const override {\n    return PMT_LoopPassManager;\n  }\n\npublic:\n  // Add a new loop into the loop queue.\n  void addLoop(Loop &L);\n\n  // Mark \\p L as deleted.\n  void markLoopAsDeleted(Loop &L);\n\nprivate:\n  std::deque<Loop *> LQ;\n  LoopInfo *LI;\n  Loop *CurrentLoop;\n  bool CurrentLoopDeleted;\n};\n\n// This pass is required by the LCSSA transformation. It is used inside\n// LPPassManager to check if current pass preserves LCSSA form, and if it does\n// pass manager calls lcssa verification for the current loop.\nstruct LCSSAVerificationPass : public FunctionPass {\n  static char ID;\n  LCSSAVerificationPass();\n\n  bool runOnFunction(Function &F) override { return false; }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.setPreservesAll();\n  }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "content": "//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file exposes an interface to building/using memory SSA to\n/// walk memory instructions using a use/def graph.\n///\n/// Memory SSA class builds an SSA form that links together memory access\n/// instructions such as loads, stores, atomics, and calls. Additionally, it\n/// does a trivial form of \"heap versioning\" Every time the memory state changes\n/// in the program, we generate a new heap version. It generates\n/// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.\n///\n/// As a trivial example,\n/// define i32 @main() #0 {\n/// entry:\n///   %call = call noalias i8* @_Znwm(i64 4) #2\n///   %0 = bitcast i8* %call to i32*\n///   %call1 = call noalias i8* @_Znwm(i64 4) #2\n///   %1 = bitcast i8* %call1 to i32*\n///   store i32 5, i32* %0, align 4\n///   store i32 7, i32* %1, align 4\n///   %2 = load i32* %0, align 4\n///   %3 = load i32* %1, align 4\n///   %add = add nsw i32 %2, %3\n///   ret i32 %add\n/// }\n///\n/// Will become\n/// define i32 @main() #0 {\n/// entry:\n///   ; 1 = MemoryDef(0)\n///   %call = call noalias i8* @_Znwm(i64 4) #3\n///   %2 = bitcast i8* %call to i32*\n///   ; 2 = MemoryDef(1)\n///   %call1 = call noalias i8* @_Znwm(i64 4) #3\n///   %4 = bitcast i8* %call1 to i32*\n///   ; 3 = MemoryDef(2)\n///   store i32 5, i32* %2, align 4\n///   ; 4 = MemoryDef(3)\n///   store i32 7, i32* %4, align 4\n///   ; MemoryUse(3)\n///   %7 = load i32* %2, align 4\n///   ; MemoryUse(4)\n///   %8 = load i32* %4, align 4\n///   %add = add nsw i32 %7, %8\n///   ret i32 %add\n/// }\n///\n/// Given this form, all the stores that could ever effect the load at %8 can be\n/// gotten by using the MemoryUse associated with it, and walking from use to\n/// def until you hit the top of the function.\n///\n/// Each def also has a list of users associated with it, so you can walk from\n/// both def to users, and users to defs. Note that we disambiguate MemoryUses,\n/// but not the RHS of MemoryDefs. You can see this above at %7, which would\n/// otherwise be a MemoryUse(4). Being disambiguated means that for a given\n/// store, all the MemoryUses on its use lists are may-aliases of that store\n/// (but the MemoryDefs on its use list may not be).\n///\n/// MemoryDefs are not disambiguated because it would require multiple reaching\n/// definitions, which would require multiple phis, and multiple memoryaccesses\n/// per instruction.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_MEMORYSSA_H\n#define LLVM_ANALYSIS_MEMORYSSA_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/ADT/simple_ilist.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/Analysis/PHITransAddr.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/DerivedUser.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\n/// Enables memory ssa as a dependency for loop passes.\nextern cl::opt<bool> EnableMSSALoopDependency;\n\nclass AllocaInst;\nclass Function;\nclass Instruction;\nclass MemoryAccess;\nclass MemorySSAWalker;\nclass LLVMContext;\nclass raw_ostream;\n\nnamespace MSSAHelpers {\n\nstruct AllAccessTag {};\nstruct DefsOnlyTag {};\n\n} // end namespace MSSAHelpers\n\nenum : unsigned {\n  // Used to signify what the default invalid ID is for MemoryAccess's\n  // getID()\n  INVALID_MEMORYACCESS_ID = -1U\n};\n\ntemplate <class T> class memoryaccess_def_iterator_base;\nusing memoryaccess_def_iterator = memoryaccess_def_iterator_base<MemoryAccess>;\nusing const_memoryaccess_def_iterator =\n    memoryaccess_def_iterator_base<const MemoryAccess>;\n\n// The base for all memory accesses. All memory accesses in a block are\n// linked together using an intrusive list.\nclass MemoryAccess\n    : public DerivedUser,\n      public ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::AllAccessTag>>,\n      public ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::DefsOnlyTag>> {\npublic:\n  using AllAccessType =\n      ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::AllAccessTag>>;\n  using DefsOnlyType =\n      ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::DefsOnlyTag>>;\n\n  MemoryAccess(const MemoryAccess &) = delete;\n  MemoryAccess &operator=(const MemoryAccess &) = delete;\n\n  void *operator new(size_t) = delete;\n\n  // Methods for support type inquiry through isa, cast, and\n  // dyn_cast\n  static bool classof(const Value *V) {\n    unsigned ID = V->getValueID();\n    return ID == MemoryUseVal || ID == MemoryPhiVal || ID == MemoryDefVal;\n  }\n\n  BasicBlock *getBlock() const { return Block; }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  /// The user iterators for a memory access\n  using iterator = user_iterator;\n  using const_iterator = const_user_iterator;\n\n  /// This iterator walks over all of the defs in a given\n  /// MemoryAccess. For MemoryPhi nodes, this walks arguments. For\n  /// MemoryUse/MemoryDef, this walks the defining access.\n  memoryaccess_def_iterator defs_begin();\n  const_memoryaccess_def_iterator defs_begin() const;\n  memoryaccess_def_iterator defs_end();\n  const_memoryaccess_def_iterator defs_end() const;\n\n  /// Get the iterators for the all access list and the defs only list\n  /// We default to the all access list.\n  AllAccessType::self_iterator getIterator() {\n    return this->AllAccessType::getIterator();\n  }\n  AllAccessType::const_self_iterator getIterator() const {\n    return this->AllAccessType::getIterator();\n  }\n  AllAccessType::reverse_self_iterator getReverseIterator() {\n    return this->AllAccessType::getReverseIterator();\n  }\n  AllAccessType::const_reverse_self_iterator getReverseIterator() const {\n    return this->AllAccessType::getReverseIterator();\n  }\n  DefsOnlyType::self_iterator getDefsIterator() {\n    return this->DefsOnlyType::getIterator();\n  }\n  DefsOnlyType::const_self_iterator getDefsIterator() const {\n    return this->DefsOnlyType::getIterator();\n  }\n  DefsOnlyType::reverse_self_iterator getReverseDefsIterator() {\n    return this->DefsOnlyType::getReverseIterator();\n  }\n  DefsOnlyType::const_reverse_self_iterator getReverseDefsIterator() const {\n    return this->DefsOnlyType::getReverseIterator();\n  }\n\nprotected:\n  friend class MemoryDef;\n  friend class MemoryPhi;\n  friend class MemorySSA;\n  friend class MemoryUse;\n  friend class MemoryUseOrDef;\n\n  /// Used by MemorySSA to change the block of a MemoryAccess when it is\n  /// moved.\n  void setBlock(BasicBlock *BB) { Block = BB; }\n\n  /// Used for debugging and tracking things about MemoryAccesses.\n  /// Guaranteed unique among MemoryAccesses, no guarantees otherwise.\n  inline unsigned getID() const;\n\n  MemoryAccess(LLVMContext &C, unsigned Vty, DeleteValueTy DeleteValue,\n               BasicBlock *BB, unsigned NumOperands)\n      : DerivedUser(Type::getVoidTy(C), Vty, nullptr, NumOperands, DeleteValue),\n        Block(BB) {}\n\n  // Use deleteValue() to delete a generic MemoryAccess.\n  ~MemoryAccess() = default;\n\nprivate:\n  BasicBlock *Block;\n};\n\ntemplate <>\nstruct ilist_alloc_traits<MemoryAccess> {\n  static void deleteNode(MemoryAccess *MA) { MA->deleteValue(); }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const MemoryAccess &MA) {\n  MA.print(OS);\n  return OS;\n}\n\n/// Class that has the common methods + fields of memory uses/defs. It's\n/// a little awkward to have, but there are many cases where we want either a\n/// use or def, and there are many cases where uses are needed (defs aren't\n/// acceptable), and vice-versa.\n///\n/// This class should never be instantiated directly; make a MemoryUse or\n/// MemoryDef instead.\nclass MemoryUseOrDef : public MemoryAccess {\npublic:\n  void *operator new(size_t) = delete;\n\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  /// Get the instruction that this MemoryUse represents.\n  Instruction *getMemoryInst() const { return MemoryInstruction; }\n\n  /// Get the access that produces the memory state used by this Use.\n  MemoryAccess *getDefiningAccess() const { return getOperand(0); }\n\n  static bool classof(const Value *MA) {\n    return MA->getValueID() == MemoryUseVal || MA->getValueID() == MemoryDefVal;\n  }\n\n  // Sadly, these have to be public because they are needed in some of the\n  // iterators.\n  inline bool isOptimized() const;\n  inline MemoryAccess *getOptimized() const;\n  inline void setOptimized(MemoryAccess *);\n\n  // Retrieve AliasResult type of the optimized access. Ideally this would be\n  // returned by the caching walker and may go away in the future.\n  Optional<AliasResult> getOptimizedAccessType() const {\n    return isOptimized() ? OptimizedAccessAlias : None;\n  }\n\n  /// Reset the ID of what this MemoryUse was optimized to, causing it to\n  /// be rewalked by the walker if necessary.\n  /// This really should only be called by tests.\n  inline void resetOptimized();\n\nprotected:\n  friend class MemorySSA;\n  friend class MemorySSAUpdater;\n\n  MemoryUseOrDef(LLVMContext &C, MemoryAccess *DMA, unsigned Vty,\n                 DeleteValueTy DeleteValue, Instruction *MI, BasicBlock *BB,\n                 unsigned NumOperands)\n      : MemoryAccess(C, Vty, DeleteValue, BB, NumOperands),\n        MemoryInstruction(MI), OptimizedAccessAlias(MayAlias) {\n    setDefiningAccess(DMA);\n  }\n\n  // Use deleteValue() to delete a generic MemoryUseOrDef.\n  ~MemoryUseOrDef() = default;\n\n  void setOptimizedAccessType(Optional<AliasResult> AR) {\n    OptimizedAccessAlias = AR;\n  }\n\n  void setDefiningAccess(MemoryAccess *DMA, bool Optimized = false,\n                         Optional<AliasResult> AR = MayAlias) {\n    if (!Optimized) {\n      setOperand(0, DMA);\n      return;\n    }\n    setOptimized(DMA);\n    setOptimizedAccessType(AR);\n  }\n\nprivate:\n  Instruction *MemoryInstruction;\n  Optional<AliasResult> OptimizedAccessAlias;\n};\n\n/// Represents read-only accesses to memory\n///\n/// In particular, the set of Instructions that will be represented by\n/// MemoryUse's is exactly the set of Instructions for which\n/// AliasAnalysis::getModRefInfo returns \"Ref\".\nclass MemoryUse final : public MemoryUseOrDef {\npublic:\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  MemoryUse(LLVMContext &C, MemoryAccess *DMA, Instruction *MI, BasicBlock *BB)\n      : MemoryUseOrDef(C, DMA, MemoryUseVal, deleteMe, MI, BB,\n                       /*NumOperands=*/1) {}\n\n  // allocate space for exactly one operand\n  void *operator new(size_t s) { return User::operator new(s, 1); }\n\n  static bool classof(const Value *MA) {\n    return MA->getValueID() == MemoryUseVal;\n  }\n\n  void print(raw_ostream &OS) const;\n\n  void setOptimized(MemoryAccess *DMA) {\n    OptimizedID = DMA->getID();\n    setOperand(0, DMA);\n  }\n\n  bool isOptimized() const {\n    return getDefiningAccess() && OptimizedID == getDefiningAccess()->getID();\n  }\n\n  MemoryAccess *getOptimized() const {\n    return getDefiningAccess();\n  }\n\n  void resetOptimized() {\n    OptimizedID = INVALID_MEMORYACCESS_ID;\n  }\n\nprotected:\n  friend class MemorySSA;\n\nprivate:\n  static void deleteMe(DerivedUser *Self);\n\n  unsigned OptimizedID = INVALID_MEMORYACCESS_ID;\n};\n\ntemplate <>\nstruct OperandTraits<MemoryUse> : public FixedNumOperandTraits<MemoryUse, 1> {};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryUse, MemoryAccess)\n\n/// Represents a read-write access to memory, whether it is a must-alias,\n/// or a may-alias.\n///\n/// In particular, the set of Instructions that will be represented by\n/// MemoryDef's is exactly the set of Instructions for which\n/// AliasAnalysis::getModRefInfo returns \"Mod\" or \"ModRef\".\n/// Note that, in order to provide def-def chains, all defs also have a use\n/// associated with them. This use points to the nearest reaching\n/// MemoryDef/MemoryPhi.\nclass MemoryDef final : public MemoryUseOrDef {\npublic:\n  friend class MemorySSA;\n\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  MemoryDef(LLVMContext &C, MemoryAccess *DMA, Instruction *MI, BasicBlock *BB,\n            unsigned Ver)\n      : MemoryUseOrDef(C, DMA, MemoryDefVal, deleteMe, MI, BB,\n                       /*NumOperands=*/2),\n        ID(Ver) {}\n\n  // allocate space for exactly two operands\n  void *operator new(size_t s) { return User::operator new(s, 2); }\n\n  static bool classof(const Value *MA) {\n    return MA->getValueID() == MemoryDefVal;\n  }\n\n  void setOptimized(MemoryAccess *MA) {\n    setOperand(1, MA);\n    OptimizedID = MA->getID();\n  }\n\n  MemoryAccess *getOptimized() const {\n    return cast_or_null<MemoryAccess>(getOperand(1));\n  }\n\n  bool isOptimized() const {\n    return getOptimized() && OptimizedID == getOptimized()->getID();\n  }\n\n  void resetOptimized() {\n    OptimizedID = INVALID_MEMORYACCESS_ID;\n    setOperand(1, nullptr);\n  }\n\n  void print(raw_ostream &OS) const;\n\n  unsigned getID() const { return ID; }\n\nprivate:\n  static void deleteMe(DerivedUser *Self);\n\n  const unsigned ID;\n  unsigned OptimizedID = INVALID_MEMORYACCESS_ID;\n};\n\ntemplate <>\nstruct OperandTraits<MemoryDef> : public FixedNumOperandTraits<MemoryDef, 2> {};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryDef, MemoryAccess)\n\ntemplate <>\nstruct OperandTraits<MemoryUseOrDef> {\n  static Use *op_begin(MemoryUseOrDef *MUD) {\n    if (auto *MU = dyn_cast<MemoryUse>(MUD))\n      return OperandTraits<MemoryUse>::op_begin(MU);\n    return OperandTraits<MemoryDef>::op_begin(cast<MemoryDef>(MUD));\n  }\n\n  static Use *op_end(MemoryUseOrDef *MUD) {\n    if (auto *MU = dyn_cast<MemoryUse>(MUD))\n      return OperandTraits<MemoryUse>::op_end(MU);\n    return OperandTraits<MemoryDef>::op_end(cast<MemoryDef>(MUD));\n  }\n\n  static unsigned operands(const MemoryUseOrDef *MUD) {\n    if (const auto *MU = dyn_cast<MemoryUse>(MUD))\n      return OperandTraits<MemoryUse>::operands(MU);\n    return OperandTraits<MemoryDef>::operands(cast<MemoryDef>(MUD));\n  }\n};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryUseOrDef, MemoryAccess)\n\n/// Represents phi nodes for memory accesses.\n///\n/// These have the same semantic as regular phi nodes, with the exception that\n/// only one phi will ever exist in a given basic block.\n/// Guaranteeing one phi per block means guaranteeing there is only ever one\n/// valid reaching MemoryDef/MemoryPHI along each path to the phi node.\n/// This is ensured by not allowing disambiguation of the RHS of a MemoryDef or\n/// a MemoryPhi's operands.\n/// That is, given\n/// if (a) {\n///   store %a\n///   store %b\n/// }\n/// it *must* be transformed into\n/// if (a) {\n///    1 = MemoryDef(liveOnEntry)\n///    store %a\n///    2 = MemoryDef(1)\n///    store %b\n/// }\n/// and *not*\n/// if (a) {\n///    1 = MemoryDef(liveOnEntry)\n///    store %a\n///    2 = MemoryDef(liveOnEntry)\n///    store %b\n/// }\n/// even if the two stores do not conflict. Otherwise, both 1 and 2 reach the\n/// end of the branch, and if there are not two phi nodes, one will be\n/// disconnected completely from the SSA graph below that point.\n/// Because MemoryUse's do not generate new definitions, they do not have this\n/// issue.\nclass MemoryPhi final : public MemoryAccess {\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) { return User::operator new(s); }\n\npublic:\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  MemoryPhi(LLVMContext &C, BasicBlock *BB, unsigned Ver, unsigned NumPreds = 0)\n      : MemoryAccess(C, MemoryPhiVal, deleteMe, BB, 0), ID(Ver),\n        ReservedSpace(NumPreds) {\n    allocHungoffUses(ReservedSpace);\n  }\n\n  // Block iterator interface. This provides access to the list of incoming\n  // basic blocks, which parallels the list of incoming values.\n  using block_iterator = BasicBlock **;\n  using const_block_iterator = BasicBlock *const *;\n\n  block_iterator block_begin() {\n    return reinterpret_cast<block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  const_block_iterator block_begin() const {\n    return reinterpret_cast<const_block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  block_iterator block_end() { return block_begin() + getNumOperands(); }\n\n  const_block_iterator block_end() const {\n    return block_begin() + getNumOperands();\n  }\n\n  iterator_range<block_iterator> blocks() {\n    return make_range(block_begin(), block_end());\n  }\n\n  iterator_range<const_block_iterator> blocks() const {\n    return make_range(block_begin(), block_end());\n  }\n\n  op_range incoming_values() { return operands(); }\n\n  const_op_range incoming_values() const { return operands(); }\n\n  /// Return the number of incoming edges\n  unsigned getNumIncomingValues() const { return getNumOperands(); }\n\n  /// Return incoming value number x\n  MemoryAccess *getIncomingValue(unsigned I) const { return getOperand(I); }\n  void setIncomingValue(unsigned I, MemoryAccess *V) {\n    assert(V && \"PHI node got a null value!\");\n    setOperand(I, V);\n  }\n\n  static unsigned getOperandNumForIncomingValue(unsigned I) { return I; }\n  static unsigned getIncomingValueNumForOperand(unsigned I) { return I; }\n\n  /// Return incoming basic block number @p i.\n  BasicBlock *getIncomingBlock(unsigned I) const { return block_begin()[I]; }\n\n  /// Return incoming basic block corresponding\n  /// to an operand of the PHI.\n  BasicBlock *getIncomingBlock(const Use &U) const {\n    assert(this == U.getUser() && \"Iterator doesn't point to PHI's Uses?\");\n    return getIncomingBlock(unsigned(&U - op_begin()));\n  }\n\n  /// Return incoming basic block corresponding\n  /// to value use iterator.\n  BasicBlock *getIncomingBlock(MemoryAccess::const_user_iterator I) const {\n    return getIncomingBlock(I.getUse());\n  }\n\n  void setIncomingBlock(unsigned I, BasicBlock *BB) {\n    assert(BB && \"PHI node got a null basic block!\");\n    block_begin()[I] = BB;\n  }\n\n  /// Add an incoming value to the end of the PHI list\n  void addIncoming(MemoryAccess *V, BasicBlock *BB) {\n    if (getNumOperands() == ReservedSpace)\n      growOperands(); // Get more space!\n    // Initialize some new operands.\n    setNumHungOffUseOperands(getNumOperands() + 1);\n    setIncomingValue(getNumOperands() - 1, V);\n    setIncomingBlock(getNumOperands() - 1, BB);\n  }\n\n  /// Return the first index of the specified basic\n  /// block in the value list for this PHI.  Returns -1 if no instance.\n  int getBasicBlockIndex(const BasicBlock *BB) const {\n    for (unsigned I = 0, E = getNumOperands(); I != E; ++I)\n      if (block_begin()[I] == BB)\n        return I;\n    return -1;\n  }\n\n  MemoryAccess *getIncomingValueForBlock(const BasicBlock *BB) const {\n    int Idx = getBasicBlockIndex(BB);\n    assert(Idx >= 0 && \"Invalid basic block argument!\");\n    return getIncomingValue(Idx);\n  }\n\n  // After deleting incoming position I, the order of incoming may be changed.\n  void unorderedDeleteIncoming(unsigned I) {\n    unsigned E = getNumOperands();\n    assert(I < E && \"Cannot remove out of bounds Phi entry.\");\n    // MemoryPhi must have at least two incoming values, otherwise the MemoryPhi\n    // itself should be deleted.\n    assert(E >= 2 && \"Cannot only remove incoming values in MemoryPhis with \"\n                     \"at least 2 values.\");\n    setIncomingValue(I, getIncomingValue(E - 1));\n    setIncomingBlock(I, block_begin()[E - 1]);\n    setOperand(E - 1, nullptr);\n    block_begin()[E - 1] = nullptr;\n    setNumHungOffUseOperands(getNumOperands() - 1);\n  }\n\n  // After deleting entries that satisfy Pred, remaining entries may have\n  // changed order.\n  template <typename Fn> void unorderedDeleteIncomingIf(Fn &&Pred) {\n    for (unsigned I = 0, E = getNumOperands(); I != E; ++I)\n      if (Pred(getIncomingValue(I), getIncomingBlock(I))) {\n        unorderedDeleteIncoming(I);\n        E = getNumOperands();\n        --I;\n      }\n    assert(getNumOperands() >= 1 &&\n           \"Cannot remove all incoming blocks in a MemoryPhi.\");\n  }\n\n  // After deleting incoming block BB, the incoming blocks order may be changed.\n  void unorderedDeleteIncomingBlock(const BasicBlock *BB) {\n    unorderedDeleteIncomingIf(\n        [&](const MemoryAccess *, const BasicBlock *B) { return BB == B; });\n  }\n\n  // After deleting incoming memory access MA, the incoming accesses order may\n  // be changed.\n  void unorderedDeleteIncomingValue(const MemoryAccess *MA) {\n    unorderedDeleteIncomingIf(\n        [&](const MemoryAccess *M, const BasicBlock *) { return MA == M; });\n  }\n\n  static bool classof(const Value *V) {\n    return V->getValueID() == MemoryPhiVal;\n  }\n\n  void print(raw_ostream &OS) const;\n\n  unsigned getID() const { return ID; }\n\nprotected:\n  friend class MemorySSA;\n\n  /// this is more complicated than the generic\n  /// User::allocHungoffUses, because we have to allocate Uses for the incoming\n  /// values and pointers to the incoming blocks, all in one allocation.\n  void allocHungoffUses(unsigned N) {\n    User::allocHungoffUses(N, /* IsPhi */ true);\n  }\n\nprivate:\n  // For debugging only\n  const unsigned ID;\n  unsigned ReservedSpace;\n\n  /// This grows the operand list in response to a push_back style of\n  /// operation.  This grows the number of ops by 1.5 times.\n  void growOperands() {\n    unsigned E = getNumOperands();\n    // 2 op PHI nodes are VERY common, so reserve at least enough for that.\n    ReservedSpace = std::max(E + E / 2, 2u);\n    growHungoffUses(ReservedSpace, /* IsPhi */ true);\n  }\n\n  static void deleteMe(DerivedUser *Self);\n};\n\ninline unsigned MemoryAccess::getID() const {\n  assert((isa<MemoryDef>(this) || isa<MemoryPhi>(this)) &&\n         \"only memory defs and phis have ids\");\n  if (const auto *MD = dyn_cast<MemoryDef>(this))\n    return MD->getID();\n  return cast<MemoryPhi>(this)->getID();\n}\n\ninline bool MemoryUseOrDef::isOptimized() const {\n  if (const auto *MD = dyn_cast<MemoryDef>(this))\n    return MD->isOptimized();\n  return cast<MemoryUse>(this)->isOptimized();\n}\n\ninline MemoryAccess *MemoryUseOrDef::getOptimized() const {\n  if (const auto *MD = dyn_cast<MemoryDef>(this))\n    return MD->getOptimized();\n  return cast<MemoryUse>(this)->getOptimized();\n}\n\ninline void MemoryUseOrDef::setOptimized(MemoryAccess *MA) {\n  if (auto *MD = dyn_cast<MemoryDef>(this))\n    MD->setOptimized(MA);\n  else\n    cast<MemoryUse>(this)->setOptimized(MA);\n}\n\ninline void MemoryUseOrDef::resetOptimized() {\n  if (auto *MD = dyn_cast<MemoryDef>(this))\n    MD->resetOptimized();\n  else\n    cast<MemoryUse>(this)->resetOptimized();\n}\n\ntemplate <> struct OperandTraits<MemoryPhi> : public HungoffOperandTraits<2> {};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryPhi, MemoryAccess)\n\n/// Encapsulates MemorySSA, including all data associated with memory\n/// accesses.\nclass MemorySSA {\npublic:\n  MemorySSA(Function &, AliasAnalysis *, DominatorTree *);\n\n  // MemorySSA must remain where it's constructed; Walkers it creates store\n  // pointers to it.\n  MemorySSA(MemorySSA &&) = delete;\n\n  ~MemorySSA();\n\n  MemorySSAWalker *getWalker();\n  MemorySSAWalker *getSkipSelfWalker();\n\n  /// Given a memory Mod/Ref'ing instruction, get the MemorySSA\n  /// access associated with it. If passed a basic block gets the memory phi\n  /// node that exists for that block, if there is one. Otherwise, this will get\n  /// a MemoryUseOrDef.\n  MemoryUseOrDef *getMemoryAccess(const Instruction *I) const {\n    return cast_or_null<MemoryUseOrDef>(ValueToMemoryAccess.lookup(I));\n  }\n\n  MemoryPhi *getMemoryAccess(const BasicBlock *BB) const {\n    return cast_or_null<MemoryPhi>(ValueToMemoryAccess.lookup(cast<Value>(BB)));\n  }\n\n  DominatorTree &getDomTree() const { return *DT; }\n\n  void dump() const;\n  void print(raw_ostream &) const;\n\n  /// Return true if \\p MA represents the live on entry value\n  ///\n  /// Loads and stores from pointer arguments and other global values may be\n  /// defined by memory operations that do not occur in the current function, so\n  /// they may be live on entry to the function. MemorySSA represents such\n  /// memory state by the live on entry definition, which is guaranteed to occur\n  /// before any other memory access in the function.\n  inline bool isLiveOnEntryDef(const MemoryAccess *MA) const {\n    return MA == LiveOnEntryDef.get();\n  }\n\n  inline MemoryAccess *getLiveOnEntryDef() const {\n    return LiveOnEntryDef.get();\n  }\n\n  // Sadly, iplists, by default, owns and deletes pointers added to the\n  // list. It's not currently possible to have two iplists for the same type,\n  // where one owns the pointers, and one does not. This is because the traits\n  // are per-type, not per-tag.  If this ever changes, we should make the\n  // DefList an iplist.\n  using AccessList = iplist<MemoryAccess, ilist_tag<MSSAHelpers::AllAccessTag>>;\n  using DefsList =\n      simple_ilist<MemoryAccess, ilist_tag<MSSAHelpers::DefsOnlyTag>>;\n\n  /// Return the list of MemoryAccess's for a given basic block.\n  ///\n  /// This list is not modifiable by the user.\n  const AccessList *getBlockAccesses(const BasicBlock *BB) const {\n    return getWritableBlockAccesses(BB);\n  }\n\n  /// Return the list of MemoryDef's and MemoryPhi's for a given basic\n  /// block.\n  ///\n  /// This list is not modifiable by the user.\n  const DefsList *getBlockDefs(const BasicBlock *BB) const {\n    return getWritableBlockDefs(BB);\n  }\n\n  /// Given two memory accesses in the same basic block, determine\n  /// whether MemoryAccess \\p A dominates MemoryAccess \\p B.\n  bool locallyDominates(const MemoryAccess *A, const MemoryAccess *B) const;\n\n  /// Given two memory accesses in potentially different blocks,\n  /// determine whether MemoryAccess \\p A dominates MemoryAccess \\p B.\n  bool dominates(const MemoryAccess *A, const MemoryAccess *B) const;\n\n  /// Given a MemoryAccess and a Use, determine whether MemoryAccess \\p A\n  /// dominates Use \\p B.\n  bool dominates(const MemoryAccess *A, const Use &B) const;\n\n  /// Verify that MemorySSA is self consistent (IE definitions dominate\n  /// all uses, uses appear in the right places).  This is used by unit tests.\n  void verifyMemorySSA() const;\n\n  /// Used in various insertion functions to specify whether we are talking\n  /// about the beginning or end of a block.\n  enum InsertionPlace { Beginning, End, BeforeTerminator };\n\nprotected:\n  // Used by Memory SSA annotater, dumpers, and wrapper pass\n  friend class MemorySSAAnnotatedWriter;\n  friend class MemorySSAPrinterLegacyPass;\n  friend class MemorySSAUpdater;\n\n  void verifyOrderingDominationAndDefUses(Function &F) const;\n  void verifyDominationNumbers(const Function &F) const;\n  void verifyPrevDefInPhis(Function &F) const;\n\n  // This is used by the use optimizer and updater.\n  AccessList *getWritableBlockAccesses(const BasicBlock *BB) const {\n    auto It = PerBlockAccesses.find(BB);\n    return It == PerBlockAccesses.end() ? nullptr : It->second.get();\n  }\n\n  // This is used by the use optimizer and updater.\n  DefsList *getWritableBlockDefs(const BasicBlock *BB) const {\n    auto It = PerBlockDefs.find(BB);\n    return It == PerBlockDefs.end() ? nullptr : It->second.get();\n  }\n\n  // These is used by the updater to perform various internal MemorySSA\n  // machinsations.  They do not always leave the IR in a correct state, and\n  // relies on the updater to fixup what it breaks, so it is not public.\n\n  void moveTo(MemoryUseOrDef *What, BasicBlock *BB, AccessList::iterator Where);\n  void moveTo(MemoryAccess *What, BasicBlock *BB, InsertionPlace Point);\n\n  // Rename the dominator tree branch rooted at BB.\n  void renamePass(BasicBlock *BB, MemoryAccess *IncomingVal,\n                  SmallPtrSetImpl<BasicBlock *> &Visited) {\n    renamePass(DT->getNode(BB), IncomingVal, Visited, true, true);\n  }\n\n  void removeFromLookups(MemoryAccess *);\n  void removeFromLists(MemoryAccess *, bool ShouldDelete = true);\n  void insertIntoListsForBlock(MemoryAccess *, const BasicBlock *,\n                               InsertionPlace);\n  void insertIntoListsBefore(MemoryAccess *, const BasicBlock *,\n                             AccessList::iterator);\n  MemoryUseOrDef *createDefinedAccess(Instruction *, MemoryAccess *,\n                                      const MemoryUseOrDef *Template = nullptr,\n                                      bool CreationMustSucceed = true);\n\nprivate:\n  template <class AliasAnalysisType> class ClobberWalkerBase;\n  template <class AliasAnalysisType> class CachingWalker;\n  template <class AliasAnalysisType> class SkipSelfWalker;\n  class OptimizeUses;\n\n  CachingWalker<AliasAnalysis> *getWalkerImpl();\n  void buildMemorySSA(BatchAAResults &BAA);\n\n  void prepareForMoveTo(MemoryAccess *, BasicBlock *);\n  void verifyUseInDefs(MemoryAccess *, MemoryAccess *) const;\n\n  using AccessMap = DenseMap<const BasicBlock *, std::unique_ptr<AccessList>>;\n  using DefsMap = DenseMap<const BasicBlock *, std::unique_ptr<DefsList>>;\n\n  void markUnreachableAsLiveOnEntry(BasicBlock *BB);\n  MemoryPhi *createMemoryPhi(BasicBlock *BB);\n  template <typename AliasAnalysisType>\n  MemoryUseOrDef *createNewAccess(Instruction *, AliasAnalysisType *,\n                                  const MemoryUseOrDef *Template = nullptr);\n  void placePHINodes(const SmallPtrSetImpl<BasicBlock *> &);\n  MemoryAccess *renameBlock(BasicBlock *, MemoryAccess *, bool);\n  void renameSuccessorPhis(BasicBlock *, MemoryAccess *, bool);\n  void renamePass(DomTreeNode *, MemoryAccess *IncomingVal,\n                  SmallPtrSetImpl<BasicBlock *> &Visited,\n                  bool SkipVisited = false, bool RenameAllUses = false);\n  AccessList *getOrCreateAccessList(const BasicBlock *);\n  DefsList *getOrCreateDefsList(const BasicBlock *);\n  void renumberBlock(const BasicBlock *) const;\n  AliasAnalysis *AA;\n  DominatorTree *DT;\n  Function &F;\n\n  // Memory SSA mappings\n  DenseMap<const Value *, MemoryAccess *> ValueToMemoryAccess;\n\n  // These two mappings contain the main block to access/def mappings for\n  // MemorySSA. The list contained in PerBlockAccesses really owns all the\n  // MemoryAccesses.\n  // Both maps maintain the invariant that if a block is found in them, the\n  // corresponding list is not empty, and if a block is not found in them, the\n  // corresponding list is empty.\n  AccessMap PerBlockAccesses;\n  DefsMap PerBlockDefs;\n  std::unique_ptr<MemoryAccess, ValueDeleter> LiveOnEntryDef;\n\n  // Domination mappings\n  // Note that the numbering is local to a block, even though the map is\n  // global.\n  mutable SmallPtrSet<const BasicBlock *, 16> BlockNumberingValid;\n  mutable DenseMap<const MemoryAccess *, unsigned long> BlockNumbering;\n\n  // Memory SSA building info\n  std::unique_ptr<ClobberWalkerBase<AliasAnalysis>> WalkerBase;\n  std::unique_ptr<CachingWalker<AliasAnalysis>> Walker;\n  std::unique_ptr<SkipSelfWalker<AliasAnalysis>> SkipWalker;\n  unsigned NextID;\n};\n\n// Internal MemorySSA utils, for use by MemorySSA classes and walkers\nclass MemorySSAUtil {\nprotected:\n  friend class GVNHoist;\n  friend class MemorySSAWalker;\n\n  // This function should not be used by new passes.\n  static bool defClobbersUseOrDef(MemoryDef *MD, const MemoryUseOrDef *MU,\n                                  AliasAnalysis &AA);\n};\n\n// This pass does eager building and then printing of MemorySSA. It is used by\n// the tests to be able to build, dump, and verify Memory SSA.\nclass MemorySSAPrinterLegacyPass : public FunctionPass {\npublic:\n  MemorySSAPrinterLegacyPass();\n\n  bool runOnFunction(Function &) override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  static char ID;\n};\n\n/// An analysis that produces \\c MemorySSA for a function.\n///\nclass MemorySSAAnalysis : public AnalysisInfoMixin<MemorySSAAnalysis> {\n  friend AnalysisInfoMixin<MemorySSAAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  // Wrap MemorySSA result to ensure address stability of internal MemorySSA\n  // pointers after construction.  Use a wrapper class instead of plain\n  // unique_ptr<MemorySSA> to avoid build breakage on MSVC.\n  struct Result {\n    Result(std::unique_ptr<MemorySSA> &&MSSA) : MSSA(std::move(MSSA)) {}\n\n    MemorySSA &getMSSA() { return *MSSA.get(); }\n\n    std::unique_ptr<MemorySSA> MSSA;\n\n    bool invalidate(Function &F, const PreservedAnalyses &PA,\n                    FunctionAnalysisManager::Invalidator &Inv);\n  };\n\n  Result run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for \\c MemorySSA.\nclass MemorySSAPrinterPass : public PassInfoMixin<MemorySSAPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit MemorySSAPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for \\c MemorySSA.\nstruct MemorySSAVerifierPass : PassInfoMixin<MemorySSAVerifierPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Legacy analysis pass which computes \\c MemorySSA.\nclass MemorySSAWrapperPass : public FunctionPass {\npublic:\n  MemorySSAWrapperPass();\n\n  static char ID;\n\n  bool runOnFunction(Function &) override;\n  void releaseMemory() override;\n  MemorySSA &getMSSA() { return *MSSA; }\n  const MemorySSA &getMSSA() const { return *MSSA; }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  void verifyAnalysis() const override;\n  void print(raw_ostream &OS, const Module *M = nullptr) const override;\n\nprivate:\n  std::unique_ptr<MemorySSA> MSSA;\n};\n\n/// This is the generic walker interface for walkers of MemorySSA.\n/// Walkers are used to be able to further disambiguate the def-use chains\n/// MemorySSA gives you, or otherwise produce better info than MemorySSA gives\n/// you.\n/// In particular, while the def-use chains provide basic information, and are\n/// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a\n/// MemoryUse as AliasAnalysis considers it, a user mant want better or other\n/// information. In particular, they may want to use SCEV info to further\n/// disambiguate memory accesses, or they may want the nearest dominating\n/// may-aliasing MemoryDef for a call or a store. This API enables a\n/// standardized interface to getting and using that info.\nclass MemorySSAWalker {\npublic:\n  MemorySSAWalker(MemorySSA *);\n  virtual ~MemorySSAWalker() = default;\n\n  using MemoryAccessSet = SmallVector<MemoryAccess *, 8>;\n\n  /// Given a memory Mod/Ref/ModRef'ing instruction, calling this\n  /// will give you the nearest dominating MemoryAccess that Mod's the location\n  /// the instruction accesses (by skipping any def which AA can prove does not\n  /// alias the location(s) accessed by the instruction given).\n  ///\n  /// Note that this will return a single access, and it must dominate the\n  /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,\n  /// this will return the MemoryPhi, not the operand. This means that\n  /// given:\n  /// if (a) {\n  ///   1 = MemoryDef(liveOnEntry)\n  ///   store %a\n  /// } else {\n  ///   2 = MemoryDef(liveOnEntry)\n  ///   store %b\n  /// }\n  /// 3 = MemoryPhi(2, 1)\n  /// MemoryUse(3)\n  /// load %a\n  ///\n  /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef\n  /// in the if (a) branch.\n  MemoryAccess *getClobberingMemoryAccess(const Instruction *I) {\n    MemoryAccess *MA = MSSA->getMemoryAccess(I);\n    assert(MA && \"Handed an instruction that MemorySSA doesn't recognize?\");\n    return getClobberingMemoryAccess(MA);\n  }\n\n  /// Does the same thing as getClobberingMemoryAccess(const Instruction *I),\n  /// but takes a MemoryAccess instead of an Instruction.\n  virtual MemoryAccess *getClobberingMemoryAccess(MemoryAccess *) = 0;\n\n  /// Given a potentially clobbering memory access and a new location,\n  /// calling this will give you the nearest dominating clobbering MemoryAccess\n  /// (by skipping non-aliasing def links).\n  ///\n  /// This version of the function is mainly used to disambiguate phi translated\n  /// pointers, where the value of a pointer may have changed from the initial\n  /// memory access. Note that this expects to be handed either a MemoryUse,\n  /// or an already potentially clobbering access. Unlike the above API, if\n  /// given a MemoryDef that clobbers the pointer as the starting access, it\n  /// will return that MemoryDef, whereas the above would return the clobber\n  /// starting from the use side of  the memory def.\n  virtual MemoryAccess *getClobberingMemoryAccess(MemoryAccess *,\n                                                  const MemoryLocation &) = 0;\n\n  /// Given a memory access, invalidate anything this walker knows about\n  /// that access.\n  /// This API is used by walkers that store information to perform basic cache\n  /// invalidation.  This will be called by MemorySSA at appropriate times for\n  /// the walker it uses or returns.\n  virtual void invalidateInfo(MemoryAccess *) {}\n\nprotected:\n  friend class MemorySSA; // For updating MSSA pointer in MemorySSA move\n                          // constructor.\n  MemorySSA *MSSA;\n};\n\n/// A MemorySSAWalker that does no alias queries, or anything else. It\n/// simply returns the links as they were constructed by the builder.\nclass DoNothingMemorySSAWalker final : public MemorySSAWalker {\npublic:\n  // Keep the overrides below from hiding the Instruction overload of\n  // getClobberingMemoryAccess.\n  using MemorySSAWalker::getClobberingMemoryAccess;\n\n  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *) override;\n  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *,\n                                          const MemoryLocation &) override;\n};\n\nusing MemoryAccessPair = std::pair<MemoryAccess *, MemoryLocation>;\nusing ConstMemoryAccessPair = std::pair<const MemoryAccess *, MemoryLocation>;\n\n/// Iterator base class used to implement const and non-const iterators\n/// over the defining accesses of a MemoryAccess.\ntemplate <class T>\nclass memoryaccess_def_iterator_base\n    : public iterator_facade_base<memoryaccess_def_iterator_base<T>,\n                                  std::forward_iterator_tag, T, ptrdiff_t, T *,\n                                  T *> {\n  using BaseT = typename memoryaccess_def_iterator_base::iterator_facade_base;\n\npublic:\n  memoryaccess_def_iterator_base(T *Start) : Access(Start) {}\n  memoryaccess_def_iterator_base() = default;\n\n  bool operator==(const memoryaccess_def_iterator_base &Other) const {\n    return Access == Other.Access && (!Access || ArgNo == Other.ArgNo);\n  }\n\n  // This is a bit ugly, but for MemoryPHI's, unlike PHINodes, you can't get the\n  // block from the operand in constant time (In a PHINode, the uselist has\n  // both, so it's just subtraction). We provide it as part of the\n  // iterator to avoid callers having to linear walk to get the block.\n  // If the operation becomes constant time on MemoryPHI's, this bit of\n  // abstraction breaking should be removed.\n  BasicBlock *getPhiArgBlock() const {\n    MemoryPhi *MP = dyn_cast<MemoryPhi>(Access);\n    assert(MP && \"Tried to get phi arg block when not iterating over a PHI\");\n    return MP->getIncomingBlock(ArgNo);\n  }\n\n  typename BaseT::iterator::pointer operator*() const {\n    assert(Access && \"Tried to access past the end of our iterator\");\n    // Go to the first argument for phis, and the defining access for everything\n    // else.\n    if (const MemoryPhi *MP = dyn_cast<MemoryPhi>(Access))\n      return MP->getIncomingValue(ArgNo);\n    return cast<MemoryUseOrDef>(Access)->getDefiningAccess();\n  }\n\n  using BaseT::operator++;\n  memoryaccess_def_iterator_base &operator++() {\n    assert(Access && \"Hit end of iterator\");\n    if (const MemoryPhi *MP = dyn_cast<MemoryPhi>(Access)) {\n      if (++ArgNo >= MP->getNumIncomingValues()) {\n        ArgNo = 0;\n        Access = nullptr;\n      }\n    } else {\n      Access = nullptr;\n    }\n    return *this;\n  }\n\nprivate:\n  T *Access = nullptr;\n  unsigned ArgNo = 0;\n};\n\ninline memoryaccess_def_iterator MemoryAccess::defs_begin() {\n  return memoryaccess_def_iterator(this);\n}\n\ninline const_memoryaccess_def_iterator MemoryAccess::defs_begin() const {\n  return const_memoryaccess_def_iterator(this);\n}\n\ninline memoryaccess_def_iterator MemoryAccess::defs_end() {\n  return memoryaccess_def_iterator();\n}\n\ninline const_memoryaccess_def_iterator MemoryAccess::defs_end() const {\n  return const_memoryaccess_def_iterator();\n}\n\n/// GraphTraits for a MemoryAccess, which walks defs in the normal case,\n/// and uses in the inverse case.\ntemplate <> struct GraphTraits<MemoryAccess *> {\n  using NodeRef = MemoryAccess *;\n  using ChildIteratorType = memoryaccess_def_iterator;\n\n  static NodeRef getEntryNode(NodeRef N) { return N; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->defs_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->defs_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<MemoryAccess *>> {\n  using NodeRef = MemoryAccess *;\n  using ChildIteratorType = MemoryAccess::iterator;\n\n  static NodeRef getEntryNode(NodeRef N) { return N; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->user_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->user_end(); }\n};\n\n/// Provide an iterator that walks defs, giving both the memory access,\n/// and the current pointer location, updating the pointer location as it\n/// changes due to phi node translation.\n///\n/// This iterator, while somewhat specialized, is what most clients actually\n/// want when walking upwards through MemorySSA def chains. It takes a pair of\n/// <MemoryAccess,MemoryLocation>, and walks defs, properly translating the\n/// memory location through phi nodes for the user.\nclass upward_defs_iterator\n    : public iterator_facade_base<upward_defs_iterator,\n                                  std::forward_iterator_tag,\n                                  const MemoryAccessPair> {\n  using BaseT = upward_defs_iterator::iterator_facade_base;\n\npublic:\n  upward_defs_iterator(const MemoryAccessPair &Info, DominatorTree *DT,\n                       bool *PerformedPhiTranslation = nullptr)\n      : DefIterator(Info.first), Location(Info.second),\n        OriginalAccess(Info.first), DT(DT),\n        PerformedPhiTranslation(PerformedPhiTranslation) {\n    CurrentPair.first = nullptr;\n\n    WalkingPhi = Info.first && isa<MemoryPhi>(Info.first);\n    fillInCurrentPair();\n  }\n\n  upward_defs_iterator() { CurrentPair.first = nullptr; }\n\n  bool operator==(const upward_defs_iterator &Other) const {\n    return DefIterator == Other.DefIterator;\n  }\n\n  BaseT::iterator::reference operator*() const {\n    assert(DefIterator != OriginalAccess->defs_end() &&\n           \"Tried to access past the end of our iterator\");\n    return CurrentPair;\n  }\n\n  using BaseT::operator++;\n  upward_defs_iterator &operator++() {\n    assert(DefIterator != OriginalAccess->defs_end() &&\n           \"Tried to access past the end of the iterator\");\n    ++DefIterator;\n    if (DefIterator != OriginalAccess->defs_end())\n      fillInCurrentPair();\n    return *this;\n  }\n\n  BasicBlock *getPhiArgBlock() const { return DefIterator.getPhiArgBlock(); }\n\nprivate:\n  /// Returns true if \\p Ptr is guaranteed to be loop invariant for any possible\n  /// loop. In particular, this guarantees that it only references a single\n  /// MemoryLocation during execution of the containing function.\n  bool IsGuaranteedLoopInvariant(Value *Ptr) const;\n\n  void fillInCurrentPair() {\n    CurrentPair.first = *DefIterator;\n    CurrentPair.second = Location;\n    if (WalkingPhi && Location.Ptr) {\n      // Mark size as unknown, if the location is not guaranteed to be\n      // loop-invariant for any possible loop in the function. Setting the size\n      // to unknown guarantees that any memory accesses that access locations\n      // after the pointer are considered as clobbers, which is important to\n      // catch loop carried dependences.\n      if (Location.Ptr &&\n          !IsGuaranteedLoopInvariant(const_cast<Value *>(Location.Ptr)))\n        CurrentPair.second =\n            Location.getWithNewSize(LocationSize::beforeOrAfterPointer());\n      PHITransAddr Translator(\n          const_cast<Value *>(Location.Ptr),\n          OriginalAccess->getBlock()->getModule()->getDataLayout(), nullptr);\n\n      if (!Translator.PHITranslateValue(OriginalAccess->getBlock(),\n                                        DefIterator.getPhiArgBlock(), DT,\n                                        true)) {\n        Value *TransAddr = Translator.getAddr();\n        if (TransAddr != Location.Ptr) {\n          CurrentPair.second = CurrentPair.second.getWithNewPtr(TransAddr);\n\n          if (TransAddr &&\n              !IsGuaranteedLoopInvariant(const_cast<Value *>(TransAddr)))\n            CurrentPair.second = CurrentPair.second.getWithNewSize(\n                LocationSize::beforeOrAfterPointer());\n\n          if (PerformedPhiTranslation)\n            *PerformedPhiTranslation = true;\n        }\n      }\n    }\n  }\n\n  MemoryAccessPair CurrentPair;\n  memoryaccess_def_iterator DefIterator;\n  MemoryLocation Location;\n  MemoryAccess *OriginalAccess = nullptr;\n  DominatorTree *DT = nullptr;\n  bool WalkingPhi = false;\n  bool *PerformedPhiTranslation = nullptr;\n};\n\ninline upward_defs_iterator\nupward_defs_begin(const MemoryAccessPair &Pair, DominatorTree &DT,\n                  bool *PerformedPhiTranslation = nullptr) {\n  return upward_defs_iterator(Pair, &DT, PerformedPhiTranslation);\n}\n\ninline upward_defs_iterator upward_defs_end() { return upward_defs_iterator(); }\n\ninline iterator_range<upward_defs_iterator>\nupward_defs(const MemoryAccessPair &Pair, DominatorTree &DT) {\n  return make_range(upward_defs_begin(Pair, DT), upward_defs_end());\n}\n\n/// Walks the defining accesses of MemoryDefs. Stops after we hit something that\n/// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when\n/// comparing against a null def_chain_iterator, this will compare equal only\n/// after walking said Phi/liveOnEntry.\n///\n/// The UseOptimizedChain flag specifies whether to walk the clobbering\n/// access chain, or all the accesses.\n///\n/// Normally, MemoryDef are all just def/use linked together, so a def_chain on\n/// a MemoryDef will walk all MemoryDefs above it in the program until it hits\n/// a phi node.  The optimized chain walks the clobbering access of a store.\n/// So if you are just trying to find, given a store, what the next\n/// thing that would clobber the same memory is, you want the optimized chain.\ntemplate <class T, bool UseOptimizedChain = false>\nstruct def_chain_iterator\n    : public iterator_facade_base<def_chain_iterator<T, UseOptimizedChain>,\n                                  std::forward_iterator_tag, MemoryAccess *> {\n  def_chain_iterator() : MA(nullptr) {}\n  def_chain_iterator(T MA) : MA(MA) {}\n\n  T operator*() const { return MA; }\n\n  def_chain_iterator &operator++() {\n    // N.B. liveOnEntry has a null defining access.\n    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA)) {\n      if (UseOptimizedChain && MUD->isOptimized())\n        MA = MUD->getOptimized();\n      else\n        MA = MUD->getDefiningAccess();\n    } else {\n      MA = nullptr;\n    }\n\n    return *this;\n  }\n\n  bool operator==(const def_chain_iterator &O) const { return MA == O.MA; }\n\nprivate:\n  T MA;\n};\n\ntemplate <class T>\ninline iterator_range<def_chain_iterator<T>>\ndef_chain(T MA, MemoryAccess *UpTo = nullptr) {\n#ifdef EXPENSIVE_CHECKS\n  assert((!UpTo || find(def_chain(MA), UpTo) != def_chain_iterator<T>()) &&\n         \"UpTo isn't in the def chain!\");\n#endif\n  return make_range(def_chain_iterator<T>(MA), def_chain_iterator<T>(UpTo));\n}\n\ntemplate <class T>\ninline iterator_range<def_chain_iterator<T, true>> optimized_def_chain(T MA) {\n  return make_range(def_chain_iterator<T, true>(MA),\n                    def_chain_iterator<T, true>(nullptr));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_MEMORYSSA_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MustExecute.h", "content": "//===- MustExecute.h - Is an instruction known to execute--------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// Contains a collection of routines for determining if a given instruction is\n/// guaranteed to execute if a given point in control flow is reached. The most\n/// common example is an instruction within a loop being provably executed if we\n/// branch to the header of it's containing loop.\n///\n/// There are two interfaces available to determine if an instruction is\n/// executed once a given point in the control flow is reached:\n/// 1) A loop-centric one derived from LoopSafetyInfo.\n/// 2) A \"must be executed context\"-based one implemented in the\n///    MustBeExecutedContextExplorer.\n/// Please refer to the class comments for more information.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_MUSTEXECUTE_H\n#define LLVM_ANALYSIS_MUSTEXECUTE_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/Analysis/InstructionPrecedenceTracking.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nnamespace {\ntemplate <typename T> using GetterTy = std::function<T *(const Function &F)>;\n}\n\nclass BasicBlock;\nclass DominatorTree;\nclass Instruction;\nclass Loop;\nclass LoopInfo;\nclass PostDominatorTree;\n\n/// Captures loop safety information.\n/// It keep information for loop blocks may throw exception or otherwise\n/// exit abnormally on any iteration of the loop which might actually execute\n/// at runtime.  The primary way to consume this information is via\n/// isGuaranteedToExecute below, but some callers bailout or fallback to\n/// alternate reasoning if a loop contains any implicit control flow.\n/// NOTE: LoopSafetyInfo contains cached information regarding loops and their\n/// particular blocks. This information is only dropped on invocation of\n/// computeLoopSafetyInfo. If the loop or any of its block is deleted, or if\n/// any thrower instructions have been added or removed from them, or if the\n/// control flow has changed, or in case of other meaningful modifications, the\n/// LoopSafetyInfo needs to be recomputed. If a meaningful modifications to the\n/// loop were made and the info wasn't recomputed properly, the behavior of all\n/// methods except for computeLoopSafetyInfo is undefined.\nclass LoopSafetyInfo {\n  // Used to update funclet bundle operands.\n  DenseMap<BasicBlock *, ColorVector> BlockColors;\n\nprotected:\n  /// Computes block colors.\n  void computeBlockColors(const Loop *CurLoop);\n\npublic:\n  /// Returns block colors map that is used to update funclet operand bundles.\n  const DenseMap<BasicBlock *, ColorVector> &getBlockColors() const;\n\n  /// Copy colors of block \\p Old into the block \\p New.\n  void copyColors(BasicBlock *New, BasicBlock *Old);\n\n  /// Returns true iff the block \\p BB potentially may throw exception. It can\n  /// be false-positive in cases when we want to avoid complex analysis.\n  virtual bool blockMayThrow(const BasicBlock *BB) const = 0;\n\n  /// Returns true iff any block of the loop for which this info is contains an\n  /// instruction that may throw or otherwise exit abnormally.\n  virtual bool anyBlockMayThrow() const = 0;\n\n  /// Return true if we must reach the block \\p BB under assumption that the\n  /// loop \\p CurLoop is entered.\n  bool allLoopPathsLeadToBlock(const Loop *CurLoop, const BasicBlock *BB,\n                               const DominatorTree *DT) const;\n\n  /// Computes safety information for a loop checks loop body & header for\n  /// the possibility of may throw exception, it takes LoopSafetyInfo and loop\n  /// as argument. Updates safety information in LoopSafetyInfo argument.\n  /// Note: This is defined to clear and reinitialize an already initialized\n  /// LoopSafetyInfo.  Some callers rely on this fact.\n  virtual void computeLoopSafetyInfo(const Loop *CurLoop) = 0;\n\n  /// Returns true if the instruction in a loop is guaranteed to execute at\n  /// least once (under the assumption that the loop is entered).\n  virtual bool isGuaranteedToExecute(const Instruction &Inst,\n                                     const DominatorTree *DT,\n                                     const Loop *CurLoop) const = 0;\n\n  LoopSafetyInfo() = default;\n\n  virtual ~LoopSafetyInfo() = default;\n};\n\n\n/// Simple and conservative implementation of LoopSafetyInfo that can give\n/// false-positive answers to its queries in order to avoid complicated\n/// analysis.\nclass SimpleLoopSafetyInfo: public LoopSafetyInfo {\n  bool MayThrow = false;       // The current loop contains an instruction which\n                               // may throw.\n  bool HeaderMayThrow = false; // Same as previous, but specific to loop header\n\npublic:\n  bool blockMayThrow(const BasicBlock *BB) const override;\n\n  bool anyBlockMayThrow() const override;\n\n  void computeLoopSafetyInfo(const Loop *CurLoop) override;\n\n  bool isGuaranteedToExecute(const Instruction &Inst,\n                             const DominatorTree *DT,\n                             const Loop *CurLoop) const override;\n};\n\n/// This implementation of LoopSafetyInfo use ImplicitControlFlowTracking to\n/// give precise answers on \"may throw\" queries. This implementation uses cache\n/// that should be invalidated by calling the methods insertInstructionTo and\n/// removeInstruction whenever we modify a basic block's contents by adding or\n/// removing instructions.\nclass ICFLoopSafetyInfo: public LoopSafetyInfo {\n  bool MayThrow = false;       // The current loop contains an instruction which\n                               // may throw.\n  // Contains information about implicit control flow in this loop's blocks.\n  mutable ImplicitControlFlowTracking ICF;\n  // Contains information about instruction that may possibly write memory.\n  mutable MemoryWriteTracking MW;\n\npublic:\n  bool blockMayThrow(const BasicBlock *BB) const override;\n\n  bool anyBlockMayThrow() const override;\n\n  void computeLoopSafetyInfo(const Loop *CurLoop) override;\n\n  bool isGuaranteedToExecute(const Instruction &Inst,\n                             const DominatorTree *DT,\n                             const Loop *CurLoop) const override;\n\n  /// Returns true if we could not execute a memory-modifying instruction before\n  /// we enter \\p BB under assumption that \\p CurLoop is entered.\n  bool doesNotWriteMemoryBefore(const BasicBlock *BB, const Loop *CurLoop)\n      const;\n\n  /// Returns true if we could not execute a memory-modifying instruction before\n  /// we execute \\p I under assumption that \\p CurLoop is entered.\n  bool doesNotWriteMemoryBefore(const Instruction &I, const Loop *CurLoop)\n      const;\n\n  /// Inform the safety info that we are planning to insert a new instruction\n  /// \\p Inst into the basic block \\p BB. It will make all cache updates to keep\n  /// it correct after this insertion.\n  void insertInstructionTo(const Instruction *Inst, const BasicBlock *BB);\n\n  /// Inform safety info that we are planning to remove the instruction \\p Inst\n  /// from its block. It will make all cache updates to keep it correct after\n  /// this removal.\n  void removeInstruction(const Instruction *Inst);\n};\n\nbool mayContainIrreducibleControl(const Function &F, const LoopInfo *LI);\n\nstruct MustBeExecutedContextExplorer;\n\n/// Enum that allows us to spell out the direction.\nenum class ExplorationDirection {\n  BACKWARD = 0,\n  FORWARD = 1,\n};\n\n/// Must be executed iterators visit stretches of instructions that are\n/// guaranteed to be executed together, potentially with other instruction\n/// executed in-between.\n///\n/// Given the following code, and assuming all statements are single\n/// instructions which transfer execution to the successor (see\n/// isGuaranteedToTransferExecutionToSuccessor), there are two possible\n/// outcomes. If we start the iterator at A, B, or E, we will visit only A, B,\n/// and E. If we start at C or D, we will visit all instructions A-E.\n///\n/// \\code\n///   A;\n///   B;\n///   if (...) {\n///     C;\n///     D;\n///   }\n///   E;\n/// \\endcode\n///\n///\n/// Below is the example extneded with instructions F and G. Now we assume F\n/// might not transfer execution to it's successor G. As a result we get the\n/// following visit sets:\n///\n/// Start Instruction   | Visit Set\n/// A                   | A, B,       E, F\n///    B                | A, B,       E, F\n///       C             | A, B, C, D, E, F\n///          D          | A, B, C, D, E, F\n///             E       | A, B,       E, F\n///                F    | A, B,       E, F\n///                   G | A, B,       E, F, G\n///\n///\n/// \\code\n///   A;\n///   B;\n///   if (...) {\n///     C;\n///     D;\n///   }\n///   E;\n///   F;  // Might not transfer execution to its successor G.\n///   G;\n/// \\endcode\n///\n///\n/// A more complex example involving conditionals, loops, break, and continue\n/// is shown below. We again assume all instructions will transmit control to\n/// the successor and we assume we can prove the inner loop to be finite. We\n/// omit non-trivial branch conditions as the exploration is oblivious to them.\n/// Constant branches are assumed to be unconditional in the CFG. The resulting\n/// visist sets are shown in the table below.\n///\n/// \\code\n///   A;\n///   while (true) {\n///     B;\n///     if (...)\n///       C;\n///     if (...)\n///       continue;\n///     D;\n///     if (...)\n///       break;\n///     do {\n///       if (...)\n///         continue;\n///       E;\n///     } while (...);\n///     F;\n///   }\n///   G;\n/// \\endcode\n///\n/// Start Instruction    | Visit Set\n/// A                    | A, B\n///    B                 | A, B\n///       C              | A, B, C\n///          D           | A, B,    D\n///             E        | A, B,    D, E, F\n///                F     | A, B,    D,    F\n///                   G  | A, B,    D,       G\n///\n///\n/// Note that the examples show optimal visist sets but not necessarily the ones\n/// derived by the explorer depending on the available CFG analyses (see\n/// MustBeExecutedContextExplorer). Also note that we, depending on the options,\n/// the visit set can contain instructions from other functions.\nstruct MustBeExecutedIterator {\n  /// Type declarations that make his class an input iterator.\n  ///{\n  typedef const Instruction *value_type;\n  typedef std::ptrdiff_t difference_type;\n  typedef const Instruction **pointer;\n  typedef const Instruction *&reference;\n  typedef std::input_iterator_tag iterator_category;\n  ///}\n\n  using ExplorerTy = MustBeExecutedContextExplorer;\n\n  MustBeExecutedIterator(const MustBeExecutedIterator &Other)\n      : Visited(Other.Visited), Explorer(Other.Explorer),\n        CurInst(Other.CurInst), Head(Other.Head), Tail(Other.Tail) {}\n\n  MustBeExecutedIterator(MustBeExecutedIterator &&Other)\n      : Visited(std::move(Other.Visited)), Explorer(Other.Explorer),\n        CurInst(Other.CurInst), Head(Other.Head), Tail(Other.Tail) {}\n\n  MustBeExecutedIterator &operator=(MustBeExecutedIterator &&Other) {\n    if (this != &Other) {\n      std::swap(Visited, Other.Visited);\n      std::swap(CurInst, Other.CurInst);\n      std::swap(Head, Other.Head);\n      std::swap(Tail, Other.Tail);\n    }\n    return *this;\n  }\n\n  ~MustBeExecutedIterator() {}\n\n  /// Pre- and post-increment operators.\n  ///{\n  MustBeExecutedIterator &operator++() {\n    CurInst = advance();\n    return *this;\n  }\n\n  MustBeExecutedIterator operator++(int) {\n    MustBeExecutedIterator tmp(*this);\n    operator++();\n    return tmp;\n  }\n  ///}\n\n  /// Equality and inequality operators. Note that we ignore the history here.\n  ///{\n  bool operator==(const MustBeExecutedIterator &Other) const {\n    return CurInst == Other.CurInst && Head == Other.Head && Tail == Other.Tail;\n  }\n\n  bool operator!=(const MustBeExecutedIterator &Other) const {\n    return !(*this == Other);\n  }\n  ///}\n\n  /// Return the underlying instruction.\n  const Instruction *&operator*() { return CurInst; }\n  const Instruction *getCurrentInst() const { return CurInst; }\n\n  /// Return true if \\p I was encountered by this iterator already.\n  bool count(const Instruction *I) const {\n    return Visited.count({I, ExplorationDirection::FORWARD}) ||\n           Visited.count({I, ExplorationDirection::BACKWARD});\n  }\n\nprivate:\n  using VisitedSetTy =\n      DenseSet<PointerIntPair<const Instruction *, 1, ExplorationDirection>>;\n\n  /// Private constructors.\n  MustBeExecutedIterator(ExplorerTy &Explorer, const Instruction *I);\n\n  /// Reset the iterator to its initial state pointing at \\p I.\n  void reset(const Instruction *I);\n\n  /// Reset the iterator to point at \\p I, keep cached state.\n  void resetInstruction(const Instruction *I);\n\n  /// Try to advance one of the underlying positions (Head or Tail).\n  ///\n  /// \\return The next instruction in the must be executed context, or nullptr\n  ///         if none was found.\n  const Instruction *advance();\n\n  /// A set to track the visited instructions in order to deal with endless\n  /// loops and recursion.\n  VisitedSetTy Visited;\n\n  /// A reference to the explorer that created this iterator.\n  ExplorerTy &Explorer;\n\n  /// The instruction we are currently exposing to the user. There is always an\n  /// instruction that we know is executed with the given program point,\n  /// initially the program point itself.\n  const Instruction *CurInst;\n\n  /// Two positions that mark the program points where this iterator will look\n  /// for the next instruction. Note that the current instruction is either the\n  /// one pointed to by Head, Tail, or both.\n  const Instruction *Head, *Tail;\n\n  friend struct MustBeExecutedContextExplorer;\n};\n\n/// A \"must be executed context\" for a given program point PP is the set of\n/// instructions, potentially before and after PP, that are executed always when\n/// PP is reached. The MustBeExecutedContextExplorer an interface to explore\n/// \"must be executed contexts\" in a module through the use of\n/// MustBeExecutedIterator.\n///\n/// The explorer exposes \"must be executed iterators\" that traverse the must be\n/// executed context. There is little information sharing between iterators as\n/// the expected use case involves few iterators for \"far apart\" instructions.\n/// If that changes, we should consider caching more intermediate results.\nstruct MustBeExecutedContextExplorer {\n\n  /// In the description of the parameters we use PP to denote a program point\n  /// for which the must be executed context is explored, or put differently,\n  /// for which the MustBeExecutedIterator is created.\n  ///\n  /// \\param ExploreInterBlock    Flag to indicate if instructions in blocks\n  ///                             other than the parent of PP should be\n  ///                             explored.\n  /// \\param ExploreCFGForward    Flag to indicate if instructions located after\n  ///                             PP in the CFG, e.g., post-dominating PP,\n  ///                             should be explored.\n  /// \\param ExploreCFGBackward   Flag to indicate if instructions located\n  ///                             before PP in the CFG, e.g., dominating PP,\n  ///                             should be explored.\n  MustBeExecutedContextExplorer(\n      bool ExploreInterBlock, bool ExploreCFGForward, bool ExploreCFGBackward,\n      GetterTy<const LoopInfo> LIGetter =\n          [](const Function &) { return nullptr; },\n      GetterTy<const DominatorTree> DTGetter =\n          [](const Function &) { return nullptr; },\n      GetterTy<const PostDominatorTree> PDTGetter =\n          [](const Function &) { return nullptr; })\n      : ExploreInterBlock(ExploreInterBlock),\n        ExploreCFGForward(ExploreCFGForward),\n        ExploreCFGBackward(ExploreCFGBackward), LIGetter(LIGetter),\n        DTGetter(DTGetter), PDTGetter(PDTGetter), EndIterator(*this, nullptr) {}\n\n  /// Iterator-based interface. \\see MustBeExecutedIterator.\n  ///{\n  using iterator = MustBeExecutedIterator;\n  using const_iterator = const MustBeExecutedIterator;\n\n  /// Return an iterator to explore the context around \\p PP.\n  iterator &begin(const Instruction *PP) {\n    auto &It = InstructionIteratorMap[PP];\n    if (!It)\n      It.reset(new iterator(*this, PP));\n    return *It;\n  }\n\n  /// Return an iterator to explore the cached context around \\p PP.\n  const_iterator &begin(const Instruction *PP) const {\n    return *InstructionIteratorMap.find(PP)->second;\n  }\n\n  /// Return an universal end iterator.\n  ///{\n  iterator &end() { return EndIterator; }\n  iterator &end(const Instruction *) { return EndIterator; }\n\n  const_iterator &end() const { return EndIterator; }\n  const_iterator &end(const Instruction *) const { return EndIterator; }\n  ///}\n\n  /// Return an iterator range to explore the context around \\p PP.\n  llvm::iterator_range<iterator> range(const Instruction *PP) {\n    return llvm::make_range(begin(PP), end(PP));\n  }\n\n  /// Return an iterator range to explore the cached context around \\p PP.\n  llvm::iterator_range<const_iterator> range(const Instruction *PP) const {\n    return llvm::make_range(begin(PP), end(PP));\n  }\n  ///}\n\n  /// Check \\p Pred on all instructions in the context.\n  ///\n  /// This method will evaluate \\p Pred and return\n  /// true if \\p Pred holds in every instruction.\n  bool checkForAllContext(const Instruction *PP,\n                          function_ref<bool(const Instruction *)> Pred) {\n    for (auto EIt = begin(PP), EEnd = end(PP); EIt != EEnd; ++EIt)\n      if (!Pred(*EIt))\n        return false;\n    return true;\n  }\n\n  /// Helper to look for \\p I in the context of \\p PP.\n  ///\n  /// The context is expanded until \\p I was found or no more expansion is\n  /// possible.\n  ///\n  /// \\returns True, iff \\p I was found.\n  bool findInContextOf(const Instruction *I, const Instruction *PP) {\n    auto EIt = begin(PP), EEnd = end(PP);\n    return findInContextOf(I, EIt, EEnd);\n  }\n\n  /// Helper to look for \\p I in the context defined by \\p EIt and \\p EEnd.\n  ///\n  /// The context is expanded until \\p I was found or no more expansion is\n  /// possible.\n  ///\n  /// \\returns True, iff \\p I was found.\n  bool findInContextOf(const Instruction *I, iterator &EIt, iterator &EEnd) {\n    bool Found = EIt.count(I);\n    while (!Found && EIt != EEnd)\n      Found = (++EIt).getCurrentInst() == I;\n    return Found;\n  }\n\n  /// Return the next instruction that is guaranteed to be executed after \\p PP.\n  ///\n  /// \\param It              The iterator that is used to traverse the must be\n  ///                        executed context.\n  /// \\param PP              The program point for which the next instruction\n  ///                        that is guaranteed to execute is determined.\n  const Instruction *\n  getMustBeExecutedNextInstruction(MustBeExecutedIterator &It,\n                                   const Instruction *PP);\n  /// Return the previous instr. that is guaranteed to be executed before \\p PP.\n  ///\n  /// \\param It              The iterator that is used to traverse the must be\n  ///                        executed context.\n  /// \\param PP              The program point for which the previous instr.\n  ///                        that is guaranteed to execute is determined.\n  const Instruction *\n  getMustBeExecutedPrevInstruction(MustBeExecutedIterator &It,\n                                   const Instruction *PP);\n\n  /// Find the next join point from \\p InitBB in forward direction.\n  const BasicBlock *findForwardJoinPoint(const BasicBlock *InitBB);\n\n  /// Find the next join point from \\p InitBB in backward direction.\n  const BasicBlock *findBackwardJoinPoint(const BasicBlock *InitBB);\n\n  /// Parameter that limit the performed exploration. See the constructor for\n  /// their meaning.\n  ///{\n  const bool ExploreInterBlock;\n  const bool ExploreCFGForward;\n  const bool ExploreCFGBackward;\n  ///}\n\nprivate:\n  /// Getters for common CFG analyses: LoopInfo, DominatorTree, and\n  /// PostDominatorTree.\n  ///{\n  GetterTy<const LoopInfo> LIGetter;\n  GetterTy<const DominatorTree> DTGetter;\n  GetterTy<const PostDominatorTree> PDTGetter;\n  ///}\n\n  /// Map to cache isGuaranteedToTransferExecutionToSuccessor results.\n  DenseMap<const BasicBlock *, Optional<bool>> BlockTransferMap;\n\n  /// Map to cache containsIrreducibleCFG results.\n  DenseMap<const Function*, Optional<bool>> IrreducibleControlMap;\n\n  /// Map from instructions to associated must be executed iterators.\n  DenseMap<const Instruction *, std::unique_ptr<MustBeExecutedIterator>>\n      InstructionIteratorMap;\n\n  /// A unique end iterator.\n  MustBeExecutedIterator EndIterator;\n};\n\nclass MustExecutePrinterPass : public PassInfoMixin<MustExecutePrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  MustExecutePrinterPass(raw_ostream &OS) : OS(OS) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\nclass MustBeExecutedContextPrinterPass\n    : public PassInfoMixin<MustBeExecutedContextPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  MustBeExecutedContextPrinterPass(raw_ostream &OS) : OS(OS) {}\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n};\n\n} // namespace llvm\n\n#endif\n"}, "102": {"id": 102, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h", "content": "//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This header provides classes for managing a pipeline of passes over loops\n/// in LLVM IR.\n///\n/// The primary loop pass pipeline is managed in a very particular way to\n/// provide a set of core guarantees:\n/// 1) Loops are, where possible, in simplified form.\n/// 2) Loops are *always* in LCSSA form.\n/// 3) A collection of Loop-specific analysis results are available:\n///    - LoopInfo\n///    - DominatorTree\n///    - ScalarEvolution\n///    - AAManager\n/// 4) All loop passes preserve #1 (where possible), #2, and #3.\n/// 5) Loop passes run over each loop in the loop nest from the innermost to\n///    the outermost. Specifically, all inner loops are processed before\n///    passes run over outer loops. When running the pipeline across an inner\n///    loop creates new inner loops, those are added and processed in this\n///    order as well.\n///\n/// This process is designed to facilitate transformations which simplify,\n/// reduce, and remove loops. For passes which are more oriented towards\n/// optimizing loops, especially optimizing loop *nests* instead of single\n/// loops in isolation, this framework is less interesting.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_LOOPPASSMANAGER_H\n#define LLVM_TRANSFORMS_SCALAR_LOOPPASSMANAGER_H\n\n#include \"llvm/ADT/PriorityWorklist.h\"\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/LoopNestAnalysis.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/PassInstrumentation.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Transforms/Utils/LCSSA.h\"\n#include \"llvm/Transforms/Utils/LoopSimplify.h\"\n#include \"llvm/Transforms/Utils/LoopUtils.h\"\n#include <memory>\n\nnamespace llvm {\n\n// Forward declarations of an update tracking API used in the pass manager.\nclass LPMUpdater;\n\nnamespace {\n\ntemplate <typename PassT>\nusing HasRunOnLoopT = decltype(std::declval<PassT>().run(\n    std::declval<Loop &>(), std::declval<LoopAnalysisManager &>(),\n    std::declval<LoopStandardAnalysisResults &>(),\n    std::declval<LPMUpdater &>()));\n\n} // namespace\n\n// Explicit specialization and instantiation declarations for the pass manager.\n// See the comments on the definition of the specialization for details on how\n// it differs from the primary template.\ntemplate <>\nclass PassManager<Loop, LoopAnalysisManager, LoopStandardAnalysisResults &,\n                  LPMUpdater &>\n    : public PassInfoMixin<\n          PassManager<Loop, LoopAnalysisManager, LoopStandardAnalysisResults &,\n                      LPMUpdater &>> {\npublic:\n  /// Construct a pass manager.\n  ///\n  /// If \\p DebugLogging is true, we'll log our progress to llvm::dbgs().\n  explicit PassManager(bool DebugLogging = false)\n      : DebugLogging(DebugLogging) {}\n\n  // FIXME: These are equivalent to the default move constructor/move\n  // assignment. However, using = default triggers linker errors due to the\n  // explicit instantiations below. Find a way to use the default and remove the\n  // duplicated code here.\n  PassManager(PassManager &&Arg)\n      : IsLoopNestPass(std::move(Arg.IsLoopNestPass)),\n        LoopPasses(std::move(Arg.LoopPasses)),\n        LoopNestPasses(std::move(Arg.LoopNestPasses)),\n        DebugLogging(std::move(Arg.DebugLogging)) {}\n\n  PassManager &operator=(PassManager &&RHS) {\n    IsLoopNestPass = std::move(RHS.IsLoopNestPass);\n    LoopPasses = std::move(RHS.LoopPasses);\n    LoopNestPasses = std::move(RHS.LoopNestPasses);\n    DebugLogging = std::move(RHS.DebugLogging);\n    return *this;\n  }\n\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n\n  /// Add either a loop pass or a loop-nest pass to the pass manager. Append \\p\n  /// Pass to the list of loop passes if it has a dedicated \\fn run() method for\n  /// loops and to the list of loop-nest passes if the \\fn run() method is for\n  /// loop-nests instead. Also append whether \\p Pass is loop-nest pass or not\n  /// to the end of \\var IsLoopNestPass so we can easily identify the types of\n  /// passes in the pass manager later.\n  template <typename PassT>\n  std::enable_if_t<is_detected<HasRunOnLoopT, PassT>::value>\n  addPass(PassT Pass) {\n    using LoopPassModelT =\n        detail::PassModel<Loop, PassT, PreservedAnalyses, LoopAnalysisManager,\n                          LoopStandardAnalysisResults &, LPMUpdater &>;\n    IsLoopNestPass.push_back(false);\n    LoopPasses.emplace_back(new LoopPassModelT(std::move(Pass)));\n  }\n\n  template <typename PassT>\n  std::enable_if_t<!is_detected<HasRunOnLoopT, PassT>::value>\n  addPass(PassT Pass) {\n    using LoopNestPassModelT =\n        detail::PassModel<LoopNest, PassT, PreservedAnalyses,\n                          LoopAnalysisManager, LoopStandardAnalysisResults &,\n                          LPMUpdater &>;\n    IsLoopNestPass.push_back(true);\n    LoopNestPasses.emplace_back(new LoopNestPassModelT(std::move(Pass)));\n  }\n\n  // Specializations of `addPass` for `RepeatedPass`. These are necessary since\n  // `RepeatedPass` has a templated `run` method that will result in incorrect\n  // detection of `HasRunOnLoopT`.\n  template <typename PassT>\n  std::enable_if_t<is_detected<HasRunOnLoopT, PassT>::value>\n  addPass(RepeatedPass<PassT> Pass) {\n    using RepeatedLoopPassModelT =\n        detail::PassModel<Loop, RepeatedPass<PassT>, PreservedAnalyses,\n                          LoopAnalysisManager, LoopStandardAnalysisResults &,\n                          LPMUpdater &>;\n    IsLoopNestPass.push_back(false);\n    LoopPasses.emplace_back(new RepeatedLoopPassModelT(std::move(Pass)));\n  }\n\n  template <typename PassT>\n  std::enable_if_t<!is_detected<HasRunOnLoopT, PassT>::value>\n  addPass(RepeatedPass<PassT> Pass) {\n    using RepeatedLoopNestPassModelT =\n        detail::PassModel<LoopNest, RepeatedPass<PassT>, PreservedAnalyses,\n                          LoopAnalysisManager, LoopStandardAnalysisResults &,\n                          LPMUpdater &>;\n    IsLoopNestPass.push_back(true);\n    LoopNestPasses.emplace_back(\n        new RepeatedLoopNestPassModelT(std::move(Pass)));\n  }\n\n  bool isEmpty() const { return LoopPasses.empty() && LoopNestPasses.empty(); }\n\n  static bool isRequired() { return true; }\n\n  size_t getNumLoopPasses() const { return LoopPasses.size(); }\n  size_t getNumLoopNestPasses() const { return LoopNestPasses.size(); }\n\nprotected:\n  using LoopPassConceptT =\n      detail::PassConcept<Loop, LoopAnalysisManager,\n                          LoopStandardAnalysisResults &, LPMUpdater &>;\n  using LoopNestPassConceptT =\n      detail::PassConcept<LoopNest, LoopAnalysisManager,\n                          LoopStandardAnalysisResults &, LPMUpdater &>;\n\n  // BitVector that identifies whether the passes are loop passes or loop-nest\n  // passes (true for loop-nest passes).\n  BitVector IsLoopNestPass;\n  std::vector<std::unique_ptr<LoopPassConceptT>> LoopPasses;\n  std::vector<std::unique_ptr<LoopNestPassConceptT>> LoopNestPasses;\n\n  /// Flag indicating whether we should do debug logging.\n  bool DebugLogging;\n\n  /// Run either a loop pass or a loop-nest pass. Returns `None` if\n  /// PassInstrumentation's BeforePass returns false. Otherwise, returns the\n  /// preserved analyses of the pass.\n  template <typename IRUnitT, typename PassT>\n  Optional<PreservedAnalyses>\n  runSinglePass(IRUnitT &IR, PassT &Pass, LoopAnalysisManager &AM,\n                LoopStandardAnalysisResults &AR, LPMUpdater &U,\n                PassInstrumentation &PI);\n\n  PreservedAnalyses runWithLoopNestPasses(Loop &L, LoopAnalysisManager &AM,\n                                          LoopStandardAnalysisResults &AR,\n                                          LPMUpdater &U);\n  PreservedAnalyses runWithoutLoopNestPasses(Loop &L, LoopAnalysisManager &AM,\n                                             LoopStandardAnalysisResults &AR,\n                                             LPMUpdater &U);\n};\n\n/// The Loop pass manager.\n///\n/// See the documentation for the PassManager template for details. It runs\n/// a sequence of Loop passes over each Loop that the manager is run over. This\n/// typedef serves as a convenient way to refer to this construct.\ntypedef PassManager<Loop, LoopAnalysisManager, LoopStandardAnalysisResults &,\n                    LPMUpdater &>\n    LoopPassManager;\n\n/// A partial specialization of the require analysis template pass to forward\n/// the extra parameters from a transformation's run method to the\n/// AnalysisManager's getResult.\ntemplate <typename AnalysisT>\nstruct RequireAnalysisPass<AnalysisT, Loop, LoopAnalysisManager,\n                           LoopStandardAnalysisResults &, LPMUpdater &>\n    : PassInfoMixin<\n          RequireAnalysisPass<AnalysisT, Loop, LoopAnalysisManager,\n                              LoopStandardAnalysisResults &, LPMUpdater &>> {\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &) {\n    (void)AM.template getResult<AnalysisT>(L, AR);\n    return PreservedAnalyses::all();\n  }\n};\n\n/// An alias template to easily name a require analysis loop pass.\ntemplate <typename AnalysisT>\nusing RequireAnalysisLoopPass =\n    RequireAnalysisPass<AnalysisT, Loop, LoopAnalysisManager,\n                        LoopStandardAnalysisResults &, LPMUpdater &>;\n\nclass FunctionToLoopPassAdaptor;\n\n/// This class provides an interface for updating the loop pass manager based\n/// on mutations to the loop nest.\n///\n/// A reference to an instance of this class is passed as an argument to each\n/// Loop pass, and Loop passes should use it to update LPM infrastructure if\n/// they modify the loop nest structure.\n///\n/// \\c LPMUpdater comes with two modes: the loop mode and the loop-nest mode. In\n/// loop mode, all the loops in the function will be pushed into the worklist\n/// and when new loops are added to the pipeline, their subloops are also\n/// inserted recursively. On the other hand, in loop-nest mode, only top-level\n/// loops are contained in the worklist and the addition of new (top-level)\n/// loops will not trigger the addition of their subloops.\nclass LPMUpdater {\npublic:\n  /// This can be queried by loop passes which run other loop passes (like pass\n  /// managers) to know whether the loop needs to be skipped due to updates to\n  /// the loop nest.\n  ///\n  /// If this returns true, the loop object may have been deleted, so passes\n  /// should take care not to touch the object.\n  bool skipCurrentLoop() const { return SkipCurrentLoop; }\n\n  /// Loop passes should use this method to indicate they have deleted a loop\n  /// from the nest.\n  ///\n  /// Note that this loop must either be the current loop or a subloop of the\n  /// current loop. This routine must be called prior to removing the loop from\n  /// the loop nest.\n  ///\n  /// If this is called for the current loop, in addition to clearing any\n  /// state, this routine will mark that the current loop should be skipped by\n  /// the rest of the pass management infrastructure.\n  void markLoopAsDeleted(Loop &L, llvm::StringRef Name) {\n    assert((!LoopNestMode || L.isOutermost()) &&\n           \"L should be a top-level loop in loop-nest mode.\");\n    LAM.clear(L, Name);\n    assert((&L == CurrentL || CurrentL->contains(&L)) &&\n           \"Cannot delete a loop outside of the \"\n           \"subloop tree currently being processed.\");\n    if (&L == CurrentL)\n      SkipCurrentLoop = true;\n  }\n\n  void setParentLoop(Loop *L) {\n#ifndef NDEBUG\n    ParentL = L;\n#endif\n  }\n\n  /// Loop passes should use this method to indicate they have added new child\n  /// loops of the current loop.\n  ///\n  /// \\p NewChildLoops must contain only the immediate children. Any nested\n  /// loops within them will be visited in postorder as usual for the loop pass\n  /// manager.\n  void addChildLoops(ArrayRef<Loop *> NewChildLoops) {\n    assert(!LoopNestMode &&\n           \"Child loops should not be pushed in loop-nest mode.\");\n    // Insert ourselves back into the worklist first, as this loop should be\n    // revisited after all the children have been processed.\n    Worklist.insert(CurrentL);\n\n#ifndef NDEBUG\n    for (Loop *NewL : NewChildLoops)\n      assert(NewL->getParentLoop() == CurrentL && \"All of the new loops must \"\n                                                  \"be immediate children of \"\n                                                  \"the current loop!\");\n#endif\n\n    appendLoopsToWorklist(NewChildLoops, Worklist);\n\n    // Also skip further processing of the current loop--it will be revisited\n    // after all of its newly added children are accounted for.\n    SkipCurrentLoop = true;\n  }\n\n  /// Loop passes should use this method to indicate they have added new\n  /// sibling loops to the current loop.\n  ///\n  /// \\p NewSibLoops must only contain the immediate sibling loops. Any nested\n  /// loops within them will be visited in postorder as usual for the loop pass\n  /// manager.\n  void addSiblingLoops(ArrayRef<Loop *> NewSibLoops) {\n#ifndef NDEBUG\n    for (Loop *NewL : NewSibLoops)\n      assert(NewL->getParentLoop() == ParentL &&\n             \"All of the new loops must be siblings of the current loop!\");\n#endif\n\n    if (LoopNestMode)\n      Worklist.insert(NewSibLoops);\n    else\n      appendLoopsToWorklist(NewSibLoops, Worklist);\n\n    // No need to skip the current loop or revisit it, as sibling loops\n    // shouldn't impact anything.\n  }\n\n  /// Restart the current loop.\n  ///\n  /// Loop passes should call this method to indicate the current loop has been\n  /// sufficiently changed that it should be re-visited from the begining of\n  /// the loop pass pipeline rather than continuing.\n  void revisitCurrentLoop() {\n    // Tell the currently in-flight pipeline to stop running.\n    SkipCurrentLoop = true;\n\n    // And insert ourselves back into the worklist.\n    Worklist.insert(CurrentL);\n  }\n\nprivate:\n  friend class llvm::FunctionToLoopPassAdaptor;\n\n  /// The \\c FunctionToLoopPassAdaptor's worklist of loops to process.\n  SmallPriorityWorklist<Loop *, 4> &Worklist;\n\n  /// The analysis manager for use in the current loop nest.\n  LoopAnalysisManager &LAM;\n\n  Loop *CurrentL;\n  bool SkipCurrentLoop;\n  const bool LoopNestMode;\n\n#ifndef NDEBUG\n  // In debug builds we also track the parent loop to implement asserts even in\n  // the face of loop deletion.\n  Loop *ParentL;\n#endif\n\n  LPMUpdater(SmallPriorityWorklist<Loop *, 4> &Worklist,\n             LoopAnalysisManager &LAM, bool LoopNestMode = false)\n      : Worklist(Worklist), LAM(LAM), LoopNestMode(LoopNestMode) {}\n};\n\ntemplate <typename IRUnitT, typename PassT>\nOptional<PreservedAnalyses> LoopPassManager::runSinglePass(\n    IRUnitT &IR, PassT &Pass, LoopAnalysisManager &AM,\n    LoopStandardAnalysisResults &AR, LPMUpdater &U, PassInstrumentation &PI) {\n  // Check the PassInstrumentation's BeforePass callbacks before running the\n  // pass, skip its execution completely if asked to (callback returns false).\n  if (!PI.runBeforePass<IRUnitT>(*Pass, IR))\n    return None;\n\n  PreservedAnalyses PA;\n  {\n    TimeTraceScope TimeScope(Pass->name(), IR.getName());\n    PA = Pass->run(IR, AM, AR, U);\n  }\n\n  // do not pass deleted Loop into the instrumentation\n  if (U.skipCurrentLoop())\n    PI.runAfterPassInvalidated<IRUnitT>(*Pass, PA);\n  else\n    PI.runAfterPass<IRUnitT>(*Pass, IR, PA);\n  return PA;\n}\n\n/// Adaptor that maps from a function to its loops.\n///\n/// Designed to allow composition of a LoopPass(Manager) and a\n/// FunctionPassManager. Note that if this pass is constructed with a \\c\n/// FunctionAnalysisManager it will run the \\c LoopAnalysisManagerFunctionProxy\n/// analysis prior to running the loop passes over the function to enable a \\c\n/// LoopAnalysisManager to be used within this run safely.\n///\n/// The adaptor comes with two modes: the loop mode and the loop-nest mode, and\n/// the worklist updater lived inside will be in the same mode as the adaptor\n/// (refer to the documentation of \\c LPMUpdater for more detailed explanation).\n/// Specifically, in loop mode, all loops in the funciton will be pushed into\n/// the worklist and processed by \\p Pass, while only top-level loops are\n/// processed in loop-nest mode. Please refer to the various specializations of\n/// \\fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest\n/// mode are used.\nclass FunctionToLoopPassAdaptor\n    : public PassInfoMixin<FunctionToLoopPassAdaptor> {\npublic:\n  using PassConceptT =\n      detail::PassConcept<Loop, LoopAnalysisManager,\n                          LoopStandardAnalysisResults &, LPMUpdater &>;\n\n  explicit FunctionToLoopPassAdaptor(std::unique_ptr<PassConceptT> Pass,\n                                     bool UseMemorySSA = false,\n                                     bool UseBlockFrequencyInfo = false,\n                                     bool DebugLogging = false,\n                                     bool LoopNestMode = false)\n      : Pass(std::move(Pass)), LoopCanonicalizationFPM(DebugLogging),\n        UseMemorySSA(UseMemorySSA),\n        UseBlockFrequencyInfo(UseBlockFrequencyInfo),\n        LoopNestMode(LoopNestMode) {\n    LoopCanonicalizationFPM.addPass(LoopSimplifyPass());\n    LoopCanonicalizationFPM.addPass(LCSSAPass());\n  }\n\n  /// Runs the loop passes across every loop in the function.\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n\n  static bool isRequired() { return true; }\n\n  bool isLoopNestMode() const { return LoopNestMode; }\n\nprivate:\n  std::unique_ptr<PassConceptT> Pass;\n\n  FunctionPassManager LoopCanonicalizationFPM;\n\n  bool UseMemorySSA = false;\n  bool UseBlockFrequencyInfo = false;\n  const bool LoopNestMode;\n};\n\n/// A function to deduce a loop pass type and wrap it in the templated\n/// adaptor.\n///\n/// If \\p Pass is a loop pass, the returned adaptor will be in loop mode.\ntemplate <typename LoopPassT>\ninline std::enable_if_t<is_detected<HasRunOnLoopT, LoopPassT>::value,\n                        FunctionToLoopPassAdaptor>\ncreateFunctionToLoopPassAdaptor(LoopPassT Pass, bool UseMemorySSA = false,\n                                bool UseBlockFrequencyInfo = false,\n                                bool DebugLogging = false) {\n  using PassModelT =\n      detail::PassModel<Loop, LoopPassT, PreservedAnalyses, LoopAnalysisManager,\n                        LoopStandardAnalysisResults &, LPMUpdater &>;\n  return FunctionToLoopPassAdaptor(\n      std::make_unique<PassModelT>(std::move(Pass)), UseMemorySSA,\n      UseBlockFrequencyInfo, DebugLogging, false);\n}\n\n/// If \\p Pass is a loop-nest pass, \\p Pass will first be wrapped into a\n/// \\c LoopPassManager and the returned adaptor will be in loop-nest mode.\ntemplate <typename LoopNestPassT>\ninline std::enable_if_t<!is_detected<HasRunOnLoopT, LoopNestPassT>::value,\n                        FunctionToLoopPassAdaptor>\ncreateFunctionToLoopPassAdaptor(LoopNestPassT Pass, bool UseMemorySSA = false,\n                                bool UseBlockFrequencyInfo = false,\n                                bool DebugLogging = false) {\n  LoopPassManager LPM(DebugLogging);\n  LPM.addPass(std::move(Pass));\n  using PassModelT =\n      detail::PassModel<Loop, LoopPassManager, PreservedAnalyses,\n                        LoopAnalysisManager, LoopStandardAnalysisResults &,\n                        LPMUpdater &>;\n  return FunctionToLoopPassAdaptor(std::make_unique<PassModelT>(std::move(LPM)),\n                                   UseMemorySSA, UseBlockFrequencyInfo,\n                                   DebugLogging, true);\n}\n\n/// If \\p Pass is an instance of \\c LoopPassManager, the returned adaptor will\n/// be in loop-nest mode if the pass manager contains only loop-nest passes.\ntemplate <>\ninline FunctionToLoopPassAdaptor\ncreateFunctionToLoopPassAdaptor<LoopPassManager>(LoopPassManager LPM,\n                                                 bool UseMemorySSA,\n                                                 bool UseBlockFrequencyInfo,\n                                                 bool DebugLogging) {\n  // Check if LPM contains any loop pass and if it does not, returns an adaptor\n  // in loop-nest mode.\n  using PassModelT =\n      detail::PassModel<Loop, LoopPassManager, PreservedAnalyses,\n                        LoopAnalysisManager, LoopStandardAnalysisResults &,\n                        LPMUpdater &>;\n  bool LoopNestMode = (LPM.getNumLoopPasses() == 0);\n  return FunctionToLoopPassAdaptor(std::make_unique<PassModelT>(std::move(LPM)),\n                                   UseMemorySSA, UseBlockFrequencyInfo,\n                                   DebugLogging, LoopNestMode);\n}\n\n/// Pass for printing a loop's contents as textual IR.\nclass PrintLoopPass : public PassInfoMixin<PrintLoopPass> {\n  raw_ostream &OS;\n  std::string Banner;\n\npublic:\n  PrintLoopPass();\n  PrintLoopPass(raw_ostream &OS, const std::string &Banner = \"\");\n\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &,\n                        LoopStandardAnalysisResults &, LPMUpdater &);\n};\n}\n\n#endif // LLVM_TRANSFORMS_SCALAR_LOOPPASSMANAGER_H\n"}, "103": {"id": 103, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h", "content": "//===- SimpleLoopUnswitch.h - Hoist loop-invariant control flow -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TRANSFORMS_SCALAR_SIMPLELOOPUNSWITCH_H\n#define LLVM_TRANSFORMS_SCALAR_SIMPLELOOPUNSWITCH_H\n\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Transforms/Scalar/LoopPassManager.h\"\n\nnamespace llvm {\n\n/// This pass transforms loops that contain branches or switches on loop-\n/// invariant conditions to have multiple loops. For example, it turns the left\n/// into the right code:\n///\n///  for (...)                  if (lic)\n///    A                          for (...)\n///    if (lic)                     A; B; C\n///      B                      else\n///    C                          for (...)\n///                                 A; C\n///\n/// This can increase the size of the code exponentially (doubling it every time\n/// a loop is unswitched) so we only unswitch if the resultant code will be\n/// smaller than a threshold.\n///\n/// This pass expects LICM to be run before it to hoist invariant conditions out\n/// of the loop, to make the unswitching opportunity obvious.\n///\n/// There is a taxonomy of unswitching that we use to classify different forms\n/// of this transformaiton:\n///\n/// - Trival unswitching: this is when the condition can be unswitched without\n///   cloning any code from inside the loop. A non-trivial unswitch requires\n///   code duplication.\n///\n/// - Full unswitching: this is when the branch or switch is completely moved\n///   from inside the loop to outside the loop. Partial unswitching removes the\n///   branch from the clone of the loop but must leave a (somewhat simplified)\n///   branch in the original loop. While theoretically partial unswitching can\n///   be done for switches, the requirements are extreme - we need the loop\n///   invariant input to the switch to be sufficient to collapse to a single\n///   successor in each clone.\n///\n/// This pass always does trivial, full unswitching for both branches and\n/// switches. For branches, it also always does trivial, partial unswitching.\n///\n/// If enabled (via the constructor's `NonTrivial` parameter), this pass will\n/// additionally do non-trivial, full unswitching for branches and switches, and\n/// will do non-trivial, partial unswitching for branches.\n///\n/// Because partial unswitching of switches is extremely unlikely to be possible\n/// in practice and significantly complicates the implementation, this pass does\n/// not currently implement that in any mode.\nclass SimpleLoopUnswitchPass : public PassInfoMixin<SimpleLoopUnswitchPass> {\n  bool NonTrivial;\n\npublic:\n  SimpleLoopUnswitchPass(bool NonTrivial = false) : NonTrivial(NonTrivial) {}\n\n  PreservedAnalyses run(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &U);\n};\n\n/// Create the legacy pass object for the simple loop unswitcher.\n///\n/// See the documentaion for `SimpleLoopUnswitchPass` for details.\nPass *createSimpleLoopUnswitchLegacyPass(bool NonTrivial = false);\n\n} // end namespace llvm\n\n#endif // LLVM_TRANSFORMS_SCALAR_SIMPLELOOPUNSWITCH_H\n"}, "107": {"id": 107, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp", "content": "///===- SimpleLoopUnswitch.cpp - Hoist loop-invariant control flow ---------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Scalar/SimpleLoopUnswitch.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/Sequence.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/CFG.h\"\n#include \"llvm/Analysis/CodeMetrics.h\"\n#include \"llvm/Analysis/GuardUtils.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/LoopIterator.h\"\n#include \"llvm/Analysis/LoopPass.h\"\n#include \"llvm/Analysis/MemorySSA.h\"\n#include \"llvm/Analysis/MemorySSAUpdater.h\"\n#include \"llvm/Analysis/MustExecute.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/GenericDomTree.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/Scalar/SimpleLoopUnswitch.h\"\n#include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n#include \"llvm/Transforms/Utils/Cloning.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include \"llvm/Transforms/Utils/LoopUtils.h\"\n#include \"llvm/Transforms/Utils/ValueMapper.h\"\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <utility>\n\n#define DEBUG_TYPE \"simple-loop-unswitch\"\n\nusing namespace llvm;\nusing namespace llvm::PatternMatch;\n\nSTATISTIC(NumBranches, \"Number of branches unswitched\");\nSTATISTIC(NumSwitches, \"Number of switches unswitched\");\nSTATISTIC(NumGuards, \"Number of guards turned into branches for unswitching\");\nSTATISTIC(NumTrivial, \"Number of unswitches that are trivial\");\nSTATISTIC(\n    NumCostMultiplierSkipped,\n    \"Number of unswitch candidates that had their cost multiplier skipped\");\n\nstatic cl::opt<bool> EnableNonTrivialUnswitch(\n    \"enable-nontrivial-unswitch\", cl::init(false), cl::Hidden,\n    cl::desc(\"Forcibly enables non-trivial loop unswitching rather than \"\n             \"following the configuration passed into the pass.\"));\n\nstatic cl::opt<int>\n    UnswitchThreshold(\"unswitch-threshold\", cl::init(50), cl::Hidden,\n                      cl::desc(\"The cost threshold for unswitching a loop.\"));\n\nstatic cl::opt<bool> EnableUnswitchCostMultiplier(\n    \"enable-unswitch-cost-multiplier\", cl::init(true), cl::Hidden,\n    cl::desc(\"Enable unswitch cost multiplier that prohibits exponential \"\n             \"explosion in nontrivial unswitch.\"));\nstatic cl::opt<int> UnswitchSiblingsToplevelDiv(\n    \"unswitch-siblings-toplevel-div\", cl::init(2), cl::Hidden,\n    cl::desc(\"Toplevel siblings divisor for cost multiplier.\"));\nstatic cl::opt<int> UnswitchNumInitialUnscaledCandidates(\n    \"unswitch-num-initial-unscaled-candidates\", cl::init(8), cl::Hidden,\n    cl::desc(\"Number of unswitch candidates that are ignored when calculating \"\n             \"cost multiplier.\"));\nstatic cl::opt<bool> UnswitchGuards(\n    \"simple-loop-unswitch-guards\", cl::init(true), cl::Hidden,\n    cl::desc(\"If enabled, simple loop unswitching will also consider \"\n             \"llvm.experimental.guard intrinsics as unswitch candidates.\"));\nstatic cl::opt<bool> DropNonTrivialImplicitNullChecks(\n    \"simple-loop-unswitch-drop-non-trivial-implicit-null-checks\",\n    cl::init(false), cl::Hidden,\n    cl::desc(\"If enabled, drop make.implicit metadata in unswitched implicit \"\n             \"null checks to save time analyzing if we can keep it.\"));\n\n/// Collect all of the loop invariant input values transitively used by the\n/// homogeneous instruction graph from a given root.\n///\n/// This essentially walks from a root recursively through loop variant operands\n/// which have the exact same opcode and finds all inputs which are loop\n/// invariant. For some operations these can be re-associated and unswitched out\n/// of the loop entirely.\nstatic TinyPtrVector<Value *>\ncollectHomogenousInstGraphLoopInvariants(Loop &L, Instruction &Root,\n                                         LoopInfo &LI) {\n  assert(!L.isLoopInvariant(&Root) &&\n         \"Only need to walk the graph if root itself is not invariant.\");\n  TinyPtrVector<Value *> Invariants;\n\n  bool IsRootAnd = match(&Root, m_LogicalAnd());\n  bool IsRootOr  = match(&Root, m_LogicalOr());\n\n  // Build a worklist and recurse through operators collecting invariants.\n  SmallVector<Instruction *, 4> Worklist;\n  SmallPtrSet<Instruction *, 8> Visited;\n  Worklist.push_back(&Root);\n  Visited.insert(&Root);\n  do {\n    Instruction &I = *Worklist.pop_back_val();\n    for (Value *OpV : I.operand_values()) {\n      // Skip constants as unswitching isn't interesting for them.\n      if (isa<Constant>(OpV))\n        continue;\n\n      // Add it to our result if loop invariant.\n      if (L.isLoopInvariant(OpV)) {\n        Invariants.push_back(OpV);\n        continue;\n      }\n\n      // If not an instruction with the same opcode, nothing we can do.\n      Instruction *OpI = dyn_cast<Instruction>(OpV);\n\n      if (OpI && ((IsRootAnd && match(OpI, m_LogicalAnd())) ||\n                  (IsRootOr  && match(OpI, m_LogicalOr())))) {\n        // Visit this operand.\n        if (Visited.insert(OpI).second)\n          Worklist.push_back(OpI);\n      }\n    }\n  } while (!Worklist.empty());\n\n  return Invariants;\n}\n\nstatic void replaceLoopInvariantUses(Loop &L, Value *Invariant,\n                                     Constant &Replacement) {\n  assert(!isa<Constant>(Invariant) && \"Why are we unswitching on a constant?\");\n\n  // Replace uses of LIC in the loop with the given constant.\n  // We use make_early_inc_range as set invalidates the iterator.\n  for (Use &U : llvm::make_early_inc_range(Invariant->uses())) {\n    Instruction *UserI = dyn_cast<Instruction>(U.getUser());\n\n    // Replace this use within the loop body.\n    if (UserI && L.contains(UserI))\n      U.set(&Replacement);\n  }\n}\n\n/// Check that all the LCSSA PHI nodes in the loop exit block have trivial\n/// incoming values along this edge.\nstatic bool areLoopExitPHIsLoopInvariant(Loop &L, BasicBlock &ExitingBB,\n                                         BasicBlock &ExitBB) {\n  for (Instruction &I : ExitBB) {\n    auto *PN = dyn_cast<PHINode>(&I);\n    if (!PN)\n      // No more PHIs to check.\n      return true;\n\n    // If the incoming value for this edge isn't loop invariant the unswitch\n    // won't be trivial.\n    if (!L.isLoopInvariant(PN->getIncomingValueForBlock(&ExitingBB)))\n      return false;\n  }\n  llvm_unreachable(\"Basic blocks should never be empty!\");\n}\n\n/// Insert code to test a set of loop invariant values, and conditionally branch\n/// on them.\nstatic void buildPartialUnswitchConditionalBranch(BasicBlock &BB,\n                                                  ArrayRef<Value *> Invariants,\n                                                  bool Direction,\n                                                  BasicBlock &UnswitchedSucc,\n                                                  BasicBlock &NormalSucc) {\n  IRBuilder<> IRB(&BB);\n\n  Value *Cond = Direction ? IRB.CreateOr(Invariants) :\n    IRB.CreateAnd(Invariants);\n  IRB.CreateCondBr(Cond, Direction ? &UnswitchedSucc : &NormalSucc,\n                   Direction ? &NormalSucc : &UnswitchedSucc);\n}\n\n/// Rewrite the PHI nodes in an unswitched loop exit basic block.\n///\n/// Requires that the loop exit and unswitched basic block are the same, and\n/// that the exiting block was a unique predecessor of that block. Rewrites the\n/// PHI nodes in that block such that what were LCSSA PHI nodes become trivial\n/// PHI nodes from the old preheader that now contains the unswitched\n/// terminator.\nstatic void rewritePHINodesForUnswitchedExitBlock(BasicBlock &UnswitchedBB,\n                                                  BasicBlock &OldExitingBB,\n                                                  BasicBlock &OldPH) {\n  for (PHINode &PN : UnswitchedBB.phis()) {\n    // When the loop exit is directly unswitched we just need to update the\n    // incoming basic block. We loop to handle weird cases with repeated\n    // incoming blocks, but expect to typically only have one operand here.\n    for (auto i : seq<int>(0, PN.getNumOperands())) {\n      assert(PN.getIncomingBlock(i) == &OldExitingBB &&\n             \"Found incoming block different from unique predecessor!\");\n      PN.setIncomingBlock(i, &OldPH);\n    }\n  }\n}\n\n/// Rewrite the PHI nodes in the loop exit basic block and the split off\n/// unswitched block.\n///\n/// Because the exit block remains an exit from the loop, this rewrites the\n/// LCSSA PHI nodes in it to remove the unswitched edge and introduces PHI\n/// nodes into the unswitched basic block to select between the value in the\n/// old preheader and the loop exit.\nstatic void rewritePHINodesForExitAndUnswitchedBlocks(BasicBlock &ExitBB,\n                                                      BasicBlock &UnswitchedBB,\n                                                      BasicBlock &OldExitingBB,\n                                                      BasicBlock &OldPH,\n                                                      bool FullUnswitch) {\n  assert(&ExitBB != &UnswitchedBB &&\n         \"Must have different loop exit and unswitched blocks!\");\n  Instruction *InsertPt = &*UnswitchedBB.begin();\n  for (PHINode &PN : ExitBB.phis()) {\n    auto *NewPN = PHINode::Create(PN.getType(), /*NumReservedValues*/ 2,\n                                  PN.getName() + \".split\", InsertPt);\n\n    // Walk backwards over the old PHI node's inputs to minimize the cost of\n    // removing each one. We have to do this weird loop manually so that we\n    // create the same number of new incoming edges in the new PHI as we expect\n    // each case-based edge to be included in the unswitched switch in some\n    // cases.\n    // FIXME: This is really, really gross. It would be much cleaner if LLVM\n    // allowed us to create a single entry for a predecessor block without\n    // having separate entries for each \"edge\" even though these edges are\n    // required to produce identical results.\n    for (int i = PN.getNumIncomingValues() - 1; i >= 0; --i) {\n      if (PN.getIncomingBlock(i) != &OldExitingBB)\n        continue;\n\n      Value *Incoming = PN.getIncomingValue(i);\n      if (FullUnswitch)\n        // No more edge from the old exiting block to the exit block.\n        PN.removeIncomingValue(i);\n\n      NewPN->addIncoming(Incoming, &OldPH);\n    }\n\n    // Now replace the old PHI with the new one and wire the old one in as an\n    // input to the new one.\n    PN.replaceAllUsesWith(NewPN);\n    NewPN->addIncoming(&PN, &ExitBB);\n  }\n}\n\n/// Hoist the current loop up to the innermost loop containing a remaining exit.\n///\n/// Because we've removed an exit from the loop, we may have changed the set of\n/// loops reachable and need to move the current loop up the loop nest or even\n/// to an entirely separate nest.\nstatic void hoistLoopToNewParent(Loop &L, BasicBlock &Preheader,\n                                 DominatorTree &DT, LoopInfo &LI,\n                                 MemorySSAUpdater *MSSAU, ScalarEvolution *SE) {\n  // If the loop is already at the top level, we can't hoist it anywhere.\n  Loop *OldParentL = L.getParentLoop();\n  if (!OldParentL)\n    return;\n\n  SmallVector<BasicBlock *, 4> Exits;\n  L.getExitBlocks(Exits);\n  Loop *NewParentL = nullptr;\n  for (auto *ExitBB : Exits)\n    if (Loop *ExitL = LI.getLoopFor(ExitBB))\n      if (!NewParentL || NewParentL->contains(ExitL))\n        NewParentL = ExitL;\n\n  if (NewParentL == OldParentL)\n    return;\n\n  // The new parent loop (if different) should always contain the old one.\n  if (NewParentL)\n    assert(NewParentL->contains(OldParentL) &&\n           \"Can only hoist this loop up the nest!\");\n\n  // The preheader will need to move with the body of this loop. However,\n  // because it isn't in this loop we also need to update the primary loop map.\n  assert(OldParentL == LI.getLoopFor(&Preheader) &&\n         \"Parent loop of this loop should contain this loop's preheader!\");\n  LI.changeLoopFor(&Preheader, NewParentL);\n\n  // Remove this loop from its old parent.\n  OldParentL->removeChildLoop(&L);\n\n  // Add the loop either to the new parent or as a top-level loop.\n  if (NewParentL)\n    NewParentL->addChildLoop(&L);\n  else\n    LI.addTopLevelLoop(&L);\n\n  // Remove this loops blocks from the old parent and every other loop up the\n  // nest until reaching the new parent. Also update all of these\n  // no-longer-containing loops to reflect the nesting change.\n  for (Loop *OldContainingL = OldParentL; OldContainingL != NewParentL;\n       OldContainingL = OldContainingL->getParentLoop()) {\n    llvm::erase_if(OldContainingL->getBlocksVector(),\n                   [&](const BasicBlock *BB) {\n                     return BB == &Preheader || L.contains(BB);\n                   });\n\n    OldContainingL->getBlocksSet().erase(&Preheader);\n    for (BasicBlock *BB : L.blocks())\n      OldContainingL->getBlocksSet().erase(BB);\n\n    // Because we just hoisted a loop out of this one, we have essentially\n    // created new exit paths from it. That means we need to form LCSSA PHI\n    // nodes for values used in the no-longer-nested loop.\n    formLCSSA(*OldContainingL, DT, &LI, SE);\n\n    // We shouldn't need to form dedicated exits because the exit introduced\n    // here is the (just split by unswitching) preheader. However, after trivial\n    // unswitching it is possible to get new non-dedicated exits out of parent\n    // loop so let's conservatively form dedicated exit blocks and figure out\n    // if we can optimize later.\n    formDedicatedExitBlocks(OldContainingL, &DT, &LI, MSSAU,\n                            /*PreserveLCSSA*/ true);\n  }\n}\n\n// Return the top-most loop containing ExitBB and having ExitBB as exiting block\n// or the loop containing ExitBB, if there is no parent loop containing ExitBB\n// as exiting block.\nstatic Loop *getTopMostExitingLoop(BasicBlock *ExitBB, LoopInfo &LI) {\n  Loop *TopMost = LI.getLoopFor(ExitBB);\n  Loop *Current = TopMost;\n  while (Current) {\n    if (Current->isLoopExiting(ExitBB))\n      TopMost = Current;\n    Current = Current->getParentLoop();\n  }\n  return TopMost;\n}\n\n/// Unswitch a trivial branch if the condition is loop invariant.\n///\n/// This routine should only be called when loop code leading to the branch has\n/// been validated as trivial (no side effects). This routine checks if the\n/// condition is invariant and one of the successors is a loop exit. This\n/// allows us to unswitch without duplicating the loop, making it trivial.\n///\n/// If this routine fails to unswitch the branch it returns false.\n///\n/// If the branch can be unswitched, this routine splits the preheader and\n/// hoists the branch above that split. Preserves loop simplified form\n/// (splitting the exit block as necessary). It simplifies the branch within\n/// the loop to an unconditional branch but doesn't remove it entirely. Further\n/// cleanup can be done with some simplify-cfg like pass.\n///\n/// If `SE` is not null, it will be updated based on the potential loop SCEVs\n/// invalidated by this.\nstatic bool unswitchTrivialBranch(Loop &L, BranchInst &BI, DominatorTree &DT,\n                                  LoopInfo &LI, ScalarEvolution *SE,\n                                  MemorySSAUpdater *MSSAU) {\n  assert(BI.isConditional() && \"Can only unswitch a conditional branch!\");\n  LLVM_DEBUG(dbgs() << \"  Trying to unswitch branch: \" << BI << \"\\n\");\n\n  // The loop invariant values that we want to unswitch.\n  TinyPtrVector<Value *> Invariants;\n\n  // When true, we're fully unswitching the branch rather than just unswitching\n  // some input conditions to the branch.\n  bool FullUnswitch = false;\n\n  if (L.isLoopInvariant(BI.getCondition())) {\n    Invariants.push_back(BI.getCondition());\n    FullUnswitch = true;\n  } else {\n    if (auto *CondInst = dyn_cast<Instruction>(BI.getCondition()))\n      Invariants = collectHomogenousInstGraphLoopInvariants(L, *CondInst, LI);\n    if (Invariants.empty())\n      // Couldn't find invariant inputs!\n      return false;\n  }\n\n  // Check that one of the branch's successors exits, and which one.\n  bool ExitDirection = true;\n  int LoopExitSuccIdx = 0;\n  auto *LoopExitBB = BI.getSuccessor(0);\n  if (L.contains(LoopExitBB)) {\n    ExitDirection = false;\n    LoopExitSuccIdx = 1;\n    LoopExitBB = BI.getSuccessor(1);\n    if (L.contains(LoopExitBB))\n      return false;\n  }\n  auto *ContinueBB = BI.getSuccessor(1 - LoopExitSuccIdx);\n  auto *ParentBB = BI.getParent();\n  if (!areLoopExitPHIsLoopInvariant(L, *ParentBB, *LoopExitBB))\n    return false;\n\n  // When unswitching only part of the branch's condition, we need the exit\n  // block to be reached directly from the partially unswitched input. This can\n  // be done when the exit block is along the true edge and the branch condition\n  // is a graph of `or` operations, or the exit block is along the false edge\n  // and the condition is a graph of `and` operations.\n  if (!FullUnswitch) {\n    if (ExitDirection) {\n      if (!match(BI.getCondition(), m_LogicalOr()))\n        return false;\n    } else {\n      if (!match(BI.getCondition(), m_LogicalAnd()))\n        return false;\n    }\n  }\n\n  LLVM_DEBUG({\n    dbgs() << \"    unswitching trivial invariant conditions for: \" << BI\n           << \"\\n\";\n    for (Value *Invariant : Invariants) {\n      dbgs() << \"      \" << *Invariant << \" == true\";\n      if (Invariant != Invariants.back())\n        dbgs() << \" ||\";\n      dbgs() << \"\\n\";\n    }\n  });\n\n  // If we have scalar evolutions, we need to invalidate them including this\n  // loop, the loop containing the exit block and the topmost parent loop\n  // exiting via LoopExitBB.\n  if (SE) {\n    if (Loop *ExitL = getTopMostExitingLoop(LoopExitBB, LI))\n      SE->forgetLoop(ExitL);\n    else\n      // Forget the entire nest as this exits the entire nest.\n      SE->forgetTopmostLoop(&L);\n  }\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  // Split the preheader, so that we know that there is a safe place to insert\n  // the conditional branch. We will change the preheader to have a conditional\n  // branch on LoopCond.\n  BasicBlock *OldPH = L.getLoopPreheader();\n  BasicBlock *NewPH = SplitEdge(OldPH, L.getHeader(), &DT, &LI, MSSAU);\n\n  // Now that we have a place to insert the conditional branch, create a place\n  // to branch to: this is the exit block out of the loop that we are\n  // unswitching. We need to split this if there are other loop predecessors.\n  // Because the loop is in simplified form, *any* other predecessor is enough.\n  BasicBlock *UnswitchedBB;\n  if (FullUnswitch && LoopExitBB->getUniquePredecessor()) {\n    assert(LoopExitBB->getUniquePredecessor() == BI.getParent() &&\n           \"A branch's parent isn't a predecessor!\");\n    UnswitchedBB = LoopExitBB;\n  } else {\n    UnswitchedBB =\n        SplitBlock(LoopExitBB, &LoopExitBB->front(), &DT, &LI, MSSAU);\n  }\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  // Actually move the invariant uses into the unswitched position. If possible,\n  // we do this by moving the instructions, but when doing partial unswitching\n  // we do it by building a new merge of the values in the unswitched position.\n  OldPH->getTerminator()->eraseFromParent();\n  if (FullUnswitch) {\n    // If fully unswitching, we can use the existing branch instruction.\n    // Splice it into the old PH to gate reaching the new preheader and re-point\n    // its successors.\n    OldPH->getInstList().splice(OldPH->end(), BI.getParent()->getInstList(),\n                                BI);\n    if (MSSAU) {\n      // Temporarily clone the terminator, to make MSSA update cheaper by\n      // separating \"insert edge\" updates from \"remove edge\" ones.\n      ParentBB->getInstList().push_back(BI.clone());\n    } else {\n      // Create a new unconditional branch that will continue the loop as a new\n      // terminator.\n      BranchInst::Create(ContinueBB, ParentBB);\n    }\n    BI.setSuccessor(LoopExitSuccIdx, UnswitchedBB);\n    BI.setSuccessor(1 - LoopExitSuccIdx, NewPH);\n  } else {\n    // Only unswitching a subset of inputs to the condition, so we will need to\n    // build a new branch that merges the invariant inputs.\n    if (ExitDirection)\n      assert(match(BI.getCondition(), m_LogicalOr()) &&\n             \"Must have an `or` of `i1`s or `select i1 X, true, Y`s for the \"\n             \"condition!\");\n    else\n      assert(match(BI.getCondition(), m_LogicalAnd()) &&\n             \"Must have an `and` of `i1`s or `select i1 X, Y, false`s for the\"\n             \" condition!\");\n    buildPartialUnswitchConditionalBranch(*OldPH, Invariants, ExitDirection,\n                                          *UnswitchedBB, *NewPH);\n  }\n\n  // Update the dominator tree with the added edge.\n  DT.insertEdge(OldPH, UnswitchedBB);\n\n  // After the dominator tree was updated with the added edge, update MemorySSA\n  // if available.\n  if (MSSAU) {\n    SmallVector<CFGUpdate, 1> Updates;\n    Updates.push_back({cfg::UpdateKind::Insert, OldPH, UnswitchedBB});\n    MSSAU->applyInsertUpdates(Updates, DT);\n  }\n\n  // Finish updating dominator tree and memory ssa for full unswitch.\n  if (FullUnswitch) {\n    if (MSSAU) {\n      // Remove the cloned branch instruction.\n      ParentBB->getTerminator()->eraseFromParent();\n      // Create unconditional branch now.\n      BranchInst::Create(ContinueBB, ParentBB);\n      MSSAU->removeEdge(ParentBB, LoopExitBB);\n    }\n    DT.deleteEdge(ParentBB, LoopExitBB);\n  }\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  // Rewrite the relevant PHI nodes.\n  if (UnswitchedBB == LoopExitBB)\n    rewritePHINodesForUnswitchedExitBlock(*UnswitchedBB, *ParentBB, *OldPH);\n  else\n    rewritePHINodesForExitAndUnswitchedBlocks(*LoopExitBB, *UnswitchedBB,\n                                              *ParentBB, *OldPH, FullUnswitch);\n\n  // The constant we can replace all of our invariants with inside the loop\n  // body. If any of the invariants have a value other than this the loop won't\n  // be entered.\n  ConstantInt *Replacement = ExitDirection\n                                 ? ConstantInt::getFalse(BI.getContext())\n                                 : ConstantInt::getTrue(BI.getContext());\n\n  // Since this is an i1 condition we can also trivially replace uses of it\n  // within the loop with a constant.\n  for (Value *Invariant : Invariants)\n    replaceLoopInvariantUses(L, Invariant, *Replacement);\n\n  // If this was full unswitching, we may have changed the nesting relationship\n  // for this loop so hoist it to its correct parent if needed.\n  if (FullUnswitch)\n    hoistLoopToNewParent(L, *NewPH, DT, LI, MSSAU, SE);\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  LLVM_DEBUG(dbgs() << \"    done: unswitching trivial branch...\\n\");\n  ++NumTrivial;\n  ++NumBranches;\n  return true;\n}\n\n/// Unswitch a trivial switch if the condition is loop invariant.\n///\n/// This routine should only be called when loop code leading to the switch has\n/// been validated as trivial (no side effects). This routine checks if the\n/// condition is invariant and that at least one of the successors is a loop\n/// exit. This allows us to unswitch without duplicating the loop, making it\n/// trivial.\n///\n/// If this routine fails to unswitch the switch it returns false.\n///\n/// If the switch can be unswitched, this routine splits the preheader and\n/// copies the switch above that split. If the default case is one of the\n/// exiting cases, it copies the non-exiting cases and points them at the new\n/// preheader. If the default case is not exiting, it copies the exiting cases\n/// and points the default at the preheader. It preserves loop simplified form\n/// (splitting the exit blocks as necessary). It simplifies the switch within\n/// the loop by removing now-dead cases. If the default case is one of those\n/// unswitched, it replaces its destination with a new basic block containing\n/// only unreachable. Such basic blocks, while technically loop exits, are not\n/// considered for unswitching so this is a stable transform and the same\n/// switch will not be revisited. If after unswitching there is only a single\n/// in-loop successor, the switch is further simplified to an unconditional\n/// branch. Still more cleanup can be done with some simplify-cfg like pass.\n///\n/// If `SE` is not null, it will be updated based on the potential loop SCEVs\n/// invalidated by this.\nstatic bool unswitchTrivialSwitch(Loop &L, SwitchInst &SI, DominatorTree &DT,\n                                  LoopInfo &LI, ScalarEvolution *SE,\n                                  MemorySSAUpdater *MSSAU) {\n  LLVM_DEBUG(dbgs() << \"  Trying to unswitch switch: \" << SI << \"\\n\");\n  Value *LoopCond = SI.getCondition();\n\n  // If this isn't switching on an invariant condition, we can't unswitch it.\n  if (!L.isLoopInvariant(LoopCond))\n    return false;\n\n  auto *ParentBB = SI.getParent();\n\n  // The same check must be used both for the default and the exit cases. We\n  // should never leave edges from the switch instruction to a basic block that\n  // we are unswitching, hence the condition used to determine the default case\n  // needs to also be used to populate ExitCaseIndices, which is then used to\n  // remove cases from the switch.\n  auto IsTriviallyUnswitchableExitBlock = [&](BasicBlock &BBToCheck) {\n    // BBToCheck is not an exit block if it is inside loop L.\n    if (L.contains(&BBToCheck))\n      return false;\n    // BBToCheck is not trivial to unswitch if its phis aren't loop invariant.\n    if (!areLoopExitPHIsLoopInvariant(L, *ParentBB, BBToCheck))\n      return false;\n    // We do not unswitch a block that only has an unreachable statement, as\n    // it's possible this is a previously unswitched block. Only unswitch if\n    // either the terminator is not unreachable, or, if it is, it's not the only\n    // instruction in the block.\n    auto *TI = BBToCheck.getTerminator();\n    bool isUnreachable = isa<UnreachableInst>(TI);\n    return !isUnreachable ||\n           (isUnreachable && (BBToCheck.getFirstNonPHIOrDbg() != TI));\n  };\n\n  SmallVector<int, 4> ExitCaseIndices;\n  for (auto Case : SI.cases())\n    if (IsTriviallyUnswitchableExitBlock(*Case.getCaseSuccessor()))\n      ExitCaseIndices.push_back(Case.getCaseIndex());\n  BasicBlock *DefaultExitBB = nullptr;\n  SwitchInstProfUpdateWrapper::CaseWeightOpt DefaultCaseWeight =\n      SwitchInstProfUpdateWrapper::getSuccessorWeight(SI, 0);\n  if (IsTriviallyUnswitchableExitBlock(*SI.getDefaultDest())) {\n    DefaultExitBB = SI.getDefaultDest();\n  } else if (ExitCaseIndices.empty())\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"    unswitching trivial switch...\\n\");\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  // We may need to invalidate SCEVs for the outermost loop reached by any of\n  // the exits.\n  Loop *OuterL = &L;\n\n  if (DefaultExitBB) {\n    // Clear out the default destination temporarily to allow accurate\n    // predecessor lists to be examined below.\n    SI.setDefaultDest(nullptr);\n    // Check the loop containing this exit.\n    Loop *ExitL = LI.getLoopFor(DefaultExitBB);\n    if (!ExitL || ExitL->contains(OuterL))\n      OuterL = ExitL;\n  }\n\n  // Store the exit cases into a separate data structure and remove them from\n  // the switch.\n  SmallVector<std::tuple<ConstantInt *, BasicBlock *,\n                         SwitchInstProfUpdateWrapper::CaseWeightOpt>,\n              4> ExitCases;\n  ExitCases.reserve(ExitCaseIndices.size());\n  SwitchInstProfUpdateWrapper SIW(SI);\n  // We walk the case indices backwards so that we remove the last case first\n  // and don't disrupt the earlier indices.\n  for (unsigned Index : reverse(ExitCaseIndices)) {\n    auto CaseI = SI.case_begin() + Index;\n    // Compute the outer loop from this exit.\n    Loop *ExitL = LI.getLoopFor(CaseI->getCaseSuccessor());\n    if (!ExitL || ExitL->contains(OuterL))\n      OuterL = ExitL;\n    // Save the value of this case.\n    auto W = SIW.getSuccessorWeight(CaseI->getSuccessorIndex());\n    ExitCases.emplace_back(CaseI->getCaseValue(), CaseI->getCaseSuccessor(), W);\n    // Delete the unswitched cases.\n    SIW.removeCase(CaseI);\n  }\n\n  if (SE) {\n    if (OuterL)\n      SE->forgetLoop(OuterL);\n    else\n      SE->forgetTopmostLoop(&L);\n  }\n\n  // Check if after this all of the remaining cases point at the same\n  // successor.\n  BasicBlock *CommonSuccBB = nullptr;\n  if (SI.getNumCases() > 0 &&\n      all_of(drop_begin(SI.cases()), [&SI](const SwitchInst::CaseHandle &Case) {\n        return Case.getCaseSuccessor() == SI.case_begin()->getCaseSuccessor();\n      }))\n    CommonSuccBB = SI.case_begin()->getCaseSuccessor();\n  if (!DefaultExitBB) {\n    // If we're not unswitching the default, we need it to match any cases to\n    // have a common successor or if we have no cases it is the common\n    // successor.\n    if (SI.getNumCases() == 0)\n      CommonSuccBB = SI.getDefaultDest();\n    else if (SI.getDefaultDest() != CommonSuccBB)\n      CommonSuccBB = nullptr;\n  }\n\n  // Split the preheader, so that we know that there is a safe place to insert\n  // the switch.\n  BasicBlock *OldPH = L.getLoopPreheader();\n  BasicBlock *NewPH = SplitEdge(OldPH, L.getHeader(), &DT, &LI, MSSAU);\n  OldPH->getTerminator()->eraseFromParent();\n\n  // Now add the unswitched switch.\n  auto *NewSI = SwitchInst::Create(LoopCond, NewPH, ExitCases.size(), OldPH);\n  SwitchInstProfUpdateWrapper NewSIW(*NewSI);\n\n  // Rewrite the IR for the unswitched basic blocks. This requires two steps.\n  // First, we split any exit blocks with remaining in-loop predecessors. Then\n  // we update the PHIs in one of two ways depending on if there was a split.\n  // We walk in reverse so that we split in the same order as the cases\n  // appeared. This is purely for convenience of reading the resulting IR, but\n  // it doesn't cost anything really.\n  SmallPtrSet<BasicBlock *, 2> UnswitchedExitBBs;\n  SmallDenseMap<BasicBlock *, BasicBlock *, 2> SplitExitBBMap;\n  // Handle the default exit if necessary.\n  // FIXME: It'd be great if we could merge this with the loop below but LLVM's\n  // ranges aren't quite powerful enough yet.\n  if (DefaultExitBB) {\n    if (pred_empty(DefaultExitBB)) {\n      UnswitchedExitBBs.insert(DefaultExitBB);\n      rewritePHINodesForUnswitchedExitBlock(*DefaultExitBB, *ParentBB, *OldPH);\n    } else {\n      auto *SplitBB =\n          SplitBlock(DefaultExitBB, &DefaultExitBB->front(), &DT, &LI, MSSAU);\n      rewritePHINodesForExitAndUnswitchedBlocks(*DefaultExitBB, *SplitBB,\n                                                *ParentBB, *OldPH,\n                                                /*FullUnswitch*/ true);\n      DefaultExitBB = SplitExitBBMap[DefaultExitBB] = SplitBB;\n    }\n  }\n  // Note that we must use a reference in the for loop so that we update the\n  // container.\n  for (auto &ExitCase : reverse(ExitCases)) {\n    // Grab a reference to the exit block in the pair so that we can update it.\n    BasicBlock *ExitBB = std::get<1>(ExitCase);\n\n    // If this case is the last edge into the exit block, we can simply reuse it\n    // as it will no longer be a loop exit. No mapping necessary.\n    if (pred_empty(ExitBB)) {\n      // Only rewrite once.\n      if (UnswitchedExitBBs.insert(ExitBB).second)\n        rewritePHINodesForUnswitchedExitBlock(*ExitBB, *ParentBB, *OldPH);\n      continue;\n    }\n\n    // Otherwise we need to split the exit block so that we retain an exit\n    // block from the loop and a target for the unswitched condition.\n    BasicBlock *&SplitExitBB = SplitExitBBMap[ExitBB];\n    if (!SplitExitBB) {\n      // If this is the first time we see this, do the split and remember it.\n      SplitExitBB = SplitBlock(ExitBB, &ExitBB->front(), &DT, &LI, MSSAU);\n      rewritePHINodesForExitAndUnswitchedBlocks(*ExitBB, *SplitExitBB,\n                                                *ParentBB, *OldPH,\n                                                /*FullUnswitch*/ true);\n    }\n    // Update the case pair to point to the split block.\n    std::get<1>(ExitCase) = SplitExitBB;\n  }\n\n  // Now add the unswitched cases. We do this in reverse order as we built them\n  // in reverse order.\n  for (auto &ExitCase : reverse(ExitCases)) {\n    ConstantInt *CaseVal = std::get<0>(ExitCase);\n    BasicBlock *UnswitchedBB = std::get<1>(ExitCase);\n\n    NewSIW.addCase(CaseVal, UnswitchedBB, std::get<2>(ExitCase));\n  }\n\n  // If the default was unswitched, re-point it and add explicit cases for\n  // entering the loop.\n  if (DefaultExitBB) {\n    NewSIW->setDefaultDest(DefaultExitBB);\n    NewSIW.setSuccessorWeight(0, DefaultCaseWeight);\n\n    // We removed all the exit cases, so we just copy the cases to the\n    // unswitched switch.\n    for (const auto &Case : SI.cases())\n      NewSIW.addCase(Case.getCaseValue(), NewPH,\n                     SIW.getSuccessorWeight(Case.getSuccessorIndex()));\n  } else if (DefaultCaseWeight) {\n    // We have to set branch weight of the default case.\n    uint64_t SW = *DefaultCaseWeight;\n    for (const auto &Case : SI.cases()) {\n      auto W = SIW.getSuccessorWeight(Case.getSuccessorIndex());\n      assert(W &&\n             \"case weight must be defined as default case weight is defined\");\n      SW += *W;\n    }\n    NewSIW.setSuccessorWeight(0, SW);\n  }\n\n  // If we ended up with a common successor for every path through the switch\n  // after unswitching, rewrite it to an unconditional branch to make it easy\n  // to recognize. Otherwise we potentially have to recognize the default case\n  // pointing at unreachable and other complexity.\n  if (CommonSuccBB) {\n    BasicBlock *BB = SI.getParent();\n    // We may have had multiple edges to this common successor block, so remove\n    // them as predecessors. We skip the first one, either the default or the\n    // actual first case.\n    bool SkippedFirst = DefaultExitBB == nullptr;\n    for (auto Case : SI.cases()) {\n      assert(Case.getCaseSuccessor() == CommonSuccBB &&\n             \"Non-common successor!\");\n      (void)Case;\n      if (!SkippedFirst) {\n        SkippedFirst = true;\n        continue;\n      }\n      CommonSuccBB->removePredecessor(BB,\n                                      /*KeepOneInputPHIs*/ true);\n    }\n    // Now nuke the switch and replace it with a direct branch.\n    SIW.eraseFromParent();\n    BranchInst::Create(CommonSuccBB, BB);\n  } else if (DefaultExitBB) {\n    assert(SI.getNumCases() > 0 &&\n           \"If we had no cases we'd have a common successor!\");\n    // Move the last case to the default successor. This is valid as if the\n    // default got unswitched it cannot be reached. This has the advantage of\n    // being simple and keeping the number of edges from this switch to\n    // successors the same, and avoiding any PHI update complexity.\n    auto LastCaseI = std::prev(SI.case_end());\n\n    SI.setDefaultDest(LastCaseI->getCaseSuccessor());\n    SIW.setSuccessorWeight(\n        0, SIW.getSuccessorWeight(LastCaseI->getSuccessorIndex()));\n    SIW.removeCase(LastCaseI);\n  }\n\n  // Walk the unswitched exit blocks and the unswitched split blocks and update\n  // the dominator tree based on the CFG edits. While we are walking unordered\n  // containers here, the API for applyUpdates takes an unordered list of\n  // updates and requires them to not contain duplicates.\n  SmallVector<DominatorTree::UpdateType, 4> DTUpdates;\n  for (auto *UnswitchedExitBB : UnswitchedExitBBs) {\n    DTUpdates.push_back({DT.Delete, ParentBB, UnswitchedExitBB});\n    DTUpdates.push_back({DT.Insert, OldPH, UnswitchedExitBB});\n  }\n  for (auto SplitUnswitchedPair : SplitExitBBMap) {\n    DTUpdates.push_back({DT.Delete, ParentBB, SplitUnswitchedPair.first});\n    DTUpdates.push_back({DT.Insert, OldPH, SplitUnswitchedPair.second});\n  }\n\n  if (MSSAU) {\n    MSSAU->applyUpdates(DTUpdates, DT, /*UpdateDT=*/true);\n    if (VerifyMemorySSA)\n      MSSAU->getMemorySSA()->verifyMemorySSA();\n  } else {\n    DT.applyUpdates(DTUpdates);\n  }\n\n  assert(DT.verify(DominatorTree::VerificationLevel::Fast));\n\n  // We may have changed the nesting relationship for this loop so hoist it to\n  // its correct parent if needed.\n  hoistLoopToNewParent(L, *NewPH, DT, LI, MSSAU, SE);\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  ++NumTrivial;\n  ++NumSwitches;\n  LLVM_DEBUG(dbgs() << \"    done: unswitching trivial switch...\\n\");\n  return true;\n}\n\n/// This routine scans the loop to find a branch or switch which occurs before\n/// any side effects occur. These can potentially be unswitched without\n/// duplicating the loop. If a branch or switch is successfully unswitched the\n/// scanning continues to see if subsequent branches or switches have become\n/// trivial. Once all trivial candidates have been unswitched, this routine\n/// returns.\n///\n/// The return value indicates whether anything was unswitched (and therefore\n/// changed).\n///\n/// If `SE` is not null, it will be updated based on the potential loop SCEVs\n/// invalidated by this.\nstatic bool unswitchAllTrivialConditions(Loop &L, DominatorTree &DT,\n                                         LoopInfo &LI, ScalarEvolution *SE,\n                                         MemorySSAUpdater *MSSAU) {\n  bool Changed = false;\n\n  // If loop header has only one reachable successor we should keep looking for\n  // trivial condition candidates in the successor as well. An alternative is\n  // to constant fold conditions and merge successors into loop header (then we\n  // only need to check header's terminator). The reason for not doing this in\n  // LoopUnswitch pass is that it could potentially break LoopPassManager's\n  // invariants. Folding dead branches could either eliminate the current loop\n  // or make other loops unreachable. LCSSA form might also not be preserved\n  // after deleting branches. The following code keeps traversing loop header's\n  // successors until it finds the trivial condition candidate (condition that\n  // is not a constant). Since unswitching generates branches with constant\n  // conditions, this scenario could be very common in practice.\n  BasicBlock *CurrentBB = L.getHeader();\n  SmallPtrSet<BasicBlock *, 8> Visited;\n  Visited.insert(CurrentBB);\n  do {\n    // Check if there are any side-effecting instructions (e.g. stores, calls,\n    // volatile loads) in the part of the loop that the code *would* execute\n    // without unswitching.\n    if (MSSAU) // Possible early exit with MSSA\n      if (auto *Defs = MSSAU->getMemorySSA()->getBlockDefs(CurrentBB))\n        if (!isa<MemoryPhi>(*Defs->begin()) || (++Defs->begin() != Defs->end()))\n          return Changed;\n    if (llvm::any_of(*CurrentBB,\n                     [](Instruction &I) { return I.mayHaveSideEffects(); }))\n      return Changed;\n\n    Instruction *CurrentTerm = CurrentBB->getTerminator();\n\n    if (auto *SI = dyn_cast<SwitchInst>(CurrentTerm)) {\n      // Don't bother trying to unswitch past a switch with a constant\n      // condition. This should be removed prior to running this pass by\n      // simplify-cfg.\n      if (isa<Constant>(SI->getCondition()))\n        return Changed;\n\n      if (!unswitchTrivialSwitch(L, *SI, DT, LI, SE, MSSAU))\n        // Couldn't unswitch this one so we're done.\n        return Changed;\n\n      // Mark that we managed to unswitch something.\n      Changed = true;\n\n      // If unswitching turned the terminator into an unconditional branch then\n      // we can continue. The unswitching logic specifically works to fold any\n      // cases it can into an unconditional branch to make it easier to\n      // recognize here.\n      auto *BI = dyn_cast<BranchInst>(CurrentBB->getTerminator());\n      if (!BI || BI->isConditional())\n        return Changed;\n\n      CurrentBB = BI->getSuccessor(0);\n      continue;\n    }\n\n    auto *BI = dyn_cast<BranchInst>(CurrentTerm);\n    if (!BI)\n      // We do not understand other terminator instructions.\n      return Changed;\n\n    // Don't bother trying to unswitch past an unconditional branch or a branch\n    // with a constant value. These should be removed by simplify-cfg prior to\n    // running this pass.\n    if (!BI->isConditional() || isa<Constant>(BI->getCondition()))\n      return Changed;\n\n    // Found a trivial condition candidate: non-foldable conditional branch. If\n    // we fail to unswitch this, we can't do anything else that is trivial.\n    if (!unswitchTrivialBranch(L, *BI, DT, LI, SE, MSSAU))\n      return Changed;\n\n    // Mark that we managed to unswitch something.\n    Changed = true;\n\n    // If we only unswitched some of the conditions feeding the branch, we won't\n    // have collapsed it to a single successor.\n    BI = cast<BranchInst>(CurrentBB->getTerminator());\n    if (BI->isConditional())\n      return Changed;\n\n    // Follow the newly unconditional branch into its successor.\n    CurrentBB = BI->getSuccessor(0);\n\n    // When continuing, if we exit the loop or reach a previous visited block,\n    // then we can not reach any trivial condition candidates (unfoldable\n    // branch instructions or switch instructions) and no unswitch can happen.\n  } while (L.contains(CurrentBB) && Visited.insert(CurrentBB).second);\n\n  return Changed;\n}\n\n/// Build the cloned blocks for an unswitched copy of the given loop.\n///\n/// The cloned blocks are inserted before the loop preheader (`LoopPH`) and\n/// after the split block (`SplitBB`) that will be used to select between the\n/// cloned and original loop.\n///\n/// This routine handles cloning all of the necessary loop blocks and exit\n/// blocks including rewriting their instructions and the relevant PHI nodes.\n/// Any loop blocks or exit blocks which are dominated by a different successor\n/// than the one for this clone of the loop blocks can be trivially skipped. We\n/// use the `DominatingSucc` map to determine whether a block satisfies that\n/// property with a simple map lookup.\n///\n/// It also correctly creates the unconditional branch in the cloned\n/// unswitched parent block to only point at the unswitched successor.\n///\n/// This does not handle most of the necessary updates to `LoopInfo`. Only exit\n/// block splitting is correctly reflected in `LoopInfo`, essentially all of\n/// the cloned blocks (and their loops) are left without full `LoopInfo`\n/// updates. This also doesn't fully update `DominatorTree`. It adds the cloned\n/// blocks to them but doesn't create the cloned `DominatorTree` structure and\n/// instead the caller must recompute an accurate DT. It *does* correctly\n/// update the `AssumptionCache` provided in `AC`.\nstatic BasicBlock *buildClonedLoopBlocks(\n    Loop &L, BasicBlock *LoopPH, BasicBlock *SplitBB,\n    ArrayRef<BasicBlock *> ExitBlocks, BasicBlock *ParentBB,\n    BasicBlock *UnswitchedSuccBB, BasicBlock *ContinueSuccBB,\n    const SmallDenseMap<BasicBlock *, BasicBlock *, 16> &DominatingSucc,\n    ValueToValueMapTy &VMap,\n    SmallVectorImpl<DominatorTree::UpdateType> &DTUpdates, AssumptionCache &AC,\n    DominatorTree &DT, LoopInfo &LI, MemorySSAUpdater *MSSAU) {\n  SmallVector<BasicBlock *, 4> NewBlocks;\n  NewBlocks.reserve(L.getNumBlocks() + ExitBlocks.size());\n\n  // We will need to clone a bunch of blocks, wrap up the clone operation in\n  // a helper.\n  auto CloneBlock = [&](BasicBlock *OldBB) {\n    // Clone the basic block and insert it before the new preheader.\n    BasicBlock *NewBB = CloneBasicBlock(OldBB, VMap, \".us\", OldBB->getParent());\n    NewBB->moveBefore(LoopPH);\n\n    // Record this block and the mapping.\n    NewBlocks.push_back(NewBB);\n    VMap[OldBB] = NewBB;\n\n    return NewBB;\n  };\n\n  // We skip cloning blocks when they have a dominating succ that is not the\n  // succ we are cloning for.\n  auto SkipBlock = [&](BasicBlock *BB) {\n    auto It = DominatingSucc.find(BB);\n    return It != DominatingSucc.end() && It->second != UnswitchedSuccBB;\n  };\n\n  // First, clone the preheader.\n  auto *ClonedPH = CloneBlock(LoopPH);\n\n  // Then clone all the loop blocks, skipping the ones that aren't necessary.\n  for (auto *LoopBB : L.blocks())\n    if (!SkipBlock(LoopBB))\n      CloneBlock(LoopBB);\n\n  // Split all the loop exit edges so that when we clone the exit blocks, if\n  // any of the exit blocks are *also* a preheader for some other loop, we\n  // don't create multiple predecessors entering the loop header.\n  for (auto *ExitBB : ExitBlocks) {\n    if (SkipBlock(ExitBB))\n      continue;\n\n    // When we are going to clone an exit, we don't need to clone all the\n    // instructions in the exit block and we want to ensure we have an easy\n    // place to merge the CFG, so split the exit first. This is always safe to\n    // do because there cannot be any non-loop predecessors of a loop exit in\n    // loop simplified form.\n    auto *MergeBB = SplitBlock(ExitBB, &ExitBB->front(), &DT, &LI, MSSAU);\n\n    // Rearrange the names to make it easier to write test cases by having the\n    // exit block carry the suffix rather than the merge block carrying the\n    // suffix.\n    MergeBB->takeName(ExitBB);\n    ExitBB->setName(Twine(MergeBB->getName()) + \".split\");\n\n    // Now clone the original exit block.\n    auto *ClonedExitBB = CloneBlock(ExitBB);\n    assert(ClonedExitBB->getTerminator()->getNumSuccessors() == 1 &&\n           \"Exit block should have been split to have one successor!\");\n    assert(ClonedExitBB->getTerminator()->getSuccessor(0) == MergeBB &&\n           \"Cloned exit block has the wrong successor!\");\n\n    // Remap any cloned instructions and create a merge phi node for them.\n    for (auto ZippedInsts : llvm::zip_first(\n             llvm::make_range(ExitBB->begin(), std::prev(ExitBB->end())),\n             llvm::make_range(ClonedExitBB->begin(),\n                              std::prev(ClonedExitBB->end())))) {\n      Instruction &I = std::get<0>(ZippedInsts);\n      Instruction &ClonedI = std::get<1>(ZippedInsts);\n\n      // The only instructions in the exit block should be PHI nodes and\n      // potentially a landing pad.\n      assert(\n          (isa<PHINode>(I) || isa<LandingPadInst>(I) || isa<CatchPadInst>(I)) &&\n          \"Bad instruction in exit block!\");\n      // We should have a value map between the instruction and its clone.\n      assert(VMap.lookup(&I) == &ClonedI && \"Mismatch in the value map!\");\n\n      auto *MergePN =\n          PHINode::Create(I.getType(), /*NumReservedValues*/ 2, \".us-phi\",\n                          &*MergeBB->getFirstInsertionPt());\n      I.replaceAllUsesWith(MergePN);\n      MergePN->addIncoming(&I, ExitBB);\n      MergePN->addIncoming(&ClonedI, ClonedExitBB);\n    }\n  }\n\n  // Rewrite the instructions in the cloned blocks to refer to the instructions\n  // in the cloned blocks. We have to do this as a second pass so that we have\n  // everything available. Also, we have inserted new instructions which may\n  // include assume intrinsics, so we update the assumption cache while\n  // processing this.\n  for (auto *ClonedBB : NewBlocks)\n    for (Instruction &I : *ClonedBB) {\n      RemapInstruction(&I, VMap,\n                       RF_NoModuleLevelChanges | RF_IgnoreMissingLocals);\n      if (auto *II = dyn_cast<IntrinsicInst>(&I))\n        if (II->getIntrinsicID() == Intrinsic::assume)\n          AC.registerAssumption(II);\n    }\n\n  // Update any PHI nodes in the cloned successors of the skipped blocks to not\n  // have spurious incoming values.\n  for (auto *LoopBB : L.blocks())\n    if (SkipBlock(LoopBB))\n      for (auto *SuccBB : successors(LoopBB))\n        if (auto *ClonedSuccBB = cast_or_null<BasicBlock>(VMap.lookup(SuccBB)))\n          for (PHINode &PN : ClonedSuccBB->phis())\n            PN.removeIncomingValue(LoopBB, /*DeletePHIIfEmpty*/ false);\n\n  // Remove the cloned parent as a predecessor of any successor we ended up\n  // cloning other than the unswitched one.\n  auto *ClonedParentBB = cast<BasicBlock>(VMap.lookup(ParentBB));\n  for (auto *SuccBB : successors(ParentBB)) {\n    if (SuccBB == UnswitchedSuccBB)\n      continue;\n\n    auto *ClonedSuccBB = cast_or_null<BasicBlock>(VMap.lookup(SuccBB));\n    if (!ClonedSuccBB)\n      continue;\n\n    ClonedSuccBB->removePredecessor(ClonedParentBB,\n                                    /*KeepOneInputPHIs*/ true);\n  }\n\n  // Replace the cloned branch with an unconditional branch to the cloned\n  // unswitched successor.\n  auto *ClonedSuccBB = cast<BasicBlock>(VMap.lookup(UnswitchedSuccBB));\n  Instruction *ClonedTerminator = ClonedParentBB->getTerminator();\n  // Trivial Simplification. If Terminator is a conditional branch and\n  // condition becomes dead - erase it.\n  Value *ClonedConditionToErase = nullptr;\n  if (auto *BI = dyn_cast<BranchInst>(ClonedTerminator))\n    ClonedConditionToErase = BI->getCondition();\n  else if (auto *SI = dyn_cast<SwitchInst>(ClonedTerminator))\n    ClonedConditionToErase = SI->getCondition();\n\n  ClonedTerminator->eraseFromParent();\n  BranchInst::Create(ClonedSuccBB, ClonedParentBB);\n\n  if (ClonedConditionToErase)\n    RecursivelyDeleteTriviallyDeadInstructions(ClonedConditionToErase, nullptr,\n                                               MSSAU);\n\n  // If there are duplicate entries in the PHI nodes because of multiple edges\n  // to the unswitched successor, we need to nuke all but one as we replaced it\n  // with a direct branch.\n  for (PHINode &PN : ClonedSuccBB->phis()) {\n    bool Found = false;\n    // Loop over the incoming operands backwards so we can easily delete as we\n    // go without invalidating the index.\n    for (int i = PN.getNumOperands() - 1; i >= 0; --i) {\n      if (PN.getIncomingBlock(i) != ClonedParentBB)\n        continue;\n      if (!Found) {\n        Found = true;\n        continue;\n      }\n      PN.removeIncomingValue(i, /*DeletePHIIfEmpty*/ false);\n    }\n  }\n\n  // Record the domtree updates for the new blocks.\n  SmallPtrSet<BasicBlock *, 4> SuccSet;\n  for (auto *ClonedBB : NewBlocks) {\n    for (auto *SuccBB : successors(ClonedBB))\n      if (SuccSet.insert(SuccBB).second)\n        DTUpdates.push_back({DominatorTree::Insert, ClonedBB, SuccBB});\n    SuccSet.clear();\n  }\n\n  return ClonedPH;\n}\n\n/// Recursively clone the specified loop and all of its children.\n///\n/// The target parent loop for the clone should be provided, or can be null if\n/// the clone is a top-level loop. While cloning, all the blocks are mapped\n/// with the provided value map. The entire original loop must be present in\n/// the value map. The cloned loop is returned.\nstatic Loop *cloneLoopNest(Loop &OrigRootL, Loop *RootParentL,\n                           const ValueToValueMapTy &VMap, LoopInfo &LI) {\n  auto AddClonedBlocksToLoop = [&](Loop &OrigL, Loop &ClonedL) {\n    assert(ClonedL.getBlocks().empty() && \"Must start with an empty loop!\");\n    ClonedL.reserveBlocks(OrigL.getNumBlocks());\n    for (auto *BB : OrigL.blocks()) {\n      auto *ClonedBB = cast<BasicBlock>(VMap.lookup(BB));\n      ClonedL.addBlockEntry(ClonedBB);\n      if (LI.getLoopFor(BB) == &OrigL)\n        LI.changeLoopFor(ClonedBB, &ClonedL);\n    }\n  };\n\n  // We specially handle the first loop because it may get cloned into\n  // a different parent and because we most commonly are cloning leaf loops.\n  Loop *ClonedRootL = LI.AllocateLoop();\n  if (RootParentL)\n    RootParentL->addChildLoop(ClonedRootL);\n  else\n    LI.addTopLevelLoop(ClonedRootL);\n  AddClonedBlocksToLoop(OrigRootL, *ClonedRootL);\n\n  if (OrigRootL.isInnermost())\n    return ClonedRootL;\n\n  // If we have a nest, we can quickly clone the entire loop nest using an\n  // iterative approach because it is a tree. We keep the cloned parent in the\n  // data structure to avoid repeatedly querying through a map to find it.\n  SmallVector<std::pair<Loop *, Loop *>, 16> LoopsToClone;\n  // Build up the loops to clone in reverse order as we'll clone them from the\n  // back.\n  for (Loop *ChildL : llvm::reverse(OrigRootL))\n    LoopsToClone.push_back({ClonedRootL, ChildL});\n  do {\n    Loop *ClonedParentL, *L;\n    std::tie(ClonedParentL, L) = LoopsToClone.pop_back_val();\n    Loop *ClonedL = LI.AllocateLoop();\n    ClonedParentL->addChildLoop(ClonedL);\n    AddClonedBlocksToLoop(*L, *ClonedL);\n    for (Loop *ChildL : llvm::reverse(*L))\n      LoopsToClone.push_back({ClonedL, ChildL});\n  } while (!LoopsToClone.empty());\n\n  return ClonedRootL;\n}\n\n/// Build the cloned loops of an original loop from unswitching.\n///\n/// Because unswitching simplifies the CFG of the loop, this isn't a trivial\n/// operation. We need to re-verify that there even is a loop (as the backedge\n/// may not have been cloned), and even if there are remaining backedges the\n/// backedge set may be different. However, we know that each child loop is\n/// undisturbed, we only need to find where to place each child loop within\n/// either any parent loop or within a cloned version of the original loop.\n///\n/// Because child loops may end up cloned outside of any cloned version of the\n/// original loop, multiple cloned sibling loops may be created. All of them\n/// are returned so that the newly introduced loop nest roots can be\n/// identified.\nstatic void buildClonedLoops(Loop &OrigL, ArrayRef<BasicBlock *> ExitBlocks,\n                             const ValueToValueMapTy &VMap, LoopInfo &LI,\n                             SmallVectorImpl<Loop *> &NonChildClonedLoops) {\n  Loop *ClonedL = nullptr;\n\n  auto *OrigPH = OrigL.getLoopPreheader();\n  auto *OrigHeader = OrigL.getHeader();\n\n  auto *ClonedPH = cast<BasicBlock>(VMap.lookup(OrigPH));\n  auto *ClonedHeader = cast<BasicBlock>(VMap.lookup(OrigHeader));\n\n  // We need to know the loops of the cloned exit blocks to even compute the\n  // accurate parent loop. If we only clone exits to some parent of the\n  // original parent, we want to clone into that outer loop. We also keep track\n  // of the loops that our cloned exit blocks participate in.\n  Loop *ParentL = nullptr;\n  SmallVector<BasicBlock *, 4> ClonedExitsInLoops;\n  SmallDenseMap<BasicBlock *, Loop *, 16> ExitLoopMap;\n  ClonedExitsInLoops.reserve(ExitBlocks.size());\n  for (auto *ExitBB : ExitBlocks)\n    if (auto *ClonedExitBB = cast_or_null<BasicBlock>(VMap.lookup(ExitBB)))\n      if (Loop *ExitL = LI.getLoopFor(ExitBB)) {\n        ExitLoopMap[ClonedExitBB] = ExitL;\n        ClonedExitsInLoops.push_back(ClonedExitBB);\n        if (!ParentL || (ParentL != ExitL && ParentL->contains(ExitL)))\n          ParentL = ExitL;\n      }\n  assert((!ParentL || ParentL == OrigL.getParentLoop() ||\n          ParentL->contains(OrigL.getParentLoop())) &&\n         \"The computed parent loop should always contain (or be) the parent of \"\n         \"the original loop.\");\n\n  // We build the set of blocks dominated by the cloned header from the set of\n  // cloned blocks out of the original loop. While not all of these will\n  // necessarily be in the cloned loop, it is enough to establish that they\n  // aren't in unreachable cycles, etc.\n  SmallSetVector<BasicBlock *, 16> ClonedLoopBlocks;\n  for (auto *BB : OrigL.blocks())\n    if (auto *ClonedBB = cast_or_null<BasicBlock>(VMap.lookup(BB)))\n      ClonedLoopBlocks.insert(ClonedBB);\n\n  // Rebuild the set of blocks that will end up in the cloned loop. We may have\n  // skipped cloning some region of this loop which can in turn skip some of\n  // the backedges so we have to rebuild the blocks in the loop based on the\n  // backedges that remain after cloning.\n  SmallVector<BasicBlock *, 16> Worklist;\n  SmallPtrSet<BasicBlock *, 16> BlocksInClonedLoop;\n  for (auto *Pred : predecessors(ClonedHeader)) {\n    // The only possible non-loop header predecessor is the preheader because\n    // we know we cloned the loop in simplified form.\n    if (Pred == ClonedPH)\n      continue;\n\n    // Because the loop was in simplified form, the only non-loop predecessor\n    // should be the preheader.\n    assert(ClonedLoopBlocks.count(Pred) && \"Found a predecessor of the loop \"\n                                           \"header other than the preheader \"\n                                           \"that is not part of the loop!\");\n\n    // Insert this block into the loop set and on the first visit (and if it\n    // isn't the header we're currently walking) put it into the worklist to\n    // recurse through.\n    if (BlocksInClonedLoop.insert(Pred).second && Pred != ClonedHeader)\n      Worklist.push_back(Pred);\n  }\n\n  // If we had any backedges then there *is* a cloned loop. Put the header into\n  // the loop set and then walk the worklist backwards to find all the blocks\n  // that remain within the loop after cloning.\n  if (!BlocksInClonedLoop.empty()) {\n    BlocksInClonedLoop.insert(ClonedHeader);\n\n    while (!Worklist.empty()) {\n      BasicBlock *BB = Worklist.pop_back_val();\n      assert(BlocksInClonedLoop.count(BB) &&\n             \"Didn't put block into the loop set!\");\n\n      // Insert any predecessors that are in the possible set into the cloned\n      // set, and if the insert is successful, add them to the worklist. Note\n      // that we filter on the blocks that are definitely reachable via the\n      // backedge to the loop header so we may prune out dead code within the\n      // cloned loop.\n      for (auto *Pred : predecessors(BB))\n        if (ClonedLoopBlocks.count(Pred) &&\n            BlocksInClonedLoop.insert(Pred).second)\n          Worklist.push_back(Pred);\n    }\n\n    ClonedL = LI.AllocateLoop();\n    if (ParentL) {\n      ParentL->addBasicBlockToLoop(ClonedPH, LI);\n      ParentL->addChildLoop(ClonedL);\n    } else {\n      LI.addTopLevelLoop(ClonedL);\n    }\n    NonChildClonedLoops.push_back(ClonedL);\n\n    ClonedL->reserveBlocks(BlocksInClonedLoop.size());\n    // We don't want to just add the cloned loop blocks based on how we\n    // discovered them. The original order of blocks was carefully built in\n    // a way that doesn't rely on predecessor ordering. Rather than re-invent\n    // that logic, we just re-walk the original blocks (and those of the child\n    // loops) and filter them as we add them into the cloned loop.\n    for (auto *BB : OrigL.blocks()) {\n      auto *ClonedBB = cast_or_null<BasicBlock>(VMap.lookup(BB));\n      if (!ClonedBB || !BlocksInClonedLoop.count(ClonedBB))\n        continue;\n\n      // Directly add the blocks that are only in this loop.\n      if (LI.getLoopFor(BB) == &OrigL) {\n        ClonedL->addBasicBlockToLoop(ClonedBB, LI);\n        continue;\n      }\n\n      // We want to manually add it to this loop and parents.\n      // Registering it with LoopInfo will happen when we clone the top\n      // loop for this block.\n      for (Loop *PL = ClonedL; PL; PL = PL->getParentLoop())\n        PL->addBlockEntry(ClonedBB);\n    }\n\n    // Now add each child loop whose header remains within the cloned loop. All\n    // of the blocks within the loop must satisfy the same constraints as the\n    // header so once we pass the header checks we can just clone the entire\n    // child loop nest.\n    for (Loop *ChildL : OrigL) {\n      auto *ClonedChildHeader =\n          cast_or_null<BasicBlock>(VMap.lookup(ChildL->getHeader()));\n      if (!ClonedChildHeader || !BlocksInClonedLoop.count(ClonedChildHeader))\n        continue;\n\n#ifndef NDEBUG\n      // We should never have a cloned child loop header but fail to have\n      // all of the blocks for that child loop.\n      for (auto *ChildLoopBB : ChildL->blocks())\n        assert(BlocksInClonedLoop.count(\n                   cast<BasicBlock>(VMap.lookup(ChildLoopBB))) &&\n               \"Child cloned loop has a header within the cloned outer \"\n               \"loop but not all of its blocks!\");\n#endif\n\n      cloneLoopNest(*ChildL, ClonedL, VMap, LI);\n    }\n  }\n\n  // Now that we've handled all the components of the original loop that were\n  // cloned into a new loop, we still need to handle anything from the original\n  // loop that wasn't in a cloned loop.\n\n  // Figure out what blocks are left to place within any loop nest containing\n  // the unswitched loop. If we never formed a loop, the cloned PH is one of\n  // them.\n  SmallPtrSet<BasicBlock *, 16> UnloopedBlockSet;\n  if (BlocksInClonedLoop.empty())\n    UnloopedBlockSet.insert(ClonedPH);\n  for (auto *ClonedBB : ClonedLoopBlocks)\n    if (!BlocksInClonedLoop.count(ClonedBB))\n      UnloopedBlockSet.insert(ClonedBB);\n\n  // Copy the cloned exits and sort them in ascending loop depth, we'll work\n  // backwards across these to process them inside out. The order shouldn't\n  // matter as we're just trying to build up the map from inside-out; we use\n  // the map in a more stably ordered way below.\n  auto OrderedClonedExitsInLoops = ClonedExitsInLoops;\n  llvm::sort(OrderedClonedExitsInLoops, [&](BasicBlock *LHS, BasicBlock *RHS) {\n    return ExitLoopMap.lookup(LHS)->getLoopDepth() <\n           ExitLoopMap.lookup(RHS)->getLoopDepth();\n  });\n\n  // Populate the existing ExitLoopMap with everything reachable from each\n  // exit, starting from the inner most exit.\n  while (!UnloopedBlockSet.empty() && !OrderedClonedExitsInLoops.empty()) {\n    assert(Worklist.empty() && \"Didn't clear worklist!\");\n\n    BasicBlock *ExitBB = OrderedClonedExitsInLoops.pop_back_val();\n    Loop *ExitL = ExitLoopMap.lookup(ExitBB);\n\n    // Walk the CFG back until we hit the cloned PH adding everything reachable\n    // and in the unlooped set to this exit block's loop.\n    Worklist.push_back(ExitBB);\n    do {\n      BasicBlock *BB = Worklist.pop_back_val();\n      // We can stop recursing at the cloned preheader (if we get there).\n      if (BB == ClonedPH)\n        continue;\n\n      for (BasicBlock *PredBB : predecessors(BB)) {\n        // If this pred has already been moved to our set or is part of some\n        // (inner) loop, no update needed.\n        if (!UnloopedBlockSet.erase(PredBB)) {\n          assert(\n              (BlocksInClonedLoop.count(PredBB) || ExitLoopMap.count(PredBB)) &&\n              \"Predecessor not mapped to a loop!\");\n          continue;\n        }\n\n        // We just insert into the loop set here. We'll add these blocks to the\n        // exit loop after we build up the set in an order that doesn't rely on\n        // predecessor order (which in turn relies on use list order).\n        bool Inserted = ExitLoopMap.insert({PredBB, ExitL}).second;\n        (void)Inserted;\n        assert(Inserted && \"Should only visit an unlooped block once!\");\n\n        // And recurse through to its predecessors.\n        Worklist.push_back(PredBB);\n      }\n    } while (!Worklist.empty());\n  }\n\n  // Now that the ExitLoopMap gives as  mapping for all the non-looping cloned\n  // blocks to their outer loops, walk the cloned blocks and the cloned exits\n  // in their original order adding them to the correct loop.\n\n  // We need a stable insertion order. We use the order of the original loop\n  // order and map into the correct parent loop.\n  for (auto *BB : llvm::concat<BasicBlock *const>(\n           makeArrayRef(ClonedPH), ClonedLoopBlocks, ClonedExitsInLoops))\n    if (Loop *OuterL = ExitLoopMap.lookup(BB))\n      OuterL->addBasicBlockToLoop(BB, LI);\n\n#ifndef NDEBUG\n  for (auto &BBAndL : ExitLoopMap) {\n    auto *BB = BBAndL.first;\n    auto *OuterL = BBAndL.second;\n    assert(LI.getLoopFor(BB) == OuterL &&\n           \"Failed to put all blocks into outer loops!\");\n  }\n#endif\n\n  // Now that all the blocks are placed into the correct containing loop in the\n  // absence of child loops, find all the potentially cloned child loops and\n  // clone them into whatever outer loop we placed their header into.\n  for (Loop *ChildL : OrigL) {\n    auto *ClonedChildHeader =\n        cast_or_null<BasicBlock>(VMap.lookup(ChildL->getHeader()));\n    if (!ClonedChildHeader || BlocksInClonedLoop.count(ClonedChildHeader))\n      continue;\n\n#ifndef NDEBUG\n    for (auto *ChildLoopBB : ChildL->blocks())\n      assert(VMap.count(ChildLoopBB) &&\n             \"Cloned a child loop header but not all of that loops blocks!\");\n#endif\n\n    NonChildClonedLoops.push_back(cloneLoopNest(\n        *ChildL, ExitLoopMap.lookup(ClonedChildHeader), VMap, LI));\n  }\n}\n\nstatic void\ndeleteDeadClonedBlocks(Loop &L, ArrayRef<BasicBlock *> ExitBlocks,\n                       ArrayRef<std::unique_ptr<ValueToValueMapTy>> VMaps,\n                       DominatorTree &DT, MemorySSAUpdater *MSSAU) {\n  // Find all the dead clones, and remove them from their successors.\n  SmallVector<BasicBlock *, 16> DeadBlocks;\n  for (BasicBlock *BB : llvm::concat<BasicBlock *const>(L.blocks(), ExitBlocks))\n    for (auto &VMap : VMaps)\n      if (BasicBlock *ClonedBB = cast_or_null<BasicBlock>(VMap->lookup(BB)))\n        if (!DT.isReachableFromEntry(ClonedBB)) {\n          for (BasicBlock *SuccBB : successors(ClonedBB))\n            SuccBB->removePredecessor(ClonedBB);\n          DeadBlocks.push_back(ClonedBB);\n        }\n\n  // Remove all MemorySSA in the dead blocks\n  if (MSSAU) {\n    SmallSetVector<BasicBlock *, 8> DeadBlockSet(DeadBlocks.begin(),\n                                                 DeadBlocks.end());\n    MSSAU->removeBlocks(DeadBlockSet);\n  }\n\n  // Drop any remaining references to break cycles.\n  for (BasicBlock *BB : DeadBlocks)\n    BB->dropAllReferences();\n  // Erase them from the IR.\n  for (BasicBlock *BB : DeadBlocks)\n    BB->eraseFromParent();\n}\n\nstatic void deleteDeadBlocksFromLoop(Loop &L,\n                                     SmallVectorImpl<BasicBlock *> &ExitBlocks,\n                                     DominatorTree &DT, LoopInfo &LI,\n                                     MemorySSAUpdater *MSSAU) {\n  // Find all the dead blocks tied to this loop, and remove them from their\n  // successors.\n  SmallSetVector<BasicBlock *, 8> DeadBlockSet;\n\n  // Start with loop/exit blocks and get a transitive closure of reachable dead\n  // blocks.\n  SmallVector<BasicBlock *, 16> DeathCandidates(ExitBlocks.begin(),\n                                                ExitBlocks.end());\n  DeathCandidates.append(L.blocks().begin(), L.blocks().end());\n  while (!DeathCandidates.empty()) {\n    auto *BB = DeathCandidates.pop_back_val();\n    if (!DeadBlockSet.count(BB) && !DT.isReachableFromEntry(BB)) {\n      for (BasicBlock *SuccBB : successors(BB)) {\n        SuccBB->removePredecessor(BB);\n        DeathCandidates.push_back(SuccBB);\n      }\n      DeadBlockSet.insert(BB);\n    }\n  }\n\n  // Remove all MemorySSA in the dead blocks\n  if (MSSAU)\n    MSSAU->removeBlocks(DeadBlockSet);\n\n  // Filter out the dead blocks from the exit blocks list so that it can be\n  // used in the caller.\n  llvm::erase_if(ExitBlocks,\n                 [&](BasicBlock *BB) { return DeadBlockSet.count(BB); });\n\n  // Walk from this loop up through its parents removing all of the dead blocks.\n  for (Loop *ParentL = &L; ParentL; ParentL = ParentL->getParentLoop()) {\n    for (auto *BB : DeadBlockSet)\n      ParentL->getBlocksSet().erase(BB);\n    llvm::erase_if(ParentL->getBlocksVector(),\n                   [&](BasicBlock *BB) { return DeadBlockSet.count(BB); });\n  }\n\n  // Now delete the dead child loops. This raw delete will clear them\n  // recursively.\n  llvm::erase_if(L.getSubLoopsVector(), [&](Loop *ChildL) {\n    if (!DeadBlockSet.count(ChildL->getHeader()))\n      return false;\n\n    assert(llvm::all_of(ChildL->blocks(),\n                        [&](BasicBlock *ChildBB) {\n                          return DeadBlockSet.count(ChildBB);\n                        }) &&\n           \"If the child loop header is dead all blocks in the child loop must \"\n           \"be dead as well!\");\n    LI.destroy(ChildL);\n    return true;\n  });\n\n  // Remove the loop mappings for the dead blocks and drop all the references\n  // from these blocks to others to handle cyclic references as we start\n  // deleting the blocks themselves.\n  for (auto *BB : DeadBlockSet) {\n    // Check that the dominator tree has already been updated.\n    assert(!DT.getNode(BB) && \"Should already have cleared domtree!\");\n    LI.changeLoopFor(BB, nullptr);\n    // Drop all uses of the instructions to make sure we won't have dangling\n    // uses in other blocks.\n    for (auto &I : *BB)\n      if (!I.use_empty())\n        I.replaceAllUsesWith(UndefValue::get(I.getType()));\n    BB->dropAllReferences();\n  }\n\n  // Actually delete the blocks now that they've been fully unhooked from the\n  // IR.\n  for (auto *BB : DeadBlockSet)\n    BB->eraseFromParent();\n}\n\n/// Recompute the set of blocks in a loop after unswitching.\n///\n/// This walks from the original headers predecessors to rebuild the loop. We\n/// take advantage of the fact that new blocks can't have been added, and so we\n/// filter by the original loop's blocks. This also handles potentially\n/// unreachable code that we don't want to explore but might be found examining\n/// the predecessors of the header.\n///\n/// If the original loop is no longer a loop, this will return an empty set. If\n/// it remains a loop, all the blocks within it will be added to the set\n/// (including those blocks in inner loops).\nstatic SmallPtrSet<const BasicBlock *, 16> recomputeLoopBlockSet(Loop &L,\n                                                                 LoopInfo &LI) {\n  SmallPtrSet<const BasicBlock *, 16> LoopBlockSet;\n\n  auto *PH = L.getLoopPreheader();\n  auto *Header = L.getHeader();\n\n  // A worklist to use while walking backwards from the header.\n  SmallVector<BasicBlock *, 16> Worklist;\n\n  // First walk the predecessors of the header to find the backedges. This will\n  // form the basis of our walk.\n  for (auto *Pred : predecessors(Header)) {\n    // Skip the preheader.\n    if (Pred == PH)\n      continue;\n\n    // Because the loop was in simplified form, the only non-loop predecessor\n    // is the preheader.\n    assert(L.contains(Pred) && \"Found a predecessor of the loop header other \"\n                               \"than the preheader that is not part of the \"\n                               \"loop!\");\n\n    // Insert this block into the loop set and on the first visit and, if it\n    // isn't the header we're currently walking, put it into the worklist to\n    // recurse through.\n    if (LoopBlockSet.insert(Pred).second && Pred != Header)\n      Worklist.push_back(Pred);\n  }\n\n  // If no backedges were found, we're done.\n  if (LoopBlockSet.empty())\n    return LoopBlockSet;\n\n  // We found backedges, recurse through them to identify the loop blocks.\n  while (!Worklist.empty()) {\n    BasicBlock *BB = Worklist.pop_back_val();\n    assert(LoopBlockSet.count(BB) && \"Didn't put block into the loop set!\");\n\n    // No need to walk past the header.\n    if (BB == Header)\n      continue;\n\n    // Because we know the inner loop structure remains valid we can use the\n    // loop structure to jump immediately across the entire nested loop.\n    // Further, because it is in loop simplified form, we can directly jump\n    // to its preheader afterward.\n    if (Loop *InnerL = LI.getLoopFor(BB))\n      if (InnerL != &L) {\n        assert(L.contains(InnerL) &&\n               \"Should not reach a loop *outside* this loop!\");\n        // The preheader is the only possible predecessor of the loop so\n        // insert it into the set and check whether it was already handled.\n        auto *InnerPH = InnerL->getLoopPreheader();\n        assert(L.contains(InnerPH) && \"Cannot contain an inner loop block \"\n                                      \"but not contain the inner loop \"\n                                      \"preheader!\");\n        if (!LoopBlockSet.insert(InnerPH).second)\n          // The only way to reach the preheader is through the loop body\n          // itself so if it has been visited the loop is already handled.\n          continue;\n\n        // Insert all of the blocks (other than those already present) into\n        // the loop set. We expect at least the block that led us to find the\n        // inner loop to be in the block set, but we may also have other loop\n        // blocks if they were already enqueued as predecessors of some other\n        // outer loop block.\n        for (auto *InnerBB : InnerL->blocks()) {\n          if (InnerBB == BB) {\n            assert(LoopBlockSet.count(InnerBB) &&\n                   \"Block should already be in the set!\");\n            continue;\n          }\n\n          LoopBlockSet.insert(InnerBB);\n        }\n\n        // Add the preheader to the worklist so we will continue past the\n        // loop body.\n        Worklist.push_back(InnerPH);\n        continue;\n      }\n\n    // Insert any predecessors that were in the original loop into the new\n    // set, and if the insert is successful, add them to the worklist.\n    for (auto *Pred : predecessors(BB))\n      if (L.contains(Pred) && LoopBlockSet.insert(Pred).second)\n        Worklist.push_back(Pred);\n  }\n\n  assert(LoopBlockSet.count(Header) && \"Cannot fail to add the header!\");\n\n  // We've found all the blocks participating in the loop, return our completed\n  // set.\n  return LoopBlockSet;\n}\n\n/// Rebuild a loop after unswitching removes some subset of blocks and edges.\n///\n/// The removal may have removed some child loops entirely but cannot have\n/// disturbed any remaining child loops. However, they may need to be hoisted\n/// to the parent loop (or to be top-level loops). The original loop may be\n/// completely removed.\n///\n/// The sibling loops resulting from this update are returned. If the original\n/// loop remains a valid loop, it will be the first entry in this list with all\n/// of the newly sibling loops following it.\n///\n/// Returns true if the loop remains a loop after unswitching, and false if it\n/// is no longer a loop after unswitching (and should not continue to be\n/// referenced).\nstatic bool rebuildLoopAfterUnswitch(Loop &L, ArrayRef<BasicBlock *> ExitBlocks,\n                                     LoopInfo &LI,\n                                     SmallVectorImpl<Loop *> &HoistedLoops) {\n  auto *PH = L.getLoopPreheader();\n\n  // Compute the actual parent loop from the exit blocks. Because we may have\n  // pruned some exits the loop may be different from the original parent.\n  Loop *ParentL = nullptr;\n  SmallVector<Loop *, 4> ExitLoops;\n  SmallVector<BasicBlock *, 4> ExitsInLoops;\n  ExitsInLoops.reserve(ExitBlocks.size());\n  for (auto *ExitBB : ExitBlocks)\n    if (Loop *ExitL = LI.getLoopFor(ExitBB)) {\n      ExitLoops.push_back(ExitL);\n      ExitsInLoops.push_back(ExitBB);\n      if (!ParentL || (ParentL != ExitL && ParentL->contains(ExitL)))\n        ParentL = ExitL;\n    }\n\n  // Recompute the blocks participating in this loop. This may be empty if it\n  // is no longer a loop.\n  auto LoopBlockSet = recomputeLoopBlockSet(L, LI);\n\n  // If we still have a loop, we need to re-set the loop's parent as the exit\n  // block set changing may have moved it within the loop nest. Note that this\n  // can only happen when this loop has a parent as it can only hoist the loop\n  // *up* the nest.\n  if (!LoopBlockSet.empty() && L.getParentLoop() != ParentL) {\n    // Remove this loop's (original) blocks from all of the intervening loops.\n    for (Loop *IL = L.getParentLoop(); IL != ParentL;\n         IL = IL->getParentLoop()) {\n      IL->getBlocksSet().erase(PH);\n      for (auto *BB : L.blocks())\n        IL->getBlocksSet().erase(BB);\n      llvm::erase_if(IL->getBlocksVector(), [&](BasicBlock *BB) {\n        return BB == PH || L.contains(BB);\n      });\n    }\n\n    LI.changeLoopFor(PH, ParentL);\n    L.getParentLoop()->removeChildLoop(&L);\n    if (ParentL)\n      ParentL->addChildLoop(&L);\n    else\n      LI.addTopLevelLoop(&L);\n  }\n\n  // Now we update all the blocks which are no longer within the loop.\n  auto &Blocks = L.getBlocksVector();\n  auto BlocksSplitI =\n      LoopBlockSet.empty()\n          ? Blocks.begin()\n          : std::stable_partition(\n                Blocks.begin(), Blocks.end(),\n                [&](BasicBlock *BB) { return LoopBlockSet.count(BB); });\n\n  // Before we erase the list of unlooped blocks, build a set of them.\n  SmallPtrSet<BasicBlock *, 16> UnloopedBlocks(BlocksSplitI, Blocks.end());\n  if (LoopBlockSet.empty())\n    UnloopedBlocks.insert(PH);\n\n  // Now erase these blocks from the loop.\n  for (auto *BB : make_range(BlocksSplitI, Blocks.end()))\n    L.getBlocksSet().erase(BB);\n  Blocks.erase(BlocksSplitI, Blocks.end());\n\n  // Sort the exits in ascending loop depth, we'll work backwards across these\n  // to process them inside out.\n  llvm::stable_sort(ExitsInLoops, [&](BasicBlock *LHS, BasicBlock *RHS) {\n    return LI.getLoopDepth(LHS) < LI.getLoopDepth(RHS);\n  });\n\n  // We'll build up a set for each exit loop.\n  SmallPtrSet<BasicBlock *, 16> NewExitLoopBlocks;\n  Loop *PrevExitL = L.getParentLoop(); // The deepest possible exit loop.\n\n  auto RemoveUnloopedBlocksFromLoop =\n      [](Loop &L, SmallPtrSetImpl<BasicBlock *> &UnloopedBlocks) {\n        for (auto *BB : UnloopedBlocks)\n          L.getBlocksSet().erase(BB);\n        llvm::erase_if(L.getBlocksVector(), [&](BasicBlock *BB) {\n          return UnloopedBlocks.count(BB);\n        });\n      };\n\n  SmallVector<BasicBlock *, 16> Worklist;\n  while (!UnloopedBlocks.empty() && !ExitsInLoops.empty()) {\n    assert(Worklist.empty() && \"Didn't clear worklist!\");\n    assert(NewExitLoopBlocks.empty() && \"Didn't clear loop set!\");\n\n    // Grab the next exit block, in decreasing loop depth order.\n    BasicBlock *ExitBB = ExitsInLoops.pop_back_val();\n    Loop &ExitL = *LI.getLoopFor(ExitBB);\n    assert(ExitL.contains(&L) && \"Exit loop must contain the inner loop!\");\n\n    // Erase all of the unlooped blocks from the loops between the previous\n    // exit loop and this exit loop. This works because the ExitInLoops list is\n    // sorted in increasing order of loop depth and thus we visit loops in\n    // decreasing order of loop depth.\n    for (; PrevExitL != &ExitL; PrevExitL = PrevExitL->getParentLoop())\n      RemoveUnloopedBlocksFromLoop(*PrevExitL, UnloopedBlocks);\n\n    // Walk the CFG back until we hit the cloned PH adding everything reachable\n    // and in the unlooped set to this exit block's loop.\n    Worklist.push_back(ExitBB);\n    do {\n      BasicBlock *BB = Worklist.pop_back_val();\n      // We can stop recursing at the cloned preheader (if we get there).\n      if (BB == PH)\n        continue;\n\n      for (BasicBlock *PredBB : predecessors(BB)) {\n        // If this pred has already been moved to our set or is part of some\n        // (inner) loop, no update needed.\n        if (!UnloopedBlocks.erase(PredBB)) {\n          assert((NewExitLoopBlocks.count(PredBB) ||\n                  ExitL.contains(LI.getLoopFor(PredBB))) &&\n                 \"Predecessor not in a nested loop (or already visited)!\");\n          continue;\n        }\n\n        // We just insert into the loop set here. We'll add these blocks to the\n        // exit loop after we build up the set in a deterministic order rather\n        // than the predecessor-influenced visit order.\n        bool Inserted = NewExitLoopBlocks.insert(PredBB).second;\n        (void)Inserted;\n        assert(Inserted && \"Should only visit an unlooped block once!\");\n\n        // And recurse through to its predecessors.\n        Worklist.push_back(PredBB);\n      }\n    } while (!Worklist.empty());\n\n    // If blocks in this exit loop were directly part of the original loop (as\n    // opposed to a child loop) update the map to point to this exit loop. This\n    // just updates a map and so the fact that the order is unstable is fine.\n    for (auto *BB : NewExitLoopBlocks)\n      if (Loop *BBL = LI.getLoopFor(BB))\n        if (BBL == &L || !L.contains(BBL))\n          LI.changeLoopFor(BB, &ExitL);\n\n    // We will remove the remaining unlooped blocks from this loop in the next\n    // iteration or below.\n    NewExitLoopBlocks.clear();\n  }\n\n  // Any remaining unlooped blocks are no longer part of any loop unless they\n  // are part of some child loop.\n  for (; PrevExitL; PrevExitL = PrevExitL->getParentLoop())\n    RemoveUnloopedBlocksFromLoop(*PrevExitL, UnloopedBlocks);\n  for (auto *BB : UnloopedBlocks)\n    if (Loop *BBL = LI.getLoopFor(BB))\n      if (BBL == &L || !L.contains(BBL))\n        LI.changeLoopFor(BB, nullptr);\n\n  // Sink all the child loops whose headers are no longer in the loop set to\n  // the parent (or to be top level loops). We reach into the loop and directly\n  // update its subloop vector to make this batch update efficient.\n  auto &SubLoops = L.getSubLoopsVector();\n  auto SubLoopsSplitI =\n      LoopBlockSet.empty()\n          ? SubLoops.begin()\n          : std::stable_partition(\n                SubLoops.begin(), SubLoops.end(), [&](Loop *SubL) {\n                  return LoopBlockSet.count(SubL->getHeader());\n                });\n  for (auto *HoistedL : make_range(SubLoopsSplitI, SubLoops.end())) {\n    HoistedLoops.push_back(HoistedL);\n    HoistedL->setParentLoop(nullptr);\n\n    // To compute the new parent of this hoisted loop we look at where we\n    // placed the preheader above. We can't lookup the header itself because we\n    // retained the mapping from the header to the hoisted loop. But the\n    // preheader and header should have the exact same new parent computed\n    // based on the set of exit blocks from the original loop as the preheader\n    // is a predecessor of the header and so reached in the reverse walk. And\n    // because the loops were all in simplified form the preheader of the\n    // hoisted loop can't be part of some *other* loop.\n    if (auto *NewParentL = LI.getLoopFor(HoistedL->getLoopPreheader()))\n      NewParentL->addChildLoop(HoistedL);\n    else\n      LI.addTopLevelLoop(HoistedL);\n  }\n  SubLoops.erase(SubLoopsSplitI, SubLoops.end());\n\n  // Actually delete the loop if nothing remained within it.\n  if (Blocks.empty()) {\n    assert(SubLoops.empty() &&\n           \"Failed to remove all subloops from the original loop!\");\n    if (Loop *ParentL = L.getParentLoop())\n      ParentL->removeChildLoop(llvm::find(*ParentL, &L));\n    else\n      LI.removeLoop(llvm::find(LI, &L));\n    LI.destroy(&L);\n    return false;\n  }\n\n  return true;\n}\n\n/// Helper to visit a dominator subtree, invoking a callable on each node.\n///\n/// Returning false at any point will stop walking past that node of the tree.\ntemplate <typename CallableT>\nvoid visitDomSubTree(DominatorTree &DT, BasicBlock *BB, CallableT Callable) {\n  SmallVector<DomTreeNode *, 4> DomWorklist;\n  DomWorklist.push_back(DT[BB]);\n#ifndef NDEBUG\n  SmallPtrSet<DomTreeNode *, 4> Visited;\n  Visited.insert(DT[BB]);\n#endif\n  do {\n    DomTreeNode *N = DomWorklist.pop_back_val();\n\n    // Visit this node.\n    if (!Callable(N->getBlock()))\n      continue;\n\n    // Accumulate the child nodes.\n    for (DomTreeNode *ChildN : *N) {\n      assert(Visited.insert(ChildN).second &&\n             \"Cannot visit a node twice when walking a tree!\");\n      DomWorklist.push_back(ChildN);\n    }\n  } while (!DomWorklist.empty());\n}\n\nstatic void unswitchNontrivialInvariants(\n    Loop &L, Instruction &TI, ArrayRef<Value *> Invariants,\n    SmallVectorImpl<BasicBlock *> &ExitBlocks, DominatorTree &DT, LoopInfo &LI,\n    AssumptionCache &AC, function_ref<void(bool, ArrayRef<Loop *>)> UnswitchCB,\n    ScalarEvolution *SE, MemorySSAUpdater *MSSAU) {\n  auto *ParentBB = TI.getParent();\n  BranchInst *BI = dyn_cast<BranchInst>(&TI);\n  SwitchInst *SI = BI ? nullptr : cast<SwitchInst>(&TI);\n\n  // We can only unswitch switches, conditional branches with an invariant\n  // condition, or combining invariant conditions with an instruction.\n  assert((SI || (BI && BI->isConditional())) &&\n         \"Can only unswitch switches and conditional branch!\");\n  bool FullUnswitch = SI || BI->getCondition() == Invariants[0];\n  if (FullUnswitch)\n    assert(Invariants.size() == 1 &&\n           \"Cannot have other invariants with full unswitching!\");\n  else\n    assert(isa<Instruction>(BI->getCondition()) &&\n           \"Partial unswitching requires an instruction as the condition!\");\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  // Constant and BBs tracking the cloned and continuing successor. When we are\n  // unswitching the entire condition, this can just be trivially chosen to\n  // unswitch towards `true`. However, when we are unswitching a set of\n  // invariants combined with `and` or `or`, the combining operation determines\n  // the best direction to unswitch: we want to unswitch the direction that will\n  // collapse the branch.\n  bool Direction = true;\n  int ClonedSucc = 0;\n  if (!FullUnswitch) {\n    if (!match(BI->getCondition(), m_LogicalOr())) {\n      assert(match(BI->getCondition(), m_LogicalAnd()) &&\n             \"Only `or`, `and`, an `select` instructions can combine \"\n             \"invariants being unswitched.\");\n      Direction = false;\n      ClonedSucc = 1;\n    }\n  }\n\n  BasicBlock *RetainedSuccBB =\n      BI ? BI->getSuccessor(1 - ClonedSucc) : SI->getDefaultDest();\n  SmallSetVector<BasicBlock *, 4> UnswitchedSuccBBs;\n  if (BI)\n    UnswitchedSuccBBs.insert(BI->getSuccessor(ClonedSucc));\n  else\n    for (auto Case : SI->cases())\n      if (Case.getCaseSuccessor() != RetainedSuccBB)\n        UnswitchedSuccBBs.insert(Case.getCaseSuccessor());\n\n  assert(!UnswitchedSuccBBs.count(RetainedSuccBB) &&\n         \"Should not unswitch the same successor we are retaining!\");\n\n  // The branch should be in this exact loop. Any inner loop's invariant branch\n  // should be handled by unswitching that inner loop. The caller of this\n  // routine should filter out any candidates that remain (but were skipped for\n  // whatever reason).\n  assert(LI.getLoopFor(ParentBB) == &L && \"Branch in an inner loop!\");\n\n  // Compute the parent loop now before we start hacking on things.\n  Loop *ParentL = L.getParentLoop();\n  // Get blocks in RPO order for MSSA update, before changing the CFG.\n  LoopBlocksRPO LBRPO(&L);\n  if (MSSAU)\n    LBRPO.perform(&LI);\n\n  // Compute the outer-most loop containing one of our exit blocks. This is the\n  // furthest up our loopnest which can be mutated, which we will use below to\n  // update things.\n  Loop *OuterExitL = &L;\n  for (auto *ExitBB : ExitBlocks) {\n    Loop *NewOuterExitL = LI.getLoopFor(ExitBB);\n    if (!NewOuterExitL) {\n      // We exited the entire nest with this block, so we're done.\n      OuterExitL = nullptr;\n      break;\n    }\n    if (NewOuterExitL != OuterExitL && NewOuterExitL->contains(OuterExitL))\n      OuterExitL = NewOuterExitL;\n  }\n\n  // At this point, we're definitely going to unswitch something so invalidate\n  // any cached information in ScalarEvolution for the outer most loop\n  // containing an exit block and all nested loops.\n  if (SE) {\n    if (OuterExitL)\n      SE->forgetLoop(OuterExitL);\n    else\n      SE->forgetTopmostLoop(&L);\n  }\n\n  // If the edge from this terminator to a successor dominates that successor,\n  // store a map from each block in its dominator subtree to it. This lets us\n  // tell when cloning for a particular successor if a block is dominated by\n  // some *other* successor with a single data structure. We use this to\n  // significantly reduce cloning.\n  SmallDenseMap<BasicBlock *, BasicBlock *, 16> DominatingSucc;\n  for (auto *SuccBB : llvm::concat<BasicBlock *const>(\n           makeArrayRef(RetainedSuccBB), UnswitchedSuccBBs))\n    if (SuccBB->getUniquePredecessor() ||\n        llvm::all_of(predecessors(SuccBB), [&](BasicBlock *PredBB) {\n          return PredBB == ParentBB || DT.dominates(SuccBB, PredBB);\n        }))\n      visitDomSubTree(DT, SuccBB, [&](BasicBlock *BB) {\n        DominatingSucc[BB] = SuccBB;\n        return true;\n      });\n\n  // Split the preheader, so that we know that there is a safe place to insert\n  // the conditional branch. We will change the preheader to have a conditional\n  // branch on LoopCond. The original preheader will become the split point\n  // between the unswitched versions, and we will have a new preheader for the\n  // original loop.\n  BasicBlock *SplitBB = L.getLoopPreheader();\n  BasicBlock *LoopPH = SplitEdge(SplitBB, L.getHeader(), &DT, &LI, MSSAU);\n\n  // Keep track of the dominator tree updates needed.\n  SmallVector<DominatorTree::UpdateType, 4> DTUpdates;\n\n  // Clone the loop for each unswitched successor.\n  SmallVector<std::unique_ptr<ValueToValueMapTy>, 4> VMaps;\n  VMaps.reserve(UnswitchedSuccBBs.size());\n  SmallDenseMap<BasicBlock *, BasicBlock *, 4> ClonedPHs;\n  for (auto *SuccBB : UnswitchedSuccBBs) {\n    VMaps.emplace_back(new ValueToValueMapTy());\n    ClonedPHs[SuccBB] = buildClonedLoopBlocks(\n        L, LoopPH, SplitBB, ExitBlocks, ParentBB, SuccBB, RetainedSuccBB,\n        DominatingSucc, *VMaps.back(), DTUpdates, AC, DT, LI, MSSAU);\n  }\n\n  // Drop metadata if we may break its semantics by moving this instr into the\n  // split block.\n  if (TI.getMetadata(LLVMContext::MD_make_implicit)) {\n    if (DropNonTrivialImplicitNullChecks)\n      // Do not spend time trying to understand if we can keep it, just drop it\n      // to save compile time.\n      TI.setMetadata(LLVMContext::MD_make_implicit, nullptr);\n    else {\n      // It is only legal to preserve make.implicit metadata if we are\n      // guaranteed no reach implicit null check after following this branch.\n      ICFLoopSafetyInfo SafetyInfo;\n      SafetyInfo.computeLoopSafetyInfo(&L);\n      if (!SafetyInfo.isGuaranteedToExecute(TI, &DT, &L))\n        TI.setMetadata(LLVMContext::MD_make_implicit, nullptr);\n    }\n  }\n\n  // The stitching of the branched code back together depends on whether we're\n  // doing full unswitching or not with the exception that we always want to\n  // nuke the initial terminator placed in the split block.\n  SplitBB->getTerminator()->eraseFromParent();\n  if (FullUnswitch) {\n    // Splice the terminator from the original loop and rewrite its\n    // successors.\n    SplitBB->getInstList().splice(SplitBB->end(), ParentBB->getInstList(), TI);\n\n    // Keep a clone of the terminator for MSSA updates.\n    Instruction *NewTI = TI.clone();\n    ParentBB->getInstList().push_back(NewTI);\n\n    // First wire up the moved terminator to the preheaders.\n    if (BI) {\n      BasicBlock *ClonedPH = ClonedPHs.begin()->second;\n      BI->setSuccessor(ClonedSucc, ClonedPH);\n      BI->setSuccessor(1 - ClonedSucc, LoopPH);\n      DTUpdates.push_back({DominatorTree::Insert, SplitBB, ClonedPH});\n    } else {\n      assert(SI && \"Must either be a branch or switch!\");\n\n      // Walk the cases and directly update their successors.\n      assert(SI->getDefaultDest() == RetainedSuccBB &&\n             \"Not retaining default successor!\");\n      SI->setDefaultDest(LoopPH);\n      for (auto &Case : SI->cases())\n        if (Case.getCaseSuccessor() == RetainedSuccBB)\n          Case.setSuccessor(LoopPH);\n        else\n          Case.setSuccessor(ClonedPHs.find(Case.getCaseSuccessor())->second);\n\n      // We need to use the set to populate domtree updates as even when there\n      // are multiple cases pointing at the same successor we only want to\n      // remove and insert one edge in the domtree.\n      for (BasicBlock *SuccBB : UnswitchedSuccBBs)\n        DTUpdates.push_back(\n            {DominatorTree::Insert, SplitBB, ClonedPHs.find(SuccBB)->second});\n    }\n\n    if (MSSAU) {\n      DT.applyUpdates(DTUpdates);\n      DTUpdates.clear();\n\n      // Remove all but one edge to the retained block and all unswitched\n      // blocks. This is to avoid having duplicate entries in the cloned Phis,\n      // when we know we only keep a single edge for each case.\n      MSSAU->removeDuplicatePhiEdgesBetween(ParentBB, RetainedSuccBB);\n      for (BasicBlock *SuccBB : UnswitchedSuccBBs)\n        MSSAU->removeDuplicatePhiEdgesBetween(ParentBB, SuccBB);\n\n      for (auto &VMap : VMaps)\n        MSSAU->updateForClonedLoop(LBRPO, ExitBlocks, *VMap,\n                                   /*IgnoreIncomingWithNoClones=*/true);\n      MSSAU->updateExitBlocksForClonedLoop(ExitBlocks, VMaps, DT);\n\n      // Remove all edges to unswitched blocks.\n      for (BasicBlock *SuccBB : UnswitchedSuccBBs)\n        MSSAU->removeEdge(ParentBB, SuccBB);\n    }\n\n    // Now unhook the successor relationship as we'll be replacing\n    // the terminator with a direct branch. This is much simpler for branches\n    // than switches so we handle those first.\n    if (BI) {\n      // Remove the parent as a predecessor of the unswitched successor.\n      assert(UnswitchedSuccBBs.size() == 1 &&\n             \"Only one possible unswitched block for a branch!\");\n      BasicBlock *UnswitchedSuccBB = *UnswitchedSuccBBs.begin();\n      UnswitchedSuccBB->removePredecessor(ParentBB,\n                                          /*KeepOneInputPHIs*/ true);\n      DTUpdates.push_back({DominatorTree::Delete, ParentBB, UnswitchedSuccBB});\n    } else {\n      // Note that we actually want to remove the parent block as a predecessor\n      // of *every* case successor. The case successor is either unswitched,\n      // completely eliminating an edge from the parent to that successor, or it\n      // is a duplicate edge to the retained successor as the retained successor\n      // is always the default successor and as we'll replace this with a direct\n      // branch we no longer need the duplicate entries in the PHI nodes.\n      SwitchInst *NewSI = cast<SwitchInst>(NewTI);\n      assert(NewSI->getDefaultDest() == RetainedSuccBB &&\n             \"Not retaining default successor!\");\n      for (auto &Case : NewSI->cases())\n        Case.getCaseSuccessor()->removePredecessor(\n            ParentBB,\n            /*KeepOneInputPHIs*/ true);\n\n      // We need to use the set to populate domtree updates as even when there\n      // are multiple cases pointing at the same successor we only want to\n      // remove and insert one edge in the domtree.\n      for (BasicBlock *SuccBB : UnswitchedSuccBBs)\n        DTUpdates.push_back({DominatorTree::Delete, ParentBB, SuccBB});\n    }\n\n    // After MSSAU update, remove the cloned terminator instruction NewTI.\n    ParentBB->getTerminator()->eraseFromParent();\n\n    // Create a new unconditional branch to the continuing block (as opposed to\n    // the one cloned).\n    BranchInst::Create(RetainedSuccBB, ParentBB);\n  } else {\n    assert(BI && \"Only branches have partial unswitching.\");\n    assert(UnswitchedSuccBBs.size() == 1 &&\n           \"Only one possible unswitched block for a branch!\");\n    BasicBlock *ClonedPH = ClonedPHs.begin()->second;\n    // When doing a partial unswitch, we have to do a bit more work to build up\n    // the branch in the split block.\n    buildPartialUnswitchConditionalBranch(*SplitBB, Invariants, Direction,\n                                          *ClonedPH, *LoopPH);\n    DTUpdates.push_back({DominatorTree::Insert, SplitBB, ClonedPH});\n\n    if (MSSAU) {\n      DT.applyUpdates(DTUpdates);\n      DTUpdates.clear();\n\n      // Perform MSSA cloning updates.\n      for (auto &VMap : VMaps)\n        MSSAU->updateForClonedLoop(LBRPO, ExitBlocks, *VMap,\n                                   /*IgnoreIncomingWithNoClones=*/true);\n      MSSAU->updateExitBlocksForClonedLoop(ExitBlocks, VMaps, DT);\n    }\n  }\n\n  // Apply the updates accumulated above to get an up-to-date dominator tree.\n  DT.applyUpdates(DTUpdates);\n\n  // Now that we have an accurate dominator tree, first delete the dead cloned\n  // blocks so that we can accurately build any cloned loops. It is important to\n  // not delete the blocks from the original loop yet because we still want to\n  // reference the original loop to understand the cloned loop's structure.\n  deleteDeadClonedBlocks(L, ExitBlocks, VMaps, DT, MSSAU);\n\n  // Build the cloned loop structure itself. This may be substantially\n  // different from the original structure due to the simplified CFG. This also\n  // handles inserting all the cloned blocks into the correct loops.\n  SmallVector<Loop *, 4> NonChildClonedLoops;\n  for (std::unique_ptr<ValueToValueMapTy> &VMap : VMaps)\n    buildClonedLoops(L, ExitBlocks, *VMap, LI, NonChildClonedLoops);\n\n  // Now that our cloned loops have been built, we can update the original loop.\n  // First we delete the dead blocks from it and then we rebuild the loop\n  // structure taking these deletions into account.\n  deleteDeadBlocksFromLoop(L, ExitBlocks, DT, LI, MSSAU);\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  SmallVector<Loop *, 4> HoistedLoops;\n  bool IsStillLoop = rebuildLoopAfterUnswitch(L, ExitBlocks, LI, HoistedLoops);\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  // This transformation has a high risk of corrupting the dominator tree, and\n  // the below steps to rebuild loop structures will result in hard to debug\n  // errors in that case so verify that the dominator tree is sane first.\n  // FIXME: Remove this when the bugs stop showing up and rely on existing\n  // verification steps.\n  assert(DT.verify(DominatorTree::VerificationLevel::Fast));\n\n  if (BI) {\n    // If we unswitched a branch which collapses the condition to a known\n    // constant we want to replace all the uses of the invariants within both\n    // the original and cloned blocks. We do this here so that we can use the\n    // now updated dominator tree to identify which side the users are on.\n    assert(UnswitchedSuccBBs.size() == 1 &&\n           \"Only one possible unswitched block for a branch!\");\n    BasicBlock *ClonedPH = ClonedPHs.begin()->second;\n\n    // When considering multiple partially-unswitched invariants\n    // we cant just go replace them with constants in both branches.\n    //\n    // For 'AND' we infer that true branch (\"continue\") means true\n    // for each invariant operand.\n    // For 'OR' we can infer that false branch (\"continue\") means false\n    // for each invariant operand.\n    // So it happens that for multiple-partial case we dont replace\n    // in the unswitched branch.\n    bool ReplaceUnswitched = FullUnswitch || (Invariants.size() == 1);\n\n    ConstantInt *UnswitchedReplacement =\n        Direction ? ConstantInt::getTrue(BI->getContext())\n                  : ConstantInt::getFalse(BI->getContext());\n    ConstantInt *ContinueReplacement =\n        Direction ? ConstantInt::getFalse(BI->getContext())\n                  : ConstantInt::getTrue(BI->getContext());\n    for (Value *Invariant : Invariants)\n      // Use make_early_inc_range here as set invalidates the iterator.\n      for (Use &U : llvm::make_early_inc_range(Invariant->uses())) {\n        Instruction *UserI = dyn_cast<Instruction>(U.getUser());\n        if (!UserI)\n          continue;\n\n        // Replace it with the 'continue' side if in the main loop body, and the\n        // unswitched if in the cloned blocks.\n        if (DT.dominates(LoopPH, UserI->getParent()))\n          U.set(ContinueReplacement);\n        else if (ReplaceUnswitched &&\n                 DT.dominates(ClonedPH, UserI->getParent()))\n          U.set(UnswitchedReplacement);\n      }\n  }\n\n  // We can change which blocks are exit blocks of all the cloned sibling\n  // loops, the current loop, and any parent loops which shared exit blocks\n  // with the current loop. As a consequence, we need to re-form LCSSA for\n  // them. But we shouldn't need to re-form LCSSA for any child loops.\n  // FIXME: This could be made more efficient by tracking which exit blocks are\n  // new, and focusing on them, but that isn't likely to be necessary.\n  //\n  // In order to reasonably rebuild LCSSA we need to walk inside-out across the\n  // loop nest and update every loop that could have had its exits changed. We\n  // also need to cover any intervening loops. We add all of these loops to\n  // a list and sort them by loop depth to achieve this without updating\n  // unnecessary loops.\n  auto UpdateLoop = [&](Loop &UpdateL) {\n#ifndef NDEBUG\n    UpdateL.verifyLoop();\n    for (Loop *ChildL : UpdateL) {\n      ChildL->verifyLoop();\n      assert(ChildL->isRecursivelyLCSSAForm(DT, LI) &&\n             \"Perturbed a child loop's LCSSA form!\");\n    }\n#endif\n    // First build LCSSA for this loop so that we can preserve it when\n    // forming dedicated exits. We don't want to perturb some other loop's\n    // LCSSA while doing that CFG edit.\n    formLCSSA(UpdateL, DT, &LI, SE);\n\n    // For loops reached by this loop's original exit blocks we may\n    // introduced new, non-dedicated exits. At least try to re-form dedicated\n    // exits for these loops. This may fail if they couldn't have dedicated\n    // exits to start with.\n    formDedicatedExitBlocks(&UpdateL, &DT, &LI, MSSAU, /*PreserveLCSSA*/ true);\n  };\n\n  // For non-child cloned loops and hoisted loops, we just need to update LCSSA\n  // and we can do it in any order as they don't nest relative to each other.\n  //\n  // Also check if any of the loops we have updated have become top-level loops\n  // as that will necessitate widening the outer loop scope.\n  for (Loop *UpdatedL :\n       llvm::concat<Loop *>(NonChildClonedLoops, HoistedLoops)) {\n    UpdateLoop(*UpdatedL);\n    if (UpdatedL->isOutermost())\n      OuterExitL = nullptr;\n  }\n  if (IsStillLoop) {\n    UpdateLoop(L);\n    if (L.isOutermost())\n      OuterExitL = nullptr;\n  }\n\n  // If the original loop had exit blocks, walk up through the outer most loop\n  // of those exit blocks to update LCSSA and form updated dedicated exits.\n  if (OuterExitL != &L)\n    for (Loop *OuterL = ParentL; OuterL != OuterExitL;\n         OuterL = OuterL->getParentLoop())\n      UpdateLoop(*OuterL);\n\n#ifndef NDEBUG\n  // Verify the entire loop structure to catch any incorrect updates before we\n  // progress in the pass pipeline.\n  LI.verify(DT);\n#endif\n\n  // Now that we've unswitched something, make callbacks to report the changes.\n  // For that we need to merge together the updated loops and the cloned loops\n  // and check whether the original loop survived.\n  SmallVector<Loop *, 4> SibLoops;\n  for (Loop *UpdatedL : llvm::concat<Loop *>(NonChildClonedLoops, HoistedLoops))\n    if (UpdatedL->getParentLoop() == ParentL)\n      SibLoops.push_back(UpdatedL);\n  UnswitchCB(IsStillLoop, SibLoops);\n\n  if (MSSAU && VerifyMemorySSA)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  if (BI)\n    ++NumBranches;\n  else\n    ++NumSwitches;\n}\n\n/// Recursively compute the cost of a dominator subtree based on the per-block\n/// cost map provided.\n///\n/// The recursive computation is memozied into the provided DT-indexed cost map\n/// to allow querying it for most nodes in the domtree without it becoming\n/// quadratic.\nstatic InstructionCost computeDomSubtreeCost(\n    DomTreeNode &N,\n    const SmallDenseMap<BasicBlock *, InstructionCost, 4> &BBCostMap,\n    SmallDenseMap<DomTreeNode *, InstructionCost, 4> &DTCostMap) {\n  // Don't accumulate cost (or recurse through) blocks not in our block cost\n  // map and thus not part of the duplication cost being considered.\n  auto BBCostIt = BBCostMap.find(N.getBlock());\n  if (BBCostIt == BBCostMap.end())\n    return 0;\n\n  // Lookup this node to see if we already computed its cost.\n  auto DTCostIt = DTCostMap.find(&N);\n  if (DTCostIt != DTCostMap.end())\n    return DTCostIt->second;\n\n  // If not, we have to compute it. We can't use insert above and update\n  // because computing the cost may insert more things into the map.\n  InstructionCost Cost = std::accumulate(\n      N.begin(), N.end(), BBCostIt->second,\n      [&](InstructionCost Sum, DomTreeNode *ChildN) -> InstructionCost {\n        return Sum + computeDomSubtreeCost(*ChildN, BBCostMap, DTCostMap);\n      });\n  bool Inserted = DTCostMap.insert({&N, Cost}).second;\n  (void)Inserted;\n  assert(Inserted && \"Should not insert a node while visiting children!\");\n  return Cost;\n}\n\n/// Turns a llvm.experimental.guard intrinsic into implicit control flow branch,\n/// making the following replacement:\n///\n///   --code before guard--\n///   call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ \"deopt\"() ]\n///   --code after guard--\n///\n/// into\n///\n///   --code before guard--\n///   br i1 %cond, label %guarded, label %deopt\n///\n/// guarded:\n///   --code after guard--\n///\n/// deopt:\n///   call void (i1, ...) @llvm.experimental.guard(i1 false) [ \"deopt\"() ]\n///   unreachable\n///\n/// It also makes all relevant DT and LI updates, so that all structures are in\n/// valid state after this transform.\nstatic BranchInst *\nturnGuardIntoBranch(IntrinsicInst *GI, Loop &L,\n                    SmallVectorImpl<BasicBlock *> &ExitBlocks,\n                    DominatorTree &DT, LoopInfo &LI, MemorySSAUpdater *MSSAU) {\n  SmallVector<DominatorTree::UpdateType, 4> DTUpdates;\n  LLVM_DEBUG(dbgs() << \"Turning \" << *GI << \" into a branch.\\n\");\n  BasicBlock *CheckBB = GI->getParent();\n\n  if (MSSAU && VerifyMemorySSA)\n     MSSAU->getMemorySSA()->verifyMemorySSA();\n\n  // Remove all CheckBB's successors from DomTree. A block can be seen among\n  // successors more than once, but for DomTree it should be added only once.\n  SmallPtrSet<BasicBlock *, 4> Successors;\n  for (auto *Succ : successors(CheckBB))\n    if (Successors.insert(Succ).second)\n      DTUpdates.push_back({DominatorTree::Delete, CheckBB, Succ});\n\n  Instruction *DeoptBlockTerm =\n      SplitBlockAndInsertIfThen(GI->getArgOperand(0), GI, true);\n  BranchInst *CheckBI = cast<BranchInst>(CheckBB->getTerminator());\n  // SplitBlockAndInsertIfThen inserts control flow that branches to\n  // DeoptBlockTerm if the condition is true.  We want the opposite.\n  CheckBI->swapSuccessors();\n\n  BasicBlock *GuardedBlock = CheckBI->getSuccessor(0);\n  GuardedBlock->setName(\"guarded\");\n  CheckBI->getSuccessor(1)->setName(\"deopt\");\n  BasicBlock *DeoptBlock = CheckBI->getSuccessor(1);\n\n  // We now have a new exit block.\n  ExitBlocks.push_back(CheckBI->getSuccessor(1));\n\n  if (MSSAU)\n    MSSAU->moveAllAfterSpliceBlocks(CheckBB, GuardedBlock, GI);\n\n  GI->moveBefore(DeoptBlockTerm);\n  GI->setArgOperand(0, ConstantInt::getFalse(GI->getContext()));\n\n  // Add new successors of CheckBB into DomTree.\n  for (auto *Succ : successors(CheckBB))\n    DTUpdates.push_back({DominatorTree::Insert, CheckBB, Succ});\n\n  // Now the blocks that used to be CheckBB's successors are GuardedBlock's\n  // successors.\n  for (auto *Succ : Successors)\n    DTUpdates.push_back({DominatorTree::Insert, GuardedBlock, Succ});\n\n  // Make proper changes to DT.\n  DT.applyUpdates(DTUpdates);\n  // Inform LI of a new loop block.\n  L.addBasicBlockToLoop(GuardedBlock, LI);\n\n  if (MSSAU) {\n    MemoryDef *MD = cast<MemoryDef>(MSSAU->getMemorySSA()->getMemoryAccess(GI));\n    MSSAU->moveToPlace(MD, DeoptBlock, MemorySSA::BeforeTerminator);\n    if (VerifyMemorySSA)\n      MSSAU->getMemorySSA()->verifyMemorySSA();\n  }\n\n  ++NumGuards;\n  return CheckBI;\n}\n\n/// Cost multiplier is a way to limit potentially exponential behavior\n/// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch\n/// candidates available. Also accounting for the number of \"sibling\" loops with\n/// the idea to account for previous unswitches that already happened on this\n/// cluster of loops. There was an attempt to keep this formula simple,\n/// just enough to limit the worst case behavior. Even if it is not that simple\n/// now it is still not an attempt to provide a detailed heuristic size\n/// prediction.\n///\n/// TODO: Make a proper accounting of \"explosion\" effect for all kinds of\n/// unswitch candidates, making adequate predictions instead of wild guesses.\n/// That requires knowing not just the number of \"remaining\" candidates but\n/// also costs of unswitching for each of these candidates.\nstatic int CalculateUnswitchCostMultiplier(\n    Instruction &TI, Loop &L, LoopInfo &LI, DominatorTree &DT,\n    ArrayRef<std::pair<Instruction *, TinyPtrVector<Value *>>>\n        UnswitchCandidates) {\n\n  // Guards and other exiting conditions do not contribute to exponential\n  // explosion as soon as they dominate the latch (otherwise there might be\n  // another path to the latch remaining that does not allow to eliminate the\n  // loop copy on unswitch).\n  BasicBlock *Latch = L.getLoopLatch();\n  BasicBlock *CondBlock = TI.getParent();\n  if (DT.dominates(CondBlock, Latch) &&\n      (isGuard(&TI) ||\n       llvm::count_if(successors(&TI), [&L](BasicBlock *SuccBB) {\n         return L.contains(SuccBB);\n       }) <= 1)) {\n    NumCostMultiplierSkipped++;\n    return 1;\n  }\n\n  auto *ParentL = L.getParentLoop();\n  int SiblingsCount = (ParentL ? ParentL->getSubLoopsVector().size()\n                               : std::distance(LI.begin(), LI.end()));\n  // Count amount of clones that all the candidates might cause during\n  // unswitching. Branch/guard counts as 1, switch counts as log2 of its cases.\n  int UnswitchedClones = 0;\n  for (auto Candidate : UnswitchCandidates) {\n    Instruction *CI = Candidate.first;\n    BasicBlock *CondBlock = CI->getParent();\n    bool SkipExitingSuccessors = DT.dominates(CondBlock, Latch);\n    if (isGuard(CI)) {\n      if (!SkipExitingSuccessors)\n        UnswitchedClones++;\n      continue;\n    }\n    int NonExitingSuccessors = llvm::count_if(\n        successors(CondBlock), [SkipExitingSuccessors, &L](BasicBlock *SuccBB) {\n          return !SkipExitingSuccessors || L.contains(SuccBB);\n        });\n    UnswitchedClones += Log2_32(NonExitingSuccessors);\n  }\n\n  // Ignore up to the \"unscaled candidates\" number of unswitch candidates\n  // when calculating the power-of-two scaling of the cost. The main idea\n  // with this control is to allow a small number of unswitches to happen\n  // and rely more on siblings multiplier (see below) when the number\n  // of candidates is small.\n  unsigned ClonesPower =\n      std::max(UnswitchedClones - (int)UnswitchNumInitialUnscaledCandidates, 0);\n\n  // Allowing top-level loops to spread a bit more than nested ones.\n  int SiblingsMultiplier =\n      std::max((ParentL ? SiblingsCount\n                        : SiblingsCount / (int)UnswitchSiblingsToplevelDiv),\n               1);\n  // Compute the cost multiplier in a way that won't overflow by saturating\n  // at an upper bound.\n  int CostMultiplier;\n  if (ClonesPower > Log2_32(UnswitchThreshold) ||\n      SiblingsMultiplier > UnswitchThreshold)\n    CostMultiplier = UnswitchThreshold;\n  else\n    CostMultiplier = std::min(SiblingsMultiplier * (1 << ClonesPower),\n                              (int)UnswitchThreshold);\n\n  LLVM_DEBUG(dbgs() << \"  Computed multiplier  \" << CostMultiplier\n                    << \" (siblings \" << SiblingsMultiplier << \" * clones \"\n                    << (1 << ClonesPower) << \")\"\n                    << \" for unswitch candidate: \" << TI << \"\\n\");\n  return CostMultiplier;\n}\n\nstatic bool\nunswitchBestCondition(Loop &L, DominatorTree &DT, LoopInfo &LI,\n                      AssumptionCache &AC, TargetTransformInfo &TTI,\n                      function_ref<void(bool, ArrayRef<Loop *>)> UnswitchCB,\n                      ScalarEvolution *SE, MemorySSAUpdater *MSSAU) {\n  // Collect all invariant conditions within this loop (as opposed to an inner\n  // loop which would be handled when visiting that inner loop).\n  SmallVector<std::pair<Instruction *, TinyPtrVector<Value *>>, 4>\n      UnswitchCandidates;\n\n  // Whether or not we should also collect guards in the loop.\n  bool CollectGuards = false;\n  if (UnswitchGuards) {\n    auto *GuardDecl = L.getHeader()->getParent()->getParent()->getFunction(\n        Intrinsic::getName(Intrinsic::experimental_guard));\n    if (GuardDecl && !GuardDecl->use_empty())\n      CollectGuards = true;\n  }\n\n  for (auto *BB : L.blocks()) {\n    if (LI.getLoopFor(BB) != &L)\n      continue;\n\n    if (CollectGuards)\n      for (auto &I : *BB)\n        if (isGuard(&I)) {\n          auto *Cond = cast<IntrinsicInst>(&I)->getArgOperand(0);\n          // TODO: Support AND, OR conditions and partial unswitching.\n          if (!isa<Constant>(Cond) && L.isLoopInvariant(Cond))\n            UnswitchCandidates.push_back({&I, {Cond}});\n        }\n\n    if (auto *SI = dyn_cast<SwitchInst>(BB->getTerminator())) {\n      // We can only consider fully loop-invariant switch conditions as we need\n      // to completely eliminate the switch after unswitching.\n      if (!isa<Constant>(SI->getCondition()) &&\n          L.isLoopInvariant(SI->getCondition()) && !BB->getUniqueSuccessor())\n        UnswitchCandidates.push_back({SI, {SI->getCondition()}});\n      continue;\n    }\n\n    auto *BI = dyn_cast<BranchInst>(BB->getTerminator());\n    if (!BI || !BI->isConditional() || isa<Constant>(BI->getCondition()) ||\n        BI->getSuccessor(0) == BI->getSuccessor(1))\n      continue;\n\n    if (L.isLoopInvariant(BI->getCondition())) {\n      UnswitchCandidates.push_back({BI, {BI->getCondition()}});\n      continue;\n    }\n\n    Instruction &CondI = *cast<Instruction>(BI->getCondition());\n    if (!match(&CondI, m_CombineOr(m_LogicalAnd(), m_LogicalOr())))\n      continue;\n\n    TinyPtrVector<Value *> Invariants =\n        collectHomogenousInstGraphLoopInvariants(L, CondI, LI);\n    if (Invariants.empty())\n      continue;\n\n    UnswitchCandidates.push_back({BI, std::move(Invariants)});\n  }\n\n  // If we didn't find any candidates, we're done.\n  if (UnswitchCandidates.empty())\n    return false;\n\n  // Check if there are irreducible CFG cycles in this loop. If so, we cannot\n  // easily unswitch non-trivial edges out of the loop. Doing so might turn the\n  // irreducible control flow into reducible control flow and introduce new\n  // loops \"out of thin air\". If we ever discover important use cases for doing\n  // this, we can add support to loop unswitch, but it is a lot of complexity\n  // for what seems little or no real world benefit.\n  LoopBlocksRPO RPOT(&L);\n  RPOT.perform(&LI);\n  if (containsIrreducibleCFG<const BasicBlock *>(RPOT, LI))\n    return false;\n\n  SmallVector<BasicBlock *, 4> ExitBlocks;\n  L.getUniqueExitBlocks(ExitBlocks);\n\n  // We cannot unswitch if exit blocks contain a cleanuppad instruction as we\n  // don't know how to split those exit blocks.\n  // FIXME: We should teach SplitBlock to handle this and remove this\n  // restriction.\n  for (auto *ExitBB : ExitBlocks)\n    if (isa<CleanupPadInst>(ExitBB->getFirstNonPHI())) {\n      dbgs() << \"Cannot unswitch because of cleanuppad in exit block\\n\";\n      return false;\n    }\n\n  LLVM_DEBUG(\n      dbgs() << \"Considering \" << UnswitchCandidates.size()\n             << \" non-trivial loop invariant conditions for unswitching.\\n\");\n\n  // Given that unswitching these terminators will require duplicating parts of\n  // the loop, so we need to be able to model that cost. Compute the ephemeral\n  // values and set up a data structure to hold per-BB costs. We cache each\n  // block's cost so that we don't recompute this when considering different\n  // subsets of the loop for duplication during unswitching.\n  SmallPtrSet<const Value *, 4> EphValues;\n  CodeMetrics::collectEphemeralValues(&L, &AC, EphValues);\n  SmallDenseMap<BasicBlock *, InstructionCost, 4> BBCostMap;\n\n  // Compute the cost of each block, as well as the total loop cost. Also, bail\n  // out if we see instructions which are incompatible with loop unswitching\n  // (convergent, noduplicate, or cross-basic-block tokens).\n  // FIXME: We might be able to safely handle some of these in non-duplicated\n  // regions.\n  TargetTransformInfo::TargetCostKind CostKind =\n      L.getHeader()->getParent()->hasMinSize()\n      ? TargetTransformInfo::TCK_CodeSize\n      : TargetTransformInfo::TCK_SizeAndLatency;\n  InstructionCost LoopCost = 0;\n  for (auto *BB : L.blocks()) {\n    InstructionCost Cost = 0;\n    for (auto &I : *BB) {\n      if (EphValues.count(&I))\n        continue;\n\n      if (I.getType()->isTokenTy() && I.isUsedOutsideOfBlock(BB))\n        return false;\n      if (auto *CB = dyn_cast<CallBase>(&I))\n        if (CB->isConvergent() || CB->cannotDuplicate())\n          return false;\n\n      Cost += TTI.getUserCost(&I, CostKind);\n    }\n    assert(Cost >= 0 && \"Must not have negative costs!\");\n    LoopCost += Cost;\n    assert(LoopCost >= 0 && \"Must not have negative loop costs!\");\n    BBCostMap[BB] = Cost;\n  }\n  LLVM_DEBUG(dbgs() << \"  Total loop cost: \" << LoopCost << \"\\n\");\n\n  // Now we find the best candidate by searching for the one with the following\n  // properties in order:\n  //\n  // 1) An unswitching cost below the threshold\n  // 2) The smallest number of duplicated unswitch candidates (to avoid\n  //    creating redundant subsequent unswitching)\n  // 3) The smallest cost after unswitching.\n  //\n  // We prioritize reducing fanout of unswitch candidates provided the cost\n  // remains below the threshold because this has a multiplicative effect.\n  //\n  // This requires memoizing each dominator subtree to avoid redundant work.\n  //\n  // FIXME: Need to actually do the number of candidates part above.\n  SmallDenseMap<DomTreeNode *, InstructionCost, 4> DTCostMap;\n  // Given a terminator which might be unswitched, computes the non-duplicated\n  // cost for that terminator.\n  auto ComputeUnswitchedCost = [&](Instruction &TI,\n                                   bool FullUnswitch) -> InstructionCost {\n    BasicBlock &BB = *TI.getParent();\n    SmallPtrSet<BasicBlock *, 4> Visited;\n\n    InstructionCost Cost = 0;\n    for (BasicBlock *SuccBB : successors(&BB)) {\n      // Don't count successors more than once.\n      if (!Visited.insert(SuccBB).second)\n        continue;\n\n      // If this is a partial unswitch candidate, then it must be a conditional\n      // branch with a condition of either `or`, `and`, or their corresponding\n      // select forms. In that case, one of the successors is necessarily\n      // duplicated, so don't even try to remove its cost.\n      if (!FullUnswitch) {\n        auto &BI = cast<BranchInst>(TI);\n        if (match(BI.getCondition(), m_LogicalAnd())) {\n          if (SuccBB == BI.getSuccessor(1))\n            continue;\n        } else {\n          assert(match(BI.getCondition(), m_LogicalOr()) &&\n                 \"Only `and` and `or` conditions can result in a partial \"\n                 \"unswitch!\");\n          if (SuccBB == BI.getSuccessor(0))\n            continue;\n        }\n      }\n\n      // This successor's domtree will not need to be duplicated after\n      // unswitching if the edge to the successor dominates it (and thus the\n      // entire tree). This essentially means there is no other path into this\n      // subtree and so it will end up live in only one clone of the loop.\n      if (SuccBB->getUniquePredecessor() ||\n          llvm::all_of(predecessors(SuccBB), [&](BasicBlock *PredBB) {\n            return PredBB == &BB || DT.dominates(SuccBB, PredBB);\n          })) {\n        Cost += computeDomSubtreeCost(*DT[SuccBB], BBCostMap, DTCostMap);\n        assert(Cost <= LoopCost &&\n               \"Non-duplicated cost should never exceed total loop cost!\");\n      }\n    }\n\n    // Now scale the cost by the number of unique successors minus one. We\n    // subtract one because there is already at least one copy of the entire\n    // loop. This is computing the new cost of unswitching a condition.\n    // Note that guards always have 2 unique successors that are implicit and\n    // will be materialized if we decide to unswitch it.\n    int SuccessorsCount = isGuard(&TI) ? 2 : Visited.size();\n    assert(SuccessorsCount > 1 &&\n           \"Cannot unswitch a condition without multiple distinct successors!\");\n    return (LoopCost - Cost) * (SuccessorsCount - 1);\n  };\n  Instruction *BestUnswitchTI = nullptr;\n  InstructionCost BestUnswitchCost = 0;\n  ArrayRef<Value *> BestUnswitchInvariants;\n  for (auto &TerminatorAndInvariants : UnswitchCandidates) {\n    Instruction &TI = *TerminatorAndInvariants.first;\n    ArrayRef<Value *> Invariants = TerminatorAndInvariants.second;\n    BranchInst *BI = dyn_cast<BranchInst>(&TI);\n    InstructionCost CandidateCost = ComputeUnswitchedCost(\n        TI, /*FullUnswitch*/ !BI || (Invariants.size() == 1 &&\n                                     Invariants[0] == BI->getCondition()));\n    // Calculate cost multiplier which is a tool to limit potentially\n    // exponential behavior of loop-unswitch.\n    if (EnableUnswitchCostMultiplier) {\n      int CostMultiplier =\n          CalculateUnswitchCostMultiplier(TI, L, LI, DT, UnswitchCandidates);\n      assert(\n          (CostMultiplier > 0 && CostMultiplier <= UnswitchThreshold) &&\n          \"cost multiplier needs to be in the range of 1..UnswitchThreshold\");\n      CandidateCost *= CostMultiplier;\n      LLVM_DEBUG(dbgs() << \"  Computed cost of \" << CandidateCost\n                        << \" (multiplier: \" << CostMultiplier << \")\"\n                        << \" for unswitch candidate: \" << TI << \"\\n\");\n    } else {\n      LLVM_DEBUG(dbgs() << \"  Computed cost of \" << CandidateCost\n                        << \" for unswitch candidate: \" << TI << \"\\n\");\n    }\n\n    if (!BestUnswitchTI || CandidateCost < BestUnswitchCost) {\n      BestUnswitchTI = &TI;\n      BestUnswitchCost = CandidateCost;\n      BestUnswitchInvariants = Invariants;\n    }\n  }\n  assert(BestUnswitchTI && \"Failed to find loop unswitch candidate\");\n\n  if (BestUnswitchCost >= UnswitchThreshold) {\n    LLVM_DEBUG(dbgs() << \"Cannot unswitch, lowest cost found: \"\n                      << BestUnswitchCost << \"\\n\");\n    return false;\n  }\n\n  // If the best candidate is a guard, turn it into a branch.\n  if (isGuard(BestUnswitchTI))\n    BestUnswitchTI = turnGuardIntoBranch(cast<IntrinsicInst>(BestUnswitchTI), L,\n                                         ExitBlocks, DT, LI, MSSAU);\n\n  LLVM_DEBUG(dbgs() << \"  Unswitching non-trivial (cost = \"\n                    << BestUnswitchCost << \") terminator: \" << *BestUnswitchTI\n                    << \"\\n\");\n  unswitchNontrivialInvariants(L, *BestUnswitchTI, BestUnswitchInvariants,\n                               ExitBlocks, DT, LI, AC, UnswitchCB, SE, MSSAU);\n  return true;\n}\n\n/// Unswitch control flow predicated on loop invariant conditions.\n///\n/// This first hoists all branches or switches which are trivial (IE, do not\n/// require duplicating any part of the loop) out of the loop body. It then\n/// looks at other loop invariant control flows and tries to unswitch those as\n/// well by cloning the loop if the result is small enough.\n///\n/// The `DT`, `LI`, `AC`, `TTI` parameters are required analyses that are also\n/// updated based on the unswitch.\n/// The `MSSA` analysis is also updated if valid (i.e. its use is enabled).\n///\n/// If either `NonTrivial` is true or the flag `EnableNonTrivialUnswitch` is\n/// true, we will attempt to do non-trivial unswitching as well as trivial\n/// unswitching.\n///\n/// The `UnswitchCB` callback provided will be run after unswitching is\n/// complete, with the first parameter set to `true` if the provided loop\n/// remains a loop, and a list of new sibling loops created.\n///\n/// If `SE` is non-null, we will update that analysis based on the unswitching\n/// done.\nstatic bool unswitchLoop(Loop &L, DominatorTree &DT, LoopInfo &LI,\n                         AssumptionCache &AC, TargetTransformInfo &TTI,\n                         bool NonTrivial,\n                         function_ref<void(bool, ArrayRef<Loop *>)> UnswitchCB,\n                         ScalarEvolution *SE, MemorySSAUpdater *MSSAU) {\n  assert(L.isRecursivelyLCSSAForm(DT, LI) &&\n         \"Loops must be in LCSSA form before unswitching.\");\n\n  // Must be in loop simplified form: we need a preheader and dedicated exits.\n  if (!L.isLoopSimplifyForm())\n    return false;\n\n  // Try trivial unswitch first before loop over other basic blocks in the loop.\n  if (unswitchAllTrivialConditions(L, DT, LI, SE, MSSAU)) {\n    // If we unswitched successfully we will want to clean up the loop before\n    // processing it further so just mark it as unswitched and return.\n    UnswitchCB(/*CurrentLoopValid*/ true, {});\n    return true;\n  }\n\n  // If we're not doing non-trivial unswitching, we're done. We both accept\n  // a parameter but also check a local flag that can be used for testing\n  // a debugging.\n  if (!NonTrivial && !EnableNonTrivialUnswitch)\n    return false;\n\n  // Skip non-trivial unswitching for optsize functions.\n  if (L.getHeader()->getParent()->hasOptSize())\n    return false;\n\n  // Skip non-trivial unswitching for loops that cannot be cloned.\n  if (!L.isSafeToClone())\n    return false;\n\n  // For non-trivial unswitching, because it often creates new loops, we rely on\n  // the pass manager to iterate on the loops rather than trying to immediately\n  // reach a fixed point. There is no substantial advantage to iterating\n  // internally, and if any of the new loops are simplified enough to contain\n  // trivial unswitching we want to prefer those.\n\n  // Try to unswitch the best invariant condition. We prefer this full unswitch to\n  // a partial unswitch when possible below the threshold.\n  if (unswitchBestCondition(L, DT, LI, AC, TTI, UnswitchCB, SE, MSSAU))\n    return true;\n\n  // No other opportunities to unswitch.\n  return false;\n}\n\nPreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,\n                                              LoopStandardAnalysisResults &AR,\n                                              LPMUpdater &U) {\n  Function &F = *L.getHeader()->getParent();\n  (void)F;\n\n  LLVM_DEBUG(dbgs() << \"Unswitching loop in \" << F.getName() << \": \" << L\n                    << \"\\n\");\n\n  // Save the current loop name in a variable so that we can report it even\n  // after it has been deleted.\n  std::string LoopName = std::string(L.getName());\n\n  auto UnswitchCB = [&L, &U, &LoopName](bool CurrentLoopValid,\n                                        ArrayRef<Loop *> NewLoops) {\n    // If we did a non-trivial unswitch, we have added new (cloned) loops.\n    if (!NewLoops.empty())\n      U.addSiblingLoops(NewLoops);\n\n    // If the current loop remains valid, we should revisit it to catch any\n    // other unswitch opportunities. Otherwise, we need to mark it as deleted.\n    if (CurrentLoopValid)\n      U.revisitCurrentLoop();\n    else\n      U.markLoopAsDeleted(L, LoopName);\n  };\n\n  Optional<MemorySSAUpdater> MSSAU;\n  if (AR.MSSA) {\n    MSSAU = MemorySSAUpdater(AR.MSSA);\n    if (VerifyMemorySSA)\n      AR.MSSA->verifyMemorySSA();\n  }\n  if (!unswitchLoop(L, AR.DT, AR.LI, AR.AC, AR.TTI, NonTrivial, UnswitchCB,\n                    &AR.SE, MSSAU.hasValue() ? MSSAU.getPointer() : nullptr))\n    return PreservedAnalyses::all();\n\n  if (AR.MSSA && VerifyMemorySSA)\n    AR.MSSA->verifyMemorySSA();\n\n  // Historically this pass has had issues with the dominator tree so verify it\n  // in asserts builds.\n  assert(AR.DT.verify(DominatorTree::VerificationLevel::Fast));\n\n  auto PA = getLoopPassPreservedAnalyses();\n  if (AR.MSSA)\n    PA.preserve<MemorySSAAnalysis>();\n  return PA;\n}\n\nnamespace {\n\nclass SimpleLoopUnswitchLegacyPass : public LoopPass {\n  bool NonTrivial;\n\npublic:\n  static char ID; // Pass ID, replacement for typeid\n\n  explicit SimpleLoopUnswitchLegacyPass(bool NonTrivial = false)\n      : LoopPass(ID), NonTrivial(NonTrivial) {\n    initializeSimpleLoopUnswitchLegacyPassPass(\n        *PassRegistry::getPassRegistry());\n  }\n\n  bool runOnLoop(Loop *L, LPPassManager &LPM) override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.addRequired<AssumptionCacheTracker>();\n    AU.addRequired<TargetTransformInfoWrapperPass>();\n    if (EnableMSSALoopDependency) {\n      AU.addRequired<MemorySSAWrapperPass>();\n      AU.addPreserved<MemorySSAWrapperPass>();\n    }\n    getLoopAnalysisUsage(AU);\n  }\n};\n\n} // end anonymous namespace\n\nbool SimpleLoopUnswitchLegacyPass::runOnLoop(Loop *L, LPPassManager &LPM) {\n  if (skipLoop(L))\n    return false;\n\n  Function &F = *L->getHeader()->getParent();\n\n  LLVM_DEBUG(dbgs() << \"Unswitching loop in \" << F.getName() << \": \" << *L\n                    << \"\\n\");\n\n  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();\n  auto &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);\n  auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);\n  MemorySSA *MSSA = nullptr;\n  Optional<MemorySSAUpdater> MSSAU;\n  if (EnableMSSALoopDependency) {\n    MSSA = &getAnalysis<MemorySSAWrapperPass>().getMSSA();\n    MSSAU = MemorySSAUpdater(MSSA);\n  }\n\n  auto *SEWP = getAnalysisIfAvailable<ScalarEvolutionWrapperPass>();\n  auto *SE = SEWP ? &SEWP->getSE() : nullptr;\n\n  auto UnswitchCB = [&L, &LPM](bool CurrentLoopValid,\n                               ArrayRef<Loop *> NewLoops) {\n    // If we did a non-trivial unswitch, we have added new (cloned) loops.\n    for (auto *NewL : NewLoops)\n      LPM.addLoop(*NewL);\n\n    // If the current loop remains valid, re-add it to the queue. This is\n    // a little wasteful as we'll finish processing the current loop as well,\n    // but it is the best we can do in the old PM.\n    if (CurrentLoopValid)\n      LPM.addLoop(*L);\n    else\n      LPM.markLoopAsDeleted(*L);\n  };\n\n  if (MSSA && VerifyMemorySSA)\n    MSSA->verifyMemorySSA();\n\n  bool Changed = unswitchLoop(*L, DT, LI, AC, TTI, NonTrivial, UnswitchCB, SE,\n                              MSSAU.hasValue() ? MSSAU.getPointer() : nullptr);\n\n  if (MSSA && VerifyMemorySSA)\n    MSSA->verifyMemorySSA();\n\n  // Historically this pass has had issues with the dominator tree so verify it\n  // in asserts builds.\n  assert(DT.verify(DominatorTree::VerificationLevel::Fast));\n\n  return Changed;\n}\n\nchar SimpleLoopUnswitchLegacyPass::ID = 0;\nINITIALIZE_PASS_BEGIN(SimpleLoopUnswitchLegacyPass, \"simple-loop-unswitch\",\n                      \"Simple unswitch loops\", false, false)\nINITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)\nINITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(LoopPass)\nINITIALIZE_PASS_DEPENDENCY(MemorySSAWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)\nINITIALIZE_PASS_END(SimpleLoopUnswitchLegacyPass, \"simple-loop-unswitch\",\n                    \"Simple unswitch loops\", false, false)\n\nPass *llvm::createSimpleLoopUnswitchLegacyPass(bool NonTrivial) {\n  return new SimpleLoopUnswitchLegacyPass(NonTrivial);\n}\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 18, "line": 41}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 18, "line": 41}, "message": "default constructor 'value_sequence_iterator<ValueT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Sequence.h", "reportHash": "ac4a2e1b3f4891953eecae9c87298487", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 18, "line": 43}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 18, "line": 43}, "message": "move constructor 'value_sequence_iterator<ValueT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Sequence.h", "reportHash": "421f4d0121f5afeaffc3dc041ad6ac26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 384}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 384}, "message": "default constructor 'AAQueryInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "reportHash": "7d6d77e4f209564d926d630f1067dcc3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 432}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 432}, "message": "move constructor 'AAResults' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "reportHash": "adf92d5ca0be78037b2833bb97af2388", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 987}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 987}, "message": "destructor '~Model<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "reportHash": "64649f8758c7f328f2fab3c2e1c4cf52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 35, "line": 1105}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 35, "line": 1105}, "message": "default constructor 'AAResultBase<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "reportHash": "7d46c57a9a242028e74541f7193886c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 1110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 1110}, "message": "move constructor 'AAResultBase<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "reportHash": "ed0d4c3b74d164263185912e18323fc1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 1248}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 1248}, "message": "default constructor 'AAResultsWrapperPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "reportHash": "65179df341e35b9290b19e727a1f7355", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 1267}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 1267}, "message": "default constructor 'ExternalAAWrapperPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h", "reportHash": "9641a6f4ae53f88f19ad801bf6193154", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 40, "line": 65}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 40, "line": 65}, "message": "default constructor 'InstrInfoQuery' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "52e2f39a4d3318350b0ed15696c1b225", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 42, "line": 32}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 42, "line": 32}, "message": "default constructor 'LoopNest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h", "reportHash": "f90398b925fb79c0e6c7e054cd9f4dda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 43, "line": 78}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 43, "line": 78}, "message": "default constructor 'LPPassManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopPass.h", "reportHash": "33421ed00a98ffc07966d1079498ec86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 43, "line": 125}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 43, "line": 125}, "message": "default constructor 'LCSSAVerificationPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopPass.h", "reportHash": "a6cee123d19f82a8227d47a1a199eec4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 709}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 45, "line": 709}, "message": "move constructor 'MemorySSA' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "reportHash": "3abaa2ffad83f52210a8a295f461f4b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 911}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 45, "line": 911}, "message": "default constructor 'MemorySSAPrinterLegacyPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "reportHash": "2e0d3cfd4055f3fa01059d728d54b3fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 962}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 45, "line": 962}, "message": "default constructor 'MemorySSAWrapperPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "reportHash": "b7148c054503260f9ddfb09685aa247d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 1084}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 45, "line": 1084}, "message": "default constructor 'memoryaccess_def_iterator_base<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "reportHash": "065c3d957d3759996699f5d548fcb862", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 1192}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 45, "line": 1192}, "message": "default constructor 'upward_defs_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "reportHash": "c9b72b5969cd07c53ea8e17a9129b1e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 1297}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 45, "line": 1297}, "message": "default constructor 'def_chain_iterator<T, UseOptimizedChain>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "reportHash": "1c13d11af8ea06ed5308e29327d28462", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 288}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 288}, "message": "move constructor 'MustBeExecutedIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MustExecute.h", "reportHash": "eac552902320eeef0185ddf18d8d9cce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 46, "line": 292}, "message": "mark 'noexcept'"}, {"location": {"col": 27, "file": 46, "line": 292}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MustExecute.h", "reportHash": "3efb2cf40ace6ac57482ba11d99f3235", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 102, "line": 79}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 102, "line": 79}, "message": "default constructor 'PassManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h", "reportHash": "3362a079813eadaa88328b26ea322ba6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 102, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 102, "line": 86}, "message": "move constructor 'PassManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h", "reportHash": "326df8afe9fcf137baecbf6d0a59651d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 102, "line": 92}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 102, "line": 92}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h", "reportHash": "b2178f56b550b2f93fc7df3ebb22efc9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 102, "line": 505}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 102, "line": 505}, "message": "default constructor 'PrintLoopPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h", "reportHash": "8145021ffca9aafd620a9305a6e33aa7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 103, "line": 66}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 103, "line": 66}, "message": "default constructor 'SimpleLoopUnswitchPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h", "reportHash": "1340bda741448c7c9fd7f9d6075166b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 107, "line": 2989}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 107, "line": 2989}, "message": "default constructor 'SimpleLoopUnswitchLegacyPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp", "reportHash": "11e18cb9d3496ca5246b5c85c697e8fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
