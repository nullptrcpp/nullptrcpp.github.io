<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp", "content": "//===- ClangAttrEmitter.cpp - Generate Clang attribute handling =-*- C++ -*--=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// These tablegen backends emit Clang attribute processing code\n//\n//===----------------------------------------------------------------------===//\n\n#include \"TableGenBackends.h\"\n#include \"ASTTableGen.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/TableGen/Error.h\"\n#include \"llvm/TableGen/Record.h\"\n#include \"llvm/TableGen/StringMatcher.h\"\n#include \"llvm/TableGen/TableGenBackend.h\"\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\nnamespace {\n\nclass FlattenedSpelling {\n  std::string V, N, NS;\n  bool K = false;\n\npublic:\n  FlattenedSpelling(const std::string &Variety, const std::string &Name,\n                    const std::string &Namespace, bool KnownToGCC) :\n    V(Variety), N(Name), NS(Namespace), K(KnownToGCC) {}\n  explicit FlattenedSpelling(const Record &Spelling)\n      : V(std::string(Spelling.getValueAsString(\"Variety\"))),\n        N(std::string(Spelling.getValueAsString(\"Name\"))) {\n    assert(V != \"GCC\" && V != \"Clang\" &&\n           \"Given a GCC spelling, which means this hasn't been flattened!\");\n    if (V == \"CXX11\" || V == \"C2x\" || V == \"Pragma\")\n      NS = std::string(Spelling.getValueAsString(\"Namespace\"));\n  }\n\n  const std::string &variety() const { return V; }\n  const std::string &name() const { return N; }\n  const std::string &nameSpace() const { return NS; }\n  bool knownToGCC() const { return K; }\n};\n\n} // end anonymous namespace\n\nstatic std::vector<FlattenedSpelling>\nGetFlattenedSpellings(const Record &Attr) {\n  std::vector<Record *> Spellings = Attr.getValueAsListOfDefs(\"Spellings\");\n  std::vector<FlattenedSpelling> Ret;\n\n  for (const auto &Spelling : Spellings) {\n    StringRef Variety = Spelling->getValueAsString(\"Variety\");\n    StringRef Name = Spelling->getValueAsString(\"Name\");\n    if (Variety == \"GCC\") {\n      Ret.emplace_back(\"GNU\", std::string(Name), \"\", true);\n      Ret.emplace_back(\"CXX11\", std::string(Name), \"gnu\", true);\n      if (Spelling->getValueAsBit(\"AllowInC\"))\n        Ret.emplace_back(\"C2x\", std::string(Name), \"gnu\", true);\n    } else if (Variety == \"Clang\") {\n      Ret.emplace_back(\"GNU\", std::string(Name), \"\", false);\n      Ret.emplace_back(\"CXX11\", std::string(Name), \"clang\", false);\n      if (Spelling->getValueAsBit(\"AllowInC\"))\n        Ret.emplace_back(\"C2x\", std::string(Name), \"clang\", false);\n    } else\n      Ret.push_back(FlattenedSpelling(*Spelling));\n  }\n\n  return Ret;\n}\n\nstatic std::string ReadPCHRecord(StringRef type) {\n  return StringSwitch<std::string>(type)\n      .EndsWith(\"Decl *\", \"Record.GetLocalDeclAs<\" +\n                              std::string(type.data(), 0, type.size() - 1) +\n                              \">(Record.readInt())\")\n      .Case(\"TypeSourceInfo *\", \"Record.readTypeSourceInfo()\")\n      .Case(\"Expr *\", \"Record.readExpr()\")\n      .Case(\"IdentifierInfo *\", \"Record.readIdentifier()\")\n      .Case(\"StringRef\", \"Record.readString()\")\n      .Case(\"ParamIdx\", \"ParamIdx::deserialize(Record.readInt())\")\n      .Case(\"OMPTraitInfo *\", \"Record.readOMPTraitInfo()\")\n      .Default(\"Record.readInt()\");\n}\n\n// Get a type that is suitable for storing an object of the specified type.\nstatic StringRef getStorageType(StringRef type) {\n  return StringSwitch<StringRef>(type)\n    .Case(\"StringRef\", \"std::string\")\n    .Default(type);\n}\n\n// Assumes that the way to get the value is SA->getname()\nstatic std::string WritePCHRecord(StringRef type, StringRef name) {\n  return \"Record.\" +\n         StringSwitch<std::string>(type)\n             .EndsWith(\"Decl *\", \"AddDeclRef(\" + std::string(name) + \");\\n\")\n             .Case(\"TypeSourceInfo *\",\n                   \"AddTypeSourceInfo(\" + std::string(name) + \");\\n\")\n             .Case(\"Expr *\", \"AddStmt(\" + std::string(name) + \");\\n\")\n             .Case(\"IdentifierInfo *\",\n                   \"AddIdentifierRef(\" + std::string(name) + \");\\n\")\n             .Case(\"StringRef\", \"AddString(\" + std::string(name) + \");\\n\")\n             .Case(\"ParamIdx\",\n                   \"push_back(\" + std::string(name) + \".serialize());\\n\")\n             .Case(\"OMPTraitInfo *\",\n                   \"writeOMPTraitInfo(\" + std::string(name) + \");\\n\")\n             .Default(\"push_back(\" + std::string(name) + \");\\n\");\n}\n\n// Normalize attribute name by removing leading and trailing\n// underscores. For example, __foo, foo__, __foo__ would\n// become foo.\nstatic StringRef NormalizeAttrName(StringRef AttrName) {\n  AttrName.consume_front(\"__\");\n  AttrName.consume_back(\"__\");\n  return AttrName;\n}\n\n// Normalize the name by removing any and all leading and trailing underscores.\n// This is different from NormalizeAttrName in that it also handles names like\n// _pascal and __pascal.\nstatic StringRef NormalizeNameForSpellingComparison(StringRef Name) {\n  return Name.trim(\"_\");\n}\n\n// Normalize the spelling of a GNU attribute (i.e. \"x\" in \"__attribute__((x))\"),\n// removing \"__\" if it appears at the beginning and end of the attribute's name.\nstatic StringRef NormalizeGNUAttrSpelling(StringRef AttrSpelling) {\n  if (AttrSpelling.startswith(\"__\") && AttrSpelling.endswith(\"__\")) {\n    AttrSpelling = AttrSpelling.substr(2, AttrSpelling.size() - 4);\n  }\n\n  return AttrSpelling;\n}\n\ntypedef std::vector<std::pair<std::string, const Record *>> ParsedAttrMap;\n\nstatic ParsedAttrMap getParsedAttrList(const RecordKeeper &Records,\n                                       ParsedAttrMap *Dupes = nullptr) {\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  std::set<std::string> Seen;\n  ParsedAttrMap R;\n  for (const auto *Attr : Attrs) {\n    if (Attr->getValueAsBit(\"SemaHandler\")) {\n      std::string AN;\n      if (Attr->isSubClassOf(\"TargetSpecificAttr\") &&\n          !Attr->isValueUnset(\"ParseKind\")) {\n        AN = std::string(Attr->getValueAsString(\"ParseKind\"));\n\n        // If this attribute has already been handled, it does not need to be\n        // handled again.\n        if (Seen.find(AN) != Seen.end()) {\n          if (Dupes)\n            Dupes->push_back(std::make_pair(AN, Attr));\n          continue;\n        }\n        Seen.insert(AN);\n      } else\n        AN = NormalizeAttrName(Attr->getName()).str();\n\n      R.push_back(std::make_pair(AN, Attr));\n    }\n  }\n  return R;\n}\n\nnamespace {\n\n  class Argument {\n    std::string lowerName, upperName;\n    StringRef attrName;\n    bool isOpt;\n    bool Fake;\n\n  public:\n    Argument(const Record &Arg, StringRef Attr)\n        : lowerName(std::string(Arg.getValueAsString(\"Name\"))),\n          upperName(lowerName), attrName(Attr), isOpt(false), Fake(false) {\n      if (!lowerName.empty()) {\n        lowerName[0] = std::tolower(lowerName[0]);\n        upperName[0] = std::toupper(upperName[0]);\n      }\n      // Work around MinGW's macro definition of 'interface' to 'struct'. We\n      // have an attribute argument called 'Interface', so only the lower case\n      // name conflicts with the macro definition.\n      if (lowerName == \"interface\")\n        lowerName = \"interface_\";\n    }\n    virtual ~Argument() = default;\n\n    StringRef getLowerName() const { return lowerName; }\n    StringRef getUpperName() const { return upperName; }\n    StringRef getAttrName() const { return attrName; }\n\n    bool isOptional() const { return isOpt; }\n    void setOptional(bool set) { isOpt = set; }\n\n    bool isFake() const { return Fake; }\n    void setFake(bool fake) { Fake = fake; }\n\n    // These functions print the argument contents formatted in different ways.\n    virtual void writeAccessors(raw_ostream &OS) const = 0;\n    virtual void writeAccessorDefinitions(raw_ostream &OS) const {}\n    virtual void writeASTVisitorTraversal(raw_ostream &OS) const {}\n    virtual void writeCloneArgs(raw_ostream &OS) const = 0;\n    virtual void writeTemplateInstantiationArgs(raw_ostream &OS) const = 0;\n    virtual void writeTemplateInstantiation(raw_ostream &OS) const {}\n    virtual void writeCtorBody(raw_ostream &OS) const {}\n    virtual void writeCtorInitializers(raw_ostream &OS) const = 0;\n    virtual void writeCtorDefaultInitializers(raw_ostream &OS) const = 0;\n    virtual void writeCtorParameters(raw_ostream &OS) const = 0;\n    virtual void writeDeclarations(raw_ostream &OS) const = 0;\n    virtual void writePCHReadArgs(raw_ostream &OS) const = 0;\n    virtual void writePCHReadDecls(raw_ostream &OS) const = 0;\n    virtual void writePCHWrite(raw_ostream &OS) const = 0;\n    virtual std::string getIsOmitted() const { return \"false\"; }\n    virtual void writeValue(raw_ostream &OS) const = 0;\n    virtual void writeDump(raw_ostream &OS) const = 0;\n    virtual void writeDumpChildren(raw_ostream &OS) const {}\n    virtual void writeHasChildren(raw_ostream &OS) const { OS << \"false\"; }\n\n    virtual bool isEnumArg() const { return false; }\n    virtual bool isVariadicEnumArg() const { return false; }\n    virtual bool isVariadic() const { return false; }\n\n    virtual void writeImplicitCtorArgs(raw_ostream &OS) const {\n      OS << getUpperName();\n    }\n  };\n\n  class SimpleArgument : public Argument {\n    std::string type;\n\n  public:\n    SimpleArgument(const Record &Arg, StringRef Attr, std::string T)\n        : Argument(Arg, Attr), type(std::move(T)) {}\n\n    std::string getType() const { return type; }\n\n    void writeAccessors(raw_ostream &OS) const override {\n      OS << \"  \" << type << \" get\" << getUpperName() << \"() const {\\n\";\n      OS << \"    return \" << getLowerName() << \";\\n\";\n      OS << \"  }\";\n    }\n\n    void writeCloneArgs(raw_ostream &OS) const override {\n      OS << getLowerName();\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      OS << \"A->get\" << getUpperName() << \"()\";\n    }\n\n    void writeCtorInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"(\" << getUpperName() << \")\";\n    }\n\n    void writeCtorDefaultInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"()\";\n    }\n\n    void writeCtorParameters(raw_ostream &OS) const override {\n      OS << type << \" \" << getUpperName();\n    }\n\n    void writeDeclarations(raw_ostream &OS) const override {\n      OS << type << \" \" << getLowerName() << \";\";\n    }\n\n    void writePCHReadDecls(raw_ostream &OS) const override {\n      std::string read = ReadPCHRecord(type);\n      OS << \"    \" << type << \" \" << getLowerName() << \" = \" << read << \";\\n\";\n    }\n\n    void writePCHReadArgs(raw_ostream &OS) const override {\n      OS << getLowerName();\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"    \"\n         << WritePCHRecord(type,\n                           \"SA->get\" + std::string(getUpperName()) + \"()\");\n    }\n\n    std::string getIsOmitted() const override {\n      if (type == \"IdentifierInfo *\")\n        return \"!get\" + getUpperName().str() + \"()\";\n      if (type == \"TypeSourceInfo *\")\n        return \"!get\" + getUpperName().str() + \"Loc()\";\n      if (type == \"ParamIdx\")\n        return \"!get\" + getUpperName().str() + \"().isValid()\";\n      return \"false\";\n    }\n\n    void writeValue(raw_ostream &OS) const override {\n      if (type == \"FunctionDecl *\")\n        OS << \"\\\" << get\" << getUpperName()\n           << \"()->getNameInfo().getAsString() << \\\"\";\n      else if (type == \"IdentifierInfo *\")\n        // Some non-optional (comma required) identifier arguments can be the\n        // empty string but are then recorded as a nullptr.\n        OS << \"\\\" << (get\" << getUpperName() << \"() ? get\" << getUpperName()\n           << \"()->getName() : \\\"\\\") << \\\"\";\n      else if (type == \"VarDecl *\")\n        OS << \"\\\" << get\" << getUpperName() << \"()->getName() << \\\"\";\n      else if (type == \"TypeSourceInfo *\")\n        OS << \"\\\" << get\" << getUpperName() << \"().getAsString() << \\\"\";\n      else if (type == \"ParamIdx\")\n        OS << \"\\\" << get\" << getUpperName() << \"().getSourceIndex() << \\\"\";\n      else\n        OS << \"\\\" << get\" << getUpperName() << \"() << \\\"\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {\n      if (StringRef(type).endswith(\"Decl *\")) {\n        OS << \"    OS << \\\" \\\";\\n\";\n        OS << \"    dumpBareDeclRef(SA->get\" << getUpperName() << \"());\\n\";\n      } else if (type == \"IdentifierInfo *\") {\n        // Some non-optional (comma required) identifier arguments can be the\n        // empty string but are then recorded as a nullptr.\n        OS << \"    if (SA->get\" << getUpperName() << \"())\\n\"\n           << \"      OS << \\\" \\\" << SA->get\" << getUpperName()\n           << \"()->getName();\\n\";\n      } else if (type == \"TypeSourceInfo *\") {\n        if (isOptional())\n          OS << \"    if (SA->get\" << getUpperName() << \"Loc())\";\n        OS << \"    OS << \\\" \\\" << SA->get\" << getUpperName()\n           << \"().getAsString();\\n\";\n      } else if (type == \"bool\") {\n        OS << \"    if (SA->get\" << getUpperName() << \"()) OS << \\\" \"\n           << getUpperName() << \"\\\";\\n\";\n      } else if (type == \"int\" || type == \"unsigned\") {\n        OS << \"    OS << \\\" \\\" << SA->get\" << getUpperName() << \"();\\n\";\n      } else if (type == \"ParamIdx\") {\n        if (isOptional())\n          OS << \"    if (SA->get\" << getUpperName() << \"().isValid())\\n  \";\n        OS << \"    OS << \\\" \\\" << SA->get\" << getUpperName()\n           << \"().getSourceIndex();\\n\";\n      } else if (type == \"OMPTraitInfo *\") {\n        OS << \"    OS << \\\" \\\" << SA->get\" << getUpperName() << \"();\\n\";\n      } else {\n        llvm_unreachable(\"Unknown SimpleArgument type!\");\n      }\n    }\n  };\n\n  class DefaultSimpleArgument : public SimpleArgument {\n    int64_t Default;\n\n  public:\n    DefaultSimpleArgument(const Record &Arg, StringRef Attr,\n                          std::string T, int64_t Default)\n      : SimpleArgument(Arg, Attr, T), Default(Default) {}\n\n    void writeAccessors(raw_ostream &OS) const override {\n      SimpleArgument::writeAccessors(OS);\n\n      OS << \"\\n\\n  static const \" << getType() << \" Default\" << getUpperName()\n         << \" = \";\n      if (getType() == \"bool\")\n        OS << (Default != 0 ? \"true\" : \"false\");\n      else\n        OS << Default;\n      OS << \";\";\n    }\n  };\n\n  class StringArgument : public Argument {\n  public:\n    StringArgument(const Record &Arg, StringRef Attr)\n      : Argument(Arg, Attr)\n    {}\n\n    void writeAccessors(raw_ostream &OS) const override {\n      OS << \"  llvm::StringRef get\" << getUpperName() << \"() const {\\n\";\n      OS << \"    return llvm::StringRef(\" << getLowerName() << \", \"\n         << getLowerName() << \"Length);\\n\";\n      OS << \"  }\\n\";\n      OS << \"  unsigned get\" << getUpperName() << \"Length() const {\\n\";\n      OS << \"    return \" << getLowerName() << \"Length;\\n\";\n      OS << \"  }\\n\";\n      OS << \"  void set\" << getUpperName()\n         << \"(ASTContext &C, llvm::StringRef S) {\\n\";\n      OS << \"    \" << getLowerName() << \"Length = S.size();\\n\";\n      OS << \"    this->\" << getLowerName() << \" = new (C, 1) char [\"\n         << getLowerName() << \"Length];\\n\";\n      OS << \"    if (!S.empty())\\n\";\n      OS << \"      std::memcpy(this->\" << getLowerName() << \", S.data(), \"\n         << getLowerName() << \"Length);\\n\";\n      OS << \"  }\";\n    }\n\n    void writeCloneArgs(raw_ostream &OS) const override {\n      OS << \"get\" << getUpperName() << \"()\";\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      OS << \"A->get\" << getUpperName() << \"()\";\n    }\n\n    void writeCtorBody(raw_ostream &OS) const override {\n      OS << \"    if (!\" << getUpperName() << \".empty())\\n\";\n      OS << \"      std::memcpy(\" << getLowerName() << \", \" << getUpperName()\n         << \".data(), \" << getLowerName() << \"Length);\\n\";\n    }\n\n    void writeCtorInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"Length(\" << getUpperName() << \".size()),\"\n         << getLowerName() << \"(new (Ctx, 1) char[\" << getLowerName()\n         << \"Length])\";\n    }\n\n    void writeCtorDefaultInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"Length(0),\" << getLowerName() << \"(nullptr)\";\n    }\n\n    void writeCtorParameters(raw_ostream &OS) const override {\n      OS << \"llvm::StringRef \" << getUpperName();\n    }\n\n    void writeDeclarations(raw_ostream &OS) const override {\n      OS << \"unsigned \" << getLowerName() << \"Length;\\n\";\n      OS << \"char *\" << getLowerName() << \";\";\n    }\n\n    void writePCHReadDecls(raw_ostream &OS) const override {\n      OS << \"    std::string \" << getLowerName()\n         << \"= Record.readString();\\n\";\n    }\n\n    void writePCHReadArgs(raw_ostream &OS) const override {\n      OS << getLowerName();\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"    Record.AddString(SA->get\" << getUpperName() << \"());\\n\";\n    }\n\n    void writeValue(raw_ostream &OS) const override {\n      OS << \"\\\\\\\"\\\" << get\" << getUpperName() << \"() << \\\"\\\\\\\"\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {\n      OS << \"    OS << \\\" \\\\\\\"\\\" << SA->get\" << getUpperName()\n         << \"() << \\\"\\\\\\\"\\\";\\n\";\n    }\n  };\n\n  class AlignedArgument : public Argument {\n  public:\n    AlignedArgument(const Record &Arg, StringRef Attr)\n      : Argument(Arg, Attr)\n    {}\n\n    void writeAccessors(raw_ostream &OS) const override {\n      OS << \"  bool is\" << getUpperName() << \"Dependent() const;\\n\";\n      OS << \"  bool is\" << getUpperName() << \"ErrorDependent() const;\\n\";\n\n      OS << \"  unsigned get\" << getUpperName() << \"(ASTContext &Ctx) const;\\n\";\n\n      OS << \"  bool is\" << getUpperName() << \"Expr() const {\\n\";\n      OS << \"    return is\" << getLowerName() << \"Expr;\\n\";\n      OS << \"  }\\n\";\n\n      OS << \"  Expr *get\" << getUpperName() << \"Expr() const {\\n\";\n      OS << \"    assert(is\" << getLowerName() << \"Expr);\\n\";\n      OS << \"    return \" << getLowerName() << \"Expr;\\n\";\n      OS << \"  }\\n\";\n\n      OS << \"  TypeSourceInfo *get\" << getUpperName() << \"Type() const {\\n\";\n      OS << \"    assert(!is\" << getLowerName() << \"Expr);\\n\";\n      OS << \"    return \" << getLowerName() << \"Type;\\n\";\n      OS << \"  }\";\n    }\n\n    void writeAccessorDefinitions(raw_ostream &OS) const override {\n      OS << \"bool \" << getAttrName() << \"Attr::is\" << getUpperName()\n         << \"Dependent() const {\\n\";\n      OS << \"  if (is\" << getLowerName() << \"Expr)\\n\";\n      OS << \"    return \" << getLowerName() << \"Expr && (\" << getLowerName()\n         << \"Expr->isValueDependent() || \" << getLowerName()\n         << \"Expr->isTypeDependent());\\n\";\n      OS << \"  else\\n\";\n      OS << \"    return \" << getLowerName()\n         << \"Type->getType()->isDependentType();\\n\";\n      OS << \"}\\n\";\n\n      OS << \"bool \" << getAttrName() << \"Attr::is\" << getUpperName()\n         << \"ErrorDependent() const {\\n\";\n      OS << \"  if (is\" << getLowerName() << \"Expr)\\n\";\n      OS << \"    return \" << getLowerName() << \"Expr && \" << getLowerName()\n         << \"Expr->containsErrors();\\n\";\n      OS << \"  return \" << getLowerName()\n         << \"Type->getType()->containsErrors();\\n\";\n      OS << \"}\\n\";\n\n      // FIXME: Do not do the calculation here\n      // FIXME: Handle types correctly\n      // A null pointer means maximum alignment\n      OS << \"unsigned \" << getAttrName() << \"Attr::get\" << getUpperName()\n         << \"(ASTContext &Ctx) const {\\n\";\n      OS << \"  assert(!is\" << getUpperName() << \"Dependent());\\n\";\n      OS << \"  if (is\" << getLowerName() << \"Expr)\\n\";\n      OS << \"    return \" << getLowerName() << \"Expr ? \" << getLowerName()\n         << \"Expr->EvaluateKnownConstInt(Ctx).getZExtValue()\"\n         << \" * Ctx.getCharWidth() : \"\n         << \"Ctx.getTargetDefaultAlignForAttributeAligned();\\n\";\n      OS << \"  else\\n\";\n      OS << \"    return 0; // FIXME\\n\";\n      OS << \"}\\n\";\n    }\n\n    void writeASTVisitorTraversal(raw_ostream &OS) const override {\n      StringRef Name = getUpperName();\n      OS << \"  if (A->is\" << Name << \"Expr()) {\\n\"\n         << \"    if (!getDerived().TraverseStmt(A->get\" << Name << \"Expr()))\\n\"\n         << \"      return false;\\n\"\n         << \"  } else if (auto *TSI = A->get\" << Name << \"Type()) {\\n\"\n         << \"    if (!getDerived().TraverseTypeLoc(TSI->getTypeLoc()))\\n\"\n         << \"      return false;\\n\"\n         << \"  }\\n\";\n    }\n\n    void writeCloneArgs(raw_ostream &OS) const override {\n      OS << \"is\" << getLowerName() << \"Expr, is\" << getLowerName()\n         << \"Expr ? static_cast<void*>(\" << getLowerName()\n         << \"Expr) : \" << getLowerName()\n         << \"Type\";\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      // FIXME: move the definition in Sema::InstantiateAttrs to here.\n      // In the meantime, aligned attributes are cloned.\n    }\n\n    void writeCtorBody(raw_ostream &OS) const override {\n      OS << \"    if (is\" << getLowerName() << \"Expr)\\n\";\n      OS << \"       \" << getLowerName() << \"Expr = reinterpret_cast<Expr *>(\"\n         << getUpperName() << \");\\n\";\n      OS << \"    else\\n\";\n      OS << \"       \" << getLowerName()\n         << \"Type = reinterpret_cast<TypeSourceInfo *>(\" << getUpperName()\n         << \");\\n\";\n    }\n\n    void writeCtorInitializers(raw_ostream &OS) const override {\n      OS << \"is\" << getLowerName() << \"Expr(Is\" << getUpperName() << \"Expr)\";\n    }\n\n    void writeCtorDefaultInitializers(raw_ostream &OS) const override {\n      OS << \"is\" << getLowerName() << \"Expr(false)\";\n    }\n\n    void writeCtorParameters(raw_ostream &OS) const override {\n      OS << \"bool Is\" << getUpperName() << \"Expr, void *\" << getUpperName();\n    }\n\n    void writeImplicitCtorArgs(raw_ostream &OS) const override {\n      OS << \"Is\" << getUpperName() << \"Expr, \" << getUpperName();\n    }\n\n    void writeDeclarations(raw_ostream &OS) const override {\n      OS << \"bool is\" << getLowerName() << \"Expr;\\n\";\n      OS << \"union {\\n\";\n      OS << \"Expr *\" << getLowerName() << \"Expr;\\n\";\n      OS << \"TypeSourceInfo *\" << getLowerName() << \"Type;\\n\";\n      OS << \"};\";\n    }\n\n    void writePCHReadArgs(raw_ostream &OS) const override {\n      OS << \"is\" << getLowerName() << \"Expr, \" << getLowerName() << \"Ptr\";\n    }\n\n    void writePCHReadDecls(raw_ostream &OS) const override {\n      OS << \"    bool is\" << getLowerName() << \"Expr = Record.readInt();\\n\";\n      OS << \"    void *\" << getLowerName() << \"Ptr;\\n\";\n      OS << \"    if (is\" << getLowerName() << \"Expr)\\n\";\n      OS << \"      \" << getLowerName() << \"Ptr = Record.readExpr();\\n\";\n      OS << \"    else\\n\";\n      OS << \"      \" << getLowerName()\n         << \"Ptr = Record.readTypeSourceInfo();\\n\";\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"    Record.push_back(SA->is\" << getUpperName() << \"Expr());\\n\";\n      OS << \"    if (SA->is\" << getUpperName() << \"Expr())\\n\";\n      OS << \"      Record.AddStmt(SA->get\" << getUpperName() << \"Expr());\\n\";\n      OS << \"    else\\n\";\n      OS << \"      Record.AddTypeSourceInfo(SA->get\" << getUpperName()\n         << \"Type());\\n\";\n    }\n\n    std::string getIsOmitted() const override {\n      return \"!is\" + getLowerName().str() + \"Expr || !\" + getLowerName().str()\n             + \"Expr\";\n    }\n\n    void writeValue(raw_ostream &OS) const override {\n      OS << \"\\\";\\n\";\n      OS << \"    \" << getLowerName()\n         << \"Expr->printPretty(OS, nullptr, Policy);\\n\";\n      OS << \"    OS << \\\"\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {\n      OS << \"    if (!SA->is\" << getUpperName() << \"Expr())\\n\";\n      OS << \"      dumpType(SA->get\" << getUpperName()\n         << \"Type()->getType());\\n\";\n    }\n\n    void writeDumpChildren(raw_ostream &OS) const override {\n      OS << \"    if (SA->is\" << getUpperName() << \"Expr())\\n\";\n      OS << \"      Visit(SA->get\" << getUpperName() << \"Expr());\\n\";\n    }\n\n    void writeHasChildren(raw_ostream &OS) const override {\n      OS << \"SA->is\" << getUpperName() << \"Expr()\";\n    }\n  };\n\n  class VariadicArgument : public Argument {\n    std::string Type, ArgName, ArgSizeName, RangeName;\n\n  protected:\n    // Assumed to receive a parameter: raw_ostream OS.\n    virtual void writeValueImpl(raw_ostream &OS) const {\n      OS << \"    OS << Val;\\n\";\n    }\n    // Assumed to receive a parameter: raw_ostream OS.\n    virtual void writeDumpImpl(raw_ostream &OS) const {\n      OS << \"      OS << \\\" \\\" << Val;\\n\";\n    }\n\n  public:\n    VariadicArgument(const Record &Arg, StringRef Attr, std::string T)\n        : Argument(Arg, Attr), Type(std::move(T)),\n          ArgName(getLowerName().str() + \"_\"), ArgSizeName(ArgName + \"Size\"),\n          RangeName(std::string(getLowerName())) {}\n\n    const std::string &getType() const { return Type; }\n    const std::string &getArgName() const { return ArgName; }\n    const std::string &getArgSizeName() const { return ArgSizeName; }\n    bool isVariadic() const override { return true; }\n\n    void writeAccessors(raw_ostream &OS) const override {\n      std::string IteratorType = getLowerName().str() + \"_iterator\";\n      std::string BeginFn = getLowerName().str() + \"_begin()\";\n      std::string EndFn = getLowerName().str() + \"_end()\";\n\n      OS << \"  typedef \" << Type << \"* \" << IteratorType << \";\\n\";\n      OS << \"  \" << IteratorType << \" \" << BeginFn << \" const {\"\n         << \" return \" << ArgName << \"; }\\n\";\n      OS << \"  \" << IteratorType << \" \" << EndFn << \" const {\"\n         << \" return \" << ArgName << \" + \" << ArgSizeName << \"; }\\n\";\n      OS << \"  unsigned \" << getLowerName() << \"_size() const {\"\n         << \" return \" << ArgSizeName << \"; }\\n\";\n      OS << \"  llvm::iterator_range<\" << IteratorType << \"> \" << RangeName\n         << \"() const { return llvm::make_range(\" << BeginFn << \", \" << EndFn\n         << \"); }\\n\";\n    }\n\n    void writeCloneArgs(raw_ostream &OS) const override {\n      OS << ArgName << \", \" << ArgSizeName;\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      // This isn't elegant, but we have to go through public methods...\n      OS << \"A->\" << getLowerName() << \"_begin(), \"\n         << \"A->\" << getLowerName() << \"_size()\";\n    }\n\n    void writeASTVisitorTraversal(raw_ostream &OS) const override {\n      // FIXME: Traverse the elements.\n    }\n\n    void writeCtorBody(raw_ostream &OS) const override {\n      OS << \"  std::copy(\" << getUpperName() << \", \" << getUpperName() << \" + \"\n         << ArgSizeName << \", \" << ArgName << \");\\n\";\n    }\n\n    void writeCtorInitializers(raw_ostream &OS) const override {\n      OS << ArgSizeName << \"(\" << getUpperName() << \"Size), \"\n         << ArgName << \"(new (Ctx, 16) \" << getType() << \"[\"\n         << ArgSizeName << \"])\";\n    }\n\n    void writeCtorDefaultInitializers(raw_ostream &OS) const override {\n      OS << ArgSizeName << \"(0), \" << ArgName << \"(nullptr)\";\n    }\n\n    void writeCtorParameters(raw_ostream &OS) const override {\n      OS << getType() << \" *\" << getUpperName() << \", unsigned \"\n         << getUpperName() << \"Size\";\n    }\n\n    void writeImplicitCtorArgs(raw_ostream &OS) const override {\n      OS << getUpperName() << \", \" << getUpperName() << \"Size\";\n    }\n\n    void writeDeclarations(raw_ostream &OS) const override {\n      OS << \"  unsigned \" << ArgSizeName << \";\\n\";\n      OS << \"  \" << getType() << \" *\" << ArgName << \";\";\n    }\n\n    void writePCHReadDecls(raw_ostream &OS) const override {\n      OS << \"    unsigned \" << getLowerName() << \"Size = Record.readInt();\\n\";\n      OS << \"    SmallVector<\" << getType() << \", 4> \"\n         << getLowerName() << \";\\n\";\n      OS << \"    \" << getLowerName() << \".reserve(\" << getLowerName()\n         << \"Size);\\n\";\n\n      // If we can't store the values in the current type (if it's something\n      // like StringRef), store them in a different type and convert the\n      // container afterwards.\n      std::string StorageType = std::string(getStorageType(getType()));\n      std::string StorageName = std::string(getLowerName());\n      if (StorageType != getType()) {\n        StorageName += \"Storage\";\n        OS << \"    SmallVector<\" << StorageType << \", 4> \"\n           << StorageName << \";\\n\";\n        OS << \"    \" << StorageName << \".reserve(\" << getLowerName()\n           << \"Size);\\n\";\n      }\n\n      OS << \"    for (unsigned i = 0; i != \" << getLowerName() << \"Size; ++i)\\n\";\n      std::string read = ReadPCHRecord(Type);\n      OS << \"      \" << StorageName << \".push_back(\" << read << \");\\n\";\n\n      if (StorageType != getType()) {\n        OS << \"    for (unsigned i = 0; i != \" << getLowerName() << \"Size; ++i)\\n\";\n        OS << \"      \" << getLowerName() << \".push_back(\"\n           << StorageName << \"[i]);\\n\";\n      }\n    }\n\n    void writePCHReadArgs(raw_ostream &OS) const override {\n      OS << getLowerName() << \".data(), \" << getLowerName() << \"Size\";\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"    Record.push_back(SA->\" << getLowerName() << \"_size());\\n\";\n      OS << \"    for (auto &Val : SA->\" << RangeName << \"())\\n\";\n      OS << \"      \" << WritePCHRecord(Type, \"Val\");\n    }\n\n    void writeValue(raw_ostream &OS) const override {\n      OS << \"\\\";\\n\";\n      OS << \"  for (const auto &Val : \" << RangeName << \"()) {\\n\"\n         << \"    DelimitAttributeArgument(OS, IsFirstArgument);\\n\";\n      writeValueImpl(OS);\n      OS << \"  }\\n\";\n      OS << \"  OS << \\\"\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {\n      OS << \"    for (const auto &Val : SA->\" << RangeName << \"())\\n\";\n      writeDumpImpl(OS);\n    }\n  };\n\n  class VariadicParamIdxArgument : public VariadicArgument {\n  public:\n    VariadicParamIdxArgument(const Record &Arg, StringRef Attr)\n        : VariadicArgument(Arg, Attr, \"ParamIdx\") {}\n\n  public:\n    void writeValueImpl(raw_ostream &OS) const override {\n      OS << \"    OS << Val.getSourceIndex();\\n\";\n    }\n\n    void writeDumpImpl(raw_ostream &OS) const override {\n      OS << \"      OS << \\\" \\\" << Val.getSourceIndex();\\n\";\n    }\n  };\n\n  struct VariadicParamOrParamIdxArgument : public VariadicArgument {\n    VariadicParamOrParamIdxArgument(const Record &Arg, StringRef Attr)\n        : VariadicArgument(Arg, Attr, \"int\") {}\n  };\n\n  // Unique the enums, but maintain the original declaration ordering.\n  std::vector<StringRef>\n  uniqueEnumsInOrder(const std::vector<StringRef> &enums) {\n    std::vector<StringRef> uniques;\n    SmallDenseSet<StringRef, 8> unique_set;\n    for (const auto &i : enums) {\n      if (unique_set.insert(i).second)\n        uniques.push_back(i);\n    }\n    return uniques;\n  }\n\n  class EnumArgument : public Argument {\n    std::string type;\n    std::vector<StringRef> values, enums, uniques;\n\n  public:\n    EnumArgument(const Record &Arg, StringRef Attr)\n        : Argument(Arg, Attr), type(std::string(Arg.getValueAsString(\"Type\"))),\n          values(Arg.getValueAsListOfStrings(\"Values\")),\n          enums(Arg.getValueAsListOfStrings(\"Enums\")),\n          uniques(uniqueEnumsInOrder(enums)) {\n      // FIXME: Emit a proper error\n      assert(!uniques.empty());\n    }\n\n    bool isEnumArg() const override { return true; }\n\n    void writeAccessors(raw_ostream &OS) const override {\n      OS << \"  \" << type << \" get\" << getUpperName() << \"() const {\\n\";\n      OS << \"    return \" << getLowerName() << \";\\n\";\n      OS << \"  }\";\n    }\n\n    void writeCloneArgs(raw_ostream &OS) const override {\n      OS << getLowerName();\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      OS << \"A->get\" << getUpperName() << \"()\";\n    }\n    void writeCtorInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"(\" << getUpperName() << \")\";\n    }\n    void writeCtorDefaultInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"(\" << type << \"(0))\";\n    }\n    void writeCtorParameters(raw_ostream &OS) const override {\n      OS << type << \" \" << getUpperName();\n    }\n    void writeDeclarations(raw_ostream &OS) const override {\n      auto i = uniques.cbegin(), e = uniques.cend();\n      // The last one needs to not have a comma.\n      --e;\n\n      OS << \"public:\\n\";\n      OS << \"  enum \" << type << \" {\\n\";\n      for (; i != e; ++i)\n        OS << \"    \" << *i << \",\\n\";\n      OS << \"    \" << *e << \"\\n\";\n      OS << \"  };\\n\";\n      OS << \"private:\\n\";\n      OS << \"  \" << type << \" \" << getLowerName() << \";\";\n    }\n\n    void writePCHReadDecls(raw_ostream &OS) const override {\n      OS << \"    \" << getAttrName() << \"Attr::\" << type << \" \" << getLowerName()\n         << \"(static_cast<\" << getAttrName() << \"Attr::\" << type\n         << \">(Record.readInt()));\\n\";\n    }\n\n    void writePCHReadArgs(raw_ostream &OS) const override {\n      OS << getLowerName();\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"Record.push_back(SA->get\" << getUpperName() << \"());\\n\";\n    }\n\n    void writeValue(raw_ostream &OS) const override {\n      // FIXME: this isn't 100% correct -- some enum arguments require printing\n      // as a string literal, while others require printing as an identifier.\n      // Tablegen currently does not distinguish between the two forms.\n      OS << \"\\\\\\\"\\\" << \" << getAttrName() << \"Attr::Convert\" << type << \"ToStr(get\"\n         << getUpperName() << \"()) << \\\"\\\\\\\"\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {\n      OS << \"    switch(SA->get\" << getUpperName() << \"()) {\\n\";\n      for (const auto &I : uniques) {\n        OS << \"    case \" << getAttrName() << \"Attr::\" << I << \":\\n\";\n        OS << \"      OS << \\\" \" << I << \"\\\";\\n\";\n        OS << \"      break;\\n\";\n      }\n      OS << \"    }\\n\";\n    }\n\n    void writeConversion(raw_ostream &OS, bool Header) const {\n      if (Header) {\n        OS << \"  static bool ConvertStrTo\" << type << \"(StringRef Val, \" << type\n           << \" &Out);\\n\";\n        OS << \"  static const char *Convert\" << type << \"ToStr(\" << type\n           << \" Val);\\n\";\n        return;\n      }\n\n      OS << \"bool \" << getAttrName() << \"Attr::ConvertStrTo\" << type\n         << \"(StringRef Val, \" << type << \" &Out) {\\n\";\n      OS << \"  Optional<\" << type << \"> R = llvm::StringSwitch<Optional<\";\n      OS << type << \">>(Val)\\n\";\n      for (size_t I = 0; I < enums.size(); ++I) {\n        OS << \"    .Case(\\\"\" << values[I] << \"\\\", \";\n        OS << getAttrName() << \"Attr::\" << enums[I] << \")\\n\";\n      }\n      OS << \"    .Default(Optional<\" << type << \">());\\n\";\n      OS << \"  if (R) {\\n\";\n      OS << \"    Out = *R;\\n      return true;\\n    }\\n\";\n      OS << \"  return false;\\n\";\n      OS << \"}\\n\\n\";\n\n      // Mapping from enumeration values back to enumeration strings isn't\n      // trivial because some enumeration values have multiple named\n      // enumerators, such as type_visibility(internal) and\n      // type_visibility(hidden) both mapping to TypeVisibilityAttr::Hidden.\n      OS << \"const char *\" << getAttrName() << \"Attr::Convert\" << type\n         << \"ToStr(\" << type << \" Val) {\\n\"\n         << \"  switch(Val) {\\n\";\n      SmallDenseSet<StringRef, 8> Uniques;\n      for (size_t I = 0; I < enums.size(); ++I) {\n        if (Uniques.insert(enums[I]).second)\n          OS << \"  case \" << getAttrName() << \"Attr::\" << enums[I]\n             << \": return \\\"\" << values[I] << \"\\\";\\n\";\n      }\n      OS << \"  }\\n\"\n         << \"  llvm_unreachable(\\\"No enumerator with that value\\\");\\n\"\n         << \"}\\n\";\n    }\n  };\n\n  class VariadicEnumArgument: public VariadicArgument {\n    std::string type, QualifiedTypeName;\n    std::vector<StringRef> values, enums, uniques;\n\n  protected:\n    void writeValueImpl(raw_ostream &OS) const override {\n      // FIXME: this isn't 100% correct -- some enum arguments require printing\n      // as a string literal, while others require printing as an identifier.\n      // Tablegen currently does not distinguish between the two forms.\n      OS << \"    OS << \\\"\\\\\\\"\\\" << \" << getAttrName() << \"Attr::Convert\" << type\n         << \"ToStr(Val)\" << \"<< \\\"\\\\\\\"\\\";\\n\";\n    }\n\n  public:\n    VariadicEnumArgument(const Record &Arg, StringRef Attr)\n        : VariadicArgument(Arg, Attr,\n                           std::string(Arg.getValueAsString(\"Type\"))),\n          type(std::string(Arg.getValueAsString(\"Type\"))),\n          values(Arg.getValueAsListOfStrings(\"Values\")),\n          enums(Arg.getValueAsListOfStrings(\"Enums\")),\n          uniques(uniqueEnumsInOrder(enums)) {\n      QualifiedTypeName = getAttrName().str() + \"Attr::\" + type;\n\n      // FIXME: Emit a proper error\n      assert(!uniques.empty());\n    }\n\n    bool isVariadicEnumArg() const override { return true; }\n\n    void writeDeclarations(raw_ostream &OS) const override {\n      auto i = uniques.cbegin(), e = uniques.cend();\n      // The last one needs to not have a comma.\n      --e;\n\n      OS << \"public:\\n\";\n      OS << \"  enum \" << type << \" {\\n\";\n      for (; i != e; ++i)\n        OS << \"    \" << *i << \",\\n\";\n      OS << \"    \" << *e << \"\\n\";\n      OS << \"  };\\n\";\n      OS << \"private:\\n\";\n\n      VariadicArgument::writeDeclarations(OS);\n    }\n\n    void writeDump(raw_ostream &OS) const override {\n      OS << \"    for (\" << getAttrName() << \"Attr::\" << getLowerName()\n         << \"_iterator I = SA->\" << getLowerName() << \"_begin(), E = SA->\"\n         << getLowerName() << \"_end(); I != E; ++I) {\\n\";\n      OS << \"      switch(*I) {\\n\";\n      for (const auto &UI : uniques) {\n        OS << \"    case \" << getAttrName() << \"Attr::\" << UI << \":\\n\";\n        OS << \"      OS << \\\" \" << UI << \"\\\";\\n\";\n        OS << \"      break;\\n\";\n      }\n      OS << \"      }\\n\";\n      OS << \"    }\\n\";\n    }\n\n    void writePCHReadDecls(raw_ostream &OS) const override {\n      OS << \"    unsigned \" << getLowerName() << \"Size = Record.readInt();\\n\";\n      OS << \"    SmallVector<\" << QualifiedTypeName << \", 4> \" << getLowerName()\n         << \";\\n\";\n      OS << \"    \" << getLowerName() << \".reserve(\" << getLowerName()\n         << \"Size);\\n\";\n      OS << \"    for (unsigned i = \" << getLowerName() << \"Size; i; --i)\\n\";\n      OS << \"      \" << getLowerName() << \".push_back(\" << \"static_cast<\"\n         << QualifiedTypeName << \">(Record.readInt()));\\n\";\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"    Record.push_back(SA->\" << getLowerName() << \"_size());\\n\";\n      OS << \"    for (\" << getAttrName() << \"Attr::\" << getLowerName()\n         << \"_iterator i = SA->\" << getLowerName() << \"_begin(), e = SA->\"\n         << getLowerName() << \"_end(); i != e; ++i)\\n\";\n      OS << \"      \" << WritePCHRecord(QualifiedTypeName, \"(*i)\");\n    }\n\n    void writeConversion(raw_ostream &OS, bool Header) const {\n      if (Header) {\n        OS << \"  static bool ConvertStrTo\" << type << \"(StringRef Val, \" << type\n           << \" &Out);\\n\";\n        OS << \"  static const char *Convert\" << type << \"ToStr(\" << type\n           << \" Val);\\n\";\n        return;\n      }\n\n      OS << \"bool \" << getAttrName() << \"Attr::ConvertStrTo\" << type\n         << \"(StringRef Val, \";\n      OS << type << \" &Out) {\\n\";\n      OS << \"  Optional<\" << type << \"> R = llvm::StringSwitch<Optional<\";\n      OS << type << \">>(Val)\\n\";\n      for (size_t I = 0; I < enums.size(); ++I) {\n        OS << \"    .Case(\\\"\" << values[I] << \"\\\", \";\n        OS << getAttrName() << \"Attr::\" << enums[I] << \")\\n\";\n      }\n      OS << \"    .Default(Optional<\" << type << \">());\\n\";\n      OS << \"  if (R) {\\n\";\n      OS << \"    Out = *R;\\n      return true;\\n    }\\n\";\n      OS << \"  return false;\\n\";\n      OS << \"}\\n\\n\";\n\n      OS << \"const char *\" << getAttrName() << \"Attr::Convert\" << type\n         << \"ToStr(\" << type << \" Val) {\\n\"\n         << \"  switch(Val) {\\n\";\n      SmallDenseSet<StringRef, 8> Uniques;\n      for (size_t I = 0; I < enums.size(); ++I) {\n        if (Uniques.insert(enums[I]).second)\n          OS << \"  case \" << getAttrName() << \"Attr::\" << enums[I]\n             << \": return \\\"\" << values[I] << \"\\\";\\n\";\n      }\n      OS << \"  }\\n\"\n         << \"  llvm_unreachable(\\\"No enumerator with that value\\\");\\n\"\n         << \"}\\n\";\n    }\n  };\n\n  class VersionArgument : public Argument {\n  public:\n    VersionArgument(const Record &Arg, StringRef Attr)\n      : Argument(Arg, Attr)\n    {}\n\n    void writeAccessors(raw_ostream &OS) const override {\n      OS << \"  VersionTuple get\" << getUpperName() << \"() const {\\n\";\n      OS << \"    return \" << getLowerName() << \";\\n\";\n      OS << \"  }\\n\";\n      OS << \"  void set\" << getUpperName()\n         << \"(ASTContext &C, VersionTuple V) {\\n\";\n      OS << \"    \" << getLowerName() << \" = V;\\n\";\n      OS << \"  }\";\n    }\n\n    void writeCloneArgs(raw_ostream &OS) const override {\n      OS << \"get\" << getUpperName() << \"()\";\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      OS << \"A->get\" << getUpperName() << \"()\";\n    }\n\n    void writeCtorInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"(\" << getUpperName() << \")\";\n    }\n\n    void writeCtorDefaultInitializers(raw_ostream &OS) const override {\n      OS << getLowerName() << \"()\";\n    }\n\n    void writeCtorParameters(raw_ostream &OS) const override {\n      OS << \"VersionTuple \" << getUpperName();\n    }\n\n    void writeDeclarations(raw_ostream &OS) const override {\n      OS << \"VersionTuple \" << getLowerName() << \";\\n\";\n    }\n\n    void writePCHReadDecls(raw_ostream &OS) const override {\n      OS << \"    VersionTuple \" << getLowerName()\n         << \"= Record.readVersionTuple();\\n\";\n    }\n\n    void writePCHReadArgs(raw_ostream &OS) const override {\n      OS << getLowerName();\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"    Record.AddVersionTuple(SA->get\" << getUpperName() << \"());\\n\";\n    }\n\n    void writeValue(raw_ostream &OS) const override {\n      OS << getLowerName() << \"=\\\" << get\" << getUpperName() << \"() << \\\"\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {\n      OS << \"    OS << \\\" \\\" << SA->get\" << getUpperName() << \"();\\n\";\n    }\n  };\n\n  class ExprArgument : public SimpleArgument {\n  public:\n    ExprArgument(const Record &Arg, StringRef Attr)\n      : SimpleArgument(Arg, Attr, \"Expr *\")\n    {}\n\n    void writeASTVisitorTraversal(raw_ostream &OS) const override {\n      OS << \"  if (!\"\n         << \"getDerived().TraverseStmt(A->get\" << getUpperName() << \"()))\\n\";\n      OS << \"    return false;\\n\";\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      OS << \"tempInst\" << getUpperName();\n    }\n\n    void writeTemplateInstantiation(raw_ostream &OS) const override {\n      OS << \"      \" << getType() << \" tempInst\" << getUpperName() << \";\\n\";\n      OS << \"      {\\n\";\n      OS << \"        EnterExpressionEvaluationContext \"\n         << \"Unevaluated(S, Sema::ExpressionEvaluationContext::Unevaluated);\\n\";\n      OS << \"        ExprResult \" << \"Result = S.SubstExpr(\"\n         << \"A->get\" << getUpperName() << \"(), TemplateArgs);\\n\";\n      OS << \"        if (Result.isInvalid())\\n\";\n      OS << \"          return nullptr;\\n\";\n      OS << \"        tempInst\" << getUpperName() << \" = Result.get();\\n\";\n      OS << \"      }\\n\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {}\n\n    void writeDumpChildren(raw_ostream &OS) const override {\n      OS << \"    Visit(SA->get\" << getUpperName() << \"());\\n\";\n    }\n\n    void writeHasChildren(raw_ostream &OS) const override { OS << \"true\"; }\n  };\n\n  class VariadicExprArgument : public VariadicArgument {\n  public:\n    VariadicExprArgument(const Record &Arg, StringRef Attr)\n      : VariadicArgument(Arg, Attr, \"Expr *\")\n    {}\n\n    void writeASTVisitorTraversal(raw_ostream &OS) const override {\n      OS << \"  {\\n\";\n      OS << \"    \" << getType() << \" *I = A->\" << getLowerName()\n         << \"_begin();\\n\";\n      OS << \"    \" << getType() << \" *E = A->\" << getLowerName()\n         << \"_end();\\n\";\n      OS << \"    for (; I != E; ++I) {\\n\";\n      OS << \"      if (!getDerived().TraverseStmt(*I))\\n\";\n      OS << \"        return false;\\n\";\n      OS << \"    }\\n\";\n      OS << \"  }\\n\";\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      OS << \"tempInst\" << getUpperName() << \", \"\n         << \"A->\" << getLowerName() << \"_size()\";\n    }\n\n    void writeTemplateInstantiation(raw_ostream &OS) const override {\n      OS << \"      auto *tempInst\" << getUpperName()\n         << \" = new (C, 16) \" << getType()\n         << \"[A->\" << getLowerName() << \"_size()];\\n\";\n      OS << \"      {\\n\";\n      OS << \"        EnterExpressionEvaluationContext \"\n         << \"Unevaluated(S, Sema::ExpressionEvaluationContext::Unevaluated);\\n\";\n      OS << \"        \" << getType() << \" *TI = tempInst\" << getUpperName()\n         << \";\\n\";\n      OS << \"        \" << getType() << \" *I = A->\" << getLowerName()\n         << \"_begin();\\n\";\n      OS << \"        \" << getType() << \" *E = A->\" << getLowerName()\n         << \"_end();\\n\";\n      OS << \"        for (; I != E; ++I, ++TI) {\\n\";\n      OS << \"          ExprResult Result = S.SubstExpr(*I, TemplateArgs);\\n\";\n      OS << \"          if (Result.isInvalid())\\n\";\n      OS << \"            return nullptr;\\n\";\n      OS << \"          *TI = Result.get();\\n\";\n      OS << \"        }\\n\";\n      OS << \"      }\\n\";\n    }\n\n    void writeDump(raw_ostream &OS) const override {}\n\n    void writeDumpChildren(raw_ostream &OS) const override {\n      OS << \"    for (\" << getAttrName() << \"Attr::\" << getLowerName()\n         << \"_iterator I = SA->\" << getLowerName() << \"_begin(), E = SA->\"\n         << getLowerName() << \"_end(); I != E; ++I)\\n\";\n      OS << \"      Visit(*I);\\n\";\n    }\n\n    void writeHasChildren(raw_ostream &OS) const override {\n      OS << \"SA->\" << getLowerName() << \"_begin() != \"\n         << \"SA->\" << getLowerName() << \"_end()\";\n    }\n  };\n\n  class VariadicIdentifierArgument : public VariadicArgument {\n  public:\n    VariadicIdentifierArgument(const Record &Arg, StringRef Attr)\n      : VariadicArgument(Arg, Attr, \"IdentifierInfo *\")\n    {}\n  };\n\n  class VariadicStringArgument : public VariadicArgument {\n  public:\n    VariadicStringArgument(const Record &Arg, StringRef Attr)\n      : VariadicArgument(Arg, Attr, \"StringRef\")\n    {}\n\n    void writeCtorBody(raw_ostream &OS) const override {\n      OS << \"  for (size_t I = 0, E = \" << getArgSizeName() << \"; I != E;\\n\"\n            \"       ++I) {\\n\"\n            \"    StringRef Ref = \" << getUpperName() << \"[I];\\n\"\n            \"    if (!Ref.empty()) {\\n\"\n            \"      char *Mem = new (Ctx, 1) char[Ref.size()];\\n\"\n            \"      std::memcpy(Mem, Ref.data(), Ref.size());\\n\"\n            \"      \" << getArgName() << \"[I] = StringRef(Mem, Ref.size());\\n\"\n            \"    }\\n\"\n            \"  }\\n\";\n    }\n\n    void writeValueImpl(raw_ostream &OS) const override {\n      OS << \"    OS << \\\"\\\\\\\"\\\" << Val << \\\"\\\\\\\"\\\";\\n\";\n    }\n  };\n\n  class TypeArgument : public SimpleArgument {\n  public:\n    TypeArgument(const Record &Arg, StringRef Attr)\n      : SimpleArgument(Arg, Attr, \"TypeSourceInfo *\")\n    {}\n\n    void writeAccessors(raw_ostream &OS) const override {\n      OS << \"  QualType get\" << getUpperName() << \"() const {\\n\";\n      OS << \"    return \" << getLowerName() << \"->getType();\\n\";\n      OS << \"  }\";\n      OS << \"  \" << getType() << \" get\" << getUpperName() << \"Loc() const {\\n\";\n      OS << \"    return \" << getLowerName() << \";\\n\";\n      OS << \"  }\";\n    }\n\n    void writeASTVisitorTraversal(raw_ostream &OS) const override {\n      OS << \"  if (auto *TSI = A->get\" << getUpperName() << \"Loc())\\n\";\n      OS << \"    if (!getDerived().TraverseTypeLoc(TSI->getTypeLoc()))\\n\";\n      OS << \"      return false;\\n\";\n    }\n\n    void writeTemplateInstantiation(raw_ostream &OS) const override {\n      OS << \"      \" << getType() << \" tempInst\" << getUpperName() << \" =\\n\";\n      OS << \"        S.SubstType(A->get\" << getUpperName() << \"Loc(), \"\n         << \"TemplateArgs, A->getLoc(), A->getAttrName());\\n\";\n      OS << \"      if (!tempInst\" << getUpperName() << \")\\n\";\n      OS << \"        return nullptr;\\n\";\n    }\n\n    void writeTemplateInstantiationArgs(raw_ostream &OS) const override {\n      OS << \"tempInst\" << getUpperName();\n    }\n\n    void writePCHWrite(raw_ostream &OS) const override {\n      OS << \"    \"\n         << WritePCHRecord(getType(),\n                           \"SA->get\" + std::string(getUpperName()) + \"Loc()\");\n    }\n  };\n\n} // end anonymous namespace\n\nstatic std::unique_ptr<Argument>\ncreateArgument(const Record &Arg, StringRef Attr,\n               const Record *Search = nullptr) {\n  if (!Search)\n    Search = &Arg;\n\n  std::unique_ptr<Argument> Ptr;\n  llvm::StringRef ArgName = Search->getName();\n\n  if (ArgName == \"AlignedArgument\")\n    Ptr = std::make_unique<AlignedArgument>(Arg, Attr);\n  else if (ArgName == \"EnumArgument\")\n    Ptr = std::make_unique<EnumArgument>(Arg, Attr);\n  else if (ArgName == \"ExprArgument\")\n    Ptr = std::make_unique<ExprArgument>(Arg, Attr);\n  else if (ArgName == \"DeclArgument\")\n    Ptr = std::make_unique<SimpleArgument>(\n        Arg, Attr, (Arg.getValueAsDef(\"Kind\")->getName() + \"Decl *\").str());\n  else if (ArgName == \"IdentifierArgument\")\n    Ptr = std::make_unique<SimpleArgument>(Arg, Attr, \"IdentifierInfo *\");\n  else if (ArgName == \"DefaultBoolArgument\")\n    Ptr = std::make_unique<DefaultSimpleArgument>(\n        Arg, Attr, \"bool\", Arg.getValueAsBit(\"Default\"));\n  else if (ArgName == \"BoolArgument\")\n    Ptr = std::make_unique<SimpleArgument>(Arg, Attr, \"bool\");\n  else if (ArgName == \"DefaultIntArgument\")\n    Ptr = std::make_unique<DefaultSimpleArgument>(\n        Arg, Attr, \"int\", Arg.getValueAsInt(\"Default\"));\n  else if (ArgName == \"IntArgument\")\n    Ptr = std::make_unique<SimpleArgument>(Arg, Attr, \"int\");\n  else if (ArgName == \"StringArgument\")\n    Ptr = std::make_unique<StringArgument>(Arg, Attr);\n  else if (ArgName == \"TypeArgument\")\n    Ptr = std::make_unique<TypeArgument>(Arg, Attr);\n  else if (ArgName == \"UnsignedArgument\")\n    Ptr = std::make_unique<SimpleArgument>(Arg, Attr, \"unsigned\");\n  else if (ArgName == \"VariadicUnsignedArgument\")\n    Ptr = std::make_unique<VariadicArgument>(Arg, Attr, \"unsigned\");\n  else if (ArgName == \"VariadicStringArgument\")\n    Ptr = std::make_unique<VariadicStringArgument>(Arg, Attr);\n  else if (ArgName == \"VariadicEnumArgument\")\n    Ptr = std::make_unique<VariadicEnumArgument>(Arg, Attr);\n  else if (ArgName == \"VariadicExprArgument\")\n    Ptr = std::make_unique<VariadicExprArgument>(Arg, Attr);\n  else if (ArgName == \"VariadicParamIdxArgument\")\n    Ptr = std::make_unique<VariadicParamIdxArgument>(Arg, Attr);\n  else if (ArgName == \"VariadicParamOrParamIdxArgument\")\n    Ptr = std::make_unique<VariadicParamOrParamIdxArgument>(Arg, Attr);\n  else if (ArgName == \"ParamIdxArgument\")\n    Ptr = std::make_unique<SimpleArgument>(Arg, Attr, \"ParamIdx\");\n  else if (ArgName == \"VariadicIdentifierArgument\")\n    Ptr = std::make_unique<VariadicIdentifierArgument>(Arg, Attr);\n  else if (ArgName == \"VersionArgument\")\n    Ptr = std::make_unique<VersionArgument>(Arg, Attr);\n  else if (ArgName == \"OMPTraitInfoArgument\")\n    Ptr = std::make_unique<SimpleArgument>(Arg, Attr, \"OMPTraitInfo *\");\n\n  if (!Ptr) {\n    // Search in reverse order so that the most-derived type is handled first.\n    ArrayRef<std::pair<Record*, SMRange>> Bases = Search->getSuperClasses();\n    for (const auto &Base : llvm::reverse(Bases)) {\n      if ((Ptr = createArgument(Arg, Attr, Base.first)))\n        break;\n    }\n  }\n\n  if (Ptr && Arg.getValueAsBit(\"Optional\"))\n    Ptr->setOptional(true);\n\n  if (Ptr && Arg.getValueAsBit(\"Fake\"))\n    Ptr->setFake(true);\n\n  return Ptr;\n}\n\nstatic void writeAvailabilityValue(raw_ostream &OS) {\n  OS << \"\\\" << getPlatform()->getName();\\n\"\n     << \"  if (getStrict()) OS << \\\", strict\\\";\\n\"\n     << \"  if (!getIntroduced().empty()) OS << \\\", introduced=\\\" << getIntroduced();\\n\"\n     << \"  if (!getDeprecated().empty()) OS << \\\", deprecated=\\\" << getDeprecated();\\n\"\n     << \"  if (!getObsoleted().empty()) OS << \\\", obsoleted=\\\" << getObsoleted();\\n\"\n     << \"  if (getUnavailable()) OS << \\\", unavailable\\\";\\n\"\n     << \"  OS << \\\"\";\n}\n\nstatic void writeDeprecatedAttrValue(raw_ostream &OS, std::string &Variety) {\n  OS << \"\\\\\\\"\\\" << getMessage() << \\\"\\\\\\\"\\\";\\n\";\n  // Only GNU deprecated has an optional fixit argument at the second position.\n  if (Variety == \"GNU\")\n     OS << \"    if (!getReplacement().empty()) OS << \\\", \\\\\\\"\\\"\"\n           \" << getReplacement() << \\\"\\\\\\\"\\\";\\n\";\n  OS << \"    OS << \\\"\";\n}\n\nstatic void writeGetSpellingFunction(const Record &R, raw_ostream &OS) {\n  std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(R);\n\n  OS << \"const char *\" << R.getName() << \"Attr::getSpelling() const {\\n\";\n  if (Spellings.empty()) {\n    OS << \"  return \\\"(No spelling)\\\";\\n}\\n\\n\";\n    return;\n  }\n\n  OS << \"  switch (getAttributeSpellingListIndex()) {\\n\"\n        \"  default:\\n\"\n        \"    llvm_unreachable(\\\"Unknown attribute spelling!\\\");\\n\"\n        \"    return \\\"(No spelling)\\\";\\n\";\n\n  for (unsigned I = 0; I < Spellings.size(); ++I)\n    OS << \"  case \" << I << \":\\n\"\n          \"    return \\\"\" << Spellings[I].name() << \"\\\";\\n\";\n  // End of the switch statement.\n  OS << \"  }\\n\";\n  // End of the getSpelling function.\n  OS << \"}\\n\\n\";\n}\n\nstatic void\nwritePrettyPrintFunction(const Record &R,\n                         const std::vector<std::unique_ptr<Argument>> &Args,\n                         raw_ostream &OS) {\n  std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(R);\n\n  OS << \"void \" << R.getName() << \"Attr::printPretty(\"\n    << \"raw_ostream &OS, const PrintingPolicy &Policy) const {\\n\";\n\n  if (Spellings.empty()) {\n    OS << \"}\\n\\n\";\n    return;\n  }\n\n  OS << \"  bool IsFirstArgument = true; (void)IsFirstArgument;\\n\"\n     << \"  unsigned TrailingOmittedArgs = 0; (void)TrailingOmittedArgs;\\n\"\n     << \"  switch (getAttributeSpellingListIndex()) {\\n\"\n     << \"  default:\\n\"\n     << \"    llvm_unreachable(\\\"Unknown attribute spelling!\\\");\\n\"\n     << \"    break;\\n\";\n\n  for (unsigned I = 0; I < Spellings.size(); ++ I) {\n    llvm::SmallString<16> Prefix;\n    llvm::SmallString<8> Suffix;\n    // The actual spelling of the name and namespace (if applicable)\n    // of an attribute without considering prefix and suffix.\n    llvm::SmallString<64> Spelling;\n    std::string Name = Spellings[I].name();\n    std::string Variety = Spellings[I].variety();\n\n    if (Variety == \"GNU\") {\n      Prefix = \" __attribute__((\";\n      Suffix = \"))\";\n    } else if (Variety == \"CXX11\" || Variety == \"C2x\") {\n      Prefix = \" [[\";\n      Suffix = \"]]\";\n      std::string Namespace = Spellings[I].nameSpace();\n      if (!Namespace.empty()) {\n        Spelling += Namespace;\n        Spelling += \"::\";\n      }\n    } else if (Variety == \"Declspec\") {\n      Prefix = \" __declspec(\";\n      Suffix = \")\";\n    } else if (Variety == \"Microsoft\") {\n      Prefix = \"[\";\n      Suffix = \"]\";\n    } else if (Variety == \"Keyword\") {\n      Prefix = \" \";\n      Suffix = \"\";\n    } else if (Variety == \"Pragma\") {\n      Prefix = \"#pragma \";\n      Suffix = \"\\n\";\n      std::string Namespace = Spellings[I].nameSpace();\n      if (!Namespace.empty()) {\n        Spelling += Namespace;\n        Spelling += \" \";\n      }\n    } else {\n      llvm_unreachable(\"Unknown attribute syntax variety!\");\n    }\n\n    Spelling += Name;\n\n    OS << \"  case \" << I << \" : {\\n\"\n       << \"    OS << \\\"\" << Prefix << Spelling << \"\\\";\\n\";\n\n    if (Variety == \"Pragma\") {\n      OS << \"    printPrettyPragma(OS, Policy);\\n\";\n      OS << \"    OS << \\\"\\\\n\\\";\";\n      OS << \"    break;\\n\";\n      OS << \"  }\\n\";\n      continue;\n    }\n\n    if (Spelling == \"availability\") {\n      OS << \"    OS << \\\"(\";\n      writeAvailabilityValue(OS);\n      OS << \")\\\";\\n\";\n    } else if (Spelling == \"deprecated\" || Spelling == \"gnu::deprecated\") {\n      OS << \"    OS << \\\"(\";\n      writeDeprecatedAttrValue(OS, Variety);\n      OS << \")\\\";\\n\";\n    } else {\n      // To avoid printing parentheses around an empty argument list or\n      // printing spurious commas at the end of an argument list, we need to\n      // determine where the last provided non-fake argument is.\n      unsigned NonFakeArgs = 0;\n      bool FoundNonOptArg = false;\n      for (const auto &arg : llvm::reverse(Args)) {\n        if (arg->isFake())\n          continue;\n        ++NonFakeArgs;\n        if (FoundNonOptArg)\n          continue;\n        // FIXME: arg->getIsOmitted() == \"false\" means we haven't implemented\n        // any way to detect whether the argument was omitted.\n        if (!arg->isOptional() || arg->getIsOmitted() == \"false\") {\n          FoundNonOptArg = true;\n          continue;\n        }\n        OS << \"    if (\" << arg->getIsOmitted() << \")\\n\"\n           << \"      ++TrailingOmittedArgs;\\n\";\n      }\n      unsigned ArgIndex = 0;\n      for (const auto &arg : Args) {\n        if (arg->isFake())\n          continue;\n        std::string IsOmitted = arg->getIsOmitted();\n        if (arg->isOptional() && IsOmitted != \"false\")\n          OS << \"    if (!(\" << IsOmitted << \")) {\\n\";\n        // Variadic arguments print their own leading comma.\n        if (!arg->isVariadic())\n          OS << \"    DelimitAttributeArgument(OS, IsFirstArgument);\\n\";\n        OS << \"    OS << \\\"\";\n        arg->writeValue(OS);\n        OS << \"\\\";\\n\";\n        if (arg->isOptional() && IsOmitted != \"false\")\n          OS << \"    }\\n\";\n        ++ArgIndex;\n      }\n      if (ArgIndex != 0)\n        OS << \"    if (!IsFirstArgument)\\n\"\n           << \"      OS << \\\")\\\";\\n\";\n    }\n    OS << \"    OS << \\\"\" << Suffix << \"\\\";\\n\"\n       << \"    break;\\n\"\n       << \"  }\\n\";\n  }\n\n  // End of the switch statement.\n  OS << \"}\\n\";\n  // End of the print function.\n  OS << \"}\\n\\n\";\n}\n\n/// Return the index of a spelling in a spelling list.\nstatic unsigned\ngetSpellingListIndex(const std::vector<FlattenedSpelling> &SpellingList,\n                     const FlattenedSpelling &Spelling) {\n  assert(!SpellingList.empty() && \"Spelling list is empty!\");\n\n  for (unsigned Index = 0; Index < SpellingList.size(); ++Index) {\n    const FlattenedSpelling &S = SpellingList[Index];\n    if (S.variety() != Spelling.variety())\n      continue;\n    if (S.nameSpace() != Spelling.nameSpace())\n      continue;\n    if (S.name() != Spelling.name())\n      continue;\n\n    return Index;\n  }\n\n  llvm_unreachable(\"Unknown spelling!\");\n}\n\nstatic void writeAttrAccessorDefinition(const Record &R, raw_ostream &OS) {\n  std::vector<Record*> Accessors = R.getValueAsListOfDefs(\"Accessors\");\n  if (Accessors.empty())\n    return;\n\n  const std::vector<FlattenedSpelling> SpellingList = GetFlattenedSpellings(R);\n  assert(!SpellingList.empty() &&\n         \"Attribute with empty spelling list can't have accessors!\");\n  for (const auto *Accessor : Accessors) {\n    const StringRef Name = Accessor->getValueAsString(\"Name\");\n    std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(*Accessor);\n\n    OS << \"  bool \" << Name\n       << \"() const { return getAttributeSpellingListIndex() == \";\n    for (unsigned Index = 0; Index < Spellings.size(); ++Index) {\n      OS << getSpellingListIndex(SpellingList, Spellings[Index]);\n      if (Index != Spellings.size() - 1)\n        OS << \" ||\\n    getAttributeSpellingListIndex() == \";\n      else\n        OS << \"; }\\n\";\n    }\n  }\n}\n\nstatic bool\nSpellingNamesAreCommon(const std::vector<FlattenedSpelling>& Spellings) {\n  assert(!Spellings.empty() && \"An empty list of spellings was provided\");\n  std::string FirstName =\n      std::string(NormalizeNameForSpellingComparison(Spellings.front().name()));\n  for (const auto &Spelling :\n       llvm::make_range(std::next(Spellings.begin()), Spellings.end())) {\n    std::string Name =\n        std::string(NormalizeNameForSpellingComparison(Spelling.name()));\n    if (Name != FirstName)\n      return false;\n  }\n  return true;\n}\n\ntypedef std::map<unsigned, std::string> SemanticSpellingMap;\nstatic std::string\nCreateSemanticSpellings(const std::vector<FlattenedSpelling> &Spellings,\n                        SemanticSpellingMap &Map) {\n  // The enumerants are automatically generated based on the variety,\n  // namespace (if present) and name for each attribute spelling. However,\n  // care is taken to avoid trampling on the reserved namespace due to\n  // underscores.\n  std::string Ret(\"  enum Spelling {\\n\");\n  std::set<std::string> Uniques;\n  unsigned Idx = 0;\n\n  // If we have a need to have this many spellings we likely need to add an\n  // extra bit to the SpellingIndex in AttributeCommonInfo, then increase the\n  // value of SpellingNotCalculated there and here.\n  assert(Spellings.size() < 15 &&\n         \"Too many spellings, would step on SpellingNotCalculated in \"\n         \"AttributeCommonInfo\");\n  for (auto I = Spellings.begin(), E = Spellings.end(); I != E; ++I, ++Idx) {\n    const FlattenedSpelling &S = *I;\n    const std::string &Variety = S.variety();\n    const std::string &Spelling = S.name();\n    const std::string &Namespace = S.nameSpace();\n    std::string EnumName;\n\n    EnumName += (Variety + \"_\");\n    if (!Namespace.empty())\n      EnumName += (NormalizeNameForSpellingComparison(Namespace).str() +\n      \"_\");\n    EnumName += NormalizeNameForSpellingComparison(Spelling);\n\n    // Even if the name is not unique, this spelling index corresponds to a\n    // particular enumerant name that we've calculated.\n    Map[Idx] = EnumName;\n\n    // Since we have been stripping underscores to avoid trampling on the\n    // reserved namespace, we may have inadvertently created duplicate\n    // enumerant names. These duplicates are not considered part of the\n    // semantic spelling, and can be elided.\n    if (Uniques.find(EnumName) != Uniques.end())\n      continue;\n\n    Uniques.insert(EnumName);\n    if (I != Spellings.begin())\n      Ret += \",\\n\";\n    // Duplicate spellings are not considered part of the semantic spelling\n    // enumeration, but the spelling index and semantic spelling values are\n    // meant to be equivalent, so we must specify a concrete value for each\n    // enumerator.\n    Ret += \"    \" + EnumName + \" = \" + llvm::utostr(Idx);\n  }\n  Ret += \",\\n  SpellingNotCalculated = 15\\n\";\n  Ret += \"\\n  };\\n\\n\";\n  return Ret;\n}\n\nvoid WriteSemanticSpellingSwitch(const std::string &VarName,\n                                 const SemanticSpellingMap &Map,\n                                 raw_ostream &OS) {\n  OS << \"  switch (\" << VarName << \") {\\n    default: \"\n    << \"llvm_unreachable(\\\"Unknown spelling list index\\\");\\n\";\n  for (const auto &I : Map)\n    OS << \"    case \" << I.first << \": return \" << I.second << \";\\n\";\n  OS << \"  }\\n\";\n}\n\n// Emits the LateParsed property for attributes.\nstatic void emitClangAttrLateParsedList(RecordKeeper &Records, raw_ostream &OS) {\n  OS << \"#if defined(CLANG_ATTR_LATE_PARSED_LIST)\\n\";\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n\n  for (const auto *Attr : Attrs) {\n    bool LateParsed = Attr->getValueAsBit(\"LateParsed\");\n\n    if (LateParsed) {\n      std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(*Attr);\n\n      // FIXME: Handle non-GNU attributes\n      for (const auto &I : Spellings) {\n        if (I.variety() != \"GNU\")\n          continue;\n        OS << \".Case(\\\"\" << I.name() << \"\\\", \" << LateParsed << \")\\n\";\n      }\n    }\n  }\n  OS << \"#endif // CLANG_ATTR_LATE_PARSED_LIST\\n\\n\";\n}\n\nstatic bool hasGNUorCXX11Spelling(const Record &Attribute) {\n  std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(Attribute);\n  for (const auto &I : Spellings) {\n    if (I.variety() == \"GNU\" || I.variety() == \"CXX11\")\n      return true;\n  }\n  return false;\n}\n\nnamespace {\n\nstruct AttributeSubjectMatchRule {\n  const Record *MetaSubject;\n  const Record *Constraint;\n\n  AttributeSubjectMatchRule(const Record *MetaSubject, const Record *Constraint)\n      : MetaSubject(MetaSubject), Constraint(Constraint) {\n    assert(MetaSubject && \"Missing subject\");\n  }\n\n  bool isSubRule() const { return Constraint != nullptr; }\n\n  std::vector<Record *> getSubjects() const {\n    return (Constraint ? Constraint : MetaSubject)\n        ->getValueAsListOfDefs(\"Subjects\");\n  }\n\n  std::vector<Record *> getLangOpts() const {\n    if (Constraint) {\n      // Lookup the options in the sub-rule first, in case the sub-rule\n      // overrides the rules options.\n      std::vector<Record *> Opts = Constraint->getValueAsListOfDefs(\"LangOpts\");\n      if (!Opts.empty())\n        return Opts;\n    }\n    return MetaSubject->getValueAsListOfDefs(\"LangOpts\");\n  }\n\n  // Abstract rules are used only for sub-rules\n  bool isAbstractRule() const { return getSubjects().empty(); }\n\n  StringRef getName() const {\n    return (Constraint ? Constraint : MetaSubject)->getValueAsString(\"Name\");\n  }\n\n  bool isNegatedSubRule() const {\n    assert(isSubRule() && \"Not a sub-rule\");\n    return Constraint->getValueAsBit(\"Negated\");\n  }\n\n  std::string getSpelling() const {\n    std::string Result = std::string(MetaSubject->getValueAsString(\"Name\"));\n    if (isSubRule()) {\n      Result += '(';\n      if (isNegatedSubRule())\n        Result += \"unless(\";\n      Result += getName();\n      if (isNegatedSubRule())\n        Result += ')';\n      Result += ')';\n    }\n    return Result;\n  }\n\n  std::string getEnumValueName() const {\n    SmallString<128> Result;\n    Result += \"SubjectMatchRule_\";\n    Result += MetaSubject->getValueAsString(\"Name\");\n    if (isSubRule()) {\n      Result += \"_\";\n      if (isNegatedSubRule())\n        Result += \"not_\";\n      Result += Constraint->getValueAsString(\"Name\");\n    }\n    if (isAbstractRule())\n      Result += \"_abstract\";\n    return std::string(Result.str());\n  }\n\n  std::string getEnumValue() const { return \"attr::\" + getEnumValueName(); }\n\n  static const char *EnumName;\n};\n\nconst char *AttributeSubjectMatchRule::EnumName = \"attr::SubjectMatchRule\";\n\nstruct PragmaClangAttributeSupport {\n  std::vector<AttributeSubjectMatchRule> Rules;\n\n  class RuleOrAggregateRuleSet {\n    std::vector<AttributeSubjectMatchRule> Rules;\n    bool IsRule;\n    RuleOrAggregateRuleSet(ArrayRef<AttributeSubjectMatchRule> Rules,\n                           bool IsRule)\n        : Rules(Rules), IsRule(IsRule) {}\n\n  public:\n    bool isRule() const { return IsRule; }\n\n    const AttributeSubjectMatchRule &getRule() const {\n      assert(IsRule && \"not a rule!\");\n      return Rules[0];\n    }\n\n    ArrayRef<AttributeSubjectMatchRule> getAggregateRuleSet() const {\n      return Rules;\n    }\n\n    static RuleOrAggregateRuleSet\n    getRule(const AttributeSubjectMatchRule &Rule) {\n      return RuleOrAggregateRuleSet(Rule, /*IsRule=*/true);\n    }\n    static RuleOrAggregateRuleSet\n    getAggregateRuleSet(ArrayRef<AttributeSubjectMatchRule> Rules) {\n      return RuleOrAggregateRuleSet(Rules, /*IsRule=*/false);\n    }\n  };\n  llvm::DenseMap<const Record *, RuleOrAggregateRuleSet> SubjectsToRules;\n\n  PragmaClangAttributeSupport(RecordKeeper &Records);\n\n  bool isAttributedSupported(const Record &Attribute);\n\n  void emitMatchRuleList(raw_ostream &OS);\n\n  void generateStrictConformsTo(const Record &Attr, raw_ostream &OS);\n\n  void generateParsingHelpers(raw_ostream &OS);\n};\n\n} // end anonymous namespace\n\nstatic bool doesDeclDeriveFrom(const Record *D, const Record *Base) {\n  const Record *CurrentBase = D->getValueAsOptionalDef(BaseFieldName);\n  if (!CurrentBase)\n    return false;\n  if (CurrentBase == Base)\n    return true;\n  return doesDeclDeriveFrom(CurrentBase, Base);\n}\n\nPragmaClangAttributeSupport::PragmaClangAttributeSupport(\n    RecordKeeper &Records) {\n  std::vector<Record *> MetaSubjects =\n      Records.getAllDerivedDefinitions(\"AttrSubjectMatcherRule\");\n  auto MapFromSubjectsToRules = [this](const Record *SubjectContainer,\n                                       const Record *MetaSubject,\n                                       const Record *Constraint) {\n    Rules.emplace_back(MetaSubject, Constraint);\n    std::vector<Record *> ApplicableSubjects =\n        SubjectContainer->getValueAsListOfDefs(\"Subjects\");\n    for (const auto *Subject : ApplicableSubjects) {\n      bool Inserted =\n          SubjectsToRules\n              .try_emplace(Subject, RuleOrAggregateRuleSet::getRule(\n                                        AttributeSubjectMatchRule(MetaSubject,\n                                                                  Constraint)))\n              .second;\n      if (!Inserted) {\n        PrintFatalError(\"Attribute subject match rules should not represent\"\n                        \"same attribute subjects.\");\n      }\n    }\n  };\n  for (const auto *MetaSubject : MetaSubjects) {\n    MapFromSubjectsToRules(MetaSubject, MetaSubject, /*Constraints=*/nullptr);\n    std::vector<Record *> Constraints =\n        MetaSubject->getValueAsListOfDefs(\"Constraints\");\n    for (const auto *Constraint : Constraints)\n      MapFromSubjectsToRules(Constraint, MetaSubject, Constraint);\n  }\n\n  std::vector<Record *> Aggregates =\n      Records.getAllDerivedDefinitions(\"AttrSubjectMatcherAggregateRule\");\n  std::vector<Record *> DeclNodes =\n    Records.getAllDerivedDefinitions(DeclNodeClassName);\n  for (const auto *Aggregate : Aggregates) {\n    Record *SubjectDecl = Aggregate->getValueAsDef(\"Subject\");\n\n    // Gather sub-classes of the aggregate subject that act as attribute\n    // subject rules.\n    std::vector<AttributeSubjectMatchRule> Rules;\n    for (const auto *D : DeclNodes) {\n      if (doesDeclDeriveFrom(D, SubjectDecl)) {\n        auto It = SubjectsToRules.find(D);\n        if (It == SubjectsToRules.end())\n          continue;\n        if (!It->second.isRule() || It->second.getRule().isSubRule())\n          continue; // Assume that the rule will be included as well.\n        Rules.push_back(It->second.getRule());\n      }\n    }\n\n    bool Inserted =\n        SubjectsToRules\n            .try_emplace(SubjectDecl,\n                         RuleOrAggregateRuleSet::getAggregateRuleSet(Rules))\n            .second;\n    if (!Inserted) {\n      PrintFatalError(\"Attribute subject match rules should not represent\"\n                      \"same attribute subjects.\");\n    }\n  }\n}\n\nstatic PragmaClangAttributeSupport &\ngetPragmaAttributeSupport(RecordKeeper &Records) {\n  static PragmaClangAttributeSupport Instance(Records);\n  return Instance;\n}\n\nvoid PragmaClangAttributeSupport::emitMatchRuleList(raw_ostream &OS) {\n  OS << \"#ifndef ATTR_MATCH_SUB_RULE\\n\";\n  OS << \"#define ATTR_MATCH_SUB_RULE(Value, Spelling, IsAbstract, Parent, \"\n        \"IsNegated) \"\n     << \"ATTR_MATCH_RULE(Value, Spelling, IsAbstract)\\n\";\n  OS << \"#endif\\n\";\n  for (const auto &Rule : Rules) {\n    OS << (Rule.isSubRule() ? \"ATTR_MATCH_SUB_RULE\" : \"ATTR_MATCH_RULE\") << '(';\n    OS << Rule.getEnumValueName() << \", \\\"\" << Rule.getSpelling() << \"\\\", \"\n       << Rule.isAbstractRule();\n    if (Rule.isSubRule())\n      OS << \", \"\n         << AttributeSubjectMatchRule(Rule.MetaSubject, nullptr).getEnumValue()\n         << \", \" << Rule.isNegatedSubRule();\n    OS << \")\\n\";\n  }\n  OS << \"#undef ATTR_MATCH_SUB_RULE\\n\";\n}\n\nbool PragmaClangAttributeSupport::isAttributedSupported(\n    const Record &Attribute) {\n  // If the attribute explicitly specified whether to support #pragma clang\n  // attribute, use that setting.\n  bool Unset;\n  bool SpecifiedResult =\n    Attribute.getValueAsBitOrUnset(\"PragmaAttributeSupport\", Unset);\n  if (!Unset)\n    return SpecifiedResult;\n\n  // Opt-out rules:\n  // An attribute requires delayed parsing (LateParsed is on)\n  if (Attribute.getValueAsBit(\"LateParsed\"))\n    return false;\n  // An attribute has no GNU/CXX11 spelling\n  if (!hasGNUorCXX11Spelling(Attribute))\n    return false;\n  // An attribute subject list has a subject that isn't covered by one of the\n  // subject match rules or has no subjects at all.\n  if (Attribute.isValueUnset(\"Subjects\"))\n    return false;\n  const Record *SubjectObj = Attribute.getValueAsDef(\"Subjects\");\n  std::vector<Record *> Subjects = SubjectObj->getValueAsListOfDefs(\"Subjects\");\n  if (Subjects.empty())\n    return false;\n  for (const auto *Subject : Subjects) {\n    if (SubjectsToRules.find(Subject) == SubjectsToRules.end())\n      return false;\n  }\n  return true;\n}\n\nstatic std::string GenerateTestExpression(ArrayRef<Record *> LangOpts) {\n  std::string Test;\n\n  for (auto *E : LangOpts) {\n    if (!Test.empty())\n      Test += \" || \";\n\n    const StringRef Code = E->getValueAsString(\"CustomCode\");\n    if (!Code.empty()) {\n      Test += \"(\";\n      Test += Code;\n      Test += \")\";\n      if (!E->getValueAsString(\"Name\").empty()) {\n        PrintWarning(\n            E->getLoc(),\n            \"non-empty 'Name' field ignored because 'CustomCode' was supplied\");\n      }\n    } else {\n      Test += \"LangOpts.\";\n      Test += E->getValueAsString(\"Name\");\n    }\n  }\n\n  if (Test.empty())\n    return \"true\";\n\n  return Test;\n}\n\nvoid\nPragmaClangAttributeSupport::generateStrictConformsTo(const Record &Attr,\n                                                      raw_ostream &OS) {\n  if (!isAttributedSupported(Attr) || Attr.isValueUnset(\"Subjects\"))\n    return;\n  // Generate a function that constructs a set of matching rules that describe\n  // to which declarations the attribute should apply to.\n  OS << \"void getPragmaAttributeMatchRules(\"\n     << \"llvm::SmallVectorImpl<std::pair<\"\n     << AttributeSubjectMatchRule::EnumName\n     << \", bool>> &MatchRules, const LangOptions &LangOpts) const override {\\n\";\n  const Record *SubjectObj = Attr.getValueAsDef(\"Subjects\");\n  std::vector<Record *> Subjects = SubjectObj->getValueAsListOfDefs(\"Subjects\");\n  for (const auto *Subject : Subjects) {\n    auto It = SubjectsToRules.find(Subject);\n    assert(It != SubjectsToRules.end() &&\n           \"This attribute is unsupported by #pragma clang attribute\");\n    for (const auto &Rule : It->getSecond().getAggregateRuleSet()) {\n      // The rule might be language specific, so only subtract it from the given\n      // rules if the specific language options are specified.\n      std::vector<Record *> LangOpts = Rule.getLangOpts();\n      OS << \"  MatchRules.push_back(std::make_pair(\" << Rule.getEnumValue()\n         << \", /*IsSupported=*/\" << GenerateTestExpression(LangOpts)\n         << \"));\\n\";\n    }\n  }\n  OS << \"}\\n\\n\";\n}\n\nvoid PragmaClangAttributeSupport::generateParsingHelpers(raw_ostream &OS) {\n  // Generate routines that check the names of sub-rules.\n  OS << \"Optional<attr::SubjectMatchRule> \"\n        \"defaultIsAttributeSubjectMatchSubRuleFor(StringRef, bool) {\\n\";\n  OS << \"  return None;\\n\";\n  OS << \"}\\n\\n\";\n\n  std::map<const Record *, std::vector<AttributeSubjectMatchRule>>\n      SubMatchRules;\n  for (const auto &Rule : Rules) {\n    if (!Rule.isSubRule())\n      continue;\n    SubMatchRules[Rule.MetaSubject].push_back(Rule);\n  }\n\n  for (const auto &SubMatchRule : SubMatchRules) {\n    OS << \"Optional<attr::SubjectMatchRule> isAttributeSubjectMatchSubRuleFor_\"\n       << SubMatchRule.first->getValueAsString(\"Name\")\n       << \"(StringRef Name, bool IsUnless) {\\n\";\n    OS << \"  if (IsUnless)\\n\";\n    OS << \"    return \"\n          \"llvm::StringSwitch<Optional<attr::SubjectMatchRule>>(Name).\\n\";\n    for (const auto &Rule : SubMatchRule.second) {\n      if (Rule.isNegatedSubRule())\n        OS << \"    Case(\\\"\" << Rule.getName() << \"\\\", \" << Rule.getEnumValue()\n           << \").\\n\";\n    }\n    OS << \"    Default(None);\\n\";\n    OS << \"  return \"\n          \"llvm::StringSwitch<Optional<attr::SubjectMatchRule>>(Name).\\n\";\n    for (const auto &Rule : SubMatchRule.second) {\n      if (!Rule.isNegatedSubRule())\n        OS << \"  Case(\\\"\" << Rule.getName() << \"\\\", \" << Rule.getEnumValue()\n           << \").\\n\";\n    }\n    OS << \"  Default(None);\\n\";\n    OS << \"}\\n\\n\";\n  }\n\n  // Generate the function that checks for the top-level rules.\n  OS << \"std::pair<Optional<attr::SubjectMatchRule>, \"\n        \"Optional<attr::SubjectMatchRule> (*)(StringRef, \"\n        \"bool)> isAttributeSubjectMatchRule(StringRef Name) {\\n\";\n  OS << \"  return \"\n        \"llvm::StringSwitch<std::pair<Optional<attr::SubjectMatchRule>, \"\n        \"Optional<attr::SubjectMatchRule> (*) (StringRef, \"\n        \"bool)>>(Name).\\n\";\n  for (const auto &Rule : Rules) {\n    if (Rule.isSubRule())\n      continue;\n    std::string SubRuleFunction;\n    if (SubMatchRules.count(Rule.MetaSubject))\n      SubRuleFunction =\n          (\"isAttributeSubjectMatchSubRuleFor_\" + Rule.getName()).str();\n    else\n      SubRuleFunction = \"defaultIsAttributeSubjectMatchSubRuleFor\";\n    OS << \"  Case(\\\"\" << Rule.getName() << \"\\\", std::make_pair(\"\n       << Rule.getEnumValue() << \", \" << SubRuleFunction << \")).\\n\";\n  }\n  OS << \"  Default(std::make_pair(None, \"\n        \"defaultIsAttributeSubjectMatchSubRuleFor));\\n\";\n  OS << \"}\\n\\n\";\n\n  // Generate the function that checks for the submatch rules.\n  OS << \"const char *validAttributeSubjectMatchSubRules(\"\n     << AttributeSubjectMatchRule::EnumName << \" Rule) {\\n\";\n  OS << \"  switch (Rule) {\\n\";\n  for (const auto &SubMatchRule : SubMatchRules) {\n    OS << \"  case \"\n       << AttributeSubjectMatchRule(SubMatchRule.first, nullptr).getEnumValue()\n       << \":\\n\";\n    OS << \"  return \\\"'\";\n    bool IsFirst = true;\n    for (const auto &Rule : SubMatchRule.second) {\n      if (!IsFirst)\n        OS << \", '\";\n      IsFirst = false;\n      if (Rule.isNegatedSubRule())\n        OS << \"unless(\";\n      OS << Rule.getName();\n      if (Rule.isNegatedSubRule())\n        OS << ')';\n      OS << \"'\";\n    }\n    OS << \"\\\";\\n\";\n  }\n  OS << \"  default: return nullptr;\\n\";\n  OS << \"  }\\n\";\n  OS << \"}\\n\\n\";\n}\n\ntemplate <typename Fn>\nstatic void forEachUniqueSpelling(const Record &Attr, Fn &&F) {\n  std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(Attr);\n  SmallDenseSet<StringRef, 8> Seen;\n  for (const FlattenedSpelling &S : Spellings) {\n    if (Seen.insert(S.name()).second)\n      F(S);\n  }\n}\n\n/// Emits the first-argument-is-type property for attributes.\nstatic void emitClangAttrTypeArgList(RecordKeeper &Records, raw_ostream &OS) {\n  OS << \"#if defined(CLANG_ATTR_TYPE_ARG_LIST)\\n\";\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n\n  for (const auto *Attr : Attrs) {\n    // Determine whether the first argument is a type.\n    std::vector<Record *> Args = Attr->getValueAsListOfDefs(\"Args\");\n    if (Args.empty())\n      continue;\n\n    if (Args[0]->getSuperClasses().back().first->getName() != \"TypeArgument\")\n      continue;\n\n    // All these spellings take a single type argument.\n    forEachUniqueSpelling(*Attr, [&](const FlattenedSpelling &S) {\n      OS << \".Case(\\\"\" << S.name() << \"\\\", \" << \"true\" << \")\\n\";\n    });\n  }\n  OS << \"#endif // CLANG_ATTR_TYPE_ARG_LIST\\n\\n\";\n}\n\n/// Emits the parse-arguments-in-unevaluated-context property for\n/// attributes.\nstatic void emitClangAttrArgContextList(RecordKeeper &Records, raw_ostream &OS) {\n  OS << \"#if defined(CLANG_ATTR_ARG_CONTEXT_LIST)\\n\";\n  ParsedAttrMap Attrs = getParsedAttrList(Records);\n  for (const auto &I : Attrs) {\n    const Record &Attr = *I.second;\n\n    if (!Attr.getValueAsBit(\"ParseArgumentsAsUnevaluated\"))\n      continue;\n\n    // All these spellings take are parsed unevaluated.\n    forEachUniqueSpelling(Attr, [&](const FlattenedSpelling &S) {\n      OS << \".Case(\\\"\" << S.name() << \"\\\", \" << \"true\" << \")\\n\";\n    });\n  }\n  OS << \"#endif // CLANG_ATTR_ARG_CONTEXT_LIST\\n\\n\";\n}\n\nstatic bool isIdentifierArgument(Record *Arg) {\n  return !Arg->getSuperClasses().empty() &&\n    llvm::StringSwitch<bool>(Arg->getSuperClasses().back().first->getName())\n    .Case(\"IdentifierArgument\", true)\n    .Case(\"EnumArgument\", true)\n    .Case(\"VariadicEnumArgument\", true)\n    .Default(false);\n}\n\nstatic bool isVariadicIdentifierArgument(Record *Arg) {\n  return !Arg->getSuperClasses().empty() &&\n         llvm::StringSwitch<bool>(\n             Arg->getSuperClasses().back().first->getName())\n             .Case(\"VariadicIdentifierArgument\", true)\n             .Case(\"VariadicParamOrParamIdxArgument\", true)\n             .Default(false);\n}\n\nstatic void emitClangAttrVariadicIdentifierArgList(RecordKeeper &Records,\n                                                   raw_ostream &OS) {\n  OS << \"#if defined(CLANG_ATTR_VARIADIC_IDENTIFIER_ARG_LIST)\\n\";\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  for (const auto *A : Attrs) {\n    // Determine whether the first argument is a variadic identifier.\n    std::vector<Record *> Args = A->getValueAsListOfDefs(\"Args\");\n    if (Args.empty() || !isVariadicIdentifierArgument(Args[0]))\n      continue;\n\n    // All these spellings take an identifier argument.\n    forEachUniqueSpelling(*A, [&](const FlattenedSpelling &S) {\n      OS << \".Case(\\\"\" << S.name() << \"\\\", \"\n         << \"true\"\n         << \")\\n\";\n    });\n  }\n  OS << \"#endif // CLANG_ATTR_VARIADIC_IDENTIFIER_ARG_LIST\\n\\n\";\n}\n\n// Emits the first-argument-is-identifier property for attributes.\nstatic void emitClangAttrIdentifierArgList(RecordKeeper &Records, raw_ostream &OS) {\n  OS << \"#if defined(CLANG_ATTR_IDENTIFIER_ARG_LIST)\\n\";\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n\n  for (const auto *Attr : Attrs) {\n    // Determine whether the first argument is an identifier.\n    std::vector<Record *> Args = Attr->getValueAsListOfDefs(\"Args\");\n    if (Args.empty() || !isIdentifierArgument(Args[0]))\n      continue;\n\n    // All these spellings take an identifier argument.\n    forEachUniqueSpelling(*Attr, [&](const FlattenedSpelling &S) {\n      OS << \".Case(\\\"\" << S.name() << \"\\\", \" << \"true\" << \")\\n\";\n    });\n  }\n  OS << \"#endif // CLANG_ATTR_IDENTIFIER_ARG_LIST\\n\\n\";\n}\n\nstatic bool keywordThisIsaIdentifierInArgument(const Record *Arg) {\n  return !Arg->getSuperClasses().empty() &&\n         llvm::StringSwitch<bool>(\n             Arg->getSuperClasses().back().first->getName())\n             .Case(\"VariadicParamOrParamIdxArgument\", true)\n             .Default(false);\n}\n\nstatic void emitClangAttrThisIsaIdentifierArgList(RecordKeeper &Records,\n                                                  raw_ostream &OS) {\n  OS << \"#if defined(CLANG_ATTR_THIS_ISA_IDENTIFIER_ARG_LIST)\\n\";\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  for (const auto *A : Attrs) {\n    // Determine whether the first argument is a variadic identifier.\n    std::vector<Record *> Args = A->getValueAsListOfDefs(\"Args\");\n    if (Args.empty() || !keywordThisIsaIdentifierInArgument(Args[0]))\n      continue;\n\n    // All these spellings take an identifier argument.\n    forEachUniqueSpelling(*A, [&](const FlattenedSpelling &S) {\n      OS << \".Case(\\\"\" << S.name() << \"\\\", \"\n         << \"true\"\n         << \")\\n\";\n    });\n  }\n  OS << \"#endif // CLANG_ATTR_THIS_ISA_IDENTIFIER_ARG_LIST\\n\\n\";\n}\n\nstatic void emitAttributes(RecordKeeper &Records, raw_ostream &OS,\n                           bool Header) {\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  ParsedAttrMap AttrMap = getParsedAttrList(Records);\n\n  // Helper to print the starting character of an attribute argument. If there\n  // hasn't been an argument yet, it prints an opening parenthese; otherwise it\n  // prints a comma.\n  OS << \"static inline void DelimitAttributeArgument(\"\n     << \"raw_ostream& OS, bool& IsFirst) {\\n\"\n     << \"  if (IsFirst) {\\n\"\n     << \"    IsFirst = false;\\n\"\n     << \"    OS << \\\"(\\\";\\n\"\n     << \"  } else\\n\"\n     << \"    OS << \\\", \\\";\\n\"\n     << \"}\\n\";\n\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n\n    // FIXME: Currently, documentation is generated as-needed due to the fact\n    // that there is no way to allow a generated project \"reach into\" the docs\n    // directory (for instance, it may be an out-of-tree build). However, we want\n    // to ensure that every attribute has a Documentation field, and produce an\n    // error if it has been neglected. Otherwise, the on-demand generation which\n    // happens server-side will fail. This code is ensuring that functionality,\n    // even though this Emitter doesn't technically need the documentation.\n    // When attribute documentation can be generated as part of the build\n    // itself, this code can be removed.\n    (void)R.getValueAsListOfDefs(\"Documentation\");\n\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n\n    ArrayRef<std::pair<Record *, SMRange>> Supers = R.getSuperClasses();\n    assert(!Supers.empty() && \"Forgot to specify a superclass for the attr\");\n    std::string SuperName;\n    bool Inheritable = false;\n    for (const auto &Super : llvm::reverse(Supers)) {\n      const Record *R = Super.first;\n      if (R->getName() != \"TargetSpecificAttr\" &&\n          R->getName() != \"DeclOrTypeAttr\" && SuperName.empty())\n        SuperName = std::string(R->getName());\n      if (R->getName() == \"InheritableAttr\")\n        Inheritable = true;\n    }\n\n    if (Header)\n      OS << \"class \" << R.getName() << \"Attr : public \" << SuperName << \" {\\n\";\n    else\n      OS << \"\\n// \" << R.getName() << \"Attr implementation\\n\\n\";\n\n    std::vector<Record*> ArgRecords = R.getValueAsListOfDefs(\"Args\");\n    std::vector<std::unique_ptr<Argument>> Args;\n    Args.reserve(ArgRecords.size());\n\n    bool HasOptArg = false;\n    bool HasFakeArg = false;\n    for (const auto *ArgRecord : ArgRecords) {\n      Args.emplace_back(createArgument(*ArgRecord, R.getName()));\n      if (Header) {\n        Args.back()->writeDeclarations(OS);\n        OS << \"\\n\\n\";\n      }\n\n      // For these purposes, fake takes priority over optional.\n      if (Args.back()->isFake()) {\n        HasFakeArg = true;\n      } else if (Args.back()->isOptional()) {\n        HasOptArg = true;\n      }\n    }\n\n    if (Header)\n      OS << \"public:\\n\";\n\n    std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(R);\n\n    // If there are zero or one spellings, all spelling-related functionality\n    // can be elided. If all of the spellings share the same name, the spelling\n    // functionality can also be elided.\n    bool ElideSpelling = (Spellings.size() <= 1) ||\n                         SpellingNamesAreCommon(Spellings);\n\n    // This maps spelling index values to semantic Spelling enumerants.\n    SemanticSpellingMap SemanticToSyntacticMap;\n\n    std::string SpellingEnum;\n    if (Spellings.size() > 1)\n      SpellingEnum = CreateSemanticSpellings(Spellings, SemanticToSyntacticMap);\n    if (Header)\n      OS << SpellingEnum;\n\n    const auto &ParsedAttrSpellingItr = llvm::find_if(\n        AttrMap, [R](const std::pair<std::string, const Record *> &P) {\n          return &R == P.second;\n        });\n\n    // Emit CreateImplicit factory methods.\n    auto emitCreate = [&](bool Implicit, bool emitFake) {\n      if (Header)\n        OS << \"  static \";\n      OS << R.getName() << \"Attr *\";\n      if (!Header)\n        OS << R.getName() << \"Attr::\";\n      OS << \"Create\";\n      if (Implicit)\n        OS << \"Implicit\";\n      OS << \"(\";\n      OS << \"ASTContext &Ctx\";\n      for (auto const &ai : Args) {\n        if (ai->isFake() && !emitFake) continue;\n        OS << \", \";\n        ai->writeCtorParameters(OS);\n      }\n      OS << \", const AttributeCommonInfo &CommonInfo\";\n      if (Header && Implicit)\n        OS << \" = {SourceRange{}}\";\n      OS << \")\";\n      if (Header) {\n        OS << \";\\n\";\n        return;\n      }\n\n      OS << \" {\\n\";\n      OS << \"  auto *A = new (Ctx) \" << R.getName();\n      OS << \"Attr(Ctx, CommonInfo\";\n      for (auto const &ai : Args) {\n        if (ai->isFake() && !emitFake) continue;\n        OS << \", \";\n        ai->writeImplicitCtorArgs(OS);\n      }\n      OS << \");\\n\";\n      if (Implicit) {\n        OS << \"  A->setImplicit(true);\\n\";\n      }\n      if (Implicit || ElideSpelling) {\n        OS << \"  if (!A->isAttributeSpellingListCalculated() && \"\n              \"!A->getAttrName())\\n\";\n        OS << \"    A->setAttributeSpellingListIndex(0);\\n\";\n      }\n      OS << \"  return A;\\n}\\n\\n\";\n    };\n\n    auto emitCreateNoCI = [&](bool Implicit, bool emitFake) {\n      if (Header)\n        OS << \"  static \";\n      OS << R.getName() << \"Attr *\";\n      if (!Header)\n        OS << R.getName() << \"Attr::\";\n      OS << \"Create\";\n      if (Implicit)\n        OS << \"Implicit\";\n      OS << \"(\";\n      OS << \"ASTContext &Ctx\";\n      for (auto const &ai : Args) {\n        if (ai->isFake() && !emitFake) continue;\n        OS << \", \";\n        ai->writeCtorParameters(OS);\n      }\n      OS << \", SourceRange Range, AttributeCommonInfo::Syntax Syntax\";\n      if (!ElideSpelling) {\n        OS << \", \" << R.getName() << \"Attr::Spelling S\";\n        if (Header)\n          OS << \" = static_cast<Spelling>(SpellingNotCalculated)\";\n      }\n      OS << \")\";\n      if (Header) {\n        OS << \";\\n\";\n        return;\n      }\n\n      OS << \" {\\n\";\n      OS << \"  AttributeCommonInfo I(Range, \";\n\n      if (ParsedAttrSpellingItr != std::end(AttrMap))\n        OS << \"AT_\" << ParsedAttrSpellingItr->first;\n      else\n        OS << \"NoSemaHandlerAttribute\";\n\n      OS << \", Syntax\";\n      if (!ElideSpelling)\n        OS << \", S\";\n      OS << \");\\n\";\n      OS << \"  return Create\";\n      if (Implicit)\n        OS << \"Implicit\";\n      OS << \"(Ctx\";\n      for (auto const &ai : Args) {\n        if (ai->isFake() && !emitFake) continue;\n        OS << \", \";\n        ai->writeImplicitCtorArgs(OS);\n      }\n      OS << \", I);\\n\";\n      OS << \"}\\n\\n\";\n    };\n\n    auto emitCreates = [&](bool emitFake) {\n      emitCreate(true, emitFake);\n      emitCreate(false, emitFake);\n      emitCreateNoCI(true, emitFake);\n      emitCreateNoCI(false, emitFake);\n    };\n\n    if (Header)\n      OS << \"  // Factory methods\\n\";\n\n    // Emit a CreateImplicit that takes all the arguments.\n    emitCreates(true);\n\n    // Emit a CreateImplicit that takes all the non-fake arguments.\n    if (HasFakeArg)\n      emitCreates(false);\n\n    // Emit constructors.\n    auto emitCtor = [&](bool emitOpt, bool emitFake) {\n      auto shouldEmitArg = [=](const std::unique_ptr<Argument> &arg) {\n        if (arg->isFake()) return emitFake;\n        if (arg->isOptional()) return emitOpt;\n        return true;\n      };\n      if (Header)\n        OS << \"  \";\n      else\n        OS << R.getName() << \"Attr::\";\n      OS << R.getName()\n         << \"Attr(ASTContext &Ctx, const AttributeCommonInfo &CommonInfo\";\n      OS << '\\n';\n      for (auto const &ai : Args) {\n        if (!shouldEmitArg(ai)) continue;\n        OS << \"              , \";\n        ai->writeCtorParameters(OS);\n        OS << \"\\n\";\n      }\n\n      OS << \"             )\";\n      if (Header) {\n        OS << \";\\n\";\n        return;\n      }\n      OS << \"\\n  : \" << SuperName << \"(Ctx, CommonInfo, \";\n      OS << \"attr::\" << R.getName() << \", \"\n         << (R.getValueAsBit(\"LateParsed\") ? \"true\" : \"false\");\n      if (Inheritable) {\n        OS << \", \"\n           << (R.getValueAsBit(\"InheritEvenIfAlreadyPresent\") ? \"true\"\n                                                              : \"false\");\n      }\n      OS << \")\\n\";\n\n      for (auto const &ai : Args) {\n        OS << \"              , \";\n        if (!shouldEmitArg(ai)) {\n          ai->writeCtorDefaultInitializers(OS);\n        } else {\n          ai->writeCtorInitializers(OS);\n        }\n        OS << \"\\n\";\n      }\n\n      OS << \"  {\\n\";\n\n      for (auto const &ai : Args) {\n        if (!shouldEmitArg(ai)) continue;\n        ai->writeCtorBody(OS);\n      }\n      OS << \"}\\n\\n\";\n    };\n\n    if (Header)\n      OS << \"\\n  // Constructors\\n\";\n\n    // Emit a constructor that includes all the arguments.\n    // This is necessary for cloning.\n    emitCtor(true, true);\n\n    // Emit a constructor that takes all the non-fake arguments.\n    if (HasFakeArg)\n      emitCtor(true, false);\n\n    // Emit a constructor that takes all the non-fake, non-optional arguments.\n    if (HasOptArg)\n      emitCtor(false, false);\n\n    if (Header) {\n      OS << '\\n';\n      OS << \"  \" << R.getName() << \"Attr *clone(ASTContext &C) const;\\n\";\n      OS << \"  void printPretty(raw_ostream &OS,\\n\"\n         << \"                   const PrintingPolicy &Policy) const;\\n\";\n      OS << \"  const char *getSpelling() const;\\n\";\n    }\n\n    if (!ElideSpelling) {\n      assert(!SemanticToSyntacticMap.empty() && \"Empty semantic mapping list\");\n      if (Header)\n        OS << \"  Spelling getSemanticSpelling() const;\\n\";\n      else {\n        OS << R.getName() << \"Attr::Spelling \" << R.getName()\n           << \"Attr::getSemanticSpelling() const {\\n\";\n        WriteSemanticSpellingSwitch(\"getAttributeSpellingListIndex()\",\n                                    SemanticToSyntacticMap, OS);\n        OS << \"}\\n\";\n      }\n    }\n\n    if (Header)\n      writeAttrAccessorDefinition(R, OS);\n\n    for (auto const &ai : Args) {\n      if (Header) {\n        ai->writeAccessors(OS);\n      } else {\n        ai->writeAccessorDefinitions(OS);\n      }\n      OS << \"\\n\\n\";\n\n      // Don't write conversion routines for fake arguments.\n      if (ai->isFake()) continue;\n\n      if (ai->isEnumArg())\n        static_cast<const EnumArgument *>(ai.get())->writeConversion(OS,\n                                                                     Header);\n      else if (ai->isVariadicEnumArg())\n        static_cast<const VariadicEnumArgument *>(ai.get())->writeConversion(\n            OS, Header);\n    }\n\n    if (Header) {\n      OS << R.getValueAsString(\"AdditionalMembers\");\n      OS << \"\\n\\n\";\n\n      OS << \"  static bool classof(const Attr *A) { return A->getKind() == \"\n         << \"attr::\" << R.getName() << \"; }\\n\";\n\n      OS << \"};\\n\\n\";\n    } else {\n      OS << R.getName() << \"Attr *\" << R.getName()\n         << \"Attr::clone(ASTContext &C) const {\\n\";\n      OS << \"  auto *A = new (C) \" << R.getName() << \"Attr(C, *this\";\n      for (auto const &ai : Args) {\n        OS << \", \";\n        ai->writeCloneArgs(OS);\n      }\n      OS << \");\\n\";\n      OS << \"  A->Inherited = Inherited;\\n\";\n      OS << \"  A->IsPackExpansion = IsPackExpansion;\\n\";\n      OS << \"  A->setImplicit(Implicit);\\n\";\n      OS << \"  return A;\\n}\\n\\n\";\n\n      writePrettyPrintFunction(R, Args, OS);\n      writeGetSpellingFunction(R, OS);\n    }\n  }\n}\n// Emits the class definitions for attributes.\nvoid clang::EmitClangAttrClass(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Attribute classes' definitions\", OS);\n\n  OS << \"#ifndef LLVM_CLANG_ATTR_CLASSES_INC\\n\";\n  OS << \"#define LLVM_CLANG_ATTR_CLASSES_INC\\n\\n\";\n\n  emitAttributes(Records, OS, true);\n\n  OS << \"#endif // LLVM_CLANG_ATTR_CLASSES_INC\\n\";\n}\n\n// Emits the class method definitions for attributes.\nvoid clang::EmitClangAttrImpl(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Attribute classes' member function definitions\", OS);\n\n  emitAttributes(Records, OS, false);\n\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n\n  // Instead of relying on virtual dispatch we just create a huge dispatch\n  // switch. This is both smaller and faster than virtual functions.\n  auto EmitFunc = [&](const char *Method) {\n    OS << \"  switch (getKind()) {\\n\";\n    for (const auto *Attr : Attrs) {\n      const Record &R = *Attr;\n      if (!R.getValueAsBit(\"ASTNode\"))\n        continue;\n\n      OS << \"  case attr::\" << R.getName() << \":\\n\";\n      OS << \"    return cast<\" << R.getName() << \"Attr>(this)->\" << Method\n         << \";\\n\";\n    }\n    OS << \"  }\\n\";\n    OS << \"  llvm_unreachable(\\\"Unexpected attribute kind!\\\");\\n\";\n    OS << \"}\\n\\n\";\n  };\n\n  OS << \"const char *Attr::getSpelling() const {\\n\";\n  EmitFunc(\"getSpelling()\");\n\n  OS << \"Attr *Attr::clone(ASTContext &C) const {\\n\";\n  EmitFunc(\"clone(C)\");\n\n  OS << \"void Attr::printPretty(raw_ostream &OS, \"\n        \"const PrintingPolicy &Policy) const {\\n\";\n  EmitFunc(\"printPretty(OS, Policy)\");\n}\n\nstatic void emitAttrList(raw_ostream &OS, StringRef Class,\n                         const std::vector<Record*> &AttrList) {\n  for (auto Cur : AttrList) {\n    OS << Class << \"(\" << Cur->getName() << \")\\n\";\n  }\n}\n\n// Determines if an attribute has a Pragma spelling.\nstatic bool AttrHasPragmaSpelling(const Record *R) {\n  std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(*R);\n  return llvm::find_if(Spellings, [](const FlattenedSpelling &S) {\n           return S.variety() == \"Pragma\";\n         }) != Spellings.end();\n}\n\nnamespace {\n\n  struct AttrClassDescriptor {\n    const char * const MacroName;\n    const char * const TableGenName;\n  };\n\n} // end anonymous namespace\n\nstatic const AttrClassDescriptor AttrClassDescriptors[] = {\n  { \"ATTR\", \"Attr\" },\n  { \"TYPE_ATTR\", \"TypeAttr\" },\n  { \"STMT_ATTR\", \"StmtAttr\" },\n  { \"DECL_OR_STMT_ATTR\", \"DeclOrStmtAttr\" },\n  { \"INHERITABLE_ATTR\", \"InheritableAttr\" },\n  { \"DECL_OR_TYPE_ATTR\", \"DeclOrTypeAttr\" },\n  { \"INHERITABLE_PARAM_ATTR\", \"InheritableParamAttr\" },\n  { \"PARAMETER_ABI_ATTR\", \"ParameterABIAttr\" }\n};\n\nstatic void emitDefaultDefine(raw_ostream &OS, StringRef name,\n                              const char *superName) {\n  OS << \"#ifndef \" << name << \"\\n\";\n  OS << \"#define \" << name << \"(NAME) \";\n  if (superName) OS << superName << \"(NAME)\";\n  OS << \"\\n#endif\\n\\n\";\n}\n\nnamespace {\n\n  /// A class of attributes.\n  struct AttrClass {\n    const AttrClassDescriptor &Descriptor;\n    Record *TheRecord;\n    AttrClass *SuperClass = nullptr;\n    std::vector<AttrClass*> SubClasses;\n    std::vector<Record*> Attrs;\n\n    AttrClass(const AttrClassDescriptor &Descriptor, Record *R)\n      : Descriptor(Descriptor), TheRecord(R) {}\n\n    void emitDefaultDefines(raw_ostream &OS) const {\n      // Default the macro unless this is a root class (i.e. Attr).\n      if (SuperClass) {\n        emitDefaultDefine(OS, Descriptor.MacroName,\n                          SuperClass->Descriptor.MacroName);\n      }\n    }\n\n    void emitUndefs(raw_ostream &OS) const {\n      OS << \"#undef \" << Descriptor.MacroName << \"\\n\";\n    }\n\n    void emitAttrList(raw_ostream &OS) const {\n      for (auto SubClass : SubClasses) {\n        SubClass->emitAttrList(OS);\n      }\n\n      ::emitAttrList(OS, Descriptor.MacroName, Attrs);\n    }\n\n    void classifyAttrOnRoot(Record *Attr) {\n      bool result = classifyAttr(Attr);\n      assert(result && \"failed to classify on root\"); (void) result;\n    }\n\n    void emitAttrRange(raw_ostream &OS) const {\n      OS << \"ATTR_RANGE(\" << Descriptor.TableGenName\n         << \", \" << getFirstAttr()->getName()\n         << \", \" << getLastAttr()->getName() << \")\\n\";\n    }\n\n  private:\n    bool classifyAttr(Record *Attr) {\n      // Check all the subclasses.\n      for (auto SubClass : SubClasses) {\n        if (SubClass->classifyAttr(Attr))\n          return true;\n      }\n\n      // It's not more specific than this class, but it might still belong here.\n      if (Attr->isSubClassOf(TheRecord)) {\n        Attrs.push_back(Attr);\n        return true;\n      }\n\n      return false;\n    }\n\n    Record *getFirstAttr() const {\n      if (!SubClasses.empty())\n        return SubClasses.front()->getFirstAttr();\n      return Attrs.front();\n    }\n\n    Record *getLastAttr() const {\n      if (!Attrs.empty())\n        return Attrs.back();\n      return SubClasses.back()->getLastAttr();\n    }\n  };\n\n  /// The entire hierarchy of attribute classes.\n  class AttrClassHierarchy {\n    std::vector<std::unique_ptr<AttrClass>> Classes;\n\n  public:\n    AttrClassHierarchy(RecordKeeper &Records) {\n      // Find records for all the classes.\n      for (auto &Descriptor : AttrClassDescriptors) {\n        Record *ClassRecord = Records.getClass(Descriptor.TableGenName);\n        AttrClass *Class = new AttrClass(Descriptor, ClassRecord);\n        Classes.emplace_back(Class);\n      }\n\n      // Link up the hierarchy.\n      for (auto &Class : Classes) {\n        if (AttrClass *SuperClass = findSuperClass(Class->TheRecord)) {\n          Class->SuperClass = SuperClass;\n          SuperClass->SubClasses.push_back(Class.get());\n        }\n      }\n\n#ifndef NDEBUG\n      for (auto i = Classes.begin(), e = Classes.end(); i != e; ++i) {\n        assert((i == Classes.begin()) == ((*i)->SuperClass == nullptr) &&\n               \"only the first class should be a root class!\");\n      }\n#endif\n    }\n\n    void emitDefaultDefines(raw_ostream &OS) const {\n      for (auto &Class : Classes) {\n        Class->emitDefaultDefines(OS);\n      }\n    }\n\n    void emitUndefs(raw_ostream &OS) const {\n      for (auto &Class : Classes) {\n        Class->emitUndefs(OS);\n      }\n    }\n\n    void emitAttrLists(raw_ostream &OS) const {\n      // Just start from the root class.\n      Classes[0]->emitAttrList(OS);\n    }\n\n    void emitAttrRanges(raw_ostream &OS) const {\n      for (auto &Class : Classes)\n        Class->emitAttrRange(OS);\n    }\n\n    void classifyAttr(Record *Attr) {\n      // Add the attribute to the root class.\n      Classes[0]->classifyAttrOnRoot(Attr);\n    }\n\n  private:\n    AttrClass *findClassByRecord(Record *R) const {\n      for (auto &Class : Classes) {\n        if (Class->TheRecord == R)\n          return Class.get();\n      }\n      return nullptr;\n    }\n\n    AttrClass *findSuperClass(Record *R) const {\n      // TableGen flattens the superclass list, so we just need to walk it\n      // in reverse.\n      auto SuperClasses = R->getSuperClasses();\n      for (signed i = 0, e = SuperClasses.size(); i != e; ++i) {\n        auto SuperClass = findClassByRecord(SuperClasses[e - i - 1].first);\n        if (SuperClass) return SuperClass;\n      }\n      return nullptr;\n    }\n  };\n\n} // end anonymous namespace\n\nnamespace clang {\n\n// Emits the enumeration list for attributes.\nvoid EmitClangAttrList(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"List of all attributes that Clang recognizes\", OS);\n\n  AttrClassHierarchy Hierarchy(Records);\n\n  // Add defaulting macro definitions.\n  Hierarchy.emitDefaultDefines(OS);\n  emitDefaultDefine(OS, \"PRAGMA_SPELLING_ATTR\", nullptr);\n\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  std::vector<Record *> PragmaAttrs;\n  for (auto *Attr : Attrs) {\n    if (!Attr->getValueAsBit(\"ASTNode\"))\n      continue;\n\n    // Add the attribute to the ad-hoc groups.\n    if (AttrHasPragmaSpelling(Attr))\n      PragmaAttrs.push_back(Attr);\n\n    // Place it in the hierarchy.\n    Hierarchy.classifyAttr(Attr);\n  }\n\n  // Emit the main attribute list.\n  Hierarchy.emitAttrLists(OS);\n\n  // Emit the ad hoc groups.\n  emitAttrList(OS, \"PRAGMA_SPELLING_ATTR\", PragmaAttrs);\n\n  // Emit the attribute ranges.\n  OS << \"#ifdef ATTR_RANGE\\n\";\n  Hierarchy.emitAttrRanges(OS);\n  OS << \"#undef ATTR_RANGE\\n\";\n  OS << \"#endif\\n\";\n\n  Hierarchy.emitUndefs(OS);\n  OS << \"#undef PRAGMA_SPELLING_ATTR\\n\";\n}\n\n// Emits the enumeration list for attributes.\nvoid EmitClangAttrSubjectMatchRuleList(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\n      \"List of all attribute subject matching rules that Clang recognizes\", OS);\n  PragmaClangAttributeSupport &PragmaAttributeSupport =\n      getPragmaAttributeSupport(Records);\n  emitDefaultDefine(OS, \"ATTR_MATCH_RULE\", nullptr);\n  PragmaAttributeSupport.emitMatchRuleList(OS);\n  OS << \"#undef ATTR_MATCH_RULE\\n\";\n}\n\n// Emits the code to read an attribute from a precompiled header.\nvoid EmitClangAttrPCHRead(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Attribute deserialization code\", OS);\n\n  Record *InhClass = Records.getClass(\"InheritableAttr\");\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\"),\n                       ArgRecords;\n  std::vector<std::unique_ptr<Argument>> Args;\n\n  OS << \"  switch (Kind) {\\n\";\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n\n    OS << \"  case attr::\" << R.getName() << \": {\\n\";\n    if (R.isSubClassOf(InhClass))\n      OS << \"    bool isInherited = Record.readInt();\\n\";\n    OS << \"    bool isImplicit = Record.readInt();\\n\";\n    OS << \"    bool isPackExpansion = Record.readInt();\\n\";\n    ArgRecords = R.getValueAsListOfDefs(\"Args\");\n    Args.clear();\n    for (const auto *Arg : ArgRecords) {\n      Args.emplace_back(createArgument(*Arg, R.getName()));\n      Args.back()->writePCHReadDecls(OS);\n    }\n    OS << \"    New = new (Context) \" << R.getName() << \"Attr(Context, Info\";\n    for (auto const &ri : Args) {\n      OS << \", \";\n      ri->writePCHReadArgs(OS);\n    }\n    OS << \");\\n\";\n    if (R.isSubClassOf(InhClass))\n      OS << \"    cast<InheritableAttr>(New)->setInherited(isInherited);\\n\";\n    OS << \"    New->setImplicit(isImplicit);\\n\";\n    OS << \"    New->setPackExpansion(isPackExpansion);\\n\";\n    OS << \"    break;\\n\";\n    OS << \"  }\\n\";\n  }\n  OS << \"  }\\n\";\n}\n\n// Emits the code to write an attribute to a precompiled header.\nvoid EmitClangAttrPCHWrite(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Attribute serialization code\", OS);\n\n  Record *InhClass = Records.getClass(\"InheritableAttr\");\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\"), Args;\n\n  OS << \"  switch (A->getKind()) {\\n\";\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n    OS << \"  case attr::\" << R.getName() << \": {\\n\";\n    Args = R.getValueAsListOfDefs(\"Args\");\n    if (R.isSubClassOf(InhClass) || !Args.empty())\n      OS << \"    const auto *SA = cast<\" << R.getName()\n         << \"Attr>(A);\\n\";\n    if (R.isSubClassOf(InhClass))\n      OS << \"    Record.push_back(SA->isInherited());\\n\";\n    OS << \"    Record.push_back(A->isImplicit());\\n\";\n    OS << \"    Record.push_back(A->isPackExpansion());\\n\";\n\n    for (const auto *Arg : Args)\n      createArgument(*Arg, R.getName())->writePCHWrite(OS);\n    OS << \"    break;\\n\";\n    OS << \"  }\\n\";\n  }\n  OS << \"  }\\n\";\n}\n\n// Helper function for GenerateTargetSpecificAttrChecks that alters the 'Test'\n// parameter with only a single check type, if applicable.\nstatic bool GenerateTargetSpecificAttrCheck(const Record *R, std::string &Test,\n                                            std::string *FnName,\n                                            StringRef ListName,\n                                            StringRef CheckAgainst,\n                                            StringRef Scope) {\n  if (!R->isValueUnset(ListName)) {\n    Test += \" && (\";\n    std::vector<StringRef> Items = R->getValueAsListOfStrings(ListName);\n    for (auto I = Items.begin(), E = Items.end(); I != E; ++I) {\n      StringRef Part = *I;\n      Test += CheckAgainst;\n      Test += \" == \";\n      Test += Scope;\n      Test += Part;\n      if (I + 1 != E)\n        Test += \" || \";\n      if (FnName)\n        *FnName += Part;\n    }\n    Test += \")\";\n    return true;\n  }\n  return false;\n}\n\n// Generate a conditional expression to check if the current target satisfies\n// the conditions for a TargetSpecificAttr record, and append the code for\n// those checks to the Test string. If the FnName string pointer is non-null,\n// append a unique suffix to distinguish this set of target checks from other\n// TargetSpecificAttr records.\nstatic bool GenerateTargetSpecificAttrChecks(const Record *R,\n                                             std::vector<StringRef> &Arches,\n                                             std::string &Test,\n                                             std::string *FnName) {\n  bool AnyTargetChecks = false;\n\n  // It is assumed that there will be an llvm::Triple object\n  // named \"T\" and a TargetInfo object named \"Target\" within\n  // scope that can be used to determine whether the attribute exists in\n  // a given target.\n  Test += \"true\";\n  // If one or more architectures is specified, check those.  Arches are handled\n  // differently because GenerateTargetRequirements needs to combine the list\n  // with ParseKind.\n  if (!Arches.empty()) {\n    AnyTargetChecks = true;\n    Test += \" && (\";\n    for (auto I = Arches.begin(), E = Arches.end(); I != E; ++I) {\n      StringRef Part = *I;\n      Test += \"T.getArch() == llvm::Triple::\";\n      Test += Part;\n      if (I + 1 != E)\n        Test += \" || \";\n      if (FnName)\n        *FnName += Part;\n    }\n    Test += \")\";\n  }\n\n  // If the attribute is specific to particular OSes, check those.\n  AnyTargetChecks |= GenerateTargetSpecificAttrCheck(\n      R, Test, FnName, \"OSes\", \"T.getOS()\", \"llvm::Triple::\");\n\n  // If one or more object formats is specified, check those.\n  AnyTargetChecks |=\n      GenerateTargetSpecificAttrCheck(R, Test, FnName, \"ObjectFormats\",\n                                      \"T.getObjectFormat()\", \"llvm::Triple::\");\n\n  // If custom code is specified, emit it.\n  StringRef Code = R->getValueAsString(\"CustomCode\");\n  if (!Code.empty()) {\n    AnyTargetChecks = true;\n    Test += \" && (\";\n    Test += Code;\n    Test += \")\";\n  }\n\n  return AnyTargetChecks;\n}\n\nstatic void GenerateHasAttrSpellingStringSwitch(\n    const std::vector<Record *> &Attrs, raw_ostream &OS,\n    const std::string &Variety = \"\", const std::string &Scope = \"\") {\n  for (const auto *Attr : Attrs) {\n    // C++11-style attributes have specific version information associated with\n    // them. If the attribute has no scope, the version information must not\n    // have the default value (1), as that's incorrect. Instead, the unscoped\n    // attribute version information should be taken from the SD-6 standing\n    // document, which can be found at:\n    // https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations\n    //\n    // C2x-style attributes have the same kind of version information\n    // associated with them. The unscoped attribute version information should\n    // be taken from the specification of the attribute in the C Standard.\n    int Version = 1;\n\n    if (Variety == \"CXX11\" || Variety == \"C2x\") {\n      std::vector<Record *> Spellings = Attr->getValueAsListOfDefs(\"Spellings\");\n      for (const auto &Spelling : Spellings) {\n        if (Spelling->getValueAsString(\"Variety\") == Variety) {\n          Version = static_cast<int>(Spelling->getValueAsInt(\"Version\"));\n          if (Scope.empty() && Version == 1)\n            PrintError(Spelling->getLoc(), \"Standard attributes must have \"\n                                           \"valid version information.\");\n          break;\n        }\n      }\n    }\n\n    std::string Test;\n    if (Attr->isSubClassOf(\"TargetSpecificAttr\")) {\n      const Record *R = Attr->getValueAsDef(\"Target\");\n      std::vector<StringRef> Arches = R->getValueAsListOfStrings(\"Arches\");\n      GenerateTargetSpecificAttrChecks(R, Arches, Test, nullptr);\n\n      // If this is the C++11 variety, also add in the LangOpts test.\n      if (Variety == \"CXX11\")\n        Test += \" && LangOpts.CPlusPlus11\";\n      else if (Variety == \"C2x\")\n        Test += \" && LangOpts.DoubleSquareBracketAttributes\";\n    } else if (Variety == \"CXX11\")\n      // C++11 mode should be checked against LangOpts, which is presumed to be\n      // present in the caller.\n      Test = \"LangOpts.CPlusPlus11\";\n    else if (Variety == \"C2x\")\n      Test = \"LangOpts.DoubleSquareBracketAttributes\";\n\n    std::string TestStr =\n        !Test.empty() ? Test + \" ? \" + llvm::itostr(Version) + \" : 0\" : \"1\";\n    std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(*Attr);\n    for (const auto &S : Spellings)\n      if (Variety.empty() || (Variety == S.variety() &&\n                              (Scope.empty() || Scope == S.nameSpace())))\n        OS << \"    .Case(\\\"\" << S.name() << \"\\\", \" << TestStr << \")\\n\";\n  }\n  OS << \"    .Default(0);\\n\";\n}\n\n// Emits the list of spellings for attributes.\nvoid EmitClangAttrHasAttrImpl(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Code to implement the __has_attribute logic\", OS);\n\n  // Separate all of the attributes out into four group: generic, C++11, GNU,\n  // and declspecs. Then generate a big switch statement for each of them.\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  std::vector<Record *> Declspec, Microsoft, GNU, Pragma;\n  std::map<std::string, std::vector<Record *>> CXX, C2x;\n\n  // Walk over the list of all attributes, and split them out based on the\n  // spelling variety.\n  for (auto *R : Attrs) {\n    std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(*R);\n    for (const auto &SI : Spellings) {\n      const std::string &Variety = SI.variety();\n      if (Variety == \"GNU\")\n        GNU.push_back(R);\n      else if (Variety == \"Declspec\")\n        Declspec.push_back(R);\n      else if (Variety == \"Microsoft\")\n        Microsoft.push_back(R);\n      else if (Variety == \"CXX11\")\n        CXX[SI.nameSpace()].push_back(R);\n      else if (Variety == \"C2x\")\n        C2x[SI.nameSpace()].push_back(R);\n      else if (Variety == \"Pragma\")\n        Pragma.push_back(R);\n    }\n  }\n\n  OS << \"const llvm::Triple &T = Target.getTriple();\\n\";\n  OS << \"switch (Syntax) {\\n\";\n  OS << \"case AttrSyntax::GNU:\\n\";\n  OS << \"  return llvm::StringSwitch<int>(Name)\\n\";\n  GenerateHasAttrSpellingStringSwitch(GNU, OS, \"GNU\");\n  OS << \"case AttrSyntax::Declspec:\\n\";\n  OS << \"  return llvm::StringSwitch<int>(Name)\\n\";\n  GenerateHasAttrSpellingStringSwitch(Declspec, OS, \"Declspec\");\n  OS << \"case AttrSyntax::Microsoft:\\n\";\n  OS << \"  return llvm::StringSwitch<int>(Name)\\n\";\n  GenerateHasAttrSpellingStringSwitch(Microsoft, OS, \"Microsoft\");\n  OS << \"case AttrSyntax::Pragma:\\n\";\n  OS << \"  return llvm::StringSwitch<int>(Name)\\n\";\n  GenerateHasAttrSpellingStringSwitch(Pragma, OS, \"Pragma\");\n  auto fn = [&OS](const char *Spelling, const char *Variety,\n                  const std::map<std::string, std::vector<Record *>> &List) {\n    OS << \"case AttrSyntax::\" << Variety << \": {\\n\";\n    // C++11-style attributes are further split out based on the Scope.\n    for (auto I = List.cbegin(), E = List.cend(); I != E; ++I) {\n      if (I != List.cbegin())\n        OS << \" else \";\n      if (I->first.empty())\n        OS << \"if (ScopeName == \\\"\\\") {\\n\";\n      else\n        OS << \"if (ScopeName == \\\"\" << I->first << \"\\\") {\\n\";\n      OS << \"  return llvm::StringSwitch<int>(Name)\\n\";\n      GenerateHasAttrSpellingStringSwitch(I->second, OS, Spelling, I->first);\n      OS << \"}\";\n    }\n    OS << \"\\n} break;\\n\";\n  };\n  fn(\"CXX11\", \"CXX\", CXX);\n  fn(\"C2x\", \"C\", C2x);\n  OS << \"}\\n\";\n}\n\nvoid EmitClangAttrSpellingListIndex(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Code to translate different attribute spellings \"\n                       \"into internal identifiers\", OS);\n\n  OS << \"  switch (getParsedKind()) {\\n\";\n  OS << \"    case IgnoredAttribute:\\n\";\n  OS << \"    case UnknownAttribute:\\n\";\n  OS << \"    case NoSemaHandlerAttribute:\\n\";\n  OS << \"      llvm_unreachable(\\\"Ignored/unknown shouldn't get here\\\");\\n\";\n\n  ParsedAttrMap Attrs = getParsedAttrList(Records);\n  for (const auto &I : Attrs) {\n    const Record &R = *I.second;\n    std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(R);\n    OS << \"  case AT_\" << I.first << \": {\\n\";\n    for (unsigned I = 0; I < Spellings.size(); ++ I) {\n      OS << \"    if (Name == \\\"\" << Spellings[I].name() << \"\\\" && \"\n         << \"getSyntax() == AttributeCommonInfo::AS_\" << Spellings[I].variety()\n         << \" && Scope == \\\"\" << Spellings[I].nameSpace() << \"\\\")\\n\"\n         << \"        return \" << I << \";\\n\";\n    }\n\n    OS << \"    break;\\n\";\n    OS << \"  }\\n\";\n  }\n\n  OS << \"  }\\n\";\n  OS << \"  return 0;\\n\";\n}\n\n// Emits code used by RecursiveASTVisitor to visit attributes\nvoid EmitClangAttrASTVisitor(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Used by RecursiveASTVisitor to visit attributes.\", OS);\n\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n\n  // Write method declarations for Traverse* methods.\n  // We emit this here because we only generate methods for attributes that\n  // are declared as ASTNodes.\n  OS << \"#ifdef ATTR_VISITOR_DECLS_ONLY\\n\\n\";\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n    OS << \"  bool Traverse\"\n       << R.getName() << \"Attr(\" << R.getName() << \"Attr *A);\\n\";\n    OS << \"  bool Visit\"\n       << R.getName() << \"Attr(\" << R.getName() << \"Attr *A) {\\n\"\n       << \"    return true; \\n\"\n       << \"  }\\n\";\n  }\n  OS << \"\\n#else // ATTR_VISITOR_DECLS_ONLY\\n\\n\";\n\n  // Write individual Traverse* methods for each attribute class.\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n\n    OS << \"template <typename Derived>\\n\"\n       << \"bool VISITORCLASS<Derived>::Traverse\"\n       << R.getName() << \"Attr(\" << R.getName() << \"Attr *A) {\\n\"\n       << \"  if (!getDerived().VisitAttr(A))\\n\"\n       << \"    return false;\\n\"\n       << \"  if (!getDerived().Visit\" << R.getName() << \"Attr(A))\\n\"\n       << \"    return false;\\n\";\n\n    std::vector<Record*> ArgRecords = R.getValueAsListOfDefs(\"Args\");\n    for (const auto *Arg : ArgRecords)\n      createArgument(*Arg, R.getName())->writeASTVisitorTraversal(OS);\n\n    OS << \"  return true;\\n\";\n    OS << \"}\\n\\n\";\n  }\n\n  // Write generic Traverse routine\n  OS << \"template <typename Derived>\\n\"\n     << \"bool VISITORCLASS<Derived>::TraverseAttr(Attr *A) {\\n\"\n     << \"  if (!A)\\n\"\n     << \"    return true;\\n\"\n     << \"\\n\"\n     << \"  switch (A->getKind()) {\\n\";\n\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n\n    OS << \"    case attr::\" << R.getName() << \":\\n\"\n       << \"      return getDerived().Traverse\" << R.getName() << \"Attr(\"\n       << \"cast<\" << R.getName() << \"Attr>(A));\\n\";\n  }\n  OS << \"  }\\n\";  // end switch\n  OS << \"  llvm_unreachable(\\\"bad attribute kind\\\");\\n\";\n  OS << \"}\\n\";  // end function\n  OS << \"#endif  // ATTR_VISITOR_DECLS_ONLY\\n\";\n}\n\nvoid EmitClangAttrTemplateInstantiateHelper(const std::vector<Record *> &Attrs,\n                                            raw_ostream &OS,\n                                            bool AppliesToDecl) {\n\n  OS << \"  switch (At->getKind()) {\\n\";\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n    OS << \"    case attr::\" << R.getName() << \": {\\n\";\n    bool ShouldClone = R.getValueAsBit(\"Clone\") &&\n                       (!AppliesToDecl ||\n                        R.getValueAsBit(\"MeaningfulToClassTemplateDefinition\"));\n\n    if (!ShouldClone) {\n      OS << \"      return nullptr;\\n\";\n      OS << \"    }\\n\";\n      continue;\n    }\n\n    OS << \"      const auto *A = cast<\"\n       << R.getName() << \"Attr>(At);\\n\";\n    bool TDependent = R.getValueAsBit(\"TemplateDependent\");\n\n    if (!TDependent) {\n      OS << \"      return A->clone(C);\\n\";\n      OS << \"    }\\n\";\n      continue;\n    }\n\n    std::vector<Record*> ArgRecords = R.getValueAsListOfDefs(\"Args\");\n    std::vector<std::unique_ptr<Argument>> Args;\n    Args.reserve(ArgRecords.size());\n\n    for (const auto *ArgRecord : ArgRecords)\n      Args.emplace_back(createArgument(*ArgRecord, R.getName()));\n\n    for (auto const &ai : Args)\n      ai->writeTemplateInstantiation(OS);\n\n    OS << \"      return new (C) \" << R.getName() << \"Attr(C, *A\";\n    for (auto const &ai : Args) {\n      OS << \", \";\n      ai->writeTemplateInstantiationArgs(OS);\n    }\n    OS << \");\\n\"\n       << \"    }\\n\";\n  }\n  OS << \"  } // end switch\\n\"\n     << \"  llvm_unreachable(\\\"Unknown attribute!\\\");\\n\"\n     << \"  return nullptr;\\n\";\n}\n\n// Emits code to instantiate dependent attributes on templates.\nvoid EmitClangAttrTemplateInstantiate(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Template instantiation code for attributes\", OS);\n\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n\n  OS << \"namespace clang {\\n\"\n     << \"namespace sema {\\n\\n\"\n     << \"Attr *instantiateTemplateAttribute(const Attr *At, ASTContext &C, \"\n     << \"Sema &S,\\n\"\n     << \"        const MultiLevelTemplateArgumentList &TemplateArgs) {\\n\";\n  EmitClangAttrTemplateInstantiateHelper(Attrs, OS, /*AppliesToDecl*/false);\n  OS << \"}\\n\\n\"\n     << \"Attr *instantiateTemplateAttributeForDecl(const Attr *At,\\n\"\n     << \" ASTContext &C, Sema &S,\\n\"\n     << \"        const MultiLevelTemplateArgumentList &TemplateArgs) {\\n\";\n  EmitClangAttrTemplateInstantiateHelper(Attrs, OS, /*AppliesToDecl*/true);\n  OS << \"}\\n\\n\"\n     << \"} // end namespace sema\\n\"\n     << \"} // end namespace clang\\n\";\n}\n\n// Emits the list of parsed attributes.\nvoid EmitClangAttrParsedAttrList(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"List of all attributes that Clang recognizes\", OS);\n\n  OS << \"#ifndef PARSED_ATTR\\n\";\n  OS << \"#define PARSED_ATTR(NAME) NAME\\n\";\n  OS << \"#endif\\n\\n\";\n\n  ParsedAttrMap Names = getParsedAttrList(Records);\n  for (const auto &I : Names) {\n    OS << \"PARSED_ATTR(\" << I.first << \")\\n\";\n  }\n}\n\nstatic bool isArgVariadic(const Record &R, StringRef AttrName) {\n  return createArgument(R, AttrName)->isVariadic();\n}\n\nstatic void emitArgInfo(const Record &R, raw_ostream &OS) {\n  // This function will count the number of arguments specified for the\n  // attribute and emit the number of required arguments followed by the\n  // number of optional arguments.\n  std::vector<Record *> Args = R.getValueAsListOfDefs(\"Args\");\n  unsigned ArgCount = 0, OptCount = 0;\n  bool HasVariadic = false;\n  for (const auto *Arg : Args) {\n    // If the arg is fake, it's the user's job to supply it: general parsing\n    // logic shouldn't need to know anything about it.\n    if (Arg->getValueAsBit(\"Fake\"))\n      continue;\n    Arg->getValueAsBit(\"Optional\") ? ++OptCount : ++ArgCount;\n    if (!HasVariadic && isArgVariadic(*Arg, R.getName()))\n      HasVariadic = true;\n  }\n\n  // If there is a variadic argument, we will set the optional argument count\n  // to its largest value. Since it's currently a 4-bit number, we set it to 15.\n  OS << \"    NumArgs = \" << ArgCount << \";\\n\";\n  OS << \"    OptArgs = \" << (HasVariadic ? 15 : OptCount) << \";\\n\";\n}\n\nstatic std::string GetDiagnosticSpelling(const Record &R) {\n  std::string Ret = std::string(R.getValueAsString(\"DiagSpelling\"));\n  if (!Ret.empty())\n    return Ret;\n\n  // If we couldn't find the DiagSpelling in this object, we can check to see\n  // if the object is one that has a base, and if it is, loop up to the Base\n  // member recursively.\n  if (auto Base = R.getValueAsOptionalDef(BaseFieldName))\n    return GetDiagnosticSpelling(*Base);\n\n  return \"\";\n}\n\nstatic std::string CalculateDiagnostic(const Record &S) {\n  // If the SubjectList object has a custom diagnostic associated with it,\n  // return that directly.\n  const StringRef CustomDiag = S.getValueAsString(\"CustomDiag\");\n  if (!CustomDiag.empty())\n    return (\"\\\"\" + Twine(CustomDiag) + \"\\\"\").str();\n\n  std::vector<std::string> DiagList;\n  std::vector<Record *> Subjects = S.getValueAsListOfDefs(\"Subjects\");\n  for (const auto *Subject : Subjects) {\n    const Record &R = *Subject;\n    // Get the diagnostic text from the Decl or Stmt node given.\n    std::string V = GetDiagnosticSpelling(R);\n    if (V.empty()) {\n      PrintError(R.getLoc(),\n                 \"Could not determine diagnostic spelling for the node: \" +\n                     R.getName() + \"; please add one to DeclNodes.td\");\n    } else {\n      // The node may contain a list of elements itself, so split the elements\n      // by a comma, and trim any whitespace.\n      SmallVector<StringRef, 2> Frags;\n      llvm::SplitString(V, Frags, \",\");\n      for (auto Str : Frags) {\n        DiagList.push_back(std::string(Str.trim()));\n      }\n    }\n  }\n\n  if (DiagList.empty()) {\n    PrintFatalError(S.getLoc(),\n                    \"Could not deduce diagnostic argument for Attr subjects\");\n    return \"\";\n  }\n\n  // FIXME: this is not particularly good for localization purposes and ideally\n  // should be part of the diagnostics engine itself with some sort of list\n  // specifier.\n\n  // A single member of the list can be returned directly.\n  if (DiagList.size() == 1)\n    return '\"' + DiagList.front() + '\"';\n\n  if (DiagList.size() == 2)\n    return '\"' + DiagList[0] + \" and \" + DiagList[1] + '\"';\n\n  // If there are more than two in the list, we serialize the first N - 1\n  // elements with a comma. This leaves the string in the state: foo, bar,\n  // baz (but misses quux). We can then add \", and \" for the last element\n  // manually.\n  std::string Diag = llvm::join(DiagList.begin(), DiagList.end() - 1, \", \");\n  return '\"' + Diag + \", and \" + *(DiagList.end() - 1) + '\"';\n}\n\nstatic std::string GetSubjectWithSuffix(const Record *R) {\n  const std::string &B = std::string(R->getName());\n  if (B == \"DeclBase\")\n    return \"Decl\";\n  return B + \"Decl\";\n}\n\nstatic std::string functionNameForCustomAppertainsTo(const Record &Subject) {\n  return \"is\" + Subject.getName().str();\n}\n\nstatic void GenerateCustomAppertainsTo(const Record &Subject, raw_ostream &OS) {\n  std::string FnName = functionNameForCustomAppertainsTo(Subject);\n\n  // If this code has already been generated, we don't need to do anything.\n  static std::set<std::string> CustomSubjectSet;\n  auto I = CustomSubjectSet.find(FnName);\n  if (I != CustomSubjectSet.end())\n    return;\n\n  // This only works with non-root Decls.\n  Record *Base = Subject.getValueAsDef(BaseFieldName);\n\n  // Not currently support custom subjects within custom subjects.\n  if (Base->isSubClassOf(\"SubsetSubject\")) {\n    PrintFatalError(Subject.getLoc(),\n                    \"SubsetSubjects within SubsetSubjects is not supported\");\n    return;\n  }\n\n  OS << \"static bool \" << FnName << \"(const Decl *D) {\\n\";\n  OS << \"  if (const auto *S = dyn_cast<\";\n  OS << GetSubjectWithSuffix(Base);\n  OS << \">(D))\\n\";\n  OS << \"    return \" << Subject.getValueAsString(\"CheckCode\") << \";\\n\";\n  OS << \"  return false;\\n\";\n  OS << \"}\\n\\n\";\n\n  CustomSubjectSet.insert(FnName);\n}\n\nstatic void GenerateAppertainsTo(const Record &Attr, raw_ostream &OS) {\n  // If the attribute does not contain a Subjects definition, then use the\n  // default appertainsTo logic.\n  if (Attr.isValueUnset(\"Subjects\"))\n    return;\n\n  const Record *SubjectObj = Attr.getValueAsDef(\"Subjects\");\n  std::vector<Record*> Subjects = SubjectObj->getValueAsListOfDefs(\"Subjects\");\n\n  // If the list of subjects is empty, it is assumed that the attribute\n  // appertains to everything.\n  if (Subjects.empty())\n    return;\n\n  bool Warn = SubjectObj->getValueAsDef(\"Diag\")->getValueAsBit(\"Warn\");\n\n  // Otherwise, generate an appertainsTo check specific to this attribute which\n  // checks all of the given subjects against the Decl passed in.\n  //\n  // If D is null, that means the attribute was not applied to a declaration\n  // at all (for instance because it was applied to a type), or that the caller\n  // has determined that the check should fail (perhaps prior to the creation\n  // of the declaration).\n  OS << \"bool diagAppertainsToDecl(Sema &S, \";\n  OS << \"const ParsedAttr &Attr, const Decl *D) const override {\\n\";\n  OS << \"  if (\";\n  for (auto I = Subjects.begin(), E = Subjects.end(); I != E; ++I) {\n    // If the subject has custom code associated with it, use the generated\n    // function for it. The function cannot be inlined into this check (yet)\n    // because it requires the subject to be of a specific type, and were that\n    // information inlined here, it would not support an attribute with multiple\n    // custom subjects.\n    if ((*I)->isSubClassOf(\"SubsetSubject\")) {\n      OS << \"!\" << functionNameForCustomAppertainsTo(**I) << \"(D)\";\n    } else {\n      OS << \"!isa<\" << GetSubjectWithSuffix(*I) << \">(D)\";\n    }\n\n    if (I + 1 != E)\n      OS << \" && \";\n  }\n  OS << \") {\\n\";\n  OS << \"    S.Diag(Attr.getLoc(), diag::\";\n  OS << (Warn ? \"warn_attribute_wrong_decl_type_str\" :\n               \"err_attribute_wrong_decl_type_str\");\n  OS << \")\\n\";\n  OS << \"      << Attr << \";\n  OS << CalculateDiagnostic(*SubjectObj) << \";\\n\";\n  OS << \"    return false;\\n\";\n  OS << \"  }\\n\";\n  OS << \"  return true;\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic void\nemitAttributeMatchRules(PragmaClangAttributeSupport &PragmaAttributeSupport,\n                        raw_ostream &OS) {\n  OS << \"static bool checkAttributeMatchRuleAppliesTo(const Decl *D, \"\n     << AttributeSubjectMatchRule::EnumName << \" rule) {\\n\";\n  OS << \"  switch (rule) {\\n\";\n  for (const auto &Rule : PragmaAttributeSupport.Rules) {\n    if (Rule.isAbstractRule()) {\n      OS << \"  case \" << Rule.getEnumValue() << \":\\n\";\n      OS << \"    assert(false && \\\"Abstract matcher rule isn't allowed\\\");\\n\";\n      OS << \"    return false;\\n\";\n      continue;\n    }\n    std::vector<Record *> Subjects = Rule.getSubjects();\n    assert(!Subjects.empty() && \"Missing subjects\");\n    OS << \"  case \" << Rule.getEnumValue() << \":\\n\";\n    OS << \"    return \";\n    for (auto I = Subjects.begin(), E = Subjects.end(); I != E; ++I) {\n      // If the subject has custom code associated with it, use the function\n      // that was generated for GenerateAppertainsTo to check if the declaration\n      // is valid.\n      if ((*I)->isSubClassOf(\"SubsetSubject\"))\n        OS << functionNameForCustomAppertainsTo(**I) << \"(D)\";\n      else\n        OS << \"isa<\" << GetSubjectWithSuffix(*I) << \">(D)\";\n\n      if (I + 1 != E)\n        OS << \" || \";\n    }\n    OS << \";\\n\";\n  }\n  OS << \"  }\\n\";\n  OS << \"  llvm_unreachable(\\\"Invalid match rule\\\");\\nreturn false;\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic void GenerateLangOptRequirements(const Record &R,\n                                        raw_ostream &OS) {\n  // If the attribute has an empty or unset list of language requirements,\n  // use the default handler.\n  std::vector<Record *> LangOpts = R.getValueAsListOfDefs(\"LangOpts\");\n  if (LangOpts.empty())\n    return;\n\n  OS << \"bool diagLangOpts(Sema &S, const ParsedAttr &Attr) \";\n  OS << \"const override {\\n\";\n  OS << \"  auto &LangOpts = S.LangOpts;\\n\";\n  OS << \"  if (\" << GenerateTestExpression(LangOpts) << \")\\n\";\n  OS << \"    return true;\\n\\n\";\n  OS << \"  S.Diag(Attr.getLoc(), diag::warn_attribute_ignored) \";\n  OS << \"<< Attr;\\n\";\n  OS << \"  return false;\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic void GenerateTargetRequirements(const Record &Attr,\n                                       const ParsedAttrMap &Dupes,\n                                       raw_ostream &OS) {\n  // If the attribute is not a target specific attribute, use the default\n  // target handler.\n  if (!Attr.isSubClassOf(\"TargetSpecificAttr\"))\n    return;\n\n  // Get the list of architectures to be tested for.\n  const Record *R = Attr.getValueAsDef(\"Target\");\n  std::vector<StringRef> Arches = R->getValueAsListOfStrings(\"Arches\");\n\n  // If there are other attributes which share the same parsed attribute kind,\n  // such as target-specific attributes with a shared spelling, collapse the\n  // duplicate architectures. This is required because a shared target-specific\n  // attribute has only one ParsedAttr::Kind enumeration value, but it\n  // applies to multiple target architectures. In order for the attribute to be\n  // considered valid, all of its architectures need to be included.\n  if (!Attr.isValueUnset(\"ParseKind\")) {\n    const StringRef APK = Attr.getValueAsString(\"ParseKind\");\n    for (const auto &I : Dupes) {\n      if (I.first == APK) {\n        std::vector<StringRef> DA =\n            I.second->getValueAsDef(\"Target\")->getValueAsListOfStrings(\n                \"Arches\");\n        Arches.insert(Arches.end(), DA.begin(), DA.end());\n      }\n    }\n  }\n\n  std::string FnName = \"isTarget\";\n  std::string Test;\n  bool UsesT = GenerateTargetSpecificAttrChecks(R, Arches, Test, &FnName);\n\n  OS << \"bool existsInTarget(const TargetInfo &Target) const override {\\n\";\n  if (UsesT)\n    OS << \"  const llvm::Triple &T = Target.getTriple(); (void)T;\\n\";\n  OS << \"  return \" << Test << \";\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic void GenerateSpellingIndexToSemanticSpelling(const Record &Attr,\n                                                    raw_ostream &OS) {\n  // If the attribute does not have a semantic form, we can bail out early.\n  if (!Attr.getValueAsBit(\"ASTNode\"))\n    return;\n\n  std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(Attr);\n\n  // If there are zero or one spellings, or all of the spellings share the same\n  // name, we can also bail out early.\n  if (Spellings.size() <= 1 || SpellingNamesAreCommon(Spellings))\n    return;\n\n  // Generate the enumeration we will use for the mapping.\n  SemanticSpellingMap SemanticToSyntacticMap;\n  std::string Enum = CreateSemanticSpellings(Spellings, SemanticToSyntacticMap);\n  std::string Name = Attr.getName().str() + \"AttrSpellingMap\";\n\n  OS << \"unsigned spellingIndexToSemanticSpelling(\";\n  OS << \"const ParsedAttr &Attr) const override {\\n\";\n  OS << Enum;\n  OS << \"  unsigned Idx = Attr.getAttributeSpellingListIndex();\\n\";\n  WriteSemanticSpellingSwitch(\"Idx\", SemanticToSyntacticMap, OS);\n  OS << \"}\\n\\n\";\n}\n\nstatic void GenerateHandleDeclAttribute(const Record &Attr, raw_ostream &OS) {\n  // Only generate if Attr can be handled simply.\n  if (!Attr.getValueAsBit(\"SimpleHandler\"))\n    return;\n\n  // Generate a function which just converts from ParsedAttr to the Attr type.\n  OS << \"AttrHandling handleDeclAttribute(Sema &S, Decl *D,\";\n  OS << \"const ParsedAttr &Attr) const override {\\n\";\n  OS << \"  D->addAttr(::new (S.Context) \" << Attr.getName();\n  OS << \"Attr(S.Context, Attr));\\n\";\n  OS << \"  return AttributeApplied;\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic bool IsKnownToGCC(const Record &Attr) {\n  // Look at the spellings for this subject; if there are any spellings which\n  // claim to be known to GCC, the attribute is known to GCC.\n  return llvm::any_of(\n      GetFlattenedSpellings(Attr),\n      [](const FlattenedSpelling &S) { return S.knownToGCC(); });\n}\n\n/// Emits the parsed attribute helpers\nvoid EmitClangAttrParsedAttrImpl(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Parsed attribute helpers\", OS);\n\n  PragmaClangAttributeSupport &PragmaAttributeSupport =\n      getPragmaAttributeSupport(Records);\n\n  // Get the list of parsed attributes, and accept the optional list of\n  // duplicates due to the ParseKind.\n  ParsedAttrMap Dupes;\n  ParsedAttrMap Attrs = getParsedAttrList(Records, &Dupes);\n\n  // Generate all of the custom appertainsTo functions that the attributes\n  // will be using.\n  for (auto I : Attrs) {\n    const Record &Attr = *I.second;\n    if (Attr.isValueUnset(\"Subjects\"))\n      continue;\n    const Record *SubjectObj = Attr.getValueAsDef(\"Subjects\");\n    for (auto Subject : SubjectObj->getValueAsListOfDefs(\"Subjects\"))\n      if (Subject->isSubClassOf(\"SubsetSubject\"))\n        GenerateCustomAppertainsTo(*Subject, OS);\n  }\n\n  // Generate a ParsedAttrInfo struct for each of the attributes.\n  for (auto I = Attrs.begin(), E = Attrs.end(); I != E; ++I) {\n    // TODO: If the attribute's kind appears in the list of duplicates, that is\n    // because it is a target-specific attribute that appears multiple times.\n    // It would be beneficial to test whether the duplicates are \"similar\n    // enough\" to each other to not cause problems. For instance, check that\n    // the spellings are identical, and custom parsing rules match, etc.\n\n    // We need to generate struct instances based off ParsedAttrInfo from\n    // ParsedAttr.cpp.\n    const std::string &AttrName = I->first;\n    const Record &Attr = *I->second;\n    auto Spellings = GetFlattenedSpellings(Attr);\n    if (!Spellings.empty()) {\n      OS << \"static constexpr ParsedAttrInfo::Spelling \" << I->first\n         << \"Spellings[] = {\\n\";\n      for (const auto &S : Spellings) {\n        const std::string &RawSpelling = S.name();\n        std::string Spelling;\n        if (!S.nameSpace().empty())\n          Spelling += S.nameSpace() + \"::\";\n        if (S.variety() == \"GNU\")\n          Spelling += NormalizeGNUAttrSpelling(RawSpelling);\n        else\n          Spelling += RawSpelling;\n        OS << \"  {AttributeCommonInfo::AS_\" << S.variety();\n        OS << \", \\\"\" << Spelling << \"\\\"},\\n\";\n      }\n      OS << \"};\\n\";\n    }\n    OS << \"struct ParsedAttrInfo\" << I->first\n       << \" final : public ParsedAttrInfo {\\n\";\n    OS << \"  ParsedAttrInfo\" << I->first << \"() {\\n\";\n    OS << \"    AttrKind = ParsedAttr::AT_\" << AttrName << \";\\n\";\n    emitArgInfo(Attr, OS);\n    OS << \"    HasCustomParsing = \";\n    OS << Attr.getValueAsBit(\"HasCustomParsing\") << \";\\n\";\n    OS << \"    IsTargetSpecific = \";\n    OS << Attr.isSubClassOf(\"TargetSpecificAttr\") << \";\\n\";\n    OS << \"    IsType = \";\n    OS << (Attr.isSubClassOf(\"TypeAttr\") ||\n           Attr.isSubClassOf(\"DeclOrTypeAttr\")) << \";\\n\";\n    OS << \"    IsStmt = \";\n    OS << (Attr.isSubClassOf(\"StmtAttr\") || Attr.isSubClassOf(\"DeclOrStmtAttr\"))\n       << \";\\n\";\n    OS << \"    IsKnownToGCC = \";\n    OS << IsKnownToGCC(Attr) << \";\\n\";\n    OS << \"    IsSupportedByPragmaAttribute = \";\n    OS << PragmaAttributeSupport.isAttributedSupported(*I->second) << \";\\n\";\n    if (!Spellings.empty())\n      OS << \"    Spellings = \" << I->first << \"Spellings;\\n\";\n    OS << \"  }\\n\";\n    GenerateAppertainsTo(Attr, OS);\n    GenerateLangOptRequirements(Attr, OS);\n    GenerateTargetRequirements(Attr, Dupes, OS);\n    GenerateSpellingIndexToSemanticSpelling(Attr, OS);\n    PragmaAttributeSupport.generateStrictConformsTo(*I->second, OS);\n    GenerateHandleDeclAttribute(Attr, OS);\n    OS << \"static const ParsedAttrInfo\" << I->first << \" Instance;\\n\";\n    OS << \"};\\n\";\n    OS << \"const ParsedAttrInfo\" << I->first << \" ParsedAttrInfo\" << I->first\n       << \"::Instance;\\n\";\n  }\n\n  OS << \"static const ParsedAttrInfo *AttrInfoMap[] = {\\n\";\n  for (auto I = Attrs.begin(), E = Attrs.end(); I != E; ++I) {\n    OS << \"&ParsedAttrInfo\" << I->first << \"::Instance,\\n\";\n  }\n  OS << \"};\\n\\n\";\n\n  // Generate the attribute match rules.\n  emitAttributeMatchRules(PragmaAttributeSupport, OS);\n}\n\n// Emits the kind list of parsed attributes\nvoid EmitClangAttrParsedAttrKinds(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Attribute name matcher\", OS);\n\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  std::vector<StringMatcher::StringPair> GNU, Declspec, Microsoft, CXX11,\n      Keywords, Pragma, C2x;\n  std::set<std::string> Seen;\n  for (const auto *A : Attrs) {\n    const Record &Attr = *A;\n\n    bool SemaHandler = Attr.getValueAsBit(\"SemaHandler\");\n    bool Ignored = Attr.getValueAsBit(\"Ignored\");\n    if (SemaHandler || Ignored) {\n      // Attribute spellings can be shared between target-specific attributes,\n      // and can be shared between syntaxes for the same attribute. For\n      // instance, an attribute can be spelled GNU<\"interrupt\"> for an ARM-\n      // specific attribute, or MSP430-specific attribute. Additionally, an\n      // attribute can be spelled GNU<\"dllexport\"> and Declspec<\"dllexport\">\n      // for the same semantic attribute. Ultimately, we need to map each of\n      // these to a single AttributeCommonInfo::Kind value, but the\n      // StringMatcher class cannot handle duplicate match strings. So we\n      // generate a list of string to match based on the syntax, and emit\n      // multiple string matchers depending on the syntax used.\n      std::string AttrName;\n      if (Attr.isSubClassOf(\"TargetSpecificAttr\") &&\n          !Attr.isValueUnset(\"ParseKind\")) {\n        AttrName = std::string(Attr.getValueAsString(\"ParseKind\"));\n        if (Seen.find(AttrName) != Seen.end())\n          continue;\n        Seen.insert(AttrName);\n      } else\n        AttrName = NormalizeAttrName(StringRef(Attr.getName())).str();\n\n      std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(Attr);\n      for (const auto &S : Spellings) {\n        const std::string &RawSpelling = S.name();\n        std::vector<StringMatcher::StringPair> *Matches = nullptr;\n        std::string Spelling;\n        const std::string &Variety = S.variety();\n        if (Variety == \"CXX11\") {\n          Matches = &CXX11;\n          if (!S.nameSpace().empty())\n            Spelling += S.nameSpace() + \"::\";\n        } else if (Variety == \"C2x\") {\n          Matches = &C2x;\n          if (!S.nameSpace().empty())\n            Spelling += S.nameSpace() + \"::\";\n        } else if (Variety == \"GNU\")\n          Matches = &GNU;\n        else if (Variety == \"Declspec\")\n          Matches = &Declspec;\n        else if (Variety == \"Microsoft\")\n          Matches = &Microsoft;\n        else if (Variety == \"Keyword\")\n          Matches = &Keywords;\n        else if (Variety == \"Pragma\")\n          Matches = &Pragma;\n\n        assert(Matches && \"Unsupported spelling variety found\");\n\n        if (Variety == \"GNU\")\n          Spelling += NormalizeGNUAttrSpelling(RawSpelling);\n        else\n          Spelling += RawSpelling;\n\n        if (SemaHandler)\n          Matches->push_back(StringMatcher::StringPair(\n              Spelling, \"return AttributeCommonInfo::AT_\" + AttrName + \";\"));\n        else\n          Matches->push_back(StringMatcher::StringPair(\n              Spelling, \"return AttributeCommonInfo::IgnoredAttribute;\"));\n      }\n    }\n  }\n\n  OS << \"static AttributeCommonInfo::Kind getAttrKind(StringRef Name, \";\n  OS << \"AttributeCommonInfo::Syntax Syntax) {\\n\";\n  OS << \"  if (AttributeCommonInfo::AS_GNU == Syntax) {\\n\";\n  StringMatcher(\"Name\", GNU, OS).Emit();\n  OS << \"  } else if (AttributeCommonInfo::AS_Declspec == Syntax) {\\n\";\n  StringMatcher(\"Name\", Declspec, OS).Emit();\n  OS << \"  } else if (AttributeCommonInfo::AS_Microsoft == Syntax) {\\n\";\n  StringMatcher(\"Name\", Microsoft, OS).Emit();\n  OS << \"  } else if (AttributeCommonInfo::AS_CXX11 == Syntax) {\\n\";\n  StringMatcher(\"Name\", CXX11, OS).Emit();\n  OS << \"  } else if (AttributeCommonInfo::AS_C2x == Syntax) {\\n\";\n  StringMatcher(\"Name\", C2x, OS).Emit();\n  OS << \"  } else if (AttributeCommonInfo::AS_Keyword == Syntax || \";\n  OS << \"AttributeCommonInfo::AS_ContextSensitiveKeyword == Syntax) {\\n\";\n  StringMatcher(\"Name\", Keywords, OS).Emit();\n  OS << \"  } else if (AttributeCommonInfo::AS_Pragma == Syntax) {\\n\";\n  StringMatcher(\"Name\", Pragma, OS).Emit();\n  OS << \"  }\\n\";\n  OS << \"  return AttributeCommonInfo::UnknownAttribute;\\n\"\n     << \"}\\n\";\n}\n\n// Emits the code to dump an attribute.\nvoid EmitClangAttrTextNodeDump(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Attribute text node dumper\", OS);\n\n  std::vector<Record*> Attrs = Records.getAllDerivedDefinitions(\"Attr\"), Args;\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n\n    // If the attribute has a semantically-meaningful name (which is determined\n    // by whether there is a Spelling enumeration for it), then write out the\n    // spelling used for the attribute.\n\n    std::string FunctionContent;\n    llvm::raw_string_ostream SS(FunctionContent);\n\n    std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(R);\n    if (Spellings.size() > 1 && !SpellingNamesAreCommon(Spellings))\n      SS << \"    OS << \\\" \\\" << A->getSpelling();\\n\";\n\n    Args = R.getValueAsListOfDefs(\"Args\");\n    for (const auto *Arg : Args)\n      createArgument(*Arg, R.getName())->writeDump(SS);\n\n    if (SS.tell()) {\n      OS << \"  void Visit\" << R.getName() << \"Attr(const \" << R.getName()\n         << \"Attr *A) {\\n\";\n      if (!Args.empty())\n        OS << \"    const auto *SA = cast<\" << R.getName()\n           << \"Attr>(A); (void)SA;\\n\";\n      OS << SS.str();\n      OS << \"  }\\n\";\n    }\n  }\n}\n\nvoid EmitClangAttrNodeTraverse(RecordKeeper &Records, raw_ostream &OS) {\n  emitSourceFileHeader(\"Attribute text node traverser\", OS);\n\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\"), Args;\n  for (const auto *Attr : Attrs) {\n    const Record &R = *Attr;\n    if (!R.getValueAsBit(\"ASTNode\"))\n      continue;\n\n    std::string FunctionContent;\n    llvm::raw_string_ostream SS(FunctionContent);\n\n    Args = R.getValueAsListOfDefs(\"Args\");\n    for (const auto *Arg : Args)\n      createArgument(*Arg, R.getName())->writeDumpChildren(SS);\n    if (SS.tell()) {\n      OS << \"  void Visit\" << R.getName() << \"Attr(const \" << R.getName()\n         << \"Attr *A) {\\n\";\n      if (!Args.empty())\n        OS << \"    const auto *SA = cast<\" << R.getName()\n           << \"Attr>(A); (void)SA;\\n\";\n      OS << SS.str();\n      OS << \"  }\\n\";\n    }\n  }\n}\n\nvoid EmitClangAttrParserStringSwitches(RecordKeeper &Records,\n                                       raw_ostream &OS) {\n  emitSourceFileHeader(\"Parser-related llvm::StringSwitch cases\", OS);\n  emitClangAttrArgContextList(Records, OS);\n  emitClangAttrIdentifierArgList(Records, OS);\n  emitClangAttrVariadicIdentifierArgList(Records, OS);\n  emitClangAttrThisIsaIdentifierArgList(Records, OS);\n  emitClangAttrTypeArgList(Records, OS);\n  emitClangAttrLateParsedList(Records, OS);\n}\n\nvoid EmitClangAttrSubjectMatchRulesParserStringSwitches(RecordKeeper &Records,\n                                                        raw_ostream &OS) {\n  getPragmaAttributeSupport(Records).generateParsingHelpers(OS);\n}\n\nenum class SpellingKind {\n  GNU,\n  CXX11,\n  C2x,\n  Declspec,\n  Microsoft,\n  Keyword,\n  Pragma,\n};\nstatic const size_t NumSpellingKinds = (size_t)SpellingKind::Pragma + 1;\n\nclass SpellingList {\n  std::vector<std::string> Spellings[NumSpellingKinds];\n\npublic:\n  ArrayRef<std::string> operator[](SpellingKind K) const {\n    return Spellings[(size_t)K];\n  }\n\n  void add(const Record &Attr, FlattenedSpelling Spelling) {\n    SpellingKind Kind = StringSwitch<SpellingKind>(Spelling.variety())\n                            .Case(\"GNU\", SpellingKind::GNU)\n                            .Case(\"CXX11\", SpellingKind::CXX11)\n                            .Case(\"C2x\", SpellingKind::C2x)\n                            .Case(\"Declspec\", SpellingKind::Declspec)\n                            .Case(\"Microsoft\", SpellingKind::Microsoft)\n                            .Case(\"Keyword\", SpellingKind::Keyword)\n                            .Case(\"Pragma\", SpellingKind::Pragma);\n    std::string Name;\n    if (!Spelling.nameSpace().empty()) {\n      switch (Kind) {\n      case SpellingKind::CXX11:\n      case SpellingKind::C2x:\n        Name = Spelling.nameSpace() + \"::\";\n        break;\n      case SpellingKind::Pragma:\n        Name = Spelling.nameSpace() + \" \";\n        break;\n      default:\n        PrintFatalError(Attr.getLoc(), \"Unexpected namespace in spelling\");\n      }\n    }\n    Name += Spelling.name();\n\n    Spellings[(size_t)Kind].push_back(Name);\n  }\n};\n\nclass DocumentationData {\npublic:\n  const Record *Documentation;\n  const Record *Attribute;\n  std::string Heading;\n  SpellingList SupportedSpellings;\n\n  DocumentationData(const Record &Documentation, const Record &Attribute,\n                    std::pair<std::string, SpellingList> HeadingAndSpellings)\n      : Documentation(&Documentation), Attribute(&Attribute),\n        Heading(std::move(HeadingAndSpellings.first)),\n        SupportedSpellings(std::move(HeadingAndSpellings.second)) {}\n};\n\nstatic void WriteCategoryHeader(const Record *DocCategory,\n                                raw_ostream &OS) {\n  const StringRef Name = DocCategory->getValueAsString(\"Name\");\n  OS << Name << \"\\n\" << std::string(Name.size(), '=') << \"\\n\";\n\n  // If there is content, print that as well.\n  const StringRef ContentStr = DocCategory->getValueAsString(\"Content\");\n  // Trim leading and trailing newlines and spaces.\n  OS << ContentStr.trim();\n\n  OS << \"\\n\\n\";\n}\n\nstatic std::pair<std::string, SpellingList>\nGetAttributeHeadingAndSpellings(const Record &Documentation,\n                                const Record &Attribute) {\n  // FIXME: there is no way to have a per-spelling category for the attribute\n  // documentation. This may not be a limiting factor since the spellings\n  // should generally be consistently applied across the category.\n\n  std::vector<FlattenedSpelling> Spellings = GetFlattenedSpellings(Attribute);\n  if (Spellings.empty())\n    PrintFatalError(Attribute.getLoc(),\n                    \"Attribute has no supported spellings; cannot be \"\n                    \"documented\");\n\n  // Determine the heading to be used for this attribute.\n  std::string Heading = std::string(Documentation.getValueAsString(\"Heading\"));\n  if (Heading.empty()) {\n    // If there's only one spelling, we can simply use that.\n    if (Spellings.size() == 1)\n      Heading = Spellings.begin()->name();\n    else {\n      std::set<std::string> Uniques;\n      for (auto I = Spellings.begin(), E = Spellings.end();\n           I != E && Uniques.size() <= 1; ++I) {\n        std::string Spelling =\n            std::string(NormalizeNameForSpellingComparison(I->name()));\n        Uniques.insert(Spelling);\n      }\n      // If the semantic map has only one spelling, that is sufficient for our\n      // needs.\n      if (Uniques.size() == 1)\n        Heading = *Uniques.begin();\n    }\n  }\n\n  // If the heading is still empty, it is an error.\n  if (Heading.empty())\n    PrintFatalError(Attribute.getLoc(),\n                    \"This attribute requires a heading to be specified\");\n\n  SpellingList SupportedSpellings;\n  for (const auto &I : Spellings)\n    SupportedSpellings.add(Attribute, I);\n\n  return std::make_pair(std::move(Heading), std::move(SupportedSpellings));\n}\n\nstatic void WriteDocumentation(RecordKeeper &Records,\n                               const DocumentationData &Doc, raw_ostream &OS) {\n  OS << Doc.Heading << \"\\n\" << std::string(Doc.Heading.length(), '-') << \"\\n\";\n\n  // List what spelling syntaxes the attribute supports.\n  OS << \".. csv-table:: Supported Syntaxes\\n\";\n  OS << \"   :header: \\\"GNU\\\", \\\"C++11\\\", \\\"C2x\\\", \\\"``__declspec``\\\",\";\n  OS << \" \\\"Keyword\\\", \\\"``#pragma``\\\", \\\"``#pragma clang attribute``\\\"\\n\\n\";\n  OS << \"   \\\"\";\n  for (size_t Kind = 0; Kind != NumSpellingKinds; ++Kind) {\n    SpellingKind K = (SpellingKind)Kind;\n    // TODO: List Microsoft (IDL-style attribute) spellings once we fully\n    // support them.\n    if (K == SpellingKind::Microsoft)\n      continue;\n\n    bool PrintedAny = false;\n    for (StringRef Spelling : Doc.SupportedSpellings[K]) {\n      if (PrintedAny)\n        OS << \" |br| \";\n      OS << \"``\" << Spelling << \"``\";\n      PrintedAny = true;\n    }\n\n    OS << \"\\\",\\\"\";\n  }\n\n  if (getPragmaAttributeSupport(Records).isAttributedSupported(\n          *Doc.Attribute))\n    OS << \"Yes\";\n  OS << \"\\\"\\n\\n\";\n\n  // If the attribute is deprecated, print a message about it, and possibly\n  // provide a replacement attribute.\n  if (!Doc.Documentation->isValueUnset(\"Deprecated\")) {\n    OS << \"This attribute has been deprecated, and may be removed in a future \"\n       << \"version of Clang.\";\n    const Record &Deprecated = *Doc.Documentation->getValueAsDef(\"Deprecated\");\n    const StringRef Replacement = Deprecated.getValueAsString(\"Replacement\");\n    if (!Replacement.empty())\n      OS << \"  This attribute has been superseded by ``\" << Replacement\n         << \"``.\";\n    OS << \"\\n\\n\";\n  }\n\n  const StringRef ContentStr = Doc.Documentation->getValueAsString(\"Content\");\n  // Trim leading and trailing newlines and spaces.\n  OS << ContentStr.trim();\n\n  OS << \"\\n\\n\\n\";\n}\n\nvoid EmitClangAttrDocs(RecordKeeper &Records, raw_ostream &OS) {\n  // Get the documentation introduction paragraph.\n  const Record *Documentation = Records.getDef(\"GlobalDocumentation\");\n  if (!Documentation) {\n    PrintFatalError(\"The Documentation top-level definition is missing, \"\n                    \"no documentation will be generated.\");\n    return;\n  }\n\n  OS << Documentation->getValueAsString(\"Intro\") << \"\\n\";\n\n  // Gather the Documentation lists from each of the attributes, based on the\n  // category provided.\n  std::vector<Record *> Attrs = Records.getAllDerivedDefinitions(\"Attr\");\n  std::map<const Record *, std::vector<DocumentationData>> SplitDocs;\n  for (const auto *A : Attrs) {\n    const Record &Attr = *A;\n    std::vector<Record *> Docs = Attr.getValueAsListOfDefs(\"Documentation\");\n    for (const auto *D : Docs) {\n      const Record &Doc = *D;\n      const Record *Category = Doc.getValueAsDef(\"Category\");\n      // If the category is \"undocumented\", then there cannot be any other\n      // documentation categories (otherwise, the attribute would become\n      // documented).\n      const StringRef Cat = Category->getValueAsString(\"Name\");\n      bool Undocumented = Cat == \"Undocumented\";\n      if (Undocumented && Docs.size() > 1)\n        PrintFatalError(Doc.getLoc(),\n                        \"Attribute is \\\"Undocumented\\\", but has multiple \"\n                        \"documentation categories\");\n\n      if (!Undocumented)\n        SplitDocs[Category].push_back(DocumentationData(\n            Doc, Attr, GetAttributeHeadingAndSpellings(Doc, Attr)));\n    }\n  }\n\n  // Having split the attributes out based on what documentation goes where,\n  // we can begin to generate sections of documentation.\n  for (auto &I : SplitDocs) {\n    WriteCategoryHeader(I.first, OS);\n\n    llvm::sort(I.second,\n               [](const DocumentationData &D1, const DocumentationData &D2) {\n                 return D1.Heading < D2.Heading;\n               });\n\n    // Walk over each of the attributes in the category and write out their\n    // documentation.\n    for (const auto &Doc : I.second)\n      WriteDocumentation(Records, Doc, OS);\n  }\n}\n\nvoid EmitTestPragmaAttributeSupportedAttributes(RecordKeeper &Records,\n                                                raw_ostream &OS) {\n  PragmaClangAttributeSupport Support = getPragmaAttributeSupport(Records);\n  ParsedAttrMap Attrs = getParsedAttrList(Records);\n  OS << \"#pragma clang attribute supports the following attributes:\\n\";\n  for (const auto &I : Attrs) {\n    if (!Support.isAttributedSupported(*I.second))\n      continue;\n    OS << I.first;\n    if (I.second->isValueUnset(\"Subjects\")) {\n      OS << \" ()\\n\";\n      continue;\n    }\n    const Record *SubjectObj = I.second->getValueAsDef(\"Subjects\");\n    std::vector<Record *> Subjects =\n        SubjectObj->getValueAsListOfDefs(\"Subjects\");\n    OS << \" (\";\n    for (const auto &Subject : llvm::enumerate(Subjects)) {\n      if (Subject.index())\n        OS << \", \";\n      PragmaClangAttributeSupport::RuleOrAggregateRuleSet &RuleSet =\n          Support.SubjectsToRules.find(Subject.value())->getSecond();\n      if (RuleSet.isRule()) {\n        OS << RuleSet.getRule().getEnumValueName();\n        continue;\n      }\n      OS << \"(\";\n      for (const auto &Rule : llvm::enumerate(RuleSet.getAggregateRuleSet())) {\n        if (Rule.index())\n          OS << \", \";\n        OS << Rule.value().getEnumValueName();\n      }\n      OS << \")\";\n    }\n    OS << \")\\n\";\n  }\n  OS << \"End of supported attributes.\\n\";\n}\n\n} // end namespace clang\n"}}, "reports": [{"events": [{"location": {"col": 18, "file": 1, "line": 2340}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 1, "line": 2340}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp", "reportHash": "785f0b220462874e38988955bb5bdfec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
