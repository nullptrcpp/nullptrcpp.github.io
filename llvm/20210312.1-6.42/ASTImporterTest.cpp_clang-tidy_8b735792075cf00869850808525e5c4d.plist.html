<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-param-test.h", "content": "// This file was GENERATED by command:\n//     pump.py gtest-param-test.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: vladl@google.com (Vlad Losev)\n//\n// Macros and functions for implementing parameterized tests\n// in Google C++ Testing Framework (Google Test)\n//\n// This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\n//\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n\n\n// Value-parameterized tests allow you to test your code with different\n// parameters without writing multiple copies of the same test.\n//\n// Here is how you use value-parameterized tests:\n\n#if 0\n\n// To write value-parameterized tests, first you should define a fixture\n// class. It is usually derived from testing::TestWithParam<T> (see below for\n// another inheritance scheme that's sometimes useful in more complicated\n// class hierarchies), where the type of your parameter values.\n// TestWithParam<T> is itself derived from testing::Test. T can be any\n// copyable type. If it's a raw pointer, you are responsible for managing the\n// lifespan of the pointed values.\n\nclass FooTest : public ::testing::TestWithParam<const char*> {\n  // You can implement all the usual class fixture members here.\n};\n\n// Then, use the TEST_P macro to define as many parameterized tests\n// for this fixture as you want. The _P suffix is for \"parameterized\"\n// or \"pattern\", whichever you prefer to think.\n\nTEST_P(FooTest, DoesBlah) {\n  // Inside a test, access the test parameter with the GetParam() method\n  // of the TestWithParam<T> class:\n  EXPECT_TRUE(foo.Blah(GetParam()));\n  ...\n}\n\nTEST_P(FooTest, HasBlahBlah) {\n  ...\n}\n\n// Finally, you can use INSTANTIATE_TEST_CASE_P to instantiate the test\n// case with any set of parameters you want. Google Test defines a number\n// of functions for generating test parameters. They return what we call\n// (surprise!) parameter generators. Here is a  summary of them, which\n// are all in the testing namespace:\n//\n//\n//  Range(begin, end [, step]) - Yields values {begin, begin+step,\n//                               begin+step+step, ...}. The values do not\n//                               include end. step defaults to 1.\n//  Values(v1, v2, ..., vN)    - Yields values {v1, v2, ..., vN}.\n//  ValuesIn(container)        - Yields values from a C-style array, an STL\n//  ValuesIn(begin,end)          container, or an iterator range [begin, end).\n//  Bool()                     - Yields sequence {false, true}.\n//  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product\n//                               for the math savvy) of the values generated\n//                               by the N generators.\n//\n// For more details, see comments at the definitions of these functions below\n// in this file.\n//\n// The following statement will instantiate tests from the FooTest test case\n// each with parameter values \"meeny\", \"miny\", and \"moe\".\n\nINSTANTIATE_TEST_CASE_P(InstantiationName,\n                        FooTest,\n                        Values(\"meeny\", \"miny\", \"moe\"));\n\n// To distinguish different instances of the pattern, (yes, you\n// can instantiate it more then once) the first argument to the\n// INSTANTIATE_TEST_CASE_P macro is a prefix that will be added to the\n// actual test case name. Remember to pick unique prefixes for different\n// instantiations. The tests from the instantiation above will have\n// these names:\n//\n//    * InstantiationName/FooTest.DoesBlah/0 for \"meeny\"\n//    * InstantiationName/FooTest.DoesBlah/1 for \"miny\"\n//    * InstantiationName/FooTest.DoesBlah/2 for \"moe\"\n//    * InstantiationName/FooTest.HasBlahBlah/0 for \"meeny\"\n//    * InstantiationName/FooTest.HasBlahBlah/1 for \"miny\"\n//    * InstantiationName/FooTest.HasBlahBlah/2 for \"moe\"\n//\n// You can use these names in --gtest_filter.\n//\n// This statement will instantiate all tests from FooTest again, each\n// with parameter values \"cat\" and \"dog\":\n\nconst char* pets[] = {\"cat\", \"dog\"};\nINSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));\n\n// The tests from the instantiation above will have these names:\n//\n//    * AnotherInstantiationName/FooTest.DoesBlah/0 for \"cat\"\n//    * AnotherInstantiationName/FooTest.DoesBlah/1 for \"dog\"\n//    * AnotherInstantiationName/FooTest.HasBlahBlah/0 for \"cat\"\n//    * AnotherInstantiationName/FooTest.HasBlahBlah/1 for \"dog\"\n//\n// Please note that INSTANTIATE_TEST_CASE_P will instantiate all tests\n// in the given test case, whether their definitions come before or\n// AFTER the INSTANTIATE_TEST_CASE_P statement.\n//\n// Please also note that generator expressions (including parameters to the\n// generators) are evaluated in InitGoogleTest(), after main() has started.\n// This allows the user on one hand, to adjust generator parameters in order\n// to dynamically determine a set of tests to run and on the other hand,\n// give the user a chance to inspect the generated tests with Google Test\n// reflection API before RUN_ALL_TESTS() is executed.\n//\n// You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc\n// for more examples.\n//\n// In the future, we plan to publish the API for defining new parameter\n// generators. But for now this interface remains part of the internal\n// implementation and is subject to change.\n//\n//\n// A parameterized test fixture must be derived from testing::Test and from\n// testing::WithParamInterface<T>, where T is the type of the parameter\n// values. Inheriting from TestWithParam<T> satisfies that requirement because\n// TestWithParam<T> inherits from both Test and WithParamInterface. In more\n// complicated hierarchies, however, it is occasionally useful to inherit\n// separately from Test and WithParamInterface. For example:\n\nclass BaseTest : public ::testing::Test {\n  // You can inherit all the usual members for a non-parameterized test\n  // fixture here.\n};\n\nclass DerivedTest : public BaseTest, public ::testing::WithParamInterface<int> {\n  // The usual test fixture members go here too.\n};\n\nTEST_F(BaseTest, HasFoo) {\n  // This is an ordinary non-parameterized test.\n}\n\nTEST_P(DerivedTest, DoesBlah) {\n  // GetParam works just the same here as if you inherit from TestWithParam.\n  EXPECT_TRUE(foo.Blah(GetParam()));\n}\n\n#endif  // 0\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if !GTEST_OS_SYMBIAN\n# include <utility>\n#endif\n\n// scripts/fuse_gtest.py depends on gtest's own header being #included\n// *unconditionally*.  Therefore these #includes cannot be moved\n// inside #if GTEST_HAS_PARAM_TEST.\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-param-util.h\"\n#include \"gtest/internal/gtest-param-util-generated.h\"\n\n#if GTEST_HAS_PARAM_TEST\n\nnamespace testing {\n\n// Functions producing parameter generators.\n//\n// Google Test uses these generators to produce parameters for value-\n// parameterized tests. When a parameterized test case is instantiated\n// with a particular generator, Google Test creates and runs tests\n// for each element in the sequence produced by the generator.\n//\n// In the following sample, tests from test case FooTest are instantiated\n// each three times with parameter values 3, 5, and 8:\n//\n// class FooTest : public TestWithParam<int> { ... };\n//\n// TEST_P(FooTest, TestThis) {\n// }\n// TEST_P(FooTest, TestThat) {\n// }\n// INSTANTIATE_TEST_CASE_P(TestSequence, FooTest, Values(3, 5, 8));\n//\n\n// Range() returns generators providing sequences of values in a range.\n//\n// Synopsis:\n// Range(start, end)\n//   - returns a generator producing a sequence of values {start, start+1,\n//     start+2, ..., }.\n// Range(start, end, step)\n//   - returns a generator producing a sequence of values {start, start+step,\n//     start+step+step, ..., }.\n// Notes:\n//   * The generated sequences never include end. For example, Range(1, 5)\n//     returns a generator producing a sequence {1, 2, 3, 4}. Range(1, 9, 2)\n//     returns a generator producing {1, 3, 5, 7}.\n//   * start and end must have the same type. That type may be any integral or\n//     floating-point type or a user defined type satisfying these conditions:\n//     * It must be assignable (have operator=() defined).\n//     * It must have operator+() (operator+(int-compatible type) for\n//       two-operand version).\n//     * It must have operator<() defined.\n//     Elements in the resulting sequences will also have that type.\n//   * Condition start < end must be satisfied in order for resulting sequences\n//     to contain any elements.\n//\ntemplate <typename T, typename IncrementT>\ninternal::ParamGenerator<T> Range(T start, T end, IncrementT step) {\n  return internal::ParamGenerator<T>(\n      new internal::RangeGenerator<T, IncrementT>(start, end, step));\n}\n\ntemplate <typename T>\ninternal::ParamGenerator<T> Range(T start, T end) {\n  return Range(start, end, 1);\n}\n\n// ValuesIn() function allows generation of tests with parameters coming from\n// a container.\n//\n// Synopsis:\n// ValuesIn(const T (&array)[N])\n//   - returns a generator producing sequences with elements from\n//     a C-style array.\n// ValuesIn(const Container& container)\n//   - returns a generator producing sequences with elements from\n//     an STL-style container.\n// ValuesIn(Iterator begin, Iterator end)\n//   - returns a generator producing sequences with elements from\n//     a range [begin, end) defined by a pair of STL-style iterators. These\n//     iterators can also be plain C pointers.\n//\n// Please note that ValuesIn copies the values from the containers\n// passed in and keeps them to generate tests in RUN_ALL_TESTS().\n//\n// Examples:\n//\n// This instantiates tests from test case StringTest\n// each with C-string values of \"foo\", \"bar\", and \"baz\":\n//\n// const char* strings[] = {\"foo\", \"bar\", \"baz\"};\n// INSTANTIATE_TEST_CASE_P(StringSequence, SrtingTest, ValuesIn(strings));\n//\n// This instantiates tests from test case StlStringTest\n// each with STL strings with values \"a\" and \"b\":\n//\n// ::std::vector< ::std::string> GetParameterStrings() {\n//   ::std::vector< ::std::string> v;\n//   v.push_back(\"a\");\n//   v.push_back(\"b\");\n//   return v;\n// }\n//\n// INSTANTIATE_TEST_CASE_P(CharSequence,\n//                         StlStringTest,\n//                         ValuesIn(GetParameterStrings()));\n//\n//\n// This will also instantiate tests from CharTest\n// each with parameter values 'a' and 'b':\n//\n// ::std::list<char> GetParameterChars() {\n//   ::std::list<char> list;\n//   list.push_back('a');\n//   list.push_back('b');\n//   return list;\n// }\n// ::std::list<char> l = GetParameterChars();\n// INSTANTIATE_TEST_CASE_P(CharSequence2,\n//                         CharTest,\n//                         ValuesIn(l.begin(), l.end()));\n//\ntemplate <typename ForwardIterator>\ninternal::ParamGenerator<\n  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\nValuesIn(ForwardIterator begin, ForwardIterator end) {\n  typedef typename ::testing::internal::IteratorTraits<ForwardIterator>\n      ::value_type ParamType;\n  return internal::ParamGenerator<ParamType>(\n      new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));\n}\n\ntemplate <typename T, size_t N>\ninternal::ParamGenerator<T> ValuesIn(const T (&array)[N]) {\n  return ValuesIn(array, array + N);\n}\n\ntemplate <class Container>\ninternal::ParamGenerator<typename Container::value_type> ValuesIn(\n    const Container& container) {\n  return ValuesIn(container.begin(), container.end());\n}\n\n// Values() allows generating tests from explicitly specified list of\n// parameters.\n//\n// Synopsis:\n// Values(T v1, T v2, ..., T vN)\n//   - returns a generator producing sequences with elements v1, v2, ..., vN.\n//\n// For example, this instantiates tests from test case BarTest each\n// with values \"one\", \"two\", and \"three\":\n//\n// INSTANTIATE_TEST_CASE_P(NumSequence, BarTest, Values(\"one\", \"two\", \"three\"));\n//\n// This instantiates tests from test case BazTest each with values 1, 2, 3.5.\n// The exact type of values will depend on the type of parameter in BazTest.\n//\n// INSTANTIATE_TEST_CASE_P(FloatingNumbers, BazTest, Values(1, 2, 3.5));\n//\n// Currently, Values() supports from 1 to 50 parameters.\n//\ntemplate <typename T1>\ninternal::ValueArray1<T1> Values(T1 v1) {\n  return internal::ValueArray1<T1>(v1);\n}\n\ntemplate <typename T1, typename T2>\ninternal::ValueArray2<T1, T2> Values(T1 v1, T2 v2) {\n  return internal::ValueArray2<T1, T2>(v1, v2);\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninternal::ValueArray3<T1, T2, T3> Values(T1 v1, T2 v2, T3 v3) {\n  return internal::ValueArray3<T1, T2, T3>(v1, v2, v3);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninternal::ValueArray4<T1, T2, T3, T4> Values(T1 v1, T2 v2, T3 v3, T4 v4) {\n  return internal::ValueArray4<T1, T2, T3, T4>(v1, v2, v3, v4);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninternal::ValueArray5<T1, T2, T3, T4, T5> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5) {\n  return internal::ValueArray5<T1, T2, T3, T4, T5>(v1, v2, v3, v4, v5);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninternal::ValueArray6<T1, T2, T3, T4, T5, T6> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6) {\n  return internal::ValueArray6<T1, T2, T3, T4, T5, T6>(v1, v2, v3, v4, v5, v6);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninternal::ValueArray7<T1, T2, T3, T4, T5, T6, T7> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7) {\n  return internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>(v1, v2, v3, v4, v5,\n      v6, v7);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninternal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) {\n  return internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>(v1, v2, v3, v4,\n      v5, v6, v7, v8);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninternal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) {\n  return internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninternal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) {\n  return internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\ninternal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n    T11> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11) {\n  return internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n      T11>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\ninternal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n    T12> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12) {\n  return internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\ninternal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n    T13> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13) {\n  return internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\ninternal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) {\n  return internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\ninternal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) {\n  return internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\ninternal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16) {\n  return internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\ninternal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17) {\n  return internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\ninternal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18) {\n  return internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\ninternal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) {\n  return internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\ninternal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) {\n  return internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\ninternal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) {\n  return internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\ninternal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22) {\n  return internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\ninternal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23) {\n  return internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\ninternal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24) {\n  return internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\ninternal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) {\n  return internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\ninternal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n    T26> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26) {\n  return internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\ninternal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n    T27> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27) {\n  return internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\ninternal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n    T28> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28) {\n  return internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\ninternal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29) {\n  return internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\ninternal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) {\n  return internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\ninternal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) {\n  return internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\ninternal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32) {\n  return internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\ninternal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33) {\n  return internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\ninternal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34) {\n  return internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\ninternal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) {\n  return internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\ninternal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) {\n  return internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\ninternal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37) {\n  return internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\ninternal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38) {\n  return internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,\n      v33, v34, v35, v36, v37, v38);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\ninternal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38, T39 v39) {\n  return internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31,\n      v32, v33, v34, v35, v36, v37, v38, v39);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\ninternal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27,\n    T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35,\n    T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) {\n  return internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29,\n      v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\ninternal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n    T41> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) {\n  return internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,\n      v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\ninternal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n    T42> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42) {\n  return internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41,\n      v42);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\ninternal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n    T43> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43) {\n  return internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,\n      v41, v42, v43);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\ninternal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43, T44 v44) {\n  return internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39,\n      v40, v41, v42, v43, v44);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\ninternal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\n    T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\n    T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) {\n  return internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38,\n      v39, v40, v41, v42, v43, v44, v45);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\ninternal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) {\n  return internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\ninternal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) {\n  return internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\ninternal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47,\n    T48 v48) {\n  return internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36,\n      v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\ninternal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38,\n    T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46,\n    T47 v47, T48 v48, T49 v49) {\n  return internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35,\n      v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\ninternal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49, T50> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37,\n    T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45,\n    T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) {\n  return internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47,\n      v48, v49, v50);\n}\n\n// Bool() allows generating tests with parameters in a set of (false, true).\n//\n// Synopsis:\n// Bool()\n//   - returns a generator producing sequences with elements {false, true}.\n//\n// It is useful when testing code that depends on Boolean flags. Combinations\n// of multiple flags can be tested when several Bool()'s are combined using\n// Combine() function.\n//\n// In the following example all tests in the test case FlagDependentTest\n// will be instantiated twice with parameters false and true.\n//\n// class FlagDependentTest : public testing::TestWithParam<bool> {\n//   virtual void SetUp() {\n//     external_flag = GetParam();\n//   }\n// }\n// INSTANTIATE_TEST_CASE_P(BoolSequence, FlagDependentTest, Bool());\n//\ninline internal::ParamGenerator<bool> Bool() {\n  return Values(false, true);\n}\n\n# if GTEST_HAS_COMBINE\n// Combine() allows the user to combine two or more sequences to produce\n// values of a Cartesian product of those sequences' elements.\n//\n// Synopsis:\n// Combine(gen1, gen2, ..., genN)\n//   - returns a generator producing sequences with elements coming from\n//     the Cartesian product of elements from the sequences generated by\n//     gen1, gen2, ..., genN. The sequence elements will have a type of\n//     tuple<T1, T2, ..., TN> where T1, T2, ..., TN are the types\n//     of elements from sequences produces by gen1, gen2, ..., genN.\n//\n// Combine can have up to 10 arguments. This number is currently limited\n// by the maximum number of elements in the tuple implementation used by Google\n// Test.\n//\n// Example:\n//\n// This will instantiate tests in test case AnimalTest each one with\n// the parameter values tuple(\"cat\", BLACK), tuple(\"cat\", WHITE),\n// tuple(\"dog\", BLACK), and tuple(\"dog\", WHITE):\n//\n// enum Color { BLACK, GRAY, WHITE };\n// class AnimalTest\n//     : public testing::TestWithParam<tuple<const char*, Color> > {...};\n//\n// TEST_P(AnimalTest, AnimalLooksNice) {...}\n//\n// INSTANTIATE_TEST_CASE_P(AnimalVariations, AnimalTest,\n//                         Combine(Values(\"cat\", \"dog\"),\n//                                 Values(BLACK, WHITE)));\n//\n// This will instantiate tests in FlagDependentTest with all variations of two\n// Boolean flags:\n//\n// class FlagDependentTest\n//     : public testing::TestWithParam<tuple<bool, bool> > {\n//   virtual void SetUp() {\n//     // Assigns external_flag_1 and external_flag_2 values from the tuple.\n//     tie(external_flag_1, external_flag_2) = GetParam();\n//   }\n// };\n//\n// TEST_P(FlagDependentTest, TestFeature1) {\n//   // Test your code using external_flag_1 and external_flag_2 here.\n// }\n// INSTANTIATE_TEST_CASE_P(TwoBoolSequence, FlagDependentTest,\n//                         Combine(Bool(), Bool()));\n//\ntemplate <typename Generator1, typename Generator2>\ninternal::CartesianProductHolder2<Generator1, Generator2> Combine(\n    const Generator1& g1, const Generator2& g2) {\n  return internal::CartesianProductHolder2<Generator1, Generator2>(\n      g1, g2);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3>\ninternal::CartesianProductHolder3<Generator1, Generator2, Generator3> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3) {\n  return internal::CartesianProductHolder3<Generator1, Generator2, Generator3>(\n      g1, g2, g3);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4>\ninternal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n    Generator4> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4) {\n  return internal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n      Generator4>(\n      g1, g2, g3, g4);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5>\ninternal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n    Generator4, Generator5> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5) {\n  return internal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n      Generator4, Generator5>(\n      g1, g2, g3, g4, g5);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6>\ninternal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6) {\n  return internal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6>(\n      g1, g2, g3, g4, g5, g6);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7>\ninternal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7) {\n  return internal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7>(\n      g1, g2, g3, g4, g5, g6, g7);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8>\ninternal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8) {\n  return internal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8>(\n      g1, g2, g3, g4, g5, g6, g7, g8);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9>\ninternal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8,\n    Generator9> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9) {\n  return internal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9,\n    typename Generator10>\ninternal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n    Generator10> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9,\n        const Generator10& g10) {\n  return internal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n      Generator10>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9, g10);\n}\n# endif  // GTEST_HAS_COMBINE\n\n\n\n# define TEST_P(test_case_name, test_name) \\\n  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      : public test_case_name { \\\n   public: \\\n    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {} \\\n    virtual void TestBody(); \\\n   private: \\\n    static int AddToRegistry() { \\\n      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\n          GetTestCasePatternHolder<test_case_name>(\\\n              #test_case_name, \\\n              ::testing::internal::CodeLocation(\\\n                  __FILE__, __LINE__))->AddTestPattern(\\\n                      #test_case_name, \\\n                      #test_name, \\\n                      new ::testing::internal::TestMetaFactory< \\\n                          GTEST_TEST_CLASS_NAME_(\\\n                              test_case_name, test_name)>()); \\\n      return 0; \\\n    } \\\n    static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \\\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n        GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \\\n  }; \\\n  int GTEST_TEST_CLASS_NAME_(test_case_name, \\\n                             test_name)::gtest_registering_dummy_ = \\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::AddToRegistry(); \\\n  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n// The optional last argument to INSTANTIATE_TEST_CASE_P allows the user\n// to specify a function or functor that generates custom test name suffixes\n// based on the test parameters. The function should accept one argument of\n// type testing::TestParamInfo<class ParamType>, and return std::string.\n//\n// testing::PrintToStringParamName is a builtin test suffix generator that\n// returns the value of testing::PrintToString(GetParam()). It does not work\n// for std::string or C strings.\n//\n// Note: test names must be non-empty, unique, and may only contain ASCII\n// alphanumeric characters or underscore.\n\n# define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator, ...) \\\n  ::testing::internal::ParamGenerator<test_case_name::ParamType> \\\n      gtest_##prefix##test_case_name##_EvalGenerator_() { return generator; } \\\n  ::std::string gtest_##prefix##test_case_name##_EvalGenerateName_( \\\n      const ::testing::TestParamInfo<test_case_name::ParamType>& info) { \\\n    return ::testing::internal::GetParamNameGen<test_case_name::ParamType> \\\n        (__VA_ARGS__)(info); \\\n  } \\\n  int gtest_##prefix##test_case_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = \\\n      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\n          GetTestCasePatternHolder<test_case_name>(\\\n              #test_case_name, \\\n              ::testing::internal::CodeLocation(\\\n                  __FILE__, __LINE__))->AddTestCaseInstantiation(\\\n                      #prefix, \\\n                      &gtest_##prefix##test_case_name##_EvalGenerator_, \\\n                      &gtest_##prefix##test_case_name##_EvalGenerateName_, \\\n                      __FILE__, __LINE__)\n\n}  // namespace testing\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "content": "//===- unittest/AST/ASTImporterTest.cpp - AST node import test ------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Tests for the correct import of AST nodes from one AST context to another.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/SmallVectorMemoryBuffer.h\"\n\n#include \"clang/AST/DeclContextInternals.h\"\n#include \"gtest/gtest.h\"\n\n#include \"ASTImporterFixtures.h\"\n\nnamespace clang {\nnamespace ast_matchers {\n\nusing internal::Matcher;\nusing internal::BindableMatcher;\nusing llvm::StringMap;\n\nstatic const RecordDecl *getRecordDeclOfFriend(FriendDecl *FD) {\n  QualType Ty = FD->getFriendType()->getType().getCanonicalType();\n  return cast<RecordType>(Ty)->getDecl();\n}\n\nstruct ImportExpr : TestImportBase {};\nstruct ImportType : TestImportBase {};\nstruct ImportDecl : TestImportBase {};\nstruct ImportFixedPointExpr : ImportExpr {};\n\nstruct CanonicalRedeclChain : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(CanonicalRedeclChain, ShouldBeConsequentWithMatchers) {\n  Decl *FromTU = getTuDecl(\"void f();\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto Redecls = getCanonicalForwardRedeclChain(D0);\n  ASSERT_EQ(Redecls.size(), 1u);\n  EXPECT_EQ(D0, Redecls[0]);\n}\n\nTEST_P(CanonicalRedeclChain, ShouldBeConsequentWithMatchers2) {\n  Decl *FromTU = getTuDecl(\"void f(); void f(); void f();\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  auto *D2 = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  FunctionDecl *D1 = D2->getPreviousDecl();\n\n  auto Redecls = getCanonicalForwardRedeclChain(D0);\n  ASSERT_EQ(Redecls.size(), 3u);\n  EXPECT_EQ(D0, Redecls[0]);\n  EXPECT_EQ(D1, Redecls[1]);\n  EXPECT_EQ(D2, Redecls[2]);\n}\n\nTEST_P(CanonicalRedeclChain, ShouldBeSameForAllDeclInTheChain) {\n  Decl *FromTU = getTuDecl(\"void f(); void f(); void f();\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  auto *D2 = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  FunctionDecl *D1 = D2->getPreviousDecl();\n\n  auto RedeclsD0 = getCanonicalForwardRedeclChain(D0);\n  auto RedeclsD1 = getCanonicalForwardRedeclChain(D1);\n  auto RedeclsD2 = getCanonicalForwardRedeclChain(D2);\n\n  EXPECT_THAT(RedeclsD0, ::testing::ContainerEq(RedeclsD1));\n  EXPECT_THAT(RedeclsD1, ::testing::ContainerEq(RedeclsD2));\n}\n\nnamespace {\nstruct RedirectingImporter : public ASTImporter {\n  using ASTImporter::ASTImporter;\n\nprotected:\n  llvm::Expected<Decl *> ImportImpl(Decl *FromD) override {\n    auto *ND = dyn_cast<NamedDecl>(FromD);\n    if (!ND || ND->getName() != \"shouldNotBeImported\")\n      return ASTImporter::ImportImpl(FromD);\n    for (Decl *D : getToContext().getTranslationUnitDecl()->decls()) {\n      if (auto *ND = dyn_cast<NamedDecl>(D))\n        if (ND->getName() == \"realDecl\") {\n          RegisterImportedDecl(FromD, ND);\n          return ND;\n        }\n    }\n    return ASTImporter::ImportImpl(FromD);\n  }\n};\n\n} // namespace\n\nstruct RedirectingImporterTest : ASTImporterOptionSpecificTestBase {\n  RedirectingImporterTest() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new RedirectingImporter(ToContext, ToFileManager, FromContext,\n                                     FromFileManager, MinimalImport,\n                                     SharedState);\n    };\n  }\n};\n\n// Test that an ASTImporter subclass can intercept an import call.\nTEST_P(RedirectingImporterTest, InterceptImport) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"class shouldNotBeImported {};\", Lang_CXX03,\n                      \"class realDecl {};\", Lang_CXX03, \"shouldNotBeImported\");\n  auto *Imported = cast<CXXRecordDecl>(To);\n  EXPECT_EQ(Imported->getQualifiedNameAsString(), \"realDecl\");\n\n  // Make sure our importer prevented the importing of the decl.\n  auto *ToTU = Imported->getTranslationUnitDecl();\n  auto Pattern = functionDecl(hasName(\"shouldNotBeImported\"));\n  unsigned count =\n      DeclCounterWithPredicate<CXXRecordDecl>().match(ToTU, Pattern);\n  EXPECT_EQ(0U, count);\n}\n\n// Test that when we indirectly import a declaration the custom ASTImporter\n// is still intercepting the import.\nTEST_P(RedirectingImporterTest, InterceptIndirectImport) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"class shouldNotBeImported {};\"\n                      \"class F { shouldNotBeImported f; };\",\n                      Lang_CXX03, \"class realDecl {};\", Lang_CXX03, \"F\");\n\n  // Make sure our ASTImporter prevented the importing of the decl.\n  auto *ToTU = To->getTranslationUnitDecl();\n  auto Pattern = functionDecl(hasName(\"shouldNotBeImported\"));\n  unsigned count =\n      DeclCounterWithPredicate<CXXRecordDecl>().match(ToTU, Pattern);\n  EXPECT_EQ(0U, count);\n}\n\nstruct ImportPath : ASTImporterOptionSpecificTestBase {\n  Decl *FromTU;\n  FunctionDecl *D0, *D1, *D2;\n  ImportPath() {\n    FromTU = getTuDecl(\"void f(); void f(); void f();\", Lang_CXX03);\n    auto Pattern = functionDecl(hasName(\"f\"));\n    D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    D2 = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    D1 = D2->getPreviousDecl();\n  }\n};\n\nTEST_P(ImportPath, Push) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  EXPECT_FALSE(path.hasCycleAtBack());\n}\n\nTEST_P(ImportPath, SmallCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  path.pop();\n  EXPECT_FALSE(path.hasCycleAtBack());\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n}\n\nTEST_P(ImportPath, GetSmallCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  std::array<Decl* ,2> Res;\n  int i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 2);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D0);\n}\n\nTEST_P(ImportPath, GetCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D1);\n  path.push(D2);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  std::array<Decl* ,4> Res;\n  int i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 4);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D2);\n  EXPECT_EQ(Res[2], D1);\n  EXPECT_EQ(Res[3], D0);\n}\n\nTEST_P(ImportPath, CycleAfterCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D1);\n  path.push(D0);\n  path.push(D1);\n  path.push(D2);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  std::array<Decl* ,4> Res;\n  int i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 4);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D2);\n  EXPECT_EQ(Res[2], D1);\n  EXPECT_EQ(Res[3], D0);\n\n  path.pop();\n  path.pop();\n  path.pop();\n  EXPECT_TRUE(path.hasCycleAtBack());\n  i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 3);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D1);\n  EXPECT_EQ(Res[2], D0);\n\n  path.pop();\n  EXPECT_FALSE(path.hasCycleAtBack());\n}\n\nTEST_P(ImportExpr, ImportStringLiteral) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)\\\"foo\\\"; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 stringLiteral(hasType(asString(\"const char [4]\"))))));\n  testImport(\"void declToImport() { (void)L\\\"foo\\\"; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 stringLiteral(hasType(asString(\"const wchar_t [4]\"))))));\n  testImport(\"void declToImport() { (void) \\\"foo\\\" \\\"bar\\\"; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 stringLiteral(hasType(asString(\"const char [7]\"))))));\n}\n\nTEST_P(ImportExpr, ImportChooseExpr) {\n  MatchVerifier<Decl> Verifier;\n\n  // This case tests C code that is not condition-dependent and has a true\n  // condition.\n  testImport(\"void declToImport() { (void)__builtin_choose_expr(1, 2, 3); }\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(chooseExpr())));\n}\n\nTEST_P(ImportExpr, ImportGNUNullExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)__null; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(gnuNullExpr(hasType(isInteger())))));\n}\n\nTEST_P(ImportExpr, ImportGenericSelectionExpr) {\n  MatchVerifier<Decl> Verifier;\n\n  testImport(\n      \"void declToImport() { int x; (void)_Generic(x, int: 0, float: 1); }\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      functionDecl(hasDescendant(genericSelectionExpr())));\n}\n\nTEST_P(ImportExpr, ImportCXXNullPtrLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { (void)nullptr; }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      functionDecl(hasDescendant(cxxNullPtrLiteralExpr())));\n}\n\n\nTEST_P(ImportExpr, ImportFloatinglLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)1.0; }\", Lang_C99, \"\", Lang_C99,\n             Verifier,\n             functionDecl(hasDescendant(\n                 floatLiteral(equals(1.0), hasType(asString(\"double\"))))));\n  testImport(\"void declToImport() { (void)1.0e-5f; }\", Lang_C99, \"\", Lang_C99,\n             Verifier,\n             functionDecl(hasDescendant(\n                 floatLiteral(equals(1.0e-5f), hasType(asString(\"float\"))))));\n}\n\nTEST_P(ImportFixedPointExpr, ImportFixedPointerLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)1.0k; }\", Lang_C99, \"\", Lang_C99,\n             Verifier, functionDecl(hasDescendant(fixedPointLiteral())));\n  testImport(\"void declToImport() { (void)0.75r; }\", Lang_C99, \"\", Lang_C99,\n             Verifier, functionDecl(hasDescendant(fixedPointLiteral())));\n}\n\nTEST_P(ImportExpr, ImportImaginaryLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { (void)1.0i; }\",\n      Lang_CXX14, \"\", Lang_CXX14, Verifier,\n      functionDecl(hasDescendant(imaginaryLiteral())));\n}\n\nTEST_P(ImportExpr, ImportCompoundLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() {\"\n             \"  struct s { int x; long y; unsigned z; }; \"\n             \"  (void)(struct s){ 42, 0L, 1U }; }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(compoundLiteralExpr(\n                 hasType(asString(\"struct s\")),\n                 has(initListExpr(\n                     hasType(asString(\"struct s\")),\n                     has(integerLiteral(equals(42), hasType(asString(\"int\")))),\n                     has(integerLiteral(equals(0), hasType(asString(\"long\")))),\n                     has(integerLiteral(\n                         equals(1), hasType(asString(\"unsigned int\"))))))))));\n}\n\nTEST_P(ImportExpr, ImportCXXThisExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"class declToImport { void f() { (void)this; } };\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             cxxRecordDecl(hasMethod(hasDescendant(\n                 cxxThisExpr(hasType(asString(\"class declToImport *\")))))));\n}\n\nTEST_P(ImportExpr, ImportAtomicExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { int *ptr; __atomic_load_n(ptr, 1); }\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(atomicExpr(\n                 has(ignoringParenImpCasts(\n                     declRefExpr(hasDeclaration(varDecl(hasName(\"ptr\"))),\n                                 hasType(asString(\"int *\"))))),\n                 has(integerLiteral(equals(1), hasType(asString(\"int\"))))))));\n}\n\nTEST_P(ImportExpr, ImportLabelDeclAndAddrLabelExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { loop: goto loop; (void)&&loop; }\", Lang_C99,\n             \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(labelStmt(\n                              hasDeclaration(labelDecl(hasName(\"loop\"))))),\n                          hasDescendant(addrLabelExpr(\n                              hasDeclaration(labelDecl(hasName(\"loop\")))))));\n}\n\nAST_MATCHER_P(TemplateDecl, hasTemplateDecl,\n              internal::Matcher<NamedDecl>, InnerMatcher) {\n  const NamedDecl *Template = Node.getTemplatedDecl();\n  return Template && InnerMatcher.matches(*Template, Finder, Builder);\n}\n\nTEST_P(ImportExpr, ImportParenListExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template<typename T> class dummy { void f() { dummy X(*this); } };\"\n      \"typedef dummy<int> declToImport;\"\n      \"template class dummy<int>;\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      typedefDecl(hasType(templateSpecializationType(\n          hasDeclaration(classTemplateSpecializationDecl(hasSpecializedTemplate(\n              classTemplateDecl(hasTemplateDecl(cxxRecordDecl(hasMethod(allOf(\n                  hasName(\"f\"),\n                  hasBody(compoundStmt(has(declStmt(hasSingleDecl(\n                      varDecl(hasInitializer(parenListExpr(has(unaryOperator(\n                          hasOperatorName(\"*\"),\n                          hasUnaryOperand(cxxThisExpr())))))))))))))))))))))));\n}\n\nTEST_P(ImportExpr, ImportSwitch) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { int b; switch (b) { case 1: break; } }\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(\n                 switchStmt(has(compoundStmt(has(caseStmt())))))));\n}\n\nTEST_P(ImportExpr, ImportStmtExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { int b; int a = b ?: 1; int C = ({int X=4; X;}); }\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(varDecl(\n                   hasName(\"C\"), hasType(asString(\"int\")),\n                   hasInitializer(stmtExpr(\n                       hasAnySubstatement(declStmt(hasSingleDecl(varDecl(\n                           hasName(\"X\"), hasType(asString(\"int\")),\n                           hasInitializer(integerLiteral(equals(4))))))),\n                       hasDescendant(implicitCastExpr()))))))));\n}\n\nTEST_P(ImportExpr, ImportConditionalOperator) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)(true ? 1 : -5); }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(conditionalOperator(\n                 hasCondition(cxxBoolLiteral(equals(true))),\n                 hasTrueExpression(integerLiteral(equals(1))),\n                 hasFalseExpression(unaryOperator(\n                     hasUnaryOperand(integerLiteral(equals(5)))))))));\n}\n\nTEST_P(ImportExpr, ImportBinaryConditionalOperator) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { (void)(1 ?: -5); }\", Lang_CXX03, \"\", Lang_CXX03,\n      Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(binaryConditionalOperator(\n                   hasCondition(implicitCastExpr(\n                       hasSourceExpression(opaqueValueExpr(\n                           hasSourceExpression(integerLiteral(equals(1))))),\n                       hasType(booleanType()))),\n                   hasTrueExpression(opaqueValueExpr(\n                       hasSourceExpression(integerLiteral(equals(1))))),\n                   hasFalseExpression(unaryOperator(\n                       hasOperatorName(\"-\"),\n                       hasUnaryOperand(integerLiteral(equals(5))))))))));\n}\n\nTEST_P(ImportExpr, ImportDesignatedInitExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() {\"\n      \"  struct point { double x; double y; };\"\n      \"  struct point ptarray[10] = \"\n      \"{ [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 }; }\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      functionDecl(hasDescendant(initListExpr(\n          has(designatedInitExpr(designatorCountIs(2),\n                                 hasDescendant(floatLiteral(equals(1.0))),\n                                 hasDescendant(integerLiteral(equals(2))))),\n          has(designatedInitExpr(designatorCountIs(2),\n                                 hasDescendant(floatLiteral(equals(2.0))),\n                                 hasDescendant(integerLiteral(equals(2))))),\n          has(designatedInitExpr(designatorCountIs(2),\n                                 hasDescendant(floatLiteral(equals(1.0))),\n                                 hasDescendant(integerLiteral(equals(0)))))))));\n}\n\nTEST_P(ImportExpr, ImportPredefinedExpr) {\n  MatchVerifier<Decl> Verifier;\n  // __func__ expands as StringLiteral(\"declToImport\")\n  testImport(\"void declToImport() { (void)__func__; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(predefinedExpr(\n                 hasType(asString(\"const char [13]\")),\n                 has(stringLiteral(hasType(asString(\"const char [13]\"))))))));\n}\n\nTEST_P(ImportExpr, ImportInitListExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() {\"\n      \"  struct point { double x; double y; };\"\n      \"  point ptarray[10] = { [2].y = 1.0, [2].x = 2.0,\"\n      \"                        [0].x = 1.0 }; }\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      functionDecl(hasDescendant(initListExpr(\n          has(cxxConstructExpr(requiresZeroInitialization())),\n          has(initListExpr(\n              hasType(asString(\"struct point\")), has(floatLiteral(equals(1.0))),\n              has(implicitValueInitExpr(hasType(asString(\"double\")))))),\n          has(initListExpr(hasType(asString(\"struct point\")),\n                           has(floatLiteral(equals(2.0))),\n                           has(floatLiteral(equals(1.0)))))))));\n}\n\n\nconst internal::VariadicDynCastAllOfMatcher<Expr, VAArgExpr> vaArgExpr;\n\nTEST_P(ImportExpr, ImportVAArgExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport(__builtin_va_list list, ...) {\"\n             \"  (void)__builtin_va_arg(list, int); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 cStyleCastExpr(hasSourceExpression(vaArgExpr())))));\n}\n\nTEST_P(ImportExpr, CXXTemporaryObjectExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"struct C {};\"\n      \"void declToImport() { C c = C(); }\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(exprWithCleanups(has(cxxConstructExpr(\n                   has(materializeTemporaryExpr(has(implicitCastExpr(\n                       has(cxxTemporaryObjectExpr()))))))))))));\n}\n\nTEST_P(ImportType, ImportAtomicType) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { typedef _Atomic(int) a_int; }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      functionDecl(hasDescendant(typedefDecl(has(atomicType())))));\n}\n\nTEST_P(ImportDecl, ImportFunctionTemplateDecl) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> void declToImport() { };\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier, functionTemplateDecl());\n}\n\nTEST_P(ImportExpr, ImportCXXDependentScopeMemberExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  (void)d.t;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 cStyleCastExpr(has(cxxDependentScopeMemberExpr())))));\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  (void)(&d)->t;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 cStyleCastExpr(has(cxxDependentScopeMemberExpr())))));\n}\n\nTEST_P(ImportType, ImportTypeAliasTemplate) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template <int K>\"\n      \"struct dummy { static const int i = K; };\"\n      \"template <int K> using dummy2 = dummy<K>;\"\n      \"int declToImport() { return dummy2<3>::i; }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(implicitCastExpr(has(declRefExpr()))),\n                            unless(hasAncestor(\n                                translationUnitDecl(has(typeAliasDecl())))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Decl, VarTemplateSpecializationDecl>\n    varTemplateSpecializationDecl;\n\nTEST_P(ImportDecl, ImportVarTemplate) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template <typename T>\"\n      \"T pi = T(3.1415926535897932385L);\"\n      \"void declToImport() { (void)pi<int>; }\",\n      Lang_CXX14, \"\", Lang_CXX14, Verifier,\n      functionDecl(\n          hasDescendant(declRefExpr(to(varTemplateSpecializationDecl()))),\n          unless(hasAncestor(translationUnitDecl(has(varDecl(\n              hasName(\"pi\"), unless(varTemplateSpecializationDecl()))))))));\n}\n\nTEST_P(ImportType, ImportPackExpansion) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename... Args>\"\n             \"struct dummy {\"\n             \"  dummy(Args... args) {}\"\n             \"  static const int i = 4;\"\n             \"};\"\n             \"int declToImport() { return dummy<int>::i; }\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             traverse(TK_AsIs, functionDecl(hasDescendant(returnStmt(has(\n                                   implicitCastExpr(has(declRefExpr()))))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Type,\n                                            DependentTemplateSpecializationType>\n    dependentTemplateSpecializationType;\n\nTEST_P(ImportType, ImportDependentTemplateSpecialization) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template<typename T>\"\n             \"struct A;\"\n             \"template<typename T>\"\n             \"struct declToImport {\"\n             \"  typename A<T>::template B<T> a;\"\n             \"};\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             classTemplateDecl(has(cxxRecordDecl(has(\n                 fieldDecl(hasType(dependentTemplateSpecializationType())))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Stmt, SizeOfPackExpr>\n    sizeOfPackExpr;\n\nTEST_P(ImportExpr, ImportSizeOfPackExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template <typename... Ts>\"\n      \"void declToImport() {\"\n      \"  const int i = sizeof...(Ts);\"\n      \"};\"\n      \"void g() { declToImport<int>(); }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n          functionTemplateDecl(hasDescendant(sizeOfPackExpr())));\n  testImport(\n      \"template <typename... Ts>\"\n      \"using X = int[sizeof...(Ts)];\"\n      \"template <typename... Us>\"\n      \"struct Y {\"\n      \"  X<Us..., int, double, int, Us...> f;\"\n      \"};\"\n      \"Y<float, int> declToImport;\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      varDecl(hasType(classTemplateSpecializationDecl(has(fieldDecl(hasType(\n          hasUnqualifiedDesugaredType(constantArrayType(hasSize(7))))))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Stmt, CXXFoldExpr> cxxFoldExpr;\n\nAST_MATCHER_P(CXXFoldExpr, hasOperator, BinaryOperatorKind, Op) {\n  return Node.getOperator() == Op;\n}\nAST_MATCHER(CXXFoldExpr, hasInit) { return Node.getInit(); }\nAST_MATCHER(CXXFoldExpr, isRightFold) { return Node.isRightFold(); }\nAST_MATCHER(CXXFoldExpr, isLeftFold) { return Node.isLeftFold(); }\n\nTEST_P(ImportExpr, ImportCXXFoldExpr) {\n  auto Match1 =\n      cxxFoldExpr(hasOperator(BO_Add), isLeftFold(), unless(hasInit()));\n  auto Match2 = cxxFoldExpr(hasOperator(BO_Sub), isLeftFold(), hasInit());\n  auto Match3 =\n      cxxFoldExpr(hasOperator(BO_Mul), isRightFold(), unless(hasInit()));\n  auto Match4 = cxxFoldExpr(hasOperator(BO_Div), isRightFold(), hasInit());\n\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename... Ts>\"\n             \"void declToImport(Ts... args) {\"\n             \"  const int i1 = (... + args);\"\n             \"  const int i2 = (1 - ... - args);\"\n             \"  const int i3 = (args * ...);\"\n             \"  const int i4 = (args / ... / 1);\"\n             \"};\"\n             \"void g() { declToImport(1, 2, 3, 4, 5); }\",\n             Lang_CXX17, \"\", Lang_CXX17, Verifier,\n             functionTemplateDecl(hasDescendant(Match1), hasDescendant(Match2),\n                                  hasDescendant(Match3),\n                                  hasDescendant(Match4)));\n}\n\n/// \\brief Matches __builtin_types_compatible_p:\n/// GNU extension to check equivalent types\n/// Given\n/// \\code\n///   __builtin_types_compatible_p(int, int)\n/// \\endcode\n//  will generate TypeTraitExpr <...> 'int'\nconst internal::VariadicDynCastAllOfMatcher<Stmt, TypeTraitExpr> typeTraitExpr;\n\nTEST_P(ImportExpr, ImportTypeTraitExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { \"\n      \"  (void)__builtin_types_compatible_p(int, int);\"\n      \"}\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      functionDecl(hasDescendant(typeTraitExpr(hasType(asString(\"int\"))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Stmt, CXXTypeidExpr> cxxTypeidExpr;\n\nTEST_P(ImportExpr, ImportCXXTypeidExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"namespace std { class type_info {}; }\"\n      \"void declToImport() {\"\n      \"  int x;\"\n      \"  auto a = typeid(int); auto b = typeid(x);\"\n      \"}\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      traverse(\n          TK_AsIs,\n          functionDecl(\n              hasDescendant(varDecl(hasName(\"a\"), hasInitializer(hasDescendant(\n                                                      cxxTypeidExpr())))),\n              hasDescendant(varDecl(hasName(\"b\"), hasInitializer(hasDescendant(\n                                                      cxxTypeidExpr())))))));\n}\n\nTEST_P(ImportExpr, ImportTypeTraitExprValDep) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template<typename T> struct declToImport {\"\n      \"  void m() { (void)__is_pod(T); }\"\n      \"};\"\n      \"void f() { declToImport<int>().m(); }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      classTemplateDecl(has(cxxRecordDecl(has(\n          functionDecl(hasDescendant(\n              typeTraitExpr(hasType(booleanType())))))))));\n}\n\nTEST_P(ImportDecl, ImportRecordDeclInFunc) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"int declToImport() { \"\n             \"  struct data_t {int a;int b;};\"\n             \"  struct data_t d;\"\n             \"  return 0;\"\n             \"}\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasBody(compoundStmt(\n                 has(declStmt(hasSingleDecl(varDecl(hasName(\"d\")))))))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportRecordTypeInFunc) {\n  Decl *FromTU = getTuDecl(\"int declToImport() { \"\n                           \"  struct data_t {int a;int b;};\"\n                           \"  struct data_t d;\"\n                           \"  return 0;\"\n                           \"}\",\n                           Lang_C99, \"input.c\");\n  auto *FromVar =\n      FirstDeclMatcher<VarDecl>().match(FromTU, varDecl(hasName(\"d\")));\n  ASSERT_TRUE(FromVar);\n  auto ToType =\n      ImportType(FromVar->getType().getCanonicalType(), FromVar, Lang_C99);\n  EXPECT_FALSE(ToType.isNull());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportRecordDeclInFuncParams) {\n  // This construct is not supported by ASTImporter.\n  Decl *FromTU = getTuDecl(\n      \"int declToImport(struct data_t{int a;int b;} ***d){ return 0; }\",\n      Lang_C99, \"input.c\");\n  auto *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"declToImport\")));\n  ASSERT_TRUE(From);\n  auto *To = Import(From, Lang_C99);\n  EXPECT_EQ(To, nullptr);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportRecordDeclInFuncFromMacro) {\n  Decl *FromTU =\n      getTuDecl(\"#define NONAME_SIZEOF(type) sizeof(struct{type *dummy;}) \\n\"\n                \"int declToImport(){ return NONAME_SIZEOF(int); }\",\n                Lang_C99, \"input.c\");\n  auto *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"declToImport\")));\n  ASSERT_TRUE(From);\n  auto *To = Import(From, Lang_C99);\n  ASSERT_TRUE(To);\n  EXPECT_TRUE(MatchVerifier<FunctionDecl>().match(\n      To, functionDecl(hasName(\"declToImport\"),\n                       hasDescendant(unaryExprOrTypeTraitExpr()))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportRecordDeclInFuncParamsFromMacro) {\n  // This construct is not supported by ASTImporter.\n  Decl *FromTU =\n      getTuDecl(\"#define PAIR_STRUCT(type) struct data_t{type a;type b;} \\n\"\n                \"int declToImport(PAIR_STRUCT(int) ***d){ return 0; }\",\n                Lang_C99, \"input.c\");\n  auto *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"declToImport\")));\n  ASSERT_TRUE(From);\n  auto *To = Import(From, Lang_C99);\n  EXPECT_EQ(To, nullptr);\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Expr, CXXPseudoDestructorExpr>\n    cxxPseudoDestructorExpr;\n\nTEST_P(ImportExpr, ImportCXXPseudoDestructorExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"typedef int T;\"\n      \"void declToImport(int *p) {\"\n      \"  T t;\"\n      \"  p->T::~T();\"\n      \"}\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      functionDecl(hasDescendant(callExpr(has(cxxPseudoDestructorExpr())))));\n}\n\nTEST_P(ImportDecl, ImportUsingDecl) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"namespace foo { int bar; }\"\n             \"void declToImport() { using foo::bar; }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(usingDecl())));\n}\n\n/// \\brief Matches shadow declarations introduced into a scope by a\n///        (resolved) using declaration.\n///\n/// Given\n/// \\code\n///   namespace n { int f; }\n///   namespace declToImport { using n::f; }\n/// \\endcode\n/// usingShadowDecl()\n///   matches \\code f \\endcode\nconst internal::VariadicDynCastAllOfMatcher<Decl,\n                                            UsingShadowDecl> usingShadowDecl;\n\nTEST_P(ImportDecl, ImportUsingShadowDecl) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"namespace foo { int bar; }\"\n             \"namespace declToImport { using foo::bar; }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             namespaceDecl(has(usingShadowDecl())));\n}\n\nTEST_P(ImportExpr, ImportUnresolvedLookupExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template<typename T> int foo();\"\n             \"template <typename T> void declToImport() {\"\n             \"  (void)::foo<T>;\"\n             \"  (void)::template foo<T>;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(unresolvedLookupExpr())));\n}\n\nTEST_P(ImportExpr, ImportCXXUnresolvedConstructExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  d.t = T();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 binaryOperator(has(cxxUnresolvedConstructExpr())))));\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  (&d)->t = T();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 binaryOperator(has(cxxUnresolvedConstructExpr())))));\n}\n\n/// Check that function \"declToImport()\" (which is the templated function\n/// for corresponding FunctionTemplateDecl) is not added into DeclContext.\n/// Same for class template declarations.\nTEST_P(ImportDecl, ImportTemplatedDeclForTemplate) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> void declToImport() { T a = 1; }\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasAncestor(translationUnitDecl(\n                 unless(has(functionDecl(hasName(\"declToImport\"))))))));\n  testImport(\"template <typename T> struct declToImport { T t; };\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             classTemplateDecl(hasAncestor(translationUnitDecl(\n                 unless(has(cxxRecordDecl(hasName(\"declToImport\"))))))));\n}\n\nTEST_P(ImportDecl, ImportClassTemplatePartialSpecialization) {\n  MatchVerifier<Decl> Verifier;\n  auto Code =\n      R\"s(\n      struct declToImport {\n        template <typename T0> struct X;\n        template <typename T0> struct X<T0 *> {};\n      };\n      )s\";\n  testImport(Code, Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             recordDecl(has(classTemplateDecl()),\n                        has(classTemplateSpecializationDecl())));\n}\n\nTEST_P(ImportExpr, CXXOperatorCallExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"class declToImport {\"\n      \"  void f() { *this = declToImport(); }\"\n      \"};\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      cxxRecordDecl(has(cxxMethodDecl(hasDescendant(cxxOperatorCallExpr())))));\n}\n\nTEST_P(ImportExpr, DependentSizedArrayType) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template<typename T, int Size> class declToImport {\"\n             \"  T data[Size];\"\n             \"};\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             classTemplateDecl(has(cxxRecordDecl(\n                 has(fieldDecl(hasType(dependentSizedArrayType())))))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, TemplateTypeParmDeclNoDefaultArg) {\n  Decl *FromTU = getTuDecl(\"template<typename T> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<TemplateTypeParmDecl>().match(\n      FromTU, templateTypeParmDecl(hasName(\"T\")));\n  TemplateTypeParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_FALSE(To->hasDefaultArgument());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, TemplateTypeParmDeclDefaultArg) {\n  Decl *FromTU =\n      getTuDecl(\"template<typename T = int> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<TemplateTypeParmDecl>().match(\n      FromTU, templateTypeParmDecl(hasName(\"T\")));\n  TemplateTypeParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_TRUE(To->hasDefaultArgument());\n  QualType ToArg = To->getDefaultArgument();\n  ASSERT_EQ(ToArg, QualType(To->getASTContext().IntTy));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportBeginLocOfDeclRefExpr) {\n  Decl *FromTU =\n      getTuDecl(\"class A { public: static int X; }; void f() { (void)A::X; }\",\n                Lang_CXX03);\n  auto From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  ASSERT_TRUE(From);\n  ASSERT_TRUE(\n      cast<CStyleCastExpr>(cast<CompoundStmt>(From->getBody())->body_front())\n          ->getSubExpr()\n          ->getBeginLoc()\n          .isValid());\n  FunctionDecl *To = Import(From, Lang_CXX03);\n  ASSERT_TRUE(To);\n  ASSERT_TRUE(\n      cast<CStyleCastExpr>(cast<CompoundStmt>(To->getBody())->body_front())\n          ->getSubExpr()\n          ->getBeginLoc()\n          .isValid());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TemplateTemplateParmDeclNoDefaultArg) {\n  Decl *FromTU = getTuDecl(R\"(\n                           template<template<typename> typename TT> struct Y {};\n                           )\",\n                           Lang_CXX17);\n  auto From = FirstDeclMatcher<TemplateTemplateParmDecl>().match(\n      FromTU, templateTemplateParmDecl(hasName(\"TT\")));\n  TemplateTemplateParmDecl *To = Import(From, Lang_CXX17);\n  ASSERT_FALSE(To->hasDefaultArgument());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, TemplateTemplateParmDeclDefaultArg) {\n  Decl *FromTU = getTuDecl(R\"(\n                           template<typename T> struct X {};\n                           template<template<typename> typename TT = X> struct Y {};\n                           )\",\n                           Lang_CXX17);\n  auto From = FirstDeclMatcher<TemplateTemplateParmDecl>().match(\n      FromTU, templateTemplateParmDecl(hasName(\"TT\")));\n  TemplateTemplateParmDecl *To = Import(From, Lang_CXX17);\n  ASSERT_TRUE(To->hasDefaultArgument());\n  const TemplateArgument &ToDefaultArg = To->getDefaultArgument().getArgument();\n  ASSERT_TRUE(To->isTemplateDecl());\n  TemplateDecl *ToTemplate = ToDefaultArg.getAsTemplate().getAsTemplateDecl();\n\n  // Find the default argument template 'X' in the AST and compare it against\n  // the default argument we got.\n  auto ToExpectedDecl = FirstDeclMatcher<ClassTemplateDecl>().match(\n      To->getTranslationUnitDecl(), classTemplateDecl(hasName(\"X\")));\n  ASSERT_EQ(ToTemplate, ToExpectedDecl);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, NonTypeTemplateParmDeclNoDefaultArg) {\n  Decl *FromTU = getTuDecl(\"template<int N> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<NonTypeTemplateParmDecl>().match(\n      FromTU, nonTypeTemplateParmDecl(hasName(\"N\")));\n  NonTypeTemplateParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_FALSE(To->hasDefaultArgument());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, NonTypeTemplateParmDeclDefaultArg) {\n  Decl *FromTU = getTuDecl(\"template<int S = 1> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<NonTypeTemplateParmDecl>().match(\n      FromTU, nonTypeTemplateParmDecl(hasName(\"S\")));\n  NonTypeTemplateParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_TRUE(To->hasDefaultArgument());\n  Stmt *ToArg = To->getDefaultArgument();\n  ASSERT_TRUE(isa<ConstantExpr>(ToArg));\n  ToArg = *ToArg->child_begin();\n  ASSERT_TRUE(isa<IntegerLiteral>(ToArg));\n  ASSERT_EQ(cast<IntegerLiteral>(ToArg)->getValue().getLimitedValue(), 1U);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclOfClassTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> struct S{};\", Lang_CXX03);\n  auto From =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTU, classTemplateDecl());\n  ASSERT_TRUE(From);\n  auto To = cast<ClassTemplateDecl>(Import(From, Lang_CXX03));\n  ASSERT_TRUE(To);\n  Decl *ToTemplated = To->getTemplatedDecl();\n  Decl *ToTemplated1 = Import(From->getTemplatedDecl(), Lang_CXX03);\n  EXPECT_TRUE(ToTemplated1);\n  EXPECT_EQ(ToTemplated1, ToTemplated);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclOfFunctionTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> void f(){}\", Lang_CXX03);\n  auto From = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU, functionTemplateDecl());\n  ASSERT_TRUE(From);\n  auto To = cast<FunctionTemplateDecl>(Import(From, Lang_CXX03));\n  ASSERT_TRUE(To);\n  Decl *ToTemplated = To->getTemplatedDecl();\n  Decl *ToTemplated1 = Import(From->getTemplatedDecl(), Lang_CXX03);\n  EXPECT_TRUE(ToTemplated1);\n  EXPECT_EQ(ToTemplated1, ToTemplated);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclShouldImportTheClassTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> struct S{};\", Lang_CXX03);\n  auto FromFT =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTU, classTemplateDecl());\n  ASSERT_TRUE(FromFT);\n\n  auto ToTemplated =\n      cast<CXXRecordDecl>(Import(FromFT->getTemplatedDecl(), Lang_CXX03));\n  EXPECT_TRUE(ToTemplated);\n  auto ToTU = ToTemplated->getTranslationUnitDecl();\n  auto ToFT =\n      FirstDeclMatcher<ClassTemplateDecl>().match(ToTU, classTemplateDecl());\n  EXPECT_TRUE(ToFT);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclShouldImportTheFunctionTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> void f(){}\", Lang_CXX03);\n  auto FromFT = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU, functionTemplateDecl());\n  ASSERT_TRUE(FromFT);\n\n  auto ToTemplated =\n      cast<FunctionDecl>(Import(FromFT->getTemplatedDecl(), Lang_CXX03));\n  EXPECT_TRUE(ToTemplated);\n  auto ToTU = ToTemplated->getTranslationUnitDecl();\n  auto ToFT = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      ToTU, functionTemplateDecl());\n  EXPECT_TRUE(ToFT);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportCorrectTemplatedDecl) {\n  auto Code =\n        R\"(\n        namespace x {\n          template<class X> struct S1{};\n          template<class X> struct S2{};\n          template<class X> struct S3{};\n        }\n        )\";\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  auto FromNs =\n      FirstDeclMatcher<NamespaceDecl>().match(FromTU, namespaceDecl());\n  auto ToNs = cast<NamespaceDecl>(Import(FromNs, Lang_CXX03));\n  ASSERT_TRUE(ToNs);\n  auto From =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTU,\n                                                  classTemplateDecl(\n                                                      hasName(\"S2\")));\n  auto To =\n      FirstDeclMatcher<ClassTemplateDecl>().match(ToNs,\n                                                  classTemplateDecl(\n                                                      hasName(\"S2\")));\n  ASSERT_TRUE(From);\n  ASSERT_TRUE(To);\n  auto ToTemplated = To->getTemplatedDecl();\n  auto ToTemplated1 =\n      cast<CXXRecordDecl>(Import(From->getTemplatedDecl(), Lang_CXX03));\n  EXPECT_TRUE(ToTemplated1);\n  ASSERT_EQ(ToTemplated1, ToTemplated);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportChooseExpr) {\n  // This tests the import of isConditionTrue directly to make sure the importer\n  // gets it right.\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      \"void declToImport() { (void)__builtin_choose_expr(1, 0, 1); }\", Lang_C99,\n      \"\", Lang_C99);\n\n  auto ToResults = match(chooseExpr().bind(\"choose\"), To->getASTContext());\n  auto FromResults = match(chooseExpr().bind(\"choose\"), From->getASTContext());\n\n  const ChooseExpr *FromChooseExpr =\n      selectFirst<ChooseExpr>(\"choose\", FromResults);\n  ASSERT_TRUE(FromChooseExpr);\n\n  const ChooseExpr *ToChooseExpr = selectFirst<ChooseExpr>(\"choose\", ToResults);\n  ASSERT_TRUE(ToChooseExpr);\n\n  EXPECT_EQ(FromChooseExpr->isConditionTrue(), ToChooseExpr->isConditionTrue());\n  EXPECT_EQ(FromChooseExpr->isConditionDependent(),\n            ToChooseExpr->isConditionDependent());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportGenericSelectionExpr) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      int declToImport() {\n        int x;\n        return _Generic(x, int: 0, default: 1);\n      }\n      )\",\n      Lang_C99, \"\", Lang_C99);\n\n  auto ToResults =\n      match(genericSelectionExpr().bind(\"expr\"), To->getASTContext());\n  auto FromResults =\n      match(genericSelectionExpr().bind(\"expr\"), From->getASTContext());\n\n  const GenericSelectionExpr *FromGenericSelectionExpr =\n      selectFirst<GenericSelectionExpr>(\"expr\", FromResults);\n  ASSERT_TRUE(FromGenericSelectionExpr);\n\n  const GenericSelectionExpr *ToGenericSelectionExpr =\n      selectFirst<GenericSelectionExpr>(\"expr\", ToResults);\n  ASSERT_TRUE(ToGenericSelectionExpr);\n\n  EXPECT_EQ(FromGenericSelectionExpr->isResultDependent(),\n            ToGenericSelectionExpr->isResultDependent());\n  EXPECT_EQ(FromGenericSelectionExpr->getResultIndex(),\n            ToGenericSelectionExpr->getResultIndex());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportFunctionWithBackReferringParameter) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template <typename T> struct X {};\n\n      void declToImport(int y, X<int> &x) {}\n\n      template <> struct X<int> {\n        void g() {\n          X<int> x;\n          declToImport(0, x);\n        }\n      };\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  auto Matcher = functionDecl(hasName(\"declToImport\"),\n                              parameterCountIs(2),\n                              hasParameter(0, hasName(\"y\")),\n                              hasParameter(1, hasName(\"x\")),\n                              hasParameter(1, hasType(asString(\"X<int> &\"))));\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainTemplatedDeclOfFunctionTemplates) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"template <typename T> void declToImport() { T a = 1; }\"\n                      \"void instantiate() { declToImport<int>(); }\",\n                      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto Check = [](Decl *D) -> bool {\n    auto TU = D->getTranslationUnitDecl();\n    for (auto Child : TU->decls()) {\n      if (auto *FD = dyn_cast<FunctionDecl>(Child)) {\n        if (FD->getNameAsString() == \"declToImport\") {\n          GTEST_NONFATAL_FAILURE_(\n              \"TU should not contain any FunctionDecl with name declToImport\");\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  ASSERT_TRUE(Check(From));\n  EXPECT_TRUE(Check(To));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainTemplatedDeclOfClassTemplates) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"template <typename T> struct declToImport { T t; };\"\n                      \"void instantiate() { declToImport<int>(); }\",\n                      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto Check = [](Decl *D) -> bool {\n    auto TU = D->getTranslationUnitDecl();\n    for (auto Child : TU->decls()) {\n      if (auto *RD = dyn_cast<CXXRecordDecl>(Child)) {\n        if (RD->getNameAsString() == \"declToImport\") {\n          GTEST_NONFATAL_FAILURE_(\n              \"TU should not contain any CXXRecordDecl with name declToImport\");\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  ASSERT_TRUE(Check(From));\n  EXPECT_TRUE(Check(To));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainTemplatedDeclOfTypeAlias) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\n          \"template <typename T> struct X {};\"\n          \"template <typename T> using declToImport = X<T>;\"\n          \"void instantiate() { declToImport<int> a; }\",\n                      Lang_CXX11, \"\", Lang_CXX11);\n\n  auto Check = [](Decl *D) -> bool {\n    auto TU = D->getTranslationUnitDecl();\n    for (auto Child : TU->decls()) {\n      if (auto *AD = dyn_cast<TypeAliasDecl>(Child)) {\n        if (AD->getNameAsString() == \"declToImport\") {\n          GTEST_NONFATAL_FAILURE_(\n              \"TU should not contain any TypeAliasDecl with name declToImport\");\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  ASSERT_TRUE(Check(From));\n  EXPECT_TRUE(Check(To));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainClassTemplateSpecializationOfImplicitInstantiation) {\n\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template<class T>\n      class Base {};\n      class declToImport : public Base<declToImport> {};\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  // Check that the ClassTemplateSpecializationDecl is NOT the child of the TU.\n  auto Pattern =\n      translationUnitDecl(unless(has(classTemplateSpecializationDecl())));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n\n  // Check that the ClassTemplateSpecializationDecl is the child of the\n  // ClassTemplateDecl.\n  Pattern = translationUnitDecl(has(classTemplateDecl(\n      hasName(\"Base\"), has(classTemplateSpecializationDecl()))));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n}\n\nAST_MATCHER_P(RecordDecl, hasFieldOrder, std::vector<StringRef>, Order) {\n  size_t Index = 0;\n  for (Decl *D : Node.decls()) {\n    if (isa<FieldDecl>(D) || isa<IndirectFieldDecl>(D)) {\n      auto *ND = cast<NamedDecl>(D);\n      if (Index == Order.size())\n        return false;\n      if (ND->getName() != Order[Index])\n        return false;\n      ++Index;\n    }\n  }\n  return Index == Order.size();\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldContainClassTemplateSpecializationOfExplicitInstantiation) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      namespace NS {\n        template<class T>\n        class X {};\n        template class X<int>;\n      }\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03, \"NS\");\n\n  // Check that the ClassTemplateSpecializationDecl is NOT the child of the\n  // ClassTemplateDecl.\n  auto Pattern = namespaceDecl(has(classTemplateDecl(\n      hasName(\"X\"), unless(has(classTemplateSpecializationDecl())))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(From, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(To, Pattern));\n\n  // Check that the ClassTemplateSpecializationDecl is the child of the\n  // NamespaceDecl.\n  Pattern = namespaceDecl(has(classTemplateSpecializationDecl(hasName(\"X\"))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(From, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(To, Pattern));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       CXXRecordDeclFieldsShouldBeInCorrectOrder) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\n          \"struct declToImport { int a; int b; };\",\n                      Lang_CXX11, \"\", Lang_CXX11);\n\n  MatchVerifier<Decl> Verifier;\n  ASSERT_TRUE(Verifier.match(From, cxxRecordDecl(hasFieldOrder({\"a\", \"b\"}))));\n  EXPECT_TRUE(Verifier.match(To, cxxRecordDecl(hasFieldOrder({\"a\", \"b\"}))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       CXXRecordDeclFieldOrderShouldNotDependOnImportOrder) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      // The original recursive algorithm of ASTImporter first imports 'c' then\n      // 'b' and lastly 'a'.  Therefore we must restore the order somehow.\n      R\"s(\n      struct declToImport {\n          int a = c + b;\n          int b = 1;\n          int c = 2;\n      };\n      )s\",\n      Lang_CXX11, \"\", Lang_CXX11);\n\n  MatchVerifier<Decl> Verifier;\n  ASSERT_TRUE(\n      Verifier.match(From, cxxRecordDecl(hasFieldOrder({\"a\", \"b\", \"c\"}))));\n  EXPECT_TRUE(\n      Verifier.match(To, cxxRecordDecl(hasFieldOrder({\"a\", \"b\", \"c\"}))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       CXXRecordDeclFieldAndIndirectFieldOrder) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      // First field is \"a\", then the field for unnamed union, then \"b\" and \"c\"\n      // from it (indirect fields), then \"d\".\n      R\"s(\n      struct declToImport {\n        int a = d;\n        union { \n          int b;\n          int c;\n        };\n        int d;\n      };\n      )s\",\n      Lang_CXX11, \"\", Lang_CXX11);\n\n  MatchVerifier<Decl> Verifier;\n  ASSERT_TRUE(Verifier.match(\n      From, cxxRecordDecl(hasFieldOrder({\"a\", \"\", \"b\", \"c\", \"d\"}))));\n  EXPECT_TRUE(Verifier.match(\n      To, cxxRecordDecl(hasFieldOrder({\"a\", \"\", \"b\", \"c\", \"d\"}))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ShouldImportImplicitCXXRecordDecl) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      struct declToImport {\n      };\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  // Match the implicit Decl.\n  auto Matcher = cxxRecordDecl(has(cxxRecordDecl()));\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ShouldImportImplicitCXXRecordDeclOfClassTemplate) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template <typename U>\n      struct declToImport {\n      };\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  // Match the implicit Decl.\n  auto Matcher = classTemplateDecl(has(cxxRecordDecl(has(cxxRecordDecl()))));\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ShouldImportImplicitCXXRecordDeclOfClassTemplateSpecializationDecl) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template<class T>\n      class Base {};\n      class declToImport : public Base<declToImport> {};\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto hasImplicitClass = has(cxxRecordDecl());\n  auto Pattern = translationUnitDecl(has(classTemplateDecl(\n      hasName(\"Base\"),\n      has(classTemplateSpecializationDecl(hasImplicitClass)))));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, IDNSOrdinary) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"void declToImport() {}\", Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  auto Matcher = functionDecl();\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n  EXPECT_EQ(From->getIdentifierNamespace(), To->getIdentifierNamespace());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, IDNSOfNonmemberOperator) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {};\n      void operator<<(int, X);\n      )\",\n      Lang_CXX03);\n  Decl *From = LastDeclMatcher<Decl>{}.match(FromTU, functionDecl());\n  const Decl *To = Import(From, Lang_CXX03);\n  EXPECT_EQ(From->getIdentifierNamespace(), To->getIdentifierNamespace());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ShouldImportMembersOfClassTemplateSpecializationDecl) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template<class T>\n      class Base { int a; };\n      class declToImport : Base<declToImport> {};\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto Pattern = translationUnitDecl(has(classTemplateDecl(\n      hasName(\"Base\"),\n      has(classTemplateSpecializationDecl(has(fieldDecl(hasName(\"a\"))))))));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportDefinitionOfClassTemplateAfterFwdDecl) {\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B;\n            )\",\n        Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n\n    Import(FromD, Lang_CXX03);\n  }\n\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B {\n              void f();\n            };\n            )\",\n        Lang_CXX03, \"input1.cc\");\n    FunctionDecl *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n    auto *FromCTD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n    auto *ToCTD = cast<ClassTemplateDecl>(Import(FromCTD, Lang_CXX03));\n    EXPECT_TRUE(ToCTD->isThisDeclarationADefinition());\n  }\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportDefinitionOfClassTemplateIfThereIsAnExistingFwdDeclAndDefinition) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      struct B {\n        void f();\n      };\n\n      template <typename T>\n      struct B;\n      )\",\n      Lang_CXX03);\n  ASSERT_EQ(1u, DeclCounterWithPredicate<ClassTemplateDecl>(\n                    [](const ClassTemplateDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateDecl()));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      struct B {\n        void f();\n      };\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  ClassTemplateDecl *FromD = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"B\")));\n\n  Import(FromD, Lang_CXX03);\n\n  // We should have only one definition.\n  EXPECT_EQ(1u, DeclCounterWithPredicate<ClassTemplateDecl>(\n                    [](const ClassTemplateDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportDefinitionOfClassIfThereIsAnExistingFwdDeclAndDefinition) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      struct B {\n        void f();\n      };\n\n      struct B;\n      )\",\n      Lang_CXX03);\n  ASSERT_EQ(2u, DeclCounter<CXXRecordDecl>().match(\n                    ToTU, cxxRecordDecl(unless(isImplicit()))));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct B {\n        void f();\n      };\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"B\")));\n\n  Import(FromD, Lang_CXX03);\n\n  EXPECT_EQ(2u, DeclCounter<CXXRecordDecl>().match(\n                    ToTU, cxxRecordDecl(unless(isImplicit()))));\n}\n\nstatic void CompareSourceLocs(FullSourceLoc Loc1, FullSourceLoc Loc2) {\n  EXPECT_EQ(Loc1.getExpansionLineNumber(), Loc2.getExpansionLineNumber());\n  EXPECT_EQ(Loc1.getExpansionColumnNumber(), Loc2.getExpansionColumnNumber());\n  EXPECT_EQ(Loc1.getSpellingLineNumber(), Loc2.getSpellingLineNumber());\n  EXPECT_EQ(Loc1.getSpellingColumnNumber(), Loc2.getSpellingColumnNumber());\n}\nstatic void CompareSourceRanges(SourceRange Range1, SourceRange Range2,\n                                SourceManager &SM1, SourceManager &SM2) {\n  CompareSourceLocs(FullSourceLoc{ Range1.getBegin(), SM1 },\n                    FullSourceLoc{ Range2.getBegin(), SM2 });\n  CompareSourceLocs(FullSourceLoc{ Range1.getEnd(), SM1 },\n                    FullSourceLoc{ Range2.getEnd(), SM2 });\n}\nTEST_P(ASTImporterOptionSpecificTestBase, ImportSourceLocs) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      #define MFOO(arg) arg = arg + 1\n\n      void foo() {\n        int a = 5;\n        MFOO(a);\n      }\n      )\",\n      Lang_CXX03);\n  auto FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n  auto ToD = Import(FromD, Lang_CXX03);\n\n  auto ToLHS = LastDeclMatcher<DeclRefExpr>().match(ToD, declRefExpr());\n  auto FromLHS = LastDeclMatcher<DeclRefExpr>().match(FromTU, declRefExpr());\n  auto ToRHS = LastDeclMatcher<IntegerLiteral>().match(ToD, integerLiteral());\n  auto FromRHS =\n      LastDeclMatcher<IntegerLiteral>().match(FromTU, integerLiteral());\n\n  SourceManager &ToSM = ToAST->getASTContext().getSourceManager();\n  SourceManager &FromSM = FromD->getASTContext().getSourceManager();\n  CompareSourceRanges(ToD->getSourceRange(), FromD->getSourceRange(), ToSM,\n                      FromSM);\n  CompareSourceRanges(ToLHS->getSourceRange(), FromLHS->getSourceRange(), ToSM,\n                      FromSM);\n  CompareSourceRanges(ToRHS->getSourceRange(), FromRHS->getSourceRange(), ToSM,\n                      FromSM);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportNestedMacro) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      #define FUNC_INT void declToImport\n      #define FUNC FUNC_INT\n      FUNC(int a);\n      )\",\n      Lang_CXX03);\n  auto FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n  auto ToD = Import(FromD, Lang_CXX03);\n\n  SourceManager &ToSM = ToAST->getASTContext().getSourceManager();\n  SourceManager &FromSM = FromD->getASTContext().getSourceManager();\n  CompareSourceRanges(ToD->getSourceRange(), FromD->getSourceRange(), ToSM,\n                      FromSM);\n}\n\nTEST_P(\n    ASTImporterOptionSpecificTestBase,\n    ImportDefinitionOfClassTemplateSpecIfThereIsAnExistingFwdDeclAndDefinition) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      struct B;\n\n      template <>\n      struct B<int> {};\n\n      template <>\n      struct B<int>;\n      )\",\n      Lang_CXX03);\n  // We should have only one definition.\n  ASSERT_EQ(1u, DeclCounterWithPredicate<ClassTemplateSpecializationDecl>(\n                    [](const ClassTemplateSpecializationDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateSpecializationDecl()));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      struct B;\n\n      template <>\n      struct B<int> {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *FromD = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"B\")));\n\n  Import(FromD, Lang_CXX03);\n\n  // We should have only one definition.\n  EXPECT_EQ(1u, DeclCounterWithPredicate<ClassTemplateSpecializationDecl>(\n                    [](const ClassTemplateSpecializationDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ObjectsWithUnnamedStructType) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct { int a; int b; } object0 = { 2, 3 };\n      struct { int x; int y; int z; } object1;\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  auto *Obj0 =\n      FirstDeclMatcher<VarDecl>().match(FromTU, varDecl(hasName(\"object0\")));\n  auto *From0 = getRecordDecl(Obj0);\n  auto *Obj1 =\n      FirstDeclMatcher<VarDecl>().match(FromTU, varDecl(hasName(\"object1\")));\n  auto *From1 = getRecordDecl(Obj1);\n\n  auto *To0 = Import(From0, Lang_CXX03);\n  auto *To1 = Import(From1, Lang_CXX03);\n\n  EXPECT_TRUE(To0);\n  EXPECT_TRUE(To1);\n  EXPECT_NE(To0, To1);\n  EXPECT_NE(To0->getCanonicalDecl(), To1->getCanonicalDecl());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, AnonymousRecords) {\n  auto *Code =\n      R\"(\n      struct X {\n        struct { int a; };\n        struct { int b; };\n      };\n      )\";\n  Decl *FromTU0 = getTuDecl(Code, Lang_C99, \"input0.c\");\n\n  Decl *FromTU1 = getTuDecl(Code, Lang_C99, \"input1.c\");\n\n  auto *X0 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU0, recordDecl(hasName(\"X\")));\n  auto *X1 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU1, recordDecl(hasName(\"X\")));\n  Import(X0, Lang_C99);\n  Import(X1, Lang_C99);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We expect no (ODR) warning during the import.\n  EXPECT_EQ(0u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n  EXPECT_EQ(1u,\n            DeclCounter<RecordDecl>().match(ToTU, recordDecl(hasName(\"X\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, AnonymousRecordsReversed) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      struct X {\n        struct { int a; };\n        struct { int b; };\n      };\n      )\",\n      Lang_C99, \"input0.c\");\n\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      struct X { // reversed order\n        struct { int b; };\n        struct { int a; };\n      };\n      )\",\n      Lang_C99, \"input1.c\");\n\n  auto *X0 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU0, recordDecl(hasName(\"X\")));\n  auto *X1 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU1, recordDecl(hasName(\"X\")));\n  Import(X0, Lang_C99);\n  Import(X1, Lang_C99);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We expect one (ODR) warning during the import.\n  EXPECT_EQ(1u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n  EXPECT_EQ(1u,\n            DeclCounter<RecordDecl>().match(ToTU, recordDecl(hasName(\"X\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDoesUpdateUsedFlag) {\n  auto Pattern = varDecl(hasName(\"x\"));\n  VarDecl *Imported1;\n  {\n    Decl *FromTU = getTuDecl(\"extern int x;\", Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    Imported1 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n  }\n  VarDecl *Imported2;\n  {\n    Decl *FromTU = getTuDecl(\"int x;\", Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    Imported2 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n  }\n  EXPECT_EQ(Imported1->getCanonicalDecl(), Imported2->getCanonicalDecl());\n  EXPECT_FALSE(Imported2->isUsed(false));\n  {\n    Decl *FromTU = getTuDecl(\"extern int x; int f() { return x; }\", Lang_CXX03,\n                             \"input2.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n  }\n  EXPECT_TRUE(Imported2->isUsed(false));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDoesUpdateUsedFlag2) {\n  auto Pattern = varDecl(hasName(\"x\"));\n  VarDecl *ExistingD;\n  {\n    Decl *ToTU = getToTuDecl(\"int x = 1;\", Lang_CXX03);\n    ExistingD = FirstDeclMatcher<VarDecl>().match(ToTU, Pattern);\n  }\n  EXPECT_FALSE(ExistingD->isUsed(false));\n  {\n    Decl *FromTU =\n        getTuDecl(\"int x = 1; int f() { return x; }\", Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n  }\n  EXPECT_TRUE(ExistingD->isUsed(false));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDoesUpdateUsedFlag3) {\n  auto Pattern = varDecl(hasName(\"a\"));\n  VarDecl *ExistingD;\n  {\n    Decl *ToTU = getToTuDecl(\n        R\"(\n        struct A {\n          static const int a = 1;\n        };\n        )\",\n        Lang_CXX03);\n    ExistingD = FirstDeclMatcher<VarDecl>().match(ToTU, Pattern);\n  }\n  EXPECT_FALSE(ExistingD->isUsed(false));\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n        struct A {\n          static const int a = 1;\n        };\n        const int *f() { return &A::a; } // requires storage,\n                                         // thus used flag will be set\n        )\",\n        Lang_CXX03, \"input1.cc\");\n    auto *FromFunD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    ASSERT_TRUE(FromD->isUsed(false));\n    Import(FromFunD, Lang_CXX03);\n  }\n  EXPECT_TRUE(ExistingD->isUsed(false));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ReimportWithUsedFlag) {\n  auto Pattern = varDecl(hasName(\"x\"));\n\n  Decl *FromTU = getTuDecl(\"int x;\", Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n\n  auto *Imported1 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n\n  ASSERT_FALSE(Imported1->isUsed(false));\n\n  FromD->setIsUsed();\n  auto *Imported2 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n\n  EXPECT_EQ(Imported1, Imported2);\n  EXPECT_TRUE(Imported2->isUsed(false));\n}\n\nstruct ImportFunctions : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFunctions, ImportPrototypeOfRecursiveFunction) {\n  Decl *FromTU = getTuDecl(\"void f(); void f() { f(); }\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern); // Proto\n\n  Decl *ImportedD = Import(From, Lang_CXX03);\n  Decl *ToTU = ImportedD->getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  auto *To0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  auto *To1 = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedD == To0);\n  EXPECT_FALSE(To0->doesThisDeclarationHaveABody());\n  EXPECT_TRUE(To1->doesThisDeclarationHaveABody());\n  EXPECT_EQ(To1->getPreviousDecl(), To0);\n}\n\nTEST_P(ImportFunctions, ImportDefinitionOfRecursiveFunction) {\n  Decl *FromTU = getTuDecl(\"void f(); void f() { f(); }\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *From =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern); // Def\n\n  Decl *ImportedD = Import(From, Lang_CXX03);\n  Decl *ToTU = ImportedD->getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  auto *To0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  auto *To1 = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedD == To1);\n  EXPECT_FALSE(To0->doesThisDeclarationHaveABody());\n  EXPECT_TRUE(To1->doesThisDeclarationHaveABody());\n  EXPECT_EQ(To1->getPreviousDecl(), To0);\n}\n\nTEST_P(ImportFunctions, OverriddenMethodsShouldBeImported) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      void B::f() {}\n      struct D : B { void f(); };\n      )\";\n  auto Pattern =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  CXXMethodDecl *Proto =\n      FirstDeclMatcher<CXXMethodDecl>().match(FromTU, Pattern);\n\n  ASSERT_EQ(Proto->size_overridden_methods(), 1u);\n  CXXMethodDecl *To = cast<CXXMethodDecl>(Import(Proto, Lang_CXX03));\n  EXPECT_EQ(To->size_overridden_methods(), 1u);\n}\n\nTEST_P(ImportFunctions, VirtualFlagShouldBePreservedWhenImportingPrototype) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      void B::f() {}\n      )\";\n  auto Pattern =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  CXXMethodDecl *Proto =\n      FirstDeclMatcher<CXXMethodDecl>().match(FromTU, Pattern);\n  CXXMethodDecl *Def = LastDeclMatcher<CXXMethodDecl>().match(FromTU, Pattern);\n\n  ASSERT_TRUE(Proto->isVirtual());\n  ASSERT_TRUE(Def->isVirtual());\n  CXXMethodDecl *To = cast<CXXMethodDecl>(Import(Proto, Lang_CXX03));\n  EXPECT_TRUE(To->isVirtual());\n}\n\nTEST_P(ImportFunctions,\n       ImportDefinitionIfThereIsAnExistingDefinitionAndFwdDecl) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      void f() {}\n      void f();\n      )\",\n      Lang_CXX03);\n  ASSERT_EQ(1u,\n            DeclCounterWithPredicate<FunctionDecl>([](const FunctionDecl *FD) {\n              return FD->doesThisDeclarationHaveABody();\n            }).match(ToTU, functionDecl()));\n\n  Decl *FromTU = getTuDecl(\"void f() {}\", Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  Import(FromD, Lang_CXX03);\n\n  EXPECT_EQ(1u,\n            DeclCounterWithPredicate<FunctionDecl>([](const FunctionDecl *FD) {\n              return FD->doesThisDeclarationHaveABody();\n            }).match(ToTU, functionDecl()));\n}\n\nTEST_P(ImportFunctions, ImportOverriddenMethodTwice) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      )\";\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto DFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n\n  Decl *FromTU0 = getTuDecl(Code, Lang_CXX03);\n  auto *DF = FirstDeclMatcher<CXXMethodDecl>().match(FromTU0, DFP);\n  Import(DF, Lang_CXX03);\n\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *BF = FirstDeclMatcher<CXXMethodDecl>().match(FromTU1, BFP);\n  Import(BF, Lang_CXX03);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFP), 1u);\n}\n\nTEST_P(ImportFunctions, ImportOverriddenMethodTwiceDefinitionFirst) {\n  auto CodeWithoutDef =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      )\";\n  auto CodeWithDef =\n      R\"(\n    struct B { virtual void f(){}; };\n    struct D:B { void f(){}; };\n  )\";\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto DFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n  auto BFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))), isDefinition());\n  auto DFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))), isDefinition());\n  auto FDefAllP = cxxMethodDecl(hasName(\"f\"), isDefinition());\n\n  {\n    Decl *FromTU = getTuDecl(CodeWithDef, Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<CXXMethodDecl>().match(FromTU, DFP);\n    Import(FromD, Lang_CXX03);\n  }\n  {\n    Decl *FromTU = getTuDecl(CodeWithoutDef, Lang_CXX03, \"input1.cc\");\n    auto *FromB = FirstDeclMatcher<CXXMethodDecl>().match(FromTU, BFP);\n    Import(FromB, Lang_CXX03);\n  }\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFDefP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFDefP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FDefAllP), 2u);\n}\n\nTEST_P(ImportFunctions, ImportOverriddenMethodTwiceOutOfClassDef) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      void B::f(){};\n      )\";\n\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto BFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))), isDefinition());\n  auto DFP = cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))),\n                           unless(isDefinition()));\n\n  Decl *FromTU0 = getTuDecl(Code, Lang_CXX03);\n  auto *D = FirstDeclMatcher<CXXMethodDecl>().match(FromTU0, DFP);\n  Import(D, Lang_CXX03);\n\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *B = FirstDeclMatcher<CXXMethodDecl>().match(FromTU1, BFP);\n  Import(B, Lang_CXX03);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFDefP), 0u);\n\n  auto *ToB = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"B\")));\n  auto *ToBFInClass = FirstDeclMatcher<CXXMethodDecl>().match(ToTU, BFP);\n  auto *ToBFOutOfClass = FirstDeclMatcher<CXXMethodDecl>().match(\n      ToTU, cxxMethodDecl(hasName(\"f\"), isDefinition()));\n\n  // The definition should be out-of-class.\n  EXPECT_NE(ToBFInClass, ToBFOutOfClass);\n  EXPECT_NE(ToBFInClass->getLexicalDeclContext(),\n            ToBFOutOfClass->getLexicalDeclContext());\n  EXPECT_EQ(ToBFOutOfClass->getDeclContext(), ToB);\n  EXPECT_EQ(ToBFOutOfClass->getLexicalDeclContext(), ToTU);\n\n  // Check that the redecl chain is intact.\n  EXPECT_EQ(ToBFOutOfClass->getPreviousDecl(), ToBFInClass);\n}\n\nTEST_P(ImportFunctions,\n       ImportOverriddenMethodTwiceOutOfClassDefInSeparateCode) {\n  auto CodeTU0 =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      )\";\n  auto CodeTU1 =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      void B::f(){}\n      void D::f(){}\n      void foo(B &b, D &d) { b.f(); d.f(); }\n      )\";\n\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto BFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))), isDefinition());\n  auto DFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n  auto DFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))), isDefinition());\n  auto FooDef = functionDecl(hasName(\"foo\"));\n\n  {\n    Decl *FromTU0 = getTuDecl(CodeTU0, Lang_CXX03, \"input0.cc\");\n    auto *D = FirstDeclMatcher<CXXMethodDecl>().match(FromTU0, DFP);\n    Import(D, Lang_CXX03);\n  }\n\n  {\n    Decl *FromTU1 = getTuDecl(CodeTU1, Lang_CXX03, \"input1.cc\");\n    auto *Foo = FirstDeclMatcher<FunctionDecl>().match(FromTU1, FooDef);\n    Import(Foo, Lang_CXX03);\n  }\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFDefP), 0u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFDefP), 0u);\n\n  auto *ToB = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"B\")));\n  auto *ToD = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"D\")));\n  auto *ToBFInClass = FirstDeclMatcher<CXXMethodDecl>().match(ToTU, BFP);\n  auto *ToBFOutOfClass = FirstDeclMatcher<CXXMethodDecl>().match(\n      ToTU, cxxMethodDecl(hasName(\"f\"), isDefinition()));\n  auto *ToDFInClass = FirstDeclMatcher<CXXMethodDecl>().match(ToTU, DFP);\n  auto *ToDFOutOfClass = LastDeclMatcher<CXXMethodDecl>().match(\n      ToTU, cxxMethodDecl(hasName(\"f\"), isDefinition()));\n\n  // The definition should be out-of-class.\n  EXPECT_NE(ToBFInClass, ToBFOutOfClass);\n  EXPECT_NE(ToBFInClass->getLexicalDeclContext(),\n            ToBFOutOfClass->getLexicalDeclContext());\n  EXPECT_EQ(ToBFOutOfClass->getDeclContext(), ToB);\n  EXPECT_EQ(ToBFOutOfClass->getLexicalDeclContext(), ToTU);\n\n  EXPECT_NE(ToDFInClass, ToDFOutOfClass);\n  EXPECT_NE(ToDFInClass->getLexicalDeclContext(),\n            ToDFOutOfClass->getLexicalDeclContext());\n  EXPECT_EQ(ToDFOutOfClass->getDeclContext(), ToD);\n  EXPECT_EQ(ToDFOutOfClass->getLexicalDeclContext(), ToTU);\n\n  // Check that the redecl chain is intact.\n  EXPECT_EQ(ToBFOutOfClass->getPreviousDecl(), ToBFInClass);\n  EXPECT_EQ(ToDFOutOfClass->getPreviousDecl(), ToDFInClass);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportVariableChainInC) {\n    std::string Code = \"static int v; static int v = 0;\";\n    auto Pattern = varDecl(hasName(\"v\"));\n\n    TranslationUnitDecl *FromTu = getTuDecl(Code, Lang_C99, \"input0.c\");\n\n    auto *From0 = FirstDeclMatcher<VarDecl>().match(FromTu, Pattern);\n    auto *From1 = LastDeclMatcher<VarDecl>().match(FromTu, Pattern);\n\n    auto *To0 = Import(From0, Lang_C99);\n    auto *To1 = Import(From1, Lang_C99);\n\n    EXPECT_TRUE(To0);\n    ASSERT_TRUE(To1);\n    EXPECT_NE(To0, To1);\n    EXPECT_EQ(To1->getPreviousDecl(), To0);\n}\n\nTEST_P(ImportFunctions, ImportFromDifferentScopedAnonNamespace) {\n  TranslationUnitDecl *FromTu =\n      getTuDecl(\"namespace NS0 { namespace { void f(); } }\"\n                \"namespace NS1 { namespace { void f(); } }\",\n                Lang_CXX03, \"input0.cc\");\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  auto *FromF0 = FirstDeclMatcher<FunctionDecl>().match(FromTu, Pattern);\n  auto *FromF1 = LastDeclMatcher<FunctionDecl>().match(FromTu, Pattern);\n\n  auto *ToF0 = Import(FromF0, Lang_CXX03);\n  auto *ToF1 = Import(FromF1, Lang_CXX03);\n\n  EXPECT_TRUE(ToF0);\n  ASSERT_TRUE(ToF1);\n  EXPECT_NE(ToF0, ToF1);\n  EXPECT_FALSE(ToF1->getPreviousDecl());\n}\n\nTEST_P(ImportFunctions, ImportFunctionFromUnnamedNamespace) {\n  {\n    Decl *FromTU = getTuDecl(\"namespace { void f() {} } void g0() { f(); }\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"g0\")));\n\n    Import(FromD, Lang_CXX03);\n  }\n  {\n    Decl *FromTU =\n        getTuDecl(\"namespace { void f() { int a; } } void g1() { f(); }\",\n                  Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"g1\")));\n    Import(FromD, Lang_CXX03);\n  }\n\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\"))),\n            2u);\n}\n\nTEST_P(ImportFunctions, ImportImplicitFunctionsInLambda) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void foo() {\n        (void)[]() { ; };\n      }\n      )\",\n      Lang_CXX11);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ToD);\n  CXXRecordDecl *LambdaRec =\n      cast<LambdaExpr>(cast<CStyleCastExpr>(\n                           *cast<CompoundStmt>(ToD->getBody())->body_begin())\n                           ->getSubExpr())\n          ->getLambdaClass();\n  EXPECT_TRUE(LambdaRec->getDestructor());\n}\n\nTEST_P(ImportFunctions,\n       CallExprOfMemberFunctionTemplateWithExplicitTemplateArgs) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {\n        template <typename T>\n        void foo(){}\n      };\n      void f() {\n        X x;\n        x.foo<int>();\n      }\n      )\",\n      Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ToD);\n  EXPECT_TRUE(MatchVerifier<FunctionDecl>().match(\n      ToD, functionDecl(hasName(\"f\"), hasDescendant(declRefExpr()))));\n}\n\nTEST_P(ImportFunctions,\n       DependentCallExprOfMemberFunctionTemplateWithExplicitTemplateArgs) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {\n        template <typename T>\n        void foo(){}\n      };\n      template <typename T>\n      void f() {\n        X x;\n        x.foo<T>();\n      }\n      void g() {\n        f<int>();\n      }\n      )\",\n      Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"g\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ToD);\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<TranslationUnitDecl>().match(\n      ToTU, translationUnitDecl(hasDescendant(\n                functionDecl(hasName(\"f\"), hasDescendant(declRefExpr()))))));\n}\n\nstruct ImportFunctionTemplates : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFunctionTemplates, ImportFunctionTemplateInRecordDeclTwice) {\n  auto Code =\n      R\"(\n      class X {\n        template <class T>\n        void f(T t);\n      };\n      )\";\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *FromD1 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU1, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD1 = Import(FromD1, Lang_CXX03);\n  Decl *FromTU2 = getTuDecl(Code, Lang_CXX03, \"input2.cc\");\n  auto *FromD2 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU2, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD2 = Import(FromD2, Lang_CXX03);\n  EXPECT_EQ(ToD1, ToD2);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportFunctionTemplateWithDefInRecordDeclTwice) {\n  auto Code =\n      R\"(\n      class X {\n        template <class T>\n        void f(T t);\n      };\n      template <class T>\n      void X::f(T t) {};\n      )\";\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *FromD1 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU1, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD1 = Import(FromD1, Lang_CXX03);\n  Decl *FromTU2 = getTuDecl(Code, Lang_CXX03, \"input2.cc\");\n  auto *FromD2 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU2, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD2 = Import(FromD2, Lang_CXX03);\n  EXPECT_EQ(ToD1, ToD2);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportFunctionWhenThereIsAFunTemplateWithSameName) {\n  getToTuDecl(\n      R\"(\n      template <typename T>\n      void foo(T) {}\n      void foo();\n      )\",\n      Lang_CXX03);\n  Decl *FromTU = getTuDecl(\"void foo();\", Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  auto *ImportedD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ImportedD);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportConstructorWhenThereIsAFunTemplateWithSameName) {\n  auto Code =\n      R\"(\n      struct Foo {\n        template <typename T>\n        Foo(T) {}\n        Foo();\n      };\n      )\";\n  getToTuDecl(Code, Lang_CXX03);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  auto *FromD =\n      LastDeclMatcher<CXXConstructorDecl>().match(FromTU, cxxConstructorDecl());\n  auto *ImportedD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ImportedD);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportOperatorWhenThereIsAFunTemplateWithSameName) {\n  getToTuDecl(\n      R\"(\n      template <typename T>\n      void operator<(T,T) {}\n      struct X{};\n      void operator<(X, X);\n      )\",\n      Lang_CXX03);\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X{};\n      void operator<(X, X);\n      )\",\n      Lang_CXX03);\n  auto *FromD = LastDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasOverloadedOperatorName(\"<\")));\n  auto *ImportedD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ImportedD);\n}\n\nstruct ImportFriendFunctions : ImportFunctions {};\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionRedeclChainProto) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"struct X { friend void f(); };\"\n                           \"void f();\",\n                           Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_FALSE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions,\n       ImportFriendFunctionRedeclChainProto_OutOfClassProtoFirst) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"void f();\"\n                           \"struct X { friend void f(); };\",\n                           Lang_CXX03, \"input0.cc\");\n  auto FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_FALSE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionRedeclChainDef) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"struct X { friend void f(){} };\"\n                           \"void f();\",\n                           Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_TRUE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_FALSE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions,\n       ImportFriendFunctionRedeclChainDef_OutOfClassDef) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"struct X { friend void f(); };\"\n                           \"void f(){}\",\n                           Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionRedeclChainDefWithClass) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n        class X;\n        void f(X *x){}\n        class X{\n        friend void f(X *x);\n        };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_TRUE(ImportedD->doesThisDeclarationHaveABody());\n  auto *InClassFD = cast<FunctionDecl>(FirstDeclMatcher<FriendDecl>()\n                                              .match(ToTU, friendDecl())\n                                              ->getFriendDecl());\n  EXPECT_FALSE(InClassFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(InClassFD->getPreviousDecl(), ImportedD);\n  // The parameters must refer the same type\n  EXPECT_EQ((*InClassFD->param_begin())->getOriginalType(),\n            (*ImportedD->param_begin())->getOriginalType());\n}\n\nTEST_P(ImportFriendFunctions,\n       ImportFriendFunctionRedeclChainDefWithClass_ImportTheProto) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n        class X;\n        void f(X *x){}\n        class X{\n        friend void f(X *x);\n        };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *FromD = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *OutOfClassFD = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(unless(hasParent(friendDecl()))));\n\n  EXPECT_TRUE(OutOfClassFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ImportedD->getPreviousDecl(), OutOfClassFD);\n  // The parameters must refer the same type\n  EXPECT_EQ((*OutOfClassFD->param_begin())->getOriginalType(),\n            (*ImportedD->param_begin())->getOriginalType());\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionFromMultipleTU) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  FunctionDecl *ImportedD;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct X { friend void f(){} };\", Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  }\n  FunctionDecl *ImportedD1;\n  {\n    Decl *FromTU = getTuDecl(\"void f();\", Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    ImportedD1 = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  }\n\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_TRUE(ImportedD->doesThisDeclarationHaveABody());\n  EXPECT_FALSE(ImportedD1->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ImportedD1->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions, Lookup) {\n  auto FunctionPattern = functionDecl(hasName(\"f\"));\n  auto ClassPattern = cxxRecordDecl(hasName(\"X\"));\n\n  TranslationUnitDecl *FromTU =\n      getTuDecl(\"struct X { friend void f(); };\", Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  ASSERT_TRUE(FromD->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_FALSE(FromD->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  {\n    auto FromName = FromD->getDeclName();\n    auto *Class = FirstDeclMatcher<CXXRecordDecl>().match(FromTU, ClassPattern);\n    auto LookupRes = Class->noload_lookup(FromName);\n    ASSERT_EQ(LookupRes.size(), 0u);\n    LookupRes = FromTU->noload_lookup(FromName);\n    ASSERT_EQ(LookupRes.size(), 1u);\n  }\n\n  auto *ToD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  auto ToName = ToD->getDeclName();\n\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *Class = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, ClassPattern);\n  auto LookupRes = Class->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 0u);\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FunctionPattern), 1u);\n  auto *To0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  EXPECT_TRUE(To0->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_FALSE(To0->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n}\n\nTEST_P(ImportFriendFunctions, LookupWithProtoAfter) {\n  auto FunctionPattern = functionDecl(hasName(\"f\"));\n  auto ClassPattern = cxxRecordDecl(hasName(\"X\"));\n\n  TranslationUnitDecl *FromTU =\n      getTuDecl(\"struct X { friend void f(); };\"\n                // This proto decl makes f available to normal\n                // lookup, otherwise it is hidden.\n                // Normal C++ lookup (implemented in\n                // `clang::Sema::CppLookupName()` and in `LookupDirect()`)\n                // returns the found `NamedDecl` only if the set IDNS is matched\n                \"void f();\",\n                Lang_CXX03, \"input0.cc\");\n  auto *FromFriend =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  auto *FromNormal =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  ASSERT_TRUE(FromFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_FALSE(FromFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_FALSE(FromNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_TRUE(FromNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n\n  auto FromName = FromFriend->getDeclName();\n  auto *FromClass =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, ClassPattern);\n  auto LookupRes = FromClass->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 0u);\n  LookupRes = FromTU->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n\n  auto *ToFriend = cast<FunctionDecl>(Import(FromFriend, Lang_CXX03));\n  auto ToName = ToFriend->getDeclName();\n\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, ClassPattern);\n  LookupRes = ToClass->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 0u);\n  LookupRes = ToTU->noload_lookup(ToName);\n  // Test is disabled because this result is 2.\n  EXPECT_EQ(LookupRes.size(), 1u);\n\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FunctionPattern), 2u);\n  ToFriend = FirstDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  auto *ToNormal = LastDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  EXPECT_TRUE(ToFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_FALSE(ToFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_FALSE(ToNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_TRUE(ToNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n}\n\nTEST_P(ImportFriendFunctions, LookupWithProtoBefore) {\n  auto FunctionPattern = functionDecl(hasName(\"f\"));\n  auto ClassPattern = cxxRecordDecl(hasName(\"X\"));\n\n  TranslationUnitDecl *FromTU = getTuDecl(\"void f();\"\n                                          \"struct X { friend void f(); };\",\n                                          Lang_CXX03, \"input0.cc\");\n  auto *FromNormal =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  auto *FromFriend =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  ASSERT_FALSE(FromNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_TRUE(FromNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_TRUE(FromFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_TRUE(FromFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n\n  auto FromName = FromNormal->getDeclName();\n  auto *FromClass =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, ClassPattern);\n  auto LookupRes = FromClass->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 0u);\n  LookupRes = FromTU->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n\n  auto *ToNormal = cast<FunctionDecl>(Import(FromNormal, Lang_CXX03));\n  auto ToName = ToNormal->getDeclName();\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, ClassPattern);\n  LookupRes = ToClass->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 0u);\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FunctionPattern), 2u);\n  ToNormal = FirstDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  auto *ToFriend = LastDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  EXPECT_FALSE(ToNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_TRUE(ToNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_TRUE(ToFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_TRUE(ToFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendChangesLookup) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  TranslationUnitDecl *FromNormalTU =\n      getTuDecl(\"void f();\", Lang_CXX03, \"input0.cc\");\n  auto *FromNormalF =\n      FirstDeclMatcher<FunctionDecl>().match(FromNormalTU, Pattern);\n  TranslationUnitDecl *FromFriendTU =\n      getTuDecl(\"class X { friend void f(); };\", Lang_CXX03, \"input1.cc\");\n  auto *FromFriendF =\n      FirstDeclMatcher<FunctionDecl>().match(FromFriendTU, Pattern);\n  auto FromNormalName = FromNormalF->getDeclName();\n  auto FromFriendName = FromFriendF->getDeclName();\n\n  ASSERT_TRUE(FromNormalF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_FALSE(FromNormalF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_FALSE(FromFriendF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_TRUE(FromFriendF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  auto LookupRes = FromNormalTU->noload_lookup(FromNormalName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n  LookupRes = FromFriendTU->noload_lookup(FromFriendName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n\n  auto *ToNormalF = cast<FunctionDecl>(Import(FromNormalF, Lang_CXX03));\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto ToName = ToNormalF->getDeclName();\n  EXPECT_TRUE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_FALSE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 1u);\n\n  auto *ToFriendF = cast<FunctionDecl>(Import(FromFriendF, Lang_CXX03));\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n\n  EXPECT_TRUE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_FALSE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n\n  EXPECT_TRUE(ToFriendF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_TRUE(ToFriendF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendList) {\n  TranslationUnitDecl *FromTU = getTuDecl(\"struct X { friend void f(); };\"\n                                          \"void f();\",\n                                          Lang_CXX03, \"input0.cc\");\n  auto *FromFriendF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  auto *FromClass = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  auto *FromFriend = FirstDeclMatcher<FriendDecl>().match(FromTU, friendDecl());\n  auto FromFriends = FromClass->friends();\n  unsigned int FrN = 0;\n  for (auto Fr : FromFriends) {\n    ASSERT_EQ(Fr, FromFriend);\n    ++FrN;\n  }\n  ASSERT_EQ(FrN, 1u);\n\n  Import(FromFriendF, Lang_CXX03);\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\")));\n  auto *ToFriend = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  auto ToFriends = ToClass->friends();\n  FrN = 0;\n  for (auto Fr : ToFriends) {\n    EXPECT_EQ(Fr, ToFriend);\n    ++FrN;\n  }\n  EXPECT_EQ(FrN, 1u);\n}\n\nAST_MATCHER_P(TagDecl, hasTypedefForAnonDecl, Matcher<TypedefNameDecl>,\n              InnerMatcher) {\n  if (auto *Typedef = Node.getTypedefNameForAnonDecl())\n    return InnerMatcher.matches(*Typedef, Finder, Builder);\n  return false;\n}\n\nTEST_P(ImportDecl, ImportEnumSequential) {\n  CodeFiles Samples{{\"main.c\",\n                     {\"void foo();\"\n                      \"void moo();\"\n                      \"int main() { foo(); moo(); }\",\n                      Lang_C99}},\n\n                    {\"foo.c\",\n                     {\"typedef enum { THING_VALUE } thing_t;\"\n                      \"void conflict(thing_t type);\"\n                      \"void foo() { (void)THING_VALUE; }\"\n                      \"void conflict(thing_t type) {}\",\n                      Lang_C99}},\n\n                    {\"moo.c\",\n                     {\"typedef enum { THING_VALUE } thing_t;\"\n                      \"void conflict(thing_t type);\"\n                      \"void moo() { conflict(THING_VALUE); }\",\n                      Lang_C99}}};\n\n  auto VerificationMatcher =\n      enumDecl(has(enumConstantDecl(hasName(\"THING_VALUE\"))),\n               hasTypedefForAnonDecl(hasName(\"thing_t\")));\n\n  ImportAction ImportFoo{\"foo.c\", \"main.c\", functionDecl(hasName(\"foo\"))},\n      ImportMoo{\"moo.c\", \"main.c\", functionDecl(hasName(\"moo\"))};\n\n  testImportSequence(\n      Samples, {ImportFoo, ImportMoo}, // \"foo\", them \"moo\".\n      // Just check that there is only one enum decl in the result AST.\n      \"main.c\", enumDecl(), VerificationMatcher);\n\n  // For different import order, result should be the same.\n  testImportSequence(\n      Samples, {ImportMoo, ImportFoo}, // \"moo\", them \"foo\".\n      // Check that there is only one enum decl in the result AST.\n      \"main.c\", enumDecl(), VerificationMatcher);\n}\n\nTEST_P(ImportDecl, ImportFieldOrder) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"struct declToImport {\"\n             \"  int b = a + 2;\"\n             \"  int a = 5;\"\n             \"};\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             recordDecl(hasFieldOrder({\"b\", \"a\"})));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Expr, DependentScopeDeclRefExpr>\n    dependentScopeDeclRefExpr;\n\nTEST_P(ImportExpr, DependentScopeDeclRefExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct S { static T foo; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  (void) S<T>::foo;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\"\n             \"template <typename T> T S<T>::foo;\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             functionTemplateDecl(has(functionDecl(has(compoundStmt(\n                 has(cStyleCastExpr(has(dependentScopeDeclRefExpr())))))))));\n\n  testImport(\"template <typename T> struct S {\"\n             \"template<typename S> static void foo(){};\"\n             \"};\"\n             \"template <typename T> void declToImport() {\"\n             \"  S<T>::template foo<T>();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             functionTemplateDecl(has(functionDecl(has(compoundStmt(\n                 has(callExpr(has(dependentScopeDeclRefExpr())))))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Type, DependentNameType>\n    dependentNameType;\n\nTEST_P(ImportExpr, DependentNameType) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct declToImport {\"\n             \"  typedef typename T::type dependent_name;\"\n             \"};\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             classTemplateDecl(has(\n                 cxxRecordDecl(has(typedefDecl(has(dependentNameType())))))));\n}\n\nTEST_P(ImportExpr, UnresolvedMemberExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"struct S { template <typename T> void mem(); };\"\n             \"template <typename U> void declToImport() {\"\n             \"  S s;\"\n             \"  s.mem<U>();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             functionTemplateDecl(has(functionDecl(has(\n                 compoundStmt(has(callExpr(has(unresolvedMemberExpr())))))))));\n}\n\nclass ImportImplicitMethods : public ASTImporterOptionSpecificTestBase {\npublic:\n  static constexpr auto DefaultCode = R\"(\n      struct A { int x; };\n      void f() {\n        A a;\n        A a1(a);\n        A a2(A{});\n        a = a1;\n        a = A{};\n        a.~A();\n      })\";\n\n  template <typename MatcherType>\n  void testImportOf(\n      const MatcherType &MethodMatcher, const char *Code = DefaultCode) {\n    test(MethodMatcher, Code, /*ExpectedCount=*/1u);\n  }\n\n  template <typename MatcherType>\n  void testNoImportOf(\n      const MatcherType &MethodMatcher, const char *Code = DefaultCode) {\n    test(MethodMatcher, Code, /*ExpectedCount=*/0u);\n  }\n\nprivate:\n  template <typename MatcherType>\n  void test(const MatcherType &MethodMatcher,\n      const char *Code, unsigned int ExpectedCount) {\n    auto ClassMatcher = cxxRecordDecl(unless(isImplicit()));\n\n    Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n    auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(\n        ToTU, ClassMatcher);\n\n    ASSERT_EQ(DeclCounter<CXXMethodDecl>().match(ToClass, MethodMatcher), 1u);\n\n    {\n      CXXMethodDecl *Method =\n          FirstDeclMatcher<CXXMethodDecl>().match(ToClass, MethodMatcher);\n      ToClass->removeDecl(Method);\n      SharedStatePtr->getLookupTable()->remove(Method);\n    }\n\n    ASSERT_EQ(DeclCounter<CXXMethodDecl>().match(ToClass, MethodMatcher), 0u);\n\n    Decl *ImportedClass = nullptr;\n    {\n      Decl *FromTU = getTuDecl(Code, Lang_CXX11, \"input1.cc\");\n      auto *FromClass = FirstDeclMatcher<CXXRecordDecl>().match(\n          FromTU, ClassMatcher);\n      ImportedClass = Import(FromClass, Lang_CXX11);\n    }\n\n    EXPECT_EQ(ToClass, ImportedClass);\n    EXPECT_EQ(DeclCounter<CXXMethodDecl>().match(ToClass, MethodMatcher),\n        ExpectedCount);\n  }\n};\n\nTEST_P(ImportImplicitMethods, DefaultConstructor) {\n  testImportOf(cxxConstructorDecl(isDefaultConstructor()));\n}\n\nTEST_P(ImportImplicitMethods, CopyConstructor) {\n  testImportOf(cxxConstructorDecl(isCopyConstructor()));\n}\n\nTEST_P(ImportImplicitMethods, MoveConstructor) {\n  testImportOf(cxxConstructorDecl(isMoveConstructor()));\n}\n\nTEST_P(ImportImplicitMethods, Destructor) {\n  testImportOf(cxxDestructorDecl());\n}\n\nTEST_P(ImportImplicitMethods, CopyAssignment) {\n  testImportOf(cxxMethodDecl(isCopyAssignmentOperator()));\n}\n\nTEST_P(ImportImplicitMethods, MoveAssignment) {\n  testImportOf(cxxMethodDecl(isMoveAssignmentOperator()));\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportUserProvided) {\n  auto Code = R\"(\n      struct A { A() { int x; } };\n      )\";\n  testNoImportOf(cxxConstructorDecl(isDefaultConstructor()), Code);\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportDefault) {\n  auto Code = R\"(\n      struct A { A() = default; };\n      )\";\n  testNoImportOf(cxxConstructorDecl(isDefaultConstructor()), Code);\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportDeleted) {\n  auto Code = R\"(\n      struct A { A() = delete; };\n      )\";\n  testNoImportOf(cxxConstructorDecl(isDefaultConstructor()), Code);\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportOtherMethod) {\n  auto Code = R\"(\n      struct A { void f() { } };\n      )\";\n  testNoImportOf(cxxMethodDecl(hasName(\"f\")), Code);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfEquivalentRecord) {\n  Decl *ToR1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { };\", Lang_CXX03, \"input0.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n\n    ToR1 = Import(FromR, Lang_CXX03);\n  }\n\n  Decl *ToR2;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { };\", Lang_CXX03, \"input1.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n\n    ToR2 = Import(FromR, Lang_CXX03);\n  }\n\n  EXPECT_EQ(ToR1, ToR2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfNonEquivalentRecord) {\n  Decl *ToR1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input0.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n    ToR1 = Import(FromR, Lang_CXX03);\n  }\n  Decl *ToR2;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct A { unsigned x; };\", Lang_CXX03, \"input1.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n    ToR2 = Import(FromR, Lang_CXX03);\n  }\n  EXPECT_NE(ToR1, ToR2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfEquivalentField) {\n  Decl *ToF1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input0.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF1 = Import(FromF, Lang_CXX03);\n  }\n  Decl *ToF2;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input1.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF2 = Import(FromF, Lang_CXX03);\n  }\n  EXPECT_EQ(ToF1, ToF2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfNonEquivalentField) {\n  Decl *ToF1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input0.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF1 = Import(FromF, Lang_CXX03);\n  }\n  Decl *ToF2;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct A { unsigned x; };\", Lang_CXX03, \"input1.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF2 = Import(FromF, Lang_CXX03);\n  }\n  EXPECT_NE(ToF1, ToF2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfEquivalentMethod) {\n  Decl *ToM1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { void x(); }; void A::x() { }\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM1 = Import(FromM, Lang_CXX03);\n  }\n  Decl *ToM2;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { void x(); }; void A::x() { }\",\n                             Lang_CXX03, \"input1.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM2 = Import(FromM, Lang_CXX03);\n  }\n  EXPECT_EQ(ToM1, ToM2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfNonEquivalentMethod) {\n  Decl *ToM1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { void x(); }; void A::x() { }\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM1 = Import(FromM, Lang_CXX03);\n  }\n  Decl *ToM2;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct A { void x() const; }; void A::x() const { }\",\n                  Lang_CXX03, \"input1.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM2 = Import(FromM, Lang_CXX03);\n  }\n  EXPECT_NE(ToM1, ToM2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportUnnamedStructsWithRecursingField) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct A {\n        struct {\n          struct A *next;\n        } entry0;\n        struct {\n          struct A *next;\n        } entry1;\n      };\n      )\",\n      Lang_C99, \"input0.cc\");\n  auto *From =\n      FirstDeclMatcher<RecordDecl>().match(FromTU, recordDecl(hasName(\"A\")));\n\n  Import(From, Lang_C99);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *Entry0 =\n      FirstDeclMatcher<FieldDecl>().match(ToTU, fieldDecl(hasName(\"entry0\")));\n  auto *Entry1 =\n      FirstDeclMatcher<FieldDecl>().match(ToTU, fieldDecl(hasName(\"entry1\")));\n  auto *R0 = getRecordDecl(Entry0);\n  auto *R1 = getRecordDecl(Entry1);\n  EXPECT_NE(R0, R1);\n  EXPECT_TRUE(MatchVerifier<RecordDecl>().match(\n      R0, recordDecl(has(fieldDecl(hasName(\"next\"))))));\n  EXPECT_TRUE(MatchVerifier<RecordDecl>().match(\n      R1, recordDecl(has(fieldDecl(hasName(\"next\"))))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportUnnamedFieldsInCorrectOrder) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f(int X, int Y, bool Z) {\n        (void)[X, Y, Z] { (void)Z; };\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto *FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  auto *ToF = cast_or_null<FunctionDecl>(Import(FromF, Lang_CXX11));\n  EXPECT_TRUE(ToF);\n\n  CXXRecordDecl *FromLambda =\n      cast<LambdaExpr>(cast<CStyleCastExpr>(cast<CompoundStmt>(\n          FromF->getBody())->body_front())->getSubExpr())->getLambdaClass();\n\n  auto *ToLambda = cast_or_null<CXXRecordDecl>(Import(FromLambda, Lang_CXX11));\n  EXPECT_TRUE(ToLambda);\n\n  // Check if the fields of the lambda class are imported in correct order.\n  unsigned FromIndex = 0u;\n  for (auto *FromField : FromLambda->fields()) {\n    ASSERT_FALSE(FromField->getDeclName());\n    auto *ToField = cast_or_null<FieldDecl>(Import(FromField, Lang_CXX11));\n    EXPECT_TRUE(ToField);\n    Optional<unsigned> ToIndex = ASTImporter::getFieldIndex(ToField);\n    EXPECT_TRUE(ToIndex);\n    EXPECT_EQ(*ToIndex, FromIndex);\n    ++FromIndex;\n  }\n\n  EXPECT_EQ(FromIndex, 3u);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       MergeFieldDeclsOfClassTemplateSpecialization) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {\n          int a{0}; // FieldDecl with InitListExpr\n          X(char) : a(3) {}     // (1)\n          X(int) {}             // (2)\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n      R\"(\n      void foo() {\n          // ClassTemplateSpec with ctor (1): FieldDecl without InitlistExpr\n          X<char> xc('c');\n      }\n      )\", Lang_CXX11);\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  // FieldDecl without InitlistExpr:\n  auto *ToField = *ToSpec->field_begin();\n  ASSERT_TRUE(ToField);\n  ASSERT_FALSE(ToField->getInClassInitializer());\n  Decl *FromTU = getTuDecl(ClassTemplate +\n      R\"(\n      void bar() {\n          // ClassTemplateSpec with ctor (2): FieldDecl WITH InitlistExpr\n          X<char> xc(1);\n      }\n      )\", Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  // FieldDecl with InitlistExpr:\n  auto *FromField = *FromSpec->field_begin();\n  ASSERT_TRUE(FromField);\n  ASSERT_TRUE(FromField->getInClassInitializer());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  ASSERT_TRUE(ImportedSpec);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  // After the import, the FieldDecl has to be merged, thus it should have the\n  // InitListExpr.\n  EXPECT_TRUE(ToField->getInClassInitializer());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       MergeFunctionOfClassTemplateSpecialization) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {\n        void f() {}\n        void g() {}\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n      R\"(\n      void foo() {\n          X<char> x;\n          x.f();\n      }\n      )\", Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate +\n      R\"(\n      void bar() {\n          X<char> x;\n          x.g();\n      }\n      )\", Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  auto FunPattern = functionDecl(hasName(\"g\"),\n                         hasParent(classTemplateSpecializationDecl()));\n  auto *FromFun =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, FunPattern);\n  auto *ToFun =\n      FirstDeclMatcher<FunctionDecl>().match(ToTU, FunPattern);\n  ASSERT_TRUE(FromFun->hasBody());\n  ASSERT_FALSE(ToFun->hasBody());\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  ASSERT_TRUE(ImportedSpec);\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_TRUE(ToFun->hasBody());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, MergeTemplateSpecWithForwardDecl) {\n  std::string ClassTemplate =\n      R\"(\n      template<typename T>\n      struct X { int m; };\n      template<>\n      struct X<int> { int m; };\n      )\";\n  // Append a forward decl for our template specialization.\n  getToTuDecl(ClassTemplate + \"template<> struct X<int>;\", Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\"), isDefinition()));\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  // Check that our definition got merged with the existing definition.\n  EXPECT_TRUE(FromSpec->isThisDeclarationADefinition());\n  EXPECT_TRUE(ImportedSpec->isThisDeclarationADefinition());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ODRViolationOfClassTemplateSpecializationsShouldBeReported) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {};\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n                               R\"(\n      template <>\n      struct X<char> {\n          int a;\n      };\n      void foo() {\n          X<char> x;\n      }\n      )\",\n                           Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate +\n                               R\"(\n      template <>\n      struct X<char> {\n          int b;\n      };\n      void foo() {\n          X<char> x;\n      }\n      )\",\n                           Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n\n  // We expect one (ODR) warning during the import.\n  EXPECT_EQ(1u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n\n  // The second specialization is different from the first, thus it violates\n  // ODR, consequently we expect to keep the first specialization only, which is\n  // already in the \"To\" context.\n  EXPECT_FALSE(ImportedSpec);\n  EXPECT_EQ(1u,\n            DeclCounter<ClassTemplateSpecializationDecl>().match(\n                ToTU, classTemplateSpecializationDecl(hasName(\"X\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       MergeCtorOfClassTemplateSpecialization) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {\n          X(char) {}\n          X(int) {}\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n      R\"(\n      void foo() {\n          X<char> x('c');\n      }\n      )\", Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate +\n      R\"(\n      void bar() {\n          X<char> x(1);\n      }\n      )\", Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  // Match the void(int) ctor.\n  auto CtorPattern =\n      cxxConstructorDecl(hasParameter(0, varDecl(hasType(asString(\"int\")))),\n                         hasParent(classTemplateSpecializationDecl()));\n  auto *FromCtor =\n      FirstDeclMatcher<CXXConstructorDecl>().match(FromTU, CtorPattern);\n  auto *ToCtor =\n      FirstDeclMatcher<CXXConstructorDecl>().match(ToTU, CtorPattern);\n  ASSERT_TRUE(FromCtor->hasBody());\n  ASSERT_FALSE(ToCtor->hasBody());\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  ASSERT_TRUE(ImportedSpec);\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_TRUE(ToCtor->hasBody());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ClassTemplateFriendDecl) {\n  const auto *Code =\n      R\"(\n      template <class T> class X {  friend T; };\n      struct Y {};\n      template class X<Y>;\n    )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl());\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_EQ(1u, DeclCounter<ClassTemplateSpecializationDecl>().match(\n                    ToTU, classTemplateSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ClassTemplatePartialSpecializationsShouldNotBeDuplicated) {\n  auto Code =\n      R\"(\n    // primary template\n    template<class T1, class T2, int I>\n    class A {};\n\n    // partial specialization\n    template<class T, int I>\n    class A<T, T*, I> {};\n    )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX11);\n  auto *FromSpec =\n      FirstDeclMatcher<ClassTemplatePartialSpecializationDecl>().match(\n          FromTU, classTemplatePartialSpecializationDecl());\n  auto *ToSpec =\n      FirstDeclMatcher<ClassTemplatePartialSpecializationDecl>().match(\n          ToTU, classTemplatePartialSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_EQ(1u, DeclCounter<ClassTemplatePartialSpecializationDecl>().match(\n                    ToTU, classTemplatePartialSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ClassTemplateSpecializationsShouldNotBeDuplicated) {\n  auto Code =\n      R\"(\n    // primary template\n    template<class T1, class T2, int I>\n    class A {};\n\n    // full specialization\n    template<>\n    class A<int, int, 1> {};\n    )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl());\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_EQ(1u, DeclCounter<ClassTemplateSpecializationDecl>().match(\n                   ToTU, classTemplateSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ClassTemplateFullAndPartialSpecsShouldNotBeMixed) {\n  std::string PrimaryTemplate =\n      R\"(\n    template<class T1, class T2, int I>\n    class A {};\n    )\";\n  auto PartialSpec =\n      R\"(\n    template<class T, int I>\n    class A<T, T*, I> {};\n    )\";\n  auto FullSpec =\n      R\"(\n    template<>\n    class A<int, int, 1> {};\n    )\";\n  Decl *ToTU = getToTuDecl(PrimaryTemplate + FullSpec, Lang_CXX11);\n  Decl *FromTU = getTuDecl(PrimaryTemplate + PartialSpec, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_TRUE(ImportedSpec);\n  // Check the number of partial specializations.\n  EXPECT_EQ(1u, DeclCounter<ClassTemplatePartialSpecializationDecl>().match(\n                    ToTU, classTemplatePartialSpecializationDecl()));\n  // Check the number of full specializations.\n  EXPECT_EQ(1u, DeclCounter<ClassTemplateSpecializationDecl>().match(\n                    ToTU, classTemplateSpecializationDecl(\n                              unless(classTemplatePartialSpecializationDecl()))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       InitListExprValueKindShouldBeImported) {\n  Decl *TU = getTuDecl(\n      R\"(\n      const int &init();\n      void foo() { const int &a{init()}; }\n      )\", Lang_CXX11, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<VarDecl>().match(TU, varDecl(hasName(\"a\")));\n  ASSERT_TRUE(FromD->getAnyInitializer());\n  auto *InitExpr = FromD->getAnyInitializer();\n  ASSERT_TRUE(InitExpr);\n  ASSERT_TRUE(InitExpr->isGLValue());\n\n  auto *ToD = Import(FromD, Lang_CXX11);\n  EXPECT_TRUE(ToD);\n  auto *ToInitExpr = cast<VarDecl>(ToD)->getAnyInitializer();\n  EXPECT_TRUE(ToInitExpr);\n  EXPECT_TRUE(ToInitExpr->isGLValue());\n}\n\nstruct ImportVariables : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportVariables, ImportOfOneDeclBringsInTheWholeChain) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct A {\n        static const int a = 1 + 2;\n      };\n      const int A::a;\n      )\",\n      Lang_CXX03, \"input1.cc\");\n\n  auto *FromDWithInit = FirstDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with init\n  auto *FromDWithDef = LastDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with definition\n  ASSERT_NE(FromDWithInit, FromDWithDef);\n  ASSERT_EQ(FromDWithDef->getPreviousDecl(), FromDWithInit);\n\n  auto *ToD0 = cast<VarDecl>(Import(FromDWithInit, Lang_CXX11));\n  auto *ToD1 = cast<VarDecl>(Import(FromDWithDef, Lang_CXX11));\n  ASSERT_TRUE(ToD0);\n  ASSERT_TRUE(ToD1);\n  EXPECT_NE(ToD0, ToD1);\n  EXPECT_EQ(ToD1->getPreviousDecl(), ToD0);\n}\n\nTEST_P(ImportVariables, InitAndDefinitionAreInDifferentTUs) {\n  auto StructA =\n      R\"(\n      struct A {\n        static const int a = 1 + 2;\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(StructA, Lang_CXX03);\n  Decl *FromTU = getTuDecl(std::string(StructA) + \"const int A::a;\", Lang_CXX03,\n                           \"input1.cc\");\n\n  auto *FromDWithInit = FirstDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with init\n  auto *FromDWithDef = LastDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with definition\n  ASSERT_EQ(FromDWithInit, FromDWithDef->getPreviousDecl());\n  ASSERT_TRUE(FromDWithInit->getInit());\n  ASSERT_FALSE(FromDWithInit->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDWithDef->isThisDeclarationADefinition());\n  ASSERT_FALSE(FromDWithDef->getInit());\n\n  auto *ToD = FirstDeclMatcher<VarDecl>().match(\n      ToTU, varDecl(hasName(\"a\"))); // Decl with init\n  ASSERT_TRUE(ToD->getInit());\n  ASSERT_FALSE(ToD->getDefinition());\n\n  auto *ImportedD = cast<VarDecl>(Import(FromDWithDef, Lang_CXX11));\n  EXPECT_TRUE(ImportedD->getAnyInitializer());\n  EXPECT_TRUE(ImportedD->getDefinition());\n}\n\nTEST_P(ImportVariables, InitAndDefinitionAreInTheFromContext) {\n  auto StructA =\n      R\"(\n      struct A {\n        static const int a;\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(StructA, Lang_CXX03);\n  Decl *FromTU = getTuDecl(std::string(StructA) + \"const int A::a = 1 + 2;\",\n                           Lang_CXX03, \"input1.cc\");\n\n  auto *FromDDeclarationOnly = FirstDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\")));\n  auto *FromDWithDef = LastDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with definition and with init.\n  ASSERT_EQ(FromDDeclarationOnly, FromDWithDef->getPreviousDecl());\n  ASSERT_FALSE(FromDDeclarationOnly->getInit());\n  ASSERT_FALSE(FromDDeclarationOnly->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDWithDef->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDWithDef->getInit());\n\n  auto *ToD = FirstDeclMatcher<VarDecl>().match(\n      ToTU, varDecl(hasName(\"a\")));\n  ASSERT_FALSE(ToD->getInit());\n  ASSERT_FALSE(ToD->getDefinition());\n\n  auto *ImportedD = cast<VarDecl>(Import(FromDWithDef, Lang_CXX11));\n  EXPECT_TRUE(ImportedD->getAnyInitializer());\n  EXPECT_TRUE(ImportedD->getDefinition());\n}\n\nstruct ImportClasses : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportClasses, ImportDefinitionWhenProtoIsInNestedToContext) {\n  Decl *ToTU = getToTuDecl(\"struct A { struct X *Xp; };\", Lang_C99);\n  Decl *FromTU1 = getTuDecl(\"struct X {};\", Lang_C99, \"input1.cc\");\n  auto Pattern = recordDecl(hasName(\"X\"), unless(isImplicit()));\n  auto ToProto = FirstDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  auto FromDef = FirstDeclMatcher<RecordDecl>().match(FromTU1, Pattern);\n\n  Decl *ImportedDef = Import(FromDef, Lang_C99);\n\n  EXPECT_NE(ImportedDef, ToProto);\n  EXPECT_EQ(DeclCounter<RecordDecl>().match(ToTU, Pattern), 2u);\n  auto ToDef = LastDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedDef == ToDef);\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_FALSE(ToProto->isThisDeclarationADefinition());\n  EXPECT_EQ(ToDef->getPreviousDecl(), ToProto);\n}\n\nTEST_P(ImportClasses, ImportDefinitionWhenProtoIsInNestedToContextCXX) {\n  Decl *ToTU = getToTuDecl(\"struct A { struct X *Xp; };\", Lang_CXX03);\n  Decl *FromTU1 = getTuDecl(\"struct X {};\", Lang_CXX03, \"input1.cc\");\n  auto Pattern = recordDecl(hasName(\"X\"), unless(isImplicit()));\n  auto ToProto = FirstDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  auto FromDef = FirstDeclMatcher<RecordDecl>().match(FromTU1, Pattern);\n\n  Decl *ImportedDef = Import(FromDef, Lang_CXX03);\n\n  EXPECT_NE(ImportedDef, ToProto);\n  EXPECT_EQ(DeclCounter<RecordDecl>().match(ToTU, Pattern), 2u);\n  auto ToDef = LastDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedDef == ToDef);\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_FALSE(ToProto->isThisDeclarationADefinition());\n  EXPECT_EQ(ToDef->getPreviousDecl(), ToProto);\n}\n\nTEST_P(ImportClasses, ImportNestedPrototypeThenDefinition) {\n  Decl *FromTU0 =\n      getTuDecl(\"struct A { struct X *Xp; };\", Lang_C99, \"input0.cc\");\n  Decl *FromTU1 = getTuDecl(\"struct X {};\", Lang_C99, \"input1.cc\");\n  auto Pattern = recordDecl(hasName(\"X\"), unless(isImplicit()));\n  auto FromProto = FirstDeclMatcher<RecordDecl>().match(FromTU0, Pattern);\n  auto FromDef = FirstDeclMatcher<RecordDecl>().match(FromTU1, Pattern);\n\n  Decl *ImportedProto = Import(FromProto, Lang_C99);\n  Decl *ImportedDef = Import(FromDef, Lang_C99);\n  Decl *ToTU = ImportedDef->getTranslationUnitDecl();\n\n  EXPECT_NE(ImportedDef, ImportedProto);\n  EXPECT_EQ(DeclCounter<RecordDecl>().match(ToTU, Pattern), 2u);\n  auto ToProto = FirstDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  auto ToDef = LastDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedDef == ToDef);\n  EXPECT_TRUE(ImportedProto == ToProto);\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_FALSE(ToProto->isThisDeclarationADefinition());\n  EXPECT_EQ(ToDef->getPreviousDecl(), ToProto);\n}\n\n\nstruct ImportFriendClasses : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFriendClasses, ImportOfFriendRecordDoesNotMergeDefinition) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      class A {\n        template <int I> class F {};\n        class X {\n          template <int I> friend class F;\n        };\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  auto *FromClass = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"F\"), isDefinition()));\n  auto *FromFriendClass = LastDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"F\")));\n\n  ASSERT_TRUE(FromClass);\n  ASSERT_TRUE(FromFriendClass);\n  ASSERT_NE(FromClass, FromFriendClass);\n  ASSERT_EQ(FromFriendClass->getDefinition(), FromClass);\n  ASSERT_EQ(FromFriendClass->getPreviousDecl(), FromClass);\n  ASSERT_EQ(FromFriendClass->getDescribedClassTemplate()->getPreviousDecl(),\n            FromClass->getDescribedClassTemplate());\n\n  auto *ToClass = cast<CXXRecordDecl>(Import(FromClass, Lang_CXX03));\n  auto *ToFriendClass =\n      cast<CXXRecordDecl>(Import(FromFriendClass, Lang_CXX03));\n\n  EXPECT_TRUE(ToClass);\n  EXPECT_TRUE(ToFriendClass);\n  EXPECT_NE(ToClass, ToFriendClass);\n  EXPECT_EQ(ToFriendClass->getDefinition(), ToClass);\n  EXPECT_EQ(ToFriendClass->getPreviousDecl(), ToClass);\n  EXPECT_EQ(ToFriendClass->getDescribedClassTemplate()->getPreviousDecl(),\n            ToClass->getDescribedClassTemplate());\n}\n\nTEST_P(ImportFriendClasses, ImportOfRecursiveFriendClass) {\n  Decl *FromTu = getTuDecl(\n      R\"(\n      class declToImport {\n        friend class declToImport;\n      };\n      )\",\n      Lang_CXX03, \"input.cc\");\n\n  auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTu, cxxRecordDecl(hasName(\"declToImport\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  auto Pattern = cxxRecordDecl(has(friendDecl()));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromD, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToD, Pattern));\n}\n\nTEST_P(ImportFriendClasses, UndeclaredFriendClassShouldNotBeVisible) {\n  Decl *FromTu =\n      getTuDecl(\"class X { friend class Y; };\", Lang_CXX03, \"from.cc\");\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTu, cxxRecordDecl(hasName(\"X\")));\n  auto *FromFriend = FirstDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n  RecordDecl *FromRecordOfFriend =\n      const_cast<RecordDecl *>(getRecordDeclOfFriend(FromFriend));\n\n  ASSERT_EQ(FromRecordOfFriend->getDeclContext(), cast<DeclContext>(FromTu));\n  ASSERT_EQ(FromRecordOfFriend->getLexicalDeclContext(),\n            cast<DeclContext>(FromX));\n  ASSERT_FALSE(\n      FromRecordOfFriend->getDeclContext()->containsDecl(FromRecordOfFriend));\n  ASSERT_FALSE(FromRecordOfFriend->getLexicalDeclContext()->containsDecl(\n      FromRecordOfFriend));\n  ASSERT_FALSE(FromRecordOfFriend->getLookupParent()\n                   ->lookup(FromRecordOfFriend->getDeclName())\n                   .empty());\n\n  auto *ToX = Import(FromX, Lang_CXX03);\n  ASSERT_TRUE(ToX);\n\n  Decl *ToTu = ToX->getTranslationUnitDecl();\n  auto *ToFriend = FirstDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  RecordDecl *ToRecordOfFriend =\n      const_cast<RecordDecl *>(getRecordDeclOfFriend(ToFriend));\n\n  ASSERT_EQ(ToRecordOfFriend->getDeclContext(), cast<DeclContext>(ToTu));\n  ASSERT_EQ(ToRecordOfFriend->getLexicalDeclContext(), cast<DeclContext>(ToX));\n  EXPECT_FALSE(\n      ToRecordOfFriend->getDeclContext()->containsDecl(ToRecordOfFriend));\n  EXPECT_FALSE(ToRecordOfFriend->getLexicalDeclContext()->containsDecl(\n      ToRecordOfFriend));\n  EXPECT_FALSE(ToRecordOfFriend->getLookupParent()\n                   ->lookup(ToRecordOfFriend->getDeclName())\n                   .empty());\n}\n\nTEST_P(ImportFriendClasses, ImportOfRecursiveFriendClassTemplate) {\n  Decl *FromTu = getTuDecl(\n      R\"(\n      template<class A> class declToImport {\n        template<class A1> friend class declToImport;\n      };\n      )\",\n      Lang_CXX03, \"input.cc\");\n\n  auto *FromD =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTu, classTemplateDecl());\n  auto *ToD = Import(FromD, Lang_CXX03);\n\n  auto Pattern = classTemplateDecl(\n      has(cxxRecordDecl(has(friendDecl(has(classTemplateDecl()))))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromD, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToD, Pattern));\n\n  auto *Class =\n      FirstDeclMatcher<ClassTemplateDecl>().match(ToD, classTemplateDecl());\n  auto *Friend = FirstDeclMatcher<FriendDecl>().match(ToD, friendDecl());\n  EXPECT_NE(Friend->getFriendDecl(), Class);\n  EXPECT_EQ(Friend->getFriendDecl()->getPreviousDecl(), Class);\n}\n\nTEST_P(ImportFriendClasses, ProperPrevDeclForClassTemplateDecls) {\n  auto Pattern = classTemplateSpecializationDecl(hasName(\"X\"));\n\n  ClassTemplateSpecializationDecl *Imported1;\n  {\n    Decl *FromTU = getTuDecl(\"template<class T> class X;\"\n                             \"struct Y { friend class X<int>; };\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n        FromTU, Pattern);\n\n    Imported1 =\n        cast<ClassTemplateSpecializationDecl>(Import(FromD, Lang_CXX03));\n  }\n  ClassTemplateSpecializationDecl *Imported2;\n  {\n    Decl *FromTU = getTuDecl(\"template<class T> class X;\"\n                             \"template<> class X<int>{};\"\n                             \"struct Z { friend class X<int>; };\",\n                             Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n        FromTU, Pattern);\n\n    Imported2 =\n        cast<ClassTemplateSpecializationDecl>(Import(FromD, Lang_CXX03));\n  }\n\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_EQ(DeclCounter<ClassTemplateSpecializationDecl>().match(ToTU, Pattern),\n            2u);\n  ASSERT_TRUE(Imported2->getPreviousDecl());\n  EXPECT_EQ(Imported2->getPreviousDecl(), Imported1);\n}\n\nTEST_P(ImportFriendClasses, TypeForDeclShouldBeSetInTemplated) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        template <typename T>\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Fwd = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU0, classTemplateDecl(hasName(\"F\")));\n  auto *Imported0 = cast<ClassTemplateDecl>(Import(Fwd, Lang_CXX03));\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      template <typename T>\n      class F {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *Definition = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU1, classTemplateDecl(hasName(\"F\")));\n  auto *Imported1 = cast<ClassTemplateDecl>(Import(Definition, Lang_CXX03));\n  EXPECT_EQ(Imported0->getTemplatedDecl()->getTypeForDecl(),\n            Imported1->getTemplatedDecl()->getTypeForDecl());\n}\n\nTEST_P(ImportFriendClasses, DeclsFromFriendsShouldBeInRedeclChains) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"class declToImport {};\", Lang_CXX03,\n                      \"class Y { friend class declToImport; };\", Lang_CXX03);\n  auto *Imported = cast<CXXRecordDecl>(To);\n\n  EXPECT_TRUE(Imported->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses,\n       ImportOfClassTemplateDefinitionShouldConnectToFwdFriend) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        template <typename T>\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03);\n  auto *ToDecl = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      class F {};\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Definition = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"F\")));\n  auto *ImportedDef = cast<ClassTemplateDecl>(Import(Definition, Lang_CXX03));\n  EXPECT_TRUE(ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ToDecl, ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ToDecl->getTemplatedDecl(),\n            ImportedDef->getTemplatedDecl()->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses,\n       ImportOfClassTemplateDefinitionAndFwdFriendShouldBeLinked) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        template <typename T>\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Fwd = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU0, classTemplateDecl(hasName(\"F\")));\n  auto *ImportedFwd = cast<ClassTemplateDecl>(Import(Fwd, Lang_CXX03));\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      template <typename T>\n      class F {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *Definition = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU1, classTemplateDecl(hasName(\"F\")));\n  auto *ImportedDef = cast<ClassTemplateDecl>(Import(Definition, Lang_CXX03));\n  EXPECT_TRUE(ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ImportedFwd, ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ImportedFwd->getTemplatedDecl(),\n            ImportedDef->getTemplatedDecl()->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses, ImportOfClassDefinitionAndFwdFriendShouldBeLinked) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Friend = FirstDeclMatcher<FriendDecl>().match(FromTU0, friendDecl());\n  QualType FT = Friend->getFriendType()->getType();\n  FT = FromTU0->getASTContext().getCanonicalType(FT);\n  auto *Fwd = cast<TagType>(FT)->getDecl();\n  auto *ImportedFwd = Import(Fwd, Lang_CXX03);\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      class F {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *Definition = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU1, cxxRecordDecl(hasName(\"F\")));\n  auto *ImportedDef = Import(Definition, Lang_CXX03);\n  EXPECT_TRUE(ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ImportedFwd, ImportedDef->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses, ImportOfRepeatedFriendType) {\n  const char *Code =\n      R\"(\n      class Container {\n        friend class X;\n        friend class X;\n      };\n      )\";\n  Decl *ToTu = getToTuDecl(Code, Lang_CXX03);\n  Decl *FromTu = getTuDecl(Code, Lang_CXX03, \"from.cc\");\n\n  auto *ToFriend1 = FirstDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *ToFriend2 = LastDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *FromFriend1 =\n      FirstDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n  auto *FromFriend2 = LastDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n\n  FriendDecl *ToImportedFriend1 = Import(FromFriend1, Lang_CXX03);\n  FriendDecl *ToImportedFriend2 = Import(FromFriend2, Lang_CXX03);\n\n  EXPECT_NE(ToImportedFriend1, ToImportedFriend2);\n  EXPECT_EQ(ToFriend1, ToImportedFriend1);\n  EXPECT_EQ(ToFriend2, ToImportedFriend2);\n}\n\nTEST_P(ImportFriendClasses, ImportOfRepeatedFriendDecl) {\n  const char *Code =\n      R\"(\n      class Container {\n        friend void f();\n        friend void f();\n      };\n      )\";\n  Decl *ToTu = getToTuDecl(Code, Lang_CXX03);\n  Decl *FromTu = getTuDecl(Code, Lang_CXX03, \"from.cc\");\n\n  auto *ToFriend1 = FirstDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *ToFriend2 = LastDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *FromFriend1 =\n      FirstDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n  auto *FromFriend2 = LastDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n\n  FriendDecl *ToImportedFriend1 = Import(FromFriend1, Lang_CXX03);\n  FriendDecl *ToImportedFriend2 = Import(FromFriend2, Lang_CXX03);\n\n  EXPECT_NE(ToImportedFriend1, ToImportedFriend2);\n  EXPECT_EQ(ToFriend1, ToImportedFriend1);\n  EXPECT_EQ(ToFriend2, ToImportedFriend2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, FriendFunInClassTemplate) {\n  auto *Code = R\"(\n  template <class T>\n  struct X {\n    friend void foo(){}\n  };\n      )\";\n  TranslationUnitDecl *ToTU = getToTuDecl(Code, Lang_CXX03);\n  auto *ToFoo = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasName(\"foo\")));\n\n  TranslationUnitDecl *FromTU = getTuDecl(Code, Lang_CXX03, \"input.cc\");\n  auto *FromFoo = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  auto *ImportedFoo = Import(FromFoo, Lang_CXX03);\n  EXPECT_EQ(ImportedFoo, ToFoo);\n}\n\nstruct DeclContextTest : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(DeclContextTest, removeDeclOfClassTemplateSpecialization) {\n  Decl *TU = getTuDecl(\n      R\"(\n      namespace NS {\n\n      template <typename T>\n      struct S {};\n      template struct S<int>;\n\n      inline namespace INS {\n        template <typename T>\n        struct S {};\n        template struct S<int>;\n      }\n\n      }\n      )\", Lang_CXX11, \"input0.cc\");\n  auto *NS = FirstDeclMatcher<NamespaceDecl>().match(\n      TU, namespaceDecl());\n  auto *Spec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      TU, classTemplateSpecializationDecl());\n  ASSERT_TRUE(NS->containsDecl(Spec));\n\n  NS->removeDecl(Spec);\n  EXPECT_FALSE(NS->containsDecl(Spec));\n}\n\nTEST_P(DeclContextTest,\n       removeDeclShouldNotFailEvenIfWeHaveExternalVisibleStorage) {\n  Decl *TU = getTuDecl(\"extern int A; int A;\", Lang_CXX03);\n  auto *A0 = FirstDeclMatcher<VarDecl>().match(TU, varDecl(hasName(\"A\")));\n  auto *A1 = LastDeclMatcher<VarDecl>().match(TU, varDecl(hasName(\"A\")));\n\n  // Investigate the list.\n  auto *DC = A0->getDeclContext();\n  ASSERT_TRUE(DC->containsDecl(A0));\n  ASSERT_TRUE(DC->containsDecl(A1));\n\n  // Investigate the lookup table.\n  auto *Map = DC->getLookupPtr();\n  ASSERT_TRUE(Map);\n  auto I = Map->find(A0->getDeclName());\n  ASSERT_NE(I, Map->end());\n  StoredDeclsList &L = I->second;\n  // The lookup table contains the most recent decl of A.\n  ASSERT_NE(L.getAsDecl(), A0);\n  ASSERT_EQ(L.getAsDecl(), A1);\n\n  ASSERT_TRUE(L.getAsDecl());\n  // Simulate the private function DeclContext::reconcileExternalVisibleStorage.\n  // The point here is to have a Vec with only one element, which is not the\n  // one we are going to delete from the DC later.\n  L.setHasExternalDecls();\n  ASSERT_TRUE(L.getAsVector());\n  ASSERT_EQ(1u, L.getAsVector()->size());\n\n  // This asserts in the old implementation.\n  DC->removeDecl(A0);\n  EXPECT_FALSE(DC->containsDecl(A0));\n}\n\nstruct ImportFunctionTemplateSpecializations\n    : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       TUshouldNotContainFunctionTemplateImplicitInstantiation) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      void foo() { f<int>(); }\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  // Check that the function template instantiation is NOT the child of the TU.\n  auto Pattern = translationUnitDecl(\n      unless(has(functionDecl(hasName(\"f\"), isTemplateInstantiation()))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromTU, Pattern));\n\n  auto *Foo = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  ASSERT_TRUE(Import(Foo, Lang_CXX03));\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToTU, Pattern));\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       TUshouldNotContainFunctionTemplateExplicitInstantiation) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template int f<int>();\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  // Check that the function template instantiation is NOT the child of the TU.\n  auto Instantiation = functionDecl(hasName(\"f\"), isTemplateInstantiation());\n  auto Pattern = translationUnitDecl(unless(has(Instantiation)));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromTU, Pattern));\n\n  ASSERT_TRUE(Import(FirstDeclMatcher<Decl>().match(FromTU, Instantiation),\n                     Lang_CXX03));\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToTU, Pattern));\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       TUshouldContainFunctionTemplateSpecialization) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template <> int f<int>() { return 4; }\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  // Check that the function template specialization is the child of the TU.\n  auto Specialization =\n      functionDecl(hasName(\"f\"), isExplicitTemplateSpecialization());\n  auto Pattern = translationUnitDecl(has(Specialization));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromTU, Pattern));\n\n  ASSERT_TRUE(Import(FirstDeclMatcher<Decl>().match(FromTU, Specialization),\n                     Lang_CXX03));\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToTU, Pattern));\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       FunctionTemplateSpecializationRedeclChain) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template <> int f<int>() { return 4; }\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  auto Spec = functionDecl(hasName(\"f\"), isExplicitTemplateSpecialization(),\n                           hasParent(translationUnitDecl()));\n  auto *FromSpecD = FirstDeclMatcher<Decl>().match(FromTU, Spec);\n  {\n    auto *TU = FromTU;\n    auto *SpecD = FromSpecD;\n    auto *TemplateD = FirstDeclMatcher<FunctionTemplateDecl>().match(\n        TU, functionTemplateDecl());\n    auto *FirstSpecD = *(TemplateD->spec_begin());\n    ASSERT_EQ(SpecD, FirstSpecD);\n    ASSERT_TRUE(SpecD->getPreviousDecl());\n    ASSERT_FALSE(cast<FunctionDecl>(SpecD->getPreviousDecl())\n                     ->doesThisDeclarationHaveABody());\n  }\n\n  ASSERT_TRUE(Import(FromSpecD, Lang_CXX03));\n\n  {\n    auto *TU = ToAST->getASTContext().getTranslationUnitDecl();\n    auto *SpecD = FirstDeclMatcher<Decl>().match(TU, Spec);\n    auto *TemplateD = FirstDeclMatcher<FunctionTemplateDecl>().match(\n        TU, functionTemplateDecl());\n    auto *FirstSpecD = *(TemplateD->spec_begin());\n    EXPECT_EQ(SpecD, FirstSpecD);\n    ASSERT_TRUE(SpecD->getPreviousDecl());\n    EXPECT_FALSE(cast<FunctionDecl>(SpecD->getPreviousDecl())\n                     ->doesThisDeclarationHaveABody());\n  }\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       MatchNumberOfFunctionTemplateSpecializations) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> constexpr int f() { return 0; }\n      template <> constexpr int f<int>() { return 4; }\n      void foo() {\n        static_assert(f<char>() == 0, \"\");\n        static_assert(f<int>() == 4, \"\");\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n\n  Import(FromD, Lang_CXX11);\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_EQ(\n      DeclCounter<FunctionDecl>().match(FromTU, functionDecl(hasName(\"f\"))),\n      DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n    ImportShouldNotReportFalseODRErrorWhenRecordIsBeingDefined) {\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B;\n            )\",\n        Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n\n    Import(FromD, Lang_CXX03);\n  }\n\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B {\n              void f();\n              B* b;\n            };\n            )\",\n        Lang_CXX03, \"input1.cc\");\n    FunctionDecl *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n    auto *FromCTD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n    auto *ToCTD = cast<ClassTemplateDecl>(Import(FromCTD, Lang_CXX03));\n    EXPECT_TRUE(ToCTD->isThisDeclarationADefinition());\n\n    // We expect no (ODR) warning during the import.\n    auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n    EXPECT_EQ(0u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n  }\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportingTypedefShouldImportTheCompleteType) {\n  // We already have an incomplete underlying type in the \"To\" context.\n  auto Code =\n      R\"(\n      template <typename T>\n      struct S {\n        void foo();\n      };\n      using U = S<int>;\n      )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  auto *ToD = FirstDeclMatcher<TypedefNameDecl>().match(ToTU,\n      typedefNameDecl(hasName(\"U\")));\n  ASSERT_TRUE(ToD->getUnderlyingType()->isIncompleteType());\n\n  // The \"From\" context has the same typedef, but the underlying type is\n  // complete this time.\n  Decl *FromTU = getTuDecl(std::string(Code) +\n      R\"(\n      void foo(U* u) {\n        u->foo();\n      }\n      )\", Lang_CXX11);\n  auto *FromD = FirstDeclMatcher<TypedefNameDecl>().match(FromTU,\n      typedefNameDecl(hasName(\"U\")));\n  ASSERT_FALSE(FromD->getUnderlyingType()->isIncompleteType());\n\n  // The imported type should be complete.\n  auto *ImportedD = cast<TypedefNameDecl>(Import(FromD, Lang_CXX11));\n  EXPECT_FALSE(ImportedD->getUnderlyingType()->isIncompleteType());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportTemplateParameterLists) {\n  auto Code =\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template <> int f<int>() { return 4; }\n      )\";\n\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU,\n      functionDecl(hasName(\"f\"), isExplicitTemplateSpecialization()));\n  ASSERT_EQ(FromD->getNumTemplateParameterLists(), 1u);\n\n  auto *ToD = Import(FromD, Lang_CXX03);\n  // The template parameter list should exist.\n  EXPECT_EQ(ToD->getNumTemplateParameterLists(), 1u);\n}\n\nstruct ASTImporterLookupTableTest : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ASTImporterLookupTableTest, OneDecl) {\n  auto *ToTU = getToTuDecl(\"int a;\", Lang_CXX03);\n  auto *D = FirstDeclMatcher<VarDecl>().match(ToTU, varDecl(hasName(\"a\")));\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(ToTU, D->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), D);\n}\n\nstatic Decl *findInDeclListOfDC(DeclContext *DC, DeclarationName Name) {\n  for (Decl *D : DC->decls()) {\n    if (auto *ND = dyn_cast<NamedDecl>(D))\n      if (ND->getDeclName() == Name)\n        return ND;\n  }\n  return nullptr;\n}\n\nTEST_P(ASTImporterLookupTableTest,\n    FriendWhichIsnotFoundByNormalLookupShouldBeFoundByImporterSpecificLookup) {\n  auto *Code = R\"(\n  template <class T>\n  struct X {\n    friend void foo(){}\n  };\n      )\";\n  TranslationUnitDecl *ToTU = getToTuDecl(Code, Lang_CXX03);\n  auto *X = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"X\")));\n  auto *Foo = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasName(\"foo\")));\n  DeclContext *FooDC = Foo->getDeclContext();\n  DeclContext *FooLexicalDC = Foo->getLexicalDeclContext();\n  ASSERT_EQ(cast<Decl>(FooLexicalDC), X->getTemplatedDecl());\n  ASSERT_EQ(cast<Decl>(FooDC), ToTU);\n  DeclarationName FooName = Foo->getDeclName();\n\n  // Cannot find in the LookupTable of its DC (TUDecl)\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  FooDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Cannot find in the LookupTable of its LexicalDC (X)\n  FooLexicalDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Can't find in the list of Decls of the DC.\n  EXPECT_EQ(findInDeclListOfDC(FooDC, FooName), nullptr);\n\n  // Can't find in the list of Decls of the LexicalDC\n  EXPECT_EQ(findInDeclListOfDC(FooLexicalDC, FooName), nullptr);\n\n  // ASTImporter specific lookup finds it.\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(FooDC, Foo->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), Foo);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       FwdDeclStructShouldBeFoundByImporterSpecificLookup) {\n  TranslationUnitDecl *ToTU =\n      getToTuDecl(\"struct A { struct Foo *p; };\", Lang_C99);\n  auto *Foo =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"Foo\")));\n  auto *A =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"A\")));\n  DeclContext *FooDC = Foo->getDeclContext();\n  DeclContext *FooLexicalDC = Foo->getLexicalDeclContext();\n  ASSERT_EQ(cast<Decl>(FooLexicalDC), A);\n  ASSERT_EQ(cast<Decl>(FooDC), ToTU);\n  DeclarationName FooName = Foo->getDeclName();\n\n  // Cannot find in the LookupTable of its DC (TUDecl).\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  FooDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Cannot find in the LookupTable of its LexicalDC (A).\n  FooLexicalDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Can't find in the list of Decls of the DC.\n  EXPECT_EQ(findInDeclListOfDC(FooDC, FooName), nullptr);\n\n  // Can find in the list of Decls of the LexicalDC.\n  EXPECT_EQ(findInDeclListOfDC(FooLexicalDC, FooName), Foo);\n\n  // ASTImporter specific lookup finds it.\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(FooDC, Foo->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), Foo);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsNamesInDifferentDC) {\n  TranslationUnitDecl *ToTU =\n      getToTuDecl(\"int V; struct A { int V; }; struct B { int V; };\", Lang_C99);\n  DeclarationName VName = FirstDeclMatcher<VarDecl>()\n                              .match(ToTU, varDecl(hasName(\"V\")))\n                              ->getDeclName();\n  auto *A =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"A\")));\n  auto *B =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"B\")));\n\n  ASTImporterLookupTable LT(*ToTU);\n\n  auto Res = LT.lookup(cast<DeclContext>(A), VName);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FirstDeclMatcher<FieldDecl>().match(\n                        ToTU, fieldDecl(hasName(\"V\"),\n                                        hasParent(recordDecl(hasName(\"A\"))))));\n  Res = LT.lookup(cast<DeclContext>(B), VName);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FirstDeclMatcher<FieldDecl>().match(\n                        ToTU, fieldDecl(hasName(\"V\"),\n                                        hasParent(recordDecl(hasName(\"B\"))))));\n  Res = LT.lookup(ToTU, VName);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FirstDeclMatcher<VarDecl>().match(\n                        ToTU, varDecl(hasName(\"V\"),\n                                        hasParent(translationUnitDecl()))));\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsOverloadedNames) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      void foo();\n      void foo(int);\n      void foo(int, int);\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, functionDecl());\n  auto *F2 = LastDeclMatcher<FunctionDecl>().match(ToTU, functionDecl());\n  DeclarationName Name = F0->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 3u);\n  EXPECT_EQ(Res.count(F0), 1u);\n  EXPECT_EQ(Res.count(F2), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       DifferentOperatorsShouldHaveDifferentResultSet) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      struct X{};\n      void operator+(X, X);\n      void operator-(X, X);\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *FPlus = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasOverloadedOperatorName(\"+\")));\n  auto *FMinus = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasOverloadedOperatorName(\"-\")));\n  DeclarationName NamePlus = FPlus->getDeclName();\n  auto ResPlus = LT.lookup(ToTU, NamePlus);\n  EXPECT_EQ(ResPlus.size(), 1u);\n  EXPECT_EQ(ResPlus.count(FPlus), 1u);\n  EXPECT_EQ(ResPlus.count(FMinus), 0u);\n  DeclarationName NameMinus = FMinus->getDeclName();\n  auto ResMinus = LT.lookup(ToTU, NameMinus);\n  EXPECT_EQ(ResMinus.size(), 1u);\n  EXPECT_EQ(ResMinus.count(FMinus), 1u);\n  EXPECT_EQ(ResMinus.count(FPlus), 0u);\n  EXPECT_NE(*ResMinus.begin(), *ResPlus.begin());\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupDeclNamesFromDifferentTUs) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      struct X {};\n      void operator+(X, X);\n      )\",\n      Lang_CXX03);\n  auto *ToPlus = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasOverloadedOperatorName(\"+\")));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {};\n      void operator+(X, X);\n      )\",\n      Lang_CXX03);\n  auto *FromPlus = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasOverloadedOperatorName(\"+\")));\n\n  // FromPlus have a different TU, thus its DeclarationName is different too.\n  ASSERT_NE(ToPlus->getDeclName(), FromPlus->getDeclName());\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(ToTU, ToPlus->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), ToPlus);\n\n  // FromPlus have a different TU, thus its DeclarationName is different too.\n  Res = LT.lookup(ToTU, FromPlus->getDeclName());\n  ASSERT_EQ(Res.size(), 0u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsFwdFriendClassDeclWithElaboratedType) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { friend class F; };\n      )\",\n      Lang_CXX03);\n\n  // In this case, the CXXRecordDecl is hidden, the FriendDecl is not a parent.\n  // So we must dig up the underlying CXXRecordDecl.\n  ASTImporterLookupTable LT(*ToTU);\n  auto *FriendD = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  const RecordDecl *RD = getRecordDeclOfFriend(FriendD);\n  auto *Y = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"Y\")));\n\n  DeclarationName Name = RD->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), RD);\n\n  Res = LT.lookup(Y, Name);\n  EXPECT_EQ(Res.size(), 0u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsFwdFriendClassDeclWithUnelaboratedType) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class F;\n      class Y { friend F; };\n      )\",\n      Lang_CXX11);\n\n  // In this case, the CXXRecordDecl is hidden, the FriendDecl is not a parent.\n  // So we must dig up the underlying CXXRecordDecl.\n  ASTImporterLookupTable LT(*ToTU);\n  auto *FriendD = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  const RecordDecl *RD = getRecordDeclOfFriend(FriendD);\n  auto *Y = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, cxxRecordDecl(hasName(\"Y\")));\n\n  DeclarationName Name = RD->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), RD);\n\n  Res = LT.lookup(Y, Name);\n  EXPECT_EQ(Res.size(), 0u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsFriendClassDeclWithTypeAliasDoesNotAssert) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class F;\n      using alias_of_f = F;\n      class Y { friend alias_of_f; };\n      )\",\n      Lang_CXX11);\n\n  // ASTImporterLookupTable constructor handles using declarations correctly,\n  // no assert is expected.\n  ASTImporterLookupTable LT(*ToTU);\n\n  auto *Alias = FirstDeclMatcher<TypeAliasDecl>().match(\n      ToTU, typeAliasDecl(hasName(\"alias_of_f\")));\n  DeclarationName Name = Alias->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.count(Alias), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsFwdFriendClassTemplateDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { template <class T> friend class F; };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 2u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, DependentFriendClass) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      class F;\n\n      template <typename T>\n      class Y {\n        friend class F<T>;\n      };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 2u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, FriendClassTemplateSpecialization) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      class F;\n\n      class Y {\n        friend class F<int>;\n      };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  ASSERT_EQ(Res.size(), 3u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n  EXPECT_EQ(Res.count(*F->spec_begin()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsFwdFriendFunctionDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { friend void F(); };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F =\n      FirstDeclMatcher<FunctionDecl>().match(ToTU, functionDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), F);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsDeclsInClassTemplateSpecialization) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      struct X {\n        int F;\n      };\n      void foo() {\n        X<char> xc;\n      }\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n\n  auto *Template = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"X\")));\n  auto *FieldInTemplate = FirstDeclMatcher<FieldDecl>().match(\n      ToTU,\n      fieldDecl(hasParent(cxxRecordDecl(hasParent(classTemplateDecl())))));\n\n  auto *Spec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  FieldDecl *FieldInSpec = *Spec->field_begin();\n  ASSERT_TRUE(FieldInSpec);\n\n  DeclarationName Name = FieldInSpec->getDeclName();\n  auto TemplateDC = cast<DeclContext>(Template->getTemplatedDecl());\n\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  TemplateDC->getRedeclContext()->localUncachedLookup(Name, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n  EXPECT_EQ(FoundDecls[0], FieldInTemplate);\n\n  auto Res = LT.lookup(TemplateDC, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FieldInTemplate);\n\n  cast<DeclContext>(Spec)->getRedeclContext()->localUncachedLookup(Name,\n                                                                   FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n  EXPECT_EQ(FoundDecls[0], FieldInSpec);\n\n  Res = LT.lookup(cast<DeclContext>(Spec), Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FieldInSpec);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsFwdFriendFunctionTemplateDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { template <class T> friend void F(); };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      ToTU, functionTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 2u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, MultipleBefriendingClasses) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      struct X;\n      struct A {\n        friend struct X;\n      };\n      struct B {\n        friend struct X;\n      };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *X = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\")));\n  auto *FriendD0 = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  auto *FriendD1 = LastDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  const RecordDecl *RD0 = getRecordDeclOfFriend(FriendD0);\n  const RecordDecl *RD1 = getRecordDeclOfFriend(FriendD1);\n  ASSERT_EQ(RD0, RD1);\n  ASSERT_EQ(RD1, X);\n\n  DeclarationName Name = X->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), X);\n}\n\nTEST_P(ASTImporterLookupTableTest, EnumConstantDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      enum E {\n        A,\n        B\n      };\n      )\",\n      Lang_C99);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *E = FirstDeclMatcher<EnumDecl>().match(ToTU, enumDecl(hasName(\"E\")));\n  auto *A = FirstDeclMatcher<EnumConstantDecl>().match(\n      ToTU, enumConstantDecl(hasName(\"A\")));\n\n  DeclarationName Name = A->getDeclName();\n  // Redecl context is the TU.\n  ASSERT_EQ(E->getRedeclContext(), ToTU);\n\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  // Normal lookup finds in the DC.\n  E->localUncachedLookup(Name, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n\n  // Normal lookup finds in the Redecl context.\n  ToTU->localUncachedLookup(Name, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n\n  // Import specific lookup finds in the DC.\n  auto Res = LT.lookup(E, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), A);\n\n  // Import specific lookup finds in the Redecl context.\n  Res = LT.lookup(ToTU, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), A);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupSearchesInTheWholeRedeclChain) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      namespace N {\n        int A;\n      }\n      namespace N {\n      }\n      )\",\n      Lang_CXX03);\n  auto *N1 =\n      LastDeclMatcher<NamespaceDecl>().match(ToTU, namespaceDecl(hasName(\"N\")));\n  auto *A = FirstDeclMatcher<VarDecl>().match(ToTU, varDecl(hasName(\"A\")));\n  DeclarationName Name = A->getDeclName();\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(N1, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), A);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       RedeclChainShouldBeCorrectAmongstNamespaces) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      namespace NS {\n        struct X;\n        struct Y {\n          static const int I = 3;\n        };\n      }\n      namespace NS {\n        struct X {  // <--- To be imported\n          void method(int i = Y::I) {}\n          int f;\n        };\n      }\n      )\",\n      Lang_CXX03);\n  auto *FromFwd = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\"), unless(isImplicit())));\n  auto *FromDef = LastDeclMatcher<CXXRecordDecl>().match(\n      FromTU,\n      cxxRecordDecl(hasName(\"X\"), isDefinition(), unless(isImplicit())));\n  ASSERT_NE(FromFwd, FromDef);\n  ASSERT_FALSE(FromFwd->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDef->isThisDeclarationADefinition());\n  ASSERT_EQ(FromFwd->getCanonicalDecl(), FromDef->getCanonicalDecl());\n\n  auto *ToDef = cast_or_null<CXXRecordDecl>(Import(FromDef, Lang_CXX03));\n  auto *ToFwd = cast_or_null<CXXRecordDecl>(Import(FromFwd, Lang_CXX03));\n  EXPECT_NE(ToFwd, ToDef);\n  EXPECT_FALSE(ToFwd->isThisDeclarationADefinition());\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_EQ(ToFwd->getCanonicalDecl(), ToDef->getCanonicalDecl());\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We expect no (ODR) warning during the import.\n  EXPECT_EQ(0u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n}\n\nstruct ImportFriendFunctionTemplates : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFriendFunctionTemplates, LookupShouldFindPreviousFriend) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      class X {\n        template <typename T> friend void foo();\n      };\n      )\",\n      Lang_CXX03);\n  auto *Friend = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      ToTU, functionTemplateDecl(hasName(\"foo\")));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> void foo();\n      )\",\n      Lang_CXX03);\n  auto *FromFoo = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU, functionTemplateDecl(hasName(\"foo\")));\n  auto *Imported = Import(FromFoo, Lang_CXX03);\n\n  EXPECT_EQ(Imported->getPreviousDecl(), Friend);\n}\n\nstruct ASTImporterWithFakeErrors : ASTImporter {\n  using ASTImporter::ASTImporter;\n  bool returnWithErrorInTest() override { return true; }\n};\n\nstruct ErrorHandlingTest : ASTImporterOptionSpecificTestBase {\n  ErrorHandlingTest() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new ASTImporterWithFakeErrors(ToContext, ToFileManager,\n                                           FromContext, FromFileManager,\n                                           MinimalImport, SharedState);\n    };\n  }\n  // In this test we purposely report an error (UnsupportedConstruct) when\n  // importing the below stmt.\n  static constexpr auto* ErroneousStmt = R\"( asm(\"\"); )\";\n};\n\n// Check a case when no new AST node is created in the AST before encountering\n// the error.\nTEST_P(ErrorHandlingTest, ErrorHappensBeforeCreatingANewNode) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      class X {};\n      template <>\n      class X<int> { int a; };\n      )\",\n      Lang_CXX03);\n  TranslationUnitDecl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      class X {};\n      template <>\n      class X<int> { double b; };\n      )\",\n      Lang_CXX03);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  ClassTemplateSpecializationDecl *ImportedSpec = Import(FromSpec, Lang_CXX03);\n  EXPECT_FALSE(ImportedSpec);\n\n  // The original Decl is kept, no new decl is created.\n  EXPECT_EQ(DeclCounter<ClassTemplateSpecializationDecl>().match(\n                ToTU, classTemplateSpecializationDecl(hasName(\"X\"))),\n            1u);\n\n  // But an error is set to the counterpart in the \"from\" context.\n  ASTImporter *Importer = findFromTU(FromSpec)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromSpec);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::NameConflict);\n}\n\n// Check a case when a new AST node is created but not linked to the AST before\n// encountering the error.\nTEST_P(ErrorHandlingTest,\n       ErrorHappensAfterCreatingTheNodeButBeforeLinkingThatToTheAST) {\n  TranslationUnitDecl *FromTU = getTuDecl(\n      std::string(\"void foo() { \") + ErroneousStmt + \" }\", Lang_CXX03);\n  auto *FromFoo = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n\n  FunctionDecl *ImportedFoo = Import(FromFoo, Lang_CXX03);\n  EXPECT_FALSE(ImportedFoo);\n\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // Created, but not linked.\n  EXPECT_EQ(\n      DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"foo\"))),\n      0u);\n\n  ASTImporter *Importer = findFromTU(FromFoo)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromFoo);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n}\n\n// Check a case when a new AST node is created and linked to the AST before\n// encountering the error. The error is set for the counterpart of the nodes in\n// the \"from\" context.\nTEST_P(ErrorHandlingTest, ErrorHappensAfterNodeIsCreatedAndLinked) {\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n      void f();\n      void f() { )\") + ErroneousStmt + R\"( }\n      )\",\n                                          Lang_CXX03);\n  auto *FromProto = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  auto *FromDef =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, functionDecl(hasName(\"f\")));\n  FunctionDecl *ImportedProto = Import(FromProto, Lang_CXX03);\n  EXPECT_FALSE(ImportedProto); // Could not import.\n  // However, we created two nodes in the AST. 1) the fwd decl 2) the\n  // definition. The definition is not added to its DC, but the fwd decl is\n  // there.\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\"))),\n            1u);\n  // Match the fwd decl.\n  auto *ToProto =\n      FirstDeclMatcher<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\")));\n  EXPECT_TRUE(ToProto);\n  // An error is set to the counterpart in the \"from\" context both for the fwd\n  // decl and the definition.\n  ASTImporter *Importer = findFromTU(FromProto)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromProto);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  OptErr = Importer->getImportDeclErrorIfAny(FromDef);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n}\n\n// An error should be set for a class if we cannot import one member.\nTEST_P(ErrorHandlingTest, ErrorIsPropagatedFromMemberToClass) {\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n      class X {\n        void f() { )\") + ErroneousStmt + R\"( } // This member has the error\n                                               // during import.\n        void ok();        // The error should not prevent importing this.\n      };                  // An error will be set for X too.\n      )\",\n                                          Lang_CXX03);\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  CXXRecordDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n  // An error is set for X.\n  EXPECT_FALSE(ImportedX);\n  ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n\n  // An error is set for f().\n  auto *FromF = FirstDeclMatcher<CXXMethodDecl>().match(\n      FromTU, cxxMethodDecl(hasName(\"f\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromF);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  // And any subsequent import should fail.\n  CXXMethodDecl *ImportedF = Import(FromF, Lang_CXX03);\n  EXPECT_FALSE(ImportedF);\n\n  // There is an error set for the other member too.\n  auto *FromOK = FirstDeclMatcher<CXXMethodDecl>().match(\n      FromTU, cxxMethodDecl(hasName(\"ok\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromOK);\n  EXPECT_TRUE(OptErr);\n  // Cannot import the other member.\n  CXXMethodDecl *ImportedOK = Import(FromOK, Lang_CXX03);\n  EXPECT_FALSE(ImportedOK);\n}\n\n// Check that an error propagates to the dependent AST nodes.\n// In the below code it means that an error in X should propagate to A.\n// And even to F since the containing A is erroneous.\n// And to all AST nodes which we visit during the import process which finally\n// ends up in a failure (in the error() function).\nTEST_P(ErrorHandlingTest, ErrorPropagatesThroughImportCycles) {\n  Decl *FromTU = getTuDecl(std::string(R\"(\n      namespace NS {\n        class A {\n          template <int I> class F {};\n          class X {\n            template <int I> friend class F;\n            void error() { )\") +\n                               ErroneousStmt + R\"( }\n          };\n        };\n\n        class B {};\n      } // NS\n      )\",\n                           Lang_CXX03, \"input0.cc\");\n\n  auto *FromFRD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"F\"), isDefinition()));\n  auto *FromA = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"A\"), isDefinition()));\n  auto *FromB = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"B\"), isDefinition()));\n  auto *FromNS = FirstDeclMatcher<NamespaceDecl>().match(\n      FromTU, namespaceDecl(hasName(\"NS\")));\n\n  // Start by importing the templated CXXRecordDecl of F.\n  // Import fails for that.\n  EXPECT_FALSE(Import(FromFRD, Lang_CXX03));\n  // Import fails for A.\n  EXPECT_FALSE(Import(FromA, Lang_CXX03));\n  // But we should be able to import the independent B.\n  EXPECT_TRUE(Import(FromB, Lang_CXX03));\n  // And the namespace.\n  EXPECT_TRUE(Import(FromNS, Lang_CXX03));\n\n  // An error is set to the templated CXXRecordDecl of F.\n  ASTImporter *Importer = findFromTU(FromFRD)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromFRD);\n  EXPECT_TRUE(OptErr);\n\n  // An error is set to A.\n  OptErr = Importer->getImportDeclErrorIfAny(FromA);\n  EXPECT_TRUE(OptErr);\n\n  // There is no error set to B.\n  OptErr = Importer->getImportDeclErrorIfAny(FromB);\n  EXPECT_FALSE(OptErr);\n\n  // There is no error set to NS.\n  OptErr = Importer->getImportDeclErrorIfAny(FromNS);\n  EXPECT_FALSE(OptErr);\n\n  // Check some of those decls whose ancestor is X, they all should have an\n  // error set if we visited them during an import process which finally failed.\n  // These decls are part of a cycle in an ImportPath.\n  // There would not be any error set for these decls if we hadn't follow the\n  // ImportPaths and the cycles.\n  OptErr = Importer->getImportDeclErrorIfAny(\n      FirstDeclMatcher<ClassTemplateDecl>().match(\n          FromTU, classTemplateDecl(hasName(\"F\"))));\n  // An error is set to the 'F' ClassTemplateDecl.\n  EXPECT_TRUE(OptErr);\n  // An error is set to the FriendDecl.\n  OptErr = Importer->getImportDeclErrorIfAny(\n      FirstDeclMatcher<FriendDecl>().match(\n          FromTU, friendDecl()));\n  EXPECT_TRUE(OptErr);\n  // An error is set to the implicit class of A.\n  OptErr =\n      Importer->getImportDeclErrorIfAny(FirstDeclMatcher<CXXRecordDecl>().match(\n          FromTU, cxxRecordDecl(hasName(\"A\"), isImplicit())));\n  EXPECT_TRUE(OptErr);\n  // An error is set to the implicit class of X.\n  OptErr =\n      Importer->getImportDeclErrorIfAny(FirstDeclMatcher<CXXRecordDecl>().match(\n          FromTU, cxxRecordDecl(hasName(\"X\"), isImplicit())));\n  EXPECT_TRUE(OptErr);\n}\n\nTEST_P(ErrorHandlingTest, ErrorIsNotPropagatedFromMemberToNamespace) {\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n      namespace X {\n        void f() { )\") + ErroneousStmt + R\"( } // This member has the error\n                                               // during import.\n        void ok();        // The error should not prevent importing this.\n      };                  // An error will be set for X too.\n      )\",\n                                          Lang_CXX03);\n  auto *FromX = FirstDeclMatcher<NamespaceDecl>().match(\n      FromTU, namespaceDecl(hasName(\"X\")));\n  NamespaceDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n  // There is no error set for X.\n  EXPECT_TRUE(ImportedX);\n  ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n  ASSERT_FALSE(OptErr);\n\n  // An error is set for f().\n  auto *FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromF);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  // And any subsequent import should fail.\n  FunctionDecl *ImportedF = Import(FromF, Lang_CXX03);\n  EXPECT_FALSE(ImportedF);\n\n  // There is no error set for ok().\n  auto *FromOK = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"ok\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromOK);\n  EXPECT_FALSE(OptErr);\n  // And we should be able to import.\n  FunctionDecl *ImportedOK = Import(FromOK, Lang_CXX03);\n  EXPECT_TRUE(ImportedOK);\n}\n\n// An error should be set for a class if it had a previous import with an error\n// from another TU.\nTEST_P(ErrorHandlingTest,\n       ImportedDeclWithErrorShouldFailTheImportOfDeclWhichMapToIt) {\n  // We already have a fwd decl.\n  TranslationUnitDecl *ToTU = getToTuDecl(\"class X;\", Lang_CXX03);\n  // Then we import a definition.\n  {\n    TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n        class X {\n          void f() { )\") + ErroneousStmt + R\"( }\n          void ok();\n        };\n        )\",\n                                            Lang_CXX03);\n    auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"X\")));\n    CXXRecordDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n    // An error is set for X ...\n    EXPECT_FALSE(ImportedX);\n    ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n    Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n    ASSERT_TRUE(OptErr);\n    EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  }\n  // ... but the node had been created.\n  auto *ToXDef = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\"), isDefinition()));\n  // An error is set for \"ToXDef\" in the shared state.\n  Optional<ImportError> OptErr =\n      SharedStatePtr->getImportDeclErrorIfAny(ToXDef);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n\n  auto *ToXFwd = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\"), unless(isDefinition())));\n  // An error is NOT set for the fwd Decl of X in the shared state.\n  OptErr = SharedStatePtr->getImportDeclErrorIfAny(ToXFwd);\n  ASSERT_FALSE(OptErr);\n\n  // Try to import  X again but from another TU.\n  {\n    TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n        class X {\n          void f() { )\") + ErroneousStmt + R\"( }\n          void ok();\n        };\n        )\",\n                                            Lang_CXX03, \"input1.cc\");\n\n    auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"X\")));\n    CXXRecordDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n    // If we did not save the errors for the \"to\" context then the below checks\n    // would fail, because the lookup finds the fwd Decl of the existing\n    // definition in the \"to\" context. We can reach the existing definition via\n    // the found fwd Decl. That existing definition is structurally equivalent\n    // (we check only the fields) with this one we want to import, so we return\n    // with the existing definition, which is erroneous (one method is missing).\n\n    // The import should fail.\n    EXPECT_FALSE(ImportedX);\n    ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n    Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n    // And an error is set for this new X in the \"from\" ctx.\n    ASSERT_TRUE(OptErr);\n    EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  }\n}\n\nTEST_P(ErrorHandlingTest, ImportOfOverriddenMethods) {\n  auto MatchFooA =\n      functionDecl(hasName(\"foo\"), hasAncestor(cxxRecordDecl(hasName(\"A\"))));\n  auto MatchFooB =\n      functionDecl(hasName(\"foo\"), hasAncestor(cxxRecordDecl(hasName(\"B\"))));\n  auto MatchFooC =\n      functionDecl(hasName(\"foo\"), hasAncestor(cxxRecordDecl(hasName(\"C\"))));\n\n  // Provoke import of a method that has overridden methods with import error.\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n        struct C;\n        struct A {\n          virtual void foo();\n          void f1(C *);\n        };\n        void A::foo() {\n          )\") + ErroneousStmt + R\"(\n        }\n        struct B : public A {\n          void foo() override;\n        };\n        struct C : public B {\n          void foo() override;\n        };\n        )\",\n                                          Lang_CXX11);\n  auto *FromFooA = FirstDeclMatcher<FunctionDecl>().match(FromTU, MatchFooA);\n  auto *FromFooB = FirstDeclMatcher<FunctionDecl>().match(FromTU, MatchFooB);\n  auto *FromFooC = FirstDeclMatcher<FunctionDecl>().match(FromTU, MatchFooC);\n\n  EXPECT_FALSE(Import(FromFooA, Lang_CXX11));\n  ASTImporter *Importer = findFromTU(FromFooA)->Importer.get();\n  auto CheckError = [&Importer](Decl *FromD) {\n    Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromD);\n    ASSERT_TRUE(OptErr);\n    EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  };\n  CheckError(FromFooA);\n  EXPECT_FALSE(Import(FromFooB, Lang_CXX11));\n  CheckError(FromFooB);\n  EXPECT_FALSE(Import(FromFooC, Lang_CXX11));\n  CheckError(FromFooC);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdaInFunctionBody) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto L = [](){};\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = lambdaExpr();\n  CXXRecordDecl *FromL =\n      FirstDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n\n  auto ToL = Import(FromL, Lang_CXX11);\n  unsigned ToLSize = std::distance(ToL->decls().begin(), ToL->decls().end());\n  unsigned FromLSize =\n      std::distance(FromL->decls().begin(), FromL->decls().end());\n  EXPECT_NE(ToLSize, 0u);\n  EXPECT_EQ(ToLSize, FromLSize);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdaInFunctionParam) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename F>\n      void f(F L = [](){}) {}\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = lambdaExpr();\n  CXXRecordDecl *FromL =\n      FirstDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n\n  auto ToL = Import(FromL, Lang_CXX11);\n  unsigned ToLSize = std::distance(ToL->decls().begin(), ToL->decls().end());\n  unsigned FromLSize =\n      std::distance(FromL->decls().begin(), FromL->decls().end());\n  EXPECT_NE(ToLSize, 0u);\n  EXPECT_EQ(ToLSize, FromLSize);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdaInGlobalScope) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto l1 = [](unsigned lp) { return 1; };\n      auto l2 = [](int lp) { return 2; };\n      int f(int p) {\n        return l1(p) + l2(p);\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  FunctionDecl *FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  FunctionDecl *ToF = Import(FromF, Lang_CXX11);\n  EXPECT_TRUE(ToF);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportExistingFriendClassTemplateDef) {\n  auto Code =\n      R\"(\n        template <class T1, class T2>\n        struct Base {\n          template <class U1, class U2>\n          friend struct Class;\n        };\n        template <class T1, class T2>\n        struct Class { };\n        )\";\n\n  TranslationUnitDecl *ToTU = getToTuDecl(Code, Lang_CXX03);\n  TranslationUnitDecl *FromTU = getTuDecl(Code, Lang_CXX03, \"input.cc\");\n\n  auto *ToClassProto = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"Class\")));\n  auto *ToClassDef = LastDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"Class\")));\n  ASSERT_FALSE(ToClassProto->isThisDeclarationADefinition());\n  ASSERT_TRUE(ToClassDef->isThisDeclarationADefinition());\n  // Previous friend decl is not linked to it!\n  ASSERT_FALSE(ToClassDef->getPreviousDecl());\n  ASSERT_EQ(ToClassDef->getMostRecentDecl(), ToClassDef);\n  ASSERT_EQ(ToClassProto->getMostRecentDecl(), ToClassProto);\n\n  auto *FromClassProto = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"Class\")));\n  auto *FromClassDef = LastDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"Class\")));\n  ASSERT_FALSE(FromClassProto->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromClassDef->isThisDeclarationADefinition());\n  ASSERT_FALSE(FromClassDef->getPreviousDecl());\n  ASSERT_EQ(FromClassDef->getMostRecentDecl(), FromClassDef);\n  ASSERT_EQ(FromClassProto->getMostRecentDecl(), FromClassProto);\n\n  auto *ImportedDef = Import(FromClassDef, Lang_CXX03);\n  // At import we should find the definition for 'Class' even if the\n  // prototype (inside 'friend') for it comes first in the AST and is not\n  // linked to the definition.\n  EXPECT_EQ(ImportedDef, ToClassDef);\n}\n\nstruct LLDBLookupTest : ASTImporterOptionSpecificTestBase {\n  LLDBLookupTest() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new ASTImporter(ToContext, ToFileManager, FromContext,\n                             FromFileManager, MinimalImport,\n                             // We use the regular lookup.\n                             /*SharedState=*/nullptr);\n    };\n  }\n};\n\nTEST_P(LLDBLookupTest, ImporterShouldFindInTransparentContext) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      extern \"C\" {\n        class X{};\n      };\n      )\",\n      Lang_CXX03);\n  auto *ToX = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\")));\n\n  // Set up a stub external storage.\n  ToTU->setHasExternalLexicalStorage(true);\n  // Set up DeclContextBits.HasLazyExternalLexicalLookups to true.\n  ToTU->setMustBuildLookupTable();\n  struct TestExternalASTSource : ExternalASTSource {};\n  ToTU->getASTContext().setExternalSource(new TestExternalASTSource());\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n        class X;\n      )\",\n      Lang_CXX03);\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  auto *ImportedX = Import(FromX, Lang_CXX03);\n  // The lookup must find the existing class definition in the LinkageSpecDecl.\n  // Then the importer renders the existing and the new decl into one chain.\n  EXPECT_EQ(ImportedX->getCanonicalDecl(), ToX->getCanonicalDecl());\n}\n\nstruct SVEBuiltins : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(SVEBuiltins, ImportTypes) {\n  static const char *const TypeNames[] = {\n    \"__SVInt8_t\",\n    \"__SVInt16_t\",\n    \"__SVInt32_t\",\n    \"__SVInt64_t\",\n    \"__SVUint8_t\",\n    \"__SVUint16_t\",\n    \"__SVUint32_t\",\n    \"__SVUint64_t\",\n    \"__SVFloat16_t\",\n    \"__SVBFloat16_t\",\n    \"__SVFloat32_t\",\n    \"__SVFloat64_t\",\n    \"__SVBool_t\"\n  };\n\n  TranslationUnitDecl *ToTU = getToTuDecl(\"\", Lang_CXX03);\n  TranslationUnitDecl *FromTU = getTuDecl(\"\", Lang_CXX03, \"input.cc\");\n  for (auto *TypeName : TypeNames) {\n    auto *ToTypedef = FirstDeclMatcher<TypedefDecl>().match(\n      ToTU, typedefDecl(hasName(TypeName)));\n    QualType ToType = ToTypedef->getUnderlyingType();\n\n    auto *FromTypedef = FirstDeclMatcher<TypedefDecl>().match(\n      FromTU, typedefDecl(hasName(TypeName)));\n    QualType FromType = FromTypedef->getUnderlyingType();\n\n    QualType ImportedType = ImportType(FromType, FromTypedef, Lang_CXX03);\n    EXPECT_EQ(ImportedType, ToType);\n  }\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfDefaultImplicitFunctions) {\n  // Test that import of implicit functions works and the functions\n  // are merged into one chain.\n  auto GetDeclToImport = [this](StringRef File) {\n    Decl *FromTU = getTuDecl(\n        R\"(\n        struct X { };\n        // Force generating some implicit operator definitions for X.\n        void f() { X x1, x2; x1 = x2; X *x3 = new X; delete x3; }\n        )\",\n        Lang_CXX11, File);\n    auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"X\"), unless(isImplicit())));\n    // Destructor is picked as one example of implicit function.\n    return FromD->getDestructor();\n  };\n\n  auto *ToD1 = Import(GetDeclToImport(\"input1.cc\"), Lang_CXX11);\n  ASSERT_TRUE(ToD1);\n\n  auto *ToD2 = Import(GetDeclToImport(\"input2.cc\"), Lang_CXX11);\n  ASSERT_TRUE(ToD2);\n\n  EXPECT_EQ(ToD1->getCanonicalDecl(), ToD2->getCanonicalDecl());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfExplicitlyDefaultedOrDeleted) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n        struct X { X() = default; X(const X&) = delete; };\n      )\",\n      Lang_CXX11);\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  auto *ImportedX = Import(FromX, Lang_CXX11);\n  auto *Constr1 = FirstDeclMatcher<CXXConstructorDecl>().match(\n      ImportedX, cxxConstructorDecl(hasName(\"X\"), unless(isImplicit())));\n  auto *Constr2 = LastDeclMatcher<CXXConstructorDecl>().match(\n      ImportedX, cxxConstructorDecl(hasName(\"X\"), unless(isImplicit())));\n\n  ASSERT_TRUE(ImportedX);\n  EXPECT_TRUE(Constr1->isDefaulted());\n  EXPECT_TRUE(Constr1->isExplicitlyDefaulted());\n  EXPECT_TRUE(Constr2->isDeletedAsWritten());\n  EXPECT_EQ(ImportedX->isAggregate(), FromX->isAggregate());\n}\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, SVEBuiltins,\n                        ::testing::Values(std::vector<std::string>{\n                            \"-target\", \"aarch64-linux-gnu\"}), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, DeclContextTest,\n                        ::testing::Values(std::vector<std::string>()), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, CanonicalRedeclChain,\n                        ::testing::Values(std::vector<std::string>()), );\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdasAreDifferentiated) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto L0 = [](){};\n        auto L1 = [](){};\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = lambdaExpr();\n  CXXRecordDecl *FromL0 =\n      FirstDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n  CXXRecordDecl *FromL1 =\n      LastDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n  ASSERT_NE(FromL0, FromL1);\n\n  CXXRecordDecl *ToL0 = Import(FromL0, Lang_CXX11);\n  CXXRecordDecl *ToL1 = Import(FromL1, Lang_CXX11);\n  EXPECT_NE(ToL0, ToL1);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       LambdasInFunctionParamsAreDifferentiated) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename F0, typename F1>\n      void f(F0 L0 = [](){}, F1 L1 = [](){}) {}\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = cxxRecordDecl(isLambda());\n  CXXRecordDecl *FromL0 =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  CXXRecordDecl *FromL1 =\n      LastDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  ASSERT_NE(FromL0, FromL1);\n\n  CXXRecordDecl *ToL0 = Import(FromL0, Lang_CXX11);\n  CXXRecordDecl *ToL1 = Import(FromL1, Lang_CXX11);\n  ASSERT_NE(ToL0, ToL1);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       LambdasInFunctionParamsAreDifferentiatedWhenMacroIsUsed) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      #define LAMBDA [](){}\n      template <typename F0, typename F1>\n      void f(F0 L0 = LAMBDA, F1 L1 = LAMBDA) {}\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = cxxRecordDecl(isLambda());\n  CXXRecordDecl *FromL0 =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  CXXRecordDecl *FromL1 =\n      LastDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  ASSERT_NE(FromL0, FromL1);\n\n  Import(FromL0, Lang_CXX11);\n  Import(FromL1, Lang_CXX11);\n  CXXRecordDecl *ToL0 = Import(FromL0, Lang_CXX11);\n  CXXRecordDecl *ToL1 = Import(FromL1, Lang_CXX11);\n  ASSERT_NE(ToL0, ToL1);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportAssignedLambda) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto x = []{} = {}; auto x2 = x;\n      }\n      )\",\n      Lang_CXX20, \"input0.cc\");\n  auto FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  // We have only one lambda class.\n  ASSERT_EQ(\n      DeclCounter<CXXRecordDecl>().match(FromTU, cxxRecordDecl(isLambda())),\n      1u);\n\n  FunctionDecl *ToF = Import(FromF, Lang_CXX20);\n  EXPECT_TRUE(ToF);\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We have only one lambda class after the import.\n  EXPECT_EQ(DeclCounter<CXXRecordDecl>().match(ToTU, cxxRecordDecl(isLambda())),\n            1u);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDefaultConstructibleLambdas) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto x = []{} = {};\n        auto xb = []{} = {};\n      }\n      )\",\n      Lang_CXX20, \"input0.cc\");\n  auto FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  // We have two lambda classes.\n  ASSERT_EQ(\n      DeclCounter<CXXRecordDecl>().match(FromTU, cxxRecordDecl(isLambda())),\n      2u);\n\n  FunctionDecl *ToF = Import(FromF, Lang_CXX20);\n  EXPECT_TRUE(ToF);\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We have two lambda classes after the import.\n  EXPECT_EQ(DeclCounter<CXXRecordDecl>().match(ToTU, cxxRecordDecl(isLambda())),\n            2u);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImplicitlyDeclareSelf) {\n  Decl *FromTU = getTuDecl(R\"(\n                           __attribute__((objc_root_class))\n                           @interface Root\n                           @end\n                           @interface C : Root\n                             -(void)method;\n                           @end\n                           @implementation C\n                             -(void)method {}\n                           @end\n                           )\",\n                           Lang_OBJCXX, \"input.mm\");\n  auto *FromMethod = LastDeclMatcher<ObjCMethodDecl>().match(\n      FromTU, namedDecl(hasName(\"method\")));\n  ASSERT_TRUE(FromMethod);\n  auto ToMethod = Import(FromMethod, Lang_OBJCXX);\n  ASSERT_TRUE(ToMethod);\n\n  // Both methods should have their implicit parameters.\n  EXPECT_TRUE(FromMethod->getSelfDecl() != nullptr);\n  EXPECT_TRUE(ToMethod->getSelfDecl() != nullptr);\n}\n\nstruct ImportAutoFunctions : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportAutoFunctions, ReturnWithTypedefDeclaredInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto X = [](long l) {\n        using int_type = long;\n        auto dur = 13;\n        return static_cast<int_type>(dur);\n      };\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  CXXMethodDecl *From =\n      FirstDeclMatcher<CXXMethodDecl>().match(FromTU, cxxMethodDecl());\n\n  // Explicitly set the return type of the lambda's operator() to the TypeAlias.\n  // Normally the return type would be the built-in 'long' type. However, there\n  // are cases when Clang does not use the canonical type and the TypeAlias is\n  // used. I could not create such an AST from regular source code, it requires\n  // some special state in the preprocessor. I've found such an AST when Clang\n  // parsed libcxx/src/filesystem/directory_iterator.cpp, but could not reduce\n  // that with creduce, because after preprocessing, the AST no longer\n  // contained the TypeAlias as a return type of the lambda.\n  ASTContext &Ctx = From->getASTContext();\n  TypeAliasDecl *FromTA =\n      FirstDeclMatcher<TypeAliasDecl>().match(FromTU, typeAliasDecl());\n  QualType TT = Ctx.getTypedefType(FromTA);\n  const FunctionProtoType *FPT = cast<FunctionProtoType>(From->getType());\n  QualType NewFunType =\n      Ctx.getFunctionType(TT, FPT->getParamTypes(), FPT->getExtProtoInfo());\n  From->setType(NewFunType);\n\n  CXXMethodDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<TypedefType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithStructDeclaredInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X {};\n        return X();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  FunctionDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithStructDeclaredInside2) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X {};\n        return X();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  // This time import the type directly.\n  QualType ToT = ImportType(From->getType(), From, Lang_CXX14);\n  const FunctionProtoType *FPT = cast<FunctionProtoType>(ToT);\n  EXPECT_TRUE(isa<AutoType>(FPT->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypedefToStructDeclaredInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X {};\n        using Y = X;\n        return Y();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  FunctionDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithStructDeclaredNestedInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X { struct Y{}; };\n        return X::Y();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  FunctionDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithInternalLambdaType) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        auto l = []() {\n          struct X {};\n          return X();\n        };\n        return l();\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypeInIf) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        if (struct X {} x; true)\n          return X();\n        else\n          return X();\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypeInFor) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        for (struct X {} x;;)\n          return X();\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypeInSwitch) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        switch (struct X {} x; 10) {\n        case 10:\n          return X();\n        }\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nstruct ImportSourceLocations : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportSourceLocations, PreserveFileIDTreeStructure) {\n  // Tests that the FileID tree structure (with the links being the include\n  // chains) is preserved while importing other files (which need to be\n  // added to this structure with fake include locations.\n\n  SourceLocation Location1;\n  {\n    auto Pattern = varDecl(hasName(\"X\"));\n    Decl *FromTU = getTuDecl(\"int X;\", Lang_C99, \"input0.c\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n\n    Location1 = Import(FromD, Lang_C99)->getLocation();\n  }\n  SourceLocation Location2;\n  {\n    auto Pattern = varDecl(hasName(\"Y\"));\n    Decl *FromTU = getTuDecl(\"int Y;\", Lang_C99, \"input1.c\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n\n    Location2 = Import(FromD, Lang_C99)->getLocation();\n  }\n\n  SourceManager &ToSM = ToAST->getSourceManager();\n  FileID FileID1 = ToSM.getFileID(Location1);\n  FileID FileID2 = ToSM.getFileID(Location2);\n\n  // Check that the imported files look like as if they were included from the\n  // start of the main file.\n  SourceLocation FileStart = ToSM.getLocForStartOfFile(ToSM.getMainFileID());\n  EXPECT_NE(FileID1, ToSM.getMainFileID());\n  EXPECT_NE(FileID2, ToSM.getMainFileID());\n  EXPECT_EQ(ToSM.getIncludeLoc(FileID1), FileStart);\n  EXPECT_EQ(ToSM.getIncludeLoc(FileID2), FileStart);\n\n  // Let the SourceManager check the order of the locations. The order should\n  // be the order in which the declarations are imported.\n  EXPECT_TRUE(ToSM.isBeforeInTranslationUnit(Location1, Location2));\n  EXPECT_FALSE(ToSM.isBeforeInTranslationUnit(Location2, Location1));\n}\n\nTEST_P(ImportSourceLocations, NormalFileBuffer) {\n  // Test importing normal file buffers.\n\n  std::string Path = \"input0.c\";\n  std::string Source = \"int X;\";\n  TranslationUnitDecl *FromTU = getTuDecl(Source, Lang_C99, Path);\n\n  SourceLocation ImportedLoc;\n  {\n    // Import the VarDecl to trigger the importing of the FileID.\n    auto Pattern = varDecl(hasName(\"X\"));\n    VarDecl *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    ImportedLoc = Import(FromD, Lang_C99)->getLocation();\n  }\n\n  // Make sure the imported buffer has the original contents.\n  SourceManager &ToSM = ToAST->getSourceManager();\n  FileID ImportedID = ToSM.getFileID(ImportedLoc);\n  EXPECT_EQ(Source,\n            ToSM.getBufferOrFake(ImportedID, SourceLocation()).getBuffer());\n}\n\nTEST_P(ImportSourceLocations, OverwrittenFileBuffer) {\n  // Test importing overwritten file buffers.\n\n  std::string Path = \"input0.c\";\n  TranslationUnitDecl *FromTU = getTuDecl(\"int X;\", Lang_C99, Path);\n\n  // Overwrite the file buffer for our input file with new content.\n  const std::string Contents = \"overwritten contents\";\n  SourceLocation ImportedLoc;\n  {\n    SourceManager &FromSM = FromTU->getASTContext().getSourceManager();\n    clang::FileManager &FM = FromSM.getFileManager();\n    const clang::FileEntry &FE =\n        *FM.getVirtualFile(Path, static_cast<off_t>(Contents.size()), 0);\n\n    llvm::SmallVector<char, 64> Buffer;\n    Buffer.append(Contents.begin(), Contents.end());\n    auto FileContents =\n        std::make_unique<llvm::SmallVectorMemoryBuffer>(std::move(Buffer), Path);\n    FromSM.overrideFileContents(&FE, std::move(FileContents));\n\n    // Import the VarDecl to trigger the importing of the FileID.\n    auto Pattern = varDecl(hasName(\"X\"));\n    VarDecl *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    ImportedLoc = Import(FromD, Lang_C99)->getLocation();\n  }\n\n  // Make sure the imported buffer has the overwritten contents.\n  SourceManager &ToSM = ToAST->getSourceManager();\n  FileID ImportedID = ToSM.getFileID(ImportedLoc);\n  EXPECT_EQ(Contents,\n            ToSM.getBufferOrFake(ImportedID, SourceLocation()).getBuffer());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportExprOfAlignmentAttr) {\n  // Test if import of these packed and aligned attributes does not trigger an\n  // error situation where source location from 'From' context is referenced in\n  // 'To' context through evaluation of the alignof attribute.\n  // This happens if the 'alignof(A)' expression is not imported correctly.\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct __attribute__((packed)) A { int __attribute__((aligned(8))) X; };\n      struct alignas(alignof(A)) S {};\n      )\",\n      Lang_CXX11, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"S\"), unless(isImplicit())));\n  ASSERT_TRUE(FromD);\n\n  auto *ToD = Import(FromD, Lang_CXX11);\n  ASSERT_TRUE(ToD);\n\n  auto *FromAttr = FromD->getAttr<AlignedAttr>();\n  auto *ToAttr = ToD->getAttr<AlignedAttr>();\n  EXPECT_EQ(FromAttr->isInherited(), ToAttr->isInherited());\n  EXPECT_EQ(FromAttr->isPackExpansion(), ToAttr->isPackExpansion());\n  EXPECT_EQ(FromAttr->isImplicit(), ToAttr->isImplicit());\n  EXPECT_EQ(FromAttr->getSyntax(), ToAttr->getSyntax());\n  EXPECT_EQ(FromAttr->getSemanticSpelling(), ToAttr->getSemanticSpelling());\n  EXPECT_TRUE(ToAttr->getAlignmentExpr());\n\n  auto *ToA = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToD->getTranslationUnitDecl(),\n      cxxRecordDecl(hasName(\"A\"), unless(isImplicit())));\n  // Ensure that 'struct A' was imported (through reference from attribute of\n  // 'S').\n  EXPECT_TRUE(ToA);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportFormatAttr) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      int foo(const char * fmt, ...)\n      __attribute__ ((__format__ (__scanf__, 1, 2)));\n      )\",\n      Lang_CXX03, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  ASSERT_TRUE(FromD);\n\n  auto *ToD = Import(FromD, Lang_CXX03);\n  ASSERT_TRUE(ToD);\n  ToD->dump(); // Should not crash!\n\n  auto *FromAttr = FromD->getAttr<FormatAttr>();\n  auto *ToAttr = ToD->getAttr<FormatAttr>();\n  EXPECT_EQ(FromAttr->isInherited(), ToAttr->isInherited());\n  EXPECT_EQ(FromAttr->isPackExpansion(), ToAttr->isPackExpansion());\n  EXPECT_EQ(FromAttr->isImplicit(), ToAttr->isImplicit());\n  EXPECT_EQ(FromAttr->getSyntax(), ToAttr->getSyntax());\n  EXPECT_EQ(FromAttr->getAttributeSpellingListIndex(),\n            ToAttr->getAttributeSpellingListIndex());\n  EXPECT_EQ(FromAttr->getType()->getName(), ToAttr->getType()->getName());\n}\ntemplate <typename T>\nauto ExtendWithOptions(const T &Values, const std::vector<std::string> &Args) {\n  auto Copy = Values;\n  for (std::vector<std::string> &ArgV : Copy) {\n    for (const std::string &Arg : Args) {\n      ArgV.push_back(Arg);\n    }\n  }\n  return ::testing::ValuesIn(Copy);\n}\n\nstruct ImportWithExternalSource : ASTImporterOptionSpecificTestBase {\n  ImportWithExternalSource() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new ASTImporter(ToContext, ToFileManager, FromContext,\n                             FromFileManager, MinimalImport,\n                             // We use the regular lookup.\n                             /*SharedState=*/nullptr);\n    };\n  }\n};\n\n/// An ExternalASTSource that keeps track of the tags is completed.\nstruct SourceWithCompletedTagList : clang::ExternalASTSource {\n  std::vector<clang::TagDecl *> &CompletedTags;\n  SourceWithCompletedTagList(std::vector<clang::TagDecl *> &CompletedTags)\n      : CompletedTags(CompletedTags) {}\n  void CompleteType(TagDecl *Tag) override {\n    auto *Record = cast<CXXRecordDecl>(Tag);\n    Record->startDefinition();\n    Record->completeDefinition();\n    CompletedTags.push_back(Tag);\n  }\n  using clang::ExternalASTSource::CompleteType;\n};\n\nTEST_P(ImportWithExternalSource, CompleteRecordBeforeImporting) {\n  // Create an empty TU.\n  TranslationUnitDecl *FromTU = getTuDecl(\"\", Lang_CXX03, \"input.cpp\");\n\n  // Create and add the test ExternalASTSource.\n  std::vector<clang::TagDecl *> CompletedTags;\n  IntrusiveRefCntPtr<ExternalASTSource> source =\n      new SourceWithCompletedTagList(CompletedTags);\n  clang::ASTContext &Context = FromTU->getASTContext();\n  Context.setExternalSource(std::move(source));\n\n  // Create a dummy class by hand with external lexical storage.\n  IdentifierInfo &Ident = Context.Idents.get(\"test_class\");\n  auto *Record = CXXRecordDecl::Create(\n      Context, TTK_Class, FromTU, SourceLocation(), SourceLocation(), &Ident);\n  Record->setHasExternalLexicalStorage();\n  FromTU->addDecl(Record);\n\n  // Do a minimal import of the created class.\n  EXPECT_EQ(0U, CompletedTags.size());\n  Import(Record, Lang_CXX03);\n  EXPECT_EQ(0U, CompletedTags.size());\n\n  // Import the definition of the created class.\n  llvm::Error Err = findFromTU(Record)->Importer->ImportDefinition(Record);\n  EXPECT_FALSE((bool)Err);\n  consumeError(std::move(Err));\n\n  // Make sure the class was completed once.\n  EXPECT_EQ(1U, CompletedTags.size());\n  EXPECT_EQ(Record, CompletedTags.front());\n}\n\nTEST_P(ImportFunctions, CTADImplicit) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        A(T);\n      };\n      A a{(int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      FromTU,\n      cxxDeductionGuideDecl(hasParameter(0, hasType(asString(\"A<T>\")))));\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n  EXPECT_TRUE(ToD->isCopyDeductionCandidate());\n  // Check that the deduced class template is also imported.\n  EXPECT_TRUE(findFromTU(FromD)->Importer->GetAlreadyImportedOrNull(\n      FromD->getDeducedTemplate()));\n}\n\nTEST_P(ImportFunctions, CTADUserDefinedExplicit) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        A(T);\n      };\n      template <typename T> explicit A(T) -> A<float>;\n      A a{(int)0}; // calls A<float>::A(float)\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      FromTU, cxxDeductionGuideDecl(unless(isImplicit())));\n  // Not-implicit: i.e. not compiler-generated, user defined.\n  ASSERT_FALSE(FromD->isImplicit());\n  ASSERT_TRUE(FromD->isExplicit()); // Has the explicit keyword.\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n  EXPECT_FALSE(FromD->isImplicit());\n  EXPECT_TRUE(ToD->isExplicit());\n}\n\nTEST_P(ImportFunctions, CTADWithLocalTypedef) {\n  Decl *TU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        typedef T U;\n        A(U);\n      };\n      A a{(int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n}\n\n// FIXME Move these tests out of ASTImporterTest. For that we need to factor\n// out the ASTImporter specific pars from ASTImporterOptionSpecificTestBase\n// into a new test Fixture. Then we should lift up this Fixture to its own\n// implementation file and only then could we reuse the Fixture in other AST\n// unitttests.\nstruct CTAD : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(CTAD, DeductionGuideShouldReferToANonLocalTypedef) {\n  Decl *TU = getTuDecl(\n      R\"(\n      typedef int U;\n      template <typename T> struct A {\n        A(U, T);\n      };\n      A a{(int)0, (int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *Guide = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *Typedef = FirstDeclMatcher<TypedefNameDecl>().match(\n      TU, typedefNameDecl(hasName(\"U\")));\n  ParmVarDecl *Param = Guide->getParamDecl(0);\n  // The type of the first param (which is a typedef) should match the typedef\n  // in the global scope.\n  EXPECT_EQ(Param->getType()->getAs<TypedefType>()->getDecl(), Typedef);\n}\n\nTEST_P(CTAD, DeductionGuideShouldReferToANonLocalTypedefInParamPtr) {\n  Decl *TU = getTuDecl(\n      R\"(\n      typedef int U;\n      template <typename T> struct A {\n        A(U*, T);\n      };\n      A a{(int*)0, (int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *Guide = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *Typedef = FirstDeclMatcher<TypedefNameDecl>().match(\n      TU, typedefNameDecl(hasName(\"U\")));\n  ParmVarDecl *Param = Guide->getParamDecl(0);\n  EXPECT_EQ(Param->getType()\n                ->getAs<PointerType>()\n                ->getPointeeType()\n                ->getAs<TypedefType>()\n                ->getDecl(),\n            Typedef);\n}\n\nTEST_P(CTAD, DeductionGuideShouldCopyALocalTypedef) {\n  Decl *TU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        typedef T U;\n        A(U, T);\n      };\n      A a{(int)0, (int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *Guide = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *Typedef = FirstDeclMatcher<TypedefNameDecl>().match(\n      TU, typedefNameDecl(hasName(\"U\")));\n  ParmVarDecl *Param = Guide->getParamDecl(0);\n  EXPECT_NE(Param->getType()->getAs<TypedefType>()->getDecl(), Typedef);\n}\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, CTAD,\n                        DefaultTestValuesForRunOptions, );\n\nTEST_P(ASTImporterOptionSpecificTestBase, TypedefWithAttribute) {\n  Decl *TU = getTuDecl(\n      R\"(\n      namespace N {\n        typedef int X __attribute__((annotate(\"A\")));\n      }\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD =\n      FirstDeclMatcher<TypedefDecl>().match(TU, typedefDecl(hasName(\"X\")));\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n  ASSERT_EQ(ToD->getAttrs().size(), 1U);\n  auto *ToAttr = dyn_cast<AnnotateAttr>(ToD->getAttrs()[0]);\n  ASSERT_TRUE(ToAttr);\n  EXPECT_EQ(ToAttr->getAnnotation(), \"A\");\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclWhenPreviousDeclHasNoDescribedTemplateSet) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n\n      namespace std {\n        template<typename T>\n        class basic_stringbuf;\n      }\n      namespace std {\n        class char_traits;\n        template<typename T = char_traits>\n        class basic_stringbuf;\n      }\n      namespace std {\n        template<typename T>\n        class basic_stringbuf {};\n      }\n\n      )\",\n      Lang_CXX11);\n\n  auto *From1 = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU,\n      classTemplateDecl(hasName(\"basic_stringbuf\"), unless(isImplicit())));\n  auto *To1 = cast_or_null<ClassTemplateDecl>(Import(From1, Lang_CXX11));\n  EXPECT_TRUE(To1);\n\n  auto *From2 = LastDeclMatcher<ClassTemplateDecl>().match(\n      FromTU,\n      classTemplateDecl(hasName(\"basic_stringbuf\"), unless(isImplicit())));\n  auto *To2 = cast_or_null<ClassTemplateDecl>(Import(From2, Lang_CXX11));\n  EXPECT_TRUE(To2);\n}\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ASTImporterLookupTableTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportPath,\n                        ::testing::Values(std::vector<std::string>()), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportExpr,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFixedPointExpr,\n                        ExtendWithOptions(DefaultTestArrayForRunOptions,\n                                          std::vector<std::string>{\n                                              \"-ffixed-point\"}), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportType,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportDecl,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ASTImporterOptionSpecificTestBase,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ErrorHandlingTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, RedirectingImporterTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFunctions,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportAutoFunctions,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFunctionTemplates,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFriendFunctionTemplates,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportClasses,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFriendFunctions,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFriendClasses,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests,\n                        ImportFunctionTemplateSpecializations,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportImplicitMethods,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportVariables,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, LLDBLookupTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportSourceLocations,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportWithExternalSource,\n                        DefaultTestValuesForRunOptions, );\n\n} // end namespace ast_matchers\n} // end namespace clang\n"}}, "reports": [{"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 41}, "message": "default constructor 'CanonicalRedeclChain_ShouldBeConsequentWithMatchers_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ad3e3f49ed4c0c23feb8699b568e3ec6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 51}, "message": "default constructor 'CanonicalRedeclChain_ShouldBeConsequentWithMatchers2_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "221daf2104b14149a4a524a819f1cc4d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 65}, "message": "default constructor 'CanonicalRedeclChain_ShouldBeSameForAllDeclInTheChain_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "54eb97ac37cb1679d4fe0014d6141ec9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 103}, "message": "default constructor 'RedirectingImporterTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c3972f1229b3cee628523ecf86c5c264", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 116}, "message": "default constructor 'RedirectingImporterTest_InterceptImport_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "436b2687bdf2c27b3bb0a36ee38c5040", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 134}, "message": "default constructor 'RedirectingImporterTest_InterceptIndirectImport_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f86e86c842d639ebc10b2055bfada306", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 152}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 152}, "message": "default constructor 'ImportPath' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2f076b378c96a03fd891bd00e9ab0ce2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 161}, "message": "default constructor 'ImportPath_Push_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "33a4201c1c2f946cfd7f776da2d950c6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 167}, "message": "default constructor 'ImportPath_SmallCycle_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9040c525d9419346846e44f9cad1bc93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 178}, "message": "default constructor 'ImportPath_GetSmallCycle_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "d8174d923a2d4d9488e305f07294677d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 193}, "message": "default constructor 'ImportPath_GetCycle_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5432930739ddeba00982ffdc5e9cd6b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 212}, "message": "default constructor 'ImportPath_CycleAfterCycle_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e1041c9015ffa7f06e78f18396e8bc85", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 249}, "message": "default constructor 'ImportExpr_ImportStringLiteral_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "794e89a85607cbff5d177136736aeb63", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 265}, "message": "default constructor 'ImportExpr_ImportChooseExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "7b2ba494cdb56c6e9e2bb2515b48fd3a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 275}, "message": "default constructor 'ImportExpr_ImportGNUNullExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "be8f122f1054b7812ddfad951fe791ec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 282}, "message": "default constructor 'ImportExpr_ImportGenericSelectionExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "acc47d6265a726872b361b14e07e8e39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 291}, "message": "default constructor 'ImportExpr_ImportCXXNullPtrLiteralExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9af5642be83c696468b84b702d788bca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 300}, "message": "default constructor 'ImportExpr_ImportFloatinglLiteralExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "641bac40d79418e3b434229ed53369d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 312}, "message": "default constructor 'ImportFixedPointExpr_ImportFixedPointerLiteralExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ca7de03362053205e92b9c7e32aaa38b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 320}, "message": "default constructor 'ImportExpr_ImportImaginaryLiteralExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "eacd342064c2b2d636baa2900497ea65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 328}, "message": "default constructor 'ImportExpr_ImportCompoundLiteralExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "973c1333523041121886f555428f99fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 344}, "message": "default constructor 'ImportExpr_ImportCXXThisExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "56d6297688164ba6a06128a9e2809c58", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 352}, "message": "default constructor 'ImportExpr_ImportAtomicExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9f3fc383d80f8c073f40a09a29edce41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 363}, "message": "default constructor 'ImportExpr_ImportLabelDeclAndAddrLabelExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "da47373a0e7e0869ea524762390eefcb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 379}, "message": "default constructor 'ImportExpr_ImportParenListExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5bea1454f049b1a5727f5e242b3ab533", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 396}, "message": "default constructor 'ImportExpr_ImportSwitch_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c265e2cda0b1f2f65c5c169dfd0ede12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 404}, "message": "default constructor 'ImportExpr_ImportStmtExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b44dbeca13c0c6cbf8ba0a17457e9df6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 419}, "message": "default constructor 'ImportExpr_ImportConditionalOperator_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2a3d56669848a4c2f41affb5a0e5f9ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 430}, "message": "default constructor 'ImportExpr_ImportBinaryConditionalOperator_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4b8c3bf88fecb5bf47351539fd4f14a8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 448}, "message": "default constructor 'ImportExpr_ImportDesignatedInitExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ccbc9e037ed1c4ab7ccebe33c4bb2bb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 468}, "message": "default constructor 'ImportExpr_ImportPredefinedExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a1c620fe45a1a0025caa0ba91b7849ed", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 478}, "message": "default constructor 'ImportExpr_ImportInitListExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "64bd4e712ca243741dd07cc09a2dce2a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 499}, "message": "default constructor 'ImportExpr_ImportVAArgExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b86dc12799efec778b1513cb893101d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 508}, "message": "default constructor 'ImportExpr_CXXTemporaryObjectExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "21cb2577313ff6d0ee5443645943bbec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 520}, "message": "default constructor 'ImportType_ImportAtomicType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "df6c41972580e26fd9a77447136ddb93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 528}, "message": "default constructor 'ImportDecl_ImportFunctionTemplateDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "eb3bd80eb152780483296f1c7d09ee0f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 534}, "message": "default constructor 'ImportExpr_ImportCXXDependentScopeMemberExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "603c300c9800f7d7dc69eb898a21084e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 556}, "message": "default constructor 'ImportType_ImportTypeAliasTemplate_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "00be19924c223845100b6746a584a108", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 573}, "message": "default constructor 'ImportDecl_ImportVarTemplate_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6446f695d548fa11dff5f23115f35149", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 586}, "message": "default constructor 'ImportType_ImportPackExpansion_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b28ae6328f3a9ac85fb4559d678cdba6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 603}, "message": "default constructor 'ImportType_ImportDependentTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9e55bc8143337084a90e3cb18e879352", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 619}, "message": "default constructor 'ImportExpr_ImportSizeOfPackExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "41f65cd316cbd3dba7a78d9aae746351", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 651}, "message": "default constructor 'ImportExpr_ImportCXXFoldExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1f7558e28a84f418b6b91206066ac024", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 683}, "message": "default constructor 'ImportExpr_ImportTypeTraitExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "dc0dc5d411453e54ae1074d4209cf036", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 695}, "message": "default constructor 'ImportExpr_ImportCXXTypeidExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1d05510fe18ef8ec87d8ea246ef8caa1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 713}, "message": "default constructor 'ImportExpr_ImportTypeTraitExprValDep_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9645227243345dd57f4beb549f0d2209", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 726}, "message": "default constructor 'ImportDecl_ImportRecordDeclInFunc_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "43aed797295c28b2c435d941f1304600", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 738}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportRecordTypeInFunc_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "d159aa3aa5eb4072cde67c603755e01b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 753}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportRecordDeclInFuncParams_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "7865c2a9d6db4b67083143bba294caa1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 765}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportRecordDeclInFuncFromMacro_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6a1c62d9707114377b332ee8d0674387", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 780}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportRecordDeclInFuncParamsFromMacro_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "630c3c544e590b3b4638f6bfba840790", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 797}, "message": "default constructor 'ImportExpr_ImportCXXPseudoDestructorExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "91f62044888f08bc5074266db91ba4e7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 809}, "message": "default constructor 'ImportDecl_ImportUsingDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1e8b1de22d7a33a2f635ed855d6b55cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 830}, "message": "default constructor 'ImportDecl_ImportUsingShadowDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c8e0b8cdc58e9aa4de9348a11404a95f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 838}, "message": "default constructor 'ImportExpr_ImportUnresolvedLookupExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a6b5d3db1b72f73d29ee3de4bcac875a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 850}, "message": "default constructor 'ImportExpr_ImportCXXUnresolvedConstructExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b64bab3cbd82a0f7c3613db3e7d3909f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 875}, "message": "default constructor 'ImportDecl_ImportTemplatedDeclForTemplate_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8a8509bf1b74fc661b728d964dd7997b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 889}, "message": "default constructor 'ImportDecl_ImportClassTemplatePartialSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f141e3edb9ab12fd7e426dc08da15121", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 903}, "message": "default constructor 'ImportExpr_CXXOperatorCallExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ce5a0331fad9751b7f89a0c5ac869774", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 913}, "message": "default constructor 'ImportExpr_DependentSizedArrayType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b425b6e075ce38c55f3013808ea0b8d6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 923}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TemplateTypeParmDeclNoDefaultArg_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "140a00103c3796007d97fafbe0a66141", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 931}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TemplateTypeParmDeclDefaultArg_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ada92bfbe12fbeb124372605fef400d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 942}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportBeginLocOfDeclRefExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2fe414b72c9b90440862cd0b494b2ca9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 963}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TemplateTemplateParmDeclNoDefaultArg_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "52056a78959d8c2116a76dda78de744e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 975}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TemplateTemplateParmDeclDefaultArg_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6c1824d00dbd402b76352732afec8c94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 996}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_NonTypeTemplateParmDeclNoDefaultArg_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9664b5476de39a98184bdd0ee35c6e17", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1004}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_NonTypeTemplateParmDeclDefaultArg_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "bedc09b2a8237ff0bf8bc7d02f4b32da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1017}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfTemplatedDeclOfClassTemplateDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "d61bfb52079b9469ba55dc5eddcdc88c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1031}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfTemplatedDeclOfFunctionTemplateDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9debe6735c75aec5c756ee311bd3736c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1045}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfTemplatedDeclShouldImportTheClassTemplateDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "458a96ede3617711b198a4be1a9d3618", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1061}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfTemplatedDeclShouldImportTheFunctionTemplateDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "483634d3c57f2d1d1885485eb3495bc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1077}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportCorrectTemplatedDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "91a543968f5b4da96fe254b0c74e321a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1108}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportChooseExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "d106e6c0f591d2903361a9dd7862f4f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1131}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportGenericSelectionExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "7445273961f27eb005e6ea68de179386", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1161}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportFunctionWithBackReferringParameter_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8667290d812665fd4a6ad19626635909", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1189}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TUshouldNotContainTemplatedDeclOfFunctionTemplates_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "203e3b5c32520c02220172b29fdba66d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1215}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TUshouldNotContainTemplatedDeclOfClassTemplates_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5ea172d397da3d38048813961b0c9ebe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1241}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TUshouldNotContainTemplatedDeclOfTypeAlias_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b3f2f03ee89e90891eddf1250c0cac9e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1269}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TUshouldNotContainClassTemplateSpecializationOfImplicitInstantiation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "3d2b85e60f29c402ac3fae00ddfcc269", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1314}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TUshouldContainClassTemplateSpecializationOfExplicitInstantiation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "aef32ad278685b1e7166ee2919723ec9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1341}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_CXXRecordDeclFieldsShouldBeInCorrectOrder_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f3c0ca1df3eb6e432620e6f47c77681d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1354}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_CXXRecordDeclFieldOrderShouldNotDependOnImportOrder_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c089c8535977b36747639cc051ec3c69", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1376}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_CXXRecordDeclFieldAndIndirectFieldOrder_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "190871a670954a46a4f53842f5a13e37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1401}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ShouldImportImplicitCXXRecordDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ee02f96b3cdd3d2b4cae63e71f973b68", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1417}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ShouldImportImplicitCXXRecordDeclOfClassTemplate_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f14f807c22e8a6f05b3091faa24d50d3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1435}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ShouldImportImplicitCXXRecordDeclOfClassTemplateSpecializationDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c66c977813b1703d747f0eae2a1cf8f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1456}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_IDNSOrdinary_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e59955754859200f1a92a103fa8f997f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1468}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_IDNSOfNonmemberOperator_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "787f4fd5264dff044fd95ac5a446ba09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1480}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ShouldImportMembersOfClassTemplateSpecializationDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8dce04d14f2c266fd6aa921872e4ca1d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1500}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDefinitionOfClassTemplateAfterFwdDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6af118544896080977afdbe696118bb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1534}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDefinitionOfClassTemplateIfThereIsAnExistingFwdDeclAndDefinition_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c568076454aad2f7c72ed49db86cb888", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1574}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDefinitionOfClassIfThereIsAnExistingFwdDeclAndDefinition_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5f0e5cdfaa2ef7ce868679c392ec1c5c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1617}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportSourceLocs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "75ef64006265b19ee9b1b5b8365b6d3c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1647}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportNestedMacro_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1615a2fb39cb303625fc05b1535d78db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1664}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDefinitionOfClassTemplateSpecIfThereIsAnExistingFwdDeclAndDefinition_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4d585bbce522f6ec672384a870e334ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1708}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ObjectsWithUnnamedStructType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "44d54ba82a741a2d6fe298bb7e47c109", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1732}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_AnonymousRecords_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "450ca24e4f4193a183242049ba9a1f21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1758}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_AnonymousRecordsReversed_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ef62a27dbadd063c6cb27ed926a44208", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1791}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDoesUpdateUsedFlag_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "0fcaee612bb6e992b0c6f748e0a81949", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1817}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDoesUpdateUsedFlag2_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b58aa0a25b3c5f17cf44c2fbe34fd80c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1835}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDoesUpdateUsedFlag3_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5b663603fd1d484ae50e39b2ace182a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1868}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ReimportWithUsedFlag_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "3baf0171e6c52ae33395af5204851992", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1887}, "message": "default constructor 'ImportFunctions_ImportPrototypeOfRecursiveFunction_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2df9479cc0fd8abd6ca7a01327549fe6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1905}, "message": "default constructor 'ImportFunctions_ImportDefinitionOfRecursiveFunction_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5479c083dd6986ae4f900465bb321171", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1923}, "message": "default constructor 'ImportFunctions_OverriddenMethodsShouldBeImported_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f41421c510a90b8887cbd06c119bf0f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1941}, "message": "default constructor 'ImportFunctions_VirtualFlagShouldBePreservedWhenImportingPrototype_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a8fe0697030c796326d41fe6bd7c1deb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1960}, "message": "default constructor 'ImportFunctions_ImportDefinitionIfThereIsAnExistingDefinitionAndFwdDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "fce172713435fd71035e5dcb6628854c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 1984}, "message": "default constructor 'ImportFunctions_ImportOverriddenMethodTwice_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "50780efe808decf66ffef8523fb2b0e5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2009}, "message": "default constructor 'ImportFunctions_ImportOverriddenMethodTwiceDefinitionFirst_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "d6a4ded83751191376ae360bc2e61a21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2050}, "message": "default constructor 'ImportFunctions_ImportOverriddenMethodTwiceOutOfClassDef_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9cf7eebbcb4d03f5327e2b004232c2b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2095}, "message": "default constructor 'ImportFunctions_ImportOverriddenMethodTwiceOutOfClassDefInSeparateCode_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "cc4d56edd424aeffef2c3fec46440ea5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2169}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportVariableChainInC_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a46857d63761bb63c7927e1c34228df2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2187}, "message": "default constructor 'ImportFunctions_ImportFromDifferentScopedAnonNamespace_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "80eb7923943f9c52ef8b15c026a743bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2206}, "message": "default constructor 'ImportFunctions_ImportFunctionFromUnnamedNamespace_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "eb8abd1308a6064e0ba05b0f4dc01a6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2229}, "message": "default constructor 'ImportFunctions_ImportImplicitFunctionsInLambda_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "fecb702dac58a0dc3a6891be511384bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2249}, "message": "default constructor 'ImportFunctions_CallExprOfMemberFunctionTemplateWithExplicitTemplateArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5a5ba0999c79ef0b1b9e86e4911e49ed", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2271}, "message": "default constructor 'ImportFunctions_DependentCallExprOfMemberFunctionTemplateWithExplicitTemplateArgs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "7715ee41410d0c5de75608caeb5c091d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2301}, "message": "default constructor 'ImportFunctionTemplates_ImportFunctionTemplateInRecordDeclTwice_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c8e8d9a7c01f15070459d4772849cb57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2320}, "message": "default constructor 'ImportFunctionTemplates_ImportFunctionTemplateWithDefInRecordDeclTwice_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "65e954215550fb91bb3c2df6efd4ea48", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2342}, "message": "default constructor 'ImportFunctionTemplates_ImportFunctionWhenThereIsAFunTemplateWithSameName_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1640521e3228b8734530165e67e9a39b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2358}, "message": "default constructor 'ImportFunctionTemplates_ImportConstructorWhenThereIsAFunTemplateWithSameName_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "0d1f2194e160db3d4fc7819983fb1c4d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2376}, "message": "default constructor 'ImportFunctionTemplates_ImportOperatorWhenThereIsAFunTemplateWithSameName_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5191465cc8844530c4eae47b19bc431f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2400}, "message": "default constructor 'ImportFriendFunctions_ImportFriendFunctionRedeclChainProto_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "439602d35ae27bdae1b9e67964e38ccc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2417}, "message": "default constructor 'ImportFriendFunctions_ImportFriendFunctionRedeclChainProto_OutOfClassProtoFirst_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1a3ae795809b54e951c547720c399dea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2435}, "message": "default constructor 'ImportFriendFunctions_ImportFriendFunctionRedeclChainDef_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e047a65f6f34cbe22204e2b51369c0c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2452}, "message": "default constructor 'ImportFriendFunctions_ImportFriendFunctionRedeclChainDef_OutOfClassDef_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a3082ec9b9de445e8a98caedb1dd8168", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2470}, "message": "default constructor 'ImportFriendFunctions_ImportFriendFunctionRedeclChainDefWithClass_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "bb9fcb2a806e6bb59419fb18fe066623", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2498}, "message": "default constructor 'ImportFriendFunctions_ImportFriendFunctionRedeclChainDefWithClass_ImportTheProto_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ef5c6f126d56f78e4d384ad9cf301bbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2527}, "message": "default constructor 'ImportFriendFunctions_ImportFriendFunctionFromMultipleTU_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "efe1f3efced62b16d6b165c80b419675", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2551}, "message": "default constructor 'ImportFriendFunctions_Lookup_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "222be1d031da2ac6bf5b891bf5609909", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2585}, "message": "default constructor 'ImportFriendFunctions_LookupWithProtoAfter_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9ed179ed73373bfcea771fab6222ffbf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2635}, "message": "default constructor 'ImportFriendFunctions_LookupWithProtoBefore_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1dbf0c313782dfeaa8fbe6b3a98553cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2678}, "message": "default constructor 'ImportFriendFunctions_ImportFriendChangesLookup_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2dd17aacf225d1a0446873372ea22f7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2722}, "message": "default constructor 'ImportFriendFunctions_ImportFriendList_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "43d2699639566cab920855510fb65bd5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2761}, "message": "default constructor 'ImportDecl_ImportEnumSequential_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ea577248b17712923924c8ae685edaf3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2800}, "message": "default constructor 'ImportDecl_ImportFieldOrder_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b947bf6868739a602fd34dd9d59b87c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2813}, "message": "default constructor 'ImportExpr_DependentScopeDeclRefExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6e8de06366e2b72a7aec307f3b140e70", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2840}, "message": "default constructor 'ImportExpr_DependentNameType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5f0505d16675f8b21d7e6911bfde03d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2850}, "message": "default constructor 'ImportExpr_UnresolvedMemberExpr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c616b81db21f8106f30ce7a8dc100fd6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2923}, "message": "default constructor 'ImportImplicitMethods_DefaultConstructor_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "56376aa00578ab4e00181c7e89e9a5f2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2927}, "message": "default constructor 'ImportImplicitMethods_CopyConstructor_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "66b63a0cdf2c51010bfe8dcedf376aa2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2931}, "message": "default constructor 'ImportImplicitMethods_MoveConstructor_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "33c4783e8b7b14b0c7ee023aa39d75a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2935}, "message": "default constructor 'ImportImplicitMethods_Destructor_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "db93e09971e1608a007c6ce99bd3b3cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2939}, "message": "default constructor 'ImportImplicitMethods_CopyAssignment_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8f6d22a74dd1bcfdf16dbe91d3e3f70c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2943}, "message": "default constructor 'ImportImplicitMethods_MoveAssignment_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9fba34d4999a6782b15070f3fda992d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2947}, "message": "default constructor 'ImportImplicitMethods_DoNotImportUserProvided_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1542a0b797384230d692a2e9b75ccc31", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2954}, "message": "default constructor 'ImportImplicitMethods_DoNotImportDefault_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "3b34af3df23c100f0221a0931f56cbdd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2961}, "message": "default constructor 'ImportImplicitMethods_DoNotImportDeleted_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "3eac8f48d4532e11d2a988dca9e9e1ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2968}, "message": "default constructor 'ImportImplicitMethods_DoNotImportOtherMethod_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "41dfc79a61c2bd9f3a1a5eadea092ec7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2975}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfEquivalentRecord_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6c84ddba4ba51c65dfaeea36773bafb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 2997}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfNonEquivalentRecord_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "593c5964a87aa924ad54318a5c3f2279", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3016}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfEquivalentField_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5810318714abca49f3ee72837a373b16", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3034}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfNonEquivalentField_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8838be4314995b86c393da9050efad0e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3053}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfEquivalentMethod_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "63ec5bda8baafac12e277ab32d334c2a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3073}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfNonEquivalentMethod_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a7c483176a0e9bdb4a958a810916ff71", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3094}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportUnnamedStructsWithRecursingField_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "832a96d913b042e17b4982c5e086aa13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3127}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportUnnamedFieldsInCorrectOrder_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b9a0df784a670bdd8e6d9d12f439f29c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3162}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_MergeFieldDeclsOfClassTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4dc8390333e49dcb2833e365554bd4ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3208}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_MergeFunctionOfClassTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e6fcf6aab734712f5ccd6822767b8a7d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3250}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_MergeTemplateSpecWithForwardDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ce799957d491a8b7025e9c625aff1c0e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3269}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ODRViolationOfClassTemplateSpecializationsShouldBeReported_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f6a63edf81a139afe1f91d5592ffaa38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3314}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_MergeCtorOfClassTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "eaeb77017cf898fa7cd7752e6689a5bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3356}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ClassTemplateFriendDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "37bf5f085687f6c0d6bbd4bf477e4b6b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3376}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ClassTemplatePartialSpecializationsShouldNotBeDuplicated_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ef001a0d28bac858c8aeac51344b880f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3403}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ClassTemplateSpecializationsShouldNotBeDuplicated_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "741e0eeb387e814b180af23b6d5c78a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3428}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ClassTemplateFullAndPartialSpecsShouldNotBeMixed_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1977086a0cdfb7acf49d329952f92409", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3461}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_InitListExprValueKindShouldBeImported_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "fd05f69d277e12a0659be1f0ae860f0b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3483}, "message": "default constructor 'ImportVariables_ImportOfOneDeclBringsInTheWholeChain_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e2e750cfdf775ade43be3f3a05936def", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3508}, "message": "default constructor 'ImportVariables_InitAndDefinitionAreInDifferentTUs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f6e5dd3c734e3218cf708acb49e4d391", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3539}, "message": "default constructor 'ImportVariables_InitAndDefinitionAreInTheFromContext_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1b2ba90e4494f3f623f9a00c99cd5f2a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3572}, "message": "default constructor 'ImportClasses_ImportDefinitionWhenProtoIsInNestedToContext_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4dbbd870a395f37d66794710ad89c805", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3590}, "message": "default constructor 'ImportClasses_ImportDefinitionWhenProtoIsInNestedToContextCXX_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "0245e3354f2cb23374604b75151738c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3608}, "message": "default constructor 'ImportClasses_ImportNestedPrototypeThenDefinition_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "873f5497f9e95fd1209bad5ba0a8051e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3634}, "message": "default constructor 'ImportFriendClasses_ImportOfFriendRecordDoesNotMergeDefinition_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "0247cf233ee95a0c89ad8376209a9ddf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3672}, "message": "default constructor 'ImportFriendClasses_ImportOfRecursiveFriendClass_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "eddb660746c624b37c8cc19a5efa9042", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3689}, "message": "default constructor 'ImportFriendClasses_UndeclaredFriendClassShouldNotBeVisible_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c0ccfa46695e08ac99d1f1a2ad23ca46", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3728}, "message": "default constructor 'ImportFriendClasses_ImportOfRecursiveFriendClassTemplate_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "d437a712736da3f6b5eb68acdb2dccdb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3753}, "message": "default constructor 'ImportFriendClasses_ProperPrevDeclForClassTemplateDecls_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "00b0bfca682fa0fda1aca4d73e401137", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3787}, "message": "default constructor 'ImportFriendClasses_TypeForDeclShouldBeSetInTemplated_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f02cc61880312307aeb51e5f818d75b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3815}, "message": "default constructor 'ImportFriendClasses_DeclsFromFriendsShouldBeInRedeclChains_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "211afdf497066242795b5fb6afc4b833", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3825}, "message": "default constructor 'ImportFriendClasses_ImportOfClassTemplateDefinitionShouldConnectToFwdFriend_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "38d4ef6ad1c44c8cc216431b93ac8c11", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3855}, "message": "default constructor 'ImportFriendClasses_ImportOfClassTemplateDefinitionAndFwdFriendShouldBeLinked_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8c449f153fde47195cfbdbbab60591fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3886}, "message": "default constructor 'ImportFriendClasses_ImportOfClassDefinitionAndFwdFriendShouldBeLinked_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "aa071c50e783c9d627f69242e3562b10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3914}, "message": "default constructor 'ImportFriendClasses_ImportOfRepeatedFriendType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ffe466d2dd2cbf161afe4f44fd1cc117", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3939}, "message": "default constructor 'ImportFriendClasses_ImportOfRepeatedFriendDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "415f965ce786e83e80cf2bf928731cda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3964}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_FriendFunInClassTemplate_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4224a8d5aaf64a60e1c54383f1ab5c6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 3984}, "message": "default constructor 'DeclContextTest_removeDeclOfClassTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ff2e3ee745f8e77b27836fdf7c0a285a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4011}, "message": "default constructor 'DeclContextTest_removeDeclShouldNotFailEvenIfWeHaveExternalVisibleStorage_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "be4d240171b88c2c7bc2a0e7af67c929", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4048}, "message": "default constructor 'ImportFunctionTemplateSpecializations_TUshouldNotContainFunctionTemplateImplicitInstantiation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "79d0f9c2af9b7fa3aad0ab88388e3ca1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4072}, "message": "default constructor 'ImportFunctionTemplateSpecializations_TUshouldNotContainFunctionTemplateExplicitInstantiation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "96b1deee3608877025311b00b99d145d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4095}, "message": "default constructor 'ImportFunctionTemplateSpecializations_TUshouldContainFunctionTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "3913287d51e5711b9762a610b17beb75", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4119}, "message": "default constructor 'ImportFunctionTemplateSpecializations_FunctionTemplateSpecializationRedeclChain_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "329e80ff8c652e4dd189e91a25ca8262", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4160}, "message": "default constructor 'ImportFunctionTemplateSpecializations_MatchNumberOfFunctionTemplateSpecializations_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8bd62daf481bf3dc196cce9f4a3d4836", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4183}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportShouldNotReportFalseODRErrorWhenRecordIsBeingDefined_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "09628667a81a74b2efc1c5f87241dfdd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4222}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportingTypedefShouldImportTheCompleteType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "426604e07fcb05778d6638d4c988b7de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4255}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportTemplateParameterLists_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "aab72b1d01834b1522180f58e4a826a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4275}, "message": "default constructor 'ASTImporterLookupTableTest_OneDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9c9e3a8ce30cbb61091f3f45ebfe20a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4293}, "message": "default constructor 'ASTImporterLookupTableTest_FriendWhichIsnotFoundByNormalLookupShouldBeFoundByImporterSpecificLookup_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "fc29c3e40d8da9eaed805528eab517cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4334}, "message": "default constructor 'ASTImporterLookupTableTest_FwdDeclStructShouldBeFoundByImporterSpecificLookup_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2e6425d7363afda6879cb1c25096c801", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4370}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsNamesInDifferentDC_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e1ce7278c0a650ee8152500948a30453", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4400}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsOverloadedNames_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "24dda65a680b388b62a0b8d9cb82e006", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4419}, "message": "default constructor 'ASTImporterLookupTableTest_DifferentOperatorsShouldHaveDifferentResultSet_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "025c0d723e984063d623b63fc2b6a802", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4447}, "message": "default constructor 'ASTImporterLookupTableTest_LookupDeclNamesFromDifferentTUs_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "efdfa0e683fec3d08e56150ab1fb2429", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4479}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsFwdFriendClassDeclWithElaboratedType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "afcbb3db8f86b28e425c1d1448254ded", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4504}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsFwdFriendClassDeclWithUnelaboratedType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e7edb3513b9a50f41902fb24201e170b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4529}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsFriendClassDeclWithTypeAliasDoesNotAssert_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "460557039434f877b9e8baefb9358344", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4550}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsFwdFriendClassTemplateDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "579d0a202aa432d2b72157d111251b5e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4567}, "message": "default constructor 'ASTImporterLookupTableTest_DependentFriendClass_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b218cb8aeee1f054d7e4991441eafc64", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4590}, "message": "default constructor 'ASTImporterLookupTableTest_FriendClassTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6481d7baa6643167e55004f145ca9260", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4613}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsFwdFriendFunctionDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "172d3aae74c4142e55955c1aa59d85da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4629}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsDeclsInClassTemplateSpecialization_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "86b29108578a81123b30660719e0b383", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4678}, "message": "default constructor 'ASTImporterLookupTableTest_LookupFindsFwdFriendFunctionTemplateDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5016bea153e2d74b0ad541e0da142952", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4695}, "message": "default constructor 'ASTImporterLookupTableTest_MultipleBefriendingClasses_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "d1827ef351a2b01728bbe32646b82853", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4724}, "message": "default constructor 'ASTImporterLookupTableTest_EnumConstantDecl_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f33e5dfd9118ad5ab8499b4bf617b891", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4763}, "message": "default constructor 'ASTImporterLookupTableTest_LookupSearchesInTheWholeRedeclChain_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "29bb3442df148bf2282455ddd8e68d82", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4784}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_RedeclChainShouldBeCorrectAmongstNamespaces_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5a6053366fd44e3b3c359469eee7e759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4825}, "message": "default constructor 'ImportFriendFunctionTemplates_LookupShouldFindPreviousFriend_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "73ed3edafe2a57625b5062a506bfeb75", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 4854}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 4854}, "message": "default constructor 'ErrorHandlingTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "01eae48c7fa11abf356b4ccebeaa48be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4871}, "message": "default constructor 'ErrorHandlingTest_ErrorHappensBeforeCreatingANewNode_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c1b3e75cd52afcf3f6fedf683f5eee72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4907}, "message": "default constructor 'ErrorHandlingTest_ErrorHappensAfterCreatingTheNodeButBeforeLinkingThatToTheAST_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "06fb15760f77dfdb2bd0e092676398f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4932}, "message": "default constructor 'ErrorHandlingTest_ErrorHappensAfterNodeIsCreatedAndLinked_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "dd1d6c7b3ec092585f35fb888bd33dab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 4966}, "message": "default constructor 'ErrorHandlingTest_ErrorIsPropagatedFromMemberToClass_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4eb71a9bba27e62efe512a02265b8d99", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5011}, "message": "default constructor 'ErrorHandlingTest_ErrorPropagatesThroughImportCycles_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b93d3e9749d8576fa6c8cfde3e6b6ed1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5091}, "message": "default constructor 'ErrorHandlingTest_ErrorIsNotPropagatedFromMemberToNamespace_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "dc751575f468a25daf72744f14b4b162", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5132}, "message": "default constructor 'ErrorHandlingTest_ImportedDeclWithErrorShouldFailTheImportOfDeclWhichMapToIt_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b1f5cbf8bb8df9814e084e88df87f4b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5202}, "message": "default constructor 'ErrorHandlingTest_ImportOfOverriddenMethods_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e38a319729dd615ba0b2ab40d42adfcb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5246}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_LambdaInFunctionBody_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "542ff06ffc3d11b52d225c395a92cfac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5266}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_LambdaInFunctionParam_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "3dc94df030835d72813d397ea464a601", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5285}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_LambdaInGlobalScope_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "30b5074b3dec49f96cd403f6ef9df4c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5301}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportExistingFriendClassTemplateDef_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e4bc63c18fc398602564679a3b6c765b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 5346}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 5346}, "message": "default constructor 'LLDBLookupTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ccdfc3049a575246bcb5f0877c457362", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5359}, "message": "default constructor 'LLDBLookupTest_ImporterShouldFindInTransparentContext_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9be9271789fd358668240ddb37a0333a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5392}, "message": "default constructor 'SVEBuiltins_ImportTypes_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9fad3143b968c0b83afeee01d077b779", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5425}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfDefaultImplicitFunctions_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "483ea6c4965bcd3258c02017c1fc607a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5451}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfExplicitlyDefaultedOrDeleted_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "80faebf2f18ccebc198b36e7c686a89b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5483}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_LambdasAreDifferentiated_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "59a0dbdcc116f2f6d2409bf352336c19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5504}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_LambdasInFunctionParamsAreDifferentiated_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b6e37d5ae94011676787afd0ddb4f485", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5524}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_LambdasInFunctionParamsAreDifferentiatedWhenMacroIsUsed_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5ad309678ff1d86231a6b14ac262bf1e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5547}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportAssignedLambda_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "754803f81e39eb96f194e7c1faab697b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5570}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportDefaultConstructibleLambdas_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "eed5aed1b8158818ac63c0132496f546", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5594}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImplicitlyDeclareSelf_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "7a0c6e4a67ee1359795eb4b3ac1576ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5620}, "message": "default constructor 'ImportAutoFunctions_ReturnWithTypedefDeclaredInside_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "8655840016b19e6d7a8f4310c8f25de7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5655}, "message": "default constructor 'ImportAutoFunctions_ReturnWithStructDeclaredInside_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "caf04a59ef6879d4f0390036854e259f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5672}, "message": "default constructor 'ImportAutoFunctions_ReturnWithStructDeclaredInside2_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a5665babb3a61a8e2cc66d80740e5434", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5690}, "message": "default constructor 'ImportAutoFunctions_ReturnWithTypedefToStructDeclaredInside_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "937b0f56ed1266673af4de5f743c2750", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5708}, "message": "default constructor 'ImportAutoFunctions_ReturnWithStructDeclaredNestedInside_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "79af8f8f2406168e4e83545463af2095", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5725}, "message": "default constructor 'ImportAutoFunctions_ReturnWithInternalLambdaType_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a7440a520d1e4731f8c478cfd3972d2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5745}, "message": "default constructor 'ImportAutoFunctions_ReturnWithTypeInIf_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "7f72b793911b71625d6e64204078e5af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5764}, "message": "default constructor 'ImportAutoFunctions_ReturnWithTypeInFor_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "16b36b80c683c59c566c9980062a0f47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5781}, "message": "default constructor 'ImportAutoFunctions_ReturnWithTypeInSwitch_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "00c733fe7585c85216be15424ac4ecca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5802}, "message": "default constructor 'ImportSourceLocations_PreserveFileIDTreeStructure_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4649e04bff7f8cfe92919de12dc110aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5842}, "message": "default constructor 'ImportSourceLocations_NormalFileBuffer_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b0f3b8b51b61aa81e31b3bfd561bf961", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5864}, "message": "default constructor 'ImportSourceLocations_OverwrittenFileBuffer_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "baf4098f30292978212b4e60801d1639", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5898}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportExprOfAlignmentAttr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "717392c74470feb5fd27436093393fe3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5933}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportFormatAttr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "297a0843ca1b6d306e4b86bbd3b2ac3d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 5970}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 5970}, "message": "default constructor 'ImportWithExternalSource' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "fba594eeb21b651d95e053c261c09521", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 5997}, "message": "default constructor 'ImportWithExternalSource_CompleteRecordBeforeImporting_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "7461dd61f857fb49204e0c393883d85d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6030}, "message": "default constructor 'ImportFunctions_CTADImplicit_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "31c56f844488476b38620c856ad418f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6050}, "message": "default constructor 'ImportFunctions_CTADUserDefinedExplicit_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ec8f96545ef14e714834f6db3839bec4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6071}, "message": "default constructor 'ImportFunctions_CTADWithLocalTypedef_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f058543e1c77692072fb8cc3c93e45c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6094}, "message": "default constructor 'CTAD_DeductionGuideShouldReferToANonLocalTypedef_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a66bbc0a72886e2bd7209394e0e3ab30", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6114}, "message": "default constructor 'CTAD_DeductionGuideShouldReferToANonLocalTypedefInParamPtr_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f3c2667137412b30a117994e666384e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6137}, "message": "default constructor 'CTAD_DeductionGuideShouldCopyALocalTypedef_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "e3ace86270b101c004e346ab2bc63d1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6158}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_TypedefWithAttribute_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "1931365f4fd5953df121cbb14b49a922", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 1384}, "message": "expanded from macro 'TEST_P'"}, {"location": {"col": 3, "file": 48, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 46, "line": 6176}, "message": "default constructor 'ASTImporterOptionSpecificTestBase_ImportOfTemplatedDeclWhenPreviousDeclHasNoDescribedTemplateSet_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "bfcc7c3dadaea9bb257560f365f7811f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
