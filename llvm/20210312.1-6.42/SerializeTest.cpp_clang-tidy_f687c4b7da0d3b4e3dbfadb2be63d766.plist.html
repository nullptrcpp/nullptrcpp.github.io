<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "content": "///===-- Representation.h - ClangDoc Representation -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the internal representations of different declaration\n// types for the clang-doc tool.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_DOC_REPRESENTATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANG_DOC_REPRESENTATION_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Tooling/StandaloneExecution.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include <array>\n#include <string>\n\nnamespace clang {\nnamespace doc {\n\n// SHA1'd hash of a USR.\nusing SymbolID = std::array<uint8_t, 20>;\n\nstruct Info;\nstruct FunctionInfo;\nstruct EnumInfo;\nstruct BaseRecordInfo;\n\nenum class InfoType {\n  IT_default,\n  IT_namespace,\n  IT_record,\n  IT_function,\n  IT_enum\n};\n\n// A representation of a parsed comment.\nstruct CommentInfo {\n  CommentInfo() = default;\n  CommentInfo(CommentInfo &Other) = delete;\n  CommentInfo(CommentInfo &&Other) = default;\n  CommentInfo &operator=(CommentInfo &&Other) = default;\n\n  bool operator==(const CommentInfo &Other) const {\n    auto FirstCI = std::tie(Kind, Text, Name, Direction, ParamName, CloseName,\n                            SelfClosing, Explicit, AttrKeys, AttrValues, Args);\n    auto SecondCI =\n        std::tie(Other.Kind, Other.Text, Other.Name, Other.Direction,\n                 Other.ParamName, Other.CloseName, Other.SelfClosing,\n                 Other.Explicit, Other.AttrKeys, Other.AttrValues, Other.Args);\n\n    if (FirstCI != SecondCI || Children.size() != Other.Children.size())\n      return false;\n\n    return std::equal(Children.begin(), Children.end(), Other.Children.begin(),\n                      llvm::deref<std::equal_to<>>{});\n  }\n\n  // This operator is used to sort a vector of CommentInfos.\n  // No specific order (attributes more important than others) is required. Any\n  // sort is enough, the order is only needed to call std::unique after sorting\n  // the vector.\n  bool operator<(const CommentInfo &Other) const {\n    auto FirstCI = std::tie(Kind, Text, Name, Direction, ParamName, CloseName,\n                            SelfClosing, Explicit, AttrKeys, AttrValues, Args);\n    auto SecondCI =\n        std::tie(Other.Kind, Other.Text, Other.Name, Other.Direction,\n                 Other.ParamName, Other.CloseName, Other.SelfClosing,\n                 Other.Explicit, Other.AttrKeys, Other.AttrValues, Other.Args);\n\n    if (FirstCI < SecondCI)\n      return true;\n\n    if (FirstCI == SecondCI) {\n      return std::lexicographical_compare(\n          Children.begin(), Children.end(), Other.Children.begin(),\n          Other.Children.end(), llvm::deref<std::less<>>());\n    }\n\n    return false;\n  }\n\n  SmallString<16>\n      Kind; // Kind of comment (FullComment, ParagraphComment, TextComment,\n            // InlineCommandComment, HTMLStartTagComment, HTMLEndTagComment,\n            // BlockCommandComment, ParamCommandComment,\n            // TParamCommandComment, VerbatimBlockComment,\n            // VerbatimBlockLineComment, VerbatimLineComment).\n  SmallString<64> Text;      // Text of the comment.\n  SmallString<16> Name;      // Name of the comment (for Verbatim and HTML).\n  SmallString<8> Direction;  // Parameter direction (for (T)ParamCommand).\n  SmallString<16> ParamName; // Parameter name (for (T)ParamCommand).\n  SmallString<16> CloseName; // Closing tag name (for VerbatimBlock).\n  bool SelfClosing = false;  // Indicates if tag is self-closing (for HTML).\n  bool Explicit = false; // Indicates if the direction of a param is explicit\n                         // (for (T)ParamCommand).\n  llvm::SmallVector<SmallString<16>, 4>\n      AttrKeys; // List of attribute keys (for HTML).\n  llvm::SmallVector<SmallString<16>, 4>\n      AttrValues; // List of attribute values for each key (for HTML).\n  llvm::SmallVector<SmallString<16>, 4>\n      Args; // List of arguments to commands (for InlineCommand).\n  std::vector<std::unique_ptr<CommentInfo>>\n      Children; // List of child comments for this CommentInfo.\n};\n\nstruct Reference {\n  Reference() = default;\n  Reference(llvm::StringRef Name) : Name(Name) {}\n  // An empty path means the info is in the global namespace because the path is\n  // a composite of the parent namespaces.\n  Reference(llvm::StringRef Name, StringRef Path)\n      : Name(Name), Path(Path), IsInGlobalNamespace(Path.empty()) {}\n  Reference(SymbolID USR, StringRef Name, InfoType IT)\n      : USR(USR), Name(Name), RefType(IT) {}\n  // An empty path means the info is in the global namespace because the path is\n  // a composite of the parent namespaces.\n  Reference(SymbolID USR, StringRef Name, InfoType IT, StringRef Path)\n      : USR(USR), Name(Name), RefType(IT), Path(Path),\n        IsInGlobalNamespace(Path.empty()) {}\n\n  bool operator==(const Reference &Other) const {\n    return std::tie(USR, Name, RefType) ==\n           std::tie(Other.USR, Other.Name, Other.RefType);\n  }\n\n  bool mergeable(const Reference &Other);\n  void merge(Reference &&I);\n\n  /// Returns the path for this Reference relative to CurrentPath.\n  llvm::SmallString<64> getRelativeFilePath(const StringRef &CurrentPath) const;\n\n  /// Returns the basename that should be used for this Reference.\n  llvm::SmallString<16> getFileBaseName() const;\n\n  SymbolID USR = SymbolID(); // Unique identifier for referenced decl\n  SmallString<16> Name;      // Name of type (possibly unresolved).\n  InfoType RefType = InfoType::IT_default; // Indicates the type of this\n                                           // Reference (namespace, record,\n                                           // function, enum, default).\n  // Path of directory where the clang-doc generated file will be saved\n  // (possibly unresolved)\n  llvm::SmallString<128> Path;\n  // Indicates if the info's parent is the global namespace, or if the info is\n  // the global namespace\n  bool IsInGlobalNamespace = false;\n};\n\n// A base struct for TypeInfos\nstruct TypeInfo {\n  TypeInfo() = default;\n  TypeInfo(SymbolID Type, StringRef Field, InfoType IT)\n      : Type(Type, Field, IT) {}\n  TypeInfo(SymbolID Type, StringRef Field, InfoType IT, StringRef Path)\n      : Type(Type, Field, IT, Path) {}\n  TypeInfo(llvm::StringRef RefName) : Type(RefName) {}\n  TypeInfo(llvm::StringRef RefName, StringRef Path) : Type(RefName, Path) {}\n\n  bool operator==(const TypeInfo &Other) const { return Type == Other.Type; }\n\n  Reference Type; // Referenced type in this info.\n};\n\n// Info for field types.\nstruct FieldTypeInfo : public TypeInfo {\n  FieldTypeInfo() = default;\n  FieldTypeInfo(SymbolID Type, StringRef Field, InfoType IT, StringRef Path,\n                llvm::StringRef Name)\n      : TypeInfo(Type, Field, IT, Path), Name(Name) {}\n  FieldTypeInfo(llvm::StringRef RefName, llvm::StringRef Name)\n      : TypeInfo(RefName), Name(Name) {}\n  FieldTypeInfo(llvm::StringRef RefName, StringRef Path, llvm::StringRef Name)\n      : TypeInfo(RefName, Path), Name(Name) {}\n\n  bool operator==(const FieldTypeInfo &Other) const {\n    return std::tie(Type, Name) == std::tie(Other.Type, Other.Name);\n  }\n\n  SmallString<16> Name; // Name associated with this info.\n};\n\n// Info for member types.\nstruct MemberTypeInfo : public FieldTypeInfo {\n  MemberTypeInfo() = default;\n  MemberTypeInfo(SymbolID Type, StringRef Field, InfoType IT, StringRef Path,\n                 llvm::StringRef Name, AccessSpecifier Access)\n      : FieldTypeInfo(Type, Field, IT, Path, Name), Access(Access) {}\n  MemberTypeInfo(llvm::StringRef RefName, llvm::StringRef Name,\n                 AccessSpecifier Access)\n      : FieldTypeInfo(RefName, Name), Access(Access) {}\n  MemberTypeInfo(llvm::StringRef RefName, StringRef Path, llvm::StringRef Name,\n                 AccessSpecifier Access)\n      : FieldTypeInfo(RefName, Path, Name), Access(Access) {}\n\n  bool operator==(const MemberTypeInfo &Other) const {\n    return std::tie(Type, Name, Access) ==\n           std::tie(Other.Type, Other.Name, Other.Access);\n  }\n\n  // Access level associated with this info (public, protected, private, none).\n  // AS_public is set as default because the bitcode writer requires the enum\n  // with value 0 to be used as the default.\n  // (AS_public = 0, AS_protected = 1, AS_private = 2, AS_none = 3)\n  AccessSpecifier Access = AccessSpecifier::AS_public;\n};\n\nstruct Location {\n  Location() = default;\n  Location(int LineNumber, SmallString<16> Filename)\n      : LineNumber(LineNumber), Filename(std::move(Filename)) {}\n  Location(int LineNumber, SmallString<16> Filename, bool IsFileInRootDir)\n      : LineNumber(LineNumber), Filename(std::move(Filename)),\n        IsFileInRootDir(IsFileInRootDir) {}\n\n  bool operator==(const Location &Other) const {\n    return std::tie(LineNumber, Filename) ==\n           std::tie(Other.LineNumber, Other.Filename);\n  }\n\n  // This operator is used to sort a vector of Locations.\n  // No specific order (attributes more important than others) is required. Any\n  // sort is enough, the order is only needed to call std::unique after sorting\n  // the vector.\n  bool operator<(const Location &Other) const {\n    return std::tie(LineNumber, Filename) <\n           std::tie(Other.LineNumber, Other.Filename);\n  }\n\n  int LineNumber;               // Line number of this Location.\n  SmallString<32> Filename;     // File for this Location.\n  bool IsFileInRootDir = false; // Indicates if file is inside root directory\n};\n\n/// A base struct for Infos.\nstruct Info {\n  Info() = default;\n  Info(InfoType IT) : IT(IT) {}\n  Info(InfoType IT, SymbolID USR) : USR(USR), IT(IT) {}\n  Info(InfoType IT, SymbolID USR, StringRef Name)\n      : USR(USR), IT(IT), Name(Name) {}\n  Info(InfoType IT, SymbolID USR, StringRef Name, StringRef Path)\n      : USR(USR), IT(IT), Name(Name), Path(Path) {}\n  Info(const Info &Other) = delete;\n  Info(Info &&Other) = default;\n\n  virtual ~Info() = default;\n\n  SymbolID USR =\n      SymbolID(); // Unique identifier for the decl described by this Info.\n  const InfoType IT = InfoType::IT_default; // InfoType of this particular Info.\n  SmallString<16> Name;                     // Unqualified name of the decl.\n  llvm::SmallVector<Reference, 4>\n      Namespace; // List of parent namespaces for this decl.\n  std::vector<CommentInfo> Description; // Comment description of this decl.\n  llvm::SmallString<128> Path;          // Path of directory where the clang-doc\n                                        // generated file will be saved\n\n  void mergeBase(Info &&I);\n  bool mergeable(const Info &Other);\n\n  llvm::SmallString<16> extractName() const;\n\n  /// Returns the file path for this Info relative to CurrentPath.\n  llvm::SmallString<64> getRelativeFilePath(const StringRef &CurrentPath) const;\n\n  /// Returns the basename that should be used for this Info.\n  llvm::SmallString<16> getFileBaseName() const;\n\n  // Returns a reference to the parent scope (that is, the immediate parent\n  // namespace or class in which this decl resides).\n  llvm::Expected<Reference> getEnclosingScope();\n};\n\n// Info for namespaces.\nstruct NamespaceInfo : public Info {\n  NamespaceInfo() : Info(InfoType::IT_namespace) {}\n  NamespaceInfo(SymbolID USR) : Info(InfoType::IT_namespace, USR) {}\n  NamespaceInfo(SymbolID USR, StringRef Name)\n      : Info(InfoType::IT_namespace, USR, Name) {}\n  NamespaceInfo(SymbolID USR, StringRef Name, StringRef Path)\n      : Info(InfoType::IT_namespace, USR, Name, Path) {}\n\n  void merge(NamespaceInfo &&I);\n\n  // Namespaces and Records are references because they will be properly\n  // documented in their own info, while the entirety of Functions and Enums are\n  // included here because they should not have separate documentation from\n  // their scope.\n  std::vector<Reference> ChildNamespaces;\n  std::vector<Reference> ChildRecords;\n  std::vector<FunctionInfo> ChildFunctions;\n  std::vector<EnumInfo> ChildEnums;\n};\n\n// Info for symbols.\nstruct SymbolInfo : public Info {\n  SymbolInfo(InfoType IT) : Info(IT) {}\n  SymbolInfo(InfoType IT, SymbolID USR) : Info(IT, USR) {}\n  SymbolInfo(InfoType IT, SymbolID USR, StringRef Name) : Info(IT, USR, Name) {}\n  SymbolInfo(InfoType IT, SymbolID USR, StringRef Name, StringRef Path)\n      : Info(IT, USR, Name, Path) {}\n\n  void merge(SymbolInfo &&I);\n\n  llvm::Optional<Location> DefLoc;    // Location where this decl is defined.\n  llvm::SmallVector<Location, 2> Loc; // Locations where this decl is declared.\n};\n\n// TODO: Expand to allow for documenting templating and default args.\n// Info for functions.\nstruct FunctionInfo : public SymbolInfo {\n  FunctionInfo() : SymbolInfo(InfoType::IT_function) {}\n  FunctionInfo(SymbolID USR) : SymbolInfo(InfoType::IT_function, USR) {}\n\n  void merge(FunctionInfo &&I);\n\n  bool IsMethod = false; // Indicates whether this function is a class method.\n  Reference Parent;      // Reference to the parent class decl for this method.\n  TypeInfo ReturnType;   // Info about the return type of this function.\n  llvm::SmallVector<FieldTypeInfo, 4> Params; // List of parameters.\n  // Access level for this method (public, private, protected, none).\n  // AS_public is set as default because the bitcode writer requires the enum\n  // with value 0 to be used as the default.\n  // (AS_public = 0, AS_protected = 1, AS_private = 2, AS_none = 3)\n  AccessSpecifier Access = AccessSpecifier::AS_public;\n};\n\n// TODO: Expand to allow for documenting templating, inheritance access,\n// friend classes\n// Info for types.\nstruct RecordInfo : public SymbolInfo {\n  RecordInfo() : SymbolInfo(InfoType::IT_record) {}\n  RecordInfo(SymbolID USR) : SymbolInfo(InfoType::IT_record, USR) {}\n  RecordInfo(SymbolID USR, StringRef Name)\n      : SymbolInfo(InfoType::IT_record, USR, Name) {}\n  RecordInfo(SymbolID USR, StringRef Name, StringRef Path)\n      : SymbolInfo(InfoType::IT_record, USR, Name, Path) {}\n\n  void merge(RecordInfo &&I);\n\n  TagTypeKind TagType = TagTypeKind::TTK_Struct; // Type of this record\n                                                 // (struct, class, union,\n                                                 // interface).\n  bool IsTypeDef = false; // Indicates if record was declared using typedef\n  llvm::SmallVector<MemberTypeInfo, 4>\n      Members;                             // List of info about record members.\n  llvm::SmallVector<Reference, 4> Parents; // List of base/parent records\n                                           // (does not include virtual\n                                           // parents).\n  llvm::SmallVector<Reference, 4>\n      VirtualParents; // List of virtual base/parent records.\n\n  std::vector<BaseRecordInfo>\n      Bases; // List of base/parent records; this includes inherited methods and\n             // attributes\n\n  // Records are references because they will be properly documented in their\n  // own info, while the entirety of Functions and Enums are included here\n  // because they should not have separate documentation from their scope.\n  std::vector<Reference> ChildRecords;\n  std::vector<FunctionInfo> ChildFunctions;\n  std::vector<EnumInfo> ChildEnums;\n};\n\nstruct BaseRecordInfo : public RecordInfo {\n  BaseRecordInfo() : RecordInfo() {}\n  BaseRecordInfo(SymbolID USR, StringRef Name, StringRef Path, bool IsVirtual,\n                 AccessSpecifier Access, bool IsParent)\n      : RecordInfo(USR, Name, Path), IsVirtual(IsVirtual), Access(Access),\n        IsParent(IsParent) {}\n\n  // Indicates if base corresponds to a virtual inheritance\n  bool IsVirtual = false;\n  // Access level associated with this inherited info (public, protected,\n  // private).\n  AccessSpecifier Access = AccessSpecifier::AS_public;\n  bool IsParent = false; // Indicates if this base is a direct parent\n};\n\n// TODO: Expand to allow for documenting templating.\n// Info for types.\nstruct EnumInfo : public SymbolInfo {\n  EnumInfo() : SymbolInfo(InfoType::IT_enum) {}\n  EnumInfo(SymbolID USR) : SymbolInfo(InfoType::IT_enum, USR) {}\n\n  void merge(EnumInfo &&I);\n\n  bool Scoped =\n      false; // Indicates whether this enum is scoped (e.g. enum class).\n  llvm::SmallVector<SmallString<16>, 4> Members; // List of enum members.\n};\n\nstruct Index : public Reference {\n  Index() = default;\n  Index(StringRef Name) : Reference(Name) {}\n  Index(StringRef Name, StringRef JumpToSection)\n      : Reference(Name), JumpToSection(JumpToSection) {}\n  Index(SymbolID USR, StringRef Name, InfoType IT, StringRef Path)\n      : Reference(USR, Name, IT, Path) {}\n  // This is used to look for a USR in a vector of Indexes using std::find\n  bool operator==(const SymbolID &Other) const { return USR == Other; }\n  bool operator<(const Index &Other) const;\n\n  llvm::Optional<SmallString<16>> JumpToSection;\n  std::vector<Index> Children;\n\n  void sort();\n};\n\n// TODO: Add functionality to include separate markdown pages.\n\n// A standalone function to call to merge a vector of infos into one.\n// This assumes that all infos in the vector are of the same type, and will fail\n// if they are different.\nllvm::Expected<std::unique_ptr<Info>>\nmergeInfos(std::vector<std::unique_ptr<Info>> &Values);\n\nstruct ClangDocContext {\n  ClangDocContext() = default;\n  ClangDocContext(tooling::ExecutionContext *ECtx, StringRef ProjectName,\n                  bool PublicOnly, StringRef OutDirectory, StringRef SourceRoot,\n                  StringRef RepositoryUrl,\n                  std::vector<std::string> UserStylesheets,\n                  std::vector<std::string> JsScripts);\n  tooling::ExecutionContext *ECtx;\n  std::string ProjectName; // Name of project clang-doc is documenting.\n  bool PublicOnly; // Indicates if only public declarations are documented.\n  std::string OutDirectory; // Directory for outputting generated files.\n  std::string SourceRoot;   // Directory where processed files are stored. Links\n                            // to definition locations will only be generated if\n                            // the file is in this dir.\n  // URL of repository that hosts code used for links to definition locations.\n  llvm::Optional<std::string> RepositoryUrl;\n  // Path of CSS stylesheets that will be copied to OutDirectory and used to\n  // style all HTML files.\n  std::vector<std::string> UserStylesheets;\n  // JavaScript files that will be imported in allHTML file.\n  std::vector<std::string> JsScripts;\n  // Other files that should be copied to OutDirectory, besides UserStylesheets.\n  std::vector<std::string> FilesToCopy;\n  Index Idx;\n};\n\n} // namespace doc\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_DOC_REPRESENTATION_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais' (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_H_\n\n#include <limits>\n#include <ostream>\n#include <vector>\n\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/gtest-death-test.h\"\n#include \"gtest/gtest-message.h\"\n#include \"gtest/gtest-param-test.h\"\n#include \"gtest/gtest-printers.h\"\n#include \"gtest/gtest_prod.h\"\n#include \"gtest/gtest-test-part.h\"\n#include \"gtest/gtest-typed-test.h\"\n\n// Depending on the platform, different string classes are available.\n// On Linux, in addition to ::std::string, Google also makes use of\n// class ::string, which has the same interface as ::std::string, but\n// has a different implementation.\n//\n// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that\n// ::string is available AND is a distinct type to ::std::string, or\n// define it to 0 to indicate otherwise.\n//\n// If ::std::string and ::string are the same class on your platform\n// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.\n//\n// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined\n// heuristically.\n\nnamespace testing {\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// \"yes\" to enable colors, \"no\" (disable colors), or \"auto\" (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests' order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a \"host:port\" string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string& message);\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don't forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestCase;\nclass TestInfo;\nclass UnitTest;\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn't successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() << n << \" is even\";\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         << \"Expected: \" << expr << \" is even\\n  Actual: it's \" << n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it's 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult& other);\n\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult's copy constructor to be used.\n  template <typename T>\n  explicit AssertionResult(\n      const T& success,\n      typename internal::EnableIf<\n          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\n          /*enabler*/ = NULL)\n      : success_(success) {}\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  // Assignment operator.\n  AssertionResult& operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true iff the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate's outcome doesn't match the\n  // assertion's expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != NULL ?  message_->c_str() : \"\";\n  }\n  // TODO(vladl@google.com): Remove this after making sure no clients use it.\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template <typename T> AssertionResult& operator<<(const T& value) {\n    AppendMessage(Message() << value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult& operator<<(\n      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {\n    AppendMessage(Message() << basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message& a_message) {\n    if (message_.get() == NULL)\n      message_.reset(new ::std::string);\n    message_->append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult& other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate's outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  internal::scoped_ptr< ::std::string> message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() << msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message& msg);\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestCases, and\n// each TestCase contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don't need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // Defines types for pointers to functions that set up and tear down\n  // a test case.\n  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;\n  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;\n\n  // The d'tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::SetUpTestCase() before running the first\n  // test in test case Foo.  Hence a sub-class can define its own\n  // SetUpTestCase() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestCase() {}\n\n  // Tears down the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::TearDownTestCase() after running the last\n  // test in test case Foo.  Hence a sub-class can define its own\n  // TearDownTestCase() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestCase() {}\n\n  // Returns true iff the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true iff the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true iff the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test case, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test case.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the <testcase> element.  Properties recorded from fixture's\n  // SetUpTestCase or TearDownTestCase are logged as attributes of the\n  // corresponding <testsuite> element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the <testsuites> element.\n  static void RecordProperty(const std::string& key, const std::string& value);\n  static void RecordProperty(const std::string& key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true iff the current test has the same fixture class as\n  // the first test in the current test case.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user's\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user's test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n\n  // We disallow copying Tests.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don't inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C'tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string& a_key, const std::string& a_value) :\n    key_(a_key), value_(a_value) {\n  }\n\n  // Gets the user supplied key.\n  const char* key() const {\n    return key_.c_str();\n  }\n\n  // Gets the user supplied value.\n  const char* value() const {\n    return value_.c_str();\n  }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string& new_value) {\n    value_ = new_value;\n  }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D'tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true iff the test passed (i.e. no test part failed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test failed.\n  bool Failed() const;\n\n  // Returns true iff the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true iff the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test part result among all the results. i can range\n  // from 0 to test_property_count() - 1. If i is not in that range, aborts\n  // the program.\n  const TestPartResult& GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty& GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestCase;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector<TestPartResult>& test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector<TestProperty>& test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string& xml_element,\n                      const TestProperty& test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testcase tags.  Returns true if the property is valid.\n  // TODO(russr): Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string& xml_element,\n                                   const TestProperty& test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult& test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properites_mutex_;\n\n  // The vector of TestPartResults\n  std::vector<TestPartResult> test_part_results_;\n  // The vector of TestProperties\n  std::vector<TestProperty> test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test case name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don't inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test case name.\n  const char* test_case_name() const { return test_case_name_.c_str(); }\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != NULL)\n      return value_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test case Foo is defined as\n  // \"Foo.Bar\".  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a '-' and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character 'A' or starts with \"Foo.\".\n  bool should_run() const { return should_run_; }\n\n  // Returns true iff this test will appear in the XML report.\n  bool is_reportable() const {\n    // For now, the XML report includes all tests matching the filter.\n    // In the future, we may trim tests that are excluded because of\n    // sharding.\n    return matches_filter_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestCase;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_case_name,\n      const char* name,\n      const char* type_param,\n      const char* value_param,\n      internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id,\n      Test::SetUpTestCaseFunc set_up_tc,\n      Test::TearDownTestCaseFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string& test_case_name,\n           const std::string& name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info->result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_case_name_;     // Test case name\n  const std::string name_;               // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const internal::scoped_ptr<const ::std::string> value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;   // ID of the test fixture class\n  bool should_run_;                 // True iff this test should run\n  bool is_disabled_;                // True iff this test is disabled\n  bool matches_filter_;             // True if this test matches the\n                                    // user-specified filter.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\n};\n\n// A test case, which consists of a vector of TestInfos.\n//\n// TestCase is not copyable.\nclass GTEST_API_ TestCase {\n public:\n  // Creates a TestCase with the given name.\n  //\n  // TestCase does NOT have a default constructor.  Always use this\n  // constructor to create a TestCase object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test case\n  //   a_type_param: the name of the test's type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test case\n  //   tear_down_tc: pointer to the function that tears down the test case\n  TestCase(const char* name, const char* a_type_param,\n           Test::SetUpTestCaseFunc set_up_tc,\n           Test::TearDownTestCaseFunc tear_down_tc);\n\n  // Destructor of TestCase.\n  virtual ~TestCase();\n\n  // Gets the name of the TestCase.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test case.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns true if any test in this test case should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test case.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests in this test case.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test case.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test case that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test case.\n  int total_test_count() const;\n\n  // Returns true iff the test case passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test case failed.\n  bool Failed() const { return failed_test_count() > 0; }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestCase and TearDownTestCase.\n  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestCase.\n  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestCase.\n  const std::vector<TestInfo*>& test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test case.  Will delete the TestInfo upon\n  // destruction of the TestCase object.\n  void AddTestInfo(TestInfo * test_info);\n\n  // Clears the results of all tests in this test case.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test case.\n  static void ClearTestCaseResult(TestCase* test_case) {\n    test_case->ClearResult();\n  }\n\n  // Runs every test in this TestCase.\n  void Run();\n\n  // Runs SetUpTestCase() for this TestCase.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestCase().\n  void RunSetUpTestCase() { (*set_up_tc_)(); }\n\n  // Runs TearDownTestCase() for this TestCase.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestCase().\n  void RunTearDownTestCase() { (*tear_down_tc_)(); }\n\n  // Returns true iff test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Passed();\n  }\n\n  // Returns true iff test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Failed();\n  }\n\n  // Returns true iff the test is disabled and will be reported in the XML\n  // report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info->is_reportable() && test_info->is_disabled_;\n  }\n\n  // Returns true iff test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info->is_disabled_;\n  }\n\n  // Returns true iff this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info->is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info->should_run();\n  }\n\n  // Shuffles the tests in this test case.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test case.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector<TestInfo*> test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector<int> test_indices_;\n  // Pointer to the function that sets up the test case.\n  Test::SetUpTestCaseFunc set_up_tc_;\n  // Pointer to the function that tears down the test case.\n  Test::TearDownTestCaseFunc tear_down_tc_;\n  // True iff any test in this test case should run.\n  bool should_run_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestCase and\n  // TearDownTestCase.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestCases.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d'tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n};\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest& unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;\n\n  // Fired before the test case starts.\n  virtual void OnTestCaseStart(const TestCase& test_case) = 0;\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo& test_info) = 0;\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo& test_info) = 0;\n\n  // Fired after the test case ends.\n  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest& unit_test,\n                                  int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationStart(const UnitTest& /*unit_test*/,\n                                    int /*iteration*/) {}\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestCaseStart(const TestCase& /*test_case*/) {}\n  virtual void OnTestStart(const TestInfo& /*test_info*/) {}\n  virtual void OnTestPartResult(const TestPartResult& /*test_part_result*/) {}\n  virtual void OnTestEnd(const TestInfo& /*test_info*/) {}\n  virtual void OnTestCaseEnd(const TestCase& /*test_case*/) {}\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationEnd(const UnitTest& /*unit_test*/,\n                                  int /*iteration*/) {}\n  virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller's responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestCase;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\n};\n\n// A UnitTest consists of a vector of TestCases.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestCase object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestCase* current_test_case() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the TestInfo object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n#if GTEST_HAS_PARAM_TEST\n  // Returns the ParameterizedTestCaseRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n#endif  // GTEST_HAS_PARAM_TEST\n\n  // Gets the number of successful test cases.\n  int successful_test_case_count() const;\n\n  // Gets the number of failed test cases.\n  int failed_test_case_count() const;\n\n  // Gets the number of all test cases.\n  int total_test_case_count() const;\n\n  // Gets the number of all test cases that contain at least one test\n  // that should run.\n  int test_case_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true iff the unit test passed (i.e. all test cases passed).\n  bool Passed() const;\n\n  // Returns true iff the unit test failed (i.e. some test case failed\n  // or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  const TestCase* GetTestCase(int i) const;\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test cases.\n  const TestResult& ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners& listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name,\n                         int line_number,\n                         const std::string& message,\n                         const std::string& os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestCase's ad_hoc_test_result_ when invoked\n  // from SetUpTestCase or TearDownTestCase, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string& key, const std::string& value);\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  TestCase* GetMutableTestCase(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and funcions are friends as they need to access private\n  // members of UnitTest.\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::ScopedTrace;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type,\n      const std::string& message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D'tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo& trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don't mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn't guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()->AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression,\n                                   const T1& lhs, const T2& rhs) {\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs),\n                   false);\n}\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression,\n                            const T1& lhs,\n                            const T2& rhs) {\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\n// With this overloaded version, we allow anonymous enums to be used\n// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums\n// can be implicitly cast to BiggestInt.\nGTEST_API_ AssertionResult CmpHelperEQ(const char* lhs_expression,\n                                       const char* rhs_expression,\n                                       BiggestInt lhs,\n                                       BiggestInt rhs);\n\n// The helper class for {ASSERT|EXPECT}_EQ.  The template argument\n// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()\n// is a null pointer literal.  The following default implementation is\n// for lhs_is_null_literal being false.\ntemplate <bool lhs_is_null_literal>\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template <typename T1, typename T2>\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 const T1& lhs,\n                                 const T2& rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n};\n\n// This specialization is used when the first argument to ASSERT_EQ()\n// is a null pointer literal, like NULL, false, or 0.\ntemplate <>\nclass EqHelper<true> {\n public:\n  // We define two overloaded versions of Compare().  The first\n  // version will be picked when the second argument to ASSERT_EQ() is\n  // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or\n  // EXPECT_EQ(false, a_bool).\n  template <typename T1, typename T2>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      const T1& lhs,\n      const T2& rhs,\n      // The following line prevents this overload from being considered if T2\n      // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)\n      // expands to Compare(\"\", \"\", NULL, my_ptr), which requires a conversion\n      // to match the Secret* in the other overload, which would otherwise make\n      // this template match better.\n      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // This version will be picked when the second argument to ASSERT_EQ() is a\n  // pointer, e.g. ASSERT_EQ(NULL, a_pointer).\n  template <typename T>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      // We used to have a second template parameter instead of Secret*.  That\n      // template parameter would deduce to 'long', making this a better match\n      // than the first overload even without the first overload's EnableIf.\n      // Unfortunately, gcc with -Wconversion-null warns when \"passing NULL to\n      // non-pointer argument\" (even a deduced integral argument), so the old\n      // implementation caused warnings in user code.\n      Secret* /* lhs (NULL) */,\n      T* rhs) {\n    // We already know that 'lhs' is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression,\n                       static_cast<T*>(NULL), rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1& val1, const T2& val2,\n                                   const char* op) {\n  return AssertionFailure()\n         << \"Expected: (\" << expr1 << \") \" << op << \" (\" << expr2\n         << \"), actual: \" << FormatForComparisonFailureMessage(val1, val2)\n         << \" vs \" << FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// For each templatized helper function, we also define an overloaded\n// version for BiggestInt in order to reduce code bloat and allow\n// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled\n// with gcc 4.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)\\\ntemplate <typename T1, typename T2>\\\nAssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                   const T1& val1, const T2& val2) {\\\n  if (val1 op val2) {\\\n    return AssertionSuccess();\\\n  } else {\\\n    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\n  }\\\n}\\\nGTEST_API_ AssertionResult CmpHelper##op_name(\\\n    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=);\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, <=);\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, <);\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, >=);\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, >);\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename RawType>\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value,\n                                         RawType rhs_value) {\n  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << rhs_value;\n\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   StringStreamToString(&lhs_ss),\n                   StringStreamToString(&rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1,\n                                                double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type,\n               const char* file,\n               int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message& message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t,\n                     const char* srcfile,\n                     int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) { }\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\n  };\n\n  AssertHelperData* const data_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\n};\n\n}  // namespace internal\n\n#if GTEST_HAS_PARAM_TEST\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam<int> {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual ~FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void SetUp() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void TearDown {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate <typename T>\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture's\n  // constructor. This member function is non-static, even though it only\n  // references static data, to reduce the opportunity for incorrect uses\n  // like writing 'WithParamInterface<bool>::GetParam()' for a test that\n  // uses a fixture whose parameter type is int.\n  const ParamType& GetParam() const {\n    GTEST_CHECK_(parameter_ != NULL)\n        << \"GetParam() can only be called inside a value-parameterized test \"\n        << \"-- did you intend to write TEST_P instead of TEST_F?\";\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) {\n    parameter_ = parameter;\n  }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface<T> and Test.\n  template <class TestClass> friend class internal::ParameterizedTestFactory;\n};\n\ntemplate <typename T>\nconst T* WithParamInterface<T>::parameter_ = NULL;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate <typename T>\nclass TestWithParam : public Test, public WithParamInterface<T> {\n};\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n// Macros for indicating success/failure in test code.\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn't automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(\"Failed\")\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line) \\\n  GTEST_MESSAGE_AT_(file, line, \"Failed\", \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(\"Failed\")\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n# define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(\"Succeeded\")\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n# define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn't throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define EXPECT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define EXPECT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_FATAL_FAILURE_)\n#define ASSERT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Includes the auto-generated header that implements a family of\n// generic predicate assertion macros.\n#include \"gtest/gtest_pred_impl.h\"\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 < v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 <= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 > v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 >= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By \"compatible\" we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(5, Foo());\n//   EXPECT_EQ(NULL, a_pointer);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) << \"There is no record left.\";\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users' own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n# define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n# define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n# define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n# define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n# define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n# define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don't depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)\\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)\\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n# define EXPECT_HRESULT_SUCCEEDED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define ASSERT_HRESULT_SUCCEEDED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define EXPECT_HRESULT_FAILED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n# define ASSERT_HRESULT_FAILED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn't generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) << \"Process() failed\";\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n#define SCOPED_TRACE(message) \\\n  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\n    __FILE__, __LINE__, ::testing::Message() << (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are\n// the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq<T1, T2> by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template <typename T> class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq<int, T>(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo<bool> foo; }\n//\n// will NOT generate a compiler error, as Foo<bool>::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo<bool> foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate <typename T1, typename T2>\nbool StaticAssertTypeEq() {\n  (void)internal::StaticAssertTypeEqHelper<T1, T2>();\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test case, and the second\n// parameter is the name of the test within the test case.\n//\n// The convention is to end the test case name with \"Test\".  For\n// example, a test case for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId<\n// ::testing::Test>() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId<\n// ::testing::Test>() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId<>() from the Google Test\n// framework.\n#define GTEST_TEST(test_case_name, test_name)\\\n  GTEST_TEST_(test_case_name, test_name, \\\n              ::testing::Test, ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n# define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test case name.  The second parameter is the\n// name of the test within the test case.\n//\n// A test fixture class must be declared earlier.  The user should put\n// his test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     virtual void SetUp() { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(0, a_.size());\n//     EXPECT_EQ(1, b_.size());\n//   }\n\n#define TEST_F(test_fixture, test_name)\\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId<test_fixture>())\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() {\n  return ::testing::UnitTest::GetInstance()->Run();\n}\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "content": "//===-- clang-doc/SerializeTest.cpp ---------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"Serialize.h\"\n#include \"ClangDocTest.h\"\n#include \"Representation.h\"\n#include \"clang/AST/Comment.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"gtest/gtest.h\"\n\nnamespace clang {\nnamespace doc {\n\nclass ClangDocSerializeTestVisitor\n    : public RecursiveASTVisitor<ClangDocSerializeTestVisitor> {\n\n  EmittedInfoList &EmittedInfos;\n  bool Public;\n\n  comments::FullComment *getComment(const NamedDecl *D) const {\n    if (RawComment *Comment =\n            D->getASTContext().getRawCommentForDeclNoCache(D)) {\n      Comment->setAttached();\n      return Comment->parse(D->getASTContext(), nullptr, D);\n    }\n    return nullptr;\n  }\n\npublic:\n  ClangDocSerializeTestVisitor(EmittedInfoList &EmittedInfos, bool Public)\n      : EmittedInfos(EmittedInfos), Public(Public) {}\n\n  template <typename T> bool mapDecl(const T *D) {\n    auto I = serialize::emitInfo(D, getComment(D), /*Line=*/0,\n                                 /*File=*/\"test.cpp\", true, Public);\n    if (I.first)\n      EmittedInfos.emplace_back(std::move(I.first));\n    if (I.second)\n      EmittedInfos.emplace_back(std::move(I.second));\n    return true;\n  }\n\n  bool VisitNamespaceDecl(const NamespaceDecl *D) { return mapDecl(D); }\n\n  bool VisitFunctionDecl(const FunctionDecl *D) {\n    // Don't visit CXXMethodDecls twice\n    if (dyn_cast<CXXMethodDecl>(D))\n      return true;\n    return mapDecl(D);\n  }\n\n  bool VisitCXXMethodDecl(const CXXMethodDecl *D) { return mapDecl(D); }\n\n  bool VisitRecordDecl(const RecordDecl *D) { return mapDecl(D); }\n\n  bool VisitEnumDecl(const EnumDecl *D) { return mapDecl(D); }\n};\n\nvoid ExtractInfosFromCode(StringRef Code, size_t NumExpectedInfos, bool Public,\n                          EmittedInfoList &EmittedInfos) {\n  auto ASTUnit = clang::tooling::buildASTFromCode(Code);\n  auto TU = ASTUnit->getASTContext().getTranslationUnitDecl();\n  ClangDocSerializeTestVisitor Visitor(EmittedInfos, Public);\n  Visitor.TraverseTranslationUnitDecl(TU);\n  ASSERT_EQ(NumExpectedInfos, EmittedInfos.size());\n}\n\nvoid ExtractInfosFromCodeWithArgs(StringRef Code, size_t NumExpectedInfos,\n                                  bool Public, EmittedInfoList &EmittedInfos,\n                                  std::vector<std::string> &Args) {\n  auto ASTUnit = clang::tooling::buildASTFromCodeWithArgs(Code, Args);\n  auto TU = ASTUnit->getASTContext().getTranslationUnitDecl();\n  ClangDocSerializeTestVisitor Visitor(EmittedInfos, Public);\n  Visitor.TraverseTranslationUnitDecl(TU);\n  ASSERT_EQ(NumExpectedInfos, EmittedInfos.size());\n}\n\n// Test serialization of namespace declarations.\nTEST(SerializeTest, emitNamespaceInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"namespace A { namespace B { void f() {} } }\", 5,\n                       /*Public=*/false, Infos);\n\n  NamespaceInfo *A = InfoAsNamespace(Infos[0].get());\n  NamespaceInfo ExpectedA(EmptySID, \"A\");\n  CheckNamespaceInfo(&ExpectedA, A);\n\n  NamespaceInfo *B = InfoAsNamespace(Infos[2].get());\n  NamespaceInfo ExpectedB(EmptySID, /*Name=*/\"B\", /*Path=*/\"A\");\n  ExpectedB.Namespace.emplace_back(EmptySID, \"A\", InfoType::IT_namespace);\n  CheckNamespaceInfo(&ExpectedB, B);\n\n  NamespaceInfo *BWithFunction = InfoAsNamespace(Infos[4].get());\n  NamespaceInfo ExpectedBWithFunction(EmptySID);\n  FunctionInfo F;\n  F.Name = \"f\";\n  F.ReturnType = TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  F.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  F.Namespace.emplace_back(EmptySID, \"B\", InfoType::IT_namespace);\n  F.Namespace.emplace_back(EmptySID, \"A\", InfoType::IT_namespace);\n  F.Access = AccessSpecifier::AS_none;\n  ExpectedBWithFunction.ChildFunctions.emplace_back(std::move(F));\n  CheckNamespaceInfo(&ExpectedBWithFunction, BWithFunction);\n}\n\nTEST(SerializeTest, emitAnonymousNamespaceInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"namespace { }\", 2, /*Public=*/false, Infos);\n\n  NamespaceInfo *A = InfoAsNamespace(Infos[0].get());\n  NamespaceInfo ExpectedA(EmptySID);\n  ExpectedA.Name = \"@nonymous_namespace\";\n  CheckNamespaceInfo(&ExpectedA, A);\n}\n\n// Test serialization of record declarations.\nTEST(SerializeTest, emitRecordInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(R\"raw(class E {\npublic:\n  E() {}\nprotected:\n  void ProtectedMethod();\n};\ntemplate <typename T>\nstruct F {\n  void TemplateMethod();\n};\ntemplate <>\nvoid F<int>::TemplateMethod();\ntypedef struct {} G;)raw\",\n                       10, /*Public=*/false, Infos);\n\n  RecordInfo *E = InfoAsRecord(Infos[0].get());\n  RecordInfo ExpectedE(EmptySID, /*Name=*/\"E\", /*Path=*/\"GlobalNamespace\");\n  ExpectedE.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedE.TagType = TagTypeKind::TTK_Class;\n  ExpectedE.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  CheckRecordInfo(&ExpectedE, E);\n\n  RecordInfo *RecordWithEConstructor = InfoAsRecord(Infos[2].get());\n  RecordInfo ExpectedRecordWithEConstructor(EmptySID);\n  FunctionInfo EConstructor;\n  EConstructor.Name = \"E\";\n  EConstructor.Parent = Reference(EmptySID, \"E\", InfoType::IT_record);\n  EConstructor.ReturnType = TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  EConstructor.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  EConstructor.Namespace.emplace_back(EmptySID, \"E\", InfoType::IT_record);\n  EConstructor.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                      InfoType::IT_namespace);\n  EConstructor.Access = AccessSpecifier::AS_public;\n  EConstructor.IsMethod = true;\n  ExpectedRecordWithEConstructor.ChildFunctions.emplace_back(\n      std::move(EConstructor));\n  CheckRecordInfo(&ExpectedRecordWithEConstructor, RecordWithEConstructor);\n\n  RecordInfo *RecordWithMethod = InfoAsRecord(Infos[3].get());\n  RecordInfo ExpectedRecordWithMethod(EmptySID);\n  FunctionInfo Method;\n  Method.Name = \"ProtectedMethod\";\n  Method.Parent = Reference(EmptySID, \"E\", InfoType::IT_record);\n  Method.ReturnType = TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  Method.Loc.emplace_back(0, llvm::SmallString<16>{\"test.cpp\"});\n  Method.Namespace.emplace_back(EmptySID, \"E\", InfoType::IT_record);\n  Method.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                InfoType::IT_namespace);\n  Method.Access = AccessSpecifier::AS_protected;\n  Method.IsMethod = true;\n  ExpectedRecordWithMethod.ChildFunctions.emplace_back(std::move(Method));\n  CheckRecordInfo(&ExpectedRecordWithMethod, RecordWithMethod);\n\n  RecordInfo *F = InfoAsRecord(Infos[4].get());\n  RecordInfo ExpectedF(EmptySID, /*Name=*/\"F\", /*Path=*/\"GlobalNamespace\");\n  ExpectedF.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedF.TagType = TagTypeKind::TTK_Struct;\n  ExpectedF.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  CheckRecordInfo(&ExpectedF, F);\n\n  RecordInfo *RecordWithTemplateMethod = InfoAsRecord(Infos[6].get());\n  RecordInfo ExpectedRecordWithTemplateMethod(EmptySID);\n  FunctionInfo TemplateMethod;\n  TemplateMethod.Name = \"TemplateMethod\";\n  TemplateMethod.Parent = Reference(EmptySID, \"F\", InfoType::IT_record);\n  TemplateMethod.ReturnType = TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  TemplateMethod.Loc.emplace_back(0, llvm::SmallString<16>{\"test.cpp\"});\n  TemplateMethod.Namespace.emplace_back(EmptySID, \"F\", InfoType::IT_record);\n  TemplateMethod.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                        InfoType::IT_namespace);\n  TemplateMethod.Access = AccessSpecifier::AS_public;\n  TemplateMethod.IsMethod = true;\n  ExpectedRecordWithTemplateMethod.ChildFunctions.emplace_back(\n      std::move(TemplateMethod));\n  CheckRecordInfo(&ExpectedRecordWithTemplateMethod, RecordWithTemplateMethod);\n\n  RecordInfo *TemplatedRecord = InfoAsRecord(Infos[7].get());\n  RecordInfo ExpectedTemplatedRecord(EmptySID);\n  FunctionInfo SpecializedTemplateMethod;\n  SpecializedTemplateMethod.Name = \"TemplateMethod\";\n  SpecializedTemplateMethod.Parent =\n      Reference(EmptySID, \"F\", InfoType::IT_record);\n  SpecializedTemplateMethod.ReturnType =\n      TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  SpecializedTemplateMethod.Loc.emplace_back(0,\n                                             llvm::SmallString<16>{\"test.cpp\"});\n  SpecializedTemplateMethod.Namespace.emplace_back(EmptySID, \"F\",\n                                                   InfoType::IT_record);\n  SpecializedTemplateMethod.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                                   InfoType::IT_namespace);\n  SpecializedTemplateMethod.Access = AccessSpecifier::AS_public;\n  SpecializedTemplateMethod.IsMethod = true;\n  ExpectedTemplatedRecord.ChildFunctions.emplace_back(\n      std::move(SpecializedTemplateMethod));\n  CheckRecordInfo(&ExpectedTemplatedRecord, TemplatedRecord);\n\n  RecordInfo *G = InfoAsRecord(Infos[8].get());\n  RecordInfo ExpectedG(EmptySID, /*Name=*/\"G\", /*Path=*/\"GlobalNamespace\");\n  ExpectedG.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedG.TagType = TagTypeKind::TTK_Struct;\n  ExpectedG.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedG.IsTypeDef = true;\n  CheckRecordInfo(&ExpectedG, G);\n}\n\n// Test serialization of enum declarations.\nTEST(SerializeTest, emitEnumInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"enum E { X, Y }; enum class G { A, B };\", 2,\n                       /*Public=*/false, Infos);\n\n  NamespaceInfo *NamespaceWithEnum = InfoAsNamespace(Infos[0].get());\n  NamespaceInfo ExpectedNamespaceWithEnum(EmptySID);\n  EnumInfo E;\n  E.Name = \"E\";\n  E.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  E.Members.emplace_back(\"X\");\n  E.Members.emplace_back(\"Y\");\n  ExpectedNamespaceWithEnum.ChildEnums.emplace_back(std::move(E));\n  CheckNamespaceInfo(&ExpectedNamespaceWithEnum, NamespaceWithEnum);\n\n  NamespaceInfo *NamespaceWithScopedEnum = InfoAsNamespace(Infos[1].get());\n  NamespaceInfo ExpectedNamespaceWithScopedEnum(EmptySID);\n  EnumInfo G;\n  G.Name = \"G\";\n  G.Scoped = true;\n  G.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  G.Members.emplace_back(\"A\");\n  G.Members.emplace_back(\"B\");\n  ExpectedNamespaceWithScopedEnum.ChildEnums.emplace_back(std::move(G));\n  CheckNamespaceInfo(&ExpectedNamespaceWithScopedEnum, NamespaceWithScopedEnum);\n}\n\nTEST(SerializeTest, emitUndefinedRecordInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"class E;\", 2, /*Public=*/false, Infos);\n\n  RecordInfo *E = InfoAsRecord(Infos[0].get());\n  RecordInfo ExpectedE(EmptySID, /*Name=*/\"E\", /*Path=*/\"GlobalNamespace\");\n  ExpectedE.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedE.TagType = TagTypeKind::TTK_Class;\n  ExpectedE.Loc.emplace_back(0, llvm::SmallString<16>{\"test.cpp\"});\n  CheckRecordInfo(&ExpectedE, E);\n}\n\nTEST(SerializeTest, emitRecordMemberInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"struct E { int I; };\", 2, /*Public=*/false, Infos);\n\n  RecordInfo *E = InfoAsRecord(Infos[0].get());\n  RecordInfo ExpectedE(EmptySID, /*Name=*/\"E\", /*Path=*/\"GlobalNamespace\");\n  ExpectedE.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedE.TagType = TagTypeKind::TTK_Struct;\n  ExpectedE.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedE.Members.emplace_back(\"int\", \"I\", AccessSpecifier::AS_public);\n  CheckRecordInfo(&ExpectedE, E);\n}\n\nTEST(SerializeTest, emitInternalRecordInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"class E { class G {}; };\", 4, /*Public=*/false, Infos);\n\n  RecordInfo *E = InfoAsRecord(Infos[0].get());\n  RecordInfo ExpectedE(EmptySID, /*Name=*/\"E\", /*Path=*/\"GlobalNamespace\");\n  ExpectedE.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedE.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedE.TagType = TagTypeKind::TTK_Class;\n  CheckRecordInfo(&ExpectedE, E);\n\n  RecordInfo *G = InfoAsRecord(Infos[2].get());\n  llvm::SmallString<128> ExpectedGPath(\"GlobalNamespace/E\");\n  llvm::sys::path::native(ExpectedGPath);\n  RecordInfo ExpectedG(EmptySID, /*Name=*/\"G\", /*Path=*/ExpectedGPath);\n  ExpectedG.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedG.TagType = TagTypeKind::TTK_Class;\n  ExpectedG.Namespace.emplace_back(EmptySID, \"E\", InfoType::IT_record);\n  ExpectedG.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  CheckRecordInfo(&ExpectedG, G);\n}\n\nTEST(SerializeTest, emitPublicAnonymousNamespaceInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"namespace { class A; }\", 0, /*Public=*/true, Infos);\n}\n\nTEST(SerializeTest, emitPublicFunctionInternalInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"int F() { class G {}; return 0; };\", 1, /*Public=*/true,\n                       Infos);\n\n  NamespaceInfo *BWithFunction = InfoAsNamespace(Infos[0].get());\n  NamespaceInfo ExpectedBWithFunction(EmptySID);\n  FunctionInfo F;\n  F.Name = \"F\";\n  F.ReturnType = TypeInfo(EmptySID, \"int\", InfoType::IT_default);\n  F.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  F.Access = AccessSpecifier::AS_none;\n  ExpectedBWithFunction.ChildFunctions.emplace_back(std::move(F));\n  CheckNamespaceInfo(&ExpectedBWithFunction, BWithFunction);\n}\n\nTEST(SerializeTest, emitInlinedFunctionInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"inline void F(int I) { };\", 1, /*Public=*/true, Infos);\n\n  NamespaceInfo *BWithFunction = InfoAsNamespace(Infos[0].get());\n  NamespaceInfo ExpectedBWithFunction(EmptySID);\n  FunctionInfo F;\n  F.Name = \"F\";\n  F.ReturnType = TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  F.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  F.Params.emplace_back(\"int\", \"I\");\n  F.Access = AccessSpecifier::AS_none;\n  ExpectedBWithFunction.ChildFunctions.emplace_back(std::move(F));\n  CheckNamespaceInfo(&ExpectedBWithFunction, BWithFunction);\n}\n\nTEST(SerializeTest, emitInheritedRecordInfo) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(R\"raw(class F { protected: void set(int N); };\nclass G { public: int get() { return 1; } protected: int I; };\nclass E : public F, virtual private G {};\nclass H : private E {};\ntemplate <typename T>\nclass I {} ;\nclass J : public I<int> {} ;)raw\",\n                       14, /*Public=*/false, Infos);\n\n  RecordInfo *F = InfoAsRecord(Infos[0].get());\n  RecordInfo ExpectedF(EmptySID, /*Name=*/\"F\", /*Path=*/\"GlobalNamespace\");\n  ExpectedF.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedF.TagType = TagTypeKind::TTK_Class;\n  ExpectedF.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  CheckRecordInfo(&ExpectedF, F);\n\n  RecordInfo *G = InfoAsRecord(Infos[3].get());\n  RecordInfo ExpectedG(EmptySID, /*Name=*/\"G\", /*Path=*/\"GlobalNamespace\");\n  ExpectedG.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedG.TagType = TagTypeKind::TTK_Class;\n  ExpectedG.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedG.Members.emplace_back(\"int\", \"I\", AccessSpecifier::AS_protected);\n  CheckRecordInfo(&ExpectedG, G);\n\n  RecordInfo *E = InfoAsRecord(Infos[6].get());\n  RecordInfo ExpectedE(EmptySID, /*Name=*/\"E\", /*Path=*/\"GlobalNamespace\");\n  ExpectedE.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedE.Parents.emplace_back(EmptySID, /*Name=*/\"F\", InfoType::IT_record,\n                                 /*Path*=*/\"GlobalNamespace\");\n  ExpectedE.VirtualParents.emplace_back(\n      EmptySID, /*Name=*/\"G\", InfoType::IT_record, /*Path*=*/\"GlobalNamespace\");\n  ExpectedE.Bases.emplace_back(EmptySID, /*Name=*/\"F\",\n                               /*Path=*/\"GlobalNamespace\", false,\n                               AccessSpecifier::AS_public, true);\n  FunctionInfo FunctionSet;\n  FunctionSet.Name = \"set\";\n  FunctionSet.ReturnType = TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  FunctionSet.Loc.emplace_back();\n  FunctionSet.Params.emplace_back(\"int\", \"N\");\n  FunctionSet.Namespace.emplace_back(EmptySID, \"F\", InfoType::IT_record);\n  FunctionSet.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                     InfoType::IT_namespace);\n  FunctionSet.Access = AccessSpecifier::AS_protected;\n  FunctionSet.IsMethod = true;\n  ExpectedE.Bases.back().ChildFunctions.emplace_back(std::move(FunctionSet));\n  ExpectedE.Bases.emplace_back(EmptySID, /*Name=*/\"G\",\n                               /*Path=*/\"GlobalNamespace\", true,\n                               AccessSpecifier::AS_private, true);\n  FunctionInfo FunctionGet;\n  FunctionGet.Name = \"get\";\n  FunctionGet.ReturnType = TypeInfo(EmptySID, \"int\", InfoType::IT_default);\n  FunctionGet.DefLoc = Location();\n  FunctionGet.Namespace.emplace_back(EmptySID, \"G\", InfoType::IT_record);\n  FunctionGet.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                     InfoType::IT_namespace);\n  FunctionGet.Access = AccessSpecifier::AS_private;\n  FunctionGet.IsMethod = true;\n  ExpectedE.Bases.back().ChildFunctions.emplace_back(std::move(FunctionGet));\n  ExpectedE.Bases.back().Members.emplace_back(\"int\", \"I\",\n                                              AccessSpecifier::AS_private);\n  ExpectedE.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedE.TagType = TagTypeKind::TTK_Class;\n  CheckRecordInfo(&ExpectedE, E);\n\n  RecordInfo *H = InfoAsRecord(Infos[8].get());\n  RecordInfo ExpectedH(EmptySID, /*Name=*/\"H\", /*Path=*/\"GlobalNamespace\");\n  ExpectedH.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedH.TagType = TagTypeKind::TTK_Class;\n  ExpectedH.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedH.Parents.emplace_back(EmptySID, /*Name=*/\"E\", InfoType::IT_record,\n                                 /*Path=*/\"GlobalNamespace\");\n  ExpectedH.VirtualParents.emplace_back(\n      EmptySID, /*Name=*/\"G\", InfoType::IT_record, /*Path=*/\"GlobalNamespace\");\n  ExpectedH.Bases.emplace_back(EmptySID, /*Name=*/\"E\",\n                               /*Path=*/\"GlobalNamespace\", false,\n                               AccessSpecifier::AS_private, true);\n  ExpectedH.Bases.emplace_back(EmptySID, /*Name=*/\"F\",\n                               /*Path=*/\"GlobalNamespace\", false,\n                               AccessSpecifier::AS_private, false);\n  FunctionInfo FunctionSetNew;\n  FunctionSetNew.Name = \"set\";\n  FunctionSetNew.ReturnType = TypeInfo(EmptySID, \"void\", InfoType::IT_default);\n  FunctionSetNew.Loc.emplace_back();\n  FunctionSetNew.Params.emplace_back(\"int\", \"N\");\n  FunctionSetNew.Namespace.emplace_back(EmptySID, \"F\", InfoType::IT_record);\n  FunctionSetNew.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                        InfoType::IT_namespace);\n  FunctionSetNew.Access = AccessSpecifier::AS_private;\n  FunctionSetNew.IsMethod = true;\n  ExpectedH.Bases.back().ChildFunctions.emplace_back(std::move(FunctionSetNew));\n  ExpectedH.Bases.emplace_back(EmptySID, /*Name=*/\"G\",\n                               /*Path=*/\"GlobalNamespace\", true,\n                               AccessSpecifier::AS_private, false);\n  FunctionInfo FunctionGetNew;\n  FunctionGetNew.Name = \"get\";\n  FunctionGetNew.ReturnType = TypeInfo(EmptySID, \"int\", InfoType::IT_default);\n  FunctionGetNew.DefLoc = Location();\n  FunctionGetNew.Namespace.emplace_back(EmptySID, \"G\", InfoType::IT_record);\n  FunctionGetNew.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                        InfoType::IT_namespace);\n  FunctionGetNew.Access = AccessSpecifier::AS_private;\n  FunctionGetNew.IsMethod = true;\n  ExpectedH.Bases.back().ChildFunctions.emplace_back(std::move(FunctionGetNew));\n  ExpectedH.Bases.back().Members.emplace_back(\"int\", \"I\",\n                                              AccessSpecifier::AS_private);\n  CheckRecordInfo(&ExpectedH, H);\n\n  RecordInfo *I = InfoAsRecord(Infos[10].get());\n  RecordInfo ExpectedI(EmptySID, /*Name=*/\"I\", /*Path=*/\"GlobalNamespace\");\n  ExpectedI.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedI.TagType = TagTypeKind::TTK_Class;\n  ExpectedI.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  CheckRecordInfo(&ExpectedI, I);\n\n  RecordInfo *J = InfoAsRecord(Infos[12].get());\n  RecordInfo ExpectedJ(EmptySID, /*Name=*/\"J\", /*Path=*/\"GlobalNamespace\");\n  ExpectedJ.Namespace.emplace_back(EmptySID, \"GlobalNamespace\",\n                                   InfoType::IT_namespace);\n  ExpectedJ.Parents.emplace_back(EmptySID, /*Name=*/\"I<int>\",\n                                 InfoType::IT_record);\n  ExpectedJ.Bases.emplace_back(EmptySID, /*Name=*/\"I<int>\",\n                               /*Path=*/\"GlobalNamespace\", false,\n                               AccessSpecifier::AS_public, true);\n  ExpectedJ.DefLoc = Location(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExpectedJ.TagType = TagTypeKind::TTK_Class;\n  CheckRecordInfo(&ExpectedJ, J);\n}\n\nTEST(SerializeTest, emitModulePublicLFunctions) {\n  EmittedInfoList Infos;\n  std::vector<std::string> Args;\n  Args.push_back(\"-fmodules-ts\");\n  ExtractInfosFromCodeWithArgs(R\"raw(export module M;\nint moduleFunction(int x);\nstatic int staticModuleFunction(int x);\nexport double exportedModuleFunction(double y);)raw\",\n                               2, /*Public=*/true, Infos, Args);\n\n  NamespaceInfo *BWithFunction = InfoAsNamespace(Infos[0].get());\n  NamespaceInfo ExpectedBWithFunction(EmptySID);\n  FunctionInfo F;\n  F.Name = \"moduleFunction\";\n  F.ReturnType = TypeInfo(EmptySID, \"int\", InfoType::IT_default);\n  F.Loc.emplace_back(0, llvm::SmallString<16>{\"test.cpp\"});\n  F.Params.emplace_back(\"int\", \"x\");\n  F.Access = AccessSpecifier::AS_none;\n  ExpectedBWithFunction.ChildFunctions.emplace_back(std::move(F));\n  CheckNamespaceInfo(&ExpectedBWithFunction, BWithFunction);\n\n  NamespaceInfo *BWithExportedFunction = InfoAsNamespace(Infos[1].get());\n  NamespaceInfo ExpectedBWithExportedFunction(EmptySID);\n  FunctionInfo ExportedF;\n  ExportedF.Name = \"exportedModuleFunction\";\n  ExportedF.ReturnType = TypeInfo(EmptySID, \"double\", InfoType::IT_default);\n  ExportedF.Loc.emplace_back(0, llvm::SmallString<16>{\"test.cpp\"});\n  ExportedF.Params.emplace_back(\"double\", \"y\");\n  ExportedF.Access = AccessSpecifier::AS_none;\n  ExpectedBWithExportedFunction.ChildFunctions.emplace_back(\n      std::move(ExportedF));\n  CheckNamespaceInfo(&ExpectedBWithExportedFunction, BWithExportedFunction);\n}\n\n// Test serialization of child records in namespaces and other records\nTEST(SerializeTest, emitChildRecords) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"class A { class B {}; }; namespace { class C {}; } \", 8,\n                       /*Public=*/false, Infos);\n\n  NamespaceInfo *ParentA = InfoAsNamespace(Infos[1].get());\n  NamespaceInfo ExpectedParentA(EmptySID);\n  ExpectedParentA.ChildRecords.emplace_back(EmptySID, \"A\", InfoType::IT_record,\n                                            \"GlobalNamespace\");\n  CheckNamespaceInfo(&ExpectedParentA, ParentA);\n\n  RecordInfo *ParentB = InfoAsRecord(Infos[3].get());\n  RecordInfo ExpectedParentB(EmptySID);\n  llvm::SmallString<128> ExpectedParentBPath(\"GlobalNamespace/A\");\n  llvm::sys::path::native(ExpectedParentBPath);\n  ExpectedParentB.ChildRecords.emplace_back(EmptySID, \"B\", InfoType::IT_record,\n                                            ExpectedParentBPath);\n  CheckRecordInfo(&ExpectedParentB, ParentB);\n\n  NamespaceInfo *ParentC = InfoAsNamespace(Infos[7].get());\n  NamespaceInfo ExpectedParentC(EmptySID);\n  ExpectedParentC.ChildRecords.emplace_back(EmptySID, \"C\", InfoType::IT_record,\n                                            \"@nonymous_namespace\");\n  CheckNamespaceInfo(&ExpectedParentC, ParentC);\n}\n\n// Test serialization of child namespaces\nTEST(SerializeTest, emitChildNamespaces) {\n  EmittedInfoList Infos;\n  ExtractInfosFromCode(\"namespace A { namespace B { } }\", 4, /*Public=*/false,\n                       Infos);\n\n  NamespaceInfo *ParentA = InfoAsNamespace(Infos[1].get());\n  NamespaceInfo ExpectedParentA(EmptySID);\n  ExpectedParentA.ChildNamespaces.emplace_back(EmptySID, \"A\",\n                                               InfoType::IT_namespace);\n  CheckNamespaceInfo(&ExpectedParentA, ParentA);\n\n  NamespaceInfo *ParentB = InfoAsNamespace(Infos[3].get());\n  NamespaceInfo ExpectedParentB(EmptySID);\n  ExpectedParentB.ChildNamespaces.emplace_back(EmptySID, \"B\",\n                                               InfoType::IT_namespace, \"A\");\n  CheckNamespaceInfo(&ExpectedParentB, ParentB);\n}\n\n} // namespace doc\n} // end namespace clang\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Attr.h", "content": "//===--- Attr.h - Classes for representing attributes ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Attr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ATTR_H\n#define LLVM_CLANG_AST_ATTR_H\n\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n\nnamespace clang {\nclass ASTContext;\nclass AttributeCommonInfo;\nclass IdentifierInfo;\nclass ObjCInterfaceDecl;\nclass Expr;\nclass QualType;\nclass FunctionDecl;\nclass TypeSourceInfo;\nclass OMPTraitInfo;\n\n/// Attr - This represents one attribute.\nclass Attr : public AttributeCommonInfo {\nprivate:\n  unsigned AttrKind : 16;\n\nprotected:\n  /// An index into the spelling list of an\n  /// attribute defined in Attr.td file.\n  unsigned Inherited : 1;\n  unsigned IsPackExpansion : 1;\n  unsigned Implicit : 1;\n  // FIXME: These are properties of the attribute kind, not state for this\n  // instance of the attribute.\n  unsigned IsLateParsed : 1;\n  unsigned InheritEvenIfAlreadyPresent : 1;\n\n  void *operator new(size_t bytes) noexcept {\n    llvm_unreachable(\"Attrs cannot be allocated with regular 'new'.\");\n  }\n  void operator delete(void *data) noexcept {\n    llvm_unreachable(\"Attrs cannot be released with regular 'delete'.\");\n  }\n\npublic:\n  // Forward so that the regular new and delete do not hide global ones.\n  void *operator new(size_t Bytes, ASTContext &C,\n                     size_t Alignment = 8) noexcept {\n    return ::operator new(Bytes, C, Alignment);\n  }\n  void operator delete(void *Ptr, ASTContext &C, size_t Alignment) noexcept {\n    return ::operator delete(Ptr, C, Alignment);\n  }\n\nprotected:\n  Attr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n       attr::Kind AK, bool IsLateParsed)\n      : AttributeCommonInfo(CommonInfo), AttrKind(AK), Inherited(false),\n        IsPackExpansion(false), Implicit(false), IsLateParsed(IsLateParsed),\n        InheritEvenIfAlreadyPresent(false) {}\n\npublic:\n  attr::Kind getKind() const { return static_cast<attr::Kind>(AttrKind); }\n\n  unsigned getSpellingListIndex() const {\n    return getAttributeSpellingListIndex();\n  }\n  const char *getSpelling() const;\n\n  SourceLocation getLocation() const { return getRange().getBegin(); }\n\n  bool isInherited() const { return Inherited; }\n\n  /// Returns true if the attribute has been implicitly created instead\n  /// of explicitly written by the user.\n  bool isImplicit() const { return Implicit; }\n  void setImplicit(bool I) { Implicit = I; }\n\n  void setPackExpansion(bool PE) { IsPackExpansion = PE; }\n  bool isPackExpansion() const { return IsPackExpansion; }\n\n  // Clone this attribute.\n  Attr *clone(ASTContext &C) const;\n\n  bool isLateParsed() const { return IsLateParsed; }\n\n  // Pretty print this attribute.\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy) const;\n};\n\nclass TypeAttr : public Attr {\nprotected:\n  TypeAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n           attr::Kind AK, bool IsLateParsed)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstTypeAttr &&\n           A->getKind() <= attr::LastTypeAttr;\n  }\n};\n\nclass StmtAttr : public Attr {\nprotected:\n  StmtAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n           attr::Kind AK, bool IsLateParsed)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstStmtAttr &&\n           A->getKind() <= attr::LastStmtAttr;\n  }\n};\n\nclass InheritableAttr : public Attr {\nprotected:\n  InheritableAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                  attr::Kind AK, bool IsLateParsed,\n                  bool InheritEvenIfAlreadyPresent)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {\n    this->InheritEvenIfAlreadyPresent = InheritEvenIfAlreadyPresent;\n  }\n\npublic:\n  void setInherited(bool I) { Inherited = I; }\n\n  /// Should this attribute be inherited from a prior declaration even if it's\n  /// explicitly provided in the current declaration?\n  bool shouldInheritEvenIfAlreadyPresent() const {\n    return InheritEvenIfAlreadyPresent;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstInheritableAttr &&\n           A->getKind() <= attr::LastInheritableAttr;\n  }\n};\n\nclass DeclOrStmtAttr : public InheritableAttr {\nprotected:\n  DeclOrStmtAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                 attr::Kind AK, bool IsLateParsed,\n                 bool InheritEvenIfAlreadyPresent)\n      : InheritableAttr(Context, CommonInfo, AK, IsLateParsed,\n                        InheritEvenIfAlreadyPresent) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstDeclOrStmtAttr &&\n           A->getKind() <= attr::LastDeclOrStmtAttr;\n  }\n};\n\nclass InheritableParamAttr : public InheritableAttr {\nprotected:\n  InheritableParamAttr(ASTContext &Context,\n                       const AttributeCommonInfo &CommonInfo, attr::Kind AK,\n                       bool IsLateParsed, bool InheritEvenIfAlreadyPresent)\n      : InheritableAttr(Context, CommonInfo, AK, IsLateParsed,\n                        InheritEvenIfAlreadyPresent) {}\n\npublic:\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstInheritableParamAttr &&\n           A->getKind() <= attr::LastInheritableParamAttr;\n  }\n};\n\n/// A parameter attribute which changes the argument-passing ABI rule\n/// for the parameter.\nclass ParameterABIAttr : public InheritableParamAttr {\nprotected:\n  ParameterABIAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                   attr::Kind AK, bool IsLateParsed,\n                   bool InheritEvenIfAlreadyPresent)\n      : InheritableParamAttr(Context, CommonInfo, AK, IsLateParsed,\n                             InheritEvenIfAlreadyPresent) {}\n\npublic:\n  ParameterABI getABI() const {\n    switch (getKind()) {\n    case attr::SwiftContext:\n      return ParameterABI::SwiftContext;\n    case attr::SwiftErrorResult:\n      return ParameterABI::SwiftErrorResult;\n    case attr::SwiftIndirectResult:\n      return ParameterABI::SwiftIndirectResult;\n    default:\n      llvm_unreachable(\"bad parameter ABI attribute kind\");\n    }\n  }\n\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstParameterABIAttr &&\n           A->getKind() <= attr::LastParameterABIAttr;\n   }\n};\n\n/// A single parameter index whose accessors require each use to make explicit\n/// the parameter index encoding needed.\nclass ParamIdx {\n  // Idx is exposed only via accessors that specify specific encodings.\n  unsigned Idx : 30;\n  unsigned HasThis : 1;\n  unsigned IsValid : 1;\n\n  void assertComparable(const ParamIdx &I) const {\n    assert(isValid() && I.isValid() &&\n           \"ParamIdx must be valid to be compared\");\n    // It's possible to compare indices from separate functions, but so far\n    // it's not proven useful.  Moreover, it might be confusing because a\n    // comparison on the results of getASTIndex might be inconsistent with a\n    // comparison on the ParamIdx objects themselves.\n    assert(HasThis == I.HasThis &&\n           \"ParamIdx must be for the same function to be compared\");\n  }\n\npublic:\n  /// Construct an invalid parameter index (\\c isValid returns false and\n  /// accessors fail an assert).\n  ParamIdx() : Idx(0), HasThis(false), IsValid(false) {}\n\n  /// \\param Idx is the parameter index as it is normally specified in\n  /// attributes in the source: one-origin including any C++ implicit this\n  /// parameter.\n  ///\n  /// \\param D is the declaration containing the parameters.  It is used to\n  /// determine if there is a C++ implicit this parameter.\n  ParamIdx(unsigned Idx, const Decl *D)\n      : Idx(Idx), HasThis(false), IsValid(true) {\n    assert(Idx >= 1 && \"Idx must be one-origin\");\n    if (const auto *FD = dyn_cast<FunctionDecl>(D))\n      HasThis = FD->isCXXInstanceMember();\n  }\n\n  /// A type into which \\c ParamIdx can be serialized.\n  ///\n  /// A static assertion that it's of the correct size follows the \\c ParamIdx\n  /// class definition.\n  typedef uint32_t SerialType;\n\n  /// Produce a representation that can later be passed to \\c deserialize to\n  /// construct an equivalent \\c ParamIdx.\n  SerialType serialize() const {\n    return *reinterpret_cast<const SerialType *>(this);\n  }\n\n  /// Construct from a result from \\c serialize.\n  static ParamIdx deserialize(SerialType S) {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC7 and earlier.\n    void *ParamIdxPtr = static_cast<void *>(&S);\n    ParamIdx P(*static_cast<ParamIdx *>(ParamIdxPtr));\n    assert((!P.IsValid || P.Idx >= 1) && \"valid Idx must be one-origin\");\n    return P;\n  }\n\n  /// Is this parameter index valid?\n  bool isValid() const { return IsValid; }\n\n  /// Get the parameter index as it would normally be encoded for attributes at\n  /// the source level of representation: one-origin including any C++ implicit\n  /// this parameter.\n  ///\n  /// This encoding thus makes sense for diagnostics, pretty printing, and\n  /// constructing new attributes from a source-like specification.\n  unsigned getSourceIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    return Idx;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the AST level\n  /// of representation: zero-origin not including any C++ implicit this\n  /// parameter.\n  ///\n  /// This is the encoding primarily used in Sema.  However, in diagnostics,\n  /// Sema uses \\c getSourceIndex instead.\n  unsigned getASTIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 + HasThis &&\n           \"stored index must be base-1 and not specify C++ implicit this\");\n    return Idx - 1 - HasThis;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the LLVM level\n  /// of representation: zero-origin including any C++ implicit this parameter.\n  ///\n  /// This is the encoding primarily used in CodeGen.\n  unsigned getLLVMIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 && \"stored index must be base-1\");\n    return Idx - 1;\n  }\n\n  bool operator==(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx == I.Idx;\n  }\n  bool operator!=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx != I.Idx;\n  }\n  bool operator<(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx < I.Idx;\n  }\n  bool operator>(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx > I.Idx;\n  }\n  bool operator<=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx <= I.Idx;\n  }\n  bool operator>=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx >= I.Idx;\n  }\n};\n\nstatic_assert(sizeof(ParamIdx) == sizeof(ParamIdx::SerialType),\n              \"ParamIdx does not fit its serialization type\");\n\n/// Contains information gathered from parsing the contents of TargetAttr.\nstruct ParsedTargetAttr {\n  std::vector<std::string> Features;\n  StringRef Architecture;\n  StringRef Tune;\n  StringRef BranchProtection;\n  bool DuplicateArchitecture = false;\n  bool DuplicateTune = false;\n  bool operator ==(const ParsedTargetAttr &Other) const {\n    return DuplicateArchitecture == Other.DuplicateArchitecture &&\n           DuplicateTune == Other.DuplicateTune &&\n           Architecture == Other.Architecture &&\n           Tune == Other.Tune &&\n           BranchProtection == Other.BranchProtection &&\n           Features == Other.Features;\n  }\n};\n\n#include \"clang/AST/Attrs.inc\"\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const Attr *At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At),\n                  DiagnosticsEngine::ak_attr);\n  return DB;\n}\n}  // end namespace clang\n\n#endif\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "content": "//===--- Comment.h - Comment AST nodes --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines comment AST nodes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_COMMENT_H\n#define LLVM_CLANG_AST_COMMENT_H\n\n#include \"clang/AST/CommentCommandTraits.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace clang {\nclass Decl;\nclass ParmVarDecl;\nclass TemplateParameterList;\n\nnamespace comments {\nclass FullComment;\n\n/// Describes the syntax that was used in a documentation command.\n///\n/// Exact values of this enumeration are important because they used to select\n/// parts of diagnostic messages.  Audit diagnostics before changing or adding\n/// a new value.\nenum CommandMarkerKind {\n  /// Command started with a backslash character:\n  /// \\code\n  ///   \\foo\n  /// \\endcode\n  CMK_Backslash = 0,\n\n  /// Command started with an 'at' character:\n  /// \\code\n  ///   @foo\n  /// \\endcode\n  CMK_At = 1\n};\n\n/// Any part of the comment.\n/// Abstract class.\nclass Comment {\nprotected:\n  /// Preferred location to show caret.\n  SourceLocation Loc;\n\n  /// Source range of this AST node.\n  SourceRange Range;\n\n  class CommentBitfields {\n    friend class Comment;\n\n    /// Type of this AST node.\n    unsigned Kind : 8;\n  };\n  enum { NumCommentBits = 8 };\n\n  class InlineContentCommentBitfields {\n    friend class InlineContentComment;\n\n    unsigned : NumCommentBits;\n\n    /// True if there is a newline after this inline content node.\n    /// (There is no separate AST node for a newline.)\n    unsigned HasTrailingNewline : 1;\n  };\n  enum { NumInlineContentCommentBits = NumCommentBits + 1 };\n\n  class TextCommentBitfields {\n    friend class TextComment;\n\n    unsigned : NumInlineContentCommentBits;\n\n    /// True if \\c IsWhitespace field contains a valid value.\n    mutable unsigned IsWhitespaceValid : 1;\n\n    /// True if this comment AST node contains only whitespace.\n    mutable unsigned IsWhitespace : 1;\n  };\n  enum { NumTextCommentBits = NumInlineContentCommentBits + 2 };\n\n  class InlineCommandCommentBitfields {\n    friend class InlineCommandComment;\n\n    unsigned : NumInlineContentCommentBits;\n\n    unsigned RenderKind : 3;\n\n    unsigned CommandID : CommandInfo::NumCommandIDBits;\n  };\n  enum { NumInlineCommandCommentBits = NumInlineContentCommentBits + 3 +\n                                       CommandInfo::NumCommandIDBits };\n\n  class HTMLTagCommentBitfields {\n    friend class HTMLTagComment;\n\n    unsigned : NumInlineContentCommentBits;\n\n    /// True if we found that this tag is malformed in some way.\n    unsigned IsMalformed : 1;\n  };\n  enum { NumHTMLTagCommentBits = NumInlineContentCommentBits + 1 };\n\n  class HTMLStartTagCommentBitfields {\n    friend class HTMLStartTagComment;\n\n    unsigned : NumHTMLTagCommentBits;\n\n    /// True if this tag is self-closing (e. g., <br />).  This is based on tag\n    /// spelling in comment (plain <br> would not set this flag).\n    unsigned IsSelfClosing : 1;\n  };\n  enum { NumHTMLStartTagCommentBits = NumHTMLTagCommentBits + 1 };\n\n  class ParagraphCommentBitfields {\n    friend class ParagraphComment;\n\n    unsigned : NumCommentBits;\n\n    /// True if \\c IsWhitespace field contains a valid value.\n    mutable unsigned IsWhitespaceValid : 1;\n\n    /// True if this comment AST node contains only whitespace.\n    mutable unsigned IsWhitespace : 1;\n  };\n  enum { NumParagraphCommentBits = NumCommentBits + 2 };\n\n  class BlockCommandCommentBitfields {\n    friend class BlockCommandComment;\n\n    unsigned : NumCommentBits;\n\n    unsigned CommandID : CommandInfo::NumCommandIDBits;\n\n    /// Describes the syntax that was used in a documentation command.\n    /// Contains values from CommandMarkerKind enum.\n    unsigned CommandMarker : 1;\n  };\n  enum { NumBlockCommandCommentBits = NumCommentBits +\n                                      CommandInfo::NumCommandIDBits + 1 };\n\n  class ParamCommandCommentBitfields {\n    friend class ParamCommandComment;\n\n    unsigned : NumBlockCommandCommentBits;\n\n    /// Parameter passing direction, see ParamCommandComment::PassDirection.\n    unsigned Direction : 2;\n\n    /// True if direction was specified explicitly in the comment.\n    unsigned IsDirectionExplicit : 1;\n  };\n  enum { NumParamCommandCommentBits = NumBlockCommandCommentBits + 3 };\n\n  union {\n    CommentBitfields CommentBits;\n    InlineContentCommentBitfields InlineContentCommentBits;\n    TextCommentBitfields TextCommentBits;\n    InlineCommandCommentBitfields InlineCommandCommentBits;\n    HTMLTagCommentBitfields HTMLTagCommentBits;\n    HTMLStartTagCommentBitfields HTMLStartTagCommentBits;\n    ParagraphCommentBitfields ParagraphCommentBits;\n    BlockCommandCommentBitfields BlockCommandCommentBits;\n    ParamCommandCommentBitfields ParamCommandCommentBits;\n  };\n\n  void setSourceRange(SourceRange SR) {\n    Range = SR;\n  }\n\n  void setLocation(SourceLocation L) {\n    Loc = L;\n  }\n\npublic:\n  enum CommentKind {\n    NoCommentKind = 0,\n#define COMMENT(CLASS, PARENT) CLASS##Kind,\n#define COMMENT_RANGE(BASE, FIRST, LAST) \\\n    First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind,\n#define LAST_COMMENT_RANGE(BASE, FIRST, LAST) \\\n    First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind\n#define ABSTRACT_COMMENT(COMMENT)\n#include \"clang/AST/CommentNodes.inc\"\n  };\n\n  Comment(CommentKind K,\n          SourceLocation LocBegin,\n          SourceLocation LocEnd) :\n      Loc(LocBegin), Range(SourceRange(LocBegin, LocEnd)) {\n    CommentBits.Kind = K;\n  }\n\n  CommentKind getCommentKind() const {\n    return static_cast<CommentKind>(CommentBits.Kind);\n  }\n\n  const char *getCommentKindName() const;\n\n  void dump() const;\n  void dumpColor() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceLocation getLocation() const LLVM_READONLY { return Loc; }\n\n  typedef Comment * const *child_iterator;\n\n  child_iterator child_begin() const;\n  child_iterator child_end() const;\n\n  // TODO: const child iterator\n\n  unsigned child_count() const {\n    return child_end() - child_begin();\n  }\n};\n\n/// Inline content (contained within a block).\n/// Abstract class.\nclass InlineContentComment : public Comment {\nprotected:\n  InlineContentComment(CommentKind K,\n                       SourceLocation LocBegin,\n                       SourceLocation LocEnd) :\n      Comment(K, LocBegin, LocEnd) {\n    InlineContentCommentBits.HasTrailingNewline = 0;\n  }\n\npublic:\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstInlineContentCommentConstant &&\n           C->getCommentKind() <= LastInlineContentCommentConstant;\n  }\n\n  void addTrailingNewline() {\n    InlineContentCommentBits.HasTrailingNewline = 1;\n  }\n\n  bool hasTrailingNewline() const {\n    return InlineContentCommentBits.HasTrailingNewline;\n  }\n};\n\n/// Plain text.\nclass TextComment : public InlineContentComment {\n  StringRef Text;\n\npublic:\n  TextComment(SourceLocation LocBegin,\n              SourceLocation LocEnd,\n              StringRef Text) :\n      InlineContentComment(TextCommentKind, LocBegin, LocEnd),\n      Text(Text) {\n    TextCommentBits.IsWhitespaceValid = false;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == TextCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  StringRef getText() const LLVM_READONLY { return Text; }\n\n  bool isWhitespace() const {\n    if (TextCommentBits.IsWhitespaceValid)\n      return TextCommentBits.IsWhitespace;\n\n    TextCommentBits.IsWhitespace = isWhitespaceNoCache();\n    TextCommentBits.IsWhitespaceValid = true;\n    return TextCommentBits.IsWhitespace;\n  }\n\nprivate:\n  bool isWhitespaceNoCache() const;\n};\n\n/// A command with word-like arguments that is considered inline content.\nclass InlineCommandComment : public InlineContentComment {\npublic:\n  struct Argument {\n    SourceRange Range;\n    StringRef Text;\n\n    Argument(SourceRange Range, StringRef Text) : Range(Range), Text(Text) { }\n  };\n\n  /// The most appropriate rendering mode for this command, chosen on command\n  /// semantics in Doxygen.\n  enum RenderKind {\n    RenderNormal,\n    RenderBold,\n    RenderMonospaced,\n    RenderEmphasized,\n    RenderAnchor\n  };\n\nprotected:\n  /// Command arguments.\n  ArrayRef<Argument> Args;\n\npublic:\n  InlineCommandComment(SourceLocation LocBegin,\n                       SourceLocation LocEnd,\n                       unsigned CommandID,\n                       RenderKind RK,\n                       ArrayRef<Argument> Args) :\n      InlineContentComment(InlineCommandCommentKind, LocBegin, LocEnd),\n      Args(Args) {\n    InlineCommandCommentBits.RenderKind = RK;\n    InlineCommandCommentBits.CommandID = CommandID;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == InlineCommandCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  unsigned getCommandID() const {\n    return InlineCommandCommentBits.CommandID;\n  }\n\n  StringRef getCommandName(const CommandTraits &Traits) const {\n    return Traits.getCommandInfo(getCommandID())->Name;\n  }\n\n  SourceRange getCommandNameRange() const {\n    return SourceRange(getBeginLoc().getLocWithOffset(-1), getEndLoc());\n  }\n\n  RenderKind getRenderKind() const {\n    return static_cast<RenderKind>(InlineCommandCommentBits.RenderKind);\n  }\n\n  unsigned getNumArgs() const {\n    return Args.size();\n  }\n\n  StringRef getArgText(unsigned Idx) const {\n    return Args[Idx].Text;\n  }\n\n  SourceRange getArgRange(unsigned Idx) const {\n    return Args[Idx].Range;\n  }\n};\n\n/// Abstract class for opening and closing HTML tags.  HTML tags are always\n/// treated as inline content (regardless HTML semantics).\nclass HTMLTagComment : public InlineContentComment {\nprotected:\n  StringRef TagName;\n  SourceRange TagNameRange;\n\n  HTMLTagComment(CommentKind K,\n                 SourceLocation LocBegin,\n                 SourceLocation LocEnd,\n                 StringRef TagName,\n                 SourceLocation TagNameBegin,\n                 SourceLocation TagNameEnd) :\n      InlineContentComment(K, LocBegin, LocEnd),\n      TagName(TagName),\n      TagNameRange(TagNameBegin, TagNameEnd) {\n    setLocation(TagNameBegin);\n    HTMLTagCommentBits.IsMalformed = 0;\n  }\n\npublic:\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstHTMLTagCommentConstant &&\n           C->getCommentKind() <= LastHTMLTagCommentConstant;\n  }\n\n  StringRef getTagName() const LLVM_READONLY { return TagName; }\n\n  SourceRange getTagNameSourceRange() const LLVM_READONLY {\n    SourceLocation L = getLocation();\n    return SourceRange(L.getLocWithOffset(1),\n                       L.getLocWithOffset(1 + TagName.size()));\n  }\n\n  bool isMalformed() const {\n    return HTMLTagCommentBits.IsMalformed;\n  }\n\n  void setIsMalformed() {\n    HTMLTagCommentBits.IsMalformed = 1;\n  }\n};\n\n/// An opening HTML tag with attributes.\nclass HTMLStartTagComment : public HTMLTagComment {\npublic:\n  class Attribute {\n  public:\n    SourceLocation NameLocBegin;\n    StringRef Name;\n\n    SourceLocation EqualsLoc;\n\n    SourceRange ValueRange;\n    StringRef Value;\n\n    Attribute() { }\n\n    Attribute(SourceLocation NameLocBegin, StringRef Name) :\n        NameLocBegin(NameLocBegin), Name(Name),\n        EqualsLoc(SourceLocation()),\n        ValueRange(SourceRange()), Value(StringRef())\n    { }\n\n    Attribute(SourceLocation NameLocBegin, StringRef Name,\n              SourceLocation EqualsLoc,\n              SourceRange ValueRange, StringRef Value) :\n        NameLocBegin(NameLocBegin), Name(Name),\n        EqualsLoc(EqualsLoc),\n        ValueRange(ValueRange), Value(Value)\n    { }\n\n    SourceLocation getNameLocEnd() const {\n      return NameLocBegin.getLocWithOffset(Name.size());\n    }\n\n    SourceRange getNameRange() const {\n      return SourceRange(NameLocBegin, getNameLocEnd());\n    }\n  };\n\nprivate:\n  ArrayRef<Attribute> Attributes;\n\npublic:\n  HTMLStartTagComment(SourceLocation LocBegin,\n                      StringRef TagName) :\n      HTMLTagComment(HTMLStartTagCommentKind,\n                     LocBegin, LocBegin.getLocWithOffset(1 + TagName.size()),\n                     TagName,\n                     LocBegin.getLocWithOffset(1),\n                     LocBegin.getLocWithOffset(1 + TagName.size())) {\n    HTMLStartTagCommentBits.IsSelfClosing = false;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == HTMLStartTagCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  unsigned getNumAttrs() const {\n    return Attributes.size();\n  }\n\n  const Attribute &getAttr(unsigned Idx) const {\n    return Attributes[Idx];\n  }\n\n  void setAttrs(ArrayRef<Attribute> Attrs) {\n    Attributes = Attrs;\n    if (!Attrs.empty()) {\n      const Attribute &Attr = Attrs.back();\n      SourceLocation L = Attr.ValueRange.getEnd();\n      if (L.isValid())\n        Range.setEnd(L);\n      else {\n        Range.setEnd(Attr.getNameLocEnd());\n      }\n    }\n  }\n\n  void setGreaterLoc(SourceLocation GreaterLoc) {\n    Range.setEnd(GreaterLoc);\n  }\n\n  bool isSelfClosing() const {\n    return HTMLStartTagCommentBits.IsSelfClosing;\n  }\n\n  void setSelfClosing() {\n    HTMLStartTagCommentBits.IsSelfClosing = true;\n  }\n};\n\n/// A closing HTML tag.\nclass HTMLEndTagComment : public HTMLTagComment {\npublic:\n  HTMLEndTagComment(SourceLocation LocBegin,\n                    SourceLocation LocEnd,\n                    StringRef TagName) :\n      HTMLTagComment(HTMLEndTagCommentKind,\n                     LocBegin, LocEnd,\n                     TagName,\n                     LocBegin.getLocWithOffset(2),\n                     LocBegin.getLocWithOffset(2 + TagName.size()))\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == HTMLEndTagCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n};\n\n/// Block content (contains inline content).\n/// Abstract class.\nclass BlockContentComment : public Comment {\nprotected:\n  BlockContentComment(CommentKind K,\n                      SourceLocation LocBegin,\n                      SourceLocation LocEnd) :\n      Comment(K, LocBegin, LocEnd)\n  { }\n\npublic:\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstBlockContentCommentConstant &&\n           C->getCommentKind() <= LastBlockContentCommentConstant;\n  }\n};\n\n/// A single paragraph that contains inline content.\nclass ParagraphComment : public BlockContentComment {\n  ArrayRef<InlineContentComment *> Content;\n\npublic:\n  ParagraphComment(ArrayRef<InlineContentComment *> Content) :\n      BlockContentComment(ParagraphCommentKind,\n                          SourceLocation(),\n                          SourceLocation()),\n      Content(Content) {\n    if (Content.empty()) {\n      ParagraphCommentBits.IsWhitespace = true;\n      ParagraphCommentBits.IsWhitespaceValid = true;\n      return;\n    }\n\n    ParagraphCommentBits.IsWhitespaceValid = false;\n\n    setSourceRange(SourceRange(Content.front()->getBeginLoc(),\n                               Content.back()->getEndLoc()));\n    setLocation(Content.front()->getBeginLoc());\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == ParagraphCommentKind;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(Content.begin());\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(Content.end());\n  }\n\n  bool isWhitespace() const {\n    if (ParagraphCommentBits.IsWhitespaceValid)\n      return ParagraphCommentBits.IsWhitespace;\n\n    ParagraphCommentBits.IsWhitespace = isWhitespaceNoCache();\n    ParagraphCommentBits.IsWhitespaceValid = true;\n    return ParagraphCommentBits.IsWhitespace;\n  }\n\nprivate:\n  bool isWhitespaceNoCache() const;\n};\n\n/// A command that has zero or more word-like arguments (number of word-like\n/// arguments depends on command name) and a paragraph as an argument\n/// (e. g., \\\\brief).\nclass BlockCommandComment : public BlockContentComment {\npublic:\n  struct Argument {\n    SourceRange Range;\n    StringRef Text;\n\n    Argument() { }\n    Argument(SourceRange Range, StringRef Text) : Range(Range), Text(Text) { }\n  };\n\nprotected:\n  /// Word-like arguments.\n  ArrayRef<Argument> Args;\n\n  /// Paragraph argument.\n  ParagraphComment *Paragraph;\n\n  BlockCommandComment(CommentKind K,\n                      SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockContentComment(K, LocBegin, LocEnd),\n      Paragraph(nullptr) {\n    setLocation(getCommandNameBeginLoc());\n    BlockCommandCommentBits.CommandID = CommandID;\n    BlockCommandCommentBits.CommandMarker = CommandMarker;\n  }\n\npublic:\n  BlockCommandComment(SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockContentComment(BlockCommandCommentKind, LocBegin, LocEnd),\n      Paragraph(nullptr) {\n    setLocation(getCommandNameBeginLoc());\n    BlockCommandCommentBits.CommandID = CommandID;\n    BlockCommandCommentBits.CommandMarker = CommandMarker;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstBlockCommandCommentConstant &&\n           C->getCommentKind() <= LastBlockCommandCommentConstant;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(&Paragraph);\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(&Paragraph + 1);\n  }\n\n  unsigned getCommandID() const {\n    return BlockCommandCommentBits.CommandID;\n  }\n\n  StringRef getCommandName(const CommandTraits &Traits) const {\n    return Traits.getCommandInfo(getCommandID())->Name;\n  }\n\n  SourceLocation getCommandNameBeginLoc() const {\n    return getBeginLoc().getLocWithOffset(1);\n  }\n\n  SourceRange getCommandNameRange(const CommandTraits &Traits) const {\n    StringRef Name = getCommandName(Traits);\n    return SourceRange(getCommandNameBeginLoc(),\n                       getBeginLoc().getLocWithOffset(1 + Name.size()));\n  }\n\n  unsigned getNumArgs() const {\n    return Args.size();\n  }\n\n  StringRef getArgText(unsigned Idx) const {\n    return Args[Idx].Text;\n  }\n\n  SourceRange getArgRange(unsigned Idx) const {\n    return Args[Idx].Range;\n  }\n\n  void setArgs(ArrayRef<Argument> A) {\n    Args = A;\n    if (Args.size() > 0) {\n      SourceLocation NewLocEnd = Args.back().Range.getEnd();\n      if (NewLocEnd.isValid())\n        setSourceRange(SourceRange(getBeginLoc(), NewLocEnd));\n    }\n  }\n\n  ParagraphComment *getParagraph() const LLVM_READONLY {\n    return Paragraph;\n  }\n\n  bool hasNonWhitespaceParagraph() const {\n    return Paragraph && !Paragraph->isWhitespace();\n  }\n\n  void setParagraph(ParagraphComment *PC) {\n    Paragraph = PC;\n    SourceLocation NewLocEnd = PC->getEndLoc();\n    if (NewLocEnd.isValid())\n      setSourceRange(SourceRange(getBeginLoc(), NewLocEnd));\n  }\n\n  CommandMarkerKind getCommandMarker() const LLVM_READONLY {\n    return static_cast<CommandMarkerKind>(\n        BlockCommandCommentBits.CommandMarker);\n  }\n};\n\n/// Doxygen \\\\param command.\nclass ParamCommandComment : public BlockCommandComment {\nprivate:\n  /// Parameter index in the function declaration.\n  unsigned ParamIndex;\n\npublic:\n  enum : unsigned {\n    InvalidParamIndex = ~0U,\n    VarArgParamIndex = ~0U/*InvalidParamIndex*/ - 1U\n  };\n\n  ParamCommandComment(SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockCommandComment(ParamCommandCommentKind, LocBegin, LocEnd,\n                          CommandID, CommandMarker),\n      ParamIndex(InvalidParamIndex) {\n    ParamCommandCommentBits.Direction = In;\n    ParamCommandCommentBits.IsDirectionExplicit = false;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == ParamCommandCommentKind;\n  }\n\n  enum PassDirection {\n    In,\n    Out,\n    InOut\n  };\n\n  static const char *getDirectionAsString(PassDirection D);\n\n  PassDirection getDirection() const LLVM_READONLY {\n    return static_cast<PassDirection>(ParamCommandCommentBits.Direction);\n  }\n\n  bool isDirectionExplicit() const LLVM_READONLY {\n    return ParamCommandCommentBits.IsDirectionExplicit;\n  }\n\n  void setDirection(PassDirection Direction, bool Explicit) {\n    ParamCommandCommentBits.Direction = Direction;\n    ParamCommandCommentBits.IsDirectionExplicit = Explicit;\n  }\n\n  bool hasParamName() const {\n    return getNumArgs() > 0;\n  }\n\n  StringRef getParamName(const FullComment *FC) const;\n\n  StringRef getParamNameAsWritten() const {\n    return Args[0].Text;\n  }\n\n  SourceRange getParamNameRange() const {\n    return Args[0].Range;\n  }\n\n  bool isParamIndexValid() const LLVM_READONLY {\n    return ParamIndex != InvalidParamIndex;\n  }\n\n  bool isVarArgParam() const LLVM_READONLY {\n    return ParamIndex == VarArgParamIndex;\n  }\n\n  void setIsVarArgParam() {\n    ParamIndex = VarArgParamIndex;\n    assert(isParamIndexValid());\n  }\n\n  unsigned getParamIndex() const LLVM_READONLY {\n    assert(isParamIndexValid());\n    assert(!isVarArgParam());\n    return ParamIndex;\n  }\n\n  void setParamIndex(unsigned Index) {\n    ParamIndex = Index;\n    assert(isParamIndexValid());\n    assert(!isVarArgParam());\n  }\n};\n\n/// Doxygen \\\\tparam command, describes a template parameter.\nclass TParamCommandComment : public BlockCommandComment {\nprivate:\n  /// If this template parameter name was resolved (found in template parameter\n  /// list), then this stores a list of position indexes in all template\n  /// parameter lists.\n  ///\n  /// For example:\n  /// \\verbatim\n  ///     template<typename C, template<typename T> class TT>\n  ///     void test(TT<int> aaa);\n  /// \\endverbatim\n  /// For C:  Position = { 0 }\n  /// For TT: Position = { 1 }\n  /// For T:  Position = { 1, 0 }\n  ArrayRef<unsigned> Position;\n\npublic:\n  TParamCommandComment(SourceLocation LocBegin,\n                       SourceLocation LocEnd,\n                       unsigned CommandID,\n                       CommandMarkerKind CommandMarker) :\n      BlockCommandComment(TParamCommandCommentKind, LocBegin, LocEnd, CommandID,\n                          CommandMarker)\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == TParamCommandCommentKind;\n  }\n\n  bool hasParamName() const {\n    return getNumArgs() > 0;\n  }\n\n  StringRef getParamName(const FullComment *FC) const;\n\n  StringRef getParamNameAsWritten() const {\n    return Args[0].Text;\n  }\n\n  SourceRange getParamNameRange() const {\n    return Args[0].Range;\n  }\n\n  bool isPositionValid() const LLVM_READONLY {\n    return !Position.empty();\n  }\n\n  unsigned getDepth() const {\n    assert(isPositionValid());\n    return Position.size();\n  }\n\n  unsigned getIndex(unsigned Depth) const {\n    assert(isPositionValid());\n    return Position[Depth];\n  }\n\n  void setPosition(ArrayRef<unsigned> NewPosition) {\n    Position = NewPosition;\n    assert(isPositionValid());\n  }\n};\n\n/// A line of text contained in a verbatim block.\nclass VerbatimBlockLineComment : public Comment {\n  StringRef Text;\n\npublic:\n  VerbatimBlockLineComment(SourceLocation LocBegin,\n                           StringRef Text) :\n      Comment(VerbatimBlockLineCommentKind,\n              LocBegin,\n              LocBegin.getLocWithOffset(Text.size())),\n      Text(Text)\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == VerbatimBlockLineCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  StringRef getText() const LLVM_READONLY {\n    return Text;\n  }\n};\n\n/// A verbatim block command (e. g., preformatted code).  Verbatim block has an\n/// opening and a closing command and contains multiple lines of text\n/// (VerbatimBlockLineComment nodes).\nclass VerbatimBlockComment : public BlockCommandComment {\nprotected:\n  StringRef CloseName;\n  SourceLocation CloseNameLocBegin;\n  ArrayRef<VerbatimBlockLineComment *> Lines;\n\npublic:\n  VerbatimBlockComment(SourceLocation LocBegin,\n                       SourceLocation LocEnd,\n                       unsigned CommandID) :\n      BlockCommandComment(VerbatimBlockCommentKind,\n                          LocBegin, LocEnd, CommandID,\n                          CMK_At) // FIXME: improve source fidelity.\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == VerbatimBlockCommentKind;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(Lines.begin());\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(Lines.end());\n  }\n\n  void setCloseName(StringRef Name, SourceLocation LocBegin) {\n    CloseName = Name;\n    CloseNameLocBegin = LocBegin;\n  }\n\n  void setLines(ArrayRef<VerbatimBlockLineComment *> L) {\n    Lines = L;\n  }\n\n  StringRef getCloseName() const {\n    return CloseName;\n  }\n\n  unsigned getNumLines() const {\n    return Lines.size();\n  }\n\n  StringRef getText(unsigned LineIdx) const {\n    return Lines[LineIdx]->getText();\n  }\n};\n\n/// A verbatim line command.  Verbatim line has an opening command, a single\n/// line of text (up to the newline after the opening command) and has no\n/// closing command.\nclass VerbatimLineComment : public BlockCommandComment {\nprotected:\n  StringRef Text;\n  SourceLocation TextBegin;\n\npublic:\n  VerbatimLineComment(SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      SourceLocation TextBegin,\n                      StringRef Text) :\n      BlockCommandComment(VerbatimLineCommentKind,\n                          LocBegin, LocEnd,\n                          CommandID,\n                          CMK_At), // FIXME: improve source fidelity.\n      Text(Text),\n      TextBegin(TextBegin)\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == VerbatimLineCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  StringRef getText() const {\n    return Text;\n  }\n\n  SourceRange getTextRange() const {\n    return SourceRange(TextBegin, getEndLoc());\n  }\n};\n\n/// Information about the declaration, useful to clients of FullComment.\nstruct DeclInfo {\n  /// Declaration the comment is actually attached to (in the source).\n  /// Should not be NULL.\n  const Decl *CommentDecl;\n\n  /// CurrentDecl is the declaration with which the FullComment is associated.\n  ///\n  /// It can be different from \\c CommentDecl.  It happens when we decide\n  /// that the comment originally attached to \\c CommentDecl is fine for\n  /// \\c CurrentDecl too (for example, for a redeclaration or an overrider of\n  /// \\c CommentDecl).\n  ///\n  /// The information in the DeclInfo corresponds to CurrentDecl.\n  const Decl *CurrentDecl;\n\n  /// Parameters that can be referenced by \\\\param if \\c CommentDecl is something\n  /// that we consider a \"function\".\n  ArrayRef<const ParmVarDecl *> ParamVars;\n\n  /// Function return type if \\c CommentDecl is something that we consider\n  /// a \"function\".\n  QualType ReturnType;\n\n  /// Template parameters that can be referenced by \\\\tparam if \\c CommentDecl is\n  /// a template (\\c IsTemplateDecl or \\c IsTemplatePartialSpecialization is\n  /// true).\n  const TemplateParameterList *TemplateParameters;\n\n  /// A simplified description of \\c CommentDecl kind that should be good enough\n  /// for documentation rendering purposes.\n  enum DeclKind {\n    /// Everything else not explicitly mentioned below.\n    OtherKind,\n\n    /// Something that we consider a \"function\":\n    /// \\li function,\n    /// \\li function template,\n    /// \\li function template specialization,\n    /// \\li member function,\n    /// \\li member function template,\n    /// \\li member function template specialization,\n    /// \\li ObjC method,\n    /// \\li a typedef for a function pointer, member function pointer,\n    ///     ObjC block.\n    FunctionKind,\n\n    /// Something that we consider a \"class\":\n    /// \\li class/struct,\n    /// \\li class template,\n    /// \\li class template (partial) specialization.\n    ClassKind,\n\n    /// Something that we consider a \"variable\":\n    /// \\li namespace scope variables;\n    /// \\li static and non-static class data members;\n    /// \\li enumerators.\n    VariableKind,\n\n    /// A C++ namespace.\n    NamespaceKind,\n\n    /// A C++ typedef-name (a 'typedef' decl specifier or alias-declaration),\n    /// see \\c TypedefNameDecl.\n    TypedefKind,\n\n    /// An enumeration or scoped enumeration.\n    EnumKind\n  };\n\n  /// What kind of template specialization \\c CommentDecl is.\n  enum TemplateDeclKind {\n    NotTemplate,\n    Template,\n    TemplateSpecialization,\n    TemplatePartialSpecialization\n  };\n\n  /// If false, only \\c CommentDecl is valid.\n  unsigned IsFilled : 1;\n\n  /// Simplified kind of \\c CommentDecl, see \\c DeclKind enum.\n  unsigned Kind : 3;\n\n  /// Is \\c CommentDecl a template declaration.\n  unsigned TemplateKind : 2;\n\n  /// Is \\c CommentDecl an ObjCMethodDecl.\n  unsigned IsObjCMethod : 1;\n\n  /// Is \\c CommentDecl a non-static member function of C++ class or\n  /// instance method of ObjC class.\n  /// Can be true only if \\c IsFunctionDecl is true.\n  unsigned IsInstanceMethod : 1;\n\n  /// Is \\c CommentDecl a static member function of C++ class or\n  /// class method of ObjC class.\n  /// Can be true only if \\c IsFunctionDecl is true.\n  unsigned IsClassMethod : 1;\n\n  void fill();\n\n  DeclKind getKind() const LLVM_READONLY {\n    return static_cast<DeclKind>(Kind);\n  }\n\n  TemplateDeclKind getTemplateKind() const LLVM_READONLY {\n    return static_cast<TemplateDeclKind>(TemplateKind);\n  }\n};\n\n/// A full comment attached to a declaration, contains block content.\nclass FullComment : public Comment {\n  ArrayRef<BlockContentComment *> Blocks;\n  DeclInfo *ThisDeclInfo;\n\npublic:\n  FullComment(ArrayRef<BlockContentComment *> Blocks, DeclInfo *D) :\n      Comment(FullCommentKind, SourceLocation(), SourceLocation()),\n      Blocks(Blocks), ThisDeclInfo(D) {\n    if (Blocks.empty())\n      return;\n\n    setSourceRange(\n        SourceRange(Blocks.front()->getBeginLoc(), Blocks.back()->getEndLoc()));\n    setLocation(Blocks.front()->getBeginLoc());\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == FullCommentKind;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(Blocks.begin());\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(Blocks.end());\n  }\n\n  const Decl *getDecl() const LLVM_READONLY {\n    return ThisDeclInfo->CommentDecl;\n  }\n\n  const DeclInfo *getDeclInfo() const LLVM_READONLY {\n    if (!ThisDeclInfo->IsFilled)\n      ThisDeclInfo->fill();\n    return ThisDeclInfo;\n  }\n\n  ArrayRef<BlockContentComment *> getBlocks() const { return Blocks; }\n\n};\n} // end namespace comments\n} // end namespace clang\n\n#endif\n\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclOpenMP.h", "content": "//===- DeclOpenMP.h - Classes for representing OpenMP directives -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file defines OpenMP nodes for declarative directives.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLOPENMP_H\n#define LLVM_CLANG_AST_DECLOPENMP_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n\n/// This is a basic class for representing single OpenMP declarative directive.\n///\ntemplate <typename U> class OMPDeclarativeDirective : public U {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\nprotected:\n  /// Data, associated with the directive.\n  OMPChildren *Data = nullptr;\n\n  /// Build instance of directive.\n  template <typename... Params>\n  OMPDeclarativeDirective(Params &&... P) : U(std::forward<Params>(P)...) {}\n\n  template <typename T, typename... Params>\n  static T *createDirective(const ASTContext &C, DeclContext *DC,\n                            ArrayRef<OMPClause *> Clauses, unsigned NumChildren,\n                            Params &&... P) {\n    auto *Inst = new (C, DC, size(Clauses.size(), NumChildren))\n        T(DC, std::forward<Params>(P)...);\n    Inst->Data = OMPChildren::Create(Inst + 1, Clauses,\n                                     /*AssociatedStmt=*/nullptr, NumChildren);\n    Inst->Data->setClauses(Clauses);\n    return Inst;\n  }\n\n  template <typename T, typename... Params>\n  static T *createEmptyDirective(const ASTContext &C, unsigned ID,\n                                 unsigned NumClauses, unsigned NumChildren,\n                                 Params &&... P) {\n    auto *Inst = new (C, ID, size(NumClauses, NumChildren))\n        T(nullptr, std::forward<Params>(P)...);\n    Inst->Data = OMPChildren::CreateEmpty(\n        Inst + 1, NumClauses, /*HasAssociatedStmt=*/false, NumChildren);\n    return Inst;\n  }\n\n  static size_t size(unsigned NumClauses, unsigned NumChildren) {\n    return OMPChildren::size(NumClauses, /*HasAssociatedStmt=*/false,\n                             NumChildren);\n  }\n\npublic:\n  /// Get number of clauses.\n  unsigned getNumClauses() const {\n    if (!Data)\n      return 0;\n    return Data->getNumClauses();\n  }\n\n  /// Returns specified clause.\n  ///\n  /// \\param I Number of clause.\n  ///\n  OMPClause *getClause(unsigned I) const { return clauses()[I]; }\n\n  ArrayRef<OMPClause *> clauses() const {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n};\n\n/// This represents '#pragma omp threadprivate ...' directive.\n/// For example, in the following, both 'a' and 'A::b' are threadprivate:\n///\n/// \\code\n/// int a;\n/// #pragma omp threadprivate(a)\n/// struct A {\n///   static int b;\n/// #pragma omp threadprivate(b)\n/// };\n/// \\endcode\n///\nclass OMPThreadPrivateDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n\n  virtual void anchor();\n\n  OMPThreadPrivateDecl(DeclContext *DC = nullptr,\n                       SourceLocation L = SourceLocation())\n      : OMPDeclarativeDirective<Decl>(OMPThreadPrivate, DC, L) {}\n\n  ArrayRef<const Expr *> getVars() const {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeArrayRef(Storage, Data->getNumChildren());\n  }\n\n  MutableArrayRef<Expr *> getVars() {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeMutableArrayRef(Storage, Data->getNumChildren());\n  }\n\n  void setVars(ArrayRef<Expr *> VL);\n\npublic:\n  static OMPThreadPrivateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      ArrayRef<Expr *> VL);\n  static OMPThreadPrivateDecl *CreateDeserialized(ASTContext &C,\n                                                  unsigned ID, unsigned N);\n\n  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;\n  typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;\n  typedef llvm::iterator_range<varlist_iterator> varlist_range;\n  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;\n\n  unsigned varlist_size() const { return Data->getNumChildren(); }\n  bool varlist_empty() const { return Data->getChildren().empty(); }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n  varlist_iterator varlist_begin() { return getVars().begin(); }\n  varlist_iterator varlist_end() { return getVars().end(); }\n  varlist_const_iterator varlist_begin() const { return getVars().begin(); }\n  varlist_const_iterator varlist_end() const { return getVars().end(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPThreadPrivate; }\n};\n\n/// This represents '#pragma omp declare reduction ...' directive.\n/// For example, in the following, declared reduction 'foo' for types 'int' and\n/// 'float':\n///\n/// \\code\n/// #pragma omp declare reduction (foo : int,float : omp_out += omp_in)\n///                     initializer (omp_priv = 0)\n/// \\endcode\n///\n/// Here 'omp_out += omp_in' is a combiner and 'omp_priv = 0' is an initializer.\nclass OMPDeclareReductionDecl final : public ValueDecl, public DeclContext {\n  // This class stores some data in DeclContext::OMPDeclareReductionDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  enum InitKind {\n    CallInit,   // Initialized by function call.\n    DirectInit, // omp_priv(<expr>)\n    CopyInit    // omp_priv = <expr>\n  };\n\nprivate:\n  friend class ASTDeclReader;\n  /// Combiner for declare reduction construct.\n  Expr *Combiner = nullptr;\n  /// Initializer for declare reduction construct.\n  Expr *Initializer = nullptr;\n  /// In parameter of the combiner.\n  Expr *In = nullptr;\n  /// Out parameter of the combiner.\n  Expr *Out = nullptr;\n  /// Priv parameter of the initializer.\n  Expr *Priv = nullptr;\n  /// Orig parameter of the initializer.\n  Expr *Orig = nullptr;\n\n  /// Reference to the previous declare reduction construct in the same\n  /// scope with the same name. Required for proper templates instantiation if\n  /// the declare reduction construct is declared inside compound statement.\n  LazyDeclPtr PrevDeclInScope;\n\n  void anchor() override;\n\n  OMPDeclareReductionDecl(Kind DK, DeclContext *DC, SourceLocation L,\n                          DeclarationName Name, QualType Ty,\n                          OMPDeclareReductionDecl *PrevDeclInScope);\n\n  void setPrevDeclInScope(OMPDeclareReductionDecl *Prev) {\n    PrevDeclInScope = Prev;\n  }\n\npublic:\n  /// Create declare reduction node.\n  static OMPDeclareReductionDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation L, DeclarationName Name,\n         QualType T, OMPDeclareReductionDecl *PrevDeclInScope);\n  /// Create deserialized declare reduction node.\n  static OMPDeclareReductionDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Get combiner expression of the declare reduction construct.\n  Expr *getCombiner() { return Combiner; }\n  const Expr *getCombiner() const { return Combiner; }\n  /// Get In variable of the combiner.\n  Expr *getCombinerIn() { return In; }\n  const Expr *getCombinerIn() const { return In; }\n  /// Get Out variable of the combiner.\n  Expr *getCombinerOut() { return Out; }\n  const Expr *getCombinerOut() const { return Out; }\n  /// Set combiner expression for the declare reduction construct.\n  void setCombiner(Expr *E) { Combiner = E; }\n  /// Set combiner In and Out vars.\n  void setCombinerData(Expr *InE, Expr *OutE) {\n    In = InE;\n    Out = OutE;\n  }\n\n  /// Get initializer expression (if specified) of the declare reduction\n  /// construct.\n  Expr *getInitializer() { return Initializer; }\n  const Expr *getInitializer() const { return Initializer; }\n  /// Get initializer kind.\n  InitKind getInitializerKind() const {\n    return static_cast<InitKind>(OMPDeclareReductionDeclBits.InitializerKind);\n  }\n  /// Get Orig variable of the initializer.\n  Expr *getInitOrig() { return Orig; }\n  const Expr *getInitOrig() const { return Orig; }\n  /// Get Priv variable of the initializer.\n  Expr *getInitPriv() { return Priv; }\n  const Expr *getInitPriv() const { return Priv; }\n  /// Set initializer expression for the declare reduction construct.\n  void setInitializer(Expr *E, InitKind IK) {\n    Initializer = E;\n    OMPDeclareReductionDeclBits.InitializerKind = IK;\n  }\n  /// Set initializer Orig and Priv vars.\n  void setInitializerData(Expr *OrigE, Expr *PrivE) {\n    Orig = OrigE;\n    Priv = PrivE;\n  }\n\n  /// Get reference to previous declare reduction construct in the same\n  /// scope with the same name.\n  OMPDeclareReductionDecl *getPrevDeclInScope();\n  const OMPDeclareReductionDecl *getPrevDeclInScope() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPDeclareReduction; }\n  static DeclContext *castToDeclContext(const OMPDeclareReductionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<OMPDeclareReductionDecl *>(D));\n  }\n  static OMPDeclareReductionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<OMPDeclareReductionDecl *>(\n        const_cast<DeclContext *>(DC));\n  }\n};\n\n/// This represents '#pragma omp declare mapper ...' directive. Map clauses are\n/// allowed to use with this directive. The following example declares a user\n/// defined mapper for the type 'struct vec'. This example instructs the fields\n/// 'len' and 'data' should be mapped when mapping instances of 'struct vec'.\n///\n/// \\code\n/// #pragma omp declare mapper(mid: struct vec v) map(v.len, v.data[0:N])\n/// \\endcode\nclass OMPDeclareMapperDecl final : public OMPDeclarativeDirective<ValueDecl>,\n                                   public DeclContext {\n  friend class OMPDeclarativeDirective<ValueDecl>;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Mapper variable, which is 'v' in the example above\n  Expr *MapperVarRef = nullptr;\n\n  /// Name of the mapper variable\n  DeclarationName VarName;\n\n  LazyDeclPtr PrevDeclInScope;\n\n  void anchor() override;\n\n  OMPDeclareMapperDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n                       QualType Ty, DeclarationName VarName,\n                       OMPDeclareMapperDecl *PrevDeclInScope)\n      : OMPDeclarativeDirective<ValueDecl>(OMPDeclareMapper, DC, L, Name, Ty),\n        DeclContext(OMPDeclareMapper), VarName(VarName),\n        PrevDeclInScope(PrevDeclInScope) {}\n\n  void setPrevDeclInScope(OMPDeclareMapperDecl *Prev) {\n    PrevDeclInScope = Prev;\n  }\n\npublic:\n  /// Creates declare mapper node.\n  static OMPDeclareMapperDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L, DeclarationName Name,\n                                      QualType T, DeclarationName VarName,\n                                      ArrayRef<OMPClause *> Clauses,\n                                      OMPDeclareMapperDecl *PrevDeclInScope);\n  /// Creates deserialized declare mapper node.\n  static OMPDeclareMapperDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                  unsigned N);\n\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range =\n      llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  /// Get the variable declared in the mapper\n  Expr *getMapperVarRef() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n  const Expr *getMapperVarRef() const {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  /// Set the variable declared in the mapper\n  void setMapperVarRef(Expr *MapperVarRefE) {\n    Data->getChildren()[0] = MapperVarRefE;\n  }\n\n  /// Get the name of the variable declared in the mapper\n  DeclarationName getVarName() { return VarName; }\n\n  /// Get reference to previous declare mapper construct in the same\n  /// scope with the same name.\n  OMPDeclareMapperDecl *getPrevDeclInScope();\n  const OMPDeclareMapperDecl *getPrevDeclInScope() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPDeclareMapper; }\n  static DeclContext *castToDeclContext(const OMPDeclareMapperDecl *D) {\n    return static_cast<DeclContext *>(const_cast<OMPDeclareMapperDecl *>(D));\n  }\n  static OMPDeclareMapperDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<OMPDeclareMapperDecl *>(const_cast<DeclContext *>(DC));\n  }\n};\n\n/// Pseudo declaration for capturing expressions. Also is used for capturing of\n/// non-static data members in non-static member functions.\n///\n/// Clang supports capturing of variables only, but OpenMP 4.5 allows to\n/// privatize non-static members of current class in non-static member\n/// functions. This pseudo-declaration allows properly handle this kind of\n/// capture by wrapping captured expression into a variable-like declaration.\nclass OMPCapturedExprDecl final : public VarDecl {\n  friend class ASTDeclReader;\n  void anchor() override;\n\n  OMPCapturedExprDecl(ASTContext &C, DeclContext *DC, IdentifierInfo *Id,\n                      QualType Type, TypeSourceInfo *TInfo,\n                      SourceLocation StartLoc)\n      : VarDecl(OMPCapturedExpr, C, DC, StartLoc, StartLoc, Id, Type, TInfo,\n                SC_None) {\n    setImplicit();\n  }\n\npublic:\n  static OMPCapturedExprDecl *Create(ASTContext &C, DeclContext *DC,\n                                     IdentifierInfo *Id, QualType T,\n                                     SourceLocation StartLoc);\n\n  static OMPCapturedExprDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPCapturedExpr; }\n};\n\n/// This represents '#pragma omp requires...' directive.\n/// For example\n///\n/// \\code\n/// #pragma omp requires unified_address\n/// \\endcode\n///\nclass OMPRequiresDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n  friend class ASTDeclReader;\n\n  virtual void anchor();\n\n  OMPRequiresDecl(DeclContext *DC, SourceLocation L)\n      : OMPDeclarativeDirective<Decl>(OMPRequires, DC, L) {}\n\npublic:\n  /// Create requires node.\n  static OMPRequiresDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, ArrayRef<OMPClause *> CL);\n  /// Create deserialized requires node.\n  static OMPRequiresDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                             unsigned N);\n\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range = llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPRequires; }\n};\n\n/// This represents '#pragma omp allocate ...' directive.\n/// For example, in the following, the default allocator is used for both 'a'\n/// and 'A::b':\n///\n/// \\code\n/// int a;\n/// #pragma omp allocate(a)\n/// struct A {\n///   static int b;\n/// #pragma omp allocate(b)\n/// };\n/// \\endcode\n///\nclass OMPAllocateDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n  friend class ASTDeclReader;\n\n  virtual void anchor();\n\n  OMPAllocateDecl(DeclContext *DC, SourceLocation L)\n      : OMPDeclarativeDirective<Decl>(OMPAllocate, DC, L) {}\n\n  ArrayRef<const Expr *> getVars() const {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeArrayRef(Storage, Data->getNumChildren());\n  }\n\n  MutableArrayRef<Expr *> getVars() {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeMutableArrayRef(Storage, Data->getNumChildren());\n  }\n\n  void setVars(ArrayRef<Expr *> VL);\n\npublic:\n  static OMPAllocateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, ArrayRef<Expr *> VL,\n                                 ArrayRef<OMPClause *> CL);\n  static OMPAllocateDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                             unsigned NVars, unsigned NClauses);\n\n  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;\n  typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;\n  typedef llvm::iterator_range<varlist_iterator> varlist_range;\n  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range = llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned varlist_size() const { return Data->getNumChildren(); }\n  bool varlist_empty() const { return Data->getChildren().empty(); }\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n  varlist_iterator varlist_begin() { return getVars().begin(); }\n  varlist_iterator varlist_end() { return getVars().end(); }\n  varlist_const_iterator varlist_begin() const { return getVars().begin(); }\n  varlist_const_iterator varlist_end() const { return getVars().end(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPAllocate; }\n};\n\n} // end namespace clang\n\n#endif\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprConcepts.h", "content": "//===- ExprConcepts.h - C++2a Concepts expressions --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines Expressions and AST nodes for C++2a concepts.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPRCONCEPTS_H\n#define LLVM_CLANG_AST_EXPRCONCEPTS_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <utility>\n#include <string>\n\nnamespace clang {\nclass ASTStmtReader;\nclass ASTStmtWriter;\n\n/// \\brief Represents the specialization of a concept - evaluates to a prvalue\n/// of type bool.\n///\n/// According to C++2a [expr.prim.id]p3 an id-expression that denotes the\n/// specialization of a concept results in a prvalue of type bool.\nclass ConceptSpecializationExpr final : public Expr, public ConceptReference,\n      private llvm::TrailingObjects<ConceptSpecializationExpr,\n                                    TemplateArgument> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\npublic:\n  using SubstitutionDiagnostic = std::pair<SourceLocation, std::string>;\n\nprotected:\n  /// \\brief The number of template arguments in the tail-allocated list of\n  /// converted template arguments.\n  unsigned NumTemplateArgs;\n\n  /// \\brief Information about the satisfaction of the named concept with the\n  /// given arguments. If this expression is value dependent, this is to be\n  /// ignored.\n  ASTConstraintSatisfaction *Satisfaction;\n\n  ConceptSpecializationExpr(const ASTContext &C, NestedNameSpecifierLoc NNS,\n                            SourceLocation TemplateKWLoc,\n                            DeclarationNameInfo ConceptNameInfo,\n                            NamedDecl *FoundDecl, ConceptDecl *NamedConcept,\n                            const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                            ArrayRef<TemplateArgument> ConvertedArgs,\n                            const ConstraintSatisfaction *Satisfaction);\n\n  ConceptSpecializationExpr(const ASTContext &C, ConceptDecl *NamedConcept,\n                            ArrayRef<TemplateArgument> ConvertedArgs,\n                            const ConstraintSatisfaction *Satisfaction,\n                            bool Dependent,\n                            bool ContainsUnexpandedParameterPack);\n\n  ConceptSpecializationExpr(EmptyShell Empty, unsigned NumTemplateArgs);\n\npublic:\n\n  static ConceptSpecializationExpr *\n  Create(const ASTContext &C, NestedNameSpecifierLoc NNS,\n         SourceLocation TemplateKWLoc, DeclarationNameInfo ConceptNameInfo,\n         NamedDecl *FoundDecl, ConceptDecl *NamedConcept,\n         const ASTTemplateArgumentListInfo *ArgsAsWritten,\n         ArrayRef<TemplateArgument> ConvertedArgs,\n         const ConstraintSatisfaction *Satisfaction);\n\n  static ConceptSpecializationExpr *\n  Create(const ASTContext &C, ConceptDecl *NamedConcept,\n         ArrayRef<TemplateArgument> ConvertedArgs,\n         const ConstraintSatisfaction *Satisfaction,\n         bool Dependent,\n         bool ContainsUnexpandedParameterPack);\n\n  static ConceptSpecializationExpr *\n  Create(ASTContext &C, EmptyShell Empty, unsigned NumTemplateArgs);\n\n  ArrayRef<TemplateArgument> getTemplateArguments() const {\n    return ArrayRef<TemplateArgument>(getTrailingObjects<TemplateArgument>(),\n                                      NumTemplateArgs);\n  }\n\n  /// \\brief Set new template arguments for this concept specialization.\n  void setTemplateArguments(ArrayRef<TemplateArgument> Converted);\n\n  /// \\brief Whether or not the concept with the given arguments was satisfied\n  /// when the expression was created.\n  /// The expression must not be dependent.\n  bool isSatisfied() const {\n    assert(!isValueDependent()\n           && \"isSatisfied called on a dependent ConceptSpecializationExpr\");\n    return Satisfaction->IsSatisfied;\n  }\n\n  /// \\brief Get elaborated satisfaction info about the template arguments'\n  /// satisfaction of the named concept.\n  /// The expression must not be dependent.\n  const ASTConstraintSatisfaction &getSatisfaction() const {\n    assert(!isValueDependent()\n           && \"getSatisfaction called on dependent ConceptSpecializationExpr\");\n    return *Satisfaction;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConceptSpecializationExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return ConceptName.getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // If the ConceptSpecializationExpr is the ImmediatelyDeclaredConstraint\n    // of a TypeConstraint written syntactically as a constrained-parameter,\n    // there may not be a template argument list.\n    return ArgsAsWritten->RAngleLoc.isValid() ? ArgsAsWritten->RAngleLoc\n                                              : ConceptName.getEndLoc();\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nnamespace concepts {\n\n/// \\brief A static requirement that can be used in a requires-expression to\n/// check properties of types and expression.\nclass Requirement {\npublic:\n  // Note - simple and compound requirements are both represented by the same\n  // class (ExprRequirement).\n  enum RequirementKind { RK_Type, RK_Simple, RK_Compound, RK_Nested };\nprivate:\n  const RequirementKind Kind;\n  // FIXME: use RequirementDependence to model dependence?\n  bool Dependent : 1;\n  bool ContainsUnexpandedParameterPack : 1;\n  bool Satisfied : 1;\npublic:\n  struct SubstitutionDiagnostic {\n    StringRef SubstitutedEntity;\n    // FIXME: Store diagnostics semantically and not as prerendered strings.\n    //  Fixing this probably requires serialization of PartialDiagnostic\n    //  objects.\n    SourceLocation DiagLoc;\n    StringRef DiagMessage;\n  };\n\n  Requirement(RequirementKind Kind, bool IsDependent,\n              bool ContainsUnexpandedParameterPack, bool IsSatisfied = true) :\n      Kind(Kind), Dependent(IsDependent),\n      ContainsUnexpandedParameterPack(ContainsUnexpandedParameterPack),\n      Satisfied(IsSatisfied) {}\n\n  RequirementKind getKind() const { return Kind; }\n\n  bool isSatisfied() const {\n    assert(!Dependent &&\n           \"isSatisfied can only be called on non-dependent requirements.\");\n    return Satisfied;\n  }\n\n  void setSatisfied(bool IsSatisfied) {\n    assert(!Dependent &&\n           \"setSatisfied can only be called on non-dependent requirements.\");\n    Satisfied = IsSatisfied;\n  }\n\n  void setDependent(bool IsDependent) { Dependent = IsDependent; }\n  bool isDependent() const { return Dependent; }\n\n  void setContainsUnexpandedParameterPack(bool Contains) {\n    ContainsUnexpandedParameterPack = Contains;\n  }\n  bool containsUnexpandedParameterPack() const {\n    return ContainsUnexpandedParameterPack;\n  }\n};\n\n/// \\brief A requires-expression requirement which queries the existence of a\n/// type name or type template specialization ('type' requirements).\nclass TypeRequirement : public Requirement {\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_SubstitutionFailure,\n      SS_Satisfied\n  };\nprivate:\n  llvm::PointerUnion<SubstitutionDiagnostic *, TypeSourceInfo *> Value;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a type requirement from a type. If the given type is not\n  /// dependent, this indicates that the type exists and the requirement will be\n  /// satisfied. Otherwise, the SubstitutionDiagnostic constructor is to be\n  /// used.\n  TypeRequirement(TypeSourceInfo *T);\n\n  /// \\brief Construct a type requirement when the nested name specifier is\n  /// invalid due to a bad substitution. The requirement is unsatisfied.\n  TypeRequirement(SubstitutionDiagnostic *Diagnostic) :\n      Requirement(RK_Type, false, false, false), Value(Diagnostic),\n      Status(SS_SubstitutionFailure) {}\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n  void setSatisfactionStatus(SatisfactionStatus Status) {\n    this->Status = Status;\n  }\n\n  bool isSubstitutionFailure() const {\n    return Status == SS_SubstitutionFailure;\n  }\n\n  SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n    assert(Status == SS_SubstitutionFailure &&\n           \"Attempted to get substitution diagnostic when there has been no \"\n           \"substitution failure.\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  TypeSourceInfo *getType() const {\n    assert(!isSubstitutionFailure() &&\n           \"Attempted to get type when there has been a substitution failure.\");\n    return Value.get<TypeSourceInfo *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Type;\n  }\n};\n\n/// \\brief A requires-expression requirement which queries the validity and\n/// properties of an expression ('simple' and 'compound' requirements).\nclass ExprRequirement : public Requirement {\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_ExprSubstitutionFailure,\n      SS_NoexceptNotMet,\n      SS_TypeRequirementSubstitutionFailure,\n      SS_ConstraintsNotSatisfied,\n      SS_Satisfied\n  };\n  class ReturnTypeRequirement {\n      llvm::PointerIntPair<\n          llvm::PointerUnion<TemplateParameterList *, SubstitutionDiagnostic *>,\n          1, bool>\n          TypeConstraintInfo;\n  public:\n      friend ASTStmtReader;\n      friend ASTStmtWriter;\n\n      /// \\brief No return type requirement was specified.\n      ReturnTypeRequirement() : TypeConstraintInfo(nullptr, 0) {}\n\n      /// \\brief A return type requirement was specified but it was a\n      /// substitution failure.\n      ReturnTypeRequirement(SubstitutionDiagnostic *SubstDiag) :\n          TypeConstraintInfo(SubstDiag, 0) {}\n\n      /// \\brief A 'type constraint' style return type requirement.\n      /// \\param TPL an invented template parameter list containing a single\n      /// type parameter with a type-constraint.\n      // TODO: Can we maybe not save the whole template parameter list and just\n      //  the type constraint? Saving the whole TPL makes it easier to handle in\n      //  serialization but is less elegant.\n      ReturnTypeRequirement(TemplateParameterList *TPL);\n\n      bool isDependent() const {\n        return TypeConstraintInfo.getInt();\n      }\n\n      bool containsUnexpandedParameterPack() const {\n        if (!isTypeConstraint())\n          return false;\n        return getTypeConstraintTemplateParameterList()\n                ->containsUnexpandedParameterPack();\n      }\n\n      bool isEmpty() const {\n        return TypeConstraintInfo.getPointer().isNull();\n      }\n\n      bool isSubstitutionFailure() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<SubstitutionDiagnostic *>();\n      }\n\n      bool isTypeConstraint() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<TemplateParameterList *>();\n      }\n\n      SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n        assert(isSubstitutionFailure());\n        return TypeConstraintInfo.getPointer().get<SubstitutionDiagnostic *>();\n      }\n\n      const TypeConstraint *getTypeConstraint() const;\n\n      TemplateParameterList *getTypeConstraintTemplateParameterList() const {\n        assert(isTypeConstraint());\n        return TypeConstraintInfo.getPointer().get<TemplateParameterList *>();\n      }\n  };\nprivate:\n  llvm::PointerUnion<Expr *, SubstitutionDiagnostic *> Value;\n  SourceLocation NoexceptLoc; // May be empty if noexcept wasn't specified.\n  ReturnTypeRequirement TypeReq;\n  ConceptSpecializationExpr *SubstitutedConstraintExpr;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a compound requirement.\n  /// \\param E the expression which is checked by this requirement.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression.\n  /// \\param Status the satisfaction status of this requirement.\n  ExprRequirement(\n      Expr *E, bool IsSimple, SourceLocation NoexceptLoc,\n      ReturnTypeRequirement Req, SatisfactionStatus Status,\n      ConceptSpecializationExpr *SubstitutedConstraintExpr = nullptr);\n\n  /// \\brief Construct a compound requirement whose expression was a\n  /// substitution failure. The requirement is not satisfied.\n  /// \\param E the diagnostic emitted while instantiating the original\n  /// expression.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression (omit\n  /// if no requirement was specified).\n  ExprRequirement(SubstitutionDiagnostic *E, bool IsSimple,\n                  SourceLocation NoexceptLoc, ReturnTypeRequirement Req = {});\n\n  bool isSimple() const { return getKind() == RK_Simple; }\n  bool isCompound() const { return getKind() == RK_Compound; }\n\n  bool hasNoexceptRequirement() const { return NoexceptLoc.isValid(); }\n  SourceLocation getNoexceptLoc() const { return NoexceptLoc; }\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n\n  bool isExprSubstitutionFailure() const {\n    return Status == SS_ExprSubstitutionFailure;\n  }\n\n  const ReturnTypeRequirement &getReturnTypeRequirement() const {\n    return TypeReq;\n  }\n\n  ConceptSpecializationExpr *\n  getReturnTypeRequirementSubstitutedConstraintExpr() const {\n    assert(Status >= SS_TypeRequirementSubstitutionFailure);\n    return SubstitutedConstraintExpr;\n  }\n\n  SubstitutionDiagnostic *getExprSubstitutionDiagnostic() const {\n    assert(isExprSubstitutionFailure() &&\n           \"Attempted to get expression substitution diagnostic when there has \"\n           \"been no expression substitution failure\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  Expr *getExpr() const {\n    assert(!isExprSubstitutionFailure() &&\n           \"ExprRequirement has no expression because there has been a \"\n           \"substitution failure.\");\n    return Value.get<Expr *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Compound || R->getKind() == RK_Simple;\n  }\n};\n\n/// \\brief A requires-expression requirement which is satisfied when a general\n/// constraint expression is satisfied ('nested' requirements).\nclass NestedRequirement : public Requirement {\n  llvm::PointerUnion<Expr *, SubstitutionDiagnostic *> Value;\n  const ASTConstraintSatisfaction *Satisfaction = nullptr;\n\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  NestedRequirement(SubstitutionDiagnostic *SubstDiag) :\n      Requirement(RK_Nested, /*Dependent=*/false,\n                  /*ContainsUnexpandedParameterPack*/false,\n                  /*Satisfied=*/false), Value(SubstDiag) {}\n\n  NestedRequirement(Expr *Constraint) :\n      Requirement(RK_Nested, /*Dependent=*/true,\n                  Constraint->containsUnexpandedParameterPack()),\n      Value(Constraint) {\n    assert(Constraint->isInstantiationDependent() &&\n           \"Nested requirement with non-dependent constraint must be \"\n           \"constructed with a ConstraintSatisfaction object\");\n  }\n\n  NestedRequirement(ASTContext &C, Expr *Constraint,\n                    const ConstraintSatisfaction &Satisfaction) :\n      Requirement(RK_Nested, Constraint->isInstantiationDependent(),\n                  Constraint->containsUnexpandedParameterPack(),\n                  Satisfaction.IsSatisfied),\n      Value(Constraint),\n      Satisfaction(ASTConstraintSatisfaction::Create(C, Satisfaction)) {}\n\n  bool isSubstitutionFailure() const {\n    return Value.is<SubstitutionDiagnostic *>();\n  }\n\n  SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n    assert(isSubstitutionFailure() &&\n           \"getSubstitutionDiagnostic() may not be called when there was no \"\n           \"substitution failure.\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  Expr *getConstraintExpr() const {\n    assert(!isSubstitutionFailure() && \"getConstraintExpr() may not be called \"\n                                       \"on nested requirements with \"\n                                       \"substitution failures.\");\n    return Value.get<Expr *>();\n  }\n\n  const ASTConstraintSatisfaction &getConstraintSatisfaction() const {\n    assert(!isSubstitutionFailure() && \"getConstraintSatisfaction() may not be \"\n                                       \"called on nested requirements with \"\n                                       \"substitution failures.\");\n    return *Satisfaction;\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Nested;\n  }\n};\n\n} // namespace concepts\n\n/// C++2a [expr.prim.req]:\n///     A requires-expression provides a concise way to express requirements on\n///     template arguments. A requirement is one that can be checked by name\n///     lookup (6.4) or by checking properties of types and expressions.\n///     [...]\n///     A requires-expression is a prvalue of type bool [...]\nclass RequiresExpr final : public Expr,\n    llvm::TrailingObjects<RequiresExpr, ParmVarDecl *,\n                          concepts::Requirement *> {\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n\n  unsigned NumLocalParameters;\n  unsigned NumRequirements;\n  RequiresExprBodyDecl *Body;\n  SourceLocation RBraceLoc;\n\n  unsigned numTrailingObjects(OverloadToken<ParmVarDecl *>) const {\n    return NumLocalParameters;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<concepts::Requirement *>) const {\n    return NumRequirements;\n  }\n\n  RequiresExpr(ASTContext &C, SourceLocation RequiresKWLoc,\n               RequiresExprBodyDecl *Body,\n               ArrayRef<ParmVarDecl *> LocalParameters,\n               ArrayRef<concepts::Requirement *> Requirements,\n               SourceLocation RBraceLoc);\n  RequiresExpr(ASTContext &C, EmptyShell Empty, unsigned NumLocalParameters,\n               unsigned NumRequirements);\n\npublic:\n  static RequiresExpr *\n  Create(ASTContext &C, SourceLocation RequiresKWLoc,\n         RequiresExprBodyDecl *Body, ArrayRef<ParmVarDecl *> LocalParameters,\n         ArrayRef<concepts::Requirement *> Requirements,\n         SourceLocation RBraceLoc);\n  static RequiresExpr *\n  Create(ASTContext &C, EmptyShell Empty, unsigned NumLocalParameters,\n         unsigned NumRequirements);\n\n  ArrayRef<ParmVarDecl *> getLocalParameters() const {\n    return {getTrailingObjects<ParmVarDecl *>(), NumLocalParameters};\n  }\n\n  RequiresExprBodyDecl *getBody() const { return Body; }\n\n  ArrayRef<concepts::Requirement *> getRequirements() const {\n    return {getTrailingObjects<concepts::Requirement *>(), NumRequirements};\n  }\n\n  /// \\brief Whether or not the requires clause is satisfied.\n  /// The expression must not be dependent.\n  bool isSatisfied() const {\n    assert(!isValueDependent()\n           && \"isSatisfied called on a dependent RequiresExpr\");\n    return RequiresExprBits.IsSatisfied;\n  }\n\n  SourceLocation getRequiresKWLoc() const {\n    return RequiresExprBits.RequiresKWLoc;\n  }\n\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RequiresExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return RequiresExprBits.RequiresKWLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return RBraceLoc;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_EXPRCONCEPTS_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "content": "//===- OpenMPClause.h - Classes for OpenMP clauses --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file defines OpenMP AST classes for clauses.\n/// There are clauses for executable directives, clauses for declarative\n/// directives and clauses which can be used in both kinds of directives.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_OPENMPCLAUSE_H\n#define LLVM_CLANG_AST_OPENMPCLAUSE_H\n\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtIterator.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include \"llvm/Frontend/OpenMP/OMPContext.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\n\n//===----------------------------------------------------------------------===//\n// AST classes for clauses.\n//===----------------------------------------------------------------------===//\n\n/// This is a basic class for representing single OpenMP clause.\nclass OMPClause {\n  /// Starting location of the clause (the clause keyword).\n  SourceLocation StartLoc;\n\n  /// Ending location of the clause.\n  SourceLocation EndLoc;\n\n  /// Kind of the clause.\n  OpenMPClauseKind Kind;\n\nprotected:\n  OMPClause(OpenMPClauseKind K, SourceLocation StartLoc, SourceLocation EndLoc)\n      : StartLoc(StartLoc), EndLoc(EndLoc), Kind(K) {}\n\npublic:\n  /// Returns the starting location of the clause.\n  SourceLocation getBeginLoc() const { return StartLoc; }\n\n  /// Returns the ending location of the clause.\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  /// Sets the starting location of the clause.\n  void setLocStart(SourceLocation Loc) { StartLoc = Loc; }\n\n  /// Sets the ending location of the clause.\n  void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }\n\n  /// Returns kind of OpenMP clause (private, shared, reduction, etc.).\n  OpenMPClauseKind getClauseKind() const { return Kind; }\n\n  bool isImplicit() const { return StartLoc.isInvalid(); }\n\n  using child_iterator = StmtIterator;\n  using const_child_iterator = ConstStmtIterator;\n  using child_range = llvm::iterator_range<child_iterator>;\n  using const_child_range = llvm::iterator_range<const_child_iterator>;\n\n  child_range children();\n  const_child_range children() const {\n    auto Children = const_cast<OMPClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  /// Get the iterator range for the expressions used in the clauses. Used\n  /// expressions include only the children that must be evaluated at the\n  /// runtime before entering the construct.\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *) { return true; }\n};\n\n/// Class that handles pre-initialization statement for some clauses, like\n/// 'shedule', 'firstprivate' etc.\nclass OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Pre-initialization statement for the clause.\n  Stmt *PreInit = nullptr;\n\n  /// Region that captures the associated stmt.\n  OpenMPDirectiveKind CaptureRegion = llvm::omp::OMPD_unknown;\n\nprotected:\n  OMPClauseWithPreInit(const OMPClause *This) {\n    assert(get(This) && \"get is not tuned for pre-init.\");\n  }\n\n  /// Set pre-initialization statement for the clause.\n  void\n  setPreInitStmt(Stmt *S,\n                 OpenMPDirectiveKind ThisRegion = llvm::omp::OMPD_unknown) {\n    PreInit = S;\n    CaptureRegion = ThisRegion;\n  }\n\npublic:\n  /// Get pre-initialization statement for the clause.\n  const Stmt *getPreInitStmt() const { return PreInit; }\n\n  /// Get pre-initialization statement for the clause.\n  Stmt *getPreInitStmt() { return PreInit; }\n\n  /// Get capture region for the stmt in the clause.\n  OpenMPDirectiveKind getCaptureRegion() const { return CaptureRegion; }\n\n  static OMPClauseWithPreInit *get(OMPClause *C);\n  static const OMPClauseWithPreInit *get(const OMPClause *C);\n};\n\n/// Class that handles post-update expression for some clauses, like\n/// 'lastprivate', 'reduction' etc.\nclass OMPClauseWithPostUpdate : public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Post-update expression for the clause.\n  Expr *PostUpdate = nullptr;\n\nprotected:\n  OMPClauseWithPostUpdate(const OMPClause *This) : OMPClauseWithPreInit(This) {\n    assert(get(This) && \"get is not tuned for post-update.\");\n  }\n\n  /// Set pre-initialization statement for the clause.\n  void setPostUpdateExpr(Expr *S) { PostUpdate = S; }\n\npublic:\n  /// Get post-update expression for the clause.\n  const Expr *getPostUpdateExpr() const { return PostUpdate; }\n\n  /// Get post-update expression for the clause.\n  Expr *getPostUpdateExpr() { return PostUpdate; }\n\n  static OMPClauseWithPostUpdate *get(OMPClause *C);\n  static const OMPClauseWithPostUpdate *get(const OMPClause *C);\n};\n\n/// This structure contains most locations needed for by an OMPVarListClause.\nstruct OMPVarListLocTy {\n  /// Starting location of the clause (the clause keyword).\n  SourceLocation StartLoc;\n  /// Location of '('.\n  SourceLocation LParenLoc;\n  /// Ending location of the clause.\n  SourceLocation EndLoc;\n  OMPVarListLocTy() = default;\n  OMPVarListLocTy(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc)\n      : StartLoc(StartLoc), LParenLoc(LParenLoc), EndLoc(EndLoc) {}\n};\n\n/// This represents clauses with the list of variables like 'private',\n/// 'firstprivate', 'copyin', 'shared', or 'reduction' clauses in the\n/// '#pragma omp ...' directives.\ntemplate <class T> class OMPVarListClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of variables in the list.\n  unsigned NumVars;\n\nprotected:\n  /// Build a clause with \\a N variables\n  ///\n  /// \\param K Kind of the clause.\n  /// \\param StartLoc Starting location of the clause (the clause keyword).\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPVarListClause(OpenMPClauseKind K, SourceLocation StartLoc,\n                   SourceLocation LParenLoc, SourceLocation EndLoc, unsigned N)\n      : OMPClause(K, StartLoc, EndLoc), LParenLoc(LParenLoc), NumVars(N) {}\n\n  /// Fetches list of variables associated with this clause.\n  MutableArrayRef<Expr *> getVarRefs() {\n    return MutableArrayRef<Expr *>(\n        static_cast<T *>(this)->template getTrailingObjects<Expr *>(), NumVars);\n  }\n\n  /// Sets the list of variables for this clause.\n  void setVarRefs(ArrayRef<Expr *> VL) {\n    assert(VL.size() == NumVars &&\n           \"Number of variables is not the same as the preallocated buffer\");\n    std::copy(VL.begin(), VL.end(),\n              static_cast<T *>(this)->template getTrailingObjects<Expr *>());\n  }\n\npublic:\n  using varlist_iterator = MutableArrayRef<Expr *>::iterator;\n  using varlist_const_iterator = ArrayRef<const Expr *>::iterator;\n  using varlist_range = llvm::iterator_range<varlist_iterator>;\n  using varlist_const_range = llvm::iterator_range<varlist_const_iterator>;\n\n  unsigned varlist_size() const { return NumVars; }\n  bool varlist_empty() const { return NumVars == 0; }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n\n  varlist_iterator varlist_begin() { return getVarRefs().begin(); }\n  varlist_iterator varlist_end() { return getVarRefs().end(); }\n  varlist_const_iterator varlist_begin() const { return getVarRefs().begin(); }\n  varlist_const_iterator varlist_end() const { return getVarRefs().end(); }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Fetches list of all variables in the clause.\n  ArrayRef<const Expr *> getVarRefs() const {\n    return llvm::makeArrayRef(\n        static_cast<const T *>(this)->template getTrailingObjects<Expr *>(),\n        NumVars);\n  }\n};\n\n/// This represents 'allocator' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp allocate(a) allocator(omp_default_mem_alloc)\n/// \\endcode\n/// In this example directive '#pragma omp allocate' has simple 'allocator'\n/// clause with the allocator 'omp_default_mem_alloc'.\nclass OMPAllocatorClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Expression with the allocator.\n  Stmt *Allocator = nullptr;\n\n  /// Set allocator.\n  void setAllocator(Expr *A) { Allocator = A; }\n\npublic:\n  /// Build 'allocator' clause with the given allocator.\n  ///\n  /// \\param A Allocator.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAllocatorClause(Expr *A, SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_allocator, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Allocator(A) {}\n\n  /// Build an empty clause.\n  OMPAllocatorClause()\n      : OMPClause(llvm::omp::OMPC_allocator, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns allocator.\n  Expr *getAllocator() const { return cast_or_null<Expr>(Allocator); }\n\n  child_range children() { return child_range(&Allocator, &Allocator + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Allocator, &Allocator + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_allocator;\n  }\n};\n\n/// This represents clause 'allocate' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel private(a) allocate(omp_default_mem_alloc :a)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'private'\n/// and clause 'allocate' for the variable 'a'.\nclass OMPAllocateClause final\n    : public OMPVarListClause<OMPAllocateClause>,\n      private llvm::TrailingObjects<OMPAllocateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Allocator specified in the clause, or 'nullptr' if the default one is\n  /// used.\n  Expr *Allocator = nullptr;\n  /// Position of the ':' delimiter in the clause;\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param Allocator Allocator expression.\n  /// \\param ColonLoc Location of ':' delimiter.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPAllocateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                    Expr *Allocator, SourceLocation ColonLoc,\n                    SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPAllocateClause>(llvm::omp::OMPC_allocate, StartLoc,\n                                            LParenLoc, EndLoc, N),\n        Allocator(Allocator), ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPAllocateClause(unsigned N)\n      : OMPVarListClause<OMPAllocateClause>(llvm::omp::OMPC_allocate,\n                                            SourceLocation(), SourceLocation(),\n                                            SourceLocation(), N) {}\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  void setAllocator(Expr *A) { Allocator = A; }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param Allocator Allocator expression.\n  /// \\param ColonLoc Location of ':' delimiter.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPAllocateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation LParenLoc, Expr *Allocator,\n                                   SourceLocation ColonLoc,\n                                   SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Returns the allocator expression or nullptr, if no allocator is specified.\n  Expr *getAllocator() const { return Allocator; }\n\n  /// Returns the location of the ':' delimiter.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPAllocateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPAllocateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_allocate;\n  }\n};\n\n/// This represents 'if' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp parallel if(parallel:a > 5)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'if' clause with\n/// condition 'a > 5' and directive name modifier 'parallel'.\nclass OMPIfClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Condition of the 'if' clause.\n  Stmt *Condition = nullptr;\n\n  /// Location of ':' (if any).\n  SourceLocation ColonLoc;\n\n  /// Directive name modifier for the clause.\n  OpenMPDirectiveKind NameModifier = llvm::omp::OMPD_unknown;\n\n  /// Name modifier location.\n  SourceLocation NameModifierLoc;\n\n  /// Set condition.\n  void setCondition(Expr *Cond) { Condition = Cond; }\n\n  /// Set directive name modifier for the clause.\n  void setNameModifier(OpenMPDirectiveKind NM) { NameModifier = NM; }\n\n  /// Set location of directive name modifier for the clause.\n  void setNameModifierLoc(SourceLocation Loc) { NameModifierLoc = Loc; }\n\n  /// Set location of ':'.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Build 'if' clause with condition \\a Cond.\n  ///\n  /// \\param NameModifier [OpenMP 4.1] Directive name modifier of clause.\n  /// \\param Cond Condition of the clause.\n  /// \\param HelperCond Helper condition for the clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param NameModifierLoc Location of directive name modifier.\n  /// \\param ColonLoc [OpenMP 4.1] Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  OMPIfClause(OpenMPDirectiveKind NameModifier, Expr *Cond, Stmt *HelperCond,\n              OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n              SourceLocation LParenLoc, SourceLocation NameModifierLoc,\n              SourceLocation ColonLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_if, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Condition(Cond),\n        ColonLoc(ColonLoc), NameModifier(NameModifier),\n        NameModifierLoc(NameModifierLoc) {\n    setPreInitStmt(HelperCond, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPIfClause()\n      : OMPClause(llvm::omp::OMPC_if, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return the location of ':'.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Returns condition.\n  Expr *getCondition() const { return cast_or_null<Expr>(Condition); }\n\n  /// Return directive name modifier associated with the clause.\n  OpenMPDirectiveKind getNameModifier() const { return NameModifier; }\n\n  /// Return the location of directive name modifier.\n  SourceLocation getNameModifierLoc() const { return NameModifierLoc; }\n\n  child_range children() { return child_range(&Condition, &Condition + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Condition, &Condition + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPIfClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_if;\n  }\n};\n\n/// This represents 'final' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp task final(a > 5)\n/// \\endcode\n/// In this example directive '#pragma omp task' has simple 'final'\n/// clause with condition 'a > 5'.\nclass OMPFinalClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Condition of the 'if' clause.\n  Stmt *Condition = nullptr;\n\n  /// Set condition.\n  void setCondition(Expr *Cond) { Condition = Cond; }\n\npublic:\n  /// Build 'final' clause with condition \\a Cond.\n  ///\n  /// \\param Cond Condition of the clause.\n  /// \\param HelperCond Helper condition for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPFinalClause(Expr *Cond, Stmt *HelperCond,\n                 OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                 SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_final, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Condition(Cond) {\n    setPreInitStmt(HelperCond, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPFinalClause()\n      : OMPClause(llvm::omp::OMPC_final, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns condition.\n  Expr *getCondition() const { return cast_or_null<Expr>(Condition); }\n\n  child_range children() { return child_range(&Condition, &Condition + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Condition, &Condition + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPFinalClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_final;\n  }\n};\n\n/// This represents 'num_threads' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp parallel num_threads(6)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'num_threads'\n/// clause with number of threads '6'.\nclass OMPNumThreadsClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Condition of the 'num_threads' clause.\n  Stmt *NumThreads = nullptr;\n\n  /// Set condition.\n  void setNumThreads(Expr *NThreads) { NumThreads = NThreads; }\n\npublic:\n  /// Build 'num_threads' clause with condition \\a NumThreads.\n  ///\n  /// \\param NumThreads Number of threads for the construct.\n  /// \\param HelperNumThreads Helper Number of threads for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNumThreadsClause(Expr *NumThreads, Stmt *HelperNumThreads,\n                      OpenMPDirectiveKind CaptureRegion,\n                      SourceLocation StartLoc, SourceLocation LParenLoc,\n                      SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_num_threads, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc),\n        NumThreads(NumThreads) {\n    setPreInitStmt(HelperNumThreads, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPNumThreadsClause()\n      : OMPClause(llvm::omp::OMPC_num_threads, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns number of threads.\n  Expr *getNumThreads() const { return cast_or_null<Expr>(NumThreads); }\n\n  child_range children() { return child_range(&NumThreads, &NumThreads + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumThreads, &NumThreads + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_num_threads;\n  }\n};\n\n/// This represents 'safelen' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp simd safelen(4)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'safelen'\n/// with single expression '4'.\n/// If the safelen clause is used then no two iterations executed\n/// concurrently with SIMD instructions can have a greater distance\n/// in the logical iteration space than its value. The parameter of\n/// the safelen clause must be a constant positive integer expression.\nclass OMPSafelenClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *Safelen = nullptr;\n\n  /// Set safelen.\n  void setSafelen(Expr *Len) { Safelen = Len; }\n\npublic:\n  /// Build 'safelen' clause.\n  ///\n  /// \\param Len Expression associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSafelenClause(Expr *Len, SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_safelen, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Safelen(Len) {}\n\n  /// Build an empty clause.\n  explicit OMPSafelenClause()\n      : OMPClause(llvm::omp::OMPC_safelen, SourceLocation(), SourceLocation()) {\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getSafelen() const { return cast_or_null<Expr>(Safelen); }\n\n  child_range children() { return child_range(&Safelen, &Safelen + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Safelen, &Safelen + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_safelen;\n  }\n};\n\n/// This represents 'simdlen' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp simd simdlen(4)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'simdlen'\n/// with single expression '4'.\n/// If the 'simdlen' clause is used then it specifies the preferred number of\n/// iterations to be executed concurrently. The parameter of the 'simdlen'\n/// clause must be a constant positive integer expression.\nclass OMPSimdlenClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *Simdlen = nullptr;\n\n  /// Set simdlen.\n  void setSimdlen(Expr *Len) { Simdlen = Len; }\n\npublic:\n  /// Build 'simdlen' clause.\n  ///\n  /// \\param Len Expression associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSimdlenClause(Expr *Len, SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_simdlen, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Simdlen(Len) {}\n\n  /// Build an empty clause.\n  explicit OMPSimdlenClause()\n      : OMPClause(llvm::omp::OMPC_simdlen, SourceLocation(), SourceLocation()) {\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getSimdlen() const { return cast_or_null<Expr>(Simdlen); }\n\n  child_range children() { return child_range(&Simdlen, &Simdlen + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Simdlen, &Simdlen + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_simdlen;\n  }\n};\n\n/// This represents the 'sizes' clause in the '#pragma omp tile' directive.\n///\n/// \\code\n/// #pragma omp tile sizes(5,5)\n/// for (int i = 0; i < 64; ++i)\n///   for (int j = 0; j < 64; ++j)\n/// \\endcode\nclass OMPSizesClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPSizesClause, Expr *> {\n  friend class OMPClauseReader;\n  friend class llvm::TrailingObjects<OMPSizesClause, Expr *>;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of tile sizes in the clause.\n  unsigned NumSizes;\n\n  /// Build an empty clause.\n  explicit OMPSizesClause(int NumSizes)\n      : OMPClause(llvm::omp::OMPC_sizes, SourceLocation(), SourceLocation()),\n        NumSizes(NumSizes) {}\n\npublic:\n  /// Build a 'sizes' AST node.\n  ///\n  /// \\param C         Context of the AST.\n  /// \\param StartLoc  Location of the 'sizes' identifier.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc    Location of ')'.\n  /// \\param Sizes     Content of the clause.\n  static OMPSizesClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                SourceLocation LParenLoc, SourceLocation EndLoc,\n                                ArrayRef<Expr *> Sizes);\n\n  /// Build an empty 'sizes' AST node for deserialization.\n  ///\n  /// \\param C     Context of the AST.\n  /// \\param NumSizes Number of items in the clause.\n  static OMPSizesClause *CreateEmpty(const ASTContext &C, unsigned NumSizes);\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns the number of list items.\n  unsigned getNumSizes() const { return NumSizes; }\n\n  /// Returns the tile size expressions.\n  MutableArrayRef<Expr *> getSizesRefs() {\n    return MutableArrayRef<Expr *>(static_cast<OMPSizesClause *>(this)\n                                       ->template getTrailingObjects<Expr *>(),\n                                   NumSizes);\n  }\n  ArrayRef<Expr *> getSizesRefs() const {\n    return ArrayRef<Expr *>(static_cast<const OMPSizesClause *>(this)\n                                ->template getTrailingObjects<Expr *>(),\n                            NumSizes);\n  }\n\n  /// Sets the tile size expressions.\n  void setSizesRefs(ArrayRef<Expr *> VL) {\n    assert(VL.size() == NumSizes);\n    std::copy(VL.begin(), VL.end(),\n              static_cast<OMPSizesClause *>(this)\n                  ->template getTrailingObjects<Expr *>());\n  }\n\n  child_range children() {\n    MutableArrayRef<Expr *> Sizes = getSizesRefs();\n    return child_range(reinterpret_cast<Stmt **>(Sizes.begin()),\n                       reinterpret_cast<Stmt **>(Sizes.end()));\n  }\n  const_child_range children() const {\n    ArrayRef<Expr *> Sizes = getSizesRefs();\n    return const_child_range(reinterpret_cast<Stmt *const *>(Sizes.begin()),\n                             reinterpret_cast<Stmt *const *>(Sizes.end()));\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_sizes;\n  }\n};\n\n/// This represents 'collapse' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp simd collapse(3)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'collapse'\n/// with single expression '3'.\n/// The parameter must be a constant positive integer expression, it specifies\n/// the number of nested loops that should be collapsed into a single iteration\n/// space.\nclass OMPCollapseClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of for-loops.\n  Stmt *NumForLoops = nullptr;\n\n  /// Set the number of associated for-loops.\n  void setNumForLoops(Expr *Num) { NumForLoops = Num; }\n\npublic:\n  /// Build 'collapse' clause.\n  ///\n  /// \\param Num Expression associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPCollapseClause(Expr *Num, SourceLocation StartLoc,\n                    SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_collapse, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), NumForLoops(Num) {}\n\n  /// Build an empty clause.\n  explicit OMPCollapseClause()\n      : OMPClause(llvm::omp::OMPC_collapse, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return the number of associated for-loops.\n  Expr *getNumForLoops() const { return cast_or_null<Expr>(NumForLoops); }\n\n  child_range children() { return child_range(&NumForLoops, &NumForLoops + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumForLoops, &NumForLoops + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_collapse;\n  }\n};\n\n/// This represents 'default' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp parallel default(shared)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'default'\n/// clause with kind 'shared'.\nclass OMPDefaultClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'default' clause.\n  llvm::omp::DefaultKind Kind = llvm::omp::OMP_DEFAULT_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clauses.\n  ///\n  /// \\param K Argument of clause.\n  void setDefaultKind(llvm::omp::DefaultKind K) { Kind = K; }\n\n  /// Set argument location.\n  ///\n  /// \\param KLoc Argument location.\n  void setDefaultKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }\n\npublic:\n  /// Build 'default' clause with argument \\a A ('none' or 'shared').\n  ///\n  /// \\param A Argument of the clause ('none' or 'shared').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDefaultClause(llvm::omp::DefaultKind A, SourceLocation ALoc,\n                   SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_default, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPDefaultClause()\n      : OMPClause(llvm::omp::OMPC_default, SourceLocation(), SourceLocation()) {\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  llvm::omp::DefaultKind getDefaultKind() const { return Kind; }\n\n  /// Returns location of clause kind.\n  SourceLocation getDefaultKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_default;\n  }\n};\n\n/// This represents 'proc_bind' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp parallel proc_bind(master)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'proc_bind'\n/// clause with kind 'master'.\nclass OMPProcBindClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'proc_bind' clause.\n  llvm::omp::ProcBindKind Kind = llvm::omp::OMP_PROC_BIND_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clause.\n  ///\n  /// \\param K Kind of clause.\n  void setProcBindKind(llvm::omp::ProcBindKind K) { Kind = K; }\n\n  /// Set clause kind location.\n  ///\n  /// \\param KLoc Kind location.\n  void setProcBindKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }\n\npublic:\n  /// Build 'proc_bind' clause with argument \\a A ('master', 'close' or\n  ///        'spread').\n  ///\n  /// \\param A Argument of the clause ('master', 'close' or 'spread').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPProcBindClause(llvm::omp::ProcBindKind A, SourceLocation ALoc,\n                    SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_proc_bind, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPProcBindClause()\n      : OMPClause(llvm::omp::OMPC_proc_bind, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  llvm::omp::ProcBindKind getProcBindKind() const { return Kind; }\n\n  /// Returns location of clause kind.\n  SourceLocation getProcBindKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_proc_bind;\n  }\n};\n\n/// This represents 'unified_address' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires unified_address\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'unified_address'\n/// clause.\nclass OMPUnifiedAddressClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'unified_address' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUnifiedAddressClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_unified_address, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPUnifiedAddressClause()\n      : OMPClause(llvm::omp::OMPC_unified_address, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_unified_address;\n  }\n};\n\n/// This represents 'unified_shared_memory' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires unified_shared_memory\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'unified_shared_memory'\n/// clause.\nclass OMPUnifiedSharedMemoryClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'unified_shared_memory' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUnifiedSharedMemoryClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_unified_shared_memory, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPUnifiedSharedMemoryClause()\n      : OMPClause(llvm::omp::OMPC_unified_shared_memory, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_unified_shared_memory;\n  }\n};\n\n/// This represents 'reverse_offload' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires reverse_offload\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'reverse_offload'\n/// clause.\nclass OMPReverseOffloadClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'reverse_offload' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPReverseOffloadClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_reverse_offload, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPReverseOffloadClause()\n      : OMPClause(llvm::omp::OMPC_reverse_offload, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_reverse_offload;\n  }\n};\n\n/// This represents 'dynamic_allocators' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires dynamic_allocators\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'dynamic_allocators'\n/// clause.\nclass OMPDynamicAllocatorsClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'dynamic_allocators' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDynamicAllocatorsClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_dynamic_allocators, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPDynamicAllocatorsClause()\n      : OMPClause(llvm::omp::OMPC_dynamic_allocators, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_dynamic_allocators;\n  }\n};\n\n/// This represents 'atomic_default_mem_order' clause in the '#pragma omp\n/// requires'  directive.\n///\n/// \\code\n/// #pragma omp requires atomic_default_mem_order(seq_cst)\n/// \\endcode\n/// In this example directive '#pragma omp requires' has simple\n/// atomic_default_mem_order' clause with kind 'seq_cst'.\nclass OMPAtomicDefaultMemOrderClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'atomic_default_mem_order' clause.\n  OpenMPAtomicDefaultMemOrderClauseKind Kind =\n      OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clause.\n  ///\n  /// \\param K Kind of clause.\n  void setAtomicDefaultMemOrderKind(OpenMPAtomicDefaultMemOrderClauseKind K) {\n    Kind = K;\n  }\n\n  /// Set clause kind location.\n  ///\n  /// \\param KLoc Kind location.\n  void setAtomicDefaultMemOrderKindKwLoc(SourceLocation KLoc) {\n    KindKwLoc = KLoc;\n  }\n\npublic:\n  /// Build 'atomic_default_mem_order' clause with argument \\a A ('seq_cst',\n  /// 'acq_rel' or 'relaxed').\n  ///\n  /// \\param A Argument of the clause ('seq_cst', 'acq_rel' or 'relaxed').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAtomicDefaultMemOrderClause(OpenMPAtomicDefaultMemOrderClauseKind A,\n                                 SourceLocation ALoc, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_atomic_default_mem_order, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPAtomicDefaultMemOrderClause()\n      : OMPClause(llvm::omp::OMPC_atomic_default_mem_order, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the locaiton of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  OpenMPAtomicDefaultMemOrderClauseKind getAtomicDefaultMemOrderKind() const {\n    return Kind;\n  }\n\n  /// Returns location of clause kind.\n  SourceLocation getAtomicDefaultMemOrderKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_atomic_default_mem_order;\n  }\n};\n\n/// This represents 'schedule' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp for schedule(static, 3)\n/// \\endcode\n/// In this example directive '#pragma omp for' has 'schedule' clause with\n/// arguments 'static' and '3'.\nclass OMPScheduleClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'schedule' clause.\n  OpenMPScheduleClauseKind Kind = OMPC_SCHEDULE_unknown;\n\n  /// Modifiers for 'schedule' clause.\n  enum {FIRST, SECOND, NUM_MODIFIERS};\n  OpenMPScheduleClauseModifier Modifiers[NUM_MODIFIERS];\n\n  /// Locations of modifiers.\n  SourceLocation ModifiersLoc[NUM_MODIFIERS];\n\n  /// Start location of the schedule ind in source code.\n  SourceLocation KindLoc;\n\n  /// Location of ',' (if any).\n  SourceLocation CommaLoc;\n\n  /// Chunk size.\n  Expr *ChunkSize = nullptr;\n\n  /// Set schedule kind.\n  ///\n  /// \\param K Schedule kind.\n  void setScheduleKind(OpenMPScheduleClauseKind K) { Kind = K; }\n\n  /// Set the first schedule modifier.\n  ///\n  /// \\param M Schedule modifier.\n  void setFirstScheduleModifier(OpenMPScheduleClauseModifier M) {\n    Modifiers[FIRST] = M;\n  }\n\n  /// Set the second schedule modifier.\n  ///\n  /// \\param M Schedule modifier.\n  void setSecondScheduleModifier(OpenMPScheduleClauseModifier M) {\n    Modifiers[SECOND] = M;\n  }\n\n  /// Set location of the first schedule modifier.\n  void setFirstScheduleModifierLoc(SourceLocation Loc) {\n    ModifiersLoc[FIRST] = Loc;\n  }\n\n  /// Set location of the second schedule modifier.\n  void setSecondScheduleModifierLoc(SourceLocation Loc) {\n    ModifiersLoc[SECOND] = Loc;\n  }\n\n  /// Set schedule modifier location.\n  ///\n  /// \\param M Schedule modifier location.\n  void setScheduleModifer(OpenMPScheduleClauseModifier M) {\n    if (Modifiers[FIRST] == OMPC_SCHEDULE_MODIFIER_unknown)\n      Modifiers[FIRST] = M;\n    else {\n      assert(Modifiers[SECOND] == OMPC_SCHEDULE_MODIFIER_unknown);\n      Modifiers[SECOND] = M;\n    }\n  }\n\n  /// Sets the location of '('.\n  ///\n  /// \\param Loc Location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Set schedule kind start location.\n  ///\n  /// \\param KLoc Schedule kind location.\n  void setScheduleKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }\n\n  /// Set location of ','.\n  ///\n  /// \\param Loc Location of ','.\n  void setCommaLoc(SourceLocation Loc) { CommaLoc = Loc; }\n\n  /// Set chunk size.\n  ///\n  /// \\param E Chunk size.\n  void setChunkSize(Expr *E) { ChunkSize = E; }\n\npublic:\n  /// Build 'schedule' clause with schedule kind \\a Kind and chunk size\n  /// expression \\a ChunkSize.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param KLoc Starting location of the argument.\n  /// \\param CommaLoc Location of ','.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Kind Schedule kind.\n  /// \\param ChunkSize Chunk size.\n  /// \\param HelperChunkSize Helper chunk size for combined directives.\n  /// \\param M1 The first modifier applied to 'schedule' clause.\n  /// \\param M1Loc Location of the first modifier\n  /// \\param M2 The second modifier applied to 'schedule' clause.\n  /// \\param M2Loc Location of the second modifier\n  OMPScheduleClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation KLoc, SourceLocation CommaLoc,\n                    SourceLocation EndLoc, OpenMPScheduleClauseKind Kind,\n                    Expr *ChunkSize, Stmt *HelperChunkSize,\n                    OpenMPScheduleClauseModifier M1, SourceLocation M1Loc,\n                    OpenMPScheduleClauseModifier M2, SourceLocation M2Loc)\n      : OMPClause(llvm::omp::OMPC_schedule, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Kind(Kind),\n        KindLoc(KLoc), CommaLoc(CommaLoc), ChunkSize(ChunkSize) {\n    setPreInitStmt(HelperChunkSize);\n    Modifiers[FIRST] = M1;\n    Modifiers[SECOND] = M2;\n    ModifiersLoc[FIRST] = M1Loc;\n    ModifiersLoc[SECOND] = M2Loc;\n  }\n\n  /// Build an empty clause.\n  explicit OMPScheduleClause()\n      : OMPClause(llvm::omp::OMPC_schedule, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {\n    Modifiers[FIRST] = OMPC_SCHEDULE_MODIFIER_unknown;\n    Modifiers[SECOND] = OMPC_SCHEDULE_MODIFIER_unknown;\n  }\n\n  /// Get kind of the clause.\n  OpenMPScheduleClauseKind getScheduleKind() const { return Kind; }\n\n  /// Get the first modifier of the clause.\n  OpenMPScheduleClauseModifier getFirstScheduleModifier() const {\n    return Modifiers[FIRST];\n  }\n\n  /// Get the second modifier of the clause.\n  OpenMPScheduleClauseModifier getSecondScheduleModifier() const {\n    return Modifiers[SECOND];\n  }\n\n  /// Get location of '('.\n  SourceLocation getLParenLoc() { return LParenLoc; }\n\n  /// Get kind location.\n  SourceLocation getScheduleKindLoc() { return KindLoc; }\n\n  /// Get the first modifier location.\n  SourceLocation getFirstScheduleModifierLoc() const {\n    return ModifiersLoc[FIRST];\n  }\n\n  /// Get the second modifier location.\n  SourceLocation getSecondScheduleModifierLoc() const {\n    return ModifiersLoc[SECOND];\n  }\n\n  /// Get location of ','.\n  SourceLocation getCommaLoc() { return CommaLoc; }\n\n  /// Get chunk size.\n  Expr *getChunkSize() { return ChunkSize; }\n\n  /// Get chunk size.\n  const Expr *getChunkSize() const { return ChunkSize; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(&ChunkSize),\n                       reinterpret_cast<Stmt **>(&ChunkSize) + 1);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPScheduleClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_schedule;\n  }\n};\n\n/// This represents 'ordered' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp for ordered (2)\n/// \\endcode\n/// In this example directive '#pragma omp for' has 'ordered' clause with\n/// parameter 2.\nclass OMPOrderedClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPOrderedClause, Expr *> {\n  friend class OMPClauseReader;\n  friend TrailingObjects;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of for-loops.\n  Stmt *NumForLoops = nullptr;\n\n  /// Real number of loops.\n  unsigned NumberOfLoops = 0;\n\n  /// Build 'ordered' clause.\n  ///\n  /// \\param Num Expression, possibly associated with this clause.\n  /// \\param NumLoops Number of loops, associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPOrderedClause(Expr *Num, unsigned NumLoops, SourceLocation StartLoc,\n                   SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_ordered, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), NumForLoops(Num), NumberOfLoops(NumLoops) {}\n\n  /// Build an empty clause.\n  explicit OMPOrderedClause(unsigned NumLoops)\n      : OMPClause(llvm::omp::OMPC_ordered, SourceLocation(), SourceLocation()),\n        NumberOfLoops(NumLoops) {}\n\n  /// Set the number of associated for-loops.\n  void setNumForLoops(Expr *Num) { NumForLoops = Num; }\n\npublic:\n  /// Build 'ordered' clause.\n  ///\n  /// \\param Num Expression, possibly associated with this clause.\n  /// \\param NumLoops Number of loops, associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  static OMPOrderedClause *Create(const ASTContext &C, Expr *Num,\n                                  unsigned NumLoops, SourceLocation StartLoc,\n                                  SourceLocation LParenLoc,\n                                  SourceLocation EndLoc);\n\n  /// Build an empty clause.\n  static OMPOrderedClause* CreateEmpty(const ASTContext &C, unsigned NumLoops);\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return the number of associated for-loops.\n  Expr *getNumForLoops() const { return cast_or_null<Expr>(NumForLoops); }\n\n  /// Set number of iterations for the specified loop.\n  void setLoopNumIterations(unsigned NumLoop, Expr *NumIterations);\n  /// Get number of iterations for all the loops.\n  ArrayRef<Expr *> getLoopNumIterations() const;\n\n  /// Set loop counter for the specified loop.\n  void setLoopCounter(unsigned NumLoop, Expr *Counter);\n  /// Get loops counter for the specified loop.\n  Expr *getLoopCounter(unsigned NumLoop);\n  const Expr *getLoopCounter(unsigned NumLoop) const;\n\n  child_range children() { return child_range(&NumForLoops, &NumForLoops + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumForLoops, &NumForLoops + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_ordered;\n  }\n};\n\n/// This represents 'nowait' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp for nowait\n/// \\endcode\n/// In this example directive '#pragma omp for' has 'nowait' clause.\nclass OMPNowaitClause : public OMPClause {\npublic:\n  /// Build 'nowait' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNowaitClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_nowait, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPNowaitClause()\n      : OMPClause(llvm::omp::OMPC_nowait, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_nowait;\n  }\n};\n\n/// This represents 'untied' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp task untied\n/// \\endcode\n/// In this example directive '#pragma omp task' has 'untied' clause.\nclass OMPUntiedClause : public OMPClause {\npublic:\n  /// Build 'untied' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUntiedClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_untied, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPUntiedClause()\n      : OMPClause(llvm::omp::OMPC_untied, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_untied;\n  }\n};\n\n/// This represents 'mergeable' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp task mergeable\n/// \\endcode\n/// In this example directive '#pragma omp task' has 'mergeable' clause.\nclass OMPMergeableClause : public OMPClause {\npublic:\n  /// Build 'mergeable' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPMergeableClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_mergeable, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPMergeableClause()\n      : OMPClause(llvm::omp::OMPC_mergeable, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_mergeable;\n  }\n};\n\n/// This represents 'read' clause in the '#pragma omp atomic' directive.\n///\n/// \\code\n/// #pragma omp atomic read\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'read' clause.\nclass OMPReadClause : public OMPClause {\npublic:\n  /// Build 'read' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPReadClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_read, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPReadClause()\n      : OMPClause(llvm::omp::OMPC_read, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_read;\n  }\n};\n\n/// This represents 'write' clause in the '#pragma omp atomic' directive.\n///\n/// \\code\n/// #pragma omp atomic write\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'write' clause.\nclass OMPWriteClause : public OMPClause {\npublic:\n  /// Build 'write' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPWriteClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_write, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPWriteClause()\n      : OMPClause(llvm::omp::OMPC_write, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_write;\n  }\n};\n\n/// This represents 'update' clause in the '#pragma omp atomic'\n/// directive.\n///\n/// \\code\n/// #pragma omp atomic update\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'update' clause.\n/// Also, this class represents 'update' clause in  '#pragma omp depobj'\n/// directive.\n///\n/// \\code\n/// #pragma omp depobj(a) update(in)\n/// \\endcode\n/// In this example directive '#pragma omp depobj' has 'update' clause with 'in'\n/// dependence kind.\nclass OMPUpdateClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPUpdateClause, SourceLocation,\n                                    OpenMPDependClauseKind> {\n  friend class OMPClauseReader;\n  friend TrailingObjects;\n\n  /// true if extended version of the clause for 'depobj' directive.\n  bool IsExtended = false;\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<SourceLocation>) const {\n    // 2 locations: for '(' and argument location.\n    return IsExtended ? 2 : 0;\n  }\n\n  /// Sets the the location of '(' in clause for 'depobj' directive.\n  void setLParenLoc(SourceLocation Loc) {\n    assert(IsExtended && \"Expected extended clause.\");\n    *getTrailingObjects<SourceLocation>() = Loc;\n  }\n\n  /// Sets the the location of '(' in clause for 'depobj' directive.\n  void setArgumentLoc(SourceLocation Loc) {\n    assert(IsExtended && \"Expected extended clause.\");\n    *std::next(getTrailingObjects<SourceLocation>(), 1) = Loc;\n  }\n\n  /// Sets the dependence kind for the clause for 'depobj' directive.\n  void setDependencyKind(OpenMPDependClauseKind DK) {\n    assert(IsExtended && \"Expected extended clause.\");\n    *getTrailingObjects<OpenMPDependClauseKind>() = DK;\n  }\n\n  /// Build 'update' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUpdateClause(SourceLocation StartLoc, SourceLocation EndLoc,\n                  bool IsExtended)\n      : OMPClause(llvm::omp::OMPC_update, StartLoc, EndLoc),\n        IsExtended(IsExtended) {}\n\n  /// Build an empty clause.\n  OMPUpdateClause(bool IsExtended)\n      : OMPClause(llvm::omp::OMPC_update, SourceLocation(), SourceLocation()),\n        IsExtended(IsExtended) {}\n\npublic:\n  /// Creates clause for 'atomic' directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  static OMPUpdateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation EndLoc);\n\n  /// Creates clause for 'depobj' directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ArgumentLoc Location of the argument.\n  /// \\param DK Dependence kind.\n  /// \\param EndLoc Ending location of the clause.\n  static OMPUpdateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation ArgumentLoc,\n                                 OpenMPDependClauseKind DK,\n                                 SourceLocation EndLoc);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param IsExtended true if extended clause for 'depobj' directive must be\n  /// created.\n  static OMPUpdateClause *CreateEmpty(const ASTContext &C, bool IsExtended);\n\n  /// Checks if the clause is the extended clauses for 'depobj' directive.\n  bool isExtended() const { return IsExtended; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// Gets the the location of '(' in clause for 'depobj' directive.\n  SourceLocation getLParenLoc() const {\n    assert(IsExtended && \"Expected extended clause.\");\n    return *getTrailingObjects<SourceLocation>();\n  }\n\n  /// Gets the the location of argument in clause for 'depobj' directive.\n  SourceLocation getArgumentLoc() const {\n    assert(IsExtended && \"Expected extended clause.\");\n    return *std::next(getTrailingObjects<SourceLocation>(), 1);\n  }\n\n  /// Gets the dependence kind in clause for 'depobj' directive.\n  OpenMPDependClauseKind getDependencyKind() const {\n    assert(IsExtended && \"Expected extended clause.\");\n    return *getTrailingObjects<OpenMPDependClauseKind>();\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_update;\n  }\n};\n\n/// This represents 'capture' clause in the '#pragma omp atomic'\n/// directive.\n///\n/// \\code\n/// #pragma omp atomic capture\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'capture' clause.\nclass OMPCaptureClause : public OMPClause {\npublic:\n  /// Build 'capture' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPCaptureClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_capture, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPCaptureClause()\n      : OMPClause(llvm::omp::OMPC_capture, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_capture;\n  }\n};\n\n/// This represents 'seq_cst' clause in the '#pragma omp atomic'\n/// directive.\n///\n/// \\code\n/// #pragma omp atomic seq_cst\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'seq_cst' clause.\nclass OMPSeqCstClause : public OMPClause {\npublic:\n  /// Build 'seq_cst' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSeqCstClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_seq_cst, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPSeqCstClause()\n      : OMPClause(llvm::omp::OMPC_seq_cst, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_seq_cst;\n  }\n};\n\n/// This represents 'acq_rel' clause in the '#pragma omp atomic|flush'\n/// directives.\n///\n/// \\code\n/// #pragma omp flush acq_rel\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 'acq_rel' clause.\nclass OMPAcqRelClause final : public OMPClause {\npublic:\n  /// Build 'ack_rel' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAcqRelClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_acq_rel, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPAcqRelClause()\n      : OMPClause(llvm::omp::OMPC_acq_rel, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_acq_rel;\n  }\n};\n\n/// This represents 'acquire' clause in the '#pragma omp atomic|flush'\n/// directives.\n///\n/// \\code\n/// #pragma omp flush acquire\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 'acquire' clause.\nclass OMPAcquireClause final : public OMPClause {\npublic:\n  /// Build 'acquire' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAcquireClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_acquire, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPAcquireClause()\n      : OMPClause(llvm::omp::OMPC_acquire, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_acquire;\n  }\n};\n\n/// This represents 'release' clause in the '#pragma omp atomic|flush'\n/// directives.\n///\n/// \\code\n/// #pragma omp flush release\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 'release' clause.\nclass OMPReleaseClause final : public OMPClause {\npublic:\n  /// Build 'release' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPReleaseClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_release, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPReleaseClause()\n      : OMPClause(llvm::omp::OMPC_release, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_release;\n  }\n};\n\n/// This represents 'relaxed' clause in the '#pragma omp atomic'\n/// directives.\n///\n/// \\code\n/// #pragma omp atomic relaxed\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'relaxed' clause.\nclass OMPRelaxedClause final : public OMPClause {\npublic:\n  /// Build 'relaxed' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPRelaxedClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_relaxed, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPRelaxedClause()\n      : OMPClause(llvm::omp::OMPC_relaxed, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_relaxed;\n  }\n};\n\n/// This represents clause 'private' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'private'\n/// with the variables 'a' and 'b'.\nclass OMPPrivateClause final\n    : public OMPVarListClause<OMPPrivateClause>,\n      private llvm::TrailingObjects<OMPPrivateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPPrivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPPrivateClause>(llvm::omp::OMPC_private, StartLoc,\n                                           LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPPrivateClause(unsigned N)\n      : OMPVarListClause<OMPPrivateClause>(llvm::omp::OMPC_private,\n                                           SourceLocation(), SourceLocation(),\n                                           SourceLocation(), N) {}\n\n  /// Sets the list of references to private copies with initializers for\n  /// new private variables.\n  /// \\param VL List of references.\n  void setPrivateCopies(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to private copies with initializers for\n  /// new private variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param PrivateVL List of references to private copies with initializers.\n  static OMPPrivateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation LParenLoc,\n                                  SourceLocation EndLoc, ArrayRef<Expr *> VL,\n                                  ArrayRef<Expr *> PrivateVL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPPrivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using private_copies_iterator = MutableArrayRef<Expr *>::iterator;\n  using private_copies_const_iterator = ArrayRef<const Expr *>::iterator;\n  using private_copies_range = llvm::iterator_range<private_copies_iterator>;\n  using private_copies_const_range =\n      llvm::iterator_range<private_copies_const_iterator>;\n\n  private_copies_range private_copies() {\n    return private_copies_range(getPrivateCopies().begin(),\n                                getPrivateCopies().end());\n  }\n\n  private_copies_const_range private_copies() const {\n    return private_copies_const_range(getPrivateCopies().begin(),\n                                      getPrivateCopies().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPPrivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_private;\n  }\n};\n\n/// This represents clause 'firstprivate' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp parallel firstprivate(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'firstprivate'\n/// with the variables 'a' and 'b'.\nclass OMPFirstprivateClause final\n    : public OMPVarListClause<OMPFirstprivateClause>,\n      public OMPClauseWithPreInit,\n      private llvm::TrailingObjects<OMPFirstprivateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPFirstprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                        SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPFirstprivateClause>(llvm::omp::OMPC_firstprivate,\n                                                StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPreInit(this) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPFirstprivateClause(unsigned N)\n      : OMPVarListClause<OMPFirstprivateClause>(\n            llvm::omp::OMPC_firstprivate, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the list of references to private copies with initializers for\n  /// new private variables.\n  /// \\param VL List of references.\n  void setPrivateCopies(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to private copies with initializers for\n  /// new private variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Sets the list of references to initializer variables for new\n  /// private variables.\n  /// \\param VL List of references.\n  void setInits(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to initializer variables for new\n  /// private variables.\n  MutableArrayRef<Expr *> getInits() {\n    return MutableArrayRef<Expr *>(getPrivateCopies().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInits() const {\n    return llvm::makeArrayRef(getPrivateCopies().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the original variables.\n  /// \\param PrivateVL List of references to private copies with initializers.\n  /// \\param InitVL List of references to auto generated variables used for\n  /// initialization of a single array element. Used if firstprivate variable is\n  /// of array type.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  static OMPFirstprivateClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> PrivateVL,\n         ArrayRef<Expr *> InitVL, Stmt *PreInit);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPFirstprivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using private_copies_iterator = MutableArrayRef<Expr *>::iterator;\n  using private_copies_const_iterator = ArrayRef<const Expr *>::iterator;\n  using private_copies_range = llvm::iterator_range<private_copies_iterator>;\n  using private_copies_const_range =\n      llvm::iterator_range<private_copies_const_iterator>;\n\n  private_copies_range private_copies() {\n    return private_copies_range(getPrivateCopies().begin(),\n                                getPrivateCopies().end());\n  }\n  private_copies_const_range private_copies() const {\n    return private_copies_const_range(getPrivateCopies().begin(),\n                                      getPrivateCopies().end());\n  }\n\n  using inits_iterator = MutableArrayRef<Expr *>::iterator;\n  using inits_const_iterator = ArrayRef<const Expr *>::iterator;\n  using inits_range = llvm::iterator_range<inits_iterator>;\n  using inits_const_range = llvm::iterator_range<inits_const_iterator>;\n\n  inits_range inits() {\n    return inits_range(getInits().begin(), getInits().end());\n  }\n  inits_const_range inits() const {\n    return inits_const_range(getInits().begin(), getInits().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPFirstprivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPFirstprivateClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_firstprivate;\n  }\n};\n\n/// This represents clause 'lastprivate' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp simd lastprivate(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'lastprivate'\n/// with the variables 'a' and 'b'.\nclass OMPLastprivateClause final\n    : public OMPVarListClause<OMPLastprivateClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPLastprivateClause, Expr *> {\n  // There are 4 additional tail-allocated arrays at the end of the class:\n  // 1. Contains list of pseudo variables with the default initialization for\n  // each non-firstprivate variables. Used in codegen for initialization of\n  // lastprivate copies.\n  // 2. List of helper expressions for proper generation of assignment operation\n  // required for lastprivate clause. This list represents private variables\n  // (for arrays, single array element).\n  // 3. List of helper expressions for proper generation of assignment operation\n  // required for lastprivate clause. This list represents original variables\n  // (for arrays, single array element).\n  // 4. List of helper expressions that represents assignment operation:\n  // \\code\n  // DstExprs = SrcExprs;\n  // \\endcode\n  // Required for proper codegen of final assignment performed by the\n  // lastprivate clause.\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Optional lastprivate kind, e.g. 'conditional', if specified by user.\n  OpenMPLastprivateModifier LPKind;\n  /// Optional location of the lasptrivate kind, if specified by user.\n  SourceLocation LPKindLoc;\n  /// Optional colon location, if specified by user.\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPLastprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc, OpenMPLastprivateModifier LPKind,\n                       SourceLocation LPKindLoc, SourceLocation ColonLoc,\n                       unsigned N)\n      : OMPVarListClause<OMPLastprivateClause>(llvm::omp::OMPC_lastprivate,\n                                               StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), LPKind(LPKind), LPKindLoc(LPKindLoc),\n        ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPLastprivateClause(unsigned N)\n      : OMPVarListClause<OMPLastprivateClause>(\n            llvm::omp::OMPC_lastprivate, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Get the list of helper expressions for initialization of private\n  /// copies for lastprivate variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent private variables (for arrays, single\n  /// array element) in the final assignment statement performed by the\n  /// lastprivate clause.\n  void setSourceExprs(ArrayRef<Expr *> SrcExprs);\n\n  /// Get the list of helper source expressions.\n  MutableArrayRef<Expr *> getSourceExprs() {\n    return MutableArrayRef<Expr *>(getPrivateCopies().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getSourceExprs() const {\n    return llvm::makeArrayRef(getPrivateCopies().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent original variables (for arrays, single\n  /// array element) in the final assignment statement performed by the\n  /// lastprivate clause.\n  void setDestinationExprs(ArrayRef<Expr *> DstExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getDestinationExprs() {\n    return MutableArrayRef<Expr *>(getSourceExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getDestinationExprs() const {\n    return llvm::makeArrayRef(getSourceExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper assignment expressions, required for proper\n  /// codegen of the clause. These expressions are assignment expressions that\n  /// assign private copy of the variable to original variable.\n  void setAssignmentOps(ArrayRef<Expr *> AssignmentOps);\n\n  /// Get the list of helper assignment expressions.\n  MutableArrayRef<Expr *> getAssignmentOps() {\n    return MutableArrayRef<Expr *>(getDestinationExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getAssignmentOps() const {\n    return llvm::makeArrayRef(getDestinationExprs().end(), varlist_size());\n  }\n\n  /// Sets lastprivate kind.\n  void setKind(OpenMPLastprivateModifier Kind) { LPKind = Kind; }\n  /// Sets location of the lastprivate kind.\n  void setKindLoc(SourceLocation Loc) { LPKindLoc = Loc; }\n  /// Sets colon symbol location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param SrcExprs List of helper expressions for proper generation of\n  /// assignment operation required for lastprivate clause. This list represents\n  /// private variables (for arrays, single array element).\n  /// \\param DstExprs List of helper expressions for proper generation of\n  /// assignment operation required for lastprivate clause. This list represents\n  /// original variables (for arrays, single array element).\n  /// \\param AssignmentOps List of helper expressions that represents assignment\n  /// operation:\n  /// \\code\n  /// DstExprs = SrcExprs;\n  /// \\endcode\n  /// Required for proper codegen of final assignment performed by the\n  /// lastprivate clause.\n  /// \\param LPKind Lastprivate kind, e.g. 'conditional'.\n  /// \\param LPKindLoc Location of the lastprivate kind.\n  /// \\param ColonLoc Location of the ':' symbol if lastprivate kind is used.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPLastprivateClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> SrcExprs,\n         ArrayRef<Expr *> DstExprs, ArrayRef<Expr *> AssignmentOps,\n         OpenMPLastprivateModifier LPKind, SourceLocation LPKindLoc,\n         SourceLocation ColonLoc, Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPLastprivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Lastprivate kind.\n  OpenMPLastprivateModifier getKind() const { return LPKind; }\n  /// Returns the location of the lastprivate kind.\n  SourceLocation getKindLoc() const { return LPKindLoc; }\n  /// Returns the location of the ':' symbol, if any.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  /// Set list of helper expressions, required for generation of private\n  /// copies of original lastprivate variables.\n  void setPrivateCopies(ArrayRef<Expr *> PrivateCopies);\n\n  helper_expr_const_range private_copies() const {\n    return helper_expr_const_range(getPrivateCopies().begin(),\n                                   getPrivateCopies().end());\n  }\n\n  helper_expr_range private_copies() {\n    return helper_expr_range(getPrivateCopies().begin(),\n                             getPrivateCopies().end());\n  }\n\n  helper_expr_const_range source_exprs() const {\n    return helper_expr_const_range(getSourceExprs().begin(),\n                                   getSourceExprs().end());\n  }\n\n  helper_expr_range source_exprs() {\n    return helper_expr_range(getSourceExprs().begin(), getSourceExprs().end());\n  }\n\n  helper_expr_const_range destination_exprs() const {\n    return helper_expr_const_range(getDestinationExprs().begin(),\n                                   getDestinationExprs().end());\n  }\n\n  helper_expr_range destination_exprs() {\n    return helper_expr_range(getDestinationExprs().begin(),\n                             getDestinationExprs().end());\n  }\n\n  helper_expr_const_range assignment_ops() const {\n    return helper_expr_const_range(getAssignmentOps().begin(),\n                                   getAssignmentOps().end());\n  }\n\n  helper_expr_range assignment_ops() {\n    return helper_expr_range(getAssignmentOps().begin(),\n                             getAssignmentOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPLastprivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_lastprivate;\n  }\n};\n\n/// This represents clause 'shared' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel shared(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'shared'\n/// with the variables 'a' and 'b'.\nclass OMPSharedClause final\n    : public OMPVarListClause<OMPSharedClause>,\n      private llvm::TrailingObjects<OMPSharedClause, Expr *> {\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPSharedClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPSharedClause>(llvm::omp::OMPC_shared, StartLoc,\n                                          LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPSharedClause(unsigned N)\n      : OMPVarListClause<OMPSharedClause>(llvm::omp::OMPC_shared,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPSharedClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPSharedClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPSharedClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_shared;\n  }\n};\n\n/// This represents clause 'reduction' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp parallel reduction(+:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'reduction'\n/// with operator '+' and the variables 'a' and 'b'.\nclass OMPReductionClause final\n    : public OMPVarListClause<OMPReductionClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPReductionClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Reduction modifier.\n  OpenMPReductionClauseModifier Modifier = OMPC_REDUCTION_unknown;\n\n  /// Reduction modifier location.\n  SourceLocation ModifierLoc;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Nested name specifier for C++.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Name of custom operator.\n  DeclarationNameInfo NameInfo;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  OMPReductionClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation ModifierLoc, SourceLocation ColonLoc,\n                     SourceLocation EndLoc,\n                     OpenMPReductionClauseModifier Modifier, unsigned N,\n                     NestedNameSpecifierLoc QualifierLoc,\n                     const DeclarationNameInfo &NameInfo)\n      : OMPVarListClause<OMPReductionClause>(llvm::omp::OMPC_reduction,\n                                             StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), Modifier(Modifier),\n        ModifierLoc(ModifierLoc), ColonLoc(ColonLoc),\n        QualifierLoc(QualifierLoc), NameInfo(NameInfo) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPReductionClause(unsigned N)\n      : OMPVarListClause<OMPReductionClause>(llvm::omp::OMPC_reduction,\n                                             SourceLocation(), SourceLocation(),\n                                             SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Sets reduction modifier.\n  void setModifier(OpenMPReductionClauseModifier M) { Modifier = M; }\n\n  /// Sets location of the modifier.\n  void setModifierLoc(SourceLocation Loc) { ModifierLoc = Loc; }\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  /// Sets the name info for specified reduction identifier.\n  void setNameInfo(DeclarationNameInfo DNI) { NameInfo = DNI; }\n\n  /// Sets the nested name specifier.\n  void setQualifierLoc(NestedNameSpecifierLoc NSL) { QualifierLoc = NSL; }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent private copy of the reduction\n  /// variable.\n  void setPrivates(ArrayRef<Expr *> Privates);\n\n  /// Get the list of helper privates.\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent LHS expression in the final\n  /// reduction expression performed by the reduction clause.\n  void setLHSExprs(ArrayRef<Expr *> LHSExprs);\n\n  /// Get the list of helper LHS expressions.\n  MutableArrayRef<Expr *> getLHSExprs() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getLHSExprs() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent RHS expression in the final\n  /// reduction expression performed by the reduction clause.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  void setRHSExprs(ArrayRef<Expr *> RHSExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getRHSExprs() {\n    return MutableArrayRef<Expr *>(getLHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getRHSExprs() const {\n    return llvm::makeArrayRef(getLHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction expressions, required for proper\n  /// codegen of the clause. These expressions are binary expressions or\n  /// operator/custom reduction call that calculates new value from source\n  /// helper expressions to destination helper expressions.\n  void setReductionOps(ArrayRef<Expr *> ReductionOps);\n\n  /// Get the list of helper reduction expressions.\n  MutableArrayRef<Expr *> getReductionOps() {\n    return MutableArrayRef<Expr *>(getRHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getReductionOps() const {\n    return llvm::makeArrayRef(getRHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper copy operations for inscan reductions.\n  /// The form is: Temps[i] = LHS[i];\n  void setInscanCopyOps(ArrayRef<Expr *> Ops);\n\n  /// Get the list of helper inscan copy operations.\n  MutableArrayRef<Expr *> getInscanCopyOps() {\n    return MutableArrayRef<Expr *>(getReductionOps().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInscanCopyOps() const {\n    return llvm::makeArrayRef(getReductionOps().end(), varlist_size());\n  }\n\n  /// Set list of helper temp vars for inscan copy array operations.\n  void setInscanCopyArrayTemps(ArrayRef<Expr *> CopyArrayTemps);\n\n  /// Get the list of helper inscan copy temps.\n  MutableArrayRef<Expr *> getInscanCopyArrayTemps() {\n    return MutableArrayRef<Expr *>(getInscanCopyOps().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInscanCopyArrayTemps() const {\n    return llvm::makeArrayRef(getInscanCopyOps().end(), varlist_size());\n  }\n\n  /// Set list of helper temp elements vars for inscan copy array operations.\n  void setInscanCopyArrayElems(ArrayRef<Expr *> CopyArrayElems);\n\n  /// Get the list of helper inscan copy temps.\n  MutableArrayRef<Expr *> getInscanCopyArrayElems() {\n    return MutableArrayRef<Expr *>(getInscanCopyArrayTemps().end(),\n                                   varlist_size());\n  }\n  ArrayRef<const Expr *> getInscanCopyArrayElems() const {\n    return llvm::makeArrayRef(getInscanCopyArrayTemps().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL The variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  /// \\param Privates List of helper expressions for proper generation of\n  /// private copies.\n  /// \\param LHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// LHSs of the reduction expressions.\n  /// \\param RHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// RHSs of the reduction expressions.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  /// \\param ReductionOps List of helper expressions that represents reduction\n  /// expressions:\n  /// \\code\n  /// LHSExprs binop RHSExprs;\n  /// operator binop(LHSExpr, RHSExpr);\n  /// <CutomReduction>(LHSExpr, RHSExpr);\n  /// \\endcode\n  /// Required for proper codegen of final reduction operation performed by the\n  /// reduction clause.\n  /// \\param CopyOps List of copy operations for inscan reductions:\n  /// \\code\n  /// TempExprs = LHSExprs;\n  /// \\endcode\n  /// \\param CopyArrayTemps Temp arrays for prefix sums.\n  /// \\param CopyArrayElems Temp arrays for prefix sums.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPReductionClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation ModifierLoc, SourceLocation ColonLoc,\n         SourceLocation EndLoc, OpenMPReductionClauseModifier Modifier,\n         ArrayRef<Expr *> VL, NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, ArrayRef<Expr *> Privates,\n         ArrayRef<Expr *> LHSExprs, ArrayRef<Expr *> RHSExprs,\n         ArrayRef<Expr *> ReductionOps, ArrayRef<Expr *> CopyOps,\n         ArrayRef<Expr *> CopyArrayTemps, ArrayRef<Expr *> CopyArrayElems,\n         Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  /// \\param Modifier Reduction modifier.\n  static OMPReductionClause *\n  CreateEmpty(const ASTContext &C, unsigned N,\n              OpenMPReductionClauseModifier Modifier);\n\n  /// Returns modifier.\n  OpenMPReductionClauseModifier getModifier() const { return Modifier; }\n\n  /// Returns modifier location.\n  SourceLocation getModifierLoc() const { return ModifierLoc; }\n\n  /// Gets location of ':' symbol in clause.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Gets the name info for specified reduction identifier.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the nested name specifier.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range privates() const {\n    return helper_expr_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_range privates() {\n    return helper_expr_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_const_range lhs_exprs() const {\n    return helper_expr_const_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_range lhs_exprs() {\n    return helper_expr_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_const_range rhs_exprs() const {\n    return helper_expr_const_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_range rhs_exprs() {\n    return helper_expr_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_const_range reduction_ops() const {\n    return helper_expr_const_range(getReductionOps().begin(),\n                                   getReductionOps().end());\n  }\n\n  helper_expr_range reduction_ops() {\n    return helper_expr_range(getReductionOps().begin(),\n                             getReductionOps().end());\n  }\n\n  helper_expr_const_range copy_ops() const {\n    return helper_expr_const_range(getInscanCopyOps().begin(),\n                                   getInscanCopyOps().end());\n  }\n\n  helper_expr_range copy_ops() {\n    return helper_expr_range(getInscanCopyOps().begin(),\n                             getInscanCopyOps().end());\n  }\n\n  helper_expr_const_range copy_array_temps() const {\n    return helper_expr_const_range(getInscanCopyArrayTemps().begin(),\n                                   getInscanCopyArrayTemps().end());\n  }\n\n  helper_expr_range copy_array_temps() {\n    return helper_expr_range(getInscanCopyArrayTemps().begin(),\n                             getInscanCopyArrayTemps().end());\n  }\n\n  helper_expr_const_range copy_array_elems() const {\n    return helper_expr_const_range(getInscanCopyArrayElems().begin(),\n                                   getInscanCopyArrayElems().end());\n  }\n\n  helper_expr_range copy_array_elems() {\n    return helper_expr_range(getInscanCopyArrayElems().begin(),\n                             getInscanCopyArrayElems().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPReductionClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPReductionClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_reduction;\n  }\n};\n\n/// This represents clause 'task_reduction' in the '#pragma omp taskgroup'\n/// directives.\n///\n/// \\code\n/// #pragma omp taskgroup task_reduction(+:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp taskgroup' has clause\n/// 'task_reduction' with operator '+' and the variables 'a' and 'b'.\nclass OMPTaskReductionClause final\n    : public OMPVarListClause<OMPTaskReductionClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPTaskReductionClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Nested name specifier for C++.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Name of custom operator.\n  DeclarationNameInfo NameInfo;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param N Number of the variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  OMPTaskReductionClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                         SourceLocation ColonLoc, SourceLocation EndLoc,\n                         unsigned N, NestedNameSpecifierLoc QualifierLoc,\n                         const DeclarationNameInfo &NameInfo)\n      : OMPVarListClause<OMPTaskReductionClause>(\n            llvm::omp::OMPC_task_reduction, StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), ColonLoc(ColonLoc),\n        QualifierLoc(QualifierLoc), NameInfo(NameInfo) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPTaskReductionClause(unsigned N)\n      : OMPVarListClause<OMPTaskReductionClause>(\n            llvm::omp::OMPC_task_reduction, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  /// Sets the name info for specified reduction identifier.\n  void setNameInfo(DeclarationNameInfo DNI) { NameInfo = DNI; }\n\n  /// Sets the nested name specifier.\n  void setQualifierLoc(NestedNameSpecifierLoc NSL) { QualifierLoc = NSL; }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent private copy of the reduction variable.\n  void setPrivates(ArrayRef<Expr *> Privates);\n\n  /// Get the list of helper privates.\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent LHS expression in the final reduction\n  /// expression performed by the reduction clause.\n  void setLHSExprs(ArrayRef<Expr *> LHSExprs);\n\n  /// Get the list of helper LHS expressions.\n  MutableArrayRef<Expr *> getLHSExprs() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getLHSExprs() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent RHS expression in the final reduction\n  /// expression performed by the reduction clause. Also, variables in these\n  /// expressions are used for proper initialization of reduction copies.\n  void setRHSExprs(ArrayRef<Expr *> RHSExprs);\n\n  ///  Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getRHSExprs() {\n    return MutableArrayRef<Expr *>(getLHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getRHSExprs() const {\n    return llvm::makeArrayRef(getLHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction expressions, required for proper\n  /// codegen of the clause. These expressions are binary expressions or\n  /// operator/custom reduction call that calculates new value from source\n  /// helper expressions to destination helper expressions.\n  void setReductionOps(ArrayRef<Expr *> ReductionOps);\n\n  ///  Get the list of helper reduction expressions.\n  MutableArrayRef<Expr *> getReductionOps() {\n    return MutableArrayRef<Expr *>(getRHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getReductionOps() const {\n    return llvm::makeArrayRef(getRHSExprs().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL The variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  /// \\param Privates List of helper expressions for proper generation of\n  /// private copies.\n  /// \\param LHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// LHSs of the reduction expressions.\n  /// \\param RHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// RHSs of the reduction expressions.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  /// \\param ReductionOps List of helper expressions that represents reduction\n  /// expressions:\n  /// \\code\n  /// LHSExprs binop RHSExprs;\n  /// operator binop(LHSExpr, RHSExpr);\n  /// <CutomReduction>(LHSExpr, RHSExpr);\n  /// \\endcode\n  /// Required for proper codegen of final reduction operation performed by the\n  /// reduction clause.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPTaskReductionClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation ColonLoc, SourceLocation EndLoc, ArrayRef<Expr *> VL,\n         NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, ArrayRef<Expr *> Privates,\n         ArrayRef<Expr *> LHSExprs, ArrayRef<Expr *> RHSExprs,\n         ArrayRef<Expr *> ReductionOps, Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPTaskReductionClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Gets location of ':' symbol in clause.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Gets the name info for specified reduction identifier.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the nested name specifier.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range privates() const {\n    return helper_expr_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_range privates() {\n    return helper_expr_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_const_range lhs_exprs() const {\n    return helper_expr_const_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_range lhs_exprs() {\n    return helper_expr_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_const_range rhs_exprs() const {\n    return helper_expr_const_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_range rhs_exprs() {\n    return helper_expr_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_const_range reduction_ops() const {\n    return helper_expr_const_range(getReductionOps().begin(),\n                                   getReductionOps().end());\n  }\n\n  helper_expr_range reduction_ops() {\n    return helper_expr_range(getReductionOps().begin(),\n                             getReductionOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPTaskReductionClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_task_reduction;\n  }\n};\n\n/// This represents clause 'in_reduction' in the '#pragma omp task' directives.\n///\n/// \\code\n/// #pragma omp task in_reduction(+:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp task' has clause 'in_reduction' with\n/// operator '+' and the variables 'a' and 'b'.\nclass OMPInReductionClause final\n    : public OMPVarListClause<OMPInReductionClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPInReductionClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Nested name specifier for C++.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Name of custom operator.\n  DeclarationNameInfo NameInfo;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param N Number of the variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  OMPInReductionClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation ColonLoc, SourceLocation EndLoc,\n                       unsigned N, NestedNameSpecifierLoc QualifierLoc,\n                       const DeclarationNameInfo &NameInfo)\n      : OMPVarListClause<OMPInReductionClause>(llvm::omp::OMPC_in_reduction,\n                                               StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), ColonLoc(ColonLoc),\n        QualifierLoc(QualifierLoc), NameInfo(NameInfo) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPInReductionClause(unsigned N)\n      : OMPVarListClause<OMPInReductionClause>(\n            llvm::omp::OMPC_in_reduction, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  /// Sets the name info for specified reduction identifier.\n  void setNameInfo(DeclarationNameInfo DNI) { NameInfo = DNI; }\n\n  /// Sets the nested name specifier.\n  void setQualifierLoc(NestedNameSpecifierLoc NSL) { QualifierLoc = NSL; }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent private copy of the reduction variable.\n  void setPrivates(ArrayRef<Expr *> Privates);\n\n  /// Get the list of helper privates.\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent LHS expression in the final reduction\n  /// expression performed by the reduction clause.\n  void setLHSExprs(ArrayRef<Expr *> LHSExprs);\n\n  /// Get the list of helper LHS expressions.\n  MutableArrayRef<Expr *> getLHSExprs() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getLHSExprs() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent RHS expression in the final reduction\n  /// expression performed by the reduction clause. Also, variables in these\n  /// expressions are used for proper initialization of reduction copies.\n  void setRHSExprs(ArrayRef<Expr *> RHSExprs);\n\n  ///  Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getRHSExprs() {\n    return MutableArrayRef<Expr *>(getLHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getRHSExprs() const {\n    return llvm::makeArrayRef(getLHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction expressions, required for proper\n  /// codegen of the clause. These expressions are binary expressions or\n  /// operator/custom reduction call that calculates new value from source\n  /// helper expressions to destination helper expressions.\n  void setReductionOps(ArrayRef<Expr *> ReductionOps);\n\n  ///  Get the list of helper reduction expressions.\n  MutableArrayRef<Expr *> getReductionOps() {\n    return MutableArrayRef<Expr *>(getRHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getReductionOps() const {\n    return llvm::makeArrayRef(getRHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction taskgroup descriptors.\n  void setTaskgroupDescriptors(ArrayRef<Expr *> ReductionOps);\n\n  ///  Get the list of helper reduction taskgroup descriptors.\n  MutableArrayRef<Expr *> getTaskgroupDescriptors() {\n    return MutableArrayRef<Expr *>(getReductionOps().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getTaskgroupDescriptors() const {\n    return llvm::makeArrayRef(getReductionOps().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL The variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  /// \\param Privates List of helper expressions for proper generation of\n  /// private copies.\n  /// \\param LHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// LHSs of the reduction expressions.\n  /// \\param RHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// RHSs of the reduction expressions.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  /// \\param ReductionOps List of helper expressions that represents reduction\n  /// expressions:\n  /// \\code\n  /// LHSExprs binop RHSExprs;\n  /// operator binop(LHSExpr, RHSExpr);\n  /// <CutomReduction>(LHSExpr, RHSExpr);\n  /// \\endcode\n  /// Required for proper codegen of final reduction operation performed by the\n  /// reduction clause.\n  /// \\param TaskgroupDescriptors List of helper taskgroup descriptors for\n  /// corresponding items in parent taskgroup task_reduction clause.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPInReductionClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation ColonLoc, SourceLocation EndLoc, ArrayRef<Expr *> VL,\n         NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, ArrayRef<Expr *> Privates,\n         ArrayRef<Expr *> LHSExprs, ArrayRef<Expr *> RHSExprs,\n         ArrayRef<Expr *> ReductionOps, ArrayRef<Expr *> TaskgroupDescriptors,\n         Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPInReductionClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Gets location of ':' symbol in clause.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Gets the name info for specified reduction identifier.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the nested name specifier.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range privates() const {\n    return helper_expr_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_range privates() {\n    return helper_expr_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_const_range lhs_exprs() const {\n    return helper_expr_const_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_range lhs_exprs() {\n    return helper_expr_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_const_range rhs_exprs() const {\n    return helper_expr_const_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_range rhs_exprs() {\n    return helper_expr_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_const_range reduction_ops() const {\n    return helper_expr_const_range(getReductionOps().begin(),\n                                   getReductionOps().end());\n  }\n\n  helper_expr_range reduction_ops() {\n    return helper_expr_range(getReductionOps().begin(),\n                             getReductionOps().end());\n  }\n\n  helper_expr_const_range taskgroup_descriptors() const {\n    return helper_expr_const_range(getTaskgroupDescriptors().begin(),\n                                   getTaskgroupDescriptors().end());\n  }\n\n  helper_expr_range taskgroup_descriptors() {\n    return helper_expr_range(getTaskgroupDescriptors().begin(),\n                             getTaskgroupDescriptors().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPInReductionClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_in_reduction;\n  }\n};\n\n/// This represents clause 'linear' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp simd linear(a,b : 2)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'linear'\n/// with variables 'a', 'b' and linear step '2'.\nclass OMPLinearClause final\n    : public OMPVarListClause<OMPLinearClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPLinearClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Modifier of 'linear' clause.\n  OpenMPLinearClauseKind Modifier = OMPC_LINEAR_val;\n\n  /// Location of linear modifier if any.\n  SourceLocation ModifierLoc;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Sets the linear step for clause.\n  void setStep(Expr *Step) { *(getFinals().end()) = Step; }\n\n  /// Sets the expression to calculate linear step for clause.\n  void setCalcStep(Expr *CalcStep) { *(getFinals().end() + 1) = CalcStep; }\n\n  /// Build 'linear' clause with given number of variables \\a NumVars.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param NumVars Number of variables.\n  OMPLinearClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  OpenMPLinearClauseKind Modifier, SourceLocation ModifierLoc,\n                  SourceLocation ColonLoc, SourceLocation EndLoc,\n                  unsigned NumVars)\n      : OMPVarListClause<OMPLinearClause>(llvm::omp::OMPC_linear, StartLoc,\n                                          LParenLoc, EndLoc, NumVars),\n        OMPClauseWithPostUpdate(this), Modifier(Modifier),\n        ModifierLoc(ModifierLoc), ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param NumVars Number of variables.\n  explicit OMPLinearClause(unsigned NumVars)\n      : OMPVarListClause<OMPLinearClause>(llvm::omp::OMPC_linear,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), NumVars),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Gets the list of initial values for linear variables.\n  ///\n  /// There are NumVars expressions with initial values allocated after the\n  /// varlist, they are followed by NumVars update expressions (used to update\n  /// the linear variable's value on current iteration) and they are followed by\n  /// NumVars final expressions (used to calculate the linear variable's\n  /// value after the loop body). After these lists, there are 2 helper\n  /// expressions - linear step and a helper to calculate it before the\n  /// loop body (used when the linear step is not constant):\n  ///\n  /// { Vars[] /* in OMPVarListClause */; Privates[]; Inits[]; Updates[];\n  /// Finals[]; Step; CalcStep; }\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  MutableArrayRef<Expr *> getInits() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInits() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Sets the list of update expressions for linear variables.\n  MutableArrayRef<Expr *> getUpdates() {\n    return MutableArrayRef<Expr *>(getInits().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getUpdates() const {\n    return llvm::makeArrayRef(getInits().end(), varlist_size());\n  }\n\n  /// Sets the list of final update expressions for linear variables.\n  MutableArrayRef<Expr *> getFinals() {\n    return MutableArrayRef<Expr *>(getUpdates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getFinals() const {\n    return llvm::makeArrayRef(getUpdates().end(), varlist_size());\n  }\n\n  /// Gets the list of used expressions for linear variables.\n  MutableArrayRef<Expr *> getUsedExprs() {\n    return MutableArrayRef<Expr *>(getFinals().end() + 2, varlist_size() + 1);\n  }\n  ArrayRef<const Expr *> getUsedExprs() const {\n    return llvm::makeArrayRef(getFinals().end() + 2, varlist_size() + 1);\n  }\n\n  /// Sets the list of the copies of original linear variables.\n  /// \\param PL List of expressions.\n  void setPrivates(ArrayRef<Expr *> PL);\n\n  /// Sets the list of the initial values for linear variables.\n  /// \\param IL List of expressions.\n  void setInits(ArrayRef<Expr *> IL);\n\npublic:\n  /// Creates clause with a list of variables \\a VL and a linear step\n  /// \\a Step.\n  ///\n  /// \\param C AST Context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param Modifier Modifier of 'linear' clause.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param PL List of private copies of original variables.\n  /// \\param IL List of initial values for the variables.\n  /// \\param Step Linear step.\n  /// \\param CalcStep Calculation of the linear step.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPLinearClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         OpenMPLinearClauseKind Modifier, SourceLocation ModifierLoc,\n         SourceLocation ColonLoc, SourceLocation EndLoc, ArrayRef<Expr *> VL,\n         ArrayRef<Expr *> PL, ArrayRef<Expr *> IL, Expr *Step, Expr *CalcStep,\n         Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param NumVars Number of variables.\n  static OMPLinearClause *CreateEmpty(const ASTContext &C, unsigned NumVars);\n\n  /// Set modifier.\n  void setModifier(OpenMPLinearClauseKind Kind) { Modifier = Kind; }\n\n  /// Return modifier.\n  OpenMPLinearClauseKind getModifier() const { return Modifier; }\n\n  /// Set modifier location.\n  void setModifierLoc(SourceLocation Loc) { ModifierLoc = Loc; }\n\n  /// Return modifier location.\n  SourceLocation getModifierLoc() const { return ModifierLoc; }\n\n  /// Sets the location of ':'.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Returns the location of ':'.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Returns linear step.\n  Expr *getStep() { return *(getFinals().end()); }\n\n  /// Returns linear step.\n  const Expr *getStep() const { return *(getFinals().end()); }\n\n  /// Returns expression to calculate linear step.\n  Expr *getCalcStep() { return *(getFinals().end() + 1); }\n\n  /// Returns expression to calculate linear step.\n  const Expr *getCalcStep() const { return *(getFinals().end() + 1); }\n\n  /// Sets the list of update expressions for linear variables.\n  /// \\param UL List of expressions.\n  void setUpdates(ArrayRef<Expr *> UL);\n\n  /// Sets the list of final update expressions for linear variables.\n  /// \\param FL List of expressions.\n  void setFinals(ArrayRef<Expr *> FL);\n\n  /// Sets the list of used expressions for the linear clause.\n  void setUsedExprs(ArrayRef<Expr *> UE);\n\n  using privates_iterator = MutableArrayRef<Expr *>::iterator;\n  using privates_const_iterator = ArrayRef<const Expr *>::iterator;\n  using privates_range = llvm::iterator_range<privates_iterator>;\n  using privates_const_range = llvm::iterator_range<privates_const_iterator>;\n\n  privates_range privates() {\n    return privates_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  privates_const_range privates() const {\n    return privates_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  using inits_iterator = MutableArrayRef<Expr *>::iterator;\n  using inits_const_iterator = ArrayRef<const Expr *>::iterator;\n  using inits_range = llvm::iterator_range<inits_iterator>;\n  using inits_const_range = llvm::iterator_range<inits_const_iterator>;\n\n  inits_range inits() {\n    return inits_range(getInits().begin(), getInits().end());\n  }\n\n  inits_const_range inits() const {\n    return inits_const_range(getInits().begin(), getInits().end());\n  }\n\n  using updates_iterator = MutableArrayRef<Expr *>::iterator;\n  using updates_const_iterator = ArrayRef<const Expr *>::iterator;\n  using updates_range = llvm::iterator_range<updates_iterator>;\n  using updates_const_range = llvm::iterator_range<updates_const_iterator>;\n\n  updates_range updates() {\n    return updates_range(getUpdates().begin(), getUpdates().end());\n  }\n\n  updates_const_range updates() const {\n    return updates_const_range(getUpdates().begin(), getUpdates().end());\n  }\n\n  using finals_iterator = MutableArrayRef<Expr *>::iterator;\n  using finals_const_iterator = ArrayRef<const Expr *>::iterator;\n  using finals_range = llvm::iterator_range<finals_iterator>;\n  using finals_const_range = llvm::iterator_range<finals_const_iterator>;\n\n  finals_range finals() {\n    return finals_range(getFinals().begin(), getFinals().end());\n  }\n\n  finals_const_range finals() const {\n    return finals_const_range(getFinals().begin(), getFinals().end());\n  }\n\n  using used_expressions_iterator = MutableArrayRef<Expr *>::iterator;\n  using used_expressions_const_iterator = ArrayRef<const Expr *>::iterator;\n  using used_expressions_range =\n      llvm::iterator_range<used_expressions_iterator>;\n  using used_expressions_const_range =\n      llvm::iterator_range<used_expressions_const_iterator>;\n\n  used_expressions_range used_expressions() {\n    return finals_range(getUsedExprs().begin(), getUsedExprs().end());\n  }\n\n  used_expressions_const_range used_expressions() const {\n    return finals_const_range(getUsedExprs().begin(), getUsedExprs().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPLinearClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children();\n\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPLinearClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_linear;\n  }\n};\n\n/// This represents clause 'aligned' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp simd aligned(a,b : 8)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'aligned'\n/// with variables 'a', 'b' and alignment '8'.\nclass OMPAlignedClause final\n    : public OMPVarListClause<OMPAlignedClause>,\n      private llvm::TrailingObjects<OMPAlignedClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Sets the alignment for clause.\n  void setAlignment(Expr *A) { *varlist_end() = A; }\n\n  /// Build 'aligned' clause with given number of variables \\a NumVars.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param NumVars Number of variables.\n  OMPAlignedClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation ColonLoc, SourceLocation EndLoc,\n                   unsigned NumVars)\n      : OMPVarListClause<OMPAlignedClause>(llvm::omp::OMPC_aligned, StartLoc,\n                                           LParenLoc, EndLoc, NumVars),\n        ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param NumVars Number of variables.\n  explicit OMPAlignedClause(unsigned NumVars)\n      : OMPVarListClause<OMPAlignedClause>(llvm::omp::OMPC_aligned,\n                                           SourceLocation(), SourceLocation(),\n                                           SourceLocation(), NumVars) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL and alignment \\a A.\n  ///\n  /// \\param C AST Context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param A Alignment.\n  static OMPAlignedClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation LParenLoc,\n                                  SourceLocation ColonLoc,\n                                  SourceLocation EndLoc, ArrayRef<Expr *> VL,\n                                  Expr *A);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param NumVars Number of variables.\n  static OMPAlignedClause *CreateEmpty(const ASTContext &C, unsigned NumVars);\n\n  /// Sets the location of ':'.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Returns the location of ':'.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Returns alignment.\n  Expr *getAlignment() { return *varlist_end(); }\n\n  /// Returns alignment.\n  const Expr *getAlignment() const { return *varlist_end(); }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPAlignedClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_aligned;\n  }\n};\n\n/// This represents clause 'copyin' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel copyin(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'copyin'\n/// with the variables 'a' and 'b'.\nclass OMPCopyinClause final\n    : public OMPVarListClause<OMPCopyinClause>,\n      private llvm::TrailingObjects<OMPCopyinClause, Expr *> {\n  // Class has 3 additional tail allocated arrays:\n  // 1. List of helper expressions for proper generation of assignment operation\n  // required for copyin clause. This list represents sources.\n  // 2. List of helper expressions for proper generation of assignment operation\n  // required for copyin clause. This list represents destinations.\n  // 3. List of helper expressions that represents assignment operation:\n  // \\code\n  // DstExprs = SrcExprs;\n  // \\endcode\n  // Required for proper codegen of propagation of master's thread values of\n  // threadprivate variables to local instances of that variables in other\n  // implicit threads.\n\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPCopyinClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPCopyinClause>(llvm::omp::OMPC_copyin, StartLoc,\n                                          LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPCopyinClause(unsigned N)\n      : OMPVarListClause<OMPCopyinClause>(llvm::omp::OMPC_copyin,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), N) {}\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent source expression in the final\n  /// assignment statement performed by the copyin clause.\n  void setSourceExprs(ArrayRef<Expr *> SrcExprs);\n\n  /// Get the list of helper source expressions.\n  MutableArrayRef<Expr *> getSourceExprs() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getSourceExprs() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent destination expression in the final\n  /// assignment statement performed by the copyin clause.\n  void setDestinationExprs(ArrayRef<Expr *> DstExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getDestinationExprs() {\n    return MutableArrayRef<Expr *>(getSourceExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getDestinationExprs() const {\n    return llvm::makeArrayRef(getSourceExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper assignment expressions, required for proper\n  /// codegen of the clause. These expressions are assignment expressions that\n  /// assign source helper expressions to destination helper expressions\n  /// correspondingly.\n  void setAssignmentOps(ArrayRef<Expr *> AssignmentOps);\n\n  /// Get the list of helper assignment expressions.\n  MutableArrayRef<Expr *> getAssignmentOps() {\n    return MutableArrayRef<Expr *>(getDestinationExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getAssignmentOps() const {\n    return llvm::makeArrayRef(getDestinationExprs().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param SrcExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyin clause. This list represents\n  /// sources.\n  /// \\param DstExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyin clause. This list represents\n  /// destinations.\n  /// \\param AssignmentOps List of helper expressions that represents assignment\n  /// operation:\n  /// \\code\n  /// DstExprs = SrcExprs;\n  /// \\endcode\n  /// Required for proper codegen of propagation of master's thread values of\n  /// threadprivate variables to local instances of that variables in other\n  /// implicit threads.\n  static OMPCopyinClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> SrcExprs,\n         ArrayRef<Expr *> DstExprs, ArrayRef<Expr *> AssignmentOps);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPCopyinClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range source_exprs() const {\n    return helper_expr_const_range(getSourceExprs().begin(),\n                                   getSourceExprs().end());\n  }\n\n  helper_expr_range source_exprs() {\n    return helper_expr_range(getSourceExprs().begin(), getSourceExprs().end());\n  }\n\n  helper_expr_const_range destination_exprs() const {\n    return helper_expr_const_range(getDestinationExprs().begin(),\n                                   getDestinationExprs().end());\n  }\n\n  helper_expr_range destination_exprs() {\n    return helper_expr_range(getDestinationExprs().begin(),\n                             getDestinationExprs().end());\n  }\n\n  helper_expr_const_range assignment_ops() const {\n    return helper_expr_const_range(getAssignmentOps().begin(),\n                                   getAssignmentOps().end());\n  }\n\n  helper_expr_range assignment_ops() {\n    return helper_expr_range(getAssignmentOps().begin(),\n                             getAssignmentOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPCopyinClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_copyin;\n  }\n};\n\n/// This represents clause 'copyprivate' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp single copyprivate(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp single' has clause 'copyprivate'\n/// with the variables 'a' and 'b'.\nclass OMPCopyprivateClause final\n    : public OMPVarListClause<OMPCopyprivateClause>,\n      private llvm::TrailingObjects<OMPCopyprivateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPCopyprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPCopyprivateClause>(llvm::omp::OMPC_copyprivate,\n                                               StartLoc, LParenLoc, EndLoc, N) {\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPCopyprivateClause(unsigned N)\n      : OMPVarListClause<OMPCopyprivateClause>(\n            llvm::omp::OMPC_copyprivate, SourceLocation(), SourceLocation(),\n            SourceLocation(), N) {}\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent source expression in the final\n  /// assignment statement performed by the copyprivate clause.\n  void setSourceExprs(ArrayRef<Expr *> SrcExprs);\n\n  /// Get the list of helper source expressions.\n  MutableArrayRef<Expr *> getSourceExprs() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getSourceExprs() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent destination expression in the final\n  /// assignment statement performed by the copyprivate clause.\n  void setDestinationExprs(ArrayRef<Expr *> DstExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getDestinationExprs() {\n    return MutableArrayRef<Expr *>(getSourceExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getDestinationExprs() const {\n    return llvm::makeArrayRef(getSourceExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper assignment expressions, required for proper\n  /// codegen of the clause. These expressions are assignment expressions that\n  /// assign source helper expressions to destination helper expressions\n  /// correspondingly.\n  void setAssignmentOps(ArrayRef<Expr *> AssignmentOps);\n\n  /// Get the list of helper assignment expressions.\n  MutableArrayRef<Expr *> getAssignmentOps() {\n    return MutableArrayRef<Expr *>(getDestinationExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getAssignmentOps() const {\n    return llvm::makeArrayRef(getDestinationExprs().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param SrcExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// sources.\n  /// \\param DstExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// destinations.\n  /// \\param AssignmentOps List of helper expressions that represents assignment\n  /// operation:\n  /// \\code\n  /// DstExprs = SrcExprs;\n  /// \\endcode\n  /// Required for proper codegen of final assignment performed by the\n  /// copyprivate clause.\n  static OMPCopyprivateClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> SrcExprs,\n         ArrayRef<Expr *> DstExprs, ArrayRef<Expr *> AssignmentOps);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPCopyprivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range source_exprs() const {\n    return helper_expr_const_range(getSourceExprs().begin(),\n                                   getSourceExprs().end());\n  }\n\n  helper_expr_range source_exprs() {\n    return helper_expr_range(getSourceExprs().begin(), getSourceExprs().end());\n  }\n\n  helper_expr_const_range destination_exprs() const {\n    return helper_expr_const_range(getDestinationExprs().begin(),\n                                   getDestinationExprs().end());\n  }\n\n  helper_expr_range destination_exprs() {\n    return helper_expr_range(getDestinationExprs().begin(),\n                             getDestinationExprs().end());\n  }\n\n  helper_expr_const_range assignment_ops() const {\n    return helper_expr_const_range(getAssignmentOps().begin(),\n                                   getAssignmentOps().end());\n  }\n\n  helper_expr_range assignment_ops() {\n    return helper_expr_range(getAssignmentOps().begin(),\n                             getAssignmentOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPCopyprivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_copyprivate;\n  }\n};\n\n/// This represents implicit clause 'flush' for the '#pragma omp flush'\n/// directive.\n/// This clause does not exist by itself, it can be only as a part of 'omp\n/// flush' directive. This clause is introduced to keep the original structure\n/// of \\a OMPExecutableDirective class and its derivatives and to use the\n/// existing infrastructure of clauses with the list of variables.\n///\n/// \\code\n/// #pragma omp flush(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp flush' has implicit clause 'flush'\n/// with the variables 'a' and 'b'.\nclass OMPFlushClause final\n    : public OMPVarListClause<OMPFlushClause>,\n      private llvm::TrailingObjects<OMPFlushClause, Expr *> {\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPFlushClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                 SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPFlushClause>(llvm::omp::OMPC_flush, StartLoc,\n                                         LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPFlushClause(unsigned N)\n      : OMPVarListClause<OMPFlushClause>(llvm::omp::OMPC_flush,\n                                         SourceLocation(), SourceLocation(),\n                                         SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPFlushClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                SourceLocation LParenLoc, SourceLocation EndLoc,\n                                ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPFlushClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPFlushClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_flush;\n  }\n};\n\n/// This represents implicit clause 'depobj' for the '#pragma omp depobj'\n/// directive.\n/// This clause does not exist by itself, it can be only as a part of 'omp\n/// depobj' directive. This clause is introduced to keep the original structure\n/// of \\a OMPExecutableDirective class and its derivatives and to use the\n/// existing infrastructure of clauses with the list of variables.\n///\n/// \\code\n/// #pragma omp depobj(a) destroy\n/// \\endcode\n/// In this example directive '#pragma omp depobj' has implicit clause 'depobj'\n/// with the depobj 'a'.\nclass OMPDepobjClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Chunk size.\n  Expr *Depobj = nullptr;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDepobjClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_depobj, StartLoc, EndLoc),\n        LParenLoc(LParenLoc) {}\n\n  /// Build an empty clause.\n  ///\n  explicit OMPDepobjClause()\n      : OMPClause(llvm::omp::OMPC_depobj, SourceLocation(), SourceLocation()) {}\n\n  void setDepobj(Expr *E) { Depobj = E; }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\npublic:\n  /// Creates clause.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Depobj depobj expression associated with the 'depobj' directive.\n  static OMPDepobjClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc, Expr *Depobj);\n\n  /// Creates an empty clause.\n  ///\n  /// \\param C AST context.\n  static OMPDepobjClause *CreateEmpty(const ASTContext &C);\n\n  /// Returns depobj expression associated with the clause.\n  Expr *getDepobj() { return Depobj; }\n  const Expr *getDepobj() const { return Depobj; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(&Depobj),\n                       reinterpret_cast<Stmt **>(&Depobj) + 1);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPDepobjClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_depobj;\n  }\n};\n\n/// This represents implicit clause 'depend' for the '#pragma omp task'\n/// directive.\n///\n/// \\code\n/// #pragma omp task depend(in:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp task' with clause 'depend' with the\n/// variables 'a' and 'b' with dependency 'in'.\nclass OMPDependClause final\n    : public OMPVarListClause<OMPDependClause>,\n      private llvm::TrailingObjects<OMPDependClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Dependency type (one of in, out, inout).\n  OpenMPDependClauseKind DepKind = OMPC_DEPEND_unknown;\n\n  /// Dependency type location.\n  SourceLocation DepLoc;\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Number of loops, associated with the depend clause.\n  unsigned NumLoops = 0;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  OMPDependClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc, unsigned N, unsigned NumLoops)\n      : OMPVarListClause<OMPDependClause>(llvm::omp::OMPC_depend, StartLoc,\n                                          LParenLoc, EndLoc, N),\n        NumLoops(NumLoops) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  explicit OMPDependClause(unsigned N, unsigned NumLoops)\n      : OMPVarListClause<OMPDependClause>(llvm::omp::OMPC_depend,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), N),\n        NumLoops(NumLoops) {}\n\n  /// Set dependency kind.\n  void setDependencyKind(OpenMPDependClauseKind K) { DepKind = K; }\n\n  /// Set dependency kind and its location.\n  void setDependencyLoc(SourceLocation Loc) { DepLoc = Loc; }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Sets optional dependency modifier.\n  void setModifier(Expr *DepModifier);\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param DepKind Dependency type.\n  /// \\param DepLoc Location of the dependency type.\n  /// \\param ColonLoc Colon location.\n  /// \\param VL List of references to the variables.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  static OMPDependClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc, Expr *DepModifier,\n                                 OpenMPDependClauseKind DepKind,\n                                 SourceLocation DepLoc, SourceLocation ColonLoc,\n                                 ArrayRef<Expr *> VL, unsigned NumLoops);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  static OMPDependClause *CreateEmpty(const ASTContext &C, unsigned N,\n                                      unsigned NumLoops);\n\n  /// Get dependency type.\n  OpenMPDependClauseKind getDependencyKind() const { return DepKind; }\n\n  /// Return optional depend modifier.\n  Expr *getModifier();\n  const Expr *getModifier() const {\n    return const_cast<OMPDependClause *>(this)->getModifier();\n  }\n\n  /// Get dependency type location.\n  SourceLocation getDependencyLoc() const { return DepLoc; }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Get number of loops associated with the clause.\n  unsigned getNumLoops() const { return NumLoops; }\n\n  /// Set the loop data for the depend clauses with 'sink|source' kind of\n  /// dependency.\n  void setLoopData(unsigned NumLoop, Expr *Cnt);\n\n  /// Get the loop data.\n  Expr *getLoopData(unsigned NumLoop);\n  const Expr *getLoopData(unsigned NumLoop) const;\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPDependClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_depend;\n  }\n};\n\n/// This represents 'device' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp target device(a)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'device'\n/// with single expression 'a'.\nclass OMPDeviceClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Device clause modifier.\n  OpenMPDeviceClauseModifier Modifier = OMPC_DEVICE_unknown;\n\n  /// Location of the modifier.\n  SourceLocation ModifierLoc;\n\n  /// Device number.\n  Stmt *Device = nullptr;\n\n  /// Set the device number.\n  ///\n  /// \\param E Device number.\n  void setDevice(Expr *E) { Device = E; }\n\n  /// Sets modifier.\n  void setModifier(OpenMPDeviceClauseModifier M) { Modifier = M; }\n\n  /// Setst modifier location.\n  void setModifierLoc(SourceLocation Loc) { ModifierLoc = Loc; }\n\npublic:\n  /// Build 'device' clause.\n  ///\n  /// \\param Modifier Clause modifier.\n  /// \\param E Expression associated with this clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDeviceClause(OpenMPDeviceClauseModifier Modifier, Expr *E, Stmt *HelperE,\n                  OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                  SourceLocation LParenLoc, SourceLocation ModifierLoc,\n                  SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_device, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Modifier(Modifier),\n        ModifierLoc(ModifierLoc), Device(E) {\n    setPreInitStmt(HelperE, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPDeviceClause()\n      : OMPClause(llvm::omp::OMPC_device, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return device number.\n  Expr *getDevice() { return cast<Expr>(Device); }\n\n  /// Return device number.\n  Expr *getDevice() const { return cast<Expr>(Device); }\n\n  /// Gets modifier.\n  OpenMPDeviceClauseModifier getModifier() const { return Modifier; }\n\n  /// Gets modifier location.\n  SourceLocation getModifierLoc() const { return ModifierLoc; }\n\n  child_range children() { return child_range(&Device, &Device + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Device, &Device + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_device;\n  }\n};\n\n/// This represents 'threads' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp ordered threads\n/// \\endcode\n/// In this example directive '#pragma omp ordered' has simple 'threads' clause.\nclass OMPThreadsClause : public OMPClause {\npublic:\n  /// Build 'threads' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPThreadsClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_threads, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPThreadsClause()\n      : OMPClause(llvm::omp::OMPC_threads, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_threads;\n  }\n};\n\n/// This represents 'simd' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp ordered simd\n/// \\endcode\n/// In this example directive '#pragma omp ordered' has simple 'simd' clause.\nclass OMPSIMDClause : public OMPClause {\npublic:\n  /// Build 'simd' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSIMDClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_simd, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPSIMDClause()\n      : OMPClause(llvm::omp::OMPC_simd, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_simd;\n  }\n};\n\n/// Struct that defines common infrastructure to handle mappable\n/// expressions used in OpenMP clauses.\nclass OMPClauseMappableExprCommon {\npublic:\n  /// Class that represents a component of a mappable expression. E.g.\n  /// for an expression S.a, the first component is a declaration reference\n  /// expression associated with 'S' and the second is a member expression\n  /// associated with the field declaration 'a'. If the expression is an array\n  /// subscript it may not have any associated declaration. In that case the\n  /// associated declaration is set to nullptr.\n  class MappableComponent {\n    /// Pair of Expression and Non-contiguous pair  associated with the\n    /// component.\n    llvm::PointerIntPair<Expr *, 1, bool> AssociatedExpressionNonContiguousPr;\n\n    /// Declaration associated with the declaration. If the component does\n    /// not have a declaration (e.g. array subscripts or section), this is set\n    /// to nullptr.\n    ValueDecl *AssociatedDeclaration = nullptr;\n\n  public:\n    explicit MappableComponent() = default;\n    explicit MappableComponent(Expr *AssociatedExpression,\n                               ValueDecl *AssociatedDeclaration,\n                               bool IsNonContiguous)\n        : AssociatedExpressionNonContiguousPr(AssociatedExpression,\n                                              IsNonContiguous),\n          AssociatedDeclaration(\n              AssociatedDeclaration\n                  ? cast<ValueDecl>(AssociatedDeclaration->getCanonicalDecl())\n                  : nullptr) {}\n\n    Expr *getAssociatedExpression() const {\n      return AssociatedExpressionNonContiguousPr.getPointer();\n    }\n\n    bool isNonContiguous() const {\n      return AssociatedExpressionNonContiguousPr.getInt();\n    }\n\n    ValueDecl *getAssociatedDeclaration() const {\n      return AssociatedDeclaration;\n    }\n  };\n\n  // List of components of an expression. This first one is the whole\n  // expression and the last one is the base expression.\n  using MappableExprComponentList = SmallVector<MappableComponent, 8>;\n  using MappableExprComponentListRef = ArrayRef<MappableComponent>;\n\n  // List of all component lists associated to the same base declaration.\n  // E.g. if both 'S.a' and 'S.b' are a mappable expressions, each will have\n  // their component list but the same base declaration 'S'.\n  using MappableExprComponentLists = SmallVector<MappableExprComponentList, 8>;\n  using MappableExprComponentListsRef = ArrayRef<MappableExprComponentList>;\n\nprotected:\n  // Return the total number of elements in a list of component lists.\n  static unsigned\n  getComponentsTotalNumber(MappableExprComponentListsRef ComponentLists);\n\n  // Return the total number of elements in a list of declarations. All\n  // declarations are expected to be canonical.\n  static unsigned\n  getUniqueDeclarationsTotalNumber(ArrayRef<const ValueDecl *> Declarations);\n};\n\n/// This structure contains all sizes needed for by an\n/// OMPMappableExprListClause.\nstruct OMPMappableExprListSizeTy {\n  /// Number of expressions listed.\n  unsigned NumVars;\n  /// Number of unique base declarations.\n  unsigned NumUniqueDeclarations;\n  /// Number of component lists.\n  unsigned NumComponentLists;\n  /// Total number of expression components.\n  unsigned NumComponents;\n  OMPMappableExprListSizeTy() = default;\n  OMPMappableExprListSizeTy(unsigned NumVars, unsigned NumUniqueDeclarations,\n                            unsigned NumComponentLists, unsigned NumComponents)\n      : NumVars(NumVars), NumUniqueDeclarations(NumUniqueDeclarations),\n        NumComponentLists(NumComponentLists), NumComponents(NumComponents) {}\n};\n\n/// This represents clauses with a list of expressions that are mappable.\n/// Examples of these clauses are 'map' in\n/// '#pragma omp target [enter|exit] [data]...' directives, and  'to' and 'from\n/// in '#pragma omp target update...' directives.\ntemplate <class T>\nclass OMPMappableExprListClause : public OMPVarListClause<T>,\n                                  public OMPClauseMappableExprCommon {\n  friend class OMPClauseReader;\n\n  /// Number of unique declarations in this clause.\n  unsigned NumUniqueDeclarations;\n\n  /// Number of component lists in this clause.\n  unsigned NumComponentLists;\n\n  /// Total number of components in this clause.\n  unsigned NumComponents;\n\n  /// Whether this clause is possible to have user-defined mappers associated.\n  /// It should be true for map, to, and from clauses, and false for\n  /// use_device_ptr and is_device_ptr.\n  const bool SupportsMapper;\n\n  /// C++ nested name specifier for the associated user-defined mapper.\n  NestedNameSpecifierLoc MapperQualifierLoc;\n\n  /// The associated user-defined mapper identifier information.\n  DeclarationNameInfo MapperIdInfo;\n\nprotected:\n  /// Build a clause for \\a NumUniqueDeclarations declarations, \\a\n  /// NumComponentLists total component lists, and \\a NumComponents total\n  /// components.\n  ///\n  /// \\param K Kind of the clause.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  /// \\param SupportsMapper Indicates whether this clause is possible to have\n  /// user-defined mappers associated.\n  /// \\param MapperQualifierLocPtr C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfoPtr The identifier of associated user-defined mapper.\n  OMPMappableExprListClause(\n      OpenMPClauseKind K, const OMPVarListLocTy &Locs,\n      const OMPMappableExprListSizeTy &Sizes, bool SupportsMapper = false,\n      NestedNameSpecifierLoc *MapperQualifierLocPtr = nullptr,\n      DeclarationNameInfo *MapperIdInfoPtr = nullptr)\n      : OMPVarListClause<T>(K, Locs.StartLoc, Locs.LParenLoc, Locs.EndLoc,\n                            Sizes.NumVars),\n        NumUniqueDeclarations(Sizes.NumUniqueDeclarations),\n        NumComponentLists(Sizes.NumComponentLists),\n        NumComponents(Sizes.NumComponents), SupportsMapper(SupportsMapper) {\n    if (MapperQualifierLocPtr)\n      MapperQualifierLoc = *MapperQualifierLocPtr;\n    if (MapperIdInfoPtr)\n      MapperIdInfo = *MapperIdInfoPtr;\n  }\n\n  /// Get the unique declarations that are in the trailing objects of the\n  /// class.\n  MutableArrayRef<ValueDecl *> getUniqueDeclsRef() {\n    return MutableArrayRef<ValueDecl *>(\n        static_cast<T *>(this)->template getTrailingObjects<ValueDecl *>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Get the unique declarations that are in the trailing objects of the\n  /// class.\n  ArrayRef<ValueDecl *> getUniqueDeclsRef() const {\n    return ArrayRef<ValueDecl *>(\n        static_cast<const T *>(this)\n            ->template getTrailingObjects<ValueDecl *>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Set the unique declarations that are in the trailing objects of the\n  /// class.\n  void setUniqueDecls(ArrayRef<ValueDecl *> UDs) {\n    assert(UDs.size() == NumUniqueDeclarations &&\n           \"Unexpected amount of unique declarations.\");\n    std::copy(UDs.begin(), UDs.end(), getUniqueDeclsRef().begin());\n  }\n\n  /// Get the number of lists per declaration that are in the trailing\n  /// objects of the class.\n  MutableArrayRef<unsigned> getDeclNumListsRef() {\n    return MutableArrayRef<unsigned>(\n        static_cast<T *>(this)->template getTrailingObjects<unsigned>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Get the number of lists per declaration that are in the trailing\n  /// objects of the class.\n  ArrayRef<unsigned> getDeclNumListsRef() const {\n    return ArrayRef<unsigned>(\n        static_cast<const T *>(this)->template getTrailingObjects<unsigned>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Set the number of lists per declaration that are in the trailing\n  /// objects of the class.\n  void setDeclNumLists(ArrayRef<unsigned> DNLs) {\n    assert(DNLs.size() == NumUniqueDeclarations &&\n           \"Unexpected amount of list numbers.\");\n    std::copy(DNLs.begin(), DNLs.end(), getDeclNumListsRef().begin());\n  }\n\n  /// Get the cumulative component lists sizes that are in the trailing\n  /// objects of the class. They are appended after the number of lists.\n  MutableArrayRef<unsigned> getComponentListSizesRef() {\n    return MutableArrayRef<unsigned>(\n        static_cast<T *>(this)->template getTrailingObjects<unsigned>() +\n            NumUniqueDeclarations,\n        NumComponentLists);\n  }\n\n  /// Get the cumulative component lists sizes that are in the trailing\n  /// objects of the class. They are appended after the number of lists.\n  ArrayRef<unsigned> getComponentListSizesRef() const {\n    return ArrayRef<unsigned>(\n        static_cast<const T *>(this)->template getTrailingObjects<unsigned>() +\n            NumUniqueDeclarations,\n        NumComponentLists);\n  }\n\n  /// Set the cumulative component lists sizes that are in the trailing\n  /// objects of the class.\n  void setComponentListSizes(ArrayRef<unsigned> CLSs) {\n    assert(CLSs.size() == NumComponentLists &&\n           \"Unexpected amount of component lists.\");\n    std::copy(CLSs.begin(), CLSs.end(), getComponentListSizesRef().begin());\n  }\n\n  /// Get the components that are in the trailing objects of the class.\n  MutableArrayRef<MappableComponent> getComponentsRef() {\n    return MutableArrayRef<MappableComponent>(\n        static_cast<T *>(this)\n            ->template getTrailingObjects<MappableComponent>(),\n        NumComponents);\n  }\n\n  /// Get the components that are in the trailing objects of the class.\n  ArrayRef<MappableComponent> getComponentsRef() const {\n    return ArrayRef<MappableComponent>(\n        static_cast<const T *>(this)\n            ->template getTrailingObjects<MappableComponent>(),\n        NumComponents);\n  }\n\n  /// Set the components that are in the trailing objects of the class.\n  /// This requires the list sizes so that it can also fill the original\n  /// expressions, which are the first component of each list.\n  void setComponents(ArrayRef<MappableComponent> Components,\n                     ArrayRef<unsigned> CLSs) {\n    assert(Components.size() == NumComponents &&\n           \"Unexpected amount of component lists.\");\n    assert(CLSs.size() == NumComponentLists &&\n           \"Unexpected amount of list sizes.\");\n    std::copy(Components.begin(), Components.end(), getComponentsRef().begin());\n  }\n\n  /// Fill the clause information from the list of declarations and\n  /// associated component lists.\n  void setClauseInfo(ArrayRef<ValueDecl *> Declarations,\n                     MappableExprComponentListsRef ComponentLists) {\n    // Perform some checks to make sure the data sizes are consistent with the\n    // information available when the clause was created.\n    assert(getUniqueDeclarationsTotalNumber(Declarations) ==\n               NumUniqueDeclarations &&\n           \"Unexpected number of mappable expression info entries!\");\n    assert(getComponentsTotalNumber(ComponentLists) == NumComponents &&\n           \"Unexpected total number of components!\");\n    assert(Declarations.size() == ComponentLists.size() &&\n           \"Declaration and component lists size is not consistent!\");\n    assert(Declarations.size() == NumComponentLists &&\n           \"Unexpected declaration and component lists size!\");\n\n    // Organize the components by declaration and retrieve the original\n    // expression. Original expressions are always the first component of the\n    // mappable component list.\n    llvm::MapVector<ValueDecl *, SmallVector<MappableExprComponentListRef, 8>>\n        ComponentListMap;\n    {\n      auto CI = ComponentLists.begin();\n      for (auto DI = Declarations.begin(), DE = Declarations.end(); DI != DE;\n           ++DI, ++CI) {\n        assert(!CI->empty() && \"Invalid component list!\");\n        ComponentListMap[*DI].push_back(*CI);\n      }\n    }\n\n    // Iterators of the target storage.\n    auto UniqueDeclarations = getUniqueDeclsRef();\n    auto UDI = UniqueDeclarations.begin();\n\n    auto DeclNumLists = getDeclNumListsRef();\n    auto DNLI = DeclNumLists.begin();\n\n    auto ComponentListSizes = getComponentListSizesRef();\n    auto CLSI = ComponentListSizes.begin();\n\n    auto Components = getComponentsRef();\n    auto CI = Components.begin();\n\n    // Variable to compute the accumulation of the number of components.\n    unsigned PrevSize = 0u;\n\n    // Scan all the declarations and associated component lists.\n    for (auto &M : ComponentListMap) {\n      // The declaration.\n      auto *D = M.first;\n      // The component lists.\n      auto CL = M.second;\n\n      // Initialize the entry.\n      *UDI = D;\n      ++UDI;\n\n      *DNLI = CL.size();\n      ++DNLI;\n\n      // Obtain the cumulative sizes and concatenate all the components in the\n      // reserved storage.\n      for (auto C : CL) {\n        // Accumulate with the previous size.\n        PrevSize += C.size();\n\n        // Save the size.\n        *CLSI = PrevSize;\n        ++CLSI;\n\n        // Append components after the current components iterator.\n        CI = std::copy(C.begin(), C.end(), CI);\n      }\n    }\n  }\n\n  /// Set the nested name specifier of associated user-defined mapper.\n  void setMapperQualifierLoc(NestedNameSpecifierLoc NNSL) {\n    MapperQualifierLoc = NNSL;\n  }\n\n  /// Set the name of associated user-defined mapper.\n  void setMapperIdInfo(DeclarationNameInfo MapperId) {\n    MapperIdInfo = MapperId;\n  }\n\n  /// Get the user-defined mapper references that are in the trailing objects of\n  /// the class.\n  MutableArrayRef<Expr *> getUDMapperRefs() {\n    assert(SupportsMapper &&\n           \"Must be a clause that is possible to have user-defined mappers\");\n    return llvm::makeMutableArrayRef<Expr *>(\n        static_cast<T *>(this)->template getTrailingObjects<Expr *>() +\n            OMPVarListClause<T>::varlist_size(),\n        OMPVarListClause<T>::varlist_size());\n  }\n\n  /// Get the user-defined mappers references that are in the trailing objects\n  /// of the class.\n  ArrayRef<Expr *> getUDMapperRefs() const {\n    assert(SupportsMapper &&\n           \"Must be a clause that is possible to have user-defined mappers\");\n    return llvm::makeArrayRef<Expr *>(\n        static_cast<const T *>(this)->template getTrailingObjects<Expr *>() +\n            OMPVarListClause<T>::varlist_size(),\n        OMPVarListClause<T>::varlist_size());\n  }\n\n  /// Set the user-defined mappers that are in the trailing objects of the\n  /// class.\n  void setUDMapperRefs(ArrayRef<Expr *> DMDs) {\n    assert(DMDs.size() == OMPVarListClause<T>::varlist_size() &&\n           \"Unexpected number of user-defined mappers.\");\n    assert(SupportsMapper &&\n           \"Must be a clause that is possible to have user-defined mappers\");\n    std::copy(DMDs.begin(), DMDs.end(), getUDMapperRefs().begin());\n  }\n\npublic:\n  /// Return the number of unique base declarations in this clause.\n  unsigned getUniqueDeclarationsNum() const { return NumUniqueDeclarations; }\n\n  /// Return the number of lists derived from the clause expressions.\n  unsigned getTotalComponentListNum() const { return NumComponentLists; }\n\n  /// Return the total number of components in all lists derived from the\n  /// clause.\n  unsigned getTotalComponentsNum() const { return NumComponents; }\n\n  /// Gets the nested name specifier for associated user-defined mapper.\n  NestedNameSpecifierLoc getMapperQualifierLoc() const {\n    return MapperQualifierLoc;\n  }\n\n  /// Gets the name info for associated user-defined mapper.\n  const DeclarationNameInfo &getMapperIdInfo() const { return MapperIdInfo; }\n\n  /// Iterator that browse the components by lists. It also allows\n  /// browsing components of a single declaration.\n  class const_component_lists_iterator\n      : public llvm::iterator_adaptor_base<\n            const_component_lists_iterator,\n            MappableExprComponentListRef::const_iterator,\n            std::forward_iterator_tag, MappableComponent, ptrdiff_t,\n            MappableComponent, MappableComponent> {\n    // The declaration the iterator currently refers to.\n    ArrayRef<ValueDecl *>::iterator DeclCur;\n\n    // The list number associated with the current declaration.\n    ArrayRef<unsigned>::iterator NumListsCur;\n\n    // Whether this clause is possible to have user-defined mappers associated.\n    const bool SupportsMapper;\n\n    // The user-defined mapper associated with the current declaration.\n    ArrayRef<Expr *>::iterator MapperCur;\n\n    // Remaining lists for the current declaration.\n    unsigned RemainingLists = 0;\n\n    // The cumulative size of the previous list, or zero if there is no previous\n    // list.\n    unsigned PrevListSize = 0;\n\n    // The cumulative sizes of the current list - it will delimit the remaining\n    // range of interest.\n    ArrayRef<unsigned>::const_iterator ListSizeCur;\n    ArrayRef<unsigned>::const_iterator ListSizeEnd;\n\n    // Iterator to the end of the components storage.\n    MappableExprComponentListRef::const_iterator End;\n\n  public:\n    /// Construct an iterator that scans all lists.\n    explicit const_component_lists_iterator(\n        ArrayRef<ValueDecl *> UniqueDecls, ArrayRef<unsigned> DeclsListNum,\n        ArrayRef<unsigned> CumulativeListSizes,\n        MappableExprComponentListRef Components, bool SupportsMapper,\n        ArrayRef<Expr *> Mappers)\n        : const_component_lists_iterator::iterator_adaptor_base(\n              Components.begin()),\n          DeclCur(UniqueDecls.begin()), NumListsCur(DeclsListNum.begin()),\n          SupportsMapper(SupportsMapper),\n          ListSizeCur(CumulativeListSizes.begin()),\n          ListSizeEnd(CumulativeListSizes.end()), End(Components.end()) {\n      assert(UniqueDecls.size() == DeclsListNum.size() &&\n             \"Inconsistent number of declarations and list sizes!\");\n      if (!DeclsListNum.empty())\n        RemainingLists = *NumListsCur;\n      if (SupportsMapper)\n        MapperCur = Mappers.begin();\n    }\n\n    /// Construct an iterator that scan lists for a given declaration \\a\n    /// Declaration.\n    explicit const_component_lists_iterator(\n        const ValueDecl *Declaration, ArrayRef<ValueDecl *> UniqueDecls,\n        ArrayRef<unsigned> DeclsListNum, ArrayRef<unsigned> CumulativeListSizes,\n        MappableExprComponentListRef Components, bool SupportsMapper,\n        ArrayRef<Expr *> Mappers)\n        : const_component_lists_iterator(UniqueDecls, DeclsListNum,\n                                         CumulativeListSizes, Components,\n                                         SupportsMapper, Mappers) {\n      // Look for the desired declaration. While we are looking for it, we\n      // update the state so that we know the component where a given list\n      // starts.\n      for (; DeclCur != UniqueDecls.end(); ++DeclCur, ++NumListsCur) {\n        if (*DeclCur == Declaration)\n          break;\n\n        assert(*NumListsCur > 0 && \"No lists associated with declaration??\");\n\n        // Skip the lists associated with the current declaration, but save the\n        // last list size that was skipped.\n        std::advance(ListSizeCur, *NumListsCur - 1);\n        PrevListSize = *ListSizeCur;\n        ++ListSizeCur;\n\n        if (SupportsMapper)\n          ++MapperCur;\n      }\n\n      // If we didn't find any declaration, advance the iterator to after the\n      // last component and set remaining lists to zero.\n      if (ListSizeCur == CumulativeListSizes.end()) {\n        this->I = End;\n        RemainingLists = 0u;\n        return;\n      }\n\n      // Set the remaining lists with the total number of lists of the current\n      // declaration.\n      RemainingLists = *NumListsCur;\n\n      // Adjust the list size end iterator to the end of the relevant range.\n      ListSizeEnd = ListSizeCur;\n      std::advance(ListSizeEnd, RemainingLists);\n\n      // Given that the list sizes are cumulative, the index of the component\n      // that start the list is the size of the previous list.\n      std::advance(this->I, PrevListSize);\n    }\n\n    // Return the array with the current list. The sizes are cumulative, so the\n    // array size is the difference between the current size and previous one.\n    std::tuple<const ValueDecl *, MappableExprComponentListRef,\n               const ValueDecl *>\n    operator*() const {\n      assert(ListSizeCur != ListSizeEnd && \"Invalid iterator!\");\n      const ValueDecl *Mapper = nullptr;\n      if (SupportsMapper && *MapperCur)\n        Mapper = cast<ValueDecl>(cast<DeclRefExpr>(*MapperCur)->getDecl());\n      return std::make_tuple(\n          *DeclCur,\n          MappableExprComponentListRef(&*this->I, *ListSizeCur - PrevListSize),\n          Mapper);\n    }\n    std::tuple<const ValueDecl *, MappableExprComponentListRef,\n               const ValueDecl *>\n    operator->() const {\n      return **this;\n    }\n\n    // Skip the components of the current list.\n    const_component_lists_iterator &operator++() {\n      assert(ListSizeCur != ListSizeEnd && RemainingLists &&\n             \"Invalid iterator!\");\n\n      // If we don't have more lists just skip all the components. Otherwise,\n      // advance the iterator by the number of components in the current list.\n      if (std::next(ListSizeCur) == ListSizeEnd) {\n        this->I = End;\n        RemainingLists = 0;\n      } else {\n        std::advance(this->I, *ListSizeCur - PrevListSize);\n        PrevListSize = *ListSizeCur;\n\n        // We are done with a declaration, move to the next one.\n        if (!(--RemainingLists)) {\n          ++DeclCur;\n          ++NumListsCur;\n          RemainingLists = *NumListsCur;\n          assert(RemainingLists && \"No lists in the following declaration??\");\n        }\n      }\n\n      ++ListSizeCur;\n      if (SupportsMapper)\n        ++MapperCur;\n      return *this;\n    }\n  };\n\n  using const_component_lists_range =\n      llvm::iterator_range<const_component_lists_iterator>;\n\n  /// Iterators for all component lists.\n  const_component_lists_iterator component_lists_begin() const {\n    return const_component_lists_iterator(\n        getUniqueDeclsRef(), getDeclNumListsRef(), getComponentListSizesRef(),\n        getComponentsRef(), SupportsMapper,\n        SupportsMapper ? getUDMapperRefs() : llvm::None);\n  }\n  const_component_lists_iterator component_lists_end() const {\n    return const_component_lists_iterator(\n        ArrayRef<ValueDecl *>(), ArrayRef<unsigned>(), ArrayRef<unsigned>(),\n        MappableExprComponentListRef(getComponentsRef().end(),\n                                     getComponentsRef().end()),\n        SupportsMapper, llvm::None);\n  }\n  const_component_lists_range component_lists() const {\n    return {component_lists_begin(), component_lists_end()};\n  }\n\n  /// Iterators for component lists associated with the provided\n  /// declaration.\n  const_component_lists_iterator\n  decl_component_lists_begin(const ValueDecl *VD) const {\n    return const_component_lists_iterator(\n        VD, getUniqueDeclsRef(), getDeclNumListsRef(),\n        getComponentListSizesRef(), getComponentsRef(), SupportsMapper,\n        SupportsMapper ? getUDMapperRefs() : llvm::None);\n  }\n  const_component_lists_iterator decl_component_lists_end() const {\n    return component_lists_end();\n  }\n  const_component_lists_range decl_component_lists(const ValueDecl *VD) const {\n    return {decl_component_lists_begin(VD), decl_component_lists_end()};\n  }\n\n  /// Iterators to access all the declarations, number of lists, list sizes, and\n  /// components.\n  using const_all_decls_iterator = ArrayRef<ValueDecl *>::iterator;\n  using const_all_decls_range = llvm::iterator_range<const_all_decls_iterator>;\n\n  const_all_decls_range all_decls() const {\n    auto A = getUniqueDeclsRef();\n    return const_all_decls_range(A.begin(), A.end());\n  }\n\n  using const_all_num_lists_iterator = ArrayRef<unsigned>::iterator;\n  using const_all_num_lists_range =\n      llvm::iterator_range<const_all_num_lists_iterator>;\n\n  const_all_num_lists_range all_num_lists() const {\n    auto A = getDeclNumListsRef();\n    return const_all_num_lists_range(A.begin(), A.end());\n  }\n\n  using const_all_lists_sizes_iterator = ArrayRef<unsigned>::iterator;\n  using const_all_lists_sizes_range =\n      llvm::iterator_range<const_all_lists_sizes_iterator>;\n\n  const_all_lists_sizes_range all_lists_sizes() const {\n    auto A = getComponentListSizesRef();\n    return const_all_lists_sizes_range(A.begin(), A.end());\n  }\n\n  using const_all_components_iterator = ArrayRef<MappableComponent>::iterator;\n  using const_all_components_range =\n      llvm::iterator_range<const_all_components_iterator>;\n\n  const_all_components_range all_components() const {\n    auto A = getComponentsRef();\n    return const_all_components_range(A.begin(), A.end());\n  }\n\n  using mapperlist_iterator = MutableArrayRef<Expr *>::iterator;\n  using mapperlist_const_iterator = ArrayRef<const Expr *>::iterator;\n  using mapperlist_range = llvm::iterator_range<mapperlist_iterator>;\n  using mapperlist_const_range =\n      llvm::iterator_range<mapperlist_const_iterator>;\n\n  mapperlist_iterator mapperlist_begin() { return getUDMapperRefs().begin(); }\n  mapperlist_iterator mapperlist_end() { return getUDMapperRefs().end(); }\n  mapperlist_const_iterator mapperlist_begin() const {\n    return getUDMapperRefs().begin();\n  }\n  mapperlist_const_iterator mapperlist_end() const {\n    return getUDMapperRefs().end();\n  }\n  mapperlist_range mapperlists() {\n    return mapperlist_range(mapperlist_begin(), mapperlist_end());\n  }\n  mapperlist_const_range mapperlists() const {\n    return mapperlist_const_range(mapperlist_begin(), mapperlist_end());\n  }\n};\n\n/// This represents clause 'map' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target map(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'map'\n/// with the variables 'a' and 'b'.\nclass OMPMapClause final : public OMPMappableExprListClause<OMPMapClause>,\n                           private llvm::TrailingObjects<\n                               OMPMapClause, Expr *, ValueDecl *, unsigned,\n                               OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    // There are varlist_size() of expressions, and varlist_size() of\n    // user-defined mappers.\n    return 2 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\nprivate:\n  /// Map-type-modifiers for the 'map' clause.\n  OpenMPMapModifierKind MapTypeModifiers[NumberOfOMPMapClauseModifiers] = {\n      OMPC_MAP_MODIFIER_unknown, OMPC_MAP_MODIFIER_unknown,\n      OMPC_MAP_MODIFIER_unknown, OMPC_MAP_MODIFIER_unknown};\n\n  /// Location of map-type-modifiers for the 'map' clause.\n  SourceLocation MapTypeModifiersLoc[NumberOfOMPMapClauseModifiers];\n\n  /// Map type for the 'map' clause.\n  OpenMPMapClauseKind MapType = OMPC_MAP_unknown;\n\n  /// Is this an implicit map type or not.\n  bool MapTypeIsImplicit = false;\n\n  /// Location of the map type.\n  SourceLocation MapLoc;\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Build a clause for \\a NumVars listed expressions, \\a\n  /// NumUniqueDeclarations declarations, \\a NumComponentLists total component\n  /// lists, and \\a NumComponents total expression components.\n  ///\n  /// \\param MapModifiers Map-type-modifiers.\n  /// \\param MapModifiersLoc Locations of map-type-modifiers.\n  /// \\param MapperQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfo The identifier of associated user-defined mapper.\n  /// \\param MapType Map type.\n  /// \\param MapTypeIsImplicit Map type is inferred implicitly.\n  /// \\param MapLoc Location of the map type.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPMapClause(ArrayRef<OpenMPMapModifierKind> MapModifiers,\n                        ArrayRef<SourceLocation> MapModifiersLoc,\n                        NestedNameSpecifierLoc MapperQualifierLoc,\n                        DeclarationNameInfo MapperIdInfo,\n                        OpenMPMapClauseKind MapType, bool MapTypeIsImplicit,\n                        SourceLocation MapLoc, const OMPVarListLocTy &Locs,\n                        const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_map, Locs, Sizes,\n                                  /*SupportsMapper=*/true, &MapperQualifierLoc,\n                                  &MapperIdInfo),\n        MapType(MapType), MapTypeIsImplicit(MapTypeIsImplicit), MapLoc(MapLoc) {\n    assert(llvm::array_lengthof(MapTypeModifiers) == MapModifiers.size() &&\n           \"Unexpected number of map type modifiers.\");\n    llvm::copy(MapModifiers, std::begin(MapTypeModifiers));\n\n    assert(llvm::array_lengthof(MapTypeModifiersLoc) ==\n               MapModifiersLoc.size() &&\n           \"Unexpected number of map type modifier locations.\");\n    llvm::copy(MapModifiersLoc, std::begin(MapTypeModifiersLoc));\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPMapClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_map, OMPVarListLocTy(), Sizes,\n                                  /*SupportsMapper=*/true) {}\n\n  /// Set map-type-modifier for the clause.\n  ///\n  /// \\param I index for map-type-modifier.\n  /// \\param T map-type-modifier for the clause.\n  void setMapTypeModifier(unsigned I, OpenMPMapModifierKind T) {\n    assert(I < NumberOfOMPMapClauseModifiers &&\n           \"Unexpected index to store map type modifier, exceeds array size.\");\n    MapTypeModifiers[I] = T;\n  }\n\n  /// Set location for the map-type-modifier.\n  ///\n  /// \\param I index for map-type-modifier location.\n  /// \\param TLoc map-type-modifier location.\n  void setMapTypeModifierLoc(unsigned I, SourceLocation TLoc) {\n    assert(I < NumberOfOMPMapClauseModifiers &&\n           \"Index to store map type modifier location exceeds array size.\");\n    MapTypeModifiersLoc[I] = TLoc;\n  }\n\n  /// Set type for the clause.\n  ///\n  /// \\param T Type for the clause.\n  void setMapType(OpenMPMapClauseKind T) { MapType = T; }\n\n  /// Set type location.\n  ///\n  /// \\param TLoc Type location.\n  void setMapLoc(SourceLocation TLoc) { MapLoc = TLoc; }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  /// \\param UDMapperRefs References to user-defined mappers associated with\n  /// expressions used in the clause.\n  /// \\param MapModifiers Map-type-modifiers.\n  /// \\param MapModifiersLoc Location of map-type-modifiers.\n  /// \\param UDMQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperId The identifier of associated user-defined mapper.\n  /// \\param Type Map type.\n  /// \\param TypeIsImplicit Map type is inferred implicitly.\n  /// \\param TypeLoc Location of the map type.\n  static OMPMapClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists,\n         ArrayRef<Expr *> UDMapperRefs,\n         ArrayRef<OpenMPMapModifierKind> MapModifiers,\n         ArrayRef<SourceLocation> MapModifiersLoc,\n         NestedNameSpecifierLoc UDMQualifierLoc, DeclarationNameInfo MapperId,\n         OpenMPMapClauseKind Type, bool TypeIsImplicit, SourceLocation TypeLoc);\n\n  /// Creates an empty clause with the place for \\a NumVars original\n  /// expressions, \\a NumUniqueDeclarations declarations, \\NumComponentLists\n  /// lists, and \\a NumComponents expression components.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPMapClause *CreateEmpty(const ASTContext &C,\n                                   const OMPMappableExprListSizeTy &Sizes);\n\n  /// Fetches mapping kind for the clause.\n  OpenMPMapClauseKind getMapType() const LLVM_READONLY { return MapType; }\n\n  /// Is this an implicit map type?\n  /// We have to capture 'IsMapTypeImplicit' from the parser for more\n  /// informative error messages.  It helps distinguish map(r) from\n  /// map(tofrom: r), which is important to print more helpful error\n  /// messages for some target directives.\n  bool isImplicitMapType() const LLVM_READONLY { return MapTypeIsImplicit; }\n\n  /// Fetches the map-type-modifier at 'Cnt' index of array of modifiers.\n  ///\n  /// \\param Cnt index for map-type-modifier.\n  OpenMPMapModifierKind getMapTypeModifier(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMapClauseModifiers &&\n           \"Requested modifier exceeds the total number of modifiers.\");\n    return MapTypeModifiers[Cnt];\n  }\n\n  /// Fetches the map-type-modifier location at 'Cnt' index of array of\n  /// modifiers' locations.\n  ///\n  /// \\param Cnt index for map-type-modifier location.\n  SourceLocation getMapTypeModifierLoc(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMapClauseModifiers &&\n           \"Requested modifier location exceeds total number of modifiers.\");\n    return MapTypeModifiersLoc[Cnt];\n  }\n\n  /// Fetches ArrayRef of map-type-modifiers.\n  ArrayRef<OpenMPMapModifierKind> getMapTypeModifiers() const LLVM_READONLY {\n    return llvm::makeArrayRef(MapTypeModifiers);\n  }\n\n  /// Fetches ArrayRef of location of map-type-modifiers.\n  ArrayRef<SourceLocation> getMapTypeModifiersLoc() const LLVM_READONLY {\n    return llvm::makeArrayRef(MapTypeModifiersLoc);\n  }\n\n  /// Fetches location of clause mapping kind.\n  SourceLocation getMapLoc() const LLVM_READONLY { return MapLoc; }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  child_range children() {\n    return child_range(\n        reinterpret_cast<Stmt **>(varlist_begin()),\n        reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPMapClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    if (MapType == OMPC_MAP_to || MapType == OMPC_MAP_tofrom)\n      return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                         reinterpret_cast<Stmt **>(varlist_end()));\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPMapClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_map;\n  }\n};\n\n/// This represents 'num_teams' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp teams num_teams(n)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'num_teams'\n/// with single expression 'n'.\nclass OMPNumTeamsClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// NumTeams number.\n  Stmt *NumTeams = nullptr;\n\n  /// Set the NumTeams number.\n  ///\n  /// \\param E NumTeams number.\n  void setNumTeams(Expr *E) { NumTeams = E; }\n\npublic:\n  /// Build 'num_teams' clause.\n  ///\n  /// \\param E Expression associated with this clause.\n  /// \\param HelperE Helper Expression associated with this clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNumTeamsClause(Expr *E, Stmt *HelperE, OpenMPDirectiveKind CaptureRegion,\n                    SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_num_teams, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), NumTeams(E) {\n    setPreInitStmt(HelperE, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPNumTeamsClause()\n      : OMPClause(llvm::omp::OMPC_num_teams, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return NumTeams number.\n  Expr *getNumTeams() { return cast<Expr>(NumTeams); }\n\n  /// Return NumTeams number.\n  Expr *getNumTeams() const { return cast<Expr>(NumTeams); }\n\n  child_range children() { return child_range(&NumTeams, &NumTeams + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumTeams, &NumTeams + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_num_teams;\n  }\n};\n\n/// This represents 'thread_limit' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp teams thread_limit(n)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'thread_limit'\n/// with single expression 'n'.\nclass OMPThreadLimitClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// ThreadLimit number.\n  Stmt *ThreadLimit = nullptr;\n\n  /// Set the ThreadLimit number.\n  ///\n  /// \\param E ThreadLimit number.\n  void setThreadLimit(Expr *E) { ThreadLimit = E; }\n\npublic:\n  /// Build 'thread_limit' clause.\n  ///\n  /// \\param E Expression associated with this clause.\n  /// \\param HelperE Helper Expression associated with this clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPThreadLimitClause(Expr *E, Stmt *HelperE,\n                       OpenMPDirectiveKind CaptureRegion,\n                       SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_thread_limit, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), ThreadLimit(E) {\n    setPreInitStmt(HelperE, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPThreadLimitClause()\n      : OMPClause(llvm::omp::OMPC_thread_limit, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return ThreadLimit number.\n  Expr *getThreadLimit() { return cast<Expr>(ThreadLimit); }\n\n  /// Return ThreadLimit number.\n  Expr *getThreadLimit() const { return cast<Expr>(ThreadLimit); }\n\n  child_range children() { return child_range(&ThreadLimit, &ThreadLimit + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&ThreadLimit, &ThreadLimit + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_thread_limit;\n  }\n};\n\n/// This represents 'priority' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp task priority(n)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'priority' with\n/// single expression 'n'.\nclass OMPPriorityClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Priority number.\n  Stmt *Priority = nullptr;\n\n  /// Set the Priority number.\n  ///\n  /// \\param E Priority number.\n  void setPriority(Expr *E) { Priority = E; }\n\npublic:\n  /// Build 'priority' clause.\n  ///\n  /// \\param Priority Expression associated with this clause.\n  /// \\param HelperPriority Helper priority for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPPriorityClause(Expr *Priority, Stmt *HelperPriority,\n                    OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                    SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_priority, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Priority(Priority) {\n    setPreInitStmt(HelperPriority, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPPriorityClause()\n      : OMPClause(llvm::omp::OMPC_priority, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return Priority number.\n  Expr *getPriority() { return cast<Expr>(Priority); }\n\n  /// Return Priority number.\n  Expr *getPriority() const { return cast<Expr>(Priority); }\n\n  child_range children() { return child_range(&Priority, &Priority + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Priority, &Priority + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPPriorityClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_priority;\n  }\n};\n\n/// This represents 'grainsize' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp taskloop grainsize(4)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has clause 'grainsize'\n/// with single expression '4'.\nclass OMPGrainsizeClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *Grainsize = nullptr;\n\n  /// Set safelen.\n  void setGrainsize(Expr *Size) { Grainsize = Size; }\n\npublic:\n  /// Build 'grainsize' clause.\n  ///\n  /// \\param Size Expression associated with this clause.\n  /// \\param HelperSize Helper grainsize for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPGrainsizeClause(Expr *Size, Stmt *HelperSize,\n                     OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                     SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_grainsize, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Grainsize(Size) {\n    setPreInitStmt(HelperSize, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  explicit OMPGrainsizeClause()\n      : OMPClause(llvm::omp::OMPC_grainsize, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getGrainsize() const { return cast_or_null<Expr>(Grainsize); }\n\n  child_range children() { return child_range(&Grainsize, &Grainsize + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Grainsize, &Grainsize + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPGrainsizeClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_grainsize;\n  }\n};\n\n/// This represents 'nogroup' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp taskloop nogroup\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has 'nogroup' clause.\nclass OMPNogroupClause : public OMPClause {\npublic:\n  /// Build 'nogroup' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNogroupClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_nogroup, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPNogroupClause()\n      : OMPClause(llvm::omp::OMPC_nogroup, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_nogroup;\n  }\n};\n\n/// This represents 'num_tasks' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp taskloop num_tasks(4)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has clause 'num_tasks'\n/// with single expression '4'.\nclass OMPNumTasksClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *NumTasks = nullptr;\n\n  /// Set safelen.\n  void setNumTasks(Expr *Size) { NumTasks = Size; }\n\npublic:\n  /// Build 'num_tasks' clause.\n  ///\n  /// \\param Size Expression associated with this clause.\n  /// \\param HelperSize Helper grainsize for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNumTasksClause(Expr *Size, Stmt *HelperSize,\n                    OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                    SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_num_tasks, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), NumTasks(Size) {\n    setPreInitStmt(HelperSize, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  explicit OMPNumTasksClause()\n      : OMPClause(llvm::omp::OMPC_num_tasks, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getNumTasks() const { return cast_or_null<Expr>(NumTasks); }\n\n  child_range children() { return child_range(&NumTasks, &NumTasks + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumTasks, &NumTasks + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPNumTasksClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_num_tasks;\n  }\n};\n\n/// This represents 'hint' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp critical (name) hint(6)\n/// \\endcode\n/// In this example directive '#pragma omp critical' has name 'name' and clause\n/// 'hint' with argument '6'.\nclass OMPHintClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Hint expression of the 'hint' clause.\n  Stmt *Hint = nullptr;\n\n  /// Set hint expression.\n  void setHint(Expr *H) { Hint = H; }\n\npublic:\n  /// Build 'hint' clause with expression \\a Hint.\n  ///\n  /// \\param Hint Hint expression.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPHintClause(Expr *Hint, SourceLocation StartLoc, SourceLocation LParenLoc,\n                SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_hint, StartLoc, EndLoc), LParenLoc(LParenLoc),\n        Hint(Hint) {}\n\n  /// Build an empty clause.\n  OMPHintClause()\n      : OMPClause(llvm::omp::OMPC_hint, SourceLocation(), SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns number of threads.\n  Expr *getHint() const { return cast_or_null<Expr>(Hint); }\n\n  child_range children() { return child_range(&Hint, &Hint + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Hint, &Hint + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_hint;\n  }\n};\n\n/// This represents 'dist_schedule' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp distribute dist_schedule(static, 3)\n/// \\endcode\n/// In this example directive '#pragma omp distribute' has 'dist_schedule'\n/// clause with arguments 'static' and '3'.\nclass OMPDistScheduleClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'schedule' clause.\n  OpenMPDistScheduleClauseKind Kind = OMPC_DIST_SCHEDULE_unknown;\n\n  /// Start location of the schedule kind in source code.\n  SourceLocation KindLoc;\n\n  /// Location of ',' (if any).\n  SourceLocation CommaLoc;\n\n  /// Chunk size.\n  Expr *ChunkSize = nullptr;\n\n  /// Set schedule kind.\n  ///\n  /// \\param K Schedule kind.\n  void setDistScheduleKind(OpenMPDistScheduleClauseKind K) { Kind = K; }\n\n  /// Sets the location of '('.\n  ///\n  /// \\param Loc Location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Set schedule kind start location.\n  ///\n  /// \\param KLoc Schedule kind location.\n  void setDistScheduleKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }\n\n  /// Set location of ','.\n  ///\n  /// \\param Loc Location of ','.\n  void setCommaLoc(SourceLocation Loc) { CommaLoc = Loc; }\n\n  /// Set chunk size.\n  ///\n  /// \\param E Chunk size.\n  void setChunkSize(Expr *E) { ChunkSize = E; }\n\npublic:\n  /// Build 'dist_schedule' clause with schedule kind \\a Kind and chunk\n  /// size expression \\a ChunkSize.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param KLoc Starting location of the argument.\n  /// \\param CommaLoc Location of ','.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Kind DistSchedule kind.\n  /// \\param ChunkSize Chunk size.\n  /// \\param HelperChunkSize Helper chunk size for combined directives.\n  OMPDistScheduleClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                        SourceLocation KLoc, SourceLocation CommaLoc,\n                        SourceLocation EndLoc,\n                        OpenMPDistScheduleClauseKind Kind, Expr *ChunkSize,\n                        Stmt *HelperChunkSize)\n      : OMPClause(llvm::omp::OMPC_dist_schedule, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Kind(Kind),\n        KindLoc(KLoc), CommaLoc(CommaLoc), ChunkSize(ChunkSize) {\n    setPreInitStmt(HelperChunkSize);\n  }\n\n  /// Build an empty clause.\n  explicit OMPDistScheduleClause()\n      : OMPClause(llvm::omp::OMPC_dist_schedule, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Get kind of the clause.\n  OpenMPDistScheduleClauseKind getDistScheduleKind() const { return Kind; }\n\n  /// Get location of '('.\n  SourceLocation getLParenLoc() { return LParenLoc; }\n\n  /// Get kind location.\n  SourceLocation getDistScheduleKindLoc() { return KindLoc; }\n\n  /// Get location of ','.\n  SourceLocation getCommaLoc() { return CommaLoc; }\n\n  /// Get chunk size.\n  Expr *getChunkSize() { return ChunkSize; }\n\n  /// Get chunk size.\n  const Expr *getChunkSize() const { return ChunkSize; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(&ChunkSize),\n                       reinterpret_cast<Stmt **>(&ChunkSize) + 1);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPDistScheduleClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_dist_schedule;\n  }\n};\n\n/// This represents 'defaultmap' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp target defaultmap(tofrom: scalar)\n/// \\endcode\n/// In this example directive '#pragma omp target' has 'defaultmap' clause of kind\n/// 'scalar' with modifier 'tofrom'.\nclass OMPDefaultmapClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Modifiers for 'defaultmap' clause.\n  OpenMPDefaultmapClauseModifier Modifier = OMPC_DEFAULTMAP_MODIFIER_unknown;\n\n  /// Locations of modifiers.\n  SourceLocation ModifierLoc;\n\n  /// A kind of the 'defaultmap' clause.\n  OpenMPDefaultmapClauseKind Kind = OMPC_DEFAULTMAP_unknown;\n\n  /// Start location of the defaultmap kind in source code.\n  SourceLocation KindLoc;\n\n  /// Set defaultmap kind.\n  ///\n  /// \\param K Defaultmap kind.\n  void setDefaultmapKind(OpenMPDefaultmapClauseKind K) { Kind = K; }\n\n  /// Set the defaultmap modifier.\n  ///\n  /// \\param M Defaultmap modifier.\n  void setDefaultmapModifier(OpenMPDefaultmapClauseModifier M) {\n    Modifier = M;\n  }\n\n  /// Set location of the defaultmap modifier.\n  void setDefaultmapModifierLoc(SourceLocation Loc) {\n    ModifierLoc = Loc;\n  }\n\n  /// Sets the location of '('.\n  ///\n  /// \\param Loc Location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Set defaultmap kind start location.\n  ///\n  /// \\param KLoc Defaultmap kind location.\n  void setDefaultmapKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }\n\npublic:\n  /// Build 'defaultmap' clause with defaultmap kind \\a Kind\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param KLoc Starting location of the argument.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Kind Defaultmap kind.\n  /// \\param M The modifier applied to 'defaultmap' clause.\n  /// \\param MLoc Location of the modifier\n  OMPDefaultmapClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                      SourceLocation MLoc, SourceLocation KLoc,\n                      SourceLocation EndLoc, OpenMPDefaultmapClauseKind Kind,\n                      OpenMPDefaultmapClauseModifier M)\n      : OMPClause(llvm::omp::OMPC_defaultmap, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Modifier(M), ModifierLoc(MLoc), Kind(Kind),\n        KindLoc(KLoc) {}\n\n  /// Build an empty clause.\n  explicit OMPDefaultmapClause()\n      : OMPClause(llvm::omp::OMPC_defaultmap, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Get kind of the clause.\n  OpenMPDefaultmapClauseKind getDefaultmapKind() const { return Kind; }\n\n  /// Get the modifier of the clause.\n  OpenMPDefaultmapClauseModifier getDefaultmapModifier() const {\n    return Modifier;\n  }\n\n  /// Get location of '('.\n  SourceLocation getLParenLoc() { return LParenLoc; }\n\n  /// Get kind location.\n  SourceLocation getDefaultmapKindLoc() { return KindLoc; }\n\n  /// Get the modifier location.\n  SourceLocation getDefaultmapModifierLoc() const {\n    return ModifierLoc;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_defaultmap;\n  }\n};\n\n/// This represents clause 'to' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target update to(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target update' has clause 'to'\n/// with the variables 'a' and 'b'.\nclass OMPToClause final : public OMPMappableExprListClause<OMPToClause>,\n                          private llvm::TrailingObjects<\n                              OMPToClause, Expr *, ValueDecl *, unsigned,\n                              OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Motion-modifiers for the 'to' clause.\n  OpenMPMotionModifierKind MotionModifiers[NumberOfOMPMotionModifiers] = {\n      OMPC_MOTION_MODIFIER_unknown, OMPC_MOTION_MODIFIER_unknown};\n\n  /// Location of motion-modifiers for the 'to' clause.\n  SourceLocation MotionModifiersLoc[NumberOfOMPMotionModifiers];\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param TheMotionModifiers Motion-modifiers.\n  /// \\param TheMotionModifiersLoc Locations of motion-modifiers.\n  /// \\param MapperQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfo The identifier of associated user-defined mapper.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPToClause(ArrayRef<OpenMPMotionModifierKind> TheMotionModifiers,\n                       ArrayRef<SourceLocation> TheMotionModifiersLoc,\n                       NestedNameSpecifierLoc MapperQualifierLoc,\n                       DeclarationNameInfo MapperIdInfo,\n                       const OMPVarListLocTy &Locs,\n                       const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_to, Locs, Sizes,\n                                  /*SupportsMapper=*/true, &MapperQualifierLoc,\n                                  &MapperIdInfo) {\n    assert(llvm::array_lengthof(MotionModifiers) == TheMotionModifiers.size() &&\n           \"Unexpected number of motion modifiers.\");\n    llvm::copy(TheMotionModifiers, std::begin(MotionModifiers));\n\n    assert(llvm::array_lengthof(MotionModifiersLoc) ==\n               TheMotionModifiersLoc.size() &&\n           \"Unexpected number of motion modifier locations.\");\n    llvm::copy(TheMotionModifiersLoc, std::begin(MotionModifiersLoc));\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPToClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_to, OMPVarListLocTy(), Sizes,\n                                  /*SupportsMapper=*/true) {}\n\n  /// Set motion-modifier for the clause.\n  ///\n  /// \\param I index for motion-modifier.\n  /// \\param T motion-modifier for the clause.\n  void setMotionModifier(unsigned I, OpenMPMotionModifierKind T) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Unexpected index to store motion modifier, exceeds array size.\");\n    MotionModifiers[I] = T;\n  }\n\n  /// Set location for the motion-modifier.\n  ///\n  /// \\param I index for motion-modifier location.\n  /// \\param TLoc motion-modifier location.\n  void setMotionModifierLoc(unsigned I, SourceLocation TLoc) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Index to store motion modifier location exceeds array size.\");\n    MotionModifiersLoc[I] = TLoc;\n  }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    // There are varlist_size() of expressions, and varlist_size() of\n    // user-defined mappers.\n    return 2 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  /// \\param MotionModifiers Motion-modifiers.\n  /// \\param MotionModifiersLoc Location of motion-modifiers.\n  /// \\param UDMapperRefs References to user-defined mappers associated with\n  /// expressions used in the clause.\n  /// \\param UDMQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperId The identifier of associated user-defined mapper.\n  static OMPToClause *Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n                             ArrayRef<Expr *> Vars,\n                             ArrayRef<ValueDecl *> Declarations,\n                             MappableExprComponentListsRef ComponentLists,\n                             ArrayRef<Expr *> UDMapperRefs,\n                             ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                             ArrayRef<SourceLocation> MotionModifiersLoc,\n                             NestedNameSpecifierLoc UDMQualifierLoc,\n                             DeclarationNameInfo MapperId);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPToClause *CreateEmpty(const ASTContext &C,\n                                  const OMPMappableExprListSizeTy &Sizes);\n\n  /// Fetches the motion-modifier at 'Cnt' index of array of modifiers.\n  ///\n  /// \\param Cnt index for motion-modifier.\n  OpenMPMotionModifierKind getMotionModifier(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier exceeds the total number of modifiers.\");\n    return MotionModifiers[Cnt];\n  }\n\n  /// Fetches the motion-modifier location at 'Cnt' index of array of modifiers'\n  /// locations.\n  ///\n  /// \\param Cnt index for motion-modifier location.\n  SourceLocation getMotionModifierLoc(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier location exceeds total number of modifiers.\");\n    return MotionModifiersLoc[Cnt];\n  }\n\n  /// Fetches ArrayRef of motion-modifiers.\n  ArrayRef<OpenMPMotionModifierKind> getMotionModifiers() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiers);\n  }\n\n  /// Fetches ArrayRef of location of motion-modifiers.\n  ArrayRef<SourceLocation> getMotionModifiersLoc() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiersLoc);\n  }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPToClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_to;\n  }\n};\n\n/// This represents clause 'from' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target update from(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target update' has clause 'from'\n/// with the variables 'a' and 'b'.\nclass OMPFromClause final\n    : public OMPMappableExprListClause<OMPFromClause>,\n      private llvm::TrailingObjects<\n          OMPFromClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Motion-modifiers for the 'from' clause.\n  OpenMPMotionModifierKind MotionModifiers[NumberOfOMPMotionModifiers] = {\n      OMPC_MOTION_MODIFIER_unknown, OMPC_MOTION_MODIFIER_unknown};\n\n  /// Location of motion-modifiers for the 'from' clause.\n  SourceLocation MotionModifiersLoc[NumberOfOMPMotionModifiers];\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param TheMotionModifiers Motion-modifiers.\n  /// \\param TheMotionModifiersLoc Locations of motion-modifiers.\n  /// \\param MapperQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfo The identifier of associated user-defined mapper.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPFromClause(ArrayRef<OpenMPMotionModifierKind> TheMotionModifiers,\n                         ArrayRef<SourceLocation> TheMotionModifiersLoc,\n                         NestedNameSpecifierLoc MapperQualifierLoc,\n                         DeclarationNameInfo MapperIdInfo,\n                         const OMPVarListLocTy &Locs,\n                         const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_from, Locs, Sizes,\n                                  /*SupportsMapper=*/true, &MapperQualifierLoc,\n                                  &MapperIdInfo) {\n    assert(llvm::array_lengthof(MotionModifiers) == TheMotionModifiers.size() &&\n           \"Unexpected number of motion modifiers.\");\n    llvm::copy(TheMotionModifiers, std::begin(MotionModifiers));\n\n    assert(llvm::array_lengthof(MotionModifiersLoc) ==\n               TheMotionModifiersLoc.size() &&\n           \"Unexpected number of motion modifier locations.\");\n    llvm::copy(TheMotionModifiersLoc, std::begin(MotionModifiersLoc));\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPFromClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_from, OMPVarListLocTy(),\n                                  Sizes, /*SupportsMapper=*/true) {}\n\n  /// Set motion-modifier for the clause.\n  ///\n  /// \\param I index for motion-modifier.\n  /// \\param T motion-modifier for the clause.\n  void setMotionModifier(unsigned I, OpenMPMotionModifierKind T) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Unexpected index to store motion modifier, exceeds array size.\");\n    MotionModifiers[I] = T;\n  }\n\n  /// Set location for the motion-modifier.\n  ///\n  /// \\param I index for motion-modifier location.\n  /// \\param TLoc motion-modifier location.\n  void setMotionModifierLoc(unsigned I, SourceLocation TLoc) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Index to store motion modifier location exceeds array size.\");\n    MotionModifiersLoc[I] = TLoc;\n  }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    // There are varlist_size() of expressions, and varlist_size() of\n    // user-defined mappers.\n    return 2 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  /// \\param MotionModifiers Motion-modifiers.\n  /// \\param MotionModifiersLoc Location of motion-modifiers.\n  /// \\param UDMapperRefs References to user-defined mappers associated with\n  /// expressions used in the clause.\n  /// \\param UDMQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperId The identifier of associated user-defined mapper.\n  static OMPFromClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists,\n         ArrayRef<Expr *> UDMapperRefs,\n         ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n         ArrayRef<SourceLocation> MotionModifiersLoc,\n         NestedNameSpecifierLoc UDMQualifierLoc, DeclarationNameInfo MapperId);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPFromClause *CreateEmpty(const ASTContext &C,\n                                    const OMPMappableExprListSizeTy &Sizes);\n\n  /// Fetches the motion-modifier at 'Cnt' index of array of modifiers.\n  ///\n  /// \\param Cnt index for motion-modifier.\n  OpenMPMotionModifierKind getMotionModifier(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier exceeds the total number of modifiers.\");\n    return MotionModifiers[Cnt];\n  }\n\n  /// Fetches the motion-modifier location at 'Cnt' index of array of modifiers'\n  /// locations.\n  ///\n  /// \\param Cnt index for motion-modifier location.\n  SourceLocation getMotionModifierLoc(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier location exceeds total number of modifiers.\");\n    return MotionModifiersLoc[Cnt];\n  }\n\n  /// Fetches ArrayRef of motion-modifiers.\n  ArrayRef<OpenMPMotionModifierKind> getMotionModifiers() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiers);\n  }\n\n  /// Fetches ArrayRef of location of motion-modifiers.\n  ArrayRef<SourceLocation> getMotionModifiersLoc() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiersLoc);\n  }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPFromClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_from;\n  }\n};\n\n/// This represents clause 'use_device_ptr' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target data use_device_ptr(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target data' has clause\n/// 'use_device_ptr' with the variables 'a' and 'b'.\nclass OMPUseDevicePtrClause final\n    : public OMPMappableExprListClause<OMPUseDevicePtrClause>,\n      private llvm::TrailingObjects<\n          OMPUseDevicePtrClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDevicePtrClause(const OMPVarListLocTy &Locs,\n                                 const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_ptr, Locs, Sizes) {\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDevicePtrClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_ptr,\n                                  OMPVarListLocTy(), Sizes) {}\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return 3 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\n  /// Sets the list of references to private copies with initializers for new\n  /// private variables.\n  /// \\param VL List of references.\n  void setPrivateCopies(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to private copies with initializers for new\n  /// private variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Sets the list of references to initializer variables for new private\n  /// variables.\n  /// \\param VL List of references.\n  void setInits(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to initializer variables for new private\n  /// variables.\n  MutableArrayRef<Expr *> getInits() {\n    return MutableArrayRef<Expr *>(getPrivateCopies().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInits() const {\n    return llvm::makeArrayRef(getPrivateCopies().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param PrivateVars Expressions referring to private copies.\n  /// \\param Inits Expressions referring to private copy initializers.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  static OMPUseDevicePtrClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<Expr *> PrivateVars,\n         ArrayRef<Expr *> Inits, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPUseDevicePtrClause *\n  CreateEmpty(const ASTContext &C, const OMPMappableExprListSizeTy &Sizes);\n\n  using private_copies_iterator = MutableArrayRef<Expr *>::iterator;\n  using private_copies_const_iterator = ArrayRef<const Expr *>::iterator;\n  using private_copies_range = llvm::iterator_range<private_copies_iterator>;\n  using private_copies_const_range =\n      llvm::iterator_range<private_copies_const_iterator>;\n\n  private_copies_range private_copies() {\n    return private_copies_range(getPrivateCopies().begin(),\n                                getPrivateCopies().end());\n  }\n\n  private_copies_const_range private_copies() const {\n    return private_copies_const_range(getPrivateCopies().begin(),\n                                      getPrivateCopies().end());\n  }\n\n  using inits_iterator = MutableArrayRef<Expr *>::iterator;\n  using inits_const_iterator = ArrayRef<const Expr *>::iterator;\n  using inits_range = llvm::iterator_range<inits_iterator>;\n  using inits_const_range = llvm::iterator_range<inits_const_iterator>;\n\n  inits_range inits() {\n    return inits_range(getInits().begin(), getInits().end());\n  }\n\n  inits_const_range inits() const {\n    return inits_const_range(getInits().begin(), getInits().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPUseDevicePtrClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_use_device_ptr;\n  }\n};\n\n/// This represents clause 'use_device_addr' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target data use_device_addr(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target data' has clause\n/// 'use_device_addr' with the variables 'a' and 'b'.\nclass OMPUseDeviceAddrClause final\n    : public OMPMappableExprListClause<OMPUseDeviceAddrClause>,\n      private llvm::TrailingObjects<\n          OMPUseDeviceAddrClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDeviceAddrClause(const OMPVarListLocTy &Locs,\n                                  const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_addr, Locs,\n                                  Sizes) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDeviceAddrClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_addr,\n                                  OMPVarListLocTy(), Sizes) {}\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  static OMPUseDeviceAddrClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPUseDeviceAddrClause *\n  CreateEmpty(const ASTContext &C, const OMPMappableExprListSizeTy &Sizes);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPUseDeviceAddrClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_use_device_addr;\n  }\n};\n\n/// This represents clause 'is_device_ptr' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target is_device_ptr(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause\n/// 'is_device_ptr' with the variables 'a' and 'b'.\nclass OMPIsDevicePtrClause final\n    : public OMPMappableExprListClause<OMPIsDevicePtrClause>,\n      private llvm::TrailingObjects<\n          OMPIsDevicePtrClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPIsDevicePtrClause(const OMPVarListLocTy &Locs,\n                                const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_is_device_ptr, Locs, Sizes) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPIsDevicePtrClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_is_device_ptr,\n                                  OMPVarListLocTy(), Sizes) {}\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  static OMPIsDevicePtrClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPIsDevicePtrClause *\n  CreateEmpty(const ASTContext &C, const OMPMappableExprListSizeTy &Sizes);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPIsDevicePtrClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_is_device_ptr;\n  }\n};\n\n/// This represents clause 'nontemporal' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp simd nontemporal(a)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'nontemporal' for\n/// the variable 'a'.\nclass OMPNontemporalClause final\n    : public OMPVarListClause<OMPNontemporalClause>,\n      private llvm::TrailingObjects<OMPNontemporalClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPNontemporalClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPNontemporalClause>(llvm::omp::OMPC_nontemporal,\n                                               StartLoc, LParenLoc, EndLoc, N) {\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPNontemporalClause(unsigned N)\n      : OMPVarListClause<OMPNontemporalClause>(\n            llvm::omp::OMPC_nontemporal, SourceLocation(), SourceLocation(),\n            SourceLocation(), N) {}\n\n  /// Get the list of privatied copies if the member expression was captured by\n  /// one of the privatization clauses.\n  MutableArrayRef<Expr *> getPrivateRefs() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateRefs() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPNontemporalClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPNontemporalClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Sets the list of references to private copies created in private clauses.\n  /// \\param VL List of references.\n  void setPrivateRefs(ArrayRef<Expr *> VL);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPNontemporalClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range private_refs() {\n    return child_range(reinterpret_cast<Stmt **>(getPrivateRefs().begin()),\n                       reinterpret_cast<Stmt **>(getPrivateRefs().end()));\n  }\n\n  const_child_range private_refs() const {\n    auto Children = const_cast<OMPNontemporalClause *>(this)->private_refs();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_nontemporal;\n  }\n};\n\n/// This represents 'order' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp simd order(concurrent)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'order'\n/// clause with kind 'concurrent'.\nclass OMPOrderClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'default' clause.\n  OpenMPOrderClauseKind Kind = OMPC_ORDER_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clause.\n  ///\n  /// \\param K Argument of clause.\n  void setKind(OpenMPOrderClauseKind K) { Kind = K; }\n\n  /// Set argument location.\n  ///\n  /// \\param KLoc Argument location.\n  void setKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }\n\npublic:\n  /// Build 'order' clause with argument \\p A ('concurrent').\n  ///\n  /// \\param A Argument of the clause ('concurrent').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPOrderClause(OpenMPOrderClauseKind A, SourceLocation ALoc,\n                 SourceLocation StartLoc, SourceLocation LParenLoc,\n                 SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_order, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPOrderClause()\n      : OMPClause(llvm::omp::OMPC_order, SourceLocation(), SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  OpenMPOrderClauseKind getKind() const { return Kind; }\n\n  /// Returns location of clause kind.\n  SourceLocation getKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_order;\n  }\n};\n\n/// This represents 'destroy' clause in the '#pragma omp depobj'\n/// directive.\n///\n/// \\code\n/// #pragma omp depobj(a) destroy\n/// \\endcode\n/// In this example directive '#pragma omp depobj' has 'destroy' clause.\nclass OMPDestroyClause final : public OMPClause {\npublic:\n  /// Build 'destroy' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDestroyClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_destroy, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPDestroyClause()\n      : OMPClause(llvm::omp::OMPC_destroy, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_destroy;\n  }\n};\n\n/// This represents 'detach' clause in the '#pragma omp task' directive.\n///\n/// \\code\n/// #pragma omp task detach(evt)\n/// \\endcode\n/// In this example directive '#pragma omp detach' has simple 'detach' clause\n/// with the variable 'evt'.\nclass OMPDetachClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Expression of the 'detach' clause.\n  Stmt *Evt = nullptr;\n\n  /// Set condition.\n  void setEventHandler(Expr *E) { Evt = E; }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\npublic:\n  /// Build 'detach' clause with event-handler \\a Evt.\n  ///\n  /// \\param Evt Event handler expression.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDetachClause(Expr *Evt, SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_detach, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Evt(Evt) {}\n\n  /// Build an empty clause.\n  OMPDetachClause()\n      : OMPClause(llvm::omp::OMPC_detach, SourceLocation(), SourceLocation()) {}\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns event-handler expression.\n  Expr *getEventHandler() const { return cast_or_null<Expr>(Evt); }\n\n  child_range children() { return child_range(&Evt, &Evt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Evt, &Evt + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_detach;\n  }\n};\n\n/// This represents clause 'inclusive' in the '#pragma omp scan' directive.\n///\n/// \\code\n/// #pragma omp scan inclusive(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp scan' has clause 'inclusive'\n/// with the variables 'a' and 'b'.\nclass OMPInclusiveClause final\n    : public OMPVarListClause<OMPInclusiveClause>,\n      private llvm::TrailingObjects<OMPInclusiveClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPInclusiveClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPInclusiveClause>(llvm::omp::OMPC_inclusive,\n                                             StartLoc, LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPInclusiveClause(unsigned N)\n      : OMPVarListClause<OMPInclusiveClause>(llvm::omp::OMPC_inclusive,\n                                             SourceLocation(), SourceLocation(),\n                                             SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the original variables.\n  static OMPInclusiveClause *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPInclusiveClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPInclusiveClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_inclusive;\n  }\n};\n\n/// This represents clause 'exclusive' in the '#pragma omp scan' directive.\n///\n/// \\code\n/// #pragma omp scan exclusive(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp scan' has clause 'exclusive'\n/// with the variables 'a' and 'b'.\nclass OMPExclusiveClause final\n    : public OMPVarListClause<OMPExclusiveClause>,\n      private llvm::TrailingObjects<OMPExclusiveClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPExclusiveClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPExclusiveClause>(llvm::omp::OMPC_exclusive,\n                                             StartLoc, LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPExclusiveClause(unsigned N)\n      : OMPVarListClause<OMPExclusiveClause>(llvm::omp::OMPC_exclusive,\n                                             SourceLocation(), SourceLocation(),\n                                             SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the original variables.\n  static OMPExclusiveClause *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPExclusiveClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPExclusiveClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_exclusive;\n  }\n};\n\n/// This represents clause 'uses_allocators' in the '#pragma omp target'-based\n/// directives.\n///\n/// \\code\n/// #pragma omp target uses_allocators(default_allocator, my_allocator(traits))\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'uses_allocators'\n/// with the allocators 'default_allocator' and user-defined 'my_allocator'.\nclass OMPUsesAllocatorsClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPUsesAllocatorsClause, Expr *,\n                                    SourceLocation> {\npublic:\n  /// Data for list of allocators.\n  struct Data {\n    /// Allocator.\n    Expr *Allocator = nullptr;\n    /// Allocator traits.\n    Expr *AllocatorTraits = nullptr;\n    /// Locations of '(' and ')' symbols.\n    SourceLocation LParenLoc, RParenLoc;\n  };\n\nprivate:\n  friend class OMPClauseReader;\n  friend TrailingObjects;\n\n  enum class ExprOffsets {\n    Allocator,\n    AllocatorTraits,\n    Total,\n  };\n\n  enum class ParenLocsOffsets {\n    LParen,\n    RParen,\n    Total,\n  };\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n  /// Total number of allocators in the clause.\n  unsigned NumOfAllocators = 0;\n\n  /// Build clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of allocators asssociated with the clause.\n  OMPUsesAllocatorsClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                          SourceLocation EndLoc, unsigned N)\n      : OMPClause(llvm::omp::OMPC_uses_allocators, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), NumOfAllocators(N) {}\n\n  /// Build an empty clause.\n  /// \\param N Number of allocators asssociated with the clause.\n  ///\n  explicit OMPUsesAllocatorsClause(unsigned N)\n      : OMPClause(llvm::omp::OMPC_uses_allocators, SourceLocation(),\n                  SourceLocation()),\n        NumOfAllocators(N) {}\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return NumOfAllocators * static_cast<int>(ExprOffsets::Total);\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Sets the allocators data for the clause.\n  void setAllocatorsData(ArrayRef<OMPUsesAllocatorsClause::Data> Data);\n\npublic:\n  /// Creates clause with a list of allocators \\p Data.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Data List of allocators.\n  static OMPUsesAllocatorsClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<OMPUsesAllocatorsClause::Data> Data);\n\n  /// Creates an empty clause with the place for \\p N allocators.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of allocators.\n  static OMPUsesAllocatorsClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns number of allocators associated with the clause.\n  unsigned getNumberOfAllocators() const { return NumOfAllocators; }\n\n  /// Returns data for the specified allocator.\n  OMPUsesAllocatorsClause::Data getAllocatorData(unsigned I) const;\n\n  // Iterators\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumOfAllocators *\n                                          static_cast<int>(ExprOffsets::Total));\n  }\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(\n        Begin, Begin + NumOfAllocators * static_cast<int>(ExprOffsets::Total));\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_uses_allocators;\n  }\n};\n\n/// This represents clause 'affinity' in the '#pragma omp task'-based\n/// directives.\n///\n/// \\code\n/// #pragma omp task affinity(iterator(i = 0:n) : ([3][n])a, b[:n], c[i])\n/// \\endcode\n/// In this example directive '#pragma omp task' has clause 'affinity' with the\n/// affinity modifer 'iterator(i = 0:n)' and locator items '([3][n])a', 'b[:n]'\n/// and 'c[i]'.\nclass OMPAffinityClause final\n    : public OMPVarListClause<OMPAffinityClause>,\n      private llvm::TrailingObjects<OMPAffinityClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':' symbol.\n  SourceLocation ColonLoc;\n\n  /// Build clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of locators asssociated with the clause.\n  OMPAffinityClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation ColonLoc, SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPAffinityClause>(llvm::omp::OMPC_affinity, StartLoc,\n                                            LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  /// \\param N Number of locators asssociated with the clause.\n  ///\n  explicit OMPAffinityClause(unsigned N)\n      : OMPVarListClause<OMPAffinityClause>(llvm::omp::OMPC_affinity,\n                                            SourceLocation(), SourceLocation(),\n                                            SourceLocation(), N) {}\n\n  /// Sets the affinity modifier for the clause, if any.\n  void setModifier(Expr *E) {\n    getTrailingObjects<Expr *>()[varlist_size()] = E;\n  }\n\n  /// Sets the location of ':' symbol.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Creates clause with a modifier a list of locator items.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Locators List of locator items.\n  static OMPAffinityClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation LParenLoc,\n                                   SourceLocation ColonLoc,\n                                   SourceLocation EndLoc, Expr *Modifier,\n                                   ArrayRef<Expr *> Locators);\n\n  /// Creates an empty clause with the place for \\p N locator items.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of locator items.\n  static OMPAffinityClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Gets affinity modifier.\n  Expr *getModifier() { return getTrailingObjects<Expr *>()[varlist_size()]; }\n  Expr *getModifier() const {\n    return getTrailingObjects<Expr *>()[varlist_size()];\n  }\n\n  /// Gets the location of ':' symbol.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  // Iterators\n  child_range children() {\n    int Offset = getModifier() ? 1 : 0;\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end() + Offset));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPAffinityClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_affinity;\n  }\n};\n\n/// This class implements a simple visitor for OMPClause\n/// subclasses.\ntemplate<class ImplClass, template <typename> class Ptr, typename RetTy>\nclass OMPClauseVisitorBase {\npublic:\n#define PTR(CLASS) Ptr<CLASS>\n#define DISPATCH(CLASS) \\\n  return static_cast<ImplClass*>(this)->Visit##CLASS(static_cast<PTR(CLASS)>(S))\n\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class)                                         \\\n  RetTy Visit##Class(PTR(Class) S) { DISPATCH(Class); }\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n\n  RetTy Visit(PTR(OMPClause) S) {\n    // Top switch clause: visit each OMPClause.\n    switch (S->getClauseKind()) {\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class)                                         \\\n  case llvm::omp::Clause::Enum:                                                \\\n    return Visit##Class(static_cast<PTR(Class)>(S));\n#define CLAUSE_NO_CLASS(Enum, Str)                                             \\\n  case llvm::omp::Clause::Enum:                                                \\\n    break;\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n    }\n  }\n  // Base case, ignore it. :)\n  RetTy VisitOMPClause(PTR(OMPClause) Node) { return RetTy(); }\n#undef PTR\n#undef DISPATCH\n};\n\ntemplate <typename T> using const_ptr = std::add_pointer_t<std::add_const_t<T>>;\n\ntemplate <class ImplClass, typename RetTy = void>\nclass OMPClauseVisitor\n    : public OMPClauseVisitorBase<ImplClass, std::add_pointer_t, RetTy> {};\ntemplate<class ImplClass, typename RetTy = void>\nclass ConstOMPClauseVisitor :\n      public OMPClauseVisitorBase <ImplClass, const_ptr, RetTy> {};\n\nclass OMPClausePrinter final : public OMPClauseVisitor<OMPClausePrinter> {\n  raw_ostream &OS;\n  const PrintingPolicy &Policy;\n\n  /// Process clauses with list of variables.\n  template <typename T> void VisitOMPClauseList(T *Node, char StartSym);\n  /// Process motion clauses.\n  template <typename T> void VisitOMPMotionClause(T *Node);\n\npublic:\n  OMPClausePrinter(raw_ostream &OS, const PrintingPolicy &Policy)\n      : OS(OS), Policy(Policy) {}\n\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) void Visit##Class(Class *S);\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n};\n\nstruct OMPTraitProperty {\n  llvm::omp::TraitProperty Kind = llvm::omp::TraitProperty::invalid;\n\n  /// The raw string as we parsed it. This is needed for the `isa` trait set\n  /// (which accepts anything) and (later) extensions.\n  StringRef RawString;\n};\nstruct OMPTraitSelector {\n  Expr *ScoreOrCondition = nullptr;\n  llvm::omp::TraitSelector Kind = llvm::omp::TraitSelector::invalid;\n  llvm::SmallVector<OMPTraitProperty, 1> Properties;\n};\nstruct OMPTraitSet {\n  llvm::omp::TraitSet Kind = llvm::omp::TraitSet::invalid;\n  llvm::SmallVector<OMPTraitSelector, 2> Selectors;\n};\n\n/// Helper data structure representing the traits in a match clause of an\n/// `declare variant` or `metadirective`. The outer level is an ordered\n/// collection of selector sets, each with an associated kind and an ordered\n/// collection of selectors. A selector has a kind, an optional score/condition,\n/// and an ordered collection of properties.\nclass OMPTraitInfo {\n  /// Private constructor accesible only by ASTContext.\n  OMPTraitInfo() {}\n  friend class ASTContext;\n\npublic:\n  /// Reconstruct a (partial) OMPTraitInfo object from a mangled name.\n  OMPTraitInfo(StringRef MangledName);\n\n  /// The outermost level of selector sets.\n  llvm::SmallVector<OMPTraitSet, 2> Sets;\n\n  bool anyScoreOrCondition(\n      llvm::function_ref<bool(Expr *&, bool /* IsScore */)> Cond) {\n    return llvm::any_of(Sets, [&](OMPTraitSet &Set) {\n      return llvm::any_of(\n          Set.Selectors, [&](OMPTraitSelector &Selector) {\n            return Cond(Selector.ScoreOrCondition,\n                        /* IsScore */ Selector.Kind !=\n                            llvm::omp::TraitSelector::user_condition);\n          });\n    });\n  }\n\n  /// Create a variant match info object from this trait info object. While the\n  /// former is a flat representation the actual main difference is that the\n  /// latter uses clang::Expr to store the score/condition while the former is\n  /// independent of clang. Thus, expressions and conditions are evaluated in\n  /// this method.\n  void getAsVariantMatchInfo(ASTContext &ASTCtx,\n                             llvm::omp::VariantMatchInfo &VMI) const;\n\n  /// Return a string representation identifying this context selector.\n  std::string getMangledName() const;\n\n  /// Check the extension trait \\p TP is active.\n  bool isExtensionActive(llvm::omp::TraitProperty TP) {\n    for (const OMPTraitSet &Set : Sets) {\n      if (Set.Kind != llvm::omp::TraitSet::implementation)\n        continue;\n      for (const OMPTraitSelector &Selector : Set.Selectors) {\n        if (Selector.Kind != llvm::omp::TraitSelector::implementation_extension)\n          continue;\n        for (const OMPTraitProperty &Property : Selector.Properties) {\n          if (Property.Kind == TP)\n            return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /// Print a human readable representation into \\p OS.\n  void print(llvm::raw_ostream &OS, const PrintingPolicy &Policy) const;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const OMPTraitInfo &TI);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const OMPTraitInfo *TI);\n\n/// Clang specific specialization of the OMPContext to lookup target features.\nstruct TargetOMPContext final : public llvm::omp::OMPContext {\n\n  TargetOMPContext(ASTContext &ASTCtx,\n                   std::function<void(StringRef)> &&DiagUnknownTrait,\n                   const FunctionDecl *CurrentFunctionDecl);\n  virtual ~TargetOMPContext() = default;\n\n  /// See llvm::omp::OMPContext::matchesISATrait\n  bool matchesISATrait(StringRef RawString) const override;\n\nprivate:\n  std::function<bool(StringRef)> FeatureValidityCheck;\n  std::function<void(StringRef)> DiagUnknownTrait;\n  llvm::StringMap<bool> FeatureMap;\n};\n\n/// Contains data for OpenMP directives: clauses, children\n/// expressions/statements (helpers for codegen) and associated statement, if\n/// any.\nclass OMPChildren final\n    : private llvm::TrailingObjects<OMPChildren, OMPClause *, Stmt *> {\n  friend TrailingObjects;\n  friend class OMPClauseReader;\n  friend class OMPExecutableDirective;\n  template <typename T> friend class OMPDeclarativeDirective;\n\n  /// Numbers of clauses.\n  unsigned NumClauses = 0;\n  /// Number of child expressions/stmts.\n  unsigned NumChildren = 0;\n  /// true if the directive has associated statement.\n  bool HasAssociatedStmt = false;\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<OMPClause *>) const {\n    return NumClauses;\n  }\n\n  OMPChildren() = delete;\n\n  OMPChildren(unsigned NumClauses, unsigned NumChildren, bool HasAssociatedStmt)\n      : NumClauses(NumClauses), NumChildren(NumChildren),\n        HasAssociatedStmt(HasAssociatedStmt) {}\n\n  static size_t size(unsigned NumClauses, bool HasAssociatedStmt,\n                     unsigned NumChildren);\n\n  static OMPChildren *Create(void *Mem, ArrayRef<OMPClause *> Clauses);\n  static OMPChildren *Create(void *Mem, ArrayRef<OMPClause *> Clauses, Stmt *S,\n                             unsigned NumChildren = 0);\n  static OMPChildren *CreateEmpty(void *Mem, unsigned NumClauses,\n                                  bool HasAssociatedStmt = false,\n                                  unsigned NumChildren = 0);\n\npublic:\n  unsigned getNumClauses() const { return NumClauses; }\n  unsigned getNumChildren() const { return NumChildren; }\n  bool hasAssociatedStmt() const { return HasAssociatedStmt; }\n\n  /// Set associated statement.\n  void setAssociatedStmt(Stmt *S) {\n    getTrailingObjects<Stmt *>()[NumChildren] = S;\n  }\n\n  void setChildren(ArrayRef<Stmt *> Children);\n\n  /// Sets the list of variables for this clause.\n  ///\n  /// \\param Clauses The list of clauses for the directive.\n  ///\n  void setClauses(ArrayRef<OMPClause *> Clauses);\n\n  /// Returns statement associated with the directive.\n  const Stmt *getAssociatedStmt() const {\n    return const_cast<OMPChildren *>(this)->getAssociatedStmt();\n  }\n  Stmt *getAssociatedStmt() {\n    assert(HasAssociatedStmt &&\n           \"Expected directive with the associated statement.\");\n    return getTrailingObjects<Stmt *>()[NumChildren];\n  }\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    return llvm::makeMutableArrayRef(getTrailingObjects<OMPClause *>(),\n                                     NumClauses);\n  }\n  ArrayRef<OMPClause *> getClauses() const {\n    return const_cast<OMPChildren *>(this)->getClauses();\n  }\n\n  /// Returns the captured statement associated with the\n  /// component region within the (combined) directive.\n  ///\n  /// \\param RegionKind Component region kind.\n  const CapturedStmt *\n  getCapturedStmt(OpenMPDirectiveKind RegionKind,\n                  ArrayRef<OpenMPDirectiveKind> CaptureRegions) const {\n    assert(llvm::any_of(\n               CaptureRegions,\n               [=](const OpenMPDirectiveKind K) { return K == RegionKind; }) &&\n           \"RegionKind not found in OpenMP CaptureRegions.\");\n    auto *CS = cast<CapturedStmt>(getAssociatedStmt());\n    for (auto ThisCaptureRegion : CaptureRegions) {\n      if (ThisCaptureRegion == RegionKind)\n        return CS;\n      CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    }\n    llvm_unreachable(\"Incorrect RegionKind specified for directive.\");\n  }\n\n  /// Get innermost captured statement for the construct.\n  CapturedStmt *\n  getInnermostCapturedStmt(ArrayRef<OpenMPDirectiveKind> CaptureRegions) {\n    assert(hasAssociatedStmt() && \"Must have associated captured statement.\");\n    assert(!CaptureRegions.empty() &&\n           \"At least one captured statement must be provided.\");\n    auto *CS = cast<CapturedStmt>(getAssociatedStmt());\n    for (unsigned Level = CaptureRegions.size(); Level > 1; --Level)\n      CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    return CS;\n  }\n\n  const CapturedStmt *\n  getInnermostCapturedStmt(ArrayRef<OpenMPDirectiveKind> CaptureRegions) const {\n    return const_cast<OMPChildren *>(this)->getInnermostCapturedStmt(\n        CaptureRegions);\n  }\n\n  MutableArrayRef<Stmt *> getChildren();\n  ArrayRef<Stmt *> getChildren() const {\n    return const_cast<OMPChildren *>(this)->getChildren();\n  }\n\n  Stmt *getRawStmt() {\n    assert(HasAssociatedStmt &&\n           \"Expected directive with the associated statement.\");\n    if (auto *CS = dyn_cast<CapturedStmt>(getAssociatedStmt())) {\n      Stmt *S = nullptr;\n      do {\n        S = CS->getCapturedStmt();\n        CS = dyn_cast<CapturedStmt>(S);\n      } while (CS);\n      return S;\n    }\n    return getAssociatedStmt();\n  }\n  const Stmt *getRawStmt() const {\n    return const_cast<OMPChildren *>(this)->getRawStmt();\n  }\n\n  Stmt::child_range getAssociatedStmtAsRange() {\n    if (!HasAssociatedStmt)\n      return Stmt::child_range(Stmt::child_iterator(), Stmt::child_iterator());\n    return Stmt::child_range(&getTrailingObjects<Stmt *>()[NumChildren],\n                             &getTrailingObjects<Stmt *>()[NumChildren + 1]);\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_OPENMPCLAUSE_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "content": "//===- StmtOpenMP.h - Classes for OpenMP directives  ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file defines OpenMP AST classes for executable directives and\n/// clauses.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMTOPENMP_H\n#define LLVM_CLANG_AST_STMTOPENMP_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n\nnamespace clang {\n\n//===----------------------------------------------------------------------===//\n// AST classes for directives.\n//===----------------------------------------------------------------------===//\n\n/// Representation of an OpenMP canonical loop.\n///\n/// OpenMP 1.0 C/C++, section 2.4.1 for Construct; canonical-shape\n/// OpenMP 2.0 C/C++, section 2.4.1 for Construct; canonical-shape\n/// OpenMP 2.5, section 2.5.1 Loop Construct; canonical form\n/// OpenMP 3.1, section 2.5.1 Loop Construct; canonical form\n/// OpenMP 4.0, section 2.6 Canonical Loop Form\n/// OpenMP 4.5, section 2.6 Canonical Loop Form\n/// OpenMP 5.0, section 2.9.1 Canonical Loop Form\n/// OpenMP 5.1, section 2.11.1 Canonical Loop Nest Form\n///\n/// An OpenMP canonical loop is a for-statement or range-based for-statement\n/// with additional requirements that ensure that the number of iterations is\n/// known before entering the loop and allow skipping to an arbitrary iteration.\n/// The OMPCanonicalLoop AST node wraps a ForStmt or CXXForRangeStmt that is\n/// known to fulfill OpenMP's canonical loop requirements because of being\n/// associated to an OMPLoopBasedDirective. That is, the general structure is:\n///\n///  OMPLoopBasedDirective\n/// [`- CapturedStmt   ]\n/// [   `- CapturedDecl]\n///        ` OMPCanonicalLoop\n///          `- ForStmt/CXXForRangeStmt\n///             `- Stmt\n///\n/// One or multiple CapturedStmt/CapturedDecl pairs may be inserted by some\n/// directives such as OMPParallelForDirective, but others do not need them\n/// (such as OMPTileDirective). In  The OMPCanonicalLoop and\n/// ForStmt/CXXForRangeStmt pair is repeated for loop associated with the\n/// directive. A OMPCanonicalLoop must not appear in the AST unless associated\n/// with a OMPLoopBasedDirective. In an imperfectly nested loop nest, the\n/// OMPCanonicalLoop may also be wrapped in a CompoundStmt:\n///\n/// [...]\n///  ` OMPCanonicalLoop\n///    `- ForStmt/CXXForRangeStmt\n///       `- CompoundStmt\n///          |- Leading in-between code (if any)\n///          |- OMPCanonicalLoop\n///          |  `- ForStmt/CXXForRangeStmt\n///          |     `- ...\n///          `- Trailing in-between code (if any)\n///\n/// The leading/trailing in-between code must not itself be a OMPCanonicalLoop\n/// to avoid confusion which loop belongs to the nesting.\n///\n/// There are three different kinds of iteration variables for different\n/// purposes:\n/// * Loop user variable: The user-accessible variable with different value for\n///   each iteration.\n/// * Loop iteration variable: The variable used to identify a loop iteration;\n///   for range-based for-statement, this is the hidden iterator '__begin'. For\n///   other loops, it is identical to the loop user variable. Must be a\n///   random-access iterator, pointer or integer type.\n/// * Logical iteration counter: Normalized loop counter starting at 0 and\n///   incrementing by one at each iteration. Allows abstracting over the type\n///   of the loop iteration variable and is always an unsigned integer type\n///   appropriate to represent the range of the loop iteration variable. Its\n///   value corresponds to the logical iteration number in the OpenMP\n///   specification.\n///\n/// This AST node provides two captured statements:\n/// * The distance function which computes the number of iterations.\n/// * The loop user variable function that computes the loop user variable when\n///   given a logical iteration number.\n///\n/// These captured statements provide the link between C/C++ semantics and the\n/// logical iteration counters used by the OpenMPIRBuilder which is\n/// language-agnostic and therefore does not know e.g. how to advance a\n/// random-access iterator. The OpenMPIRBuilder will use this information to\n/// apply simd, workshare-loop, distribute, taskloop and loop directives to the\n/// loop. For compatibility with the non-OpenMPIRBuilder codegen path, an\n/// OMPCanonicalLoop can itself also be wrapped into the CapturedStmts of an\n/// OMPLoopDirective and skipped when searching for the associated syntactical\n/// loop.\n///\n/// Example:\n/// <code>\n///   std::vector<std::string> Container{1,2,3};\n///   for (std::string Str : Container)\n///      Body(Str);\n/// </code>\n/// which is syntactic sugar for approximately:\n/// <code>\n///   auto &&__range = Container;\n///   auto __begin = std::begin(__range);\n///   auto __end = std::end(__range);\n///   for (; __begin != __end; ++__begin) {\n///     std::String Str = *__begin;\n///     Body(Str);\n///   }\n/// </code>\n/// In this example, the loop user variable is `Str`, the loop iteration\n/// variable is `__begin` of type `std::vector<std::string>::iterator` and the\n/// logical iteration number type is `size_t` (unsigned version of\n/// `std::vector<std::string>::iterator::difference_type` aka `ptrdiff_t`).\n/// Therefore, the distance function will be\n/// <code>\n///   [&](size_t &Result) { Result = __end - __begin; }\n/// </code>\n/// and the loop variable function is\n/// <code>\n///   [&,__begin](std::vector<std::string>::iterator &Result, size_t Logical) {\n///     Result = __begin + Logical;\n///   }\n/// </code>\n/// The variable `__begin`, aka the loop iteration variable, is captured by\n/// value because it is modified in the loop body, but both functions require\n/// the initial value. The OpenMP specification explicitly leaves unspecified\n/// when the loop expressions are evaluated such that a capture by reference is\n/// sufficient.\nclass OMPCanonicalLoop : public Stmt {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Children of this AST node.\n  enum {\n    LOOP_STMT,\n    DISTANCE_FUNC,\n    LOOPVAR_FUNC,\n    LOOPVAR_REF,\n    LastSubStmt = LOOPVAR_REF\n  };\n\nprivate:\n  /// This AST node's children.\n  Stmt *SubStmts[LastSubStmt + 1] = {};\n\n  OMPCanonicalLoop() : Stmt(StmtClass::OMPCanonicalLoopClass) {}\n\npublic:\n  /// Create a new OMPCanonicalLoop.\n  static OMPCanonicalLoop *create(const ASTContext &Ctx, Stmt *LoopStmt,\n                                  CapturedStmt *DistanceFunc,\n                                  CapturedStmt *LoopVarFunc,\n                                  DeclRefExpr *LoopVarRef) {\n    OMPCanonicalLoop *S = new (Ctx) OMPCanonicalLoop();\n    S->setLoopStmt(LoopStmt);\n    S->setDistanceFunc(DistanceFunc);\n    S->setLoopVarFunc(LoopVarFunc);\n    S->setLoopVarRef(LoopVarRef);\n    return S;\n  }\n\n  /// Create an empty OMPCanonicalLoop for deserialization.\n  static OMPCanonicalLoop *createEmpty(const ASTContext &Ctx) {\n    return new (Ctx) OMPCanonicalLoop();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == StmtClass::OMPCanonicalLoopClass;\n  }\n\n  SourceLocation getBeginLoc() const { return getLoopStmt()->getBeginLoc(); }\n  SourceLocation getEndLoc() const { return getLoopStmt()->getEndLoc(); }\n\n  /// Return this AST node's children.\n  /// @{\n  child_range children() {\n    return child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  /// @}\n\n  /// The wrapped syntactic loop statement (ForStmt or CXXForRangeStmt).\n  /// @{\n  Stmt *getLoopStmt() { return SubStmts[LOOP_STMT]; }\n  const Stmt *getLoopStmt() const { return SubStmts[LOOP_STMT]; }\n  void setLoopStmt(Stmt *S) {\n    assert((isa<ForStmt>(S) || isa<CXXForRangeStmt>(S)) &&\n           \"Canonical loop must be a for loop (range-based or otherwise)\");\n    SubStmts[LOOP_STMT] = S;\n  }\n  /// @}\n\n  /// The function that computes the number of loop iterations. Can be evaluated\n  /// before entering the loop but after the syntactical loop's init\n  /// statement(s).\n  ///\n  /// Function signature: void(LogicalTy &Result)\n  /// Any values necessary to compute the distance are captures of the closure.\n  /// @{\n  CapturedStmt *getDistanceFunc() {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  const CapturedStmt *getDistanceFunc() const {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  void setDistanceFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[DISTANCE_FUNC] = S;\n  }\n  /// @}\n\n  /// The function that computes the loop user variable from a logical iteration\n  /// counter. Can be evaluated as first statement in the loop.\n  ///\n  /// Function signature: void(LoopVarTy &Result, LogicalTy Number)\n  /// Any other values required to compute the loop user variable (such as start\n  /// value, step size) are captured by the closure. In particular, the initial\n  /// value of loop iteration variable is captured by value to be unaffected by\n  /// previous iterations.\n  /// @{\n  CapturedStmt *getLoopVarFunc() {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  const CapturedStmt *getLoopVarFunc() const {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  void setLoopVarFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[LOOPVAR_FUNC] = S;\n  }\n  /// @}\n\n  /// Reference to the loop user variable as accessed in the loop body.\n  /// @{\n  DeclRefExpr *getLoopVarRef() {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  const DeclRefExpr *getLoopVarRef() const {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  void setLoopVarRef(DeclRefExpr *E) {\n    assert(E && \"Expected non-null loop variable\");\n    SubStmts[LOOPVAR_REF] = E;\n  }\n  /// @}\n};\n\n/// This is a basic class for representing single OpenMP executable\n/// directive.\n///\nclass OMPExecutableDirective : public Stmt {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Kind of the directive.\n  OpenMPDirectiveKind Kind = llvm::omp::OMPD_unknown;\n  /// Starting location of the directive (directive keyword).\n  SourceLocation StartLoc;\n  /// Ending location of the directive.\n  SourceLocation EndLoc;\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\nprotected:\n  /// Data, associated with the directive.\n  OMPChildren *Data = nullptr;\n\n  /// Build instance of directive of class \\a K.\n  ///\n  /// \\param SC Statement class.\n  /// \\param K Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPExecutableDirective(StmtClass SC, OpenMPDirectiveKind K,\n                         SourceLocation StartLoc, SourceLocation EndLoc)\n      : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),\n        EndLoc(std::move(EndLoc)) {}\n\n  template <typename T, typename... Params>\n  static T *createDirective(const ASTContext &C, ArrayRef<OMPClause *> Clauses,\n                            Stmt *AssociatedStmt, unsigned NumChildren,\n                            Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(Clauses.size(), AssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n\n    auto *Data = OMPChildren::Create(reinterpret_cast<T *>(Mem) + 1, Clauses,\n                                     AssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T, typename... Params>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt, unsigned NumChildren,\n                                 Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt = false,\n                                 unsigned NumChildren = 0) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T;\n    Inst->Data = Data;\n    return Inst;\n  }\n\npublic:\n  /// Iterates over expressions/statements used in the construct.\n  class used_clauses_child_iterator\n      : public llvm::iterator_adaptor_base<\n            used_clauses_child_iterator, ArrayRef<OMPClause *>::iterator,\n            std::forward_iterator_tag, Stmt *, ptrdiff_t, Stmt *, Stmt *> {\n    ArrayRef<OMPClause *>::iterator End;\n    OMPClause::child_iterator ChildI, ChildEnd;\n\n    void MoveToNext() {\n      if (ChildI != ChildEnd)\n        return;\n      while (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n          if (ChildI != ChildEnd)\n            return;\n        }\n      }\n    }\n\n  public:\n    explicit used_clauses_child_iterator(ArrayRef<OMPClause *> Clauses)\n        : used_clauses_child_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      if (this->I != End) {\n        ChildI = (*this->I)->used_children().begin();\n        ChildEnd = (*this->I)->used_children().end();\n        MoveToNext();\n      }\n    }\n    Stmt *operator*() const { return *ChildI; }\n    Stmt *operator->() const { return **this; }\n\n    used_clauses_child_iterator &operator++() {\n      ++ChildI;\n      if (ChildI != ChildEnd)\n        return *this;\n      if (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n        }\n      }\n      MoveToNext();\n      return *this;\n    }\n  };\n\n  static llvm::iterator_range<used_clauses_child_iterator>\n  used_clauses_children(ArrayRef<OMPClause *> Clauses) {\n    return {used_clauses_child_iterator(Clauses),\n            used_clauses_child_iterator(llvm::makeArrayRef(Clauses.end(), 0))};\n  }\n\n  /// Iterates over a filtered subrange of clauses applied to a\n  /// directive.\n  ///\n  /// This iterator visits only clauses of type SpecificClause.\n  template <typename SpecificClause>\n  class specific_clause_iterator\n      : public llvm::iterator_adaptor_base<\n            specific_clause_iterator<SpecificClause>,\n            ArrayRef<OMPClause *>::const_iterator, std::forward_iterator_tag,\n            const SpecificClause *, ptrdiff_t, const SpecificClause *,\n            const SpecificClause *> {\n    ArrayRef<OMPClause *>::const_iterator End;\n\n    void SkipToNextClause() {\n      while (this->I != End && !isa<SpecificClause>(*this->I))\n        ++this->I;\n    }\n\n  public:\n    explicit specific_clause_iterator(ArrayRef<OMPClause *> Clauses)\n        : specific_clause_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      SkipToNextClause();\n    }\n\n    const SpecificClause *operator*() const {\n      return cast<SpecificClause>(*this->I);\n    }\n    const SpecificClause *operator->() const { return **this; }\n\n    specific_clause_iterator &operator++() {\n      ++this->I;\n      SkipToNextClause();\n      return *this;\n    }\n  };\n\n  template <typename SpecificClause>\n  static llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind(ArrayRef<OMPClause *> Clauses) {\n    return {specific_clause_iterator<SpecificClause>(Clauses),\n            specific_clause_iterator<SpecificClause>(\n                llvm::makeArrayRef(Clauses.end(), 0))};\n  }\n\n  template <typename SpecificClause>\n  llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind() const {\n    return getClausesOfKind<SpecificClause>(clauses());\n  }\n\n  /// Gets a single clause of the specified kind associated with the\n  /// current directive iff there is only one clause of this kind (and assertion\n  /// is fired if there is more than one clause is associated with the\n  /// directive). Returns nullptr if no clause of this kind is associated with\n  /// the directive.\n  template <typename SpecificClause>\n  const SpecificClause *getSingleClause() const {\n    auto Clauses = getClausesOfKind<SpecificClause>();\n\n    if (Clauses.begin() != Clauses.end()) {\n      assert(std::next(Clauses.begin()) == Clauses.end() &&\n             \"There are at least 2 clauses of the specified kind\");\n      return *Clauses.begin();\n    }\n    return nullptr;\n  }\n\n  /// Returns true if the current directive has one or more clauses of a\n  /// specific kind.\n  template <typename SpecificClause>\n  bool hasClausesOfKind() const {\n    auto Clauses = getClausesOfKind<SpecificClause>();\n    return Clauses.begin() != Clauses.end();\n  }\n\n  /// Returns starting location of directive kind.\n  SourceLocation getBeginLoc() const { return StartLoc; }\n  /// Returns ending location of directive.\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  /// Set starting location of directive kind.\n  ///\n  /// \\param Loc New starting location of directive.\n  ///\n  void setLocStart(SourceLocation Loc) { StartLoc = Loc; }\n  /// Set ending location of directive.\n  ///\n  /// \\param Loc New ending location of directive.\n  ///\n  void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }\n\n  /// Get number of clauses.\n  unsigned getNumClauses() const {\n    if (!Data)\n      return 0;\n    return Data->getNumClauses();\n  }\n\n  /// Returns specified clause.\n  ///\n  /// \\param I Number of clause.\n  ///\n  OMPClause *getClause(unsigned I) const { return clauses()[I]; }\n\n  /// Returns true if directive has associated statement.\n  bool hasAssociatedStmt() const { return Data && Data->hasAssociatedStmt(); }\n\n  /// Returns statement associated with the directive.\n  const Stmt *getAssociatedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getAssociatedStmt();\n  }\n  Stmt *getAssociatedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getAssociatedStmt();\n  }\n\n  /// Returns the captured statement associated with the\n  /// component region within the (combined) directive.\n  ///\n  /// \\param RegionKind Component region kind.\n  const CapturedStmt *getCapturedStmt(OpenMPDirectiveKind RegionKind) const {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getCapturedStmt(RegionKind, CaptureRegions);\n  }\n\n  /// Get innermost captured statement for the construct.\n  CapturedStmt *getInnermostCapturedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getInnermostCapturedStmt(CaptureRegions);\n  }\n\n  const CapturedStmt *getInnermostCapturedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)\n        ->getInnermostCapturedStmt();\n  }\n\n  OpenMPDirectiveKind getDirectiveKind() const { return Kind; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstOMPExecutableDirectiveConstant &&\n           S->getStmtClass() <= lastOMPExecutableDirectiveConstant;\n  }\n\n  child_range children() {\n    if (!Data)\n      return child_range(child_iterator(), child_iterator());\n    return Data->getAssociatedStmtAsRange();\n  }\n\n  const_child_range children() const {\n    return const_cast<OMPExecutableDirective *>(this)->children();\n  }\n\n  ArrayRef<OMPClause *> clauses() const {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\n  /// Returns whether or not this is a Standalone directive.\n  ///\n  /// Stand-alone directives are executable directives\n  /// that have no associated user code.\n  bool isStandaloneDirective() const;\n\n  /// Returns the AST node representing OpenMP structured-block of this\n  /// OpenMP executable directive,\n  /// Prerequisite: Executable Directive must not be Standalone directive.\n  const Stmt *getStructuredBlock() const {\n    return const_cast<OMPExecutableDirective *>(this)->getStructuredBlock();\n  }\n  Stmt *getStructuredBlock();\n\n  const Stmt *getRawStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getRawStmt();\n  }\n  Stmt *getRawStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getRawStmt();\n  }\n};\n\n/// This represents '#pragma omp parallel' directive.\n///\n/// \\code\n/// #pragma omp parallel private(a,b) reduction(+: c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clauses 'private'\n/// with the variables 'a' and 'b' and 'reduction' with operator '+' and\n/// variables 'c' and 'd'.\n///\nclass OMPParallelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPParallelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelDirectiveClass,\n                               llvm::omp::OMPD_parallel, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPParallelDirective()\n      : OMPExecutableDirective(OMPParallelDirectiveClass,\n                               llvm::omp::OMPD_parallel, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPParallelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelDirectiveClass;\n  }\n};\n\n/// The base class for all loop-based directives, including loop transformation\n/// directives.\nclass OMPLoopBasedDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n\nprotected:\n  /// Number of collapsed loops as specified by 'collapse' clause.\n  unsigned NumAssociatedLoops = 0;\n\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param NumAssociatedLoops Number of loops associated with the construct.\n  ///\n  OMPLoopBasedDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                        SourceLocation StartLoc, SourceLocation EndLoc,\n                        unsigned NumAssociatedLoops)\n      : OMPExecutableDirective(SC, Kind, StartLoc, EndLoc),\n        NumAssociatedLoops(NumAssociatedLoops) {}\n\npublic:\n  /// The expressions built to support OpenMP loops in combined/composite\n  /// pragmas (e.g. pragma omp distribute parallel for)\n  struct DistCombinedHelperExprs {\n    /// DistributeLowerBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *LB;\n    /// DistributeUpperBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *UB;\n    /// DistributeEnsureUpperBound - used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct, EUB depends on DistUB\n    Expr *EUB;\n    /// Distribute loop iteration variable init used when composing 'omp\n    /// distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Init;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Cond;\n    /// Update of LowerBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NUB;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct when schedule is chunked.\n    Expr *DistCond;\n    /// 'omp parallel for' loop condition used when composed with\n    /// 'omp distribute' in the same construct and when schedule is\n    /// chunked and the chunk size is 1.\n    Expr *ParForInDistCond;\n  };\n\n  /// The expressions built for the OpenMP loop CodeGen for the\n  /// whole collapsed loop nest.\n  struct HelperExprs {\n    /// Loop iteration variable.\n    Expr *IterationVarRef;\n    /// Loop last iteration number.\n    Expr *LastIteration;\n    /// Loop number of iterations.\n    Expr *NumIterations;\n    /// Calculation of last iteration.\n    Expr *CalcLastIteration;\n    /// Loop pre-condition.\n    Expr *PreCond;\n    /// Loop condition.\n    Expr *Cond;\n    /// Loop iteration variable init.\n    Expr *Init;\n    /// Loop increment.\n    Expr *Inc;\n    /// IsLastIteration - local flag variable passed to runtime.\n    Expr *IL;\n    /// LowerBound - local variable passed to runtime.\n    Expr *LB;\n    /// UpperBound - local variable passed to runtime.\n    Expr *UB;\n    /// Stride - local variable passed to runtime.\n    Expr *ST;\n    /// EnsureUpperBound -- expression UB = min(UB, NumIterations).\n    Expr *EUB;\n    /// Update of LowerBound for statically scheduled 'omp for' loops.\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled 'omp for' loops.\n    Expr *NUB;\n    /// PreviousLowerBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevLB;\n    /// PreviousUpperBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevUB;\n    /// DistInc - increment expression for distribute loop when found\n    /// combined with a further loop level (e.g. in 'distribute parallel for')\n    /// expression IV = IV + ST\n    Expr *DistInc;\n    /// PrevEUB - expression similar to EUB but to be used when loop\n    /// scheduling uses PrevLB and PrevUB (e.g.  in 'distribute parallel for'\n    /// when ensuring that the UB is either the calculated UB by the runtime or\n    /// the end of the assigned distribute chunk)\n    /// expression UB = min (UB, PrevUB)\n    Expr *PrevEUB;\n    /// Counters Loop counters.\n    SmallVector<Expr *, 4> Counters;\n    /// PrivateCounters Loop counters.\n    SmallVector<Expr *, 4> PrivateCounters;\n    /// Expressions for loop counters inits for CodeGen.\n    SmallVector<Expr *, 4> Inits;\n    /// Expressions for loop counters update for CodeGen.\n    SmallVector<Expr *, 4> Updates;\n    /// Final loop counter values for GodeGen.\n    SmallVector<Expr *, 4> Finals;\n    /// List of counters required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentCounters;\n    /// List of initializers required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentInits;\n    /// List of final conditions required for the generation of the\n    /// non-rectangular loops.\n    SmallVector<Expr *, 4> FinalsConditions;\n    /// Init statement for all captured expressions.\n    Stmt *PreInits;\n\n    /// Expressions used when combining OpenMP loop pragmas\n    DistCombinedHelperExprs DistCombinedFields;\n\n    /// Check if all the expressions are built (does not check the\n    /// worksharing ones).\n    bool builtAll() {\n      return IterationVarRef != nullptr && LastIteration != nullptr &&\n             NumIterations != nullptr && PreCond != nullptr &&\n             Cond != nullptr && Init != nullptr && Inc != nullptr;\n    }\n\n    /// Initialize all the fields to null.\n    /// \\param Size Number of elements in the\n    /// counters/finals/updates/dependent_counters/dependent_inits/finals_conditions\n    /// arrays.\n    void clear(unsigned Size) {\n      IterationVarRef = nullptr;\n      LastIteration = nullptr;\n      CalcLastIteration = nullptr;\n      PreCond = nullptr;\n      Cond = nullptr;\n      Init = nullptr;\n      Inc = nullptr;\n      IL = nullptr;\n      LB = nullptr;\n      UB = nullptr;\n      ST = nullptr;\n      EUB = nullptr;\n      NLB = nullptr;\n      NUB = nullptr;\n      NumIterations = nullptr;\n      PrevLB = nullptr;\n      PrevUB = nullptr;\n      DistInc = nullptr;\n      PrevEUB = nullptr;\n      Counters.resize(Size);\n      PrivateCounters.resize(Size);\n      Inits.resize(Size);\n      Updates.resize(Size);\n      Finals.resize(Size);\n      DependentCounters.resize(Size);\n      DependentInits.resize(Size);\n      FinalsConditions.resize(Size);\n      for (unsigned I = 0; I < Size; ++I) {\n        Counters[I] = nullptr;\n        PrivateCounters[I] = nullptr;\n        Inits[I] = nullptr;\n        Updates[I] = nullptr;\n        Finals[I] = nullptr;\n        DependentCounters[I] = nullptr;\n        DependentInits[I] = nullptr;\n        FinalsConditions[I] = nullptr;\n      }\n      PreInits = nullptr;\n      DistCombinedFields.LB = nullptr;\n      DistCombinedFields.UB = nullptr;\n      DistCombinedFields.EUB = nullptr;\n      DistCombinedFields.Init = nullptr;\n      DistCombinedFields.Cond = nullptr;\n      DistCombinedFields.NLB = nullptr;\n      DistCombinedFields.NUB = nullptr;\n      DistCombinedFields.DistCond = nullptr;\n      DistCombinedFields.ParForInDistCond = nullptr;\n    }\n  };\n\n  /// Get number of collapsed loops.\n  unsigned getLoopsNumber() const { return NumAssociatedLoops; }\n\n  /// Try to find the next loop sub-statement in the specified statement \\p\n  /// CurStmt.\n  /// \\param TryImperfectlyNestedLoops true, if we need to try to look for the\n  /// imperfectly nested loop.\n  static Stmt *tryToFindNextInnerLoop(Stmt *CurStmt,\n                                      bool TryImperfectlyNestedLoops);\n  static const Stmt *tryToFindNextInnerLoop(const Stmt *CurStmt,\n                                            bool TryImperfectlyNestedLoops) {\n    return tryToFindNextInnerLoop(const_cast<Stmt *>(CurStmt),\n                                  TryImperfectlyNestedLoops);\n  }\n\n  /// Calls the specified callback function for all the loops in \\p CurStmt,\n  /// from the outermost to the innermost.\n  static bool\n  doForAllLoops(Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, Stmt *)> Callback);\n  static bool\n  doForAllLoops(const Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *CurStmt) {\n      return Callback(Cnt, CurStmt);\n    };\n    return doForAllLoops(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                         NumLoops, NewCallback);\n  }\n\n  /// Calls the specified callback function for all the loop bodies in \\p\n  /// CurStmt, from the outermost loop to the innermost.\n  static void doForAllLoopsBodies(\n      Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, Stmt *, Stmt *)> Callback);\n  static void doForAllLoopsBodies(\n      const Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, const Stmt *, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *Loop, Stmt *Body) {\n      Callback(Cnt, Loop, Body);\n    };\n    doForAllLoopsBodies(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                        NumLoops, NewCallback);\n  }\n\n  static bool classof(const Stmt *T) {\n    if (auto *D = dyn_cast<OMPExecutableDirective>(T))\n      return isOpenMPLoopDirective(D->getDirectiveKind());\n    return false;\n  }\n};\n\n/// This is a common base class for loop directives ('omp simd', 'omp\n/// for', 'omp for simd' etc.). It is responsible for the loop code generation.\n///\nclass OMPLoopDirective : public OMPLoopBasedDirective {\n  friend class ASTStmtReader;\n\n  /// Offsets to the stored exprs.\n  /// This enumeration contains offsets to all the pointers to children\n  /// expressions stored in OMPLoopDirective.\n  /// The first 9 children are necessary for all the loop directives,\n  /// the next 8 are specific to the worksharing ones, and the next 11 are\n  /// used for combined constructs containing two pragmas associated to loops.\n  /// After the fixed children, three arrays of length NumAssociatedLoops are\n  /// allocated: loop counters, their updates and final values.\n  /// PrevLowerBound and PrevUpperBound are used to communicate blocking\n  /// information in composite constructs which require loop blocking\n  /// DistInc is used to generate the increment expression for the distribute\n  /// loop when combined with a further nested loop\n  /// PrevEnsureUpperBound is used as the EnsureUpperBound expression for the\n  /// for loop when combined with a previous distribute loop in the same pragma\n  /// (e.g. 'distribute parallel for')\n  ///\n  enum {\n    IterationVariableOffset = 0,\n    LastIterationOffset = 1,\n    CalcLastIterationOffset = 2,\n    PreConditionOffset = 3,\n    CondOffset = 4,\n    InitOffset = 5,\n    IncOffset = 6,\n    PreInitsOffset = 7,\n    // The '...End' enumerators do not correspond to child expressions - they\n    // specify the offset to the end (and start of the following counters/\n    // updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays).\n    DefaultEnd = 8,\n    // The following 8 exprs are used by worksharing and distribute loops only.\n    IsLastIterVariableOffset = 8,\n    LowerBoundVariableOffset = 9,\n    UpperBoundVariableOffset = 10,\n    StrideVariableOffset = 11,\n    EnsureUpperBoundOffset = 12,\n    NextLowerBoundOffset = 13,\n    NextUpperBoundOffset = 14,\n    NumIterationsOffset = 15,\n    // Offset to the end for worksharing loop directives.\n    WorksharingEnd = 16,\n    PrevLowerBoundVariableOffset = 16,\n    PrevUpperBoundVariableOffset = 17,\n    DistIncOffset = 18,\n    PrevEnsureUpperBoundOffset = 19,\n    CombinedLowerBoundVariableOffset = 20,\n    CombinedUpperBoundVariableOffset = 21,\n    CombinedEnsureUpperBoundOffset = 22,\n    CombinedInitOffset = 23,\n    CombinedConditionOffset = 24,\n    CombinedNextLowerBoundOffset = 25,\n    CombinedNextUpperBoundOffset = 26,\n    CombinedDistConditionOffset = 27,\n    CombinedParForInDistConditionOffset = 28,\n    // Offset to the end (and start of the following\n    // counters/updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays) for combined distribute loop directives.\n    CombinedDistributeEnd = 29,\n  };\n\n  /// Get the counters storage.\n  MutableArrayRef<Expr *> getCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind())]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the private counters storage.\n  MutableArrayRef<Expr *> getPrivateCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             2 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getUpdates() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             3 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the final counter updates storage.\n  MutableArrayRef<Expr *> getFinals() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             4 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent counters storage.\n  MutableArrayRef<Expr *> getDependentCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             5 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent inits storage.\n  MutableArrayRef<Expr *> getDependentInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             6 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the finals conditions storage.\n  MutableArrayRef<Expr *> getFinalsConditions() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             7 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\nprotected:\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops from 'collapse' clause.\n  ///\n  OMPLoopDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                   SourceLocation StartLoc, SourceLocation EndLoc,\n                   unsigned CollapsedNum)\n      : OMPLoopBasedDirective(SC, Kind, StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Offset to the start of children expression arrays.\n  static unsigned getArraysOffset(OpenMPDirectiveKind Kind) {\n    if (isOpenMPLoopBoundSharingDirective(Kind))\n      return CombinedDistributeEnd;\n    if (isOpenMPWorksharingDirective(Kind) || isOpenMPTaskLoopDirective(Kind) ||\n        isOpenMPDistributeDirective(Kind))\n      return WorksharingEnd;\n    return DefaultEnd;\n  }\n\n  /// Children number.\n  static unsigned numLoopChildren(unsigned CollapsedNum,\n                                  OpenMPDirectiveKind Kind) {\n    return getArraysOffset(Kind) +\n           8 * CollapsedNum; // Counters, PrivateCounters, Inits,\n                             // Updates, Finals, DependentCounters,\n                             // DependentInits, FinalsConditions.\n  }\n\n  void setIterationVariable(Expr *IV) {\n    Data->getChildren()[IterationVariableOffset] = IV;\n  }\n  void setLastIteration(Expr *LI) {\n    Data->getChildren()[LastIterationOffset] = LI;\n  }\n  void setCalcLastIteration(Expr *CLI) {\n    Data->getChildren()[CalcLastIterationOffset] = CLI;\n  }\n  void setPreCond(Expr *PC) { Data->getChildren()[PreConditionOffset] = PC; }\n  void setCond(Expr *Cond) { Data->getChildren()[CondOffset] = Cond; }\n  void setInit(Expr *Init) { Data->getChildren()[InitOffset] = Init; }\n  void setInc(Expr *Inc) { Data->getChildren()[IncOffset] = Inc; }\n  void setPreInits(Stmt *PreInits) {\n    Data->getChildren()[PreInitsOffset] = PreInits;\n  }\n  void setIsLastIterVariable(Expr *IL) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[IsLastIterVariableOffset] = IL;\n  }\n  void setLowerBoundVariable(Expr *LB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[LowerBoundVariableOffset] = LB;\n  }\n  void setUpperBoundVariable(Expr *UB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[UpperBoundVariableOffset] = UB;\n  }\n  void setStrideVariable(Expr *ST) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[StrideVariableOffset] = ST;\n  }\n  void setEnsureUpperBound(Expr *EUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[EnsureUpperBoundOffset] = EUB;\n  }\n  void setNextLowerBound(Expr *NLB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextLowerBoundOffset] = NLB;\n  }\n  void setNextUpperBound(Expr *NUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextUpperBoundOffset] = NUB;\n  }\n  void setNumIterations(Expr *NI) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NumIterationsOffset] = NI;\n  }\n  void setPrevLowerBoundVariable(Expr *PrevLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevLowerBoundVariableOffset] = PrevLB;\n  }\n  void setPrevUpperBoundVariable(Expr *PrevUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevUpperBoundVariableOffset] = PrevUB;\n  }\n  void setDistInc(Expr *DistInc) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[DistIncOffset] = DistInc;\n  }\n  void setPrevEnsureUpperBound(Expr *PrevEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevEnsureUpperBoundOffset] = PrevEUB;\n  }\n  void setCombinedLowerBoundVariable(Expr *CombLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedLowerBoundVariableOffset] = CombLB;\n  }\n  void setCombinedUpperBoundVariable(Expr *CombUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedUpperBoundVariableOffset] = CombUB;\n  }\n  void setCombinedEnsureUpperBound(Expr *CombEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedEnsureUpperBoundOffset] = CombEUB;\n  }\n  void setCombinedInit(Expr *CombInit) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedInitOffset] = CombInit;\n  }\n  void setCombinedCond(Expr *CombCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedConditionOffset] = CombCond;\n  }\n  void setCombinedNextLowerBound(Expr *CombNLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextLowerBoundOffset] = CombNLB;\n  }\n  void setCombinedNextUpperBound(Expr *CombNUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextUpperBoundOffset] = CombNUB;\n  }\n  void setCombinedDistCond(Expr *CombDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedDistConditionOffset] = CombDistCond;\n  }\n  void setCombinedParForInDistCond(Expr *CombParForInDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedParForInDistConditionOffset] =\n        CombParForInDistCond;\n  }\n  void setCounters(ArrayRef<Expr *> A);\n  void setPrivateCounters(ArrayRef<Expr *> A);\n  void setInits(ArrayRef<Expr *> A);\n  void setUpdates(ArrayRef<Expr *> A);\n  void setFinals(ArrayRef<Expr *> A);\n  void setDependentCounters(ArrayRef<Expr *> A);\n  void setDependentInits(ArrayRef<Expr *> A);\n  void setFinalsConditions(ArrayRef<Expr *> A);\n\npublic:\n  Expr *getIterationVariable() const {\n    return cast<Expr>(Data->getChildren()[IterationVariableOffset]);\n  }\n  Expr *getLastIteration() const {\n    return cast<Expr>(Data->getChildren()[LastIterationOffset]);\n  }\n  Expr *getCalcLastIteration() const {\n    return cast<Expr>(Data->getChildren()[CalcLastIterationOffset]);\n  }\n  Expr *getPreCond() const {\n    return cast<Expr>(Data->getChildren()[PreConditionOffset]);\n  }\n  Expr *getCond() const { return cast<Expr>(Data->getChildren()[CondOffset]); }\n  Expr *getInit() const { return cast<Expr>(Data->getChildren()[InitOffset]); }\n  Expr *getInc() const { return cast<Expr>(Data->getChildren()[IncOffset]); }\n  const Stmt *getPreInits() const {\n    return Data->getChildren()[PreInitsOffset];\n  }\n  Stmt *getPreInits() { return Data->getChildren()[PreInitsOffset]; }\n  Expr *getIsLastIterVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[IsLastIterVariableOffset]);\n  }\n  Expr *getLowerBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[LowerBoundVariableOffset]);\n  }\n  Expr *getUpperBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[UpperBoundVariableOffset]);\n  }\n  Expr *getStrideVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[StrideVariableOffset]);\n  }\n  Expr *getEnsureUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[EnsureUpperBoundOffset]);\n  }\n  Expr *getNextLowerBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextLowerBoundOffset]);\n  }\n  Expr *getNextUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextUpperBoundOffset]);\n  }\n  Expr *getNumIterations() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NumIterationsOffset]);\n  }\n  Expr *getPrevLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevLowerBoundVariableOffset]);\n  }\n  Expr *getPrevUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevUpperBoundVariableOffset]);\n  }\n  Expr *getDistInc() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[DistIncOffset]);\n  }\n  Expr *getPrevEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedLowerBoundVariableOffset]);\n  }\n  Expr *getCombinedUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedUpperBoundVariableOffset]);\n  }\n  Expr *getCombinedEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedInit() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedInitOffset]);\n  }\n  Expr *getCombinedCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedConditionOffset]);\n  }\n  Expr *getCombinedNextLowerBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextLowerBoundOffset]);\n  }\n  Expr *getCombinedNextUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextUpperBoundOffset]);\n  }\n  Expr *getCombinedDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedDistConditionOffset]);\n  }\n  Expr *getCombinedParForInDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedParForInDistConditionOffset]);\n  }\n  Stmt *getBody();\n  const Stmt *getBody() const {\n    return const_cast<OMPLoopDirective *>(this)->getBody();\n  }\n\n  ArrayRef<Expr *> counters() { return getCounters(); }\n\n  ArrayRef<Expr *> counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getCounters();\n  }\n\n  ArrayRef<Expr *> private_counters() { return getPrivateCounters(); }\n\n  ArrayRef<Expr *> private_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getPrivateCounters();\n  }\n\n  ArrayRef<Expr *> inits() { return getInits(); }\n\n  ArrayRef<Expr *> inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getInits();\n  }\n\n  ArrayRef<Expr *> updates() { return getUpdates(); }\n\n  ArrayRef<Expr *> updates() const {\n    return const_cast<OMPLoopDirective *>(this)->getUpdates();\n  }\n\n  ArrayRef<Expr *> finals() { return getFinals(); }\n\n  ArrayRef<Expr *> finals() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinals();\n  }\n\n  ArrayRef<Expr *> dependent_counters() { return getDependentCounters(); }\n\n  ArrayRef<Expr *> dependent_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentCounters();\n  }\n\n  ArrayRef<Expr *> dependent_inits() { return getDependentInits(); }\n\n  ArrayRef<Expr *> dependent_inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentInits();\n  }\n\n  ArrayRef<Expr *> finals_conditions() { return getFinalsConditions(); }\n\n  ArrayRef<Expr *> finals_conditions() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinalsConditions();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSimdDirectiveClass ||\n           T->getStmtClass() == OMPForDirectiveClass ||\n           T->getStmtClass() == OMPForSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelForDirectiveClass ||\n           T->getStmtClass() == OMPParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp simd' directive.\n///\n/// \\code\n/// #pragma omp simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and\n/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.\n///\nclass OMPSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                   unsigned CollapsedNum)\n      : OMPLoopDirective(OMPSimdDirectiveClass, llvm::omp::OMPD_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPSimdDirectiveClass, llvm::omp::OMPD_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPSimdDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc, unsigned CollapsedNum,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  Stmt *AssociatedStmt,\n                                  const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSimdDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp for' directive.\n///\n/// \\code\n/// #pragma omp for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp for' has clauses 'private' with the\n/// variables 'a' and 'b' and 'reduction' with operator '+' and variables 'c'\n/// and 'd'.\n///\nclass OMPForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                  unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(getLoopsNumber(),\n                                        llvm::omp::OMPD_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPForDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation EndLoc, unsigned CollapsedNum,\n                                 ArrayRef<OMPClause *> Clauses,\n                                 Stmt *AssociatedStmt, const HelperExprs &Exprs,\n                                 Expr *TaskRedRef, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPForDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                      unsigned CollapsedNum, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPForDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp for simd' directive.\n///\n/// \\code\n/// #pragma omp for simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp for simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and\n/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.\n///\nclass OMPForSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                      unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForSimdDirectiveClass, llvm::omp::OMPD_for_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForSimdDirectiveClass, llvm::omp::OMPD_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPForSimdDirective *CreateEmpty(const ASTContext &C,\n                                          unsigned NumClauses,\n                                          unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp sections' directive.\n///\n/// \\code\n/// #pragma omp sections private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp sections' has clauses 'private' with\n/// the variables 'a' and 'b' and 'reduction' with operator '+' and variables\n/// 'c' and 'd'.\n///\nclass OMPSectionsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSectionsDirectiveClass,\n                               llvm::omp::OMPD_sections, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSectionsDirective()\n      : OMPExecutableDirective(OMPSectionsDirectiveClass,\n                               llvm::omp::OMPD_sections, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner directive.\n  ///\n  static OMPSectionsDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSectionsDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPSectionsDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSectionsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp section' directive.\n///\n/// \\code\n/// #pragma omp section\n/// \\endcode\n///\nclass OMPSectionDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSectionDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSectionDirectiveClass,\n                               llvm::omp::OMPD_section, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSectionDirective()\n      : OMPExecutableDirective(OMPSectionDirectiveClass,\n                               llvm::omp::OMPD_section, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param HasCancel true if current directive has inner directive.\n  ///\n  static OMPSectionDirective *Create(const ASTContext &C,\n                                     SourceLocation StartLoc,\n                                     SourceLocation EndLoc,\n                                     Stmt *AssociatedStmt, bool HasCancel);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPSectionDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSectionDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp single' directive.\n///\n/// \\code\n/// #pragma omp single private(a,b) copyprivate(c,d)\n/// \\endcode\n/// In this example directive '#pragma omp single' has clauses 'private' with\n/// the variables 'a' and 'b' and 'copyprivate' with variables 'c' and 'd'.\n///\nclass OMPSingleDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSingleDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSingleDirectiveClass, llvm::omp::OMPD_single,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSingleDirective()\n      : OMPExecutableDirective(OMPSingleDirectiveClass, llvm::omp::OMPD_single,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPSingleDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSingleDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSingleDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master' directive.\n///\n/// \\code\n/// #pragma omp master\n/// \\endcode\n///\nclass OMPMasterDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPMasterDirectiveClass, llvm::omp::OMPD_master,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPMasterDirective()\n      : OMPExecutableDirective(OMPMasterDirectiveClass, llvm::omp::OMPD_master,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPMasterDirective *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPMasterDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp critical' directive.\n///\n/// \\code\n/// #pragma omp critical\n/// \\endcode\n///\nclass OMPCriticalDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Name of the directive.\n  DeclarationNameInfo DirName;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param Name Name of the directive.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPCriticalDirective(const DeclarationNameInfo &Name, SourceLocation StartLoc,\n                       SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCriticalDirectiveClass,\n                               llvm::omp::OMPD_critical, StartLoc, EndLoc),\n        DirName(Name) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPCriticalDirective()\n      : OMPExecutableDirective(OMPCriticalDirectiveClass,\n                               llvm::omp::OMPD_critical, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Set name of the directive.\n  ///\n  /// \\param Name Name of the directive.\n  ///\n  void setDirectiveName(const DeclarationNameInfo &Name) { DirName = Name; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param Name Name of the directive.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPCriticalDirective *\n  Create(const ASTContext &C, const DeclarationNameInfo &Name,\n         SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPCriticalDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Return name of the directive.\n  ///\n  DeclarationNameInfo getDirectiveName() const { return DirName; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCriticalDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel for' directive.\n///\n/// \\code\n/// #pragma omp parallel for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel for' has clauses 'private'\n/// with the variables 'a' and 'b' and 'reduction' with operator '+' and\n/// variables 'c' and 'd'.\n///\nclass OMPParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current region has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                          unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForDirectiveClass,\n                         llvm::omp::OMPD_parallel_for, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForDirectiveClass,\n                         llvm::omp::OMPD_parallel_for, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(getLoopsNumber(),\n                                        llvm::omp::OMPD_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelForDirective *CreateEmpty(const ASTContext &C,\n                                              unsigned NumClauses,\n                                              unsigned CollapsedNum,\n                                              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel for simd' directive.\n///\n/// \\code\n/// #pragma omp parallel for simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel for simd' has clauses\n/// 'private' with the variables 'a' and 'b', 'linear' with variables 'i', 'j'\n/// and linear step 's', 'reduction' with operator '+' and variables 'c' and\n/// 'd'.\n///\nclass OMPParallelForSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                              unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_for_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_for_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelForSimdDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned NumClauses,\n                                                  unsigned CollapsedNum,\n                                                  EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master' directive.\n///\n/// \\code\n/// #pragma omp parallel master private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master' has clauses\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPParallelMasterDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  OMPParallelMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelMasterDirectiveClass,\n                               llvm::omp::OMPD_parallel_master, StartLoc,\n                               EndLoc) {}\n\n  explicit OMPParallelMasterDirective()\n      : OMPExecutableDirective(OMPParallelMasterDirectiveClass,\n                               llvm::omp::OMPD_parallel_master,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  ///\n  static OMPParallelMasterDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelMasterDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel sections' directive.\n///\n/// \\code\n/// #pragma omp parallel sections private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel sections' has clauses\n/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'\n/// and variables 'c' and 'd'.\n///\nclass OMPParallelSectionsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPParallelSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelSectionsDirectiveClass,\n                               llvm::omp::OMPD_parallel_sections, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPParallelSectionsDirective()\n      : OMPExecutableDirective(OMPParallelSectionsDirectiveClass,\n                               llvm::omp::OMPD_parallel_sections,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPParallelSectionsDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelSectionsDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelSectionsDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelSectionsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp task' directive.\n///\n/// \\code\n/// #pragma omp task private(a,b) final(d)\n/// \\endcode\n/// In this example directive '#pragma omp task' has clauses 'private' with the\n/// variables 'a' and 'b' and 'final' with condition 'd'.\n///\nclass OMPTaskDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if this directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskDirectiveClass, llvm::omp::OMPD_task,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskDirective()\n      : OMPExecutableDirective(OMPTaskDirectiveClass, llvm::omp::OMPD_task,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param HasCancel true, if current directive has inner cancel directive.\n  ///\n  static OMPTaskDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  Stmt *AssociatedStmt, bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskyield' directive.\n///\n/// \\code\n/// #pragma omp taskyield\n/// \\endcode\n///\nclass OMPTaskyieldDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskyieldDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskyieldDirectiveClass,\n                               llvm::omp::OMPD_taskyield, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskyieldDirective()\n      : OMPExecutableDirective(OMPTaskyieldDirectiveClass,\n                               llvm::omp::OMPD_taskyield, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPTaskyieldDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPTaskyieldDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskyieldDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp barrier' directive.\n///\n/// \\code\n/// #pragma omp barrier\n/// \\endcode\n///\nclass OMPBarrierDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPBarrierDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPBarrierDirectiveClass,\n                               llvm::omp::OMPD_barrier, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPBarrierDirective()\n      : OMPExecutableDirective(OMPBarrierDirectiveClass,\n                               llvm::omp::OMPD_barrier, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPBarrierDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPBarrierDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPBarrierDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskwait' directive.\n///\n/// \\code\n/// #pragma omp taskwait\n/// \\endcode\n///\nclass OMPTaskwaitDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskwaitDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskwaitDirectiveClass,\n                               llvm::omp::OMPD_taskwait, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskwaitDirective()\n      : OMPExecutableDirective(OMPTaskwaitDirectiveClass,\n                               llvm::omp::OMPD_taskwait, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPTaskwaitDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPTaskwaitDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskwaitDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskgroup' directive.\n///\n/// \\code\n/// #pragma omp taskgroup\n/// \\endcode\n///\nclass OMPTaskgroupDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskgroupDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskgroupDirectiveClass,\n                               llvm::omp::OMPD_taskgroup, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskgroupDirective()\n      : OMPExecutableDirective(OMPTaskgroupDirectiveClass,\n                               llvm::omp::OMPD_taskgroup, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets the task_reduction return variable.\n  void setReductionRef(Expr *RR) { Data->getChildren()[0] = RR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param ReductionRef Reference to the task_reduction return variable.\n  ///\n  static OMPTaskgroupDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt,\n         Expr *ReductionRef);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskgroupDirective *CreateEmpty(const ASTContext &C,\n                                            unsigned NumClauses, EmptyShell);\n\n\n  /// Returns reference to the task_reduction return variable.\n  const Expr *getReductionRef() const {\n    return const_cast<OMPTaskgroupDirective *>(this)->getReductionRef();\n  }\n  Expr *getReductionRef() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskgroupDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp flush' directive.\n///\n/// \\code\n/// #pragma omp flush(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 2 arguments- variables 'a'\n/// and 'b'.\n/// 'omp flush' directive does not have clauses but have an optional list of\n/// variables to flush. This list of variables is stored within some fake clause\n/// FlushClause.\nclass OMPFlushDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPFlushDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPFlushDirectiveClass, llvm::omp::OMPD_flush,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPFlushDirective()\n      : OMPExecutableDirective(OMPFlushDirectiveClass, llvm::omp::OMPD_flush,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses (only single OMPFlushClause clause is\n  /// allowed).\n  ///\n  static OMPFlushDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation EndLoc,\n                                   ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPFlushDirective *CreateEmpty(const ASTContext &C,\n                                        unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPFlushDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp depobj' directive.\n///\n/// \\code\n/// #pragma omp depobj(a) depend(in:x,y)\n/// \\endcode\n/// In this example directive '#pragma omp  depobj' initializes a depobj object\n/// 'a' with dependence type 'in' and a list with 'x' and 'y' locators.\nclass OMPDepobjDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPDepobjDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPDepobjDirectiveClass, llvm::omp::OMPD_depobj,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPDepobjDirective()\n      : OMPExecutableDirective(OMPDepobjDirectiveClass, llvm::omp::OMPD_depobj,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  ///\n  static OMPDepobjDirective *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDepobjDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDepobjDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp ordered' directive.\n///\n/// \\code\n/// #pragma omp ordered\n/// \\endcode\n///\nclass OMPOrderedDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPOrderedDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPOrderedDirectiveClass,\n                               llvm::omp::OMPD_ordered, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPOrderedDirective()\n      : OMPExecutableDirective(OMPOrderedDirectiveClass,\n                               llvm::omp::OMPD_ordered, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPOrderedDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  /// \\param IsStandalone true, if the the standalone directive is created.\n  ///\n  static OMPOrderedDirective *CreateEmpty(const ASTContext &C,\n                                          unsigned NumClauses,\n                                          bool IsStandalone, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPOrderedDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp atomic' directive.\n///\n/// \\code\n/// #pragma omp atomic capture\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has clause 'capture'.\n///\nclass OMPAtomicDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Used for 'atomic update' or 'atomic capture' constructs. They may\n  /// have atomic expressions of forms\n  /// \\code\n  /// x = x binop expr;\n  /// x = expr binop x;\n  /// \\endcode\n  /// This field is true for the first form of the expression and false for the\n  /// second. Required for correct codegen of non-associative operations (like\n  /// << or >>).\n  bool IsXLHSInRHSPart = false;\n  /// Used for 'atomic update' or 'atomic capture' constructs. They may\n  /// have atomic expressions of forms\n  /// \\code\n  /// v = x; <update x>;\n  /// <update x>; v = x;\n  /// \\endcode\n  /// This field is true for the first(postfix) form of the expression and false\n  /// otherwise.\n  bool IsPostfixUpdate = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPAtomicDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPAtomicDirective()\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set 'x' part of the associated expression/statement.\n  void setX(Expr *X) { Data->getChildren()[0] = X; }\n  /// Set helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  void setUpdateExpr(Expr *UE) { Data->getChildren()[1] = UE; }\n  /// Set 'v' part of the associated expression/statement.\n  void setV(Expr *V) { Data->getChildren()[2] = V; }\n  /// Set 'expr' part of the associated expression/statement.\n  void setExpr(Expr *E) { Data->getChildren()[3] = E; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses and 'x', 'v' and 'expr'\n  /// parts of the atomic construct (see Section 2.12.6, atomic Construct, for\n  /// detailed description of 'x', 'v' and 'expr').\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param X 'x' part of the associated expression/statement.\n  /// \\param V 'v' part of the associated expression/statement.\n  /// \\param E 'expr' part of the associated expression/statement.\n  /// \\param UE Helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  /// \\param IsXLHSInRHSPart true if \\a UE has the first form and false if the\n  /// second.\n  /// \\param IsPostfixUpdate true if original value of 'x' must be stored in\n  /// 'v', not an updated one.\n  static OMPAtomicDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *X, Expr *V,\n         Expr *E, Expr *UE, bool IsXLHSInRHSPart, bool IsPostfixUpdate);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPAtomicDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  /// Get 'x' part of the associated expression/statement.\n  Expr *getX() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n  const Expr *getX() const {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  /// Get helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  Expr *getUpdateExpr() { return cast_or_null<Expr>(Data->getChildren()[1]); }\n  const Expr *getUpdateExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[1]);\n  }\n  /// Return true if helper update expression has form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' and false if it has form\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  bool isXLHSInRHSPart() const { return IsXLHSInRHSPart; }\n  /// Return true if 'v' expression must be updated to original value of\n  /// 'x', false if 'v' must be updated to the new value of 'x'.\n  bool isPostfixUpdate() const { return IsPostfixUpdate; }\n  /// Get 'v' part of the associated expression/statement.\n  Expr *getV() { return cast_or_null<Expr>(Data->getChildren()[2]); }\n  const Expr *getV() const {\n    return cast_or_null<Expr>(Data->getChildren()[2]);\n  }\n  /// Get 'expr' part of the associated expression/statement.\n  Expr *getExpr() { return cast_or_null<Expr>(Data->getChildren()[3]); }\n  const Expr *getExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[3]);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPAtomicDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target' directive.\n///\n/// \\code\n/// #pragma omp target if(a)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTargetDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetDirectiveClass, llvm::omp::OMPD_target,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetDirective()\n      : OMPExecutableDirective(OMPTargetDirectiveClass, llvm::omp::OMPD_target,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target data' directive.\n///\n/// \\code\n/// #pragma omp target data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target data' has clauses 'device'\n/// with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetDataDirectiveClass,\n                               llvm::omp::OMPD_target_data, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetDataDirective()\n      : OMPExecutableDirective(OMPTargetDataDirectiveClass,\n                               llvm::omp::OMPD_target_data, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetDataDirective *CreateEmpty(const ASTContext &C, unsigned N,\n                                             EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target enter data' directive.\n///\n/// \\code\n/// #pragma omp target enter data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target enter data' has clauses\n/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetEnterDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetEnterDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetEnterDataDirectiveClass,\n                               llvm::omp::OMPD_target_enter_data, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetEnterDataDirective()\n      : OMPExecutableDirective(OMPTargetEnterDataDirectiveClass,\n                               llvm::omp::OMPD_target_enter_data,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetEnterDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetEnterDataDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned N, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetEnterDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target exit data' directive.\n///\n/// \\code\n/// #pragma omp target exit data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target exit data' has clauses\n/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetExitDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetExitDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetExitDataDirectiveClass,\n                               llvm::omp::OMPD_target_exit_data, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetExitDataDirective()\n      : OMPExecutableDirective(OMPTargetExitDataDirectiveClass,\n                               llvm::omp::OMPD_target_exit_data,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetExitDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetExitDataDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned N, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetExitDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel' directive.\n///\n/// \\code\n/// #pragma omp target parallel if(a)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTargetParallelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetParallelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetParallelDirectiveClass,\n                               llvm::omp::OMPD_target_parallel, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetParallelDirective()\n      : OMPExecutableDirective(OMPTargetParallelDirectiveClass,\n                               llvm::omp::OMPD_target_parallel,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTargetParallelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetParallelDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel for' directive.\n///\n/// \\code\n/// #pragma omp target parallel for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel for' has clauses\n/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'\n/// and variables 'c' and 'd'.\n///\nclass OMPTargetParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current region has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                                unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_target_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPTargetParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelForDirective *CreateEmpty(const ASTContext &C,\n                                                    unsigned NumClauses,\n                                                    unsigned CollapsedNum,\n                                                    EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_target_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams' directive.\n///\n/// \\code\n/// #pragma omp teams if(a)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTeamsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTeamsDirectiveClass, llvm::omp::OMPD_teams,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTeamsDirective()\n      : OMPExecutableDirective(OMPTeamsDirectiveClass, llvm::omp::OMPD_teams,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTeamsDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation EndLoc,\n                                   ArrayRef<OMPClause *> Clauses,\n                                   Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDirective *CreateEmpty(const ASTContext &C,\n                                        unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp cancellation point' directive.\n///\n/// \\code\n/// #pragma omp cancellation point for\n/// \\endcode\n///\n/// In this example a cancellation point is created for innermost 'for' region.\nclass OMPCancellationPointDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  OpenMPDirectiveKind CancelRegion = llvm::omp::OMPD_unknown;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// statements and child expressions.\n  ///\n  OMPCancellationPointDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,\n                               llvm::omp::OMPD_cancellation_point, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  explicit OMPCancellationPointDirective()\n      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,\n                               llvm::omp::OMPD_cancellation_point,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel region for current cancellation point.\n  /// \\param CR Cancellation region.\n  void setCancelRegion(OpenMPDirectiveKind CR) { CancelRegion = CR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPCancellationPointDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         OpenMPDirectiveKind CancelRegion);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPCancellationPointDirective *CreateEmpty(const ASTContext &C,\n                                                    EmptyShell);\n\n  /// Get cancellation region for the current cancellation point.\n  OpenMPDirectiveKind getCancelRegion() const { return CancelRegion; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCancellationPointDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp cancel' directive.\n///\n/// \\code\n/// #pragma omp cancel for\n/// \\endcode\n///\n/// In this example a cancel is created for innermost 'for' region.\nclass OMPCancelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  OpenMPDirectiveKind CancelRegion = llvm::omp::OMPD_unknown;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPCancelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCancelDirectiveClass, llvm::omp::OMPD_cancel,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPCancelDirective()\n      : OMPExecutableDirective(OMPCancelDirectiveClass, llvm::omp::OMPD_cancel,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel region for current cancellation point.\n  /// \\param CR Cancellation region.\n  void setCancelRegion(OpenMPDirectiveKind CR) { CancelRegion = CR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  ///\n  static OMPCancelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, OpenMPDirectiveKind CancelRegion);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPCancelDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  /// Get cancellation region for the current cancellation point.\n  OpenMPDirectiveKind getCancelRegion() const { return CancelRegion; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCancelDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskloop' directive.\n///\n/// \\code\n/// #pragma omp taskloop private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has clauses 'private'\n/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and\n/// 'num_tasks' with expression 'num'.\n///\nclass OMPTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTaskLoopDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                       unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopDirectiveClass, llvm::omp::OMPD_taskloop,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopDirectiveClass, llvm::omp::OMPD_taskloop,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses,\n                                           unsigned CollapsedNum, EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp taskloop simd private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and\n/// 'num_tasks' with expression 'num'.\n///\nclass OMPTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTaskLoopSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                           unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_taskloop_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_taskloop_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskLoopSimdDirective *CreateEmpty(const ASTContext &C,\n                                               unsigned NumClauses,\n                                               unsigned CollapsedNum,\n                                               EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master taskloop' directive.\n///\n/// \\code\n/// #pragma omp master taskloop private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp master taskloop' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPMasterTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPMasterTaskLoopDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPMasterTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPMasterTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPMasterTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned NumClauses,\n                                                 unsigned CollapsedNum,\n                                                 EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp master taskloop simd private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp master taskloop simd' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPMasterTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPMasterTaskLoopSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                                 unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPMasterTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\p Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPMasterTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\p NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPMasterTaskLoopSimdDirective *CreateEmpty(const ASTContext &C,\n                                                     unsigned NumClauses,\n                                                     unsigned CollapsedNum,\n                                                     EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master taskloop' directive.\n///\n/// \\code\n/// #pragma omp parallel master taskloop private(a,b) grainsize(val)\n/// num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master taskloop' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPParallelMasterTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelMasterTaskLoopDirective(SourceLocation StartLoc,\n                                     SourceLocation EndLoc,\n                                     unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelMasterTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPParallelMasterTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                                         unsigned NumClauses,\n                                                         unsigned CollapsedNum,\n                                                         EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp parallel master taskloop simd private(a,b) grainsize(val)\n/// num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master taskloop simd' has\n/// clauses 'private' with the variables 'a' and 'b', 'grainsize' with\n/// expression 'val' and 'num_tasks' with expression 'num'.\n///\nclass OMPParallelMasterTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelMasterTaskLoopSimdDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelMasterTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\p Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPParallelMasterTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterTaskLoopSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute' directive.\n///\n/// \\code\n/// #pragma omp distribute private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp distribute' has clauses 'private'\n/// with the variables 'a' and 'b'\n///\nclass OMPDistributeDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeDirectiveClass,\n                         llvm::omp::OMPD_distribute, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeDirectiveClass,\n                         llvm::omp::OMPD_distribute, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeDirective *CreateEmpty(const ASTContext &C,\n                                             unsigned NumClauses,\n                                             unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target update' directive.\n///\n/// \\code\n/// #pragma omp target update to(a) from(b) device(1)\n/// \\endcode\n/// In this example directive '#pragma omp target update' has clause 'to' with\n/// argument 'a', clause 'from' with argument 'b' and clause 'device' with\n/// argument '1'.\n///\nclass OMPTargetUpdateDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetUpdateDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetUpdateDirectiveClass,\n                               llvm::omp::OMPD_target_update, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetUpdateDirective()\n      : OMPExecutableDirective(OMPTargetUpdateDirectiveClass,\n                               llvm::omp::OMPD_target_update, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetUpdateDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses The number of clauses.\n  ///\n  static OMPTargetUpdateDirective *CreateEmpty(const ASTContext &C,\n                                               unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetUpdateDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute parallel for' composite\n///  directive.\n///\n/// \\code\n/// #pragma omp distribute parallel for private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp distribute parallel for' has clause\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPDistributeParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeParallelForDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeParallelForDirective *CreateEmpty(const ASTContext &C,\n                                                        unsigned NumClauses,\n                                                        unsigned CollapsedNum,\n                                                        EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute parallel for simd' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp distribute parallel for simd' has\n/// clause 'private' with the variables 'x'\n///\nclass OMPDistributeParallelForSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeParallelForSimdDirective *Create(\n      const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n      unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n      Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeParallelForSimdDirective *CreateEmpty(\n      const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n      EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute simd' composite directive.\n///\n/// \\code\n/// #pragma omp distribute simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp distribute simd' has clause\n/// 'private' with the variables 'x'\n///\nclass OMPDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeSimdDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned NumClauses,\n                                                 unsigned CollapsedNum,\n                                                 EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel for simd' directive.\n///\n/// \\code\n/// #pragma omp target parallel for simd private(a) map(b) safelen(c)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel for simd' has clauses\n/// 'private' with the variable 'a', 'map' with the variable 'b' and 'safelen'\n/// with the variable 'c'.\n///\nclass OMPTargetParallelForSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetParallelForSimdDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelForSimdDirective *CreateEmpty(const ASTContext &C,\n                                                        unsigned NumClauses,\n                                                        unsigned CollapsedNum,\n                                                        EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target simd' directive.\n///\n/// \\code\n/// #pragma omp target simd private(a) map(b) safelen(c)\n/// \\endcode\n/// In this example directive '#pragma omp target simd' has clauses 'private'\n/// with the variable 'a', 'map' with the variable 'b' and 'safelen' with\n/// the variable 'c'.\n///\nclass OMPTargetSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetSimdDirectiveClass,\n                         llvm::omp::OMPD_target_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetSimdDirectiveClass,\n                         llvm::omp::OMPD_target_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetSimdDirective *CreateEmpty(const ASTContext &C,\n                                             unsigned NumClauses,\n                                             unsigned CollapsedNum,\n                                             EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute' directive.\n///\n/// \\code\n/// #pragma omp teams distribute private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute' has clauses\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPTeamsDistributeDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                              unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned NumClauses,\n                                                  unsigned CollapsedNum,\n                                                  EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute simd'\n/// combined directive.\n///\n/// \\code\n/// #pragma omp teams distribute simd private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute simd'\n/// has clause 'private' with the variables 'a' and 'b'\n///\nclass OMPTeamsDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeSimdDirective(SourceLocation StartLoc,\n                                  SourceLocation EndLoc, unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeSimdDirective *CreateEmpty(const ASTContext &C,\n                                                      unsigned NumClauses,\n                                                      unsigned CollapsedNum,\n                                                      EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute parallel for simd' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp teams distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute parallel for simd'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTeamsDistributeParallelForSimdDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                             SourceLocation EndLoc,\n                                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeParallelForSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute parallel for' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp teams distribute parallel for private(x)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute parallel for'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTeamsDistributeParallelForDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeParallelForDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_teams_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTeamsDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeParallelForDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_teams_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTeamsDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams' directive.\n///\n/// \\code\n/// #pragma omp target teams if(a>0)\n/// \\endcode\n/// In this example directive '#pragma omp target teams' has clause 'if' with\n/// condition 'a>0'.\n///\nclass OMPTargetTeamsDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetTeamsDirectiveClass,\n                               llvm::omp::OMPD_target_teams, StartLoc, EndLoc) {\n  }\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetTeamsDirective()\n      : OMPExecutableDirective(OMPTargetTeamsDirectiveClass,\n                               llvm::omp::OMPD_target_teams, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetTeamsDirective *Create(const ASTContext &C,\n                                         SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDirective *CreateEmpty(const ASTContext &C,\n                                              unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute' combined directive.\n///\n/// \\code\n/// #pragma omp target teams distribute private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute' has clause\n/// 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute parallel for' combined\n/// directive.\n///\n/// \\code\n/// #pragma omp target teams distribute parallel for private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute parallel\n/// for' has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeParallelForDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeParallelForDirective(SourceLocation StartLoc,\n                                               SourceLocation EndLoc,\n                                               unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_parallel_for,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(),\n        llvm::omp::OMPD_target_teams_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTargetTeamsDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeParallelForDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(),\n        llvm::omp::OMPD_target_teams_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetTeamsDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() ==\n           OMPTargetTeamsDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute parallel for simd'\n/// combined directive.\n///\n/// \\code\n/// #pragma omp target teams distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute parallel\n/// for simd' has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeParallelForSimdDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                                   SourceLocation EndLoc,\n                                                   unsigned CollapsedNum)\n      : OMPLoopDirective(\n            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,\n            llvm::omp::OMPD_target_teams_distribute_parallel_for_simd, StartLoc,\n            EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeParallelForSimdDirective(\n      unsigned CollapsedNum)\n      : OMPLoopDirective(\n            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,\n            llvm::omp::OMPD_target_teams_distribute_parallel_for_simd,\n            SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeParallelForSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() ==\n           OMPTargetTeamsDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute simd' combined\n/// directive.\n///\n/// \\code\n/// #pragma omp target teams distribute simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute simd'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeSimdDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents the '#pragma omp tile' loop transformation directive.\nclass OMPTileDirective final : public OMPLoopBasedDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Default list of offsets.\n  enum {\n    PreInitsOffset = 0,\n    TransformedStmtOffset,\n  };\n\n  explicit OMPTileDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                            unsigned NumLoops)\n      : OMPLoopBasedDirective(OMPTileDirectiveClass, llvm::omp::OMPD_tile,\n                              StartLoc, EndLoc, NumLoops) {}\n\n  void setPreInits(Stmt *PreInits) {\n    Data->getChildren()[PreInitsOffset] = PreInits;\n  }\n\n  void setTransformedStmt(Stmt *S) {\n    Data->getChildren()[TransformedStmtOffset] = S;\n  }\n\npublic:\n  /// Create a new AST node representation for '#pragma omp tile'.\n  ///\n  /// \\param C         Context of the AST.\n  /// \\param StartLoc  Location of the introducer (e.g. the 'omp' token).\n  /// \\param EndLoc    Location of the directive's end (e.g. the tok::eod).\n  /// \\param Clauses   The directive's clauses.\n  /// \\param NumLoops  Number of associated loops (number of items in the\n  ///                  'sizes' clause).\n  /// \\param AssociatedStmt The outermost associated loop.\n  /// \\param TransformedStmt The loop nest after tiling, or nullptr in\n  ///                        dependent contexts.\n  /// \\param PreInits Helper preinits statements for the loop nest.\n  static OMPTileDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  unsigned NumLoops, Stmt *AssociatedStmt,\n                                  Stmt *TransformedStmt, Stmt *PreInits);\n\n  /// Build an empty '#pragma omp tile' AST node for deserialization.\n  ///\n  /// \\param C          Context of the AST.\n  /// \\param NumClauses Number of clauses to allocate.\n  /// \\param NumLoops   Number of associated loops to allocate.\n  static OMPTileDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       unsigned NumLoops);\n\n  unsigned getNumAssociatedLoops() const { return getLoopsNumber(); }\n\n  /// Gets/sets the associated loops after tiling.\n  ///\n  /// This is in de-sugared format stored as a CompoundStmt.\n  ///\n  /// \\code\n  ///   for (...)\n  ///     ...\n  /// \\endcode\n  ///\n  /// Note that if the generated loops a become associated loops of another\n  /// directive, they may need to be hoisted before them.\n  Stmt *getTransformedStmt() const {\n    return Data->getChildren()[TransformedStmtOffset];\n  }\n\n  /// Return preinits statement.\n  Stmt *getPreInits() const { return Data->getChildren()[PreInitsOffset]; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTileDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp scan' directive.\n///\n/// \\code\n/// #pragma omp scan inclusive(a)\n/// \\endcode\n/// In this example directive '#pragma omp scan' has clause 'inclusive' with\n/// list item 'a'.\nclass OMPScanDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPScanDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPScanDirectiveClass, llvm::omp::OMPD_scan,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPScanDirective()\n      : OMPExecutableDirective(OMPScanDirectiveClass, llvm::omp::OMPD_scan,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses (only single OMPFlushClause clause is\n  /// allowed).\n  ///\n  static OMPScanDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPScanDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPScanDirectiveClass;\n  }\n};\n\n} // end namespace clang\n\n#endif\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "content": "\n//===--- CommandLineSourceLoc.h - Parsing for source locations-*- C++ -*---===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Command line parsing for source locations.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_COMMANDLINESOURCELOC_H\n#define LLVM_CLANG_FRONTEND_COMMANDLINESOURCELOC_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace clang {\n\n/// A source location that has been parsed on the command line.\nstruct ParsedSourceLocation {\n  std::string FileName;\n  unsigned Line;\n  unsigned Column;\n\npublic:\n  /// Construct a parsed source location from a string; the Filename is empty on\n  /// error.\n  static ParsedSourceLocation FromString(StringRef Str) {\n    ParsedSourceLocation PSL;\n    std::pair<StringRef, StringRef> ColSplit = Str.rsplit(':');\n    std::pair<StringRef, StringRef> LineSplit =\n      ColSplit.first.rsplit(':');\n\n    // If both tail splits were valid integers, return success.\n    if (!ColSplit.second.getAsInteger(10, PSL.Column) &&\n        !LineSplit.second.getAsInteger(10, PSL.Line)) {\n      PSL.FileName = std::string(LineSplit.first);\n\n      // On the command-line, stdin may be specified via \"-\". Inside the\n      // compiler, stdin is called \"<stdin>\".\n      if (PSL.FileName == \"-\")\n        PSL.FileName = \"<stdin>\";\n    }\n\n    return PSL;\n  }\n\n  /// Serialize ParsedSourceLocation back to a string.\n  std::string ToString() const {\n    return (llvm::Twine(FileName == \"<stdin>\" ? \"-\" : FileName) + \":\" +\n            Twine(Line) + \":\" + Twine(Column))\n        .str();\n  }\n};\n\n/// A source range that has been parsed on the command line.\nstruct ParsedSourceRange {\n  std::string FileName;\n  /// The starting location of the range. The first element is the line and\n  /// the second element is the column.\n  std::pair<unsigned, unsigned> Begin;\n  /// The ending location of the range. The first element is the line and the\n  /// second element is the column.\n  std::pair<unsigned, unsigned> End;\n\n  /// Returns a parsed source range from a string or None if the string is\n  /// invalid.\n  ///\n  /// These source string has the following format:\n  ///\n  /// file:start_line:start_column[-end_line:end_column]\n  ///\n  /// If the end line and column are omitted, the starting line and columns\n  /// are used as the end values.\n  static Optional<ParsedSourceRange> fromString(StringRef Str) {\n    std::pair<StringRef, StringRef> RangeSplit = Str.rsplit('-');\n    unsigned EndLine, EndColumn;\n    bool HasEndLoc = false;\n    if (!RangeSplit.second.empty()) {\n      std::pair<StringRef, StringRef> Split = RangeSplit.second.rsplit(':');\n      if (Split.first.getAsInteger(10, EndLine) ||\n          Split.second.getAsInteger(10, EndColumn)) {\n        // The string does not end in end_line:end_column, so the '-'\n        // probably belongs to the filename which menas the whole\n        // string should be parsed.\n        RangeSplit.first = Str;\n      } else\n        HasEndLoc = true;\n    }\n    auto Begin = ParsedSourceLocation::FromString(RangeSplit.first);\n    if (Begin.FileName.empty())\n      return None;\n    if (!HasEndLoc) {\n      EndLine = Begin.Line;\n      EndColumn = Begin.Column;\n    }\n    return ParsedSourceRange{std::move(Begin.FileName),\n                             {Begin.Line, Begin.Column},\n                             {EndLine, EndColumn}};\n  }\n};\n}\n\nnamespace llvm {\n  namespace cl {\n    /// Command-line option parser that parses source locations.\n    ///\n    /// Source locations are of the form filename:line:column.\n    template<>\n    class parser<clang::ParsedSourceLocation> final\n      : public basic_parser<clang::ParsedSourceLocation> {\n    public:\n      inline bool parse(Option &O, StringRef ArgName, StringRef ArgValue,\n                 clang::ParsedSourceLocation &Val);\n    };\n\n    bool\n    parser<clang::ParsedSourceLocation>::\n    parse(Option &O, StringRef ArgName, StringRef ArgValue,\n          clang::ParsedSourceLocation &Val) {\n      using namespace clang;\n\n      Val = ParsedSourceLocation::FromString(ArgValue);\n      if (Val.FileName.empty()) {\n        errs() << \"error: \"\n               << \"source location must be of the form filename:line:column\\n\";\n        return true;\n      }\n\n      return false;\n    }\n  }\n}\n\n#endif\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Execution.h", "content": "//===--- Execution.h - Executing clang frontend actions -*- C++ ---------*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines framework for executing clang frontend actions.\n//\n//  The framework can be extended to support different execution plans including\n//  standalone execution on the given TUs or parallel execution on all TUs in\n//  the codebase.\n//\n//  In order to enable multiprocessing execution, tool actions are expected to\n//  output result into the ToolResults provided by the executor. The\n//  `ToolResults` is an interface that abstracts how results are stored e.g.\n//  in-memory for standalone execution or on-disk for large-scale execution.\n//\n//  New executors can be registered as ToolExecutorPlugins via the\n//  `ToolExecutorPluginRegistry`. CLI tools can use\n//  `createExecutorFromCommandLineArgs` to create a specific registered executor\n//  according to the command-line arguments.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_EXECUTION_H\n#define LLVM_CLANG_TOOLING_EXECUTION_H\n\n#include \"clang/Tooling/CommonOptionsParser.h\"\n#include \"clang/Tooling/Tooling.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Registry.h\"\n#include \"llvm/Support/StringSaver.h\"\n\nnamespace clang {\nnamespace tooling {\n\nextern llvm::cl::opt<std::string> ExecutorName;\n\n/// An abstraction for the result of a tool execution. For example, the\n/// underlying result can be in-memory or on-disk.\n///\n/// Results should be string key-value pairs. For example, a refactoring tool\n/// can use source location as key and a replacement in YAML format as value.\nclass ToolResults {\npublic:\n  virtual ~ToolResults() = default;\n  virtual void addResult(StringRef Key, StringRef Value) = 0;\n  virtual std::vector<std::pair<llvm::StringRef, llvm::StringRef>>\n  AllKVResults() = 0;\n  virtual void forEachResult(\n      llvm::function_ref<void(StringRef Key, StringRef Value)> Callback) = 0;\n};\n\n/// Stores the key-value results in memory. It maintains the lifetime of\n/// the result. Clang tools using this class are expected to generate a small\n/// set of different results, or a large set of duplicated results.\nclass InMemoryToolResults : public ToolResults {\npublic:\n  InMemoryToolResults() : Strings(Arena) {}\n  void addResult(StringRef Key, StringRef Value) override;\n  std::vector<std::pair<llvm::StringRef, llvm::StringRef>>\n  AllKVResults() override;\n  void forEachResult(llvm::function_ref<void(StringRef Key, StringRef Value)>\n                         Callback) override;\n\nprivate:\n  llvm::BumpPtrAllocator Arena;\n  llvm::UniqueStringSaver Strings;\n\n  std::vector<std::pair<llvm::StringRef, llvm::StringRef>> KVResults;\n};\n\n/// The context of an execution, including the information about\n/// compilation and results.\nclass ExecutionContext {\npublic:\n  virtual ~ExecutionContext() {}\n\n  /// Initializes a context. This does not take ownership of `Results`.\n  explicit ExecutionContext(ToolResults *Results) : Results(Results) {}\n\n  /// Adds a KV pair to the result container of this execution.\n  void reportResult(StringRef Key, StringRef Value);\n\n  // Returns the source control system's revision number if applicable.\n  // Otherwise returns an empty string.\n  virtual std::string getRevision() { return \"\"; }\n\n  // Returns the corpus being analyzed, e.g. \"llvm\" for the LLVM codebase, if\n  // applicable.\n  virtual std::string getCorpus() { return \"\"; }\n\n  // Returns the currently processed compilation unit if available.\n  virtual std::string getCurrentCompilationUnit() { return \"\"; }\n\nprivate:\n  ToolResults *Results;\n};\n\n/// Interface for executing clang frontend actions.\n///\n/// This can be extended to support running tool actions in different\n/// execution mode, e.g. on a specific set of TUs or many TUs in parallel.\n///\n///  New executors can be registered as ToolExecutorPlugins via the\n///  `ToolExecutorPluginRegistry`. CLI tools can use\n///  `createExecutorFromCommandLineArgs` to create a specific registered\n///  executor according to the command-line arguments.\nclass ToolExecutor {\npublic:\n  virtual ~ToolExecutor() {}\n\n  /// Returns the name of a specific executor.\n  virtual StringRef getExecutorName() const = 0;\n\n  /// Executes each action with a corresponding arguments adjuster.\n  virtual llvm::Error\n  execute(llvm::ArrayRef<\n          std::pair<std::unique_ptr<FrontendActionFactory>, ArgumentsAdjuster>>\n              Actions) = 0;\n\n  /// Convenient functions for the above `execute`.\n  llvm::Error execute(std::unique_ptr<FrontendActionFactory> Action);\n  /// Executes an action with an argument adjuster.\n  llvm::Error execute(std::unique_ptr<FrontendActionFactory> Action,\n                      ArgumentsAdjuster Adjuster);\n\n  /// Returns a reference to the execution context.\n  ///\n  /// This should be passed to tool callbacks, and tool callbacks should report\n  /// results via the returned context.\n  virtual ExecutionContext *getExecutionContext() = 0;\n\n  /// Returns a reference to the result container.\n  ///\n  /// NOTE: This should only be used after the execution finishes. Tool\n  /// callbacks should report results via `ExecutionContext` instead.\n  virtual ToolResults *getToolResults() = 0;\n\n  /// Map a virtual file to be used while running the tool.\n  ///\n  /// \\param FilePath The path at which the content will be mapped.\n  /// \\param Content A buffer of the file's content.\n  virtual void mapVirtualFile(StringRef FilePath, StringRef Content) = 0;\n};\n\n/// Interface for factories that create specific executors. This is also\n/// used as a plugin to be registered into ToolExecutorPluginRegistry.\nclass ToolExecutorPlugin {\npublic:\n  virtual ~ToolExecutorPlugin() {}\n\n  /// Create an `ToolExecutor`.\n  ///\n  /// `OptionsParser` can be consumed (e.g. moved) if the creation succeeds.\n  virtual llvm::Expected<std::unique_ptr<ToolExecutor>>\n  create(CommonOptionsParser &OptionsParser) = 0;\n};\n\n/// This creates a ToolExecutor that is in the global registry based on\n/// commandline arguments.\n///\n/// This picks the right executor based on the `--executor` option. This parses\n/// the commandline arguments with `CommonOptionsParser`, so caller does not\n/// need to parse again.\n///\n/// By default, this creates a `StandaloneToolExecutor` (\"standalone\") if\n/// `--executor` is not provided.\nllvm::Expected<std::unique_ptr<ToolExecutor>>\ncreateExecutorFromCommandLineArgs(int &argc, const char **argv,\n                                  llvm::cl::OptionCategory &Category,\n                                  const char *Overview = nullptr);\n\nnamespace internal {\nllvm::Expected<std::unique_ptr<ToolExecutor>>\ncreateExecutorFromCommandLineArgsImpl(int &argc, const char **argv,\n                                      llvm::cl::OptionCategory &Category,\n                                      const char *Overview = nullptr);\n} // end namespace internal\n\n} // end namespace tooling\n} // end namespace clang\n\n#endif // LLVM_CLANG_TOOLING_EXECUTION_H\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 284}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 284}, "message": "default constructor 'NamespaceInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "9bc165edee66df6ea0c31ddab5ff673e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 320}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 320}, "message": "default constructor 'FunctionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "e76cb37e858510e81289452cac2185f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 340}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 340}, "message": "default constructor 'RecordInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "b84f798b8fd224b37ddf4e6bbf61a1c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 374}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 374}, "message": "default constructor 'BaseRecordInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "dc41036f1bdc99a7d9f6dae86fa23e1b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 391}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 391}, "message": "default constructor 'EnumInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "8586d194742dca6bbb5fbeb492bc53eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 84}, "message": "default constructor 'SerializeTest_emitNamespaceInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "a9f39af1a4fbd7184e76e49875e2e2d7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 111}, "message": "default constructor 'SerializeTest_emitAnonymousNamespaceInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "f916717c8e7ef591236bf5e854bb2800", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 122}, "message": "default constructor 'SerializeTest_emitRecordInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "c74db0b47c7183442d59a13025fb8bac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 233}, "message": "default constructor 'SerializeTest_emitEnumInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "543c888c1030c6a1cd73f24d58aaca5c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 260}, "message": "default constructor 'SerializeTest_emitUndefinedRecordInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "072fa19abe0369f57108295ba968d76b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 273}, "message": "default constructor 'SerializeTest_emitRecordMemberInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "6756300e08a3aa60a61ffceb45a3f7d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 287}, "message": "default constructor 'SerializeTest_emitInternalRecordInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "f3cca287ce2ed5e4270d1ce402fe1e31", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 311}, "message": "default constructor 'SerializeTest_emitPublicAnonymousNamespaceInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "6ebc3d076fdc99cd9f37bf05584604bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 316}, "message": "default constructor 'SerializeTest_emitPublicFunctionInternalInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "0a92fe2b62cb0bc5d1aeb978cfe5808c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 332}, "message": "default constructor 'SerializeTest_emitInlinedFunctionInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "54dbe6be7f40f0fc8b4a42ab157f80a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 348}, "message": "default constructor 'SerializeTest_emitInheritedRecordInfo_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "75eb674ecfcdc699708f5d38a1696e4f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 483}, "message": "default constructor 'SerializeTest_emitModulePublicLFunctions_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "d4b90a085d6ce5725355bdb6454e40a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 518}, "message": "default constructor 'SerializeTest_emitChildRecords_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "5424f38e3d07326cf8164fa9c80502cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 2, "line": 2187}, "message": "expanded from macro 'TEST'"}, {"location": {"col": 3, "file": 2, "line": 2181}, "message": "expanded from macro 'GTEST_TEST'"}, {"location": {"col": 3, "file": 3, "line": 1217}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 3, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 1, "line": 545}, "message": "default constructor 'SerializeTest_emitChildNamespaces_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/unittests/clang-doc/SerializeTest.cpp", "reportHash": "88715e54fec30e5d2f1b69ab51d8cc8e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 248}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 9, "line": 248}, "message": "default constructor 'ParamIdx' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Attr.h", "reportHash": "b3626e41b1064f4b2f0f440ba1e352d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 12, "line": 425}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 12, "line": 425}, "message": "default constructor 'Attribute' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "43caad4634f669b29999679dc55012d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 12, "line": 602}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 12, "line": 602}, "message": "default constructor 'Argument' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "b14ebf1dc670c6fbc97a433018038aaa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 47}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 47}, "message": "default constructor 'OMPDeclarativeDirective<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclOpenMP.h", "reportHash": "f38d18b03f50acc32e7f558fa8a363a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 115}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 115}, "message": "default constructor 'OMPThreadPrivateDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclOpenMP.h", "reportHash": "c1064b833e5414095f410654daec64bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 278}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 21, "line": 278}, "message": "default constructor 'ReturnTypeRequirement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprConcepts.h", "reportHash": "7932a30539efa6da4a96406bd3332484", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 294}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 294}, "message": "default constructor 'OMPAllocatorClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "ab494513c311ffac9e95044837d6e404", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 484}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 484}, "message": "default constructor 'OMPIfClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "644525e2571c79aa39eaf702051c6827", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 561}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 561}, "message": "default constructor 'OMPFinalClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "ca50cfc1cd5d301ca1b467d07d41232f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 632}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 632}, "message": "default constructor 'OMPNumThreadsClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "271db4c8fe2429c9b70559b775f7c267", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 700}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 700}, "message": "default constructor 'OMPSafelenClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "caaa6596996a5660445c36ad22619eb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 766}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 766}, "message": "default constructor 'OMPSimdlenClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "565d8b8265fc053b00c46ba4fd142f5e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 927}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 927}, "message": "default constructor 'OMPCollapseClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "982815a24db2d960d69bed309950ef77", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1002}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1002}, "message": "default constructor 'OMPDefaultClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "3bbc88f493c85bc3a83db0c10a2a27a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1084}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1084}, "message": "default constructor 'OMPProcBindClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "bad4f4039a8f29436bf7cbb615e03700", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1139}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1139}, "message": "default constructor 'OMPUnifiedAddressClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "3e9a1da7c03da6fb82ee7bd326d10903", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1182}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1182}, "message": "default constructor 'OMPUnifiedSharedMemoryClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "869903d12a15b4d4620b0a66deca3d44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1225}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1225}, "message": "default constructor 'OMPReverseOffloadClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "304bbd6f8b3f744c786cd3f27ffba442", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1268}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1268}, "message": "default constructor 'OMPDynamicAllocatorsClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "0ac65da264ce43339ff5967144752d87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1344}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1344}, "message": "default constructor 'OMPAtomicDefaultMemOrderClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "bcb4bf76c10b6d461f5d1e5585fe5520", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 1508}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 1508}, "message": "default constructor 'OMPScheduleClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "c8ba94fbcdfff5c8ff8d3b28458651a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1687}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1687}, "message": "default constructor 'OMPNowaitClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "7e765474e5b43228c68b7a8e1fec87e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1726}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1726}, "message": "default constructor 'OMPUntiedClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "72252725b644e77e86d75d86d6411676", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1766}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1766}, "message": "default constructor 'OMPMergeableClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "1705414c65d8b12012f9fc14f9fcf6d3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1806}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1806}, "message": "default constructor 'OMPReadClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "1c0a2740d702ae51e83173fbb0ff2eb5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 1845}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 1845}, "message": "default constructor 'OMPWriteClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "0ee55c17f0e981a4532074124dcf7292", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 2020}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 2020}, "message": "default constructor 'OMPCaptureClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "58878102d187ce99471e982a739099c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 2061}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 2061}, "message": "default constructor 'OMPSeqCstClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "b691257d3b2fe2c3e659d8cb5cb049b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 2102}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 2102}, "message": "default constructor 'OMPAcqRelClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "a145e89ff5cd9702aae876c5b659db03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 2143}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 2143}, "message": "default constructor 'OMPAcquireClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "fe2e323baa90d9e8127f6f0ba58a27f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 2184}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 2184}, "message": "default constructor 'OMPReleaseClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "10650993669d9cd2d45b379d44a8bb4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 2225}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 2225}, "message": "default constructor 'OMPRelaxedClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "06354dc02375b43e93aebdebcc664169", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 4455}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 4455}, "message": "default constructor 'OMPDepobjClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "1c3bff030748d573fda527f2c9711e10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 4706}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 4706}, "message": "default constructor 'OMPDeviceClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "f193d902d22ab37ac93a8b91a81d7247", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 4762}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 4762}, "message": "default constructor 'OMPThreadsClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "52ec151678566d121d41c1fbcf3b1135", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 4802}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 4802}, "message": "default constructor 'OMPSIMDClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "9d185762f492caba8da1c53333dc59a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 5760}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 5760}, "message": "default constructor 'OMPNumTeamsClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "ca5c4c87b599913ec13bcd1e66f8634a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 5837}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 5837}, "message": "default constructor 'OMPThreadLimitClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "f4afb26f8051309d34831db6a8185f51", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 5913}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 5913}, "message": "default constructor 'OMPPriorityClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "f53435451351b0da171041e13682b3de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 5984}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 5984}, "message": "default constructor 'OMPGrainsizeClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "f4087137832721f32e195bf63e78df08", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 6031}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 6031}, "message": "default constructor 'OMPNogroupClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "e2680b4ff3685e2349c1ae1b812389ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 6093}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 6093}, "message": "default constructor 'OMPNumTasksClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "780700123c64db977445c7d0e0ec0bb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 6156}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 6156}, "message": "default constructor 'OMPHintClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "c981dcfa5372629bc96b5e16f0b54aaf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 6261}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 6261}, "message": "default constructor 'OMPDistScheduleClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "4bbcd52b0c1cc8b902e0ab661ddeaca7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 24, "line": 6377}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 24, "line": 6377}, "message": "default constructor 'OMPDefaultmapClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "1e36b7640ab515c1f326f1f50597a79f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 7334}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 7334}, "message": "default constructor 'OMPOrderClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "5ed6d7a1cafb4250cfa133bc8aaaad43", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 7386}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 7386}, "message": "default constructor 'OMPDestroyClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "8b8a12b43d70991bd92ee9f5789d68c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 7445}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 7445}, "message": "default constructor 'OMPDetachClause' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "99e256cf55b10576f0d0bce5d391aa47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 7930}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 7930}, "message": "default constructor 'OMPTraitInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "3c542e27d5bdb429819f151b841bb6ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 8026}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 8026}, "message": "default constructor 'OMPChildren' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "00aeeda6b78ce3f0abaf7e999bf4797e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 159}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 159}, "message": "default constructor 'OMPCanonicalLoop' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "aba03389cf407ea3b9b4fe821c39b6bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 623}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 623}, "message": "default constructor 'OMPParallelDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "3cb91ebdc01f9092c07988bdcc1f031f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 1703}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 1703}, "message": "default constructor 'OMPSectionsDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "5fa4be21225da8bc70b49a5b2190f45b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 1780}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 1780}, "message": "default constructor 'OMPSectionDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "9f24aca1fbeef8464cdc0b7f256162dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 1838}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 1838}, "message": "default constructor 'OMPSingleDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "5c6e6db4f9ace3831f68c676c7cdeb2a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 1889}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 1889}, "message": "default constructor 'OMPMasterDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "79164c5b8f9ad8988d9215c8a7665c3f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 1942}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 1942}, "message": "default constructor 'OMPCriticalDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "afe3c07302adae1883ce3deaf3e298fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2165}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2165}, "message": "default constructor 'OMPParallelMasterDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "98dc41506eba929c608d64b06474fd50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2239}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2239}, "message": "default constructor 'OMPParallelSectionsDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "c4ccdd27f1493b44d958e32c3a0c3305", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2318}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2318}, "message": "default constructor 'OMPTaskDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "b7bf80a49bbfeb52f94512b1e2c21949", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2377}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2377}, "message": "default constructor 'OMPTaskyieldDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "8ad4ccd3481cf8c9de162eb2c74e4952", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2423}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2423}, "message": "default constructor 'OMPBarrierDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "1e5270729ecaa68d0c86b8433ff6c4e7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2469}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2469}, "message": "default constructor 'OMPTaskwaitDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "0779ae0ecc9bede54f5510f6afaa941b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2515}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2515}, "message": "default constructor 'OMPTaskgroupDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "516cc6fc19d7a823902f7f3c44e7dde0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2582}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2582}, "message": "default constructor 'OMPFlushDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "720e7361124911eb7c8a197975646691", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2635}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2635}, "message": "default constructor 'OMPDepobjDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "9bb000e880f8bb834b3dd8bb1eedf226", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2686}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2686}, "message": "default constructor 'OMPOrderedDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "92944ada20f1f3952f5a06b114d726b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2760}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2760}, "message": "default constructor 'OMPAtomicDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "e4c33139436d4e94d49e4f6751520e7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2866}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2866}, "message": "default constructor 'OMPTargetDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "3e51b3d64984222c40606bce90404e9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2920}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2920}, "message": "default constructor 'OMPTargetDataDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "5dbf099f58869620849b70f42818d398", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 2975}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 2975}, "message": "default constructor 'OMPTargetEnterDataDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "e788d90bdc48d53e2993c73a0cfa1492", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 3030}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 3030}, "message": "default constructor 'OMPTargetExitDataDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "eccbf2f104820b76687da4074b7628e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 3087}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 3087}, "message": "default constructor 'OMPTargetParallelDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "9c3a98969273bb67bdf8ba6a6bddeb26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 3258}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 3258}, "message": "default constructor 'OMPTeamsDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "e853fde98f304af1da953ea2c1946ffa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 3313}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 3313}, "message": "default constructor 'OMPCancellationPointDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "d7549774248e3ab046f30365a6cff9ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 3370}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 3370}, "message": "default constructor 'OMPCancelDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "1dc9798826c6ffe7d64672bb008600a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 3920}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 3920}, "message": "default constructor 'OMPTargetUpdateDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "cbfdc76f93ddea5a857e04c30a033472", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 4628}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 4628}, "message": "default constructor 'OMPTargetTeamsDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "b9a7e2ddf99c16e0a4741b4d60aca30b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 29, "line": 5058}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 29, "line": 5058}, "message": "default constructor 'OMPScanDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "7732f922d29fb427347a0c8e7b5f9a0a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 45, "line": 24}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 45, "line": 24}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "reportHash": "500e701cbc014e9076ebc966d7e53d2b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 60, "line": 61}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 60, "line": 61}, "message": "default constructor 'InMemoryToolResults' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Execution.h", "reportHash": "43e79ad25134aeeb4613a494381adb96", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
