<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp", "content": "//===- CompilerInvocation.cpp ---------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Frontend/CompilerInvocation.h\"\n#include \"TestModuleFileExtension.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/CommentOptions.h\"\n#include \"clang/Basic/DebugInfoOptions.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticDriver.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Basic/ObjCRuntime.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/TargetOptions.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"clang/Basic/XRayInstr.h\"\n#include \"clang/Config/config.h\"\n#include \"clang/Driver/Driver.h\"\n#include \"clang/Driver/DriverDiagnostic.h\"\n#include \"clang/Driver/Options.h\"\n#include \"clang/Frontend/CommandLineSourceLoc.h\"\n#include \"clang/Frontend/DependencyOutputOptions.h\"\n#include \"clang/Frontend/FrontendDiagnostic.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n#include \"clang/Frontend/MigratorOptions.h\"\n#include \"clang/Frontend/PreprocessorOutputOptions.h\"\n#include \"clang/Frontend/TextDiagnosticBuffer.h\"\n#include \"clang/Frontend/Utils.h\"\n#include \"clang/Lex/HeaderSearchOptions.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/Linker/Linker.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n#include \"llvm/Option/Arg.h\"\n#include \"llvm/Option/ArgList.h\"\n#include \"llvm/Option/OptSpecifier.h\"\n#include \"llvm/Option/OptTable.h\"\n#include \"llvm/Option/Option.h\"\n#include \"llvm/ProfileData/InstrProfReader.h\"\n#include \"llvm/Remarks/HotnessThresholdParser.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Host.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Process.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <algorithm>\n#include <atomic>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\nusing namespace driver;\nusing namespace options;\nusing namespace llvm::opt;\n\n//===----------------------------------------------------------------------===//\n// Initialization.\n//===----------------------------------------------------------------------===//\n\nCompilerInvocationBase::CompilerInvocationBase()\n    : LangOpts(new LangOptions()), TargetOpts(new TargetOptions()),\n      DiagnosticOpts(new DiagnosticOptions()),\n      HeaderSearchOpts(new HeaderSearchOptions()),\n      PreprocessorOpts(new PreprocessorOptions()) {}\n\nCompilerInvocationBase::CompilerInvocationBase(const CompilerInvocationBase &X)\n    : LangOpts(new LangOptions(*X.getLangOpts())),\n      TargetOpts(new TargetOptions(X.getTargetOpts())),\n      DiagnosticOpts(new DiagnosticOptions(X.getDiagnosticOpts())),\n      HeaderSearchOpts(new HeaderSearchOptions(X.getHeaderSearchOpts())),\n      PreprocessorOpts(new PreprocessorOptions(X.getPreprocessorOpts())) {}\n\nCompilerInvocationBase::~CompilerInvocationBase() = default;\n\n//===----------------------------------------------------------------------===//\n// Normalizers\n//===----------------------------------------------------------------------===//\n\n#define SIMPLE_ENUM_VALUE_TABLE\n#include \"clang/Driver/Options.inc\"\n#undef SIMPLE_ENUM_VALUE_TABLE\n\nstatic llvm::Optional<bool>\nnormalizeSimpleFlag(OptSpecifier Opt, unsigned TableIndex, const ArgList &Args,\n                    DiagnosticsEngine &Diags, bool &Success) {\n  if (Args.hasArg(Opt))\n    return true;\n  return None;\n}\n\nstatic Optional<bool> normalizeSimpleNegativeFlag(OptSpecifier Opt, unsigned,\n                                                  const ArgList &Args,\n                                                  DiagnosticsEngine &,\n                                                  bool &Success) {\n  if (Args.hasArg(Opt))\n    return false;\n  return None;\n}\n\n/// The tblgen-erated code passes in a fifth parameter of an arbitrary type, but\n/// denormalizeSimpleFlags never looks at it. Avoid bloating compile-time with\n/// unnecessary template instantiations and just ignore it with a variadic\n/// argument.\nstatic void denormalizeSimpleFlag(SmallVectorImpl<const char *> &Args,\n                                  const char *Spelling,\n                                  CompilerInvocation::StringAllocator,\n                                  Option::OptionClass, unsigned, /*T*/...) {\n  Args.push_back(Spelling);\n}\n\ntemplate <typename T> static constexpr bool is_uint64_t_convertible() {\n  return !std::is_same<T, uint64_t>::value &&\n         llvm::is_integral_or_enum<T>::value;\n}\n\ntemplate <typename T,\n          std::enable_if_t<!is_uint64_t_convertible<T>(), bool> = false>\nstatic auto makeFlagToValueNormalizer(T Value) {\n  return [Value](OptSpecifier Opt, unsigned, const ArgList &Args,\n                 DiagnosticsEngine &, bool &Success) -> Optional<T> {\n    if (Args.hasArg(Opt))\n      return Value;\n    return None;\n  };\n}\n\ntemplate <typename T,\n          std::enable_if_t<is_uint64_t_convertible<T>(), bool> = false>\nstatic auto makeFlagToValueNormalizer(T Value) {\n  return makeFlagToValueNormalizer(uint64_t(Value));\n}\n\nstatic auto makeBooleanOptionNormalizer(bool Value, bool OtherValue,\n                                        OptSpecifier OtherOpt) {\n  return [Value, OtherValue, OtherOpt](OptSpecifier Opt, unsigned,\n                                       const ArgList &Args, DiagnosticsEngine &,\n                                       bool &Success) -> Optional<bool> {\n    if (const Arg *A = Args.getLastArg(Opt, OtherOpt)) {\n      return A->getOption().matches(Opt) ? Value : OtherValue;\n    }\n    return None;\n  };\n}\n\nstatic auto makeBooleanOptionDenormalizer(bool Value) {\n  return [Value](SmallVectorImpl<const char *> &Args, const char *Spelling,\n                 CompilerInvocation::StringAllocator, Option::OptionClass,\n                 unsigned, bool KeyPath) {\n    if (KeyPath == Value)\n      Args.push_back(Spelling);\n  };\n}\n\nstatic void denormalizeStringImpl(SmallVectorImpl<const char *> &Args,\n                                  const char *Spelling,\n                                  CompilerInvocation::StringAllocator SA,\n                                  Option::OptionClass OptClass, unsigned,\n                                  const Twine &Value) {\n  switch (OptClass) {\n  case Option::SeparateClass:\n  case Option::JoinedOrSeparateClass:\n    Args.push_back(Spelling);\n    Args.push_back(SA(Value));\n    break;\n  case Option::JoinedClass:\n  case Option::CommaJoinedClass:\n    Args.push_back(SA(Twine(Spelling) + Value));\n    break;\n  default:\n    llvm_unreachable(\"Cannot denormalize an option with option class \"\n                     \"incompatible with string denormalization.\");\n  }\n}\n\ntemplate <typename T>\nstatic void\ndenormalizeString(SmallVectorImpl<const char *> &Args, const char *Spelling,\n                  CompilerInvocation::StringAllocator SA,\n                  Option::OptionClass OptClass, unsigned TableIndex, T Value) {\n  denormalizeStringImpl(Args, Spelling, SA, OptClass, TableIndex, Twine(Value));\n}\n\nstatic Optional<SimpleEnumValue>\nfindValueTableByName(const SimpleEnumValueTable &Table, StringRef Name) {\n  for (int I = 0, E = Table.Size; I != E; ++I)\n    if (Name == Table.Table[I].Name)\n      return Table.Table[I];\n\n  return None;\n}\n\nstatic Optional<SimpleEnumValue>\nfindValueTableByValue(const SimpleEnumValueTable &Table, unsigned Value) {\n  for (int I = 0, E = Table.Size; I != E; ++I)\n    if (Value == Table.Table[I].Value)\n      return Table.Table[I];\n\n  return None;\n}\n\nstatic llvm::Optional<unsigned>\nnormalizeSimpleEnum(OptSpecifier Opt, unsigned TableIndex, const ArgList &Args,\n                    DiagnosticsEngine &Diags, bool &Success) {\n  assert(TableIndex < SimpleEnumValueTablesSize);\n  const SimpleEnumValueTable &Table = SimpleEnumValueTables[TableIndex];\n\n  auto *Arg = Args.getLastArg(Opt);\n  if (!Arg)\n    return None;\n\n  StringRef ArgValue = Arg->getValue();\n  if (auto MaybeEnumVal = findValueTableByName(Table, ArgValue))\n    return MaybeEnumVal->Value;\n\n  Success = false;\n  Diags.Report(diag::err_drv_invalid_value)\n      << Arg->getAsString(Args) << ArgValue;\n  return None;\n}\n\nstatic void denormalizeSimpleEnumImpl(SmallVectorImpl<const char *> &Args,\n                                      const char *Spelling,\n                                      CompilerInvocation::StringAllocator SA,\n                                      Option::OptionClass OptClass,\n                                      unsigned TableIndex, unsigned Value) {\n  assert(TableIndex < SimpleEnumValueTablesSize);\n  const SimpleEnumValueTable &Table = SimpleEnumValueTables[TableIndex];\n  if (auto MaybeEnumVal = findValueTableByValue(Table, Value)) {\n    denormalizeString(Args, Spelling, SA, OptClass, TableIndex,\n                      MaybeEnumVal->Name);\n  } else {\n    llvm_unreachable(\"The simple enum value was not correctly defined in \"\n                     \"the tablegen option description\");\n  }\n}\n\ntemplate <typename T>\nstatic void denormalizeSimpleEnum(SmallVectorImpl<const char *> &Args,\n                                  const char *Spelling,\n                                  CompilerInvocation::StringAllocator SA,\n                                  Option::OptionClass OptClass,\n                                  unsigned TableIndex, T Value) {\n  return denormalizeSimpleEnumImpl(Args, Spelling, SA, OptClass, TableIndex,\n                                   static_cast<unsigned>(Value));\n}\n\nstatic Optional<std::string> normalizeString(OptSpecifier Opt, int TableIndex,\n                                             const ArgList &Args,\n                                             DiagnosticsEngine &Diags,\n                                             bool &Success) {\n  auto *Arg = Args.getLastArg(Opt);\n  if (!Arg)\n    return None;\n  return std::string(Arg->getValue());\n}\n\ntemplate <typename IntTy>\nstatic Optional<IntTy>\nnormalizeStringIntegral(OptSpecifier Opt, int, const ArgList &Args,\n                        DiagnosticsEngine &Diags, bool &Success) {\n  auto *Arg = Args.getLastArg(Opt);\n  if (!Arg)\n    return None;\n  IntTy Res;\n  if (StringRef(Arg->getValue()).getAsInteger(0, Res)) {\n    Success = false;\n    Diags.Report(diag::err_drv_invalid_int_value)\n        << Arg->getAsString(Args) << Arg->getValue();\n    return None;\n  }\n  return Res;\n}\n\nstatic Optional<std::vector<std::string>>\nnormalizeStringVector(OptSpecifier Opt, int, const ArgList &Args,\n                      DiagnosticsEngine &, bool &Success) {\n  return Args.getAllArgValues(Opt);\n}\n\nstatic void denormalizeStringVector(SmallVectorImpl<const char *> &Args,\n                                    const char *Spelling,\n                                    CompilerInvocation::StringAllocator SA,\n                                    Option::OptionClass OptClass,\n                                    unsigned TableIndex,\n                                    const std::vector<std::string> &Values) {\n  switch (OptClass) {\n  case Option::CommaJoinedClass: {\n    std::string CommaJoinedValue;\n    if (!Values.empty()) {\n      CommaJoinedValue.append(Values.front());\n      for (const std::string &Value : llvm::drop_begin(Values, 1)) {\n        CommaJoinedValue.append(\",\");\n        CommaJoinedValue.append(Value);\n      }\n    }\n    denormalizeString(Args, Spelling, SA, Option::OptionClass::JoinedClass,\n                      TableIndex, CommaJoinedValue);\n    break;\n  }\n  case Option::JoinedClass:\n  case Option::SeparateClass:\n  case Option::JoinedOrSeparateClass:\n    for (const std::string &Value : Values)\n      denormalizeString(Args, Spelling, SA, OptClass, TableIndex, Value);\n    break;\n  default:\n    llvm_unreachable(\"Cannot denormalize an option with option class \"\n                     \"incompatible with string vector denormalization.\");\n  }\n}\n\nstatic Optional<std::string> normalizeTriple(OptSpecifier Opt, int TableIndex,\n                                             const ArgList &Args,\n                                             DiagnosticsEngine &Diags,\n                                             bool &Success) {\n  auto *Arg = Args.getLastArg(Opt);\n  if (!Arg)\n    return None;\n  return llvm::Triple::normalize(Arg->getValue());\n}\n\ntemplate <typename T, typename U>\nstatic T mergeForwardValue(T KeyPath, U Value) {\n  return static_cast<T>(Value);\n}\n\ntemplate <typename T, typename U> static T mergeMaskValue(T KeyPath, U Value) {\n  return KeyPath | Value;\n}\n\ntemplate <typename T> static T extractForwardValue(T KeyPath) {\n  return KeyPath;\n}\n\ntemplate <typename T, typename U, U Value>\nstatic T extractMaskValue(T KeyPath) {\n  return ((KeyPath & Value) == Value) ? static_cast<T>(Value) : T();\n}\n\n#define PARSE_OPTION_WITH_MARSHALLING(ARGS, DIAGS, SUCCESS, ID, FLAGS, PARAM,  \\\n                                      SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,    \\\n                                      IMPLIED_CHECK, IMPLIED_VALUE,            \\\n                                      NORMALIZER, MERGER, TABLE_INDEX)         \\\n  if ((FLAGS)&options::CC1Option) {                                            \\\n    KEYPATH = MERGER(KEYPATH, DEFAULT_VALUE);                                  \\\n    if (IMPLIED_CHECK)                                                         \\\n      KEYPATH = MERGER(KEYPATH, IMPLIED_VALUE);                                \\\n    if (SHOULD_PARSE)                                                          \\\n      if (auto MaybeValue =                                                    \\\n              NORMALIZER(OPT_##ID, TABLE_INDEX, ARGS, DIAGS, SUCCESS))         \\\n        KEYPATH =                                                              \\\n            MERGER(KEYPATH, static_cast<decltype(KEYPATH)>(*MaybeValue));      \\\n  }\n\n// Capture the extracted value as a lambda argument to avoid potential issues\n// with lifetime extension of the reference.\n#define GENERATE_OPTION_WITH_MARSHALLING(                                      \\\n    ARGS, STRING_ALLOCATOR, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH,       \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR,      \\\n    TABLE_INDEX)                                                               \\\n  if ((FLAGS)&options::CC1Option) {                                            \\\n    [&](const auto &Extracted) {                                               \\\n      if (ALWAYS_EMIT ||                                                       \\\n          (Extracted !=                                                        \\\n           static_cast<decltype(KEYPATH)>((IMPLIED_CHECK) ? (IMPLIED_VALUE)    \\\n                                                          : (DEFAULT_VALUE)))) \\\n        DENORMALIZER(ARGS, SPELLING, STRING_ALLOCATOR, Option::KIND##Class,    \\\n                     TABLE_INDEX, Extracted);                                  \\\n    }(EXTRACTOR(KEYPATH));                                                     \\\n  }\n\nstatic const StringRef GetInputKindName(InputKind IK);\n\nstatic bool FixupInvocation(CompilerInvocation &Invocation,\n                            DiagnosticsEngine &Diags, const ArgList &Args,\n                            InputKind IK) {\n  unsigned NumErrorsBefore = Diags.getNumErrors();\n\n  LangOptions &LangOpts = *Invocation.getLangOpts();\n  CodeGenOptions &CodeGenOpts = Invocation.getCodeGenOpts();\n  TargetOptions &TargetOpts = Invocation.getTargetOpts();\n  FrontendOptions &FrontendOpts = Invocation.getFrontendOpts();\n  CodeGenOpts.XRayInstrumentFunctions = LangOpts.XRayInstrument;\n  CodeGenOpts.XRayAlwaysEmitCustomEvents = LangOpts.XRayAlwaysEmitCustomEvents;\n  CodeGenOpts.XRayAlwaysEmitTypedEvents = LangOpts.XRayAlwaysEmitTypedEvents;\n  CodeGenOpts.DisableFree = FrontendOpts.DisableFree;\n  FrontendOpts.GenerateGlobalModuleIndex = FrontendOpts.UseGlobalModuleIndex;\n\n  LangOpts.ForceEmitVTables = CodeGenOpts.ForceEmitVTables;\n  LangOpts.SpeculativeLoadHardening = CodeGenOpts.SpeculativeLoadHardening;\n  LangOpts.CurrentModule = LangOpts.ModuleName;\n\n  llvm::Triple T(TargetOpts.Triple);\n  llvm::Triple::ArchType Arch = T.getArch();\n\n  CodeGenOpts.CodeModel = TargetOpts.CodeModel;\n\n  if (LangOpts.getExceptionHandling() != llvm::ExceptionHandling::None &&\n      T.isWindowsMSVCEnvironment())\n    Diags.Report(diag::err_fe_invalid_exception_model)\n        << static_cast<unsigned>(LangOpts.getExceptionHandling()) << T.str();\n\n  if (LangOpts.AppleKext && !LangOpts.CPlusPlus)\n    Diags.Report(diag::warn_c_kext);\n\n  if (Args.hasArg(OPT_fconcepts_ts))\n    Diags.Report(diag::warn_fe_concepts_ts_flag);\n\n  if (LangOpts.NewAlignOverride &&\n      !llvm::isPowerOf2_32(LangOpts.NewAlignOverride)) {\n    Arg *A = Args.getLastArg(OPT_fnew_alignment_EQ);\n    Diags.Report(diag::err_fe_invalid_alignment)\n        << A->getAsString(Args) << A->getValue();\n    LangOpts.NewAlignOverride = 0;\n  }\n\n  if (Args.hasArg(OPT_fgnu89_inline) && LangOpts.CPlusPlus)\n    Diags.Report(diag::err_drv_argument_not_allowed_with)\n        << \"-fgnu89-inline\" << GetInputKindName(IK);\n\n  if (Args.hasArg(OPT_fgpu_allow_device_init) && !LangOpts.HIP)\n    Diags.Report(diag::warn_ignored_hip_only_option)\n        << Args.getLastArg(OPT_fgpu_allow_device_init)->getAsString(Args);\n\n  if (Args.hasArg(OPT_gpu_max_threads_per_block_EQ) && !LangOpts.HIP)\n    Diags.Report(diag::warn_ignored_hip_only_option)\n        << Args.getLastArg(OPT_gpu_max_threads_per_block_EQ)->getAsString(Args);\n\n  // -cl-strict-aliasing needs to emit diagnostic in the case where CL > 1.0.\n  // This option should be deprecated for CL > 1.0 because\n  // this option was added for compatibility with OpenCL 1.0.\n  if (Args.getLastArg(OPT_cl_strict_aliasing) && LangOpts.OpenCLVersion > 100)\n    Diags.Report(diag::warn_option_invalid_ocl_version)\n        << LangOpts.getOpenCLVersionTuple().getAsString()\n        << Args.getLastArg(OPT_cl_strict_aliasing)->getAsString(Args);\n\n  if (Arg *A = Args.getLastArg(OPT_fdefault_calling_conv_EQ)) {\n    auto DefaultCC = LangOpts.getDefaultCallingConv();\n\n    bool emitError = (DefaultCC == LangOptions::DCC_FastCall ||\n                      DefaultCC == LangOptions::DCC_StdCall) &&\n                     Arch != llvm::Triple::x86;\n    emitError |= (DefaultCC == LangOptions::DCC_VectorCall ||\n                  DefaultCC == LangOptions::DCC_RegCall) &&\n                 !T.isX86();\n    if (emitError)\n      Diags.Report(diag::err_drv_argument_not_allowed_with)\n          << A->getSpelling() << T.getTriple();\n  }\n\n  if (!CodeGenOpts.ProfileRemappingFile.empty() && CodeGenOpts.LegacyPassManager)\n    Diags.Report(diag::err_drv_argument_only_allowed_with)\n        << Args.getLastArg(OPT_fprofile_remapping_file_EQ)->getAsString(Args)\n        << \"-fno-legacy-pass-manager\";\n\n  return Diags.getNumErrors() == NumErrorsBefore;\n}\n\n//===----------------------------------------------------------------------===//\n// Deserialization (from args)\n//===----------------------------------------------------------------------===//\n\nstatic unsigned getOptimizationLevel(ArgList &Args, InputKind IK,\n                                     DiagnosticsEngine &Diags) {\n  unsigned DefaultOpt = llvm::CodeGenOpt::None;\n  if (IK.getLanguage() == Language::OpenCL && !Args.hasArg(OPT_cl_opt_disable))\n    DefaultOpt = llvm::CodeGenOpt::Default;\n\n  if (Arg *A = Args.getLastArg(options::OPT_O_Group)) {\n    if (A->getOption().matches(options::OPT_O0))\n      return llvm::CodeGenOpt::None;\n\n    if (A->getOption().matches(options::OPT_Ofast))\n      return llvm::CodeGenOpt::Aggressive;\n\n    assert(A->getOption().matches(options::OPT_O));\n\n    StringRef S(A->getValue());\n    if (S == \"s\" || S == \"z\")\n      return llvm::CodeGenOpt::Default;\n\n    if (S == \"g\")\n      return llvm::CodeGenOpt::Less;\n\n    return getLastArgIntValue(Args, OPT_O, DefaultOpt, Diags);\n  }\n\n  return DefaultOpt;\n}\n\nstatic unsigned getOptimizationLevelSize(ArgList &Args) {\n  if (Arg *A = Args.getLastArg(options::OPT_O_Group)) {\n    if (A->getOption().matches(options::OPT_O)) {\n      switch (A->getValue()[0]) {\n      default:\n        return 0;\n      case 's':\n        return 1;\n      case 'z':\n        return 2;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic void GenerateArg(SmallVectorImpl<const char *> &Args,\n                        llvm::opt::OptSpecifier OptSpecifier,\n                        CompilerInvocation::StringAllocator SA) {\n  Option Opt = getDriverOptTable().getOption(OptSpecifier);\n  denormalizeSimpleFlag(Args, SA(Opt.getPrefix() + Opt.getName()), SA,\n                        Option::OptionClass::FlagClass, 0);\n}\n\nstatic void GenerateArg(SmallVectorImpl<const char *> &Args,\n                        llvm::opt::OptSpecifier OptSpecifier,\n                        const Twine &Value,\n                        CompilerInvocation::StringAllocator SA) {\n  Option Opt = getDriverOptTable().getOption(OptSpecifier);\n  denormalizeString(Args, SA(Opt.getPrefix() + Opt.getName()), SA,\n                    Opt.getKind(), 0, Value);\n}\n\n// Parse command line arguments into CompilerInvocation.\nusing ParseFn =\n    llvm::function_ref<bool(CompilerInvocation &, ArrayRef<const char *>,\n                            DiagnosticsEngine &, const char *)>;\n\n// Generate command line arguments from CompilerInvocation.\nusing GenerateFn = llvm::function_ref<void(\n    CompilerInvocation &, SmallVectorImpl<const char *> &,\n    CompilerInvocation::StringAllocator)>;\n\n// May perform round-trip of command line arguments. By default, the round-trip\n// is enabled if CLANG_ROUND_TRIP_CC1_ARGS was defined during build. This can be\n// overwritten at run-time via the \"-round-trip-args\" and \"-no-round-trip-args\"\n// command line flags.\n// During round-trip, the command line arguments are parsed into a dummy\n// instance of CompilerInvocation which is used to generate the command line\n// arguments again. The real CompilerInvocation instance is then created by\n// parsing the generated arguments, not the original ones.\nstatic bool RoundTrip(ParseFn Parse, GenerateFn Generate,\n                      CompilerInvocation &RealInvocation,\n                      CompilerInvocation &DummyInvocation,\n                      ArrayRef<const char *> CommandLineArgs,\n                      DiagnosticsEngine &Diags, const char *Argv0) {\n  // FIXME: Switch to '#ifndef NDEBUG' when possible.\n#ifdef CLANG_ROUND_TRIP_CC1_ARGS\n  bool DoRoundTripDefault = true;\n#else\n  bool DoRoundTripDefault = false;\n#endif\n\n  bool DoRoundTrip = DoRoundTripDefault;\n  for (const auto *Arg : CommandLineArgs) {\n    if (Arg == StringRef(\"-round-trip-args\"))\n      DoRoundTrip = true;\n    if (Arg == StringRef(\"-no-round-trip-args\"))\n      DoRoundTrip = false;\n  }\n\n  // If round-trip was not requested, simply run the parser with the real\n  // invocation diagnostics.\n  if (!DoRoundTrip)\n    return Parse(RealInvocation, CommandLineArgs, Diags, Argv0);\n\n  // Serializes quoted (and potentially escaped) arguments.\n  auto SerializeArgs = [](ArrayRef<const char *> Args) {\n    std::string Buffer;\n    llvm::raw_string_ostream OS(Buffer);\n    for (const char *Arg : Args) {\n      llvm::sys::printArg(OS, Arg, /*Quote=*/true);\n      OS << ' ';\n    }\n    OS.flush();\n    return Buffer;\n  };\n\n  // Setup a dummy DiagnosticsEngine.\n  DiagnosticsEngine DummyDiags(new DiagnosticIDs(), new DiagnosticOptions());\n  DummyDiags.setClient(new TextDiagnosticBuffer());\n\n  // Run the first parse on the original arguments with the dummy invocation and\n  // diagnostics.\n  if (!Parse(DummyInvocation, CommandLineArgs, DummyDiags, Argv0) ||\n      DummyDiags.getNumWarnings() != 0) {\n    // If the first parse did not succeed, it must be user mistake (invalid\n    // command line arguments). We won't be able to generate arguments that\n    // would reproduce the same result. Let's fail again with the real\n    // invocation and diagnostics, so all side-effects of parsing are visible.\n    unsigned NumWarningsBefore = Diags.getNumWarnings();\n    auto Success = Parse(RealInvocation, CommandLineArgs, Diags, Argv0);\n    if (!Success || Diags.getNumWarnings() != NumWarningsBefore)\n      return Success;\n\n    // Parse with original options and diagnostics succeeded even though it\n    // shouldn't have. Something is off.\n    Diags.Report(diag::err_cc1_round_trip_fail_then_ok);\n    Diags.Report(diag::note_cc1_round_trip_original)\n        << SerializeArgs(CommandLineArgs);\n    return false;\n  }\n\n  // Setup string allocator.\n  llvm::BumpPtrAllocator Alloc;\n  llvm::StringSaver StringPool(Alloc);\n  auto SA = [&StringPool](const Twine &Arg) {\n    return StringPool.save(Arg).data();\n  };\n\n  // Generate arguments from the dummy invocation. If Generate is the\n  // inverse of Parse, the newly generated arguments must have the same\n  // semantics as the original.\n  SmallVector<const char *, 16> GeneratedArgs1;\n  Generate(DummyInvocation, GeneratedArgs1, SA);\n\n  // Run the second parse, now on the generated arguments, and with the real\n  // invocation and diagnostics. The result is what we will end up using for the\n  // rest of compilation, so if Generate is not inverse of Parse, something down\n  // the line will break.\n  bool Success2 = Parse(RealInvocation, GeneratedArgs1, Diags, Argv0);\n\n  // The first parse on original arguments succeeded, but second parse of\n  // generated arguments failed. Something must be wrong with the generator.\n  if (!Success2) {\n    Diags.Report(diag::err_cc1_round_trip_ok_then_fail);\n    Diags.Report(diag::note_cc1_round_trip_generated)\n        << 1 << SerializeArgs(GeneratedArgs1);\n    return false;\n  }\n\n  // Generate arguments again, this time from the options we will end up using\n  // for the rest of the compilation.\n  SmallVector<const char *, 16> GeneratedArgs2;\n  Generate(RealInvocation, GeneratedArgs2, SA);\n\n  // Compares two lists of generated arguments.\n  auto Equal = [](const ArrayRef<const char *> A,\n                  const ArrayRef<const char *> B) {\n    return std::equal(A.begin(), A.end(), B.begin(), B.end(),\n                      [](const char *AElem, const char *BElem) {\n                        return StringRef(AElem) == StringRef(BElem);\n                      });\n  };\n\n  // If we generated different arguments from what we assume are two\n  // semantically equivalent CompilerInvocations, the Generate function may\n  // be non-deterministic.\n  if (!Equal(GeneratedArgs1, GeneratedArgs2)) {\n    Diags.Report(diag::err_cc1_round_trip_mismatch);\n    Diags.Report(diag::note_cc1_round_trip_generated)\n        << 1 << SerializeArgs(GeneratedArgs1);\n    Diags.Report(diag::note_cc1_round_trip_generated)\n        << 2 << SerializeArgs(GeneratedArgs2);\n    return false;\n  }\n\n  Diags.Report(diag::remark_cc1_round_trip_generated)\n      << 1 << SerializeArgs(GeneratedArgs1);\n  Diags.Report(diag::remark_cc1_round_trip_generated)\n      << 2 << SerializeArgs(GeneratedArgs2);\n\n  return Success2;\n}\n\nstatic void addDiagnosticArgs(ArgList &Args, OptSpecifier Group,\n                              OptSpecifier GroupWithValue,\n                              std::vector<std::string> &Diagnostics) {\n  for (auto *A : Args.filtered(Group)) {\n    if (A->getOption().getKind() == Option::FlagClass) {\n      // The argument is a pure flag (such as OPT_Wall or OPT_Wdeprecated). Add\n      // its name (minus the \"W\" or \"R\" at the beginning) to the diagnostics.\n      Diagnostics.push_back(\n          std::string(A->getOption().getName().drop_front(1)));\n    } else if (A->getOption().matches(GroupWithValue)) {\n      // This is -Wfoo= or -Rfoo=, where foo is the name of the diagnostic\n      // group. Add only the group name to the diagnostics.\n      Diagnostics.push_back(\n          std::string(A->getOption().getName().drop_front(1).rtrim(\"=-\")));\n    } else {\n      // Otherwise, add its value (for OPT_W_Joined and similar).\n      Diagnostics.push_back(A->getValue());\n    }\n  }\n}\n\n// Parse the Static Analyzer configuration. If \\p Diags is set to nullptr,\n// it won't verify the input.\nstatic void parseAnalyzerConfigs(AnalyzerOptions &AnOpts,\n                                 DiagnosticsEngine *Diags);\n\nstatic void getAllNoBuiltinFuncValues(ArgList &Args,\n                                      std::vector<std::string> &Funcs) {\n  std::vector<std::string> Values = Args.getAllArgValues(OPT_fno_builtin_);\n  auto BuiltinEnd = llvm::partition(Values, [](const std::string FuncName) {\n    return Builtin::Context::isBuiltinFunc(FuncName);\n  });\n  Funcs.insert(Funcs.end(), Values.begin(), BuiltinEnd);\n}\n\nstatic void GenerateAnalyzerArgs(AnalyzerOptions &Opts,\n                                 SmallVectorImpl<const char *> &Args,\n                                 CompilerInvocation::StringAllocator SA) {\n  const AnalyzerOptions *AnalyzerOpts = &Opts;\n\n#define ANALYZER_OPTION_WITH_MARSHALLING(                                      \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef ANALYZER_OPTION_WITH_MARSHALLING\n\n  if (Opts.AnalysisStoreOpt != RegionStoreModel) {\n    switch (Opts.AnalysisStoreOpt) {\n#define ANALYSIS_STORE(NAME, CMDFLAG, DESC, CREATFN)                           \\\n  case NAME##Model:                                                            \\\n    GenerateArg(Args, OPT_analyzer_store, CMDFLAG, SA);                        \\\n    break;\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n    default:\n      llvm_unreachable(\"Tried to generate unknown analysis store.\");\n    }\n  }\n\n  if (Opts.AnalysisConstraintsOpt != RangeConstraintsModel) {\n    switch (Opts.AnalysisConstraintsOpt) {\n#define ANALYSIS_CONSTRAINTS(NAME, CMDFLAG, DESC, CREATFN)                     \\\n  case NAME##Model:                                                            \\\n    GenerateArg(Args, OPT_analyzer_constraints, CMDFLAG, SA);                  \\\n    break;\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n    default:\n      llvm_unreachable(\"Tried to generate unknown analysis constraint.\");\n    }\n  }\n\n  if (Opts.AnalysisDiagOpt != PD_HTML) {\n    switch (Opts.AnalysisDiagOpt) {\n#define ANALYSIS_DIAGNOSTICS(NAME, CMDFLAG, DESC, CREATFN)                     \\\n  case PD_##NAME:                                                              \\\n    GenerateArg(Args, OPT_analyzer_output, CMDFLAG, SA);                       \\\n    break;\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n    default:\n      llvm_unreachable(\"Tried to generate unknown analysis diagnostic client.\");\n    }\n  }\n\n  if (Opts.AnalysisPurgeOpt != PurgeStmt) {\n    switch (Opts.AnalysisPurgeOpt) {\n#define ANALYSIS_PURGE(NAME, CMDFLAG, DESC)                                    \\\n  case NAME:                                                                   \\\n    GenerateArg(Args, OPT_analyzer_purge, CMDFLAG, SA);                        \\\n    break;\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n    default:\n      llvm_unreachable(\"Tried to generate unknown analysis purge mode.\");\n    }\n  }\n\n  if (Opts.InliningMode != NoRedundancy) {\n    switch (Opts.InliningMode) {\n#define ANALYSIS_INLINING_MODE(NAME, CMDFLAG, DESC)                            \\\n  case NAME:                                                                   \\\n    GenerateArg(Args, OPT_analyzer_inlining_mode, CMDFLAG, SA);                \\\n    break;\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n    default:\n      llvm_unreachable(\"Tried to generate unknown analysis inlining mode.\");\n    }\n  }\n\n  for (const auto &CP : Opts.CheckersAndPackages) {\n    OptSpecifier Opt =\n        CP.second ? OPT_analyzer_checker : OPT_analyzer_disable_checker;\n    GenerateArg(Args, Opt, CP.first, SA);\n  }\n\n  AnalyzerOptions ConfigOpts;\n  parseAnalyzerConfigs(ConfigOpts, nullptr);\n\n  for (const auto &C : Opts.Config) {\n    // Don't generate anything that came from parseAnalyzerConfigs. It would be\n    // redundant and may not be valid on the command line.\n    auto Entry = ConfigOpts.Config.find(C.getKey());\n    if (Entry != ConfigOpts.Config.end() && Entry->getValue() == C.getValue())\n      continue;\n\n    GenerateArg(Args, OPT_analyzer_config, C.getKey() + \"=\" + C.getValue(), SA);\n  }\n\n  // Nothing to generate for FullCompilerInvocation.\n}\n\nstatic bool ParseAnalyzerArgs(AnalyzerOptions &Opts, ArgList &Args,\n                              DiagnosticsEngine &Diags) {\n  AnalyzerOptions *AnalyzerOpts = &Opts;\n  bool Success = true;\n\n#define ANALYZER_OPTION_WITH_MARSHALLING(                                      \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef ANALYZER_OPTION_WITH_MARSHALLING\n\n  if (Arg *A = Args.getLastArg(OPT_analyzer_store)) {\n    StringRef Name = A->getValue();\n    AnalysisStores Value = llvm::StringSwitch<AnalysisStores>(Name)\n#define ANALYSIS_STORE(NAME, CMDFLAG, DESC, CREATFN) \\\n      .Case(CMDFLAG, NAME##Model)\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n      .Default(NumStores);\n    if (Value == NumStores) {\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << Name;\n      Success = false;\n    } else {\n      Opts.AnalysisStoreOpt = Value;\n    }\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_analyzer_constraints)) {\n    StringRef Name = A->getValue();\n    AnalysisConstraints Value = llvm::StringSwitch<AnalysisConstraints>(Name)\n#define ANALYSIS_CONSTRAINTS(NAME, CMDFLAG, DESC, CREATFN) \\\n      .Case(CMDFLAG, NAME##Model)\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n      .Default(NumConstraints);\n    if (Value == NumConstraints) {\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << Name;\n      Success = false;\n    } else {\n      Opts.AnalysisConstraintsOpt = Value;\n    }\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_analyzer_output)) {\n    StringRef Name = A->getValue();\n    AnalysisDiagClients Value = llvm::StringSwitch<AnalysisDiagClients>(Name)\n#define ANALYSIS_DIAGNOSTICS(NAME, CMDFLAG, DESC, CREATFN) \\\n      .Case(CMDFLAG, PD_##NAME)\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n      .Default(NUM_ANALYSIS_DIAG_CLIENTS);\n    if (Value == NUM_ANALYSIS_DIAG_CLIENTS) {\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << Name;\n      Success = false;\n    } else {\n      Opts.AnalysisDiagOpt = Value;\n    }\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_analyzer_purge)) {\n    StringRef Name = A->getValue();\n    AnalysisPurgeMode Value = llvm::StringSwitch<AnalysisPurgeMode>(Name)\n#define ANALYSIS_PURGE(NAME, CMDFLAG, DESC) \\\n      .Case(CMDFLAG, NAME)\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n      .Default(NumPurgeModes);\n    if (Value == NumPurgeModes) {\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << Name;\n      Success = false;\n    } else {\n      Opts.AnalysisPurgeOpt = Value;\n    }\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_analyzer_inlining_mode)) {\n    StringRef Name = A->getValue();\n    AnalysisInliningMode Value = llvm::StringSwitch<AnalysisInliningMode>(Name)\n#define ANALYSIS_INLINING_MODE(NAME, CMDFLAG, DESC) \\\n      .Case(CMDFLAG, NAME)\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\n      .Default(NumInliningModes);\n    if (Value == NumInliningModes) {\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << Name;\n      Success = false;\n    } else {\n      Opts.InliningMode = Value;\n    }\n  }\n\n  Opts.CheckersAndPackages.clear();\n  for (const Arg *A :\n       Args.filtered(OPT_analyzer_checker, OPT_analyzer_disable_checker)) {\n    A->claim();\n    bool IsEnabled = A->getOption().getID() == OPT_analyzer_checker;\n    // We can have a list of comma separated checker names, e.g:\n    // '-analyzer-checker=cocoa,unix'\n    StringRef CheckerAndPackageList = A->getValue();\n    SmallVector<StringRef, 16> CheckersAndPackages;\n    CheckerAndPackageList.split(CheckersAndPackages, \",\");\n    for (const StringRef &CheckerOrPackage : CheckersAndPackages)\n      Opts.CheckersAndPackages.emplace_back(std::string(CheckerOrPackage),\n                                            IsEnabled);\n  }\n\n  // Go through the analyzer configuration options.\n  for (const auto *A : Args.filtered(OPT_analyzer_config)) {\n\n    // We can have a list of comma separated config names, e.g:\n    // '-analyzer-config key1=val1,key2=val2'\n    StringRef configList = A->getValue();\n    SmallVector<StringRef, 4> configVals;\n    configList.split(configVals, \",\");\n    for (const auto &configVal : configVals) {\n      StringRef key, val;\n      std::tie(key, val) = configVal.split(\"=\");\n      if (val.empty()) {\n        Diags.Report(SourceLocation(),\n                     diag::err_analyzer_config_no_value) << configVal;\n        Success = false;\n        break;\n      }\n      if (val.find('=') != StringRef::npos) {\n        Diags.Report(SourceLocation(),\n                     diag::err_analyzer_config_multiple_values)\n          << configVal;\n        Success = false;\n        break;\n      }\n\n      // TODO: Check checker options too, possibly in CheckerRegistry.\n      // Leave unknown non-checker configs unclaimed.\n      if (!key.contains(\":\") && Opts.isUnknownAnalyzerConfig(key)) {\n        if (Opts.ShouldEmitErrorsOnInvalidConfigValue) {\n          Diags.Report(diag::err_analyzer_config_unknown) << key;\n          Success = false;\n        }\n        continue;\n      }\n\n      A->claim();\n      Opts.Config[key] = std::string(val);\n    }\n  }\n\n  if (Opts.ShouldEmitErrorsOnInvalidConfigValue)\n    parseAnalyzerConfigs(Opts, &Diags);\n  else\n    parseAnalyzerConfigs(Opts, nullptr);\n\n  llvm::raw_string_ostream os(Opts.FullCompilerInvocation);\n  for (unsigned i = 0; i < Args.getNumInputArgStrings(); ++i) {\n    if (i != 0)\n      os << \" \";\n    os << Args.getArgString(i);\n  }\n  os.flush();\n\n  return Success;\n}\n\nstatic StringRef getStringOption(AnalyzerOptions::ConfigTable &Config,\n                                 StringRef OptionName, StringRef DefaultVal) {\n  return Config.insert({OptionName, std::string(DefaultVal)}).first->second;\n}\n\nstatic void initOption(AnalyzerOptions::ConfigTable &Config,\n                       DiagnosticsEngine *Diags,\n                       StringRef &OptionField, StringRef Name,\n                       StringRef DefaultVal) {\n  // String options may be known to invalid (e.g. if the expected string is a\n  // file name, but the file does not exist), those will have to be checked in\n  // parseConfigs.\n  OptionField = getStringOption(Config, Name, DefaultVal);\n}\n\nstatic void initOption(AnalyzerOptions::ConfigTable &Config,\n                       DiagnosticsEngine *Diags,\n                       bool &OptionField, StringRef Name, bool DefaultVal) {\n  auto PossiblyInvalidVal = llvm::StringSwitch<Optional<bool>>(\n                 getStringOption(Config, Name, (DefaultVal ? \"true\" : \"false\")))\n      .Case(\"true\", true)\n      .Case(\"false\", false)\n      .Default(None);\n\n  if (!PossiblyInvalidVal) {\n    if (Diags)\n      Diags->Report(diag::err_analyzer_config_invalid_input)\n        << Name << \"a boolean\";\n    else\n      OptionField = DefaultVal;\n  } else\n    OptionField = PossiblyInvalidVal.getValue();\n}\n\nstatic void initOption(AnalyzerOptions::ConfigTable &Config,\n                       DiagnosticsEngine *Diags,\n                       unsigned &OptionField, StringRef Name,\n                       unsigned DefaultVal) {\n\n  OptionField = DefaultVal;\n  bool HasFailed = getStringOption(Config, Name, std::to_string(DefaultVal))\n                     .getAsInteger(0, OptionField);\n  if (Diags && HasFailed)\n    Diags->Report(diag::err_analyzer_config_invalid_input)\n      << Name << \"an unsigned\";\n}\n\nstatic void parseAnalyzerConfigs(AnalyzerOptions &AnOpts,\n                                 DiagnosticsEngine *Diags) {\n  // TODO: There's no need to store the entire configtable, it'd be plenty\n  // enough tostore checker options.\n\n#define ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, DEFAULT_VAL)                \\\n  initOption(AnOpts.Config, Diags, AnOpts.NAME, CMDFLAG, DEFAULT_VAL);\n\n#define ANALYZER_OPTION_DEPENDS_ON_USER_MODE(TYPE, NAME, CMDFLAG, DESC,        \\\n                                           SHALLOW_VAL, DEEP_VAL)              \\\n  switch (AnOpts.getUserMode()) {                                              \\\n  case UMK_Shallow:                                                            \\\n    initOption(AnOpts.Config, Diags, AnOpts.NAME, CMDFLAG, SHALLOW_VAL);       \\\n    break;                                                                     \\\n  case UMK_Deep:                                                               \\\n    initOption(AnOpts.Config, Diags, AnOpts.NAME, CMDFLAG, DEEP_VAL);          \\\n    break;                                                                     \\\n  }                                                                            \\\n\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.def\"\n#undef ANALYZER_OPTION\n#undef ANALYZER_OPTION_DEPENDS_ON_USER_MODE\n\n  // At this point, AnalyzerOptions is configured. Let's validate some options.\n\n  // FIXME: Here we try to validate the silenced checkers or packages are valid.\n  // The current approach only validates the registered checkers which does not\n  // contain the runtime enabled checkers and optimally we would validate both.\n  if (!AnOpts.RawSilencedCheckersAndPackages.empty()) {\n    std::vector<StringRef> Checkers =\n        AnOpts.getRegisteredCheckers(/*IncludeExperimental=*/true);\n    std::vector<StringRef> Packages =\n        AnOpts.getRegisteredPackages(/*IncludeExperimental=*/true);\n\n    SmallVector<StringRef, 16> CheckersAndPackages;\n    AnOpts.RawSilencedCheckersAndPackages.split(CheckersAndPackages, \";\");\n\n    for (const StringRef &CheckerOrPackage : CheckersAndPackages) {\n      if (Diags) {\n        bool IsChecker = CheckerOrPackage.contains('.');\n        bool IsValidName =\n            IsChecker\n                ? llvm::find(Checkers, CheckerOrPackage) != Checkers.end()\n                : llvm::find(Packages, CheckerOrPackage) != Packages.end();\n\n        if (!IsValidName)\n          Diags->Report(diag::err_unknown_analyzer_checker_or_package)\n              << CheckerOrPackage;\n      }\n\n      AnOpts.SilencedCheckersAndPackages.emplace_back(CheckerOrPackage);\n    }\n  }\n\n  if (!Diags)\n    return;\n\n  if (AnOpts.ShouldTrackConditionsDebug && !AnOpts.ShouldTrackConditions)\n    Diags->Report(diag::err_analyzer_config_invalid_input)\n        << \"track-conditions-debug\" << \"'track-conditions' to also be enabled\";\n\n  if (!AnOpts.CTUDir.empty() && !llvm::sys::fs::is_directory(AnOpts.CTUDir))\n    Diags->Report(diag::err_analyzer_config_invalid_input) << \"ctu-dir\"\n                                                           << \"a filename\";\n\n  if (!AnOpts.ModelPath.empty() &&\n      !llvm::sys::fs::is_directory(AnOpts.ModelPath))\n    Diags->Report(diag::err_analyzer_config_invalid_input) << \"model-path\"\n                                                           << \"a filename\";\n}\n\n/// Generate a remark argument. This is an inverse of `ParseOptimizationRemark`.\nstatic void\nGenerateOptimizationRemark(SmallVectorImpl<const char *> &Args,\n                           CompilerInvocation::StringAllocator SA,\n                           OptSpecifier OptEQ, StringRef Name,\n                           const CodeGenOptions::OptRemark &Remark) {\n  if (Remark.hasValidPattern()) {\n    GenerateArg(Args, OptEQ, Remark.Pattern, SA);\n  } else if (Remark.Kind == CodeGenOptions::RK_Enabled) {\n    GenerateArg(Args, OPT_R_Joined, Name, SA);\n  } else if (Remark.Kind == CodeGenOptions::RK_Disabled) {\n    GenerateArg(Args, OPT_R_Joined, StringRef(\"no-\") + Name, SA);\n  }\n}\n\n/// Parse a remark command line argument. It may be missing, disabled/enabled by\n/// '-R[no-]group' or specified with a regular expression by '-Rgroup=regexp'.\n/// On top of that, it can be disabled/enabled globally by '-R[no-]everything'.\nstatic CodeGenOptions::OptRemark\nParseOptimizationRemark(DiagnosticsEngine &Diags, ArgList &Args,\n                        OptSpecifier OptEQ, StringRef Name) {\n  CodeGenOptions::OptRemark Result;\n\n  auto InitializeResultPattern = [&Diags, &Args, &Result](const Arg *A) {\n    Result.Pattern = A->getValue();\n\n    std::string RegexError;\n    Result.Regex = std::make_shared<llvm::Regex>(Result.Pattern);\n    if (!Result.Regex->isValid(RegexError)) {\n      Diags.Report(diag::err_drv_optimization_remark_pattern)\n          << RegexError << A->getAsString(Args);\n      return false;\n    }\n\n    return true;\n  };\n\n  for (Arg *A : Args) {\n    if (A->getOption().matches(OPT_R_Joined)) {\n      StringRef Value = A->getValue();\n\n      if (Value == Name)\n        Result.Kind = CodeGenOptions::RK_Enabled;\n      else if (Value == \"everything\")\n        Result.Kind = CodeGenOptions::RK_EnabledEverything;\n      else if (Value.split('-') == std::make_pair(StringRef(\"no\"), Name))\n        Result.Kind = CodeGenOptions::RK_Disabled;\n      else if (Value == \"no-everything\")\n        Result.Kind = CodeGenOptions::RK_DisabledEverything;\n    } else if (A->getOption().matches(OptEQ)) {\n      Result.Kind = CodeGenOptions::RK_WithPattern;\n      if (!InitializeResultPattern(A))\n        return CodeGenOptions::OptRemark();\n    }\n  }\n\n  if (Result.Kind == CodeGenOptions::RK_Disabled ||\n      Result.Kind == CodeGenOptions::RK_DisabledEverything) {\n    Result.Pattern = \"\";\n    Result.Regex = nullptr;\n  }\n\n  return Result;\n}\n\nstatic bool parseDiagnosticLevelMask(StringRef FlagName,\n                                     const std::vector<std::string> &Levels,\n                                     DiagnosticsEngine &Diags,\n                                     DiagnosticLevelMask &M) {\n  bool Success = true;\n  for (const auto &Level : Levels) {\n    DiagnosticLevelMask const PM =\n      llvm::StringSwitch<DiagnosticLevelMask>(Level)\n        .Case(\"note\",    DiagnosticLevelMask::Note)\n        .Case(\"remark\",  DiagnosticLevelMask::Remark)\n        .Case(\"warning\", DiagnosticLevelMask::Warning)\n        .Case(\"error\",   DiagnosticLevelMask::Error)\n        .Default(DiagnosticLevelMask::None);\n    if (PM == DiagnosticLevelMask::None) {\n      Success = false;\n      Diags.Report(diag::err_drv_invalid_value) << FlagName << Level;\n    }\n    M = M | PM;\n  }\n  return Success;\n}\n\nstatic void parseSanitizerKinds(StringRef FlagName,\n                                const std::vector<std::string> &Sanitizers,\n                                DiagnosticsEngine &Diags, SanitizerSet &S) {\n  for (const auto &Sanitizer : Sanitizers) {\n    SanitizerMask K = parseSanitizerValue(Sanitizer, /*AllowGroups=*/false);\n    if (K == SanitizerMask())\n      Diags.Report(diag::err_drv_invalid_value) << FlagName << Sanitizer;\n    else\n      S.set(K, true);\n  }\n}\n\nstatic SmallVector<StringRef, 4> serializeSanitizerKinds(SanitizerSet S) {\n  SmallVector<StringRef, 4> Values;\n  serializeSanitizerSet(S, Values);\n  return Values;\n}\n\nstatic void parseXRayInstrumentationBundle(StringRef FlagName, StringRef Bundle,\n                                           ArgList &Args, DiagnosticsEngine &D,\n                                           XRayInstrSet &S) {\n  llvm::SmallVector<StringRef, 2> BundleParts;\n  llvm::SplitString(Bundle, BundleParts, \",\");\n  for (const auto &B : BundleParts) {\n    auto Mask = parseXRayInstrValue(B);\n    if (Mask == XRayInstrKind::None)\n      if (B != \"none\")\n        D.Report(diag::err_drv_invalid_value) << FlagName << Bundle;\n      else\n        S.Mask = Mask;\n    else if (Mask == XRayInstrKind::All)\n      S.Mask = Mask;\n    else\n      S.set(Mask, true);\n  }\n}\n\nstatic std::string serializeXRayInstrumentationBundle(const XRayInstrSet &S) {\n  llvm::SmallVector<StringRef, 2> BundleParts;\n  serializeXRayInstrValue(S, BundleParts);\n  std::string Buffer;\n  llvm::raw_string_ostream OS(Buffer);\n  llvm::interleave(BundleParts, OS, [&OS](StringRef Part) { OS << Part; }, \",\");\n  return OS.str();\n}\n\n// Set the profile kind using fprofile-instrument-use-path.\nstatic void setPGOUseInstrumentor(CodeGenOptions &Opts,\n                                  const Twine &ProfileName) {\n  auto ReaderOrErr = llvm::IndexedInstrProfReader::create(ProfileName);\n  // In error, return silently and let Clang PGOUse report the error message.\n  if (auto E = ReaderOrErr.takeError()) {\n    llvm::consumeError(std::move(E));\n    Opts.setProfileUse(CodeGenOptions::ProfileClangInstr);\n    return;\n  }\n  std::unique_ptr<llvm::IndexedInstrProfReader> PGOReader =\n    std::move(ReaderOrErr.get());\n  if (PGOReader->isIRLevelProfile()) {\n    if (PGOReader->hasCSIRLevelProfile())\n      Opts.setProfileUse(CodeGenOptions::ProfileCSIRInstr);\n    else\n      Opts.setProfileUse(CodeGenOptions::ProfileIRInstr);\n  } else\n    Opts.setProfileUse(CodeGenOptions::ProfileClangInstr);\n}\n\nvoid CompilerInvocation::GenerateCodeGenArgs(\n    const CodeGenOptions &Opts, SmallVectorImpl<const char *> &Args,\n    StringAllocator SA, const llvm::Triple &T, const std::string &OutputFile,\n    const LangOptions *LangOpts) {\n  const CodeGenOptions &CodeGenOpts = Opts;\n\n  if (Opts.OptimizationLevel == 0)\n    GenerateArg(Args, OPT_O0, SA);\n  else\n    GenerateArg(Args, OPT_O, Twine(Opts.OptimizationLevel), SA);\n\n#define CODEGEN_OPTION_WITH_MARSHALLING(                                       \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef CODEGEN_OPTION_WITH_MARSHALLING\n\n  if (Opts.OptimizationLevel > 0) {\n    if (Opts.Inlining == CodeGenOptions::NormalInlining)\n      GenerateArg(Args, OPT_finline_functions, SA);\n    else if (Opts.Inlining == CodeGenOptions::OnlyHintInlining)\n      GenerateArg(Args, OPT_finline_hint_functions, SA);\n    else if (Opts.Inlining == CodeGenOptions::OnlyAlwaysInlining)\n      GenerateArg(Args, OPT_fno_inline, SA);\n  }\n\n  if (Opts.DirectAccessExternalData && LangOpts->PICLevel != 0)\n    GenerateArg(Args, OPT_fdirect_access_external_data, SA);\n  else if (!Opts.DirectAccessExternalData && LangOpts->PICLevel == 0)\n    GenerateArg(Args, OPT_fno_direct_access_external_data, SA);\n\n  Optional<StringRef> DebugInfoVal;\n  switch (Opts.DebugInfo) {\n  case codegenoptions::DebugLineTablesOnly:\n    DebugInfoVal = \"line-tables-only\";\n    break;\n  case codegenoptions::DebugDirectivesOnly:\n    DebugInfoVal = \"line-directives-only\";\n    break;\n  case codegenoptions::DebugInfoConstructor:\n    DebugInfoVal = \"constructor\";\n    break;\n  case codegenoptions::LimitedDebugInfo:\n    DebugInfoVal = \"limited\";\n    break;\n  case codegenoptions::FullDebugInfo:\n    DebugInfoVal = \"standalone\";\n    break;\n  case codegenoptions::UnusedTypeInfo:\n    DebugInfoVal = \"unused-types\";\n    break;\n  case codegenoptions::NoDebugInfo: // default value\n    DebugInfoVal = None;\n    break;\n  case codegenoptions::LocTrackingOnly: // implied value\n    DebugInfoVal = None;\n    break;\n  }\n  if (DebugInfoVal)\n    GenerateArg(Args, OPT_debug_info_kind_EQ, *DebugInfoVal, SA);\n\n  if (Opts.DebugInfo == codegenoptions::DebugInfoConstructor)\n    GenerateArg(Args, OPT_fuse_ctor_homing, SA);\n\n  for (const auto &Prefix : Opts.DebugPrefixMap)\n    GenerateArg(Args, OPT_fdebug_prefix_map_EQ,\n                Prefix.first + \"=\" + Prefix.second, SA);\n\n  for (const auto &Prefix : Opts.CoveragePrefixMap)\n    GenerateArg(Args, OPT_fcoverage_prefix_map_EQ,\n                Prefix.first + \"=\" + Prefix.second, SA);\n\n  if (Opts.NewStructPathTBAA)\n    GenerateArg(Args, OPT_new_struct_path_tbaa, SA);\n\n  if (Opts.OptimizeSize == 1)\n    GenerateArg(Args, OPT_O, \"s\", SA);\n  else if (Opts.OptimizeSize == 2)\n    GenerateArg(Args, OPT_O, \"z\", SA);\n\n  // SimplifyLibCalls is set only in the absence of -fno-builtin and\n  // -ffreestanding. We'll consider that when generating them.\n\n  // NoBuiltinFuncs are generated by LangOptions.\n\n  if (Opts.UnrollLoops && Opts.OptimizationLevel <= 1)\n    GenerateArg(Args, OPT_funroll_loops, SA);\n  else if (!Opts.UnrollLoops && Opts.OptimizationLevel > 1)\n    GenerateArg(Args, OPT_fno_unroll_loops, SA);\n\n  if (!Opts.BinutilsVersion.empty())\n    GenerateArg(Args, OPT_fbinutils_version_EQ, Opts.BinutilsVersion, SA);\n\n  if (Opts.DebugNameTable ==\n      static_cast<unsigned>(llvm::DICompileUnit::DebugNameTableKind::GNU))\n    GenerateArg(Args, OPT_ggnu_pubnames, SA);\n  else if (Opts.DebugNameTable ==\n           static_cast<unsigned>(\n               llvm::DICompileUnit::DebugNameTableKind::Default))\n    GenerateArg(Args, OPT_gpubnames, SA);\n\n  // ProfileInstrumentUsePath is marshalled automatically, no need to generate\n  // it or PGOUseInstrumentor.\n\n  if (Opts.TimePasses) {\n    if (Opts.TimePassesPerRun)\n      GenerateArg(Args, OPT_ftime_report_EQ, \"per-pass-run\", SA);\n    else\n      GenerateArg(Args, OPT_ftime_report, SA);\n  }\n\n  if (Opts.PrepareForLTO && !Opts.PrepareForThinLTO)\n    GenerateArg(Args, OPT_flto, SA);\n\n  if (Opts.PrepareForThinLTO)\n    GenerateArg(Args, OPT_flto_EQ, \"thin\", SA);\n\n  if (!Opts.ThinLTOIndexFile.empty())\n    GenerateArg(Args, OPT_fthinlto_index_EQ, Opts.ThinLTOIndexFile, SA);\n\n  if (Opts.SaveTempsFilePrefix == OutputFile)\n    GenerateArg(Args, OPT_save_temps_EQ, \"obj\", SA);\n\n  StringRef MemProfileBasename(\"memprof.profraw\");\n  if (!Opts.MemoryProfileOutput.empty()) {\n    if (Opts.MemoryProfileOutput == MemProfileBasename) {\n      GenerateArg(Args, OPT_fmemory_profile, SA);\n    } else {\n      size_t ArgLength =\n          Opts.MemoryProfileOutput.size() - MemProfileBasename.size();\n      GenerateArg(Args, OPT_fmemory_profile_EQ,\n                  Opts.MemoryProfileOutput.substr(0, ArgLength), SA);\n    }\n  }\n\n  if (memcmp(Opts.CoverageVersion, \"408*\", 4) != 0)\n    GenerateArg(Args, OPT_coverage_version_EQ,\n                StringRef(Opts.CoverageVersion, 4), SA);\n\n  // TODO: Check if we need to generate arguments stored in CmdArgs. (Namely\n  //  '-fembed_bitcode', which does not map to any CompilerInvocation field and\n  //  won't be generated.)\n\n  if (Opts.XRayInstrumentationBundle.Mask != XRayInstrKind::All) {\n    std::string InstrBundle =\n        serializeXRayInstrumentationBundle(Opts.XRayInstrumentationBundle);\n    if (!InstrBundle.empty())\n      GenerateArg(Args, OPT_fxray_instrumentation_bundle, InstrBundle, SA);\n  }\n\n  if (Opts.CFProtectionReturn && Opts.CFProtectionBranch)\n    GenerateArg(Args, OPT_fcf_protection_EQ, \"full\", SA);\n  else if (Opts.CFProtectionReturn)\n    GenerateArg(Args, OPT_fcf_protection_EQ, \"return\", SA);\n  else if (Opts.CFProtectionBranch)\n    GenerateArg(Args, OPT_fcf_protection_EQ, \"branch\", SA);\n\n  for (const auto &F : Opts.LinkBitcodeFiles) {\n    bool Builtint = F.LinkFlags == llvm::Linker::Flags::LinkOnlyNeeded &&\n                    F.PropagateAttrs && F.Internalize;\n    GenerateArg(Args,\n                Builtint ? OPT_mlink_builtin_bitcode : OPT_mlink_bitcode_file,\n                F.Filename, SA);\n  }\n\n  // TODO: Consider removing marshalling annotations from f[no_]emulated_tls.\n  //  That would make it easy to generate the option only **once** if it was\n  //  explicitly set to non-default value.\n  if (Opts.ExplicitEmulatedTLS) {\n    GenerateArg(\n        Args, Opts.EmulatedTLS ? OPT_femulated_tls : OPT_fno_emulated_tls, SA);\n  }\n\n  if (Opts.FPDenormalMode != llvm::DenormalMode::getIEEE())\n    GenerateArg(Args, OPT_fdenormal_fp_math_EQ, Opts.FPDenormalMode.str(), SA);\n\n  if (Opts.FP32DenormalMode != llvm::DenormalMode::getIEEE())\n    GenerateArg(Args, OPT_fdenormal_fp_math_f32_EQ, Opts.FP32DenormalMode.str(),\n                SA);\n\n  if (Opts.StructReturnConvention == CodeGenOptions::SRCK_OnStack) {\n    OptSpecifier Opt =\n        T.isPPC32() ? OPT_maix_struct_return : OPT_fpcc_struct_return;\n    GenerateArg(Args, Opt, SA);\n  } else if (Opts.StructReturnConvention == CodeGenOptions::SRCK_InRegs) {\n    OptSpecifier Opt =\n        T.isPPC32() ? OPT_msvr4_struct_return : OPT_freg_struct_return;\n    GenerateArg(Args, Opt, SA);\n  }\n\n  if (Opts.EnableAIXExtendedAltivecABI)\n    GenerateArg(Args, OPT_mabi_EQ_vec_extabi, SA);\n\n  if (!Opts.OptRecordPasses.empty())\n    GenerateArg(Args, OPT_opt_record_passes, Opts.OptRecordPasses, SA);\n\n  if (!Opts.OptRecordFormat.empty())\n    GenerateArg(Args, OPT_opt_record_format, Opts.OptRecordFormat, SA);\n\n  GenerateOptimizationRemark(Args, SA, OPT_Rpass_EQ, \"pass\",\n                             Opts.OptimizationRemark);\n\n  GenerateOptimizationRemark(Args, SA, OPT_Rpass_missed_EQ, \"pass-missed\",\n                             Opts.OptimizationRemarkMissed);\n\n  GenerateOptimizationRemark(Args, SA, OPT_Rpass_analysis_EQ, \"pass-analysis\",\n                             Opts.OptimizationRemarkAnalysis);\n\n  GenerateArg(Args, OPT_fdiagnostics_hotness_threshold_EQ,\n              Opts.DiagnosticsHotnessThreshold\n                  ? Twine(*Opts.DiagnosticsHotnessThreshold)\n                  : \"auto\",\n              SA);\n\n  for (StringRef Sanitizer : serializeSanitizerKinds(Opts.SanitizeRecover))\n    GenerateArg(Args, OPT_fsanitize_recover_EQ, Sanitizer, SA);\n\n  for (StringRef Sanitizer : serializeSanitizerKinds(Opts.SanitizeTrap))\n    GenerateArg(Args, OPT_fsanitize_trap_EQ, Sanitizer, SA);\n\n  if (!Opts.EmitVersionIdentMetadata)\n    GenerateArg(Args, OPT_Qn, SA);\n\n  switch (Opts.FiniteLoops) {\n  case CodeGenOptions::FiniteLoopsKind::Language:\n    break;\n  case CodeGenOptions::FiniteLoopsKind::Always:\n    GenerateArg(Args, OPT_ffinite_loops, SA);\n    break;\n  case CodeGenOptions::FiniteLoopsKind::Never:\n    GenerateArg(Args, OPT_fno_finite_loops, SA);\n    break;\n  }\n}\n\nbool CompilerInvocation::ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args,\n                                          InputKind IK,\n                                          DiagnosticsEngine &Diags,\n                                          const llvm::Triple &T,\n                                          const std::string &OutputFile,\n                                          const LangOptions &LangOptsRef) {\n  unsigned NumErrorsBefore = Diags.getNumErrors();\n\n  bool Success = true;\n\n  unsigned OptimizationLevel = getOptimizationLevel(Args, IK, Diags);\n  // TODO: This could be done in Driver\n  unsigned MaxOptLevel = 3;\n  if (OptimizationLevel > MaxOptLevel) {\n    // If the optimization level is not supported, fall back on the default\n    // optimization\n    Diags.Report(diag::warn_drv_optimization_value)\n        << Args.getLastArg(OPT_O)->getAsString(Args) << \"-O\" << MaxOptLevel;\n    OptimizationLevel = MaxOptLevel;\n  }\n  Opts.OptimizationLevel = OptimizationLevel;\n\n  // The key paths of codegen options defined in Options.td start with\n  // \"CodeGenOpts.\". Let's provide the expected variable name and type.\n  CodeGenOptions &CodeGenOpts = Opts;\n  // Some codegen options depend on language options. Let's provide the expected\n  // variable name and type.\n  const LangOptions *LangOpts = &LangOptsRef;\n\n#define CODEGEN_OPTION_WITH_MARSHALLING(                                       \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef CODEGEN_OPTION_WITH_MARSHALLING\n\n  // At O0 we want to fully disable inlining outside of cases marked with\n  // 'alwaysinline' that are required for correctness.\n  Opts.setInlining((Opts.OptimizationLevel == 0)\n                       ? CodeGenOptions::OnlyAlwaysInlining\n                       : CodeGenOptions::NormalInlining);\n  // Explicit inlining flags can disable some or all inlining even at\n  // optimization levels above zero.\n  if (Arg *InlineArg = Args.getLastArg(\n          options::OPT_finline_functions, options::OPT_finline_hint_functions,\n          options::OPT_fno_inline_functions, options::OPT_fno_inline)) {\n    if (Opts.OptimizationLevel > 0) {\n      const Option &InlineOpt = InlineArg->getOption();\n      if (InlineOpt.matches(options::OPT_finline_functions))\n        Opts.setInlining(CodeGenOptions::NormalInlining);\n      else if (InlineOpt.matches(options::OPT_finline_hint_functions))\n        Opts.setInlining(CodeGenOptions::OnlyHintInlining);\n      else\n        Opts.setInlining(CodeGenOptions::OnlyAlwaysInlining);\n    }\n  }\n\n  // PIC defaults to -fno-direct-access-external-data while non-PIC defaults to\n  // -fdirect-access-external-data.\n  Opts.DirectAccessExternalData =\n      Args.hasArg(OPT_fdirect_access_external_data) ||\n      (!Args.hasArg(OPT_fno_direct_access_external_data) &&\n       LangOpts->PICLevel == 0);\n\n  if (Arg *A = Args.getLastArg(OPT_debug_info_kind_EQ)) {\n    unsigned Val =\n        llvm::StringSwitch<unsigned>(A->getValue())\n            .Case(\"line-tables-only\", codegenoptions::DebugLineTablesOnly)\n            .Case(\"line-directives-only\", codegenoptions::DebugDirectivesOnly)\n            .Case(\"constructor\", codegenoptions::DebugInfoConstructor)\n            .Case(\"limited\", codegenoptions::LimitedDebugInfo)\n            .Case(\"standalone\", codegenoptions::FullDebugInfo)\n            .Case(\"unused-types\", codegenoptions::UnusedTypeInfo)\n            .Default(~0U);\n    if (Val == ~0U)\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)\n                                                << A->getValue();\n    else\n      Opts.setDebugInfo(static_cast<codegenoptions::DebugInfoKind>(Val));\n  }\n\n  // If -fuse-ctor-homing is set and limited debug info is already on, then use\n  // constructor homing.\n  if (Args.getLastArg(OPT_fuse_ctor_homing))\n    if (Opts.getDebugInfo() == codegenoptions::LimitedDebugInfo)\n      Opts.setDebugInfo(codegenoptions::DebugInfoConstructor);\n\n  for (const auto &Arg : Args.getAllArgValues(OPT_fdebug_prefix_map_EQ)) {\n    auto Split = StringRef(Arg).split('=');\n    Opts.DebugPrefixMap.insert(\n        {std::string(Split.first), std::string(Split.second)});\n  }\n\n  for (const auto &Arg : Args.getAllArgValues(OPT_fcoverage_prefix_map_EQ)) {\n    auto Split = StringRef(Arg).split('=');\n    Opts.CoveragePrefixMap.insert(\n        {std::string(Split.first), std::string(Split.second)});\n  }\n\n  const llvm::Triple::ArchType DebugEntryValueArchs[] = {\n      llvm::Triple::x86, llvm::Triple::x86_64, llvm::Triple::aarch64,\n      llvm::Triple::arm, llvm::Triple::armeb, llvm::Triple::mips,\n      llvm::Triple::mipsel, llvm::Triple::mips64, llvm::Triple::mips64el};\n\n  if (Opts.OptimizationLevel > 0 && Opts.hasReducedDebugInfo() &&\n      llvm::is_contained(DebugEntryValueArchs, T.getArch()))\n    Opts.EmitCallSiteInfo = true;\n\n  Opts.NewStructPathTBAA = !Args.hasArg(OPT_no_struct_path_tbaa) &&\n                           Args.hasArg(OPT_new_struct_path_tbaa);\n  Opts.OptimizeSize = getOptimizationLevelSize(Args);\n  Opts.SimplifyLibCalls = !LangOpts->NoBuiltin;\n  if (Opts.SimplifyLibCalls)\n    Opts.NoBuiltinFuncs = LangOpts->NoBuiltinFuncs;\n  Opts.UnrollLoops =\n      Args.hasFlag(OPT_funroll_loops, OPT_fno_unroll_loops,\n                   (Opts.OptimizationLevel > 1));\n  Opts.BinutilsVersion =\n      std::string(Args.getLastArgValue(OPT_fbinutils_version_EQ));\n\n  Opts.DebugNameTable = static_cast<unsigned>(\n      Args.hasArg(OPT_ggnu_pubnames)\n          ? llvm::DICompileUnit::DebugNameTableKind::GNU\n          : Args.hasArg(OPT_gpubnames)\n                ? llvm::DICompileUnit::DebugNameTableKind::Default\n                : llvm::DICompileUnit::DebugNameTableKind::None);\n\n  if (!Opts.ProfileInstrumentUsePath.empty())\n    setPGOUseInstrumentor(Opts, Opts.ProfileInstrumentUsePath);\n\n  if (const Arg *A = Args.getLastArg(OPT_ftime_report, OPT_ftime_report_EQ)) {\n    Opts.TimePasses = true;\n\n    // -ftime-report= is only for new pass manager.\n    if (A->getOption().getID() == OPT_ftime_report_EQ) {\n      if (Opts.LegacyPassManager)\n        Diags.Report(diag::err_drv_argument_only_allowed_with)\n            << A->getAsString(Args) << \"-fno-legacy-pass-manager\";\n\n      StringRef Val = A->getValue();\n      if (Val == \"per-pass\")\n        Opts.TimePassesPerRun = false;\n      else if (Val == \"per-pass-run\")\n        Opts.TimePassesPerRun = true;\n      else\n        Diags.Report(diag::err_drv_invalid_value)\n            << A->getAsString(Args) << A->getValue();\n    }\n  }\n\n  Opts.PrepareForLTO = Args.hasArg(OPT_flto, OPT_flto_EQ);\n  Opts.PrepareForThinLTO = false;\n  if (Arg *A = Args.getLastArg(OPT_flto_EQ)) {\n    StringRef S = A->getValue();\n    if (S == \"thin\")\n      Opts.PrepareForThinLTO = true;\n    else if (S != \"full\")\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << S;\n  }\n  if (Arg *A = Args.getLastArg(OPT_fthinlto_index_EQ)) {\n    if (IK.getLanguage() != Language::LLVM_IR)\n      Diags.Report(diag::err_drv_argument_only_allowed_with)\n          << A->getAsString(Args) << \"-x ir\";\n    Opts.ThinLTOIndexFile =\n        std::string(Args.getLastArgValue(OPT_fthinlto_index_EQ));\n  }\n  if (Arg *A = Args.getLastArg(OPT_save_temps_EQ))\n    Opts.SaveTempsFilePrefix =\n        llvm::StringSwitch<std::string>(A->getValue())\n            .Case(\"obj\", OutputFile)\n            .Default(llvm::sys::path::filename(OutputFile).str());\n\n  // The memory profile runtime appends the pid to make this name more unique.\n  const char *MemProfileBasename = \"memprof.profraw\";\n  if (Args.hasArg(OPT_fmemory_profile_EQ)) {\n    SmallString<128> Path(\n        std::string(Args.getLastArgValue(OPT_fmemory_profile_EQ)));\n    llvm::sys::path::append(Path, MemProfileBasename);\n    Opts.MemoryProfileOutput = std::string(Path);\n  } else if (Args.hasArg(OPT_fmemory_profile))\n    Opts.MemoryProfileOutput = MemProfileBasename;\n\n  memcpy(Opts.CoverageVersion, \"408*\", 4);\n  if (Opts.EmitGcovArcs || Opts.EmitGcovNotes) {\n    if (Args.hasArg(OPT_coverage_version_EQ)) {\n      StringRef CoverageVersion = Args.getLastArgValue(OPT_coverage_version_EQ);\n      if (CoverageVersion.size() != 4) {\n        Diags.Report(diag::err_drv_invalid_value)\n            << Args.getLastArg(OPT_coverage_version_EQ)->getAsString(Args)\n            << CoverageVersion;\n      } else {\n        memcpy(Opts.CoverageVersion, CoverageVersion.data(), 4);\n      }\n    }\n  }\n  // FIXME: For backend options that are not yet recorded as function\n  // attributes in the IR, keep track of them so we can embed them in a\n  // separate data section and use them when building the bitcode.\n  for (const auto &A : Args) {\n    // Do not encode output and input.\n    if (A->getOption().getID() == options::OPT_o ||\n        A->getOption().getID() == options::OPT_INPUT ||\n        A->getOption().getID() == options::OPT_x ||\n        A->getOption().getID() == options::OPT_fembed_bitcode ||\n        A->getOption().matches(options::OPT_W_Group))\n      continue;\n    ArgStringList ASL;\n    A->render(Args, ASL);\n    for (const auto &arg : ASL) {\n      StringRef ArgStr(arg);\n      Opts.CmdArgs.insert(Opts.CmdArgs.end(), ArgStr.begin(), ArgStr.end());\n      // using \\00 to separate each commandline options.\n      Opts.CmdArgs.push_back('\\0');\n    }\n  }\n\n  auto XRayInstrBundles =\n      Args.getAllArgValues(OPT_fxray_instrumentation_bundle);\n  if (XRayInstrBundles.empty())\n    Opts.XRayInstrumentationBundle.Mask = XRayInstrKind::All;\n  else\n    for (const auto &A : XRayInstrBundles)\n      parseXRayInstrumentationBundle(\"-fxray-instrumentation-bundle=\", A, Args,\n                                     Diags, Opts.XRayInstrumentationBundle);\n\n  if (const Arg *A = Args.getLastArg(OPT_fcf_protection_EQ)) {\n    StringRef Name = A->getValue();\n    if (Name == \"full\") {\n      Opts.CFProtectionReturn = 1;\n      Opts.CFProtectionBranch = 1;\n    } else if (Name == \"return\")\n      Opts.CFProtectionReturn = 1;\n    else if (Name == \"branch\")\n      Opts.CFProtectionBranch = 1;\n    else if (Name != \"none\") {\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << Name;\n      Success = false;\n    }\n  }\n\n  for (auto *A :\n       Args.filtered(OPT_mlink_bitcode_file, OPT_mlink_builtin_bitcode)) {\n    CodeGenOptions::BitcodeFileToLink F;\n    F.Filename = A->getValue();\n    if (A->getOption().matches(OPT_mlink_builtin_bitcode)) {\n      F.LinkFlags = llvm::Linker::Flags::LinkOnlyNeeded;\n      // When linking CUDA bitcode, propagate function attributes so that\n      // e.g. libdevice gets fast-math attrs if we're building with fast-math.\n      F.PropagateAttrs = true;\n      F.Internalize = true;\n    }\n    Opts.LinkBitcodeFiles.push_back(F);\n  }\n\n  if (Args.getLastArg(OPT_femulated_tls) ||\n      Args.getLastArg(OPT_fno_emulated_tls)) {\n    Opts.ExplicitEmulatedTLS = true;\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_fdenormal_fp_math_EQ)) {\n    StringRef Val = A->getValue();\n    Opts.FPDenormalMode = llvm::parseDenormalFPAttribute(Val);\n    if (!Opts.FPDenormalMode.isValid())\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << Val;\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_fdenormal_fp_math_f32_EQ)) {\n    StringRef Val = A->getValue();\n    Opts.FP32DenormalMode = llvm::parseDenormalFPAttribute(Val);\n    if (!Opts.FP32DenormalMode.isValid())\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << Val;\n  }\n\n  // X86_32 has -fppc-struct-return and -freg-struct-return.\n  // PPC32 has -maix-struct-return and -msvr4-struct-return.\n  if (Arg *A =\n          Args.getLastArg(OPT_fpcc_struct_return, OPT_freg_struct_return,\n                          OPT_maix_struct_return, OPT_msvr4_struct_return)) {\n    // TODO: We might want to consider enabling these options on AIX in the\n    // future.\n    if (T.isOSAIX())\n      Diags.Report(diag::err_drv_unsupported_opt_for_target)\n          << A->getSpelling() << T.str();\n\n    const Option &O = A->getOption();\n    if (O.matches(OPT_fpcc_struct_return) ||\n        O.matches(OPT_maix_struct_return)) {\n      Opts.setStructReturnConvention(CodeGenOptions::SRCK_OnStack);\n    } else {\n      assert(O.matches(OPT_freg_struct_return) ||\n             O.matches(OPT_msvr4_struct_return));\n      Opts.setStructReturnConvention(CodeGenOptions::SRCK_InRegs);\n    }\n  }\n\n  if (Arg *A =\n          Args.getLastArg(OPT_mabi_EQ_vec_default, OPT_mabi_EQ_vec_extabi)) {\n    if (!T.isOSAIX())\n      Diags.Report(diag::err_drv_unsupported_opt_for_target)\n          << A->getSpelling() << T.str();\n\n    const Option &O = A->getOption();\n    if (O.matches(OPT_mabi_EQ_vec_default))\n      Diags.Report(diag::err_aix_default_altivec_abi)\n          << A->getSpelling() << T.str();\n    else {\n      assert(O.matches(OPT_mabi_EQ_vec_extabi));\n      Opts.EnableAIXExtendedAltivecABI = 1;\n    }\n  }\n\n  bool NeedLocTracking = false;\n\n  if (!Opts.OptRecordFile.empty())\n    NeedLocTracking = true;\n\n  if (Arg *A = Args.getLastArg(OPT_opt_record_passes)) {\n    Opts.OptRecordPasses = A->getValue();\n    NeedLocTracking = true;\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_opt_record_format)) {\n    Opts.OptRecordFormat = A->getValue();\n    NeedLocTracking = true;\n  }\n\n  Opts.OptimizationRemark =\n      ParseOptimizationRemark(Diags, Args, OPT_Rpass_EQ, \"pass\");\n\n  Opts.OptimizationRemarkMissed =\n      ParseOptimizationRemark(Diags, Args, OPT_Rpass_missed_EQ, \"pass-missed\");\n\n  Opts.OptimizationRemarkAnalysis = ParseOptimizationRemark(\n      Diags, Args, OPT_Rpass_analysis_EQ, \"pass-analysis\");\n\n  NeedLocTracking |= Opts.OptimizationRemark.hasValidPattern() ||\n                     Opts.OptimizationRemarkMissed.hasValidPattern() ||\n                     Opts.OptimizationRemarkAnalysis.hasValidPattern();\n\n  bool UsingSampleProfile = !Opts.SampleProfileFile.empty();\n  bool UsingProfile = UsingSampleProfile ||\n      (Opts.getProfileUse() != CodeGenOptions::ProfileNone);\n\n  if (Opts.DiagnosticsWithHotness && !UsingProfile &&\n      // An IR file will contain PGO as metadata\n      IK.getLanguage() != Language::LLVM_IR)\n    Diags.Report(diag::warn_drv_diagnostics_hotness_requires_pgo)\n        << \"-fdiagnostics-show-hotness\";\n\n  // Parse remarks hotness threshold. Valid value is either integer or 'auto'.\n  if (auto *arg =\n          Args.getLastArg(options::OPT_fdiagnostics_hotness_threshold_EQ)) {\n    auto ResultOrErr =\n        llvm::remarks::parseHotnessThresholdOption(arg->getValue());\n\n    if (!ResultOrErr) {\n      Diags.Report(diag::err_drv_invalid_diagnotics_hotness_threshold)\n          << \"-fdiagnostics-hotness-threshold=\";\n    } else {\n      Opts.DiagnosticsHotnessThreshold = *ResultOrErr;\n      if ((!Opts.DiagnosticsHotnessThreshold.hasValue() ||\n           Opts.DiagnosticsHotnessThreshold.getValue() > 0) &&\n          !UsingProfile)\n        Diags.Report(diag::warn_drv_diagnostics_hotness_requires_pgo)\n            << \"-fdiagnostics-hotness-threshold=\";\n    }\n  }\n\n  // If the user requested to use a sample profile for PGO, then the\n  // backend will need to track source location information so the profile\n  // can be incorporated into the IR.\n  if (UsingSampleProfile)\n    NeedLocTracking = true;\n\n  // If the user requested a flag that requires source locations available in\n  // the backend, make sure that the backend tracks source location information.\n  if (NeedLocTracking && Opts.getDebugInfo() == codegenoptions::NoDebugInfo)\n    Opts.setDebugInfo(codegenoptions::LocTrackingOnly);\n\n  // Parse -fsanitize-recover= arguments.\n  // FIXME: Report unrecoverable sanitizers incorrectly specified here.\n  parseSanitizerKinds(\"-fsanitize-recover=\",\n                      Args.getAllArgValues(OPT_fsanitize_recover_EQ), Diags,\n                      Opts.SanitizeRecover);\n  parseSanitizerKinds(\"-fsanitize-trap=\",\n                      Args.getAllArgValues(OPT_fsanitize_trap_EQ), Diags,\n                      Opts.SanitizeTrap);\n\n  Opts.EmitVersionIdentMetadata = Args.hasFlag(OPT_Qy, OPT_Qn, true);\n\n  if (Args.hasArg(options::OPT_ffinite_loops))\n    Opts.FiniteLoops = CodeGenOptions::FiniteLoopsKind::Always;\n  else if (Args.hasArg(options::OPT_fno_finite_loops))\n    Opts.FiniteLoops = CodeGenOptions::FiniteLoopsKind::Never;\n\n  return Success && Diags.getNumErrors() == NumErrorsBefore;\n}\n\nstatic void\nGenerateDependencyOutputArgs(const DependencyOutputOptions &Opts,\n                             SmallVectorImpl<const char *> &Args,\n                             CompilerInvocation::StringAllocator SA) {\n  const DependencyOutputOptions &DependencyOutputOpts = Opts;\n#define DEPENDENCY_OUTPUT_OPTION_WITH_MARSHALLING(                             \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef DEPENDENCY_OUTPUT_OPTION_WITH_MARSHALLING\n\n  if (Opts.ShowIncludesDest != ShowIncludesDestination::None)\n    GenerateArg(Args, OPT_show_includes, SA);\n\n  for (const auto &Dep : Opts.ExtraDeps) {\n    switch (Dep.second) {\n    case EDK_SanitizeBlacklist:\n      // Sanitizer blacklist arguments are generated from LanguageOptions.\n      continue;\n    case EDK_ModuleFile:\n      // Module file arguments are generated from FrontendOptions and\n      // HeaderSearchOptions.\n      continue;\n    case EDK_ProfileList:\n      // Profile list arguments are generated from LanguageOptions via the\n      // marshalling infrastructure.\n      continue;\n    case EDK_DepFileEntry:\n      GenerateArg(Args, OPT_fdepfile_entry, Dep.first, SA);\n      break;\n    }\n  }\n}\n\nstatic bool ParseDependencyOutputArgs(DependencyOutputOptions &Opts,\n                                      ArgList &Args, DiagnosticsEngine &Diags,\n                                      frontend::ActionKind Action,\n                                      bool ShowLineMarkers) {\n  unsigned NumErrorsBefore = Diags.getNumErrors();\n  bool Success = true;\n\n  DependencyOutputOptions &DependencyOutputOpts = Opts;\n#define DEPENDENCY_OUTPUT_OPTION_WITH_MARSHALLING(                             \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef DEPENDENCY_OUTPUT_OPTION_WITH_MARSHALLING\n\n  if (Args.hasArg(OPT_show_includes)) {\n    // Writing both /showIncludes and preprocessor output to stdout\n    // would produce interleaved output, so use stderr for /showIncludes.\n    // This behaves the same as cl.exe, when /E, /EP or /P are passed.\n    if (Action == frontend::PrintPreprocessedInput || !ShowLineMarkers)\n      Opts.ShowIncludesDest = ShowIncludesDestination::Stderr;\n    else\n      Opts.ShowIncludesDest = ShowIncludesDestination::Stdout;\n  } else {\n    Opts.ShowIncludesDest = ShowIncludesDestination::None;\n  }\n\n  // Add sanitizer blacklists as extra dependencies.\n  // They won't be discovered by the regular preprocessor, so\n  // we let make / ninja to know about this implicit dependency.\n  if (!Args.hasArg(OPT_fno_sanitize_blacklist)) {\n    for (const auto *A : Args.filtered(OPT_fsanitize_blacklist)) {\n      StringRef Val = A->getValue();\n      if (Val.find('=') == StringRef::npos)\n        Opts.ExtraDeps.emplace_back(std::string(Val), EDK_SanitizeBlacklist);\n    }\n    if (Opts.IncludeSystemHeaders) {\n      for (const auto *A : Args.filtered(OPT_fsanitize_system_blacklist)) {\n        StringRef Val = A->getValue();\n        if (Val.find('=') == StringRef::npos)\n          Opts.ExtraDeps.emplace_back(std::string(Val), EDK_SanitizeBlacklist);\n      }\n    }\n  }\n\n  // -fprofile-list= dependencies.\n  for (const auto &Filename : Args.getAllArgValues(OPT_fprofile_list_EQ))\n    Opts.ExtraDeps.emplace_back(Filename, EDK_ProfileList);\n\n  // Propagate the extra dependencies.\n  for (const auto *A : Args.filtered(OPT_fdepfile_entry))\n    Opts.ExtraDeps.emplace_back(A->getValue(), EDK_DepFileEntry);\n\n  // Only the -fmodule-file=<file> form.\n  for (const auto *A : Args.filtered(OPT_fmodule_file)) {\n    StringRef Val = A->getValue();\n    if (Val.find('=') == StringRef::npos)\n      Opts.ExtraDeps.emplace_back(std::string(Val), EDK_ModuleFile);\n  }\n\n  return Success && Diags.getNumErrors() == NumErrorsBefore;\n}\n\nstatic bool parseShowColorsArgs(const ArgList &Args, bool DefaultColor) {\n  // Color diagnostics default to auto (\"on\" if terminal supports) in the driver\n  // but default to off in cc1, needing an explicit OPT_fdiagnostics_color.\n  // Support both clang's -f[no-]color-diagnostics and gcc's\n  // -f[no-]diagnostics-colors[=never|always|auto].\n  enum {\n    Colors_On,\n    Colors_Off,\n    Colors_Auto\n  } ShowColors = DefaultColor ? Colors_Auto : Colors_Off;\n  for (auto *A : Args) {\n    const Option &O = A->getOption();\n    if (O.matches(options::OPT_fcolor_diagnostics) ||\n        O.matches(options::OPT_fdiagnostics_color)) {\n      ShowColors = Colors_On;\n    } else if (O.matches(options::OPT_fno_color_diagnostics) ||\n               O.matches(options::OPT_fno_diagnostics_color)) {\n      ShowColors = Colors_Off;\n    } else if (O.matches(options::OPT_fdiagnostics_color_EQ)) {\n      StringRef Value(A->getValue());\n      if (Value == \"always\")\n        ShowColors = Colors_On;\n      else if (Value == \"never\")\n        ShowColors = Colors_Off;\n      else if (Value == \"auto\")\n        ShowColors = Colors_Auto;\n    }\n  }\n  return ShowColors == Colors_On ||\n         (ShowColors == Colors_Auto &&\n          llvm::sys::Process::StandardErrHasColors());\n}\n\nstatic bool checkVerifyPrefixes(const std::vector<std::string> &VerifyPrefixes,\n                                DiagnosticsEngine &Diags) {\n  bool Success = true;\n  for (const auto &Prefix : VerifyPrefixes) {\n    // Every prefix must start with a letter and contain only alphanumeric\n    // characters, hyphens, and underscores.\n    auto BadChar = llvm::find_if(Prefix, [](char C) {\n      return !isAlphanumeric(C) && C != '-' && C != '_';\n    });\n    if (BadChar != Prefix.end() || !isLetter(Prefix[0])) {\n      Success = false;\n      Diags.Report(diag::err_drv_invalid_value) << \"-verify=\" << Prefix;\n      Diags.Report(diag::note_drv_verify_prefix_spelling);\n    }\n  }\n  return Success;\n}\n\nstatic void GenerateFileSystemArgs(const FileSystemOptions &Opts,\n                                   SmallVectorImpl<const char *> &Args,\n                                   CompilerInvocation::StringAllocator SA) {\n  const FileSystemOptions &FileSystemOpts = Opts;\n\n#define FILE_SYSTEM_OPTION_WITH_MARSHALLING(                                   \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef FILE_SYSTEM_OPTION_WITH_MARSHALLING\n}\n\nstatic bool ParseFileSystemArgs(FileSystemOptions &Opts, const ArgList &Args,\n                                DiagnosticsEngine &Diags) {\n  FileSystemOptions &FileSystemOpts = Opts;\n  bool Success = true;\n\n#define FILE_SYSTEM_OPTION_WITH_MARSHALLING(                                   \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef FILE_SYSTEM_OPTION_WITH_MARSHALLING\n\n  return Success;\n}\n\nstatic void GenerateMigratorArgs(const MigratorOptions &Opts,\n                                 SmallVectorImpl<const char *> &Args,\n                                 CompilerInvocation::StringAllocator SA) {\n  const MigratorOptions &MigratorOpts = Opts;\n\n#define MIGRATOR_OPTION_WITH_MARSHALLING(                                      \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef MIGRATOR_OPTION_WITH_MARSHALLING\n}\n\nstatic bool ParseMigratorArgs(MigratorOptions &Opts, const ArgList &Args,\n                              DiagnosticsEngine &Diags) {\n  MigratorOptions &MigratorOpts = Opts;\n  bool Success = true;\n\n#define MIGRATOR_OPTION_WITH_MARSHALLING(                                      \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef MIGRATOR_OPTION_WITH_MARSHALLING\n\n  return Success;\n}\n\nvoid CompilerInvocation::GenerateDiagnosticArgs(\n    const DiagnosticOptions &Opts, SmallVectorImpl<const char *> &Args,\n    StringAllocator SA, bool DefaultDiagColor) {\n  const DiagnosticOptions *DiagnosticOpts = &Opts;\n#define DIAG_OPTION_WITH_MARSHALLING(                                          \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef DIAG_OPTION_WITH_MARSHALLING\n\n  if (!Opts.DiagnosticSerializationFile.empty())\n    GenerateArg(Args, OPT_diagnostic_serialized_file,\n                Opts.DiagnosticSerializationFile, SA);\n\n  if (Opts.ShowColors)\n    GenerateArg(Args, OPT_fcolor_diagnostics, SA);\n\n  if (Opts.VerifyDiagnostics &&\n      llvm::is_contained(Opts.VerifyPrefixes, \"expected\"))\n    GenerateArg(Args, OPT_verify, SA);\n\n  for (const auto &Prefix : Opts.VerifyPrefixes)\n    if (Prefix != \"expected\")\n      GenerateArg(Args, OPT_verify_EQ, Prefix, SA);\n\n  DiagnosticLevelMask VIU = Opts.getVerifyIgnoreUnexpected();\n  if (VIU == DiagnosticLevelMask::None) {\n    // This is the default, don't generate anything.\n  } else if (VIU == DiagnosticLevelMask::All) {\n    GenerateArg(Args, OPT_verify_ignore_unexpected, SA);\n  } else {\n    if (static_cast<unsigned>(VIU & DiagnosticLevelMask::Note) != 0)\n      GenerateArg(Args, OPT_verify_ignore_unexpected_EQ, \"note\", SA);\n    if (static_cast<unsigned>(VIU & DiagnosticLevelMask::Remark) != 0)\n      GenerateArg(Args, OPT_verify_ignore_unexpected_EQ, \"remark\", SA);\n    if (static_cast<unsigned>(VIU & DiagnosticLevelMask::Warning) != 0)\n      GenerateArg(Args, OPT_verify_ignore_unexpected_EQ, \"warning\", SA);\n    if (static_cast<unsigned>(VIU & DiagnosticLevelMask::Error) != 0)\n      GenerateArg(Args, OPT_verify_ignore_unexpected_EQ, \"error\", SA);\n  }\n\n  for (const auto &Warning : Opts.Warnings) {\n    // This option is automatically generated from UndefPrefixes.\n    if (Warning == \"undef-prefix\")\n      continue;\n    Args.push_back(SA(StringRef(\"-W\") + Warning));\n  }\n\n  for (const auto &Remark : Opts.Remarks) {\n    // These arguments are generated from OptimizationRemark fields of\n    // CodeGenOptions.\n    StringRef IgnoredRemarks[] = {\"pass\",          \"no-pass\",\n                                  \"pass-analysis\", \"no-pass-analysis\",\n                                  \"pass-missed\",   \"no-pass-missed\"};\n    if (llvm::is_contained(IgnoredRemarks, Remark))\n      continue;\n\n    Args.push_back(SA(StringRef(\"-R\") + Remark));\n  }\n}\n\nbool clang::ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,\n                                DiagnosticsEngine *Diags,\n                                bool DefaultDiagColor) {\n  Optional<DiagnosticsEngine> IgnoringDiags;\n  if (!Diags) {\n    IgnoringDiags.emplace(new DiagnosticIDs(), new DiagnosticOptions(),\n                          new IgnoringDiagConsumer());\n    Diags = &*IgnoringDiags;\n  }\n\n  // The key paths of diagnostic options defined in Options.td start with\n  // \"DiagnosticOpts->\". Let's provide the expected variable name and type.\n  DiagnosticOptions *DiagnosticOpts = &Opts;\n  bool Success = true;\n\n#define DIAG_OPTION_WITH_MARSHALLING(                                          \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, *Diags, Success, ID, FLAGS, PARAM,       \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef DIAG_OPTION_WITH_MARSHALLING\n\n  llvm::sys::Process::UseANSIEscapeCodes(Opts.UseANSIEscapeCodes);\n\n  if (Arg *A =\n          Args.getLastArg(OPT_diagnostic_serialized_file, OPT__serialize_diags))\n    Opts.DiagnosticSerializationFile = A->getValue();\n  Opts.ShowColors = parseShowColorsArgs(Args, DefaultDiagColor);\n\n  Opts.VerifyDiagnostics = Args.hasArg(OPT_verify) || Args.hasArg(OPT_verify_EQ);\n  Opts.VerifyPrefixes = Args.getAllArgValues(OPT_verify_EQ);\n  if (Args.hasArg(OPT_verify))\n    Opts.VerifyPrefixes.push_back(\"expected\");\n  // Keep VerifyPrefixes in its original order for the sake of diagnostics, and\n  // then sort it to prepare for fast lookup using std::binary_search.\n  if (!checkVerifyPrefixes(Opts.VerifyPrefixes, *Diags)) {\n    Opts.VerifyDiagnostics = false;\n    Success = false;\n  }\n  else\n    llvm::sort(Opts.VerifyPrefixes);\n  DiagnosticLevelMask DiagMask = DiagnosticLevelMask::None;\n  Success &= parseDiagnosticLevelMask(\"-verify-ignore-unexpected=\",\n    Args.getAllArgValues(OPT_verify_ignore_unexpected_EQ),\n    *Diags, DiagMask);\n  if (Args.hasArg(OPT_verify_ignore_unexpected))\n    DiagMask = DiagnosticLevelMask::All;\n  Opts.setVerifyIgnoreUnexpected(DiagMask);\n  if (Opts.TabStop == 0 || Opts.TabStop > DiagnosticOptions::MaxTabStop) {\n    Opts.TabStop = DiagnosticOptions::DefaultTabStop;\n    Diags->Report(diag::warn_ignoring_ftabstop_value)\n        << Opts.TabStop << DiagnosticOptions::DefaultTabStop;\n  }\n\n  addDiagnosticArgs(Args, OPT_W_Group, OPT_W_value_Group, Opts.Warnings);\n  addDiagnosticArgs(Args, OPT_R_Group, OPT_R_value_Group, Opts.Remarks);\n\n  return Success;\n}\n\n/// Parse the argument to the -ftest-module-file-extension\n/// command-line argument.\n///\n/// \\returns true on error, false on success.\nstatic bool parseTestModuleFileExtensionArg(StringRef Arg,\n                                            std::string &BlockName,\n                                            unsigned &MajorVersion,\n                                            unsigned &MinorVersion,\n                                            bool &Hashed,\n                                            std::string &UserInfo) {\n  SmallVector<StringRef, 5> Args;\n  Arg.split(Args, ':', 5);\n  if (Args.size() < 5)\n    return true;\n\n  BlockName = std::string(Args[0]);\n  if (Args[1].getAsInteger(10, MajorVersion)) return true;\n  if (Args[2].getAsInteger(10, MinorVersion)) return true;\n  if (Args[3].getAsInteger(2, Hashed)) return true;\n  if (Args.size() > 4)\n    UserInfo = std::string(Args[4]);\n  return false;\n}\n\n/// Return a table that associates command line option specifiers with the\n/// frontend action. Note: The pair {frontend::PluginAction, OPT_plugin} is\n/// intentionally missing, as this case is handled separately from other\n/// frontend options.\nstatic const auto &getFrontendActionTable() {\n  static const std::pair<frontend::ActionKind, unsigned> Table[] = {\n      {frontend::ASTDeclList, OPT_ast_list},\n\n      {frontend::ASTDump, OPT_ast_dump_all_EQ},\n      {frontend::ASTDump, OPT_ast_dump_all},\n      {frontend::ASTDump, OPT_ast_dump_EQ},\n      {frontend::ASTDump, OPT_ast_dump},\n      {frontend::ASTDump, OPT_ast_dump_lookups},\n      {frontend::ASTDump, OPT_ast_dump_decl_types},\n\n      {frontend::ASTPrint, OPT_ast_print},\n      {frontend::ASTView, OPT_ast_view},\n      {frontend::DumpCompilerOptions, OPT_compiler_options_dump},\n      {frontend::DumpRawTokens, OPT_dump_raw_tokens},\n      {frontend::DumpTokens, OPT_dump_tokens},\n      {frontend::EmitAssembly, OPT_S},\n      {frontend::EmitBC, OPT_emit_llvm_bc},\n      {frontend::EmitHTML, OPT_emit_html},\n      {frontend::EmitLLVM, OPT_emit_llvm},\n      {frontend::EmitLLVMOnly, OPT_emit_llvm_only},\n      {frontend::EmitCodeGenOnly, OPT_emit_codegen_only},\n      {frontend::EmitCodeGenOnly, OPT_emit_codegen_only},\n      {frontend::EmitObj, OPT_emit_obj},\n\n      {frontend::FixIt, OPT_fixit_EQ},\n      {frontend::FixIt, OPT_fixit},\n\n      {frontend::GenerateModule, OPT_emit_module},\n      {frontend::GenerateModuleInterface, OPT_emit_module_interface},\n      {frontend::GenerateHeaderModule, OPT_emit_header_module},\n      {frontend::GeneratePCH, OPT_emit_pch},\n      {frontend::GenerateInterfaceStubs, OPT_emit_interface_stubs},\n      {frontend::InitOnly, OPT_init_only},\n      {frontend::ParseSyntaxOnly, OPT_fsyntax_only},\n      {frontend::ModuleFileInfo, OPT_module_file_info},\n      {frontend::VerifyPCH, OPT_verify_pch},\n      {frontend::PrintPreamble, OPT_print_preamble},\n      {frontend::PrintPreprocessedInput, OPT_E},\n      {frontend::TemplightDump, OPT_templight_dump},\n      {frontend::RewriteMacros, OPT_rewrite_macros},\n      {frontend::RewriteObjC, OPT_rewrite_objc},\n      {frontend::RewriteTest, OPT_rewrite_test},\n      {frontend::RunAnalysis, OPT_analyze},\n      {frontend::MigrateSource, OPT_migrate},\n      {frontend::RunPreprocessorOnly, OPT_Eonly},\n      {frontend::PrintDependencyDirectivesSourceMinimizerOutput,\n          OPT_print_dependency_directives_minimized_source},\n  };\n\n  return Table;\n}\n\n/// Maps command line option to frontend action.\nstatic Optional<frontend::ActionKind> getFrontendAction(OptSpecifier &Opt) {\n  for (const auto &ActionOpt : getFrontendActionTable())\n    if (ActionOpt.second == Opt.getID())\n      return ActionOpt.first;\n\n  return None;\n}\n\n/// Maps frontend action to command line option.\nstatic Optional<OptSpecifier>\ngetProgramActionOpt(frontend::ActionKind ProgramAction) {\n  for (const auto &ActionOpt : getFrontendActionTable())\n    if (ActionOpt.first == ProgramAction)\n      return OptSpecifier(ActionOpt.second);\n\n  return None;\n}\n\nstatic void GenerateFrontendArgs(const FrontendOptions &Opts,\n                                 SmallVectorImpl<const char *> &Args,\n                                 CompilerInvocation::StringAllocator SA,\n                                 bool IsHeader) {\n  const FrontendOptions &FrontendOpts = Opts;\n#define FRONTEND_OPTION_WITH_MARSHALLING(                                      \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef FRONTEND_OPTION_WITH_MARSHALLING\n\n  Optional<OptSpecifier> ProgramActionOpt =\n      getProgramActionOpt(Opts.ProgramAction);\n\n  // Generating a simple flag covers most frontend actions.\n  std::function<void()> GenerateProgramAction = [&]() {\n    GenerateArg(Args, *ProgramActionOpt, SA);\n  };\n\n  if (!ProgramActionOpt) {\n    // PluginAction is the only program action handled separately.\n    assert(Opts.ProgramAction == frontend::PluginAction &&\n           \"Frontend action without option.\");\n    GenerateProgramAction = [&]() {\n      GenerateArg(Args, OPT_plugin, Opts.ActionName, SA);\n    };\n  }\n\n  // FIXME: Simplify the complex 'AST dump' command line.\n  if (Opts.ProgramAction == frontend::ASTDump) {\n    GenerateProgramAction = [&]() {\n      // ASTDumpLookups, ASTDumpDeclTypes and ASTDumpFilter are generated via\n      // marshalling infrastructure.\n\n      if (Opts.ASTDumpFormat != ADOF_Default) {\n        StringRef Format;\n        switch (Opts.ASTDumpFormat) {\n        case ADOF_Default:\n          llvm_unreachable(\"Default AST dump format.\");\n        case ADOF_JSON:\n          Format = \"json\";\n          break;\n        }\n\n        if (Opts.ASTDumpAll)\n          GenerateArg(Args, OPT_ast_dump_all_EQ, Format, SA);\n        if (Opts.ASTDumpDecls)\n          GenerateArg(Args, OPT_ast_dump_EQ, Format, SA);\n      } else {\n        if (Opts.ASTDumpAll)\n          GenerateArg(Args, OPT_ast_dump_all, SA);\n        if (Opts.ASTDumpDecls)\n          GenerateArg(Args, OPT_ast_dump, SA);\n      }\n    };\n  }\n\n  if (Opts.ProgramAction == frontend::FixIt && !Opts.FixItSuffix.empty()) {\n    GenerateProgramAction = [&]() {\n      GenerateArg(Args, OPT_fixit_EQ, Opts.FixItSuffix, SA);\n    };\n  }\n\n  GenerateProgramAction();\n\n  for (const auto &PluginArgs : Opts.PluginArgs)\n    for (const auto &PluginArg : PluginArgs.second)\n      GenerateArg(Args, OPT_plugin_arg, PluginArgs.first + PluginArg, SA);\n\n  for (const auto &Ext : Opts.ModuleFileExtensions)\n    if (auto *TestExt = dyn_cast_or_null<TestModuleFileExtension>(Ext.get()))\n      GenerateArg(Args, OPT_ftest_module_file_extension_EQ, TestExt->str(), SA);\n\n  if (!Opts.CodeCompletionAt.FileName.empty())\n    GenerateArg(Args, OPT_code_completion_at, Opts.CodeCompletionAt.ToString(),\n                SA);\n\n  for (const auto &Plugin : Opts.Plugins)\n    GenerateArg(Args, OPT_load, Plugin, SA);\n\n  // ASTDumpDecls and ASTDumpAll already handled with ProgramAction.\n\n  for (const auto &ModuleFile : Opts.ModuleFiles)\n    GenerateArg(Args, OPT_fmodule_file, ModuleFile, SA);\n\n  if (Opts.AuxTargetCPU.hasValue())\n    GenerateArg(Args, OPT_aux_target_cpu, *Opts.AuxTargetCPU, SA);\n\n  if (Opts.AuxTargetFeatures.hasValue())\n    for (const auto &Feature : *Opts.AuxTargetFeatures)\n      GenerateArg(Args, OPT_aux_target_feature, Feature, SA);\n\n  {\n    StringRef Preprocessed = Opts.DashX.isPreprocessed() ? \"-cpp-output\" : \"\";\n    StringRef ModuleMap =\n        Opts.DashX.getFormat() == InputKind::ModuleMap ? \"-module-map\" : \"\";\n    StringRef Header = IsHeader ? \"-header\" : \"\";\n\n    StringRef Lang;\n    switch (Opts.DashX.getLanguage()) {\n    case Language::C:\n      Lang = \"c\";\n      break;\n    case Language::OpenCL:\n      Lang = \"cl\";\n      break;\n    case Language::CUDA:\n      Lang = \"cuda\";\n      break;\n    case Language::HIP:\n      Lang = \"hip\";\n      break;\n    case Language::CXX:\n      Lang = \"c++\";\n      break;\n    case Language::ObjC:\n      Lang = \"objective-c\";\n      break;\n    case Language::ObjCXX:\n      Lang = \"objective-c++\";\n      break;\n    case Language::RenderScript:\n      Lang = \"renderscript\";\n      break;\n    case Language::Asm:\n      Lang = \"assembler-with-cpp\";\n      break;\n    case Language::Unknown:\n      assert(Opts.DashX.getFormat() == InputKind::Precompiled &&\n             \"Generating -x argument for unknown language (not precompiled).\");\n      Lang = \"ast\";\n      break;\n    case Language::LLVM_IR:\n      Lang = \"ir\";\n      break;\n    }\n\n    GenerateArg(Args, OPT_x, Lang + Header + ModuleMap + Preprocessed, SA);\n  }\n\n  // OPT_INPUT has a unique class, generate it directly.\n  for (const auto &Input : Opts.Inputs)\n    Args.push_back(SA(Input.getFile()));\n}\n\nstatic bool ParseFrontendArgs(FrontendOptions &Opts, ArgList &Args,\n                              DiagnosticsEngine &Diags, bool &IsHeaderFile) {\n  FrontendOptions &FrontendOpts = Opts;\n  bool Success = true;\n  unsigned NumErrorsBefore = Diags.getNumErrors();\n#define FRONTEND_OPTION_WITH_MARSHALLING(                                      \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef FRONTEND_OPTION_WITH_MARSHALLING\n\n  Opts.ProgramAction = frontend::ParseSyntaxOnly;\n  if (const Arg *A = Args.getLastArg(OPT_Action_Group)) {\n    OptSpecifier Opt = OptSpecifier(A->getOption().getID());\n    Optional<frontend::ActionKind> ProgramAction = getFrontendAction(Opt);\n    assert(ProgramAction && \"Option specifier not in Action_Group.\");\n\n    if (ProgramAction == frontend::ASTDump &&\n        (Opt == OPT_ast_dump_all_EQ || Opt == OPT_ast_dump_EQ)) {\n      unsigned Val = llvm::StringSwitch<unsigned>(A->getValue())\n                         .CaseLower(\"default\", ADOF_Default)\n                         .CaseLower(\"json\", ADOF_JSON)\n                         .Default(std::numeric_limits<unsigned>::max());\n\n      if (Val != std::numeric_limits<unsigned>::max())\n        Opts.ASTDumpFormat = static_cast<ASTDumpOutputFormat>(Val);\n      else {\n        Diags.Report(diag::err_drv_invalid_value)\n            << A->getAsString(Args) << A->getValue();\n        Opts.ASTDumpFormat = ADOF_Default;\n      }\n    }\n\n    if (ProgramAction == frontend::FixIt && Opt == OPT_fixit_EQ)\n      Opts.FixItSuffix = A->getValue();\n\n    if (ProgramAction == frontend::GenerateInterfaceStubs) {\n      StringRef ArgStr =\n          Args.hasArg(OPT_interface_stub_version_EQ)\n              ? Args.getLastArgValue(OPT_interface_stub_version_EQ)\n              : \"experimental-ifs-v2\";\n      if (ArgStr == \"experimental-yaml-elf-v1\" ||\n          ArgStr == \"experimental-ifs-v1\" ||\n          ArgStr == \"experimental-tapi-elf-v1\") {\n        std::string ErrorMessage =\n            \"Invalid interface stub format: \" + ArgStr.str() +\n            \" is deprecated.\";\n        Diags.Report(diag::err_drv_invalid_value)\n            << \"Must specify a valid interface stub format type, ie: \"\n               \"-interface-stub-version=experimental-ifs-v2\"\n            << ErrorMessage;\n        ProgramAction = frontend::ParseSyntaxOnly;\n      } else if (!ArgStr.startswith(\"experimental-ifs-\")) {\n        std::string ErrorMessage =\n            \"Invalid interface stub format: \" + ArgStr.str() + \".\";\n        Diags.Report(diag::err_drv_invalid_value)\n            << \"Must specify a valid interface stub format type, ie: \"\n               \"-interface-stub-version=experimental-ifs-v2\"\n            << ErrorMessage;\n        ProgramAction = frontend::ParseSyntaxOnly;\n      }\n    }\n\n    Opts.ProgramAction = *ProgramAction;\n  }\n\n  if (const Arg* A = Args.getLastArg(OPT_plugin)) {\n    Opts.Plugins.emplace_back(A->getValue(0));\n    Opts.ProgramAction = frontend::PluginAction;\n    Opts.ActionName = A->getValue();\n  }\n  for (const auto *AA : Args.filtered(OPT_plugin_arg))\n    Opts.PluginArgs[AA->getValue(0)].emplace_back(AA->getValue(1));\n\n  for (const std::string &Arg :\n         Args.getAllArgValues(OPT_ftest_module_file_extension_EQ)) {\n    std::string BlockName;\n    unsigned MajorVersion;\n    unsigned MinorVersion;\n    bool Hashed;\n    std::string UserInfo;\n    if (parseTestModuleFileExtensionArg(Arg, BlockName, MajorVersion,\n                                        MinorVersion, Hashed, UserInfo)) {\n      Diags.Report(diag::err_test_module_file_extension_format) << Arg;\n\n      continue;\n    }\n\n    // Add the testing module file extension.\n    Opts.ModuleFileExtensions.push_back(\n        std::make_shared<TestModuleFileExtension>(\n            BlockName, MajorVersion, MinorVersion, Hashed, UserInfo));\n  }\n\n  if (const Arg *A = Args.getLastArg(OPT_code_completion_at)) {\n    Opts.CodeCompletionAt =\n      ParsedSourceLocation::FromString(A->getValue());\n    if (Opts.CodeCompletionAt.FileName.empty())\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << A->getValue();\n  }\n\n  Opts.Plugins = Args.getAllArgValues(OPT_load);\n  Opts.ASTDumpDecls = Args.hasArg(OPT_ast_dump, OPT_ast_dump_EQ);\n  Opts.ASTDumpAll = Args.hasArg(OPT_ast_dump_all, OPT_ast_dump_all_EQ);\n  // Only the -fmodule-file=<file> form.\n  for (const auto *A : Args.filtered(OPT_fmodule_file)) {\n    StringRef Val = A->getValue();\n    if (Val.find('=') == StringRef::npos)\n      Opts.ModuleFiles.push_back(std::string(Val));\n  }\n\n  if (Opts.ProgramAction != frontend::GenerateModule && Opts.IsSystemModule)\n    Diags.Report(diag::err_drv_argument_only_allowed_with) << \"-fsystem-module\"\n                                                           << \"-emit-module\";\n\n  if (Args.hasArg(OPT_aux_target_cpu))\n    Opts.AuxTargetCPU = std::string(Args.getLastArgValue(OPT_aux_target_cpu));\n  if (Args.hasArg(OPT_aux_target_feature))\n    Opts.AuxTargetFeatures = Args.getAllArgValues(OPT_aux_target_feature);\n\n  if (Opts.ARCMTAction != FrontendOptions::ARCMT_None &&\n      Opts.ObjCMTAction != FrontendOptions::ObjCMT_None) {\n    Diags.Report(diag::err_drv_argument_not_allowed_with)\n      << \"ARC migration\" << \"ObjC migration\";\n  }\n\n  InputKind DashX(Language::Unknown);\n  if (const Arg *A = Args.getLastArg(OPT_x)) {\n    StringRef XValue = A->getValue();\n\n    // Parse suffixes: '<lang>(-header|[-module-map][-cpp-output])'.\n    // FIXME: Supporting '<lang>-header-cpp-output' would be useful.\n    bool Preprocessed = XValue.consume_back(\"-cpp-output\");\n    bool ModuleMap = XValue.consume_back(\"-module-map\");\n    IsHeaderFile = !Preprocessed && !ModuleMap &&\n                   XValue != \"precompiled-header\" &&\n                   XValue.consume_back(\"-header\");\n\n    // Principal languages.\n    DashX = llvm::StringSwitch<InputKind>(XValue)\n                .Case(\"c\", Language::C)\n                .Case(\"cl\", Language::OpenCL)\n                .Case(\"cuda\", Language::CUDA)\n                .Case(\"hip\", Language::HIP)\n                .Case(\"c++\", Language::CXX)\n                .Case(\"objective-c\", Language::ObjC)\n                .Case(\"objective-c++\", Language::ObjCXX)\n                .Case(\"renderscript\", Language::RenderScript)\n                .Default(Language::Unknown);\n\n    // \"objc[++]-cpp-output\" is an acceptable synonym for\n    // \"objective-c[++]-cpp-output\".\n    if (DashX.isUnknown() && Preprocessed && !IsHeaderFile && !ModuleMap)\n      DashX = llvm::StringSwitch<InputKind>(XValue)\n                  .Case(\"objc\", Language::ObjC)\n                  .Case(\"objc++\", Language::ObjCXX)\n                  .Default(Language::Unknown);\n\n    // Some special cases cannot be combined with suffixes.\n    if (DashX.isUnknown() && !Preprocessed && !ModuleMap && !IsHeaderFile)\n      DashX = llvm::StringSwitch<InputKind>(XValue)\n                  .Case(\"cpp-output\", InputKind(Language::C).getPreprocessed())\n                  .Case(\"assembler-with-cpp\", Language::Asm)\n                  .Cases(\"ast\", \"pcm\", \"precompiled-header\",\n                         InputKind(Language::Unknown, InputKind::Precompiled))\n                  .Case(\"ir\", Language::LLVM_IR)\n                  .Default(Language::Unknown);\n\n    if (DashX.isUnknown())\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << A->getValue();\n\n    if (Preprocessed)\n      DashX = DashX.getPreprocessed();\n    if (ModuleMap)\n      DashX = DashX.withFormat(InputKind::ModuleMap);\n  }\n\n  // '-' is the default input if none is given.\n  std::vector<std::string> Inputs = Args.getAllArgValues(OPT_INPUT);\n  Opts.Inputs.clear();\n  if (Inputs.empty())\n    Inputs.push_back(\"-\");\n  for (unsigned i = 0, e = Inputs.size(); i != e; ++i) {\n    InputKind IK = DashX;\n    if (IK.isUnknown()) {\n      IK = FrontendOptions::getInputKindForExtension(\n        StringRef(Inputs[i]).rsplit('.').second);\n      // FIXME: Warn on this?\n      if (IK.isUnknown())\n        IK = Language::C;\n      // FIXME: Remove this hack.\n      if (i == 0)\n        DashX = IK;\n    }\n\n    bool IsSystem = false;\n\n    // The -emit-module action implicitly takes a module map.\n    if (Opts.ProgramAction == frontend::GenerateModule &&\n        IK.getFormat() == InputKind::Source) {\n      IK = IK.withFormat(InputKind::ModuleMap);\n      IsSystem = Opts.IsSystemModule;\n    }\n\n    Opts.Inputs.emplace_back(std::move(Inputs[i]), IK, IsSystem);\n  }\n\n  Opts.DashX = DashX;\n\n  return Diags.getNumErrors() == NumErrorsBefore;\n}\n\nstd::string CompilerInvocation::GetResourcesPath(const char *Argv0,\n                                                 void *MainAddr) {\n  std::string ClangExecutable =\n      llvm::sys::fs::getMainExecutable(Argv0, MainAddr);\n  return Driver::GetResourcesPath(ClangExecutable, CLANG_RESOURCE_DIR);\n}\n\nstatic void GenerateHeaderSearchArgs(HeaderSearchOptions &Opts,\n                                     SmallVectorImpl<const char *> &Args,\n                                     CompilerInvocation::StringAllocator SA) {\n  const HeaderSearchOptions *HeaderSearchOpts = &Opts;\n#define HEADER_SEARCH_OPTION_WITH_MARSHALLING(                                 \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef HEADER_SEARCH_OPTION_WITH_MARSHALLING\n\n  if (Opts.UseLibcxx)\n    GenerateArg(Args, OPT_stdlib_EQ, \"libc++\", SA);\n\n  if (!Opts.ModuleCachePath.empty())\n    GenerateArg(Args, OPT_fmodules_cache_path, Opts.ModuleCachePath, SA);\n\n  for (const auto &File : Opts.PrebuiltModuleFiles)\n    GenerateArg(Args, OPT_fmodule_file, File.first + \"=\" + File.second, SA);\n\n  for (const auto &Path : Opts.PrebuiltModulePaths)\n    GenerateArg(Args, OPT_fprebuilt_module_path, Path, SA);\n\n  for (const auto &Macro : Opts.ModulesIgnoreMacros)\n    GenerateArg(Args, OPT_fmodules_ignore_macro, Macro.val(), SA);\n\n  auto Matches = [](const HeaderSearchOptions::Entry &Entry,\n                    llvm::ArrayRef<frontend::IncludeDirGroup> Groups,\n                    llvm::Optional<bool> IsFramework,\n                    llvm::Optional<bool> IgnoreSysRoot) {\n    return llvm::find(Groups, Entry.Group) != Groups.end() &&\n           (!IsFramework || (Entry.IsFramework == *IsFramework)) &&\n           (!IgnoreSysRoot || (Entry.IgnoreSysRoot == *IgnoreSysRoot));\n  };\n\n  auto It = Opts.UserEntries.begin();\n  auto End = Opts.UserEntries.end();\n\n  // Add -I..., -F..., and -index-header-map options in order.\n  for (; It < End &&\n         Matches(*It, {frontend::IndexHeaderMap, frontend::Angled}, None, true);\n       ++It) {\n    OptSpecifier Opt = [It, Matches]() {\n      if (Matches(*It, frontend::IndexHeaderMap, true, true))\n        return OPT_F;\n      if (Matches(*It, frontend::IndexHeaderMap, false, true))\n        return OPT_I;\n      if (Matches(*It, frontend::Angled, true, true))\n        return OPT_F;\n      if (Matches(*It, frontend::Angled, false, true))\n        return OPT_I;\n      llvm_unreachable(\"Unexpected HeaderSearchOptions::Entry.\");\n    }();\n\n    if (It->Group == frontend::IndexHeaderMap)\n      GenerateArg(Args, OPT_index_header_map, SA);\n    GenerateArg(Args, Opt, It->Path, SA);\n  };\n\n  // Note: some paths that came from \"[-iprefix=xx] -iwithprefixbefore=yy\" may\n  // have already been generated as \"-I[xx]yy\". If that's the case, their\n  // position on command line was such that this has no semantic impact on\n  // include paths.\n  for (; It < End &&\n         Matches(*It, {frontend::After, frontend::Angled}, false, true);\n       ++It) {\n    OptSpecifier Opt =\n        It->Group == frontend::After ? OPT_iwithprefix : OPT_iwithprefixbefore;\n    GenerateArg(Args, Opt, It->Path, SA);\n  }\n\n  // Note: Some paths that came from \"-idirafter=xxyy\" may have already been\n  // generated as \"-iwithprefix=xxyy\". If that's the case, their position on\n  // command line was such that this has no semantic impact on include paths.\n  for (; It < End && Matches(*It, {frontend::After}, false, true); ++It)\n    GenerateArg(Args, OPT_idirafter, It->Path, SA);\n  for (; It < End && Matches(*It, {frontend::Quoted}, false, true); ++It)\n    GenerateArg(Args, OPT_iquote, It->Path, SA);\n  for (; It < End && Matches(*It, {frontend::System}, false, None); ++It)\n    GenerateArg(Args, It->IgnoreSysRoot ? OPT_isystem : OPT_iwithsysroot,\n                It->Path, SA);\n  for (; It < End && Matches(*It, {frontend::System}, true, true); ++It)\n    GenerateArg(Args, OPT_iframework, It->Path, SA);\n  for (; It < End && Matches(*It, {frontend::System}, true, false); ++It)\n    GenerateArg(Args, OPT_iframeworkwithsysroot, It->Path, SA);\n\n  // Add the paths for the various language specific isystem flags.\n  for (; It < End && Matches(*It, {frontend::CSystem}, false, true); ++It)\n    GenerateArg(Args, OPT_c_isystem, It->Path, SA);\n  for (; It < End && Matches(*It, {frontend::CXXSystem}, false, true); ++It)\n    GenerateArg(Args, OPT_cxx_isystem, It->Path, SA);\n  for (; It < End && Matches(*It, {frontend::ObjCSystem}, false, true); ++It)\n    GenerateArg(Args, OPT_objc_isystem, It->Path, SA);\n  for (; It < End && Matches(*It, {frontend::ObjCXXSystem}, false, true); ++It)\n    GenerateArg(Args, OPT_objcxx_isystem, It->Path, SA);\n\n  // Add the internal paths from a driver that detects standard include paths.\n  // Note: Some paths that came from \"-internal-isystem\" arguments may have\n  // already been generated as \"-isystem\". If that's the case, their position on\n  // command line was such that this has no semantic impact on include paths.\n  for (; It < End &&\n         Matches(*It, {frontend::System, frontend::ExternCSystem}, false, true);\n       ++It) {\n    OptSpecifier Opt = It->Group == frontend::System\n                           ? OPT_internal_isystem\n                           : OPT_internal_externc_isystem;\n    GenerateArg(Args, Opt, It->Path, SA);\n  }\n\n  assert(It == End && \"Unhandled HeaderSearchOption::Entry.\");\n\n  // Add the path prefixes which are implicitly treated as being system headers.\n  for (const auto &P : Opts.SystemHeaderPrefixes) {\n    OptSpecifier Opt = P.IsSystemHeader ? OPT_system_header_prefix\n                                        : OPT_no_system_header_prefix;\n    GenerateArg(Args, Opt, P.Prefix, SA);\n  }\n\n  for (const std::string &F : Opts.VFSOverlayFiles)\n    GenerateArg(Args, OPT_ivfsoverlay, F, SA);\n}\n\nstatic bool ParseHeaderSearchArgs(HeaderSearchOptions &Opts, ArgList &Args,\n                                  DiagnosticsEngine &Diags,\n                                  const std::string &WorkingDir) {\n  HeaderSearchOptions *HeaderSearchOpts = &Opts;\n  bool Success = true;\n\n#define HEADER_SEARCH_OPTION_WITH_MARSHALLING(                                 \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef HEADER_SEARCH_OPTION_WITH_MARSHALLING\n\n  if (const Arg *A = Args.getLastArg(OPT_stdlib_EQ))\n    Opts.UseLibcxx = (strcmp(A->getValue(), \"libc++\") == 0);\n\n  // Canonicalize -fmodules-cache-path before storing it.\n  SmallString<128> P(Args.getLastArgValue(OPT_fmodules_cache_path));\n  if (!(P.empty() || llvm::sys::path::is_absolute(P))) {\n    if (WorkingDir.empty())\n      llvm::sys::fs::make_absolute(P);\n    else\n      llvm::sys::fs::make_absolute(WorkingDir, P);\n  }\n  llvm::sys::path::remove_dots(P);\n  Opts.ModuleCachePath = std::string(P.str());\n\n  // Only the -fmodule-file=<name>=<file> form.\n  for (const auto *A : Args.filtered(OPT_fmodule_file)) {\n    StringRef Val = A->getValue();\n    if (Val.find('=') != StringRef::npos){\n      auto Split = Val.split('=');\n      Opts.PrebuiltModuleFiles.insert(\n          {std::string(Split.first), std::string(Split.second)});\n    }\n  }\n  for (const auto *A : Args.filtered(OPT_fprebuilt_module_path))\n    Opts.AddPrebuiltModulePath(A->getValue());\n\n  for (const auto *A : Args.filtered(OPT_fmodules_ignore_macro)) {\n    StringRef MacroDef = A->getValue();\n    Opts.ModulesIgnoreMacros.insert(\n        llvm::CachedHashString(MacroDef.split('=').first));\n  }\n\n  // Add -I..., -F..., and -index-header-map options in order.\n  bool IsIndexHeaderMap = false;\n  bool IsSysrootSpecified =\n      Args.hasArg(OPT__sysroot_EQ) || Args.hasArg(OPT_isysroot);\n  for (const auto *A : Args.filtered(OPT_I, OPT_F, OPT_index_header_map)) {\n    if (A->getOption().matches(OPT_index_header_map)) {\n      // -index-header-map applies to the next -I or -F.\n      IsIndexHeaderMap = true;\n      continue;\n    }\n\n    frontend::IncludeDirGroup Group =\n        IsIndexHeaderMap ? frontend::IndexHeaderMap : frontend::Angled;\n\n    bool IsFramework = A->getOption().matches(OPT_F);\n    std::string Path = A->getValue();\n\n    if (IsSysrootSpecified && !IsFramework && A->getValue()[0] == '=') {\n      SmallString<32> Buffer;\n      llvm::sys::path::append(Buffer, Opts.Sysroot,\n                              llvm::StringRef(A->getValue()).substr(1));\n      Path = std::string(Buffer.str());\n    }\n\n    Opts.AddPath(Path, Group, IsFramework,\n                 /*IgnoreSysroot*/ true);\n    IsIndexHeaderMap = false;\n  }\n\n  // Add -iprefix/-iwithprefix/-iwithprefixbefore options.\n  StringRef Prefix = \"\"; // FIXME: This isn't the correct default prefix.\n  for (const auto *A :\n       Args.filtered(OPT_iprefix, OPT_iwithprefix, OPT_iwithprefixbefore)) {\n    if (A->getOption().matches(OPT_iprefix))\n      Prefix = A->getValue();\n    else if (A->getOption().matches(OPT_iwithprefix))\n      Opts.AddPath(Prefix.str() + A->getValue(), frontend::After, false, true);\n    else\n      Opts.AddPath(Prefix.str() + A->getValue(), frontend::Angled, false, true);\n  }\n\n  for (const auto *A : Args.filtered(OPT_idirafter))\n    Opts.AddPath(A->getValue(), frontend::After, false, true);\n  for (const auto *A : Args.filtered(OPT_iquote))\n    Opts.AddPath(A->getValue(), frontend::Quoted, false, true);\n  for (const auto *A : Args.filtered(OPT_isystem, OPT_iwithsysroot))\n    Opts.AddPath(A->getValue(), frontend::System, false,\n                 !A->getOption().matches(OPT_iwithsysroot));\n  for (const auto *A : Args.filtered(OPT_iframework))\n    Opts.AddPath(A->getValue(), frontend::System, true, true);\n  for (const auto *A : Args.filtered(OPT_iframeworkwithsysroot))\n    Opts.AddPath(A->getValue(), frontend::System, /*IsFramework=*/true,\n                 /*IgnoreSysRoot=*/false);\n\n  // Add the paths for the various language specific isystem flags.\n  for (const auto *A : Args.filtered(OPT_c_isystem))\n    Opts.AddPath(A->getValue(), frontend::CSystem, false, true);\n  for (const auto *A : Args.filtered(OPT_cxx_isystem))\n    Opts.AddPath(A->getValue(), frontend::CXXSystem, false, true);\n  for (const auto *A : Args.filtered(OPT_objc_isystem))\n    Opts.AddPath(A->getValue(), frontend::ObjCSystem, false,true);\n  for (const auto *A : Args.filtered(OPT_objcxx_isystem))\n    Opts.AddPath(A->getValue(), frontend::ObjCXXSystem, false, true);\n\n  // Add the internal paths from a driver that detects standard include paths.\n  for (const auto *A :\n       Args.filtered(OPT_internal_isystem, OPT_internal_externc_isystem)) {\n    frontend::IncludeDirGroup Group = frontend::System;\n    if (A->getOption().matches(OPT_internal_externc_isystem))\n      Group = frontend::ExternCSystem;\n    Opts.AddPath(A->getValue(), Group, false, true);\n  }\n\n  // Add the path prefixes which are implicitly treated as being system headers.\n  for (const auto *A :\n       Args.filtered(OPT_system_header_prefix, OPT_no_system_header_prefix))\n    Opts.AddSystemHeaderPrefix(\n        A->getValue(), A->getOption().matches(OPT_system_header_prefix));\n\n  for (const auto *A : Args.filtered(OPT_ivfsoverlay))\n    Opts.AddVFSOverlayFile(A->getValue());\n\n  return Success;\n}\n\nvoid CompilerInvocation::setLangDefaults(LangOptions &Opts, InputKind IK,\n                                         const llvm::Triple &T,\n                                         std::vector<std::string> &Includes,\n                                         LangStandard::Kind LangStd) {\n  // Set some properties which depend solely on the input kind; it would be nice\n  // to move these to the language standard, and have the driver resolve the\n  // input kind + language standard.\n  //\n  // FIXME: Perhaps a better model would be for a single source file to have\n  // multiple language standards (C / C++ std, ObjC std, OpenCL std, OpenMP std)\n  // simultaneously active?\n  if (IK.getLanguage() == Language::Asm) {\n    Opts.AsmPreprocessor = 1;\n  } else if (IK.isObjectiveC()) {\n    Opts.ObjC = 1;\n  }\n\n  if (LangStd == LangStandard::lang_unspecified) {\n    // Based on the base language, pick one.\n    switch (IK.getLanguage()) {\n    case Language::Unknown:\n    case Language::LLVM_IR:\n      llvm_unreachable(\"Invalid input kind!\");\n    case Language::OpenCL:\n      LangStd = LangStandard::lang_opencl10;\n      break;\n    case Language::CUDA:\n      LangStd = LangStandard::lang_cuda;\n      break;\n    case Language::Asm:\n    case Language::C:\n#if defined(CLANG_DEFAULT_STD_C)\n      LangStd = CLANG_DEFAULT_STD_C;\n#else\n      // The PS4 uses C99 as the default C standard.\n      if (T.isPS4())\n        LangStd = LangStandard::lang_gnu99;\n      else\n        LangStd = LangStandard::lang_gnu17;\n#endif\n      break;\n    case Language::ObjC:\n#if defined(CLANG_DEFAULT_STD_C)\n      LangStd = CLANG_DEFAULT_STD_C;\n#else\n      LangStd = LangStandard::lang_gnu11;\n#endif\n      break;\n    case Language::CXX:\n    case Language::ObjCXX:\n#if defined(CLANG_DEFAULT_STD_CXX)\n      LangStd = CLANG_DEFAULT_STD_CXX;\n#else\n      LangStd = LangStandard::lang_gnucxx14;\n#endif\n      break;\n    case Language::RenderScript:\n      LangStd = LangStandard::lang_c99;\n      break;\n    case Language::HIP:\n      LangStd = LangStandard::lang_hip;\n      break;\n    }\n  }\n\n  const LangStandard &Std = LangStandard::getLangStandardForKind(LangStd);\n  Opts.LangStd = LangStd;\n  Opts.LineComment = Std.hasLineComments();\n  Opts.C99 = Std.isC99();\n  Opts.C11 = Std.isC11();\n  Opts.C17 = Std.isC17();\n  Opts.C2x = Std.isC2x();\n  Opts.CPlusPlus = Std.isCPlusPlus();\n  Opts.CPlusPlus11 = Std.isCPlusPlus11();\n  Opts.CPlusPlus14 = Std.isCPlusPlus14();\n  Opts.CPlusPlus17 = Std.isCPlusPlus17();\n  Opts.CPlusPlus20 = Std.isCPlusPlus20();\n  Opts.CPlusPlus2b = Std.isCPlusPlus2b();\n  Opts.GNUMode = Std.isGNUMode();\n  Opts.GNUCVersion = 0;\n  Opts.HexFloats = Std.hasHexFloats();\n  Opts.ImplicitInt = Std.hasImplicitInt();\n\n  Opts.CPlusPlusModules = Opts.CPlusPlus20;\n\n  // Set OpenCL Version.\n  Opts.OpenCL = Std.isOpenCL();\n  if (LangStd == LangStandard::lang_opencl10)\n    Opts.OpenCLVersion = 100;\n  else if (LangStd == LangStandard::lang_opencl11)\n    Opts.OpenCLVersion = 110;\n  else if (LangStd == LangStandard::lang_opencl12)\n    Opts.OpenCLVersion = 120;\n  else if (LangStd == LangStandard::lang_opencl20)\n    Opts.OpenCLVersion = 200;\n  else if (LangStd == LangStandard::lang_opencl30)\n    Opts.OpenCLVersion = 300;\n  else if (LangStd == LangStandard::lang_openclcpp)\n    Opts.OpenCLCPlusPlusVersion = 100;\n\n  // OpenCL has some additional defaults.\n  if (Opts.OpenCL) {\n    Opts.AltiVec = 0;\n    Opts.ZVector = 0;\n    Opts.setDefaultFPContractMode(LangOptions::FPM_On);\n    Opts.OpenCLCPlusPlus = Opts.CPlusPlus;\n    Opts.OpenCLPipe = Opts.OpenCLCPlusPlus || Opts.OpenCLVersion == 200;\n    Opts.OpenCLGenericAddressSpace =\n        Opts.OpenCLCPlusPlus || Opts.OpenCLVersion == 200;\n\n    // Include default header file for OpenCL.\n    if (Opts.IncludeDefaultHeader) {\n      if (Opts.DeclareOpenCLBuiltins) {\n        // Only include base header file for builtin types and constants.\n        Includes.push_back(\"opencl-c-base.h\");\n      } else {\n        Includes.push_back(\"opencl-c.h\");\n      }\n    }\n  }\n\n  Opts.HIP = IK.getLanguage() == Language::HIP;\n  Opts.CUDA = IK.getLanguage() == Language::CUDA || Opts.HIP;\n  if (Opts.HIP) {\n    // HIP toolchain does not support 'Fast' FPOpFusion in backends since it\n    // fuses multiplication/addition instructions without contract flag from\n    // device library functions in LLVM bitcode, which causes accuracy loss in\n    // certain math functions, e.g. tan(-1e20) becomes -0.933 instead of 0.8446.\n    // For device library functions in bitcode to work, 'Strict' or 'Standard'\n    // FPOpFusion options in backends is needed. Therefore 'fast-honor-pragmas'\n    // FP contract option is used to allow fuse across statements in frontend\n    // whereas respecting contract flag in backend.\n    Opts.setDefaultFPContractMode(LangOptions::FPM_FastHonorPragmas);\n  } else if (Opts.CUDA) {\n    // Allow fuse across statements disregarding pragmas.\n    Opts.setDefaultFPContractMode(LangOptions::FPM_Fast);\n  }\n\n  Opts.RenderScript = IK.getLanguage() == Language::RenderScript;\n\n  // OpenCL and C++ both have bool, true, false keywords.\n  Opts.Bool = Opts.OpenCL || Opts.CPlusPlus;\n\n  // OpenCL has half keyword\n  Opts.Half = Opts.OpenCL;\n}\n\n/// Check if input file kind and language standard are compatible.\nstatic bool IsInputCompatibleWithStandard(InputKind IK,\n                                          const LangStandard &S) {\n  switch (IK.getLanguage()) {\n  case Language::Unknown:\n  case Language::LLVM_IR:\n    llvm_unreachable(\"should not parse language flags for this input\");\n\n  case Language::C:\n  case Language::ObjC:\n  case Language::RenderScript:\n    return S.getLanguage() == Language::C;\n\n  case Language::OpenCL:\n    return S.getLanguage() == Language::OpenCL;\n\n  case Language::CXX:\n  case Language::ObjCXX:\n    return S.getLanguage() == Language::CXX;\n\n  case Language::CUDA:\n    // FIXME: What -std= values should be permitted for CUDA compilations?\n    return S.getLanguage() == Language::CUDA ||\n           S.getLanguage() == Language::CXX;\n\n  case Language::HIP:\n    return S.getLanguage() == Language::CXX || S.getLanguage() == Language::HIP;\n\n  case Language::Asm:\n    // Accept (and ignore) all -std= values.\n    // FIXME: The -std= value is not ignored; it affects the tokenization\n    // and preprocessing rules if we're preprocessing this asm input.\n    return true;\n  }\n\n  llvm_unreachable(\"unexpected input language\");\n}\n\n/// Get language name for given input kind.\nstatic const StringRef GetInputKindName(InputKind IK) {\n  switch (IK.getLanguage()) {\n  case Language::C:\n    return \"C\";\n  case Language::ObjC:\n    return \"Objective-C\";\n  case Language::CXX:\n    return \"C++\";\n  case Language::ObjCXX:\n    return \"Objective-C++\";\n  case Language::OpenCL:\n    return \"OpenCL\";\n  case Language::CUDA:\n    return \"CUDA\";\n  case Language::RenderScript:\n    return \"RenderScript\";\n  case Language::HIP:\n    return \"HIP\";\n\n  case Language::Asm:\n    return \"Asm\";\n  case Language::LLVM_IR:\n    return \"LLVM IR\";\n\n  case Language::Unknown:\n    break;\n  }\n  llvm_unreachable(\"unknown input language\");\n}\n\nvoid CompilerInvocation::GenerateLangArgs(const LangOptions &Opts,\n                                          SmallVectorImpl<const char *> &Args,\n                                          StringAllocator SA,\n                                          const llvm::Triple &T) {\n  OptSpecifier StdOpt;\n  switch (Opts.LangStd) {\n  case LangStandard::lang_opencl10:\n  case LangStandard::lang_opencl11:\n  case LangStandard::lang_opencl12:\n  case LangStandard::lang_opencl20:\n  case LangStandard::lang_opencl30:\n  case LangStandard::lang_openclcpp:\n    StdOpt = OPT_cl_std_EQ;\n    break;\n  default:\n    StdOpt = OPT_std_EQ;\n    break;\n  }\n\n  auto LangStandard = LangStandard::getLangStandardForKind(Opts.LangStd);\n  GenerateArg(Args, StdOpt, LangStandard.getName(), SA);\n\n  if (Opts.IncludeDefaultHeader)\n    GenerateArg(Args, OPT_finclude_default_header, SA);\n  if (Opts.DeclareOpenCLBuiltins)\n    GenerateArg(Args, OPT_fdeclare_opencl_builtins, SA);\n\n  const LangOptions *LangOpts = &Opts;\n\n#define LANG_OPTION_WITH_MARSHALLING(                                          \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef LANG_OPTION_WITH_MARSHALLING\n\n  // The '-fcf-protection=' option is generated by CodeGenOpts generator.\n\n  if (Opts.ObjC) {\n    GenerateArg(Args, OPT_fobjc_runtime_EQ, Opts.ObjCRuntime.getAsString(), SA);\n\n    if (Opts.GC == LangOptions::GCOnly)\n      GenerateArg(Args, OPT_fobjc_gc_only, SA);\n    else if (Opts.GC == LangOptions::HybridGC)\n      GenerateArg(Args, OPT_fobjc_gc, SA);\n    else if (Opts.ObjCAutoRefCount == 1)\n      GenerateArg(Args, OPT_fobjc_arc, SA);\n\n    if (Opts.ObjCWeakRuntime)\n      GenerateArg(Args, OPT_fobjc_runtime_has_weak, SA);\n\n    if (Opts.ObjCWeak)\n      GenerateArg(Args, OPT_fobjc_weak, SA);\n\n    if (Opts.ObjCSubscriptingLegacyRuntime)\n      GenerateArg(Args, OPT_fobjc_subscripting_legacy_runtime, SA);\n  }\n\n  if (Opts.GNUCVersion != 0) {\n    unsigned Major = Opts.GNUCVersion / 100 / 100;\n    unsigned Minor = (Opts.GNUCVersion / 100) % 100;\n    unsigned Patch = Opts.GNUCVersion % 100;\n    GenerateArg(Args, OPT_fgnuc_version_EQ,\n                Twine(Major) + \".\" + Twine(Minor) + \".\" + Twine(Patch), SA);\n  }\n\n  if (Opts.IgnoreXCOFFVisibility)\n    GenerateArg(Args, OPT_mignore_xcoff_visibility, SA);\n\n  if (Opts.SignedOverflowBehavior == LangOptions::SOB_Trapping) {\n    GenerateArg(Args, OPT_ftrapv, SA);\n    GenerateArg(Args, OPT_ftrapv_handler, Opts.OverflowHandler, SA);\n  } else if (Opts.SignedOverflowBehavior == LangOptions::SOB_Defined) {\n    GenerateArg(Args, OPT_fwrapv, SA);\n  }\n\n  if (Opts.MSCompatibilityVersion != 0) {\n    unsigned Major = Opts.MSCompatibilityVersion / 10000000;\n    unsigned Minor = (Opts.MSCompatibilityVersion / 100000) % 100;\n    unsigned Subminor = Opts.MSCompatibilityVersion % 100000;\n    GenerateArg(Args, OPT_fms_compatibility_version,\n                Twine(Major) + \".\" + Twine(Minor) + \".\" + Twine(Subminor), SA);\n  }\n\n  if ((!Opts.GNUMode && !Opts.MSVCCompat && !Opts.CPlusPlus17) || T.isOSzOS()) {\n    if (!Opts.Trigraphs)\n      GenerateArg(Args, OPT_fno_trigraphs, SA);\n  } else {\n    if (Opts.Trigraphs)\n      GenerateArg(Args, OPT_ftrigraphs, SA);\n  }\n\n  if (Opts.Blocks && !(Opts.OpenCL && Opts.OpenCLVersion == 200))\n    GenerateArg(Args, OPT_fblocks, SA);\n\n  if (Opts.ConvergentFunctions &&\n      !(Opts.OpenCL || (Opts.CUDA && Opts.CUDAIsDevice) || Opts.SYCLIsDevice))\n    GenerateArg(Args, OPT_fconvergent_functions, SA);\n\n  if (Opts.NoBuiltin && !Opts.Freestanding)\n    GenerateArg(Args, OPT_fno_builtin, SA);\n\n  if (!Opts.NoBuiltin)\n    for (const auto &Func : Opts.NoBuiltinFuncs)\n      GenerateArg(Args, OPT_fno_builtin_, Func, SA);\n\n  if (Opts.LongDoubleSize == 128)\n    GenerateArg(Args, OPT_mlong_double_128, SA);\n  else if (Opts.LongDoubleSize == 64)\n    GenerateArg(Args, OPT_mlong_double_64, SA);\n\n  // Not generating '-mrtd', it's just an alias for '-fdefault-calling-conv='.\n\n  // OpenMP was requested via '-fopenmp', not implied by '-fopenmp-simd' or\n  // '-fopenmp-targets='.\n  if (Opts.OpenMP && !Opts.OpenMPSimd) {\n    GenerateArg(Args, OPT_fopenmp, SA);\n\n    if (Opts.OpenMP != 50)\n      GenerateArg(Args, OPT_fopenmp_version_EQ, Twine(Opts.OpenMP), SA);\n\n    if (!Opts.OpenMPUseTLS)\n      GenerateArg(Args, OPT_fnoopenmp_use_tls, SA);\n\n    if (Opts.OpenMPIsDevice)\n      GenerateArg(Args, OPT_fopenmp_is_device, SA);\n\n    if (Opts.OpenMPIRBuilder)\n      GenerateArg(Args, OPT_fopenmp_enable_irbuilder, SA);\n  }\n\n  if (Opts.OpenMPSimd) {\n    GenerateArg(Args, OPT_fopenmp_simd, SA);\n\n    if (Opts.OpenMP != 50)\n      GenerateArg(Args, OPT_fopenmp_version_EQ, Twine(Opts.OpenMP), SA);\n  }\n\n  if (Opts.OpenMPCUDANumSMs != 0)\n    GenerateArg(Args, OPT_fopenmp_cuda_number_of_sm_EQ,\n                Twine(Opts.OpenMPCUDANumSMs), SA);\n\n  if (Opts.OpenMPCUDABlocksPerSM != 0)\n    GenerateArg(Args, OPT_fopenmp_cuda_blocks_per_sm_EQ,\n                Twine(Opts.OpenMPCUDABlocksPerSM), SA);\n\n  if (Opts.OpenMPCUDAReductionBufNum != 1024)\n    GenerateArg(Args, OPT_fopenmp_cuda_teams_reduction_recs_num_EQ,\n                Twine(Opts.OpenMPCUDAReductionBufNum), SA);\n\n  if (!Opts.OMPTargetTriples.empty()) {\n    std::string Targets;\n    llvm::raw_string_ostream OS(Targets);\n    llvm::interleave(\n        Opts.OMPTargetTriples, OS,\n        [&OS](const llvm::Triple &T) { OS << T.str(); }, \",\");\n    GenerateArg(Args, OPT_fopenmp_targets_EQ, OS.str(), SA);\n  }\n\n  if (!Opts.OMPHostIRFile.empty())\n    GenerateArg(Args, OPT_fopenmp_host_ir_file_path, Opts.OMPHostIRFile, SA);\n\n  if (Opts.OpenMPCUDAMode)\n    GenerateArg(Args, OPT_fopenmp_cuda_mode, SA);\n\n  if (Opts.OpenMPCUDATargetParallel)\n    GenerateArg(Args, OPT_fopenmp_cuda_parallel_target_regions, SA);\n\n  if (Opts.OpenMPCUDAForceFullRuntime)\n    GenerateArg(Args, OPT_fopenmp_cuda_force_full_runtime, SA);\n\n  // The arguments used to set Optimize, OptimizeSize and NoInlineDefine are\n  // generated from CodeGenOptions.\n\n  if (Opts.DefaultFPContractMode == LangOptions::FPM_Fast)\n    GenerateArg(Args, OPT_ffp_contract, \"fast\", SA);\n  else if (Opts.DefaultFPContractMode == LangOptions::FPM_On)\n    GenerateArg(Args, OPT_ffp_contract, \"on\", SA);\n  else if (Opts.DefaultFPContractMode == LangOptions::FPM_Off)\n    GenerateArg(Args, OPT_ffp_contract, \"off\", SA);\n  else if (Opts.DefaultFPContractMode == LangOptions::FPM_FastHonorPragmas)\n    GenerateArg(Args, OPT_ffp_contract, \"fast-honor-pragmas\", SA);\n\n  for (StringRef Sanitizer : serializeSanitizerKinds(Opts.Sanitize))\n    GenerateArg(Args, OPT_fsanitize_EQ, Sanitizer, SA);\n\n  // Conflating '-fsanitize-system-blacklist' and '-fsanitize-blacklist'.\n  for (const std::string &F : Opts.NoSanitizeFiles)\n    GenerateArg(Args, OPT_fsanitize_blacklist, F, SA);\n\n  if (Opts.getClangABICompat() == LangOptions::ClangABI::Ver3_8)\n    GenerateArg(Args, OPT_fclang_abi_compat_EQ, \"3.8\", SA);\n  else if (Opts.getClangABICompat() == LangOptions::ClangABI::Ver4)\n    GenerateArg(Args, OPT_fclang_abi_compat_EQ, \"4.0\", SA);\n  else if (Opts.getClangABICompat() == LangOptions::ClangABI::Ver6)\n    GenerateArg(Args, OPT_fclang_abi_compat_EQ, \"6.0\", SA);\n  else if (Opts.getClangABICompat() == LangOptions::ClangABI::Ver7)\n    GenerateArg(Args, OPT_fclang_abi_compat_EQ, \"7.0\", SA);\n  else if (Opts.getClangABICompat() == LangOptions::ClangABI::Ver9)\n    GenerateArg(Args, OPT_fclang_abi_compat_EQ, \"9.0\", SA);\n  else if (Opts.getClangABICompat() == LangOptions::ClangABI::Ver11)\n    GenerateArg(Args, OPT_fclang_abi_compat_EQ, \"11.0\", SA);\n\n  if (Opts.getSignReturnAddressScope() ==\n      LangOptions::SignReturnAddressScopeKind::All)\n    GenerateArg(Args, OPT_msign_return_address_EQ, \"all\", SA);\n  else if (Opts.getSignReturnAddressScope() ==\n           LangOptions::SignReturnAddressScopeKind::NonLeaf)\n    GenerateArg(Args, OPT_msign_return_address_EQ, \"non-leaf\", SA);\n\n  if (Opts.getSignReturnAddressKey() ==\n      LangOptions::SignReturnAddressKeyKind::BKey)\n    GenerateArg(Args, OPT_msign_return_address_key_EQ, \"b_key\", SA);\n}\n\nbool CompilerInvocation::ParseLangArgs(LangOptions &Opts, ArgList &Args,\n                                       InputKind IK, const llvm::Triple &T,\n                                       std::vector<std::string> &Includes,\n                                       DiagnosticsEngine &Diags) {\n  unsigned NumErrorsBefore = Diags.getNumErrors();\n\n  // FIXME: Cleanup per-file based stuff.\n  LangStandard::Kind LangStd = LangStandard::lang_unspecified;\n  if (const Arg *A = Args.getLastArg(OPT_std_EQ)) {\n    LangStd = LangStandard::getLangKind(A->getValue());\n    if (LangStd == LangStandard::lang_unspecified) {\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << A->getValue();\n      // Report supported standards with short description.\n      for (unsigned KindValue = 0;\n           KindValue != LangStandard::lang_unspecified;\n           ++KindValue) {\n        const LangStandard &Std = LangStandard::getLangStandardForKind(\n          static_cast<LangStandard::Kind>(KindValue));\n        if (IsInputCompatibleWithStandard(IK, Std)) {\n          auto Diag = Diags.Report(diag::note_drv_use_standard);\n          Diag << Std.getName() << Std.getDescription();\n          unsigned NumAliases = 0;\n#define LANGSTANDARD(id, name, lang, desc, features)\n#define LANGSTANDARD_ALIAS(id, alias) \\\n          if (KindValue == LangStandard::lang_##id) ++NumAliases;\n#define LANGSTANDARD_ALIAS_DEPR(id, alias)\n#include \"clang/Basic/LangStandards.def\"\n          Diag << NumAliases;\n#define LANGSTANDARD(id, name, lang, desc, features)\n#define LANGSTANDARD_ALIAS(id, alias) \\\n          if (KindValue == LangStandard::lang_##id) Diag << alias;\n#define LANGSTANDARD_ALIAS_DEPR(id, alias)\n#include \"clang/Basic/LangStandards.def\"\n        }\n      }\n    } else {\n      // Valid standard, check to make sure language and standard are\n      // compatible.\n      const LangStandard &Std = LangStandard::getLangStandardForKind(LangStd);\n      if (!IsInputCompatibleWithStandard(IK, Std)) {\n        Diags.Report(diag::err_drv_argument_not_allowed_with)\n          << A->getAsString(Args) << GetInputKindName(IK);\n      }\n    }\n  }\n\n  // -cl-std only applies for OpenCL language standards.\n  // Override the -std option in this case.\n  if (const Arg *A = Args.getLastArg(OPT_cl_std_EQ)) {\n    LangStandard::Kind OpenCLLangStd\n      = llvm::StringSwitch<LangStandard::Kind>(A->getValue())\n        .Cases(\"cl\", \"CL\", LangStandard::lang_opencl10)\n        .Cases(\"cl1.0\", \"CL1.0\", LangStandard::lang_opencl10)\n        .Cases(\"cl1.1\", \"CL1.1\", LangStandard::lang_opencl11)\n        .Cases(\"cl1.2\", \"CL1.2\", LangStandard::lang_opencl12)\n        .Cases(\"cl2.0\", \"CL2.0\", LangStandard::lang_opencl20)\n        .Cases(\"cl3.0\", \"CL3.0\", LangStandard::lang_opencl30)\n        .Cases(\"clc++\", \"CLC++\", LangStandard::lang_openclcpp)\n        .Default(LangStandard::lang_unspecified);\n\n    if (OpenCLLangStd == LangStandard::lang_unspecified) {\n      Diags.Report(diag::err_drv_invalid_value)\n        << A->getAsString(Args) << A->getValue();\n    }\n    else\n      LangStd = OpenCLLangStd;\n  }\n\n  // These need to be parsed now. They are used to set OpenCL defaults.\n  Opts.IncludeDefaultHeader = Args.hasArg(OPT_finclude_default_header);\n  Opts.DeclareOpenCLBuiltins = Args.hasArg(OPT_fdeclare_opencl_builtins);\n\n  CompilerInvocation::setLangDefaults(Opts, IK, T, Includes, LangStd);\n\n  // The key paths of codegen options defined in Options.td start with\n  // \"LangOpts->\". Let's provide the expected variable name and type.\n  LangOptions *LangOpts = &Opts;\n  bool Success = true;\n\n#define LANG_OPTION_WITH_MARSHALLING(                                          \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef LANG_OPTION_WITH_MARSHALLING\n\n  if (const Arg *A = Args.getLastArg(OPT_fcf_protection_EQ)) {\n    StringRef Name = A->getValue();\n    if (Name == \"full\" || Name == \"branch\") {\n      Opts.CFProtectionBranch = 1;\n    }\n  }\n\n  if (Opts.ObjC) {\n    if (Arg *arg = Args.getLastArg(OPT_fobjc_runtime_EQ)) {\n      StringRef value = arg->getValue();\n      if (Opts.ObjCRuntime.tryParse(value))\n        Diags.Report(diag::err_drv_unknown_objc_runtime) << value;\n    }\n\n    if (Args.hasArg(OPT_fobjc_gc_only))\n      Opts.setGC(LangOptions::GCOnly);\n    else if (Args.hasArg(OPT_fobjc_gc))\n      Opts.setGC(LangOptions::HybridGC);\n    else if (Args.hasArg(OPT_fobjc_arc)) {\n      Opts.ObjCAutoRefCount = 1;\n      if (!Opts.ObjCRuntime.allowsARC())\n        Diags.Report(diag::err_arc_unsupported_on_runtime);\n    }\n\n    // ObjCWeakRuntime tracks whether the runtime supports __weak, not\n    // whether the feature is actually enabled.  This is predominantly\n    // determined by -fobjc-runtime, but we allow it to be overridden\n    // from the command line for testing purposes.\n    if (Args.hasArg(OPT_fobjc_runtime_has_weak))\n      Opts.ObjCWeakRuntime = 1;\n    else\n      Opts.ObjCWeakRuntime = Opts.ObjCRuntime.allowsWeak();\n\n    // ObjCWeak determines whether __weak is actually enabled.\n    // Note that we allow -fno-objc-weak to disable this even in ARC mode.\n    if (auto weakArg = Args.getLastArg(OPT_fobjc_weak, OPT_fno_objc_weak)) {\n      if (!weakArg->getOption().matches(OPT_fobjc_weak)) {\n        assert(!Opts.ObjCWeak);\n      } else if (Opts.getGC() != LangOptions::NonGC) {\n        Diags.Report(diag::err_objc_weak_with_gc);\n      } else if (!Opts.ObjCWeakRuntime) {\n        Diags.Report(diag::err_objc_weak_unsupported);\n      } else {\n        Opts.ObjCWeak = 1;\n      }\n    } else if (Opts.ObjCAutoRefCount) {\n      Opts.ObjCWeak = Opts.ObjCWeakRuntime;\n    }\n\n    if (Args.hasArg(OPT_fobjc_subscripting_legacy_runtime))\n      Opts.ObjCSubscriptingLegacyRuntime =\n        (Opts.ObjCRuntime.getKind() == ObjCRuntime::FragileMacOSX);\n  }\n\n  if (Arg *A = Args.getLastArg(options::OPT_fgnuc_version_EQ)) {\n    // Check that the version has 1 to 3 components and the minor and patch\n    // versions fit in two decimal digits.\n    VersionTuple GNUCVer;\n    bool Invalid = GNUCVer.tryParse(A->getValue());\n    unsigned Major = GNUCVer.getMajor();\n    unsigned Minor = GNUCVer.getMinor().getValueOr(0);\n    unsigned Patch = GNUCVer.getSubminor().getValueOr(0);\n    if (Invalid || GNUCVer.getBuild() || Minor >= 100 || Patch >= 100) {\n      Diags.Report(diag::err_drv_invalid_value)\n          << A->getAsString(Args) << A->getValue();\n    }\n    Opts.GNUCVersion = Major * 100 * 100 + Minor * 100 + Patch;\n  }\n\n  // In AIX OS, the -mignore-xcoff-visibility is enable by default if there is\n  // no -fvisibility=* option.\n  // This is the reason why '-fvisibility' needs to be always generated:\n  // its absence implies '-mignore-xcoff-visibility'.\n  //\n  // Suppose the original cc1 command line does contain '-fvisibility default':\n  // '-mignore-xcoff-visibility' should not be implied.\n  // * If '-fvisibility' is not generated (as most options with default values\n  //   don't), its absence would imply '-mignore-xcoff-visibility'. This changes\n  //   the command line semantics.\n  // * If '-fvisibility' is generated regardless of its presence and value,\n  //   '-mignore-xcoff-visibility' won't be implied and the command line\n  //   semantics are kept intact.\n  //\n  // When the original cc1 command line does **not** contain '-fvisibility',\n  // '-mignore-xcoff-visibility' is implied. The generated command line will\n  // contain both '-fvisibility default' and '-mignore-xcoff-visibility' and\n  // subsequent calls to `CreateFromArgs`/`generateCC1CommandLine` will always\n  // produce the same arguments. \n \n  if (T.isOSAIX() && (Args.hasArg(OPT_mignore_xcoff_visibility) ||\n                      !Args.hasArg(OPT_fvisibility)))\n    Opts.IgnoreXCOFFVisibility = 1;\n\n  if (Args.hasArg(OPT_ftrapv)) {\n    Opts.setSignedOverflowBehavior(LangOptions::SOB_Trapping);\n    // Set the handler, if one is specified.\n    Opts.OverflowHandler =\n        std::string(Args.getLastArgValue(OPT_ftrapv_handler));\n  }\n  else if (Args.hasArg(OPT_fwrapv))\n    Opts.setSignedOverflowBehavior(LangOptions::SOB_Defined);\n\n  Opts.MSCompatibilityVersion = 0;\n  if (const Arg *A = Args.getLastArg(OPT_fms_compatibility_version)) {\n    VersionTuple VT;\n    if (VT.tryParse(A->getValue()))\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)\n                                                << A->getValue();\n    Opts.MSCompatibilityVersion = VT.getMajor() * 10000000 +\n                                  VT.getMinor().getValueOr(0) * 100000 +\n                                  VT.getSubminor().getValueOr(0);\n  }\n\n  // Mimicking gcc's behavior, trigraphs are only enabled if -trigraphs\n  // is specified, or -std is set to a conforming mode.\n  // Trigraphs are disabled by default in c++1z onwards.\n  // For z/OS, trigraphs are enabled by default (without regard to the above).\n  Opts.Trigraphs =\n      (!Opts.GNUMode && !Opts.MSVCCompat && !Opts.CPlusPlus17) || T.isOSzOS();\n  Opts.Trigraphs =\n      Args.hasFlag(OPT_ftrigraphs, OPT_fno_trigraphs, Opts.Trigraphs);\n\n  Opts.Blocks = Args.hasArg(OPT_fblocks) || (Opts.OpenCL\n    && Opts.OpenCLVersion == 200);\n\n  Opts.ConvergentFunctions = Opts.OpenCL || (Opts.CUDA && Opts.CUDAIsDevice) ||\n                             Opts.SYCLIsDevice ||\n                             Args.hasArg(OPT_fconvergent_functions);\n\n  Opts.NoBuiltin = Args.hasArg(OPT_fno_builtin) || Opts.Freestanding;\n  if (!Opts.NoBuiltin)\n    getAllNoBuiltinFuncValues(Args, Opts.NoBuiltinFuncs);\n  Opts.LongDoubleSize = Args.hasArg(OPT_mlong_double_128)\n                            ? 128\n                            : Args.hasArg(OPT_mlong_double_64) ? 64 : 0;\n  if (Opts.FastRelaxedMath)\n    Opts.setDefaultFPContractMode(LangOptions::FPM_Fast);\n  llvm::sort(Opts.ModuleFeatures);\n\n  // -mrtd option\n  if (Arg *A = Args.getLastArg(OPT_mrtd)) {\n    if (Opts.getDefaultCallingConv() != LangOptions::DCC_None)\n      Diags.Report(diag::err_drv_argument_not_allowed_with)\n          << A->getSpelling() << \"-fdefault-calling-conv\";\n    else {\n      if (T.getArch() != llvm::Triple::x86)\n        Diags.Report(diag::err_drv_argument_not_allowed_with)\n            << A->getSpelling() << T.getTriple();\n      else\n        Opts.setDefaultCallingConv(LangOptions::DCC_StdCall);\n    }\n  }\n\n  // Check if -fopenmp is specified and set default version to 5.0.\n  Opts.OpenMP = Args.hasArg(OPT_fopenmp) ? 50 : 0;\n  // Check if -fopenmp-simd is specified.\n  bool IsSimdSpecified =\n      Args.hasFlag(options::OPT_fopenmp_simd, options::OPT_fno_openmp_simd,\n                   /*Default=*/false);\n  Opts.OpenMPSimd = !Opts.OpenMP && IsSimdSpecified;\n  Opts.OpenMPUseTLS =\n      Opts.OpenMP && !Args.hasArg(options::OPT_fnoopenmp_use_tls);\n  Opts.OpenMPIsDevice =\n      Opts.OpenMP && Args.hasArg(options::OPT_fopenmp_is_device);\n  Opts.OpenMPIRBuilder =\n      Opts.OpenMP && Args.hasArg(options::OPT_fopenmp_enable_irbuilder);\n  bool IsTargetSpecified =\n      Opts.OpenMPIsDevice || Args.hasArg(options::OPT_fopenmp_targets_EQ);\n\n  Opts.ConvergentFunctions = Opts.ConvergentFunctions || Opts.OpenMPIsDevice;\n\n  if (Opts.OpenMP || Opts.OpenMPSimd) {\n    if (int Version = getLastArgIntValue(\n            Args, OPT_fopenmp_version_EQ,\n            (IsSimdSpecified || IsTargetSpecified) ? 50 : Opts.OpenMP, Diags))\n      Opts.OpenMP = Version;\n    // Provide diagnostic when a given target is not expected to be an OpenMP\n    // device or host.\n    if (!Opts.OpenMPIsDevice) {\n      switch (T.getArch()) {\n      default:\n        break;\n      // Add unsupported host targets here:\n      case llvm::Triple::nvptx:\n      case llvm::Triple::nvptx64:\n        Diags.Report(diag::err_drv_omp_host_target_not_supported) << T.str();\n        break;\n      }\n    }\n  }\n\n  // Set the flag to prevent the implementation from emitting device exception\n  // handling code for those requiring so.\n  if ((Opts.OpenMPIsDevice && (T.isNVPTX() || T.isAMDGCN())) ||\n      Opts.OpenCLCPlusPlus) {\n    Opts.Exceptions = 0;\n    Opts.CXXExceptions = 0;\n  }\n  if (Opts.OpenMPIsDevice && T.isNVPTX()) {\n    Opts.OpenMPCUDANumSMs =\n        getLastArgIntValue(Args, options::OPT_fopenmp_cuda_number_of_sm_EQ,\n                           Opts.OpenMPCUDANumSMs, Diags);\n    Opts.OpenMPCUDABlocksPerSM =\n        getLastArgIntValue(Args, options::OPT_fopenmp_cuda_blocks_per_sm_EQ,\n                           Opts.OpenMPCUDABlocksPerSM, Diags);\n    Opts.OpenMPCUDAReductionBufNum = getLastArgIntValue(\n        Args, options::OPT_fopenmp_cuda_teams_reduction_recs_num_EQ,\n        Opts.OpenMPCUDAReductionBufNum, Diags);\n  }\n\n  // Get the OpenMP target triples if any.\n  if (Arg *A = Args.getLastArg(options::OPT_fopenmp_targets_EQ)) {\n    enum ArchPtrSize { Arch16Bit, Arch32Bit, Arch64Bit };\n    auto getArchPtrSize = [](const llvm::Triple &T) {\n      if (T.isArch16Bit())\n        return Arch16Bit;\n      if (T.isArch32Bit())\n        return Arch32Bit;\n      assert(T.isArch64Bit() && \"Expected 64-bit architecture\");\n      return Arch64Bit;\n    };\n\n    for (unsigned i = 0; i < A->getNumValues(); ++i) {\n      llvm::Triple TT(A->getValue(i));\n\n      if (TT.getArch() == llvm::Triple::UnknownArch ||\n          !(TT.getArch() == llvm::Triple::aarch64 || TT.isPPC() ||\n            TT.getArch() == llvm::Triple::nvptx ||\n            TT.getArch() == llvm::Triple::nvptx64 ||\n            TT.getArch() == llvm::Triple::amdgcn ||\n            TT.getArch() == llvm::Triple::x86 ||\n            TT.getArch() == llvm::Triple::x86_64))\n        Diags.Report(diag::err_drv_invalid_omp_target) << A->getValue(i);\n      else if (getArchPtrSize(T) != getArchPtrSize(TT))\n        Diags.Report(diag::err_drv_incompatible_omp_arch)\n            << A->getValue(i) << T.str();\n      else\n        Opts.OMPTargetTriples.push_back(TT);\n    }\n  }\n\n  // Get OpenMP host file path if any and report if a non existent file is\n  // found\n  if (Arg *A = Args.getLastArg(options::OPT_fopenmp_host_ir_file_path)) {\n    Opts.OMPHostIRFile = A->getValue();\n    if (!llvm::sys::fs::exists(Opts.OMPHostIRFile))\n      Diags.Report(diag::err_drv_omp_host_ir_file_not_found)\n          << Opts.OMPHostIRFile;\n  }\n\n  // Set CUDA mode for OpenMP target NVPTX/AMDGCN if specified in options\n  Opts.OpenMPCUDAMode = Opts.OpenMPIsDevice && (T.isNVPTX() || T.isAMDGCN()) &&\n                        Args.hasArg(options::OPT_fopenmp_cuda_mode);\n\n  // Set CUDA support for parallel execution of target regions for OpenMP target\n  // NVPTX/AMDGCN if specified in options.\n  Opts.OpenMPCUDATargetParallel =\n      Opts.OpenMPIsDevice && (T.isNVPTX() || T.isAMDGCN()) &&\n      Args.hasArg(options::OPT_fopenmp_cuda_parallel_target_regions);\n\n  // Set CUDA mode for OpenMP target NVPTX/AMDGCN if specified in options\n  Opts.OpenMPCUDAForceFullRuntime =\n      Opts.OpenMPIsDevice && (T.isNVPTX() || T.isAMDGCN()) &&\n      Args.hasArg(options::OPT_fopenmp_cuda_force_full_runtime);\n\n  // FIXME: Eliminate this dependency.\n  unsigned Opt = getOptimizationLevel(Args, IK, Diags),\n       OptSize = getOptimizationLevelSize(Args);\n  Opts.Optimize = Opt != 0;\n  Opts.OptimizeSize = OptSize != 0;\n\n  // This is the __NO_INLINE__ define, which just depends on things like the\n  // optimization level and -fno-inline, not actually whether the backend has\n  // inlining enabled.\n  Opts.NoInlineDefine = !Opts.Optimize;\n  if (Arg *InlineArg = Args.getLastArg(\n          options::OPT_finline_functions, options::OPT_finline_hint_functions,\n          options::OPT_fno_inline_functions, options::OPT_fno_inline))\n    if (InlineArg->getOption().matches(options::OPT_fno_inline))\n      Opts.NoInlineDefine = true;\n\n  if (Arg *A = Args.getLastArg(OPT_ffp_contract)) {\n    StringRef Val = A->getValue();\n    if (Val == \"fast\")\n      Opts.setDefaultFPContractMode(LangOptions::FPM_Fast);\n    else if (Val == \"on\")\n      Opts.setDefaultFPContractMode(LangOptions::FPM_On);\n    else if (Val == \"off\")\n      Opts.setDefaultFPContractMode(LangOptions::FPM_Off);\n    else if (Val == \"fast-honor-pragmas\")\n      Opts.setDefaultFPContractMode(LangOptions::FPM_FastHonorPragmas);\n    else\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << Val;\n  }\n\n  // Parse -fsanitize= arguments.\n  parseSanitizerKinds(\"-fsanitize=\", Args.getAllArgValues(OPT_fsanitize_EQ),\n                      Diags, Opts.Sanitize);\n  Opts.NoSanitizeFiles = Args.getAllArgValues(OPT_fsanitize_blacklist);\n  std::vector<std::string> systemBlacklists =\n      Args.getAllArgValues(OPT_fsanitize_system_blacklist);\n  Opts.NoSanitizeFiles.insert(Opts.NoSanitizeFiles.end(),\n                              systemBlacklists.begin(), systemBlacklists.end());\n\n  if (Arg *A = Args.getLastArg(OPT_fclang_abi_compat_EQ)) {\n    Opts.setClangABICompat(LangOptions::ClangABI::Latest);\n\n    StringRef Ver = A->getValue();\n    std::pair<StringRef, StringRef> VerParts = Ver.split('.');\n    unsigned Major, Minor = 0;\n\n    // Check the version number is valid: either 3.x (0 <= x <= 9) or\n    // y or y.0 (4 <= y <= current version).\n    if (!VerParts.first.startswith(\"0\") &&\n        !VerParts.first.getAsInteger(10, Major) &&\n        3 <= Major && Major <= CLANG_VERSION_MAJOR &&\n        (Major == 3 ? VerParts.second.size() == 1 &&\n                      !VerParts.second.getAsInteger(10, Minor)\n                    : VerParts.first.size() == Ver.size() ||\n                      VerParts.second == \"0\")) {\n      // Got a valid version number.\n      if (Major == 3 && Minor <= 8)\n        Opts.setClangABICompat(LangOptions::ClangABI::Ver3_8);\n      else if (Major <= 4)\n        Opts.setClangABICompat(LangOptions::ClangABI::Ver4);\n      else if (Major <= 6)\n        Opts.setClangABICompat(LangOptions::ClangABI::Ver6);\n      else if (Major <= 7)\n        Opts.setClangABICompat(LangOptions::ClangABI::Ver7);\n      else if (Major <= 9)\n        Opts.setClangABICompat(LangOptions::ClangABI::Ver9);\n      else if (Major <= 11)\n        Opts.setClangABICompat(LangOptions::ClangABI::Ver11);\n    } else if (Ver != \"latest\") {\n      Diags.Report(diag::err_drv_invalid_value)\n          << A->getAsString(Args) << A->getValue();\n    }\n  }\n\n  if (Arg *A = Args.getLastArg(OPT_msign_return_address_EQ)) {\n    StringRef SignScope = A->getValue();\n\n    if (SignScope.equals_lower(\"none\"))\n      Opts.setSignReturnAddressScope(\n          LangOptions::SignReturnAddressScopeKind::None);\n    else if (SignScope.equals_lower(\"all\"))\n      Opts.setSignReturnAddressScope(\n          LangOptions::SignReturnAddressScopeKind::All);\n    else if (SignScope.equals_lower(\"non-leaf\"))\n      Opts.setSignReturnAddressScope(\n          LangOptions::SignReturnAddressScopeKind::NonLeaf);\n    else\n      Diags.Report(diag::err_drv_invalid_value)\n          << A->getAsString(Args) << SignScope;\n\n    if (Arg *A = Args.getLastArg(OPT_msign_return_address_key_EQ)) {\n      StringRef SignKey = A->getValue();\n      if (!SignScope.empty() && !SignKey.empty()) {\n        if (SignKey.equals_lower(\"a_key\"))\n          Opts.setSignReturnAddressKey(\n              LangOptions::SignReturnAddressKeyKind::AKey);\n        else if (SignKey.equals_lower(\"b_key\"))\n          Opts.setSignReturnAddressKey(\n              LangOptions::SignReturnAddressKeyKind::BKey);\n        else\n          Diags.Report(diag::err_drv_invalid_value)\n              << A->getAsString(Args) << SignKey;\n      }\n    }\n  }\n\n  return Success && Diags.getNumErrors() == NumErrorsBefore;\n}\n\nstatic bool isStrictlyPreprocessorAction(frontend::ActionKind Action) {\n  switch (Action) {\n  case frontend::ASTDeclList:\n  case frontend::ASTDump:\n  case frontend::ASTPrint:\n  case frontend::ASTView:\n  case frontend::EmitAssembly:\n  case frontend::EmitBC:\n  case frontend::EmitHTML:\n  case frontend::EmitLLVM:\n  case frontend::EmitLLVMOnly:\n  case frontend::EmitCodeGenOnly:\n  case frontend::EmitObj:\n  case frontend::FixIt:\n  case frontend::GenerateModule:\n  case frontend::GenerateModuleInterface:\n  case frontend::GenerateHeaderModule:\n  case frontend::GeneratePCH:\n  case frontend::GenerateInterfaceStubs:\n  case frontend::ParseSyntaxOnly:\n  case frontend::ModuleFileInfo:\n  case frontend::VerifyPCH:\n  case frontend::PluginAction:\n  case frontend::RewriteObjC:\n  case frontend::RewriteTest:\n  case frontend::RunAnalysis:\n  case frontend::TemplightDump:\n  case frontend::MigrateSource:\n    return false;\n\n  case frontend::DumpCompilerOptions:\n  case frontend::DumpRawTokens:\n  case frontend::DumpTokens:\n  case frontend::InitOnly:\n  case frontend::PrintPreamble:\n  case frontend::PrintPreprocessedInput:\n  case frontend::RewriteMacros:\n  case frontend::RunPreprocessorOnly:\n  case frontend::PrintDependencyDirectivesSourceMinimizerOutput:\n    return true;\n  }\n  llvm_unreachable(\"invalid frontend action\");\n}\n\nstatic void GeneratePreprocessorArgs(PreprocessorOptions &Opts,\n                                     SmallVectorImpl<const char *> &Args,\n                                     CompilerInvocation::StringAllocator SA,\n                                     const LangOptions &LangOpts,\n                                     const FrontendOptions &FrontendOpts,\n                                     const CodeGenOptions &CodeGenOpts) {\n  PreprocessorOptions *PreprocessorOpts = &Opts;\n\n#define PREPROCESSOR_OPTION_WITH_MARSHALLING(                                  \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef PREPROCESSOR_OPTION_WITH_MARSHALLING\n\n  if (Opts.PCHWithHdrStop && !Opts.PCHWithHdrStopCreate)\n    GenerateArg(Args, OPT_pch_through_hdrstop_use, SA);\n\n  for (const auto &D : Opts.DeserializedPCHDeclsToErrorOn)\n    GenerateArg(Args, OPT_error_on_deserialized_pch_decl, D, SA);\n\n  for (const auto &MP : Opts.MacroPrefixMap)\n    GenerateArg(Args, OPT_fmacro_prefix_map_EQ, MP.first + \"=\" + MP.second, SA);\n\n  if (Opts.PrecompiledPreambleBytes != std::make_pair(0u, false))\n    GenerateArg(Args, OPT_preamble_bytes_EQ,\n                Twine(Opts.PrecompiledPreambleBytes.first) + \",\" +\n                    (Opts.PrecompiledPreambleBytes.second ? \"1\" : \"0\"),\n                SA);\n\n  for (const auto &M : Opts.Macros) {\n    // Don't generate __CET__ macro definitions. They are implied by the\n    // -fcf-protection option that is generated elsewhere.\n    if (M.first == \"__CET__=1\" && !M.second &&\n        !CodeGenOpts.CFProtectionReturn && CodeGenOpts.CFProtectionBranch)\n      continue;\n    if (M.first == \"__CET__=2\" && !M.second && CodeGenOpts.CFProtectionReturn &&\n        !CodeGenOpts.CFProtectionBranch)\n      continue;\n    if (M.first == \"__CET__=3\" && !M.second && CodeGenOpts.CFProtectionReturn &&\n        CodeGenOpts.CFProtectionBranch)\n      continue;\n\n    GenerateArg(Args, M.second ? OPT_U : OPT_D, M.first, SA);\n  }\n\n  for (const auto &I : Opts.Includes) {\n    // Don't generate OpenCL includes. They are implied by other flags that are\n    // generated elsewhere.\n    if (LangOpts.OpenCL && LangOpts.IncludeDefaultHeader &&\n        ((LangOpts.DeclareOpenCLBuiltins && I == \"opencl-c-base.h\") ||\n         I == \"opencl-c.h\"))\n      continue;\n\n    GenerateArg(Args, OPT_include, I, SA);\n  }\n\n  for (const auto &CI : Opts.ChainedIncludes)\n    GenerateArg(Args, OPT_chain_include, CI, SA);\n\n  for (const auto &RF : Opts.RemappedFiles)\n    GenerateArg(Args, OPT_remap_file, RF.first + \";\" + RF.second, SA);\n\n  // Don't handle LexEditorPlaceholders. It is implied by the action that is\n  // generated elsewhere.\n}\n\nstatic bool ParsePreprocessorArgs(PreprocessorOptions &Opts, ArgList &Args,\n                                  DiagnosticsEngine &Diags,\n                                  frontend::ActionKind Action,\n                                  const FrontendOptions &FrontendOpts) {\n  PreprocessorOptions *PreprocessorOpts = &Opts;\n  bool Success = true;\n\n#define PREPROCESSOR_OPTION_WITH_MARSHALLING(                                  \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef PREPROCESSOR_OPTION_WITH_MARSHALLING\n\n  Opts.PCHWithHdrStop = Args.hasArg(OPT_pch_through_hdrstop_create) ||\n                        Args.hasArg(OPT_pch_through_hdrstop_use);\n\n  for (const auto *A : Args.filtered(OPT_error_on_deserialized_pch_decl))\n    Opts.DeserializedPCHDeclsToErrorOn.insert(A->getValue());\n\n  for (const auto &A : Args.getAllArgValues(OPT_fmacro_prefix_map_EQ)) {\n    auto Split = StringRef(A).split('=');\n    Opts.MacroPrefixMap.insert(\n        {std::string(Split.first), std::string(Split.second)});\n  }\n\n  if (const Arg *A = Args.getLastArg(OPT_preamble_bytes_EQ)) {\n    StringRef Value(A->getValue());\n    size_t Comma = Value.find(',');\n    unsigned Bytes = 0;\n    unsigned EndOfLine = 0;\n\n    if (Comma == StringRef::npos ||\n        Value.substr(0, Comma).getAsInteger(10, Bytes) ||\n        Value.substr(Comma + 1).getAsInteger(10, EndOfLine))\n      Diags.Report(diag::err_drv_preamble_format);\n    else {\n      Opts.PrecompiledPreambleBytes.first = Bytes;\n      Opts.PrecompiledPreambleBytes.second = (EndOfLine != 0);\n    }\n  }\n\n  // Add the __CET__ macro if a CFProtection option is set.\n  if (const Arg *A = Args.getLastArg(OPT_fcf_protection_EQ)) {\n    StringRef Name = A->getValue();\n    if (Name == \"branch\")\n      Opts.addMacroDef(\"__CET__=1\");\n    else if (Name == \"return\")\n      Opts.addMacroDef(\"__CET__=2\");\n    else if (Name == \"full\")\n      Opts.addMacroDef(\"__CET__=3\");\n  }\n\n  // Add macros from the command line.\n  for (const auto *A : Args.filtered(OPT_D, OPT_U)) {\n    if (A->getOption().matches(OPT_D))\n      Opts.addMacroDef(A->getValue());\n    else\n      Opts.addMacroUndef(A->getValue());\n  }\n\n  // Add the ordered list of -includes.\n  for (const auto *A : Args.filtered(OPT_include))\n    Opts.Includes.emplace_back(A->getValue());\n\n  for (const auto *A : Args.filtered(OPT_chain_include))\n    Opts.ChainedIncludes.emplace_back(A->getValue());\n\n  for (const auto *A : Args.filtered(OPT_remap_file)) {\n    std::pair<StringRef, StringRef> Split = StringRef(A->getValue()).split(';');\n\n    if (Split.second.empty()) {\n      Diags.Report(diag::err_drv_invalid_remap_file) << A->getAsString(Args);\n      continue;\n    }\n\n    Opts.addRemappedFile(Split.first, Split.second);\n  }\n\n  // Always avoid lexing editor placeholders when we're just running the\n  // preprocessor as we never want to emit the\n  // \"editor placeholder in source file\" error in PP only mode.\n  if (isStrictlyPreprocessorAction(Action))\n    Opts.LexEditorPlaceholders = false;\n\n  return Success;\n}\n\nstatic void GeneratePreprocessorOutputArgs(\n    const PreprocessorOutputOptions &Opts, SmallVectorImpl<const char *> &Args,\n    CompilerInvocation::StringAllocator SA, frontend::ActionKind Action) {\n  const PreprocessorOutputOptions &PreprocessorOutputOpts = Opts;\n\n#define PREPROCESSOR_OUTPUT_OPTION_WITH_MARSHALLING(                           \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef PREPROCESSOR_OUTPUT_OPTION_WITH_MARSHALLING\n\n  bool Generate_dM = isStrictlyPreprocessorAction(Action) && !Opts.ShowCPP;\n  if (Generate_dM)\n    GenerateArg(Args, OPT_dM, SA);\n  if (!Generate_dM && Opts.ShowMacros)\n    GenerateArg(Args, OPT_dD, SA);\n}\n\nstatic bool ParsePreprocessorOutputArgs(PreprocessorOutputOptions &Opts,\n                                        ArgList &Args, DiagnosticsEngine &Diags,\n                                        frontend::ActionKind Action) {\n  PreprocessorOutputOptions &PreprocessorOutputOpts = Opts;\n  unsigned NumErrorsBefore = Diags.getNumErrors();\n  bool Success = true;\n\n#define PREPROCESSOR_OUTPUT_OPTION_WITH_MARSHALLING(                           \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef PREPROCESSOR_OUTPUT_OPTION_WITH_MARSHALLING\n\n  Opts.ShowCPP = isStrictlyPreprocessorAction(Action) && !Args.hasArg(OPT_dM);\n  Opts.ShowMacros = Args.hasArg(OPT_dM) || Args.hasArg(OPT_dD);\n\n  return Success && Diags.getNumErrors() == NumErrorsBefore;\n}\n\nstatic void GenerateTargetArgs(const TargetOptions &Opts,\n                               SmallVectorImpl<const char *> &Args,\n                               CompilerInvocation::StringAllocator SA) {\n  const TargetOptions *TargetOpts = &Opts;\n#define TARGET_OPTION_WITH_MARSHALLING(                                        \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  GENERATE_OPTION_WITH_MARSHALLING(                                            \\\n      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \\\n      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef TARGET_OPTION_WITH_MARSHALLING\n\n  if (!Opts.SDKVersion.empty())\n    GenerateArg(Args, OPT_target_sdk_version_EQ, Opts.SDKVersion.getAsString(),\n                SA);\n}\n\nstatic bool ParseTargetArgs(TargetOptions &Opts, ArgList &Args,\n                            DiagnosticsEngine &Diags) {\n  TargetOptions *TargetOpts = &Opts;\n  unsigned NumErrorsBefore = Diags.getNumErrors();\n  bool Success = true;\n\n#define TARGET_OPTION_WITH_MARSHALLING(                                        \\\n    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \\\n    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \\\n    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \\\n    MERGER, EXTRACTOR, TABLE_INDEX)                                            \\\n  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \\\n                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \\\n                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \\\n                                MERGER, TABLE_INDEX)\n#include \"clang/Driver/Options.inc\"\n#undef TARGET_OPTION_WITH_MARSHALLING\n\n  if (Arg *A = Args.getLastArg(options::OPT_target_sdk_version_EQ)) {\n    llvm::VersionTuple Version;\n    if (Version.tryParse(A->getValue()))\n      Diags.Report(diag::err_drv_invalid_value)\n          << A->getAsString(Args) << A->getValue();\n    else\n      Opts.SDKVersion = Version;\n  }\n\n  return Success && Diags.getNumErrors() == NumErrorsBefore;\n}\n\nbool CompilerInvocation::CreateFromArgsImpl(\n    CompilerInvocation &Res, ArrayRef<const char *> CommandLineArgs,\n    DiagnosticsEngine &Diags, const char *Argv0) {\n  bool Success = true;\n\n  // Parse the arguments.\n  const OptTable &Opts = getDriverOptTable();\n  const unsigned IncludedFlagsBitmask = options::CC1Option;\n  unsigned MissingArgIndex, MissingArgCount;\n  InputArgList Args = Opts.ParseArgs(CommandLineArgs, MissingArgIndex,\n                                     MissingArgCount, IncludedFlagsBitmask);\n  LangOptions &LangOpts = *Res.getLangOpts();\n\n  // Check for missing argument error.\n  if (MissingArgCount) {\n    Diags.Report(diag::err_drv_missing_argument)\n        << Args.getArgString(MissingArgIndex) << MissingArgCount;\n    Success = false;\n  }\n\n  // Issue errors on unknown arguments.\n  for (const auto *A : Args.filtered(OPT_UNKNOWN)) {\n    auto ArgString = A->getAsString(Args);\n    std::string Nearest;\n    if (Opts.findNearest(ArgString, Nearest, IncludedFlagsBitmask) > 1)\n      Diags.Report(diag::err_drv_unknown_argument) << ArgString;\n    else\n      Diags.Report(diag::err_drv_unknown_argument_with_suggestion)\n          << ArgString << Nearest;\n    Success = false;\n  }\n\n  Success &= ParseFileSystemArgs(Res.getFileSystemOpts(), Args, Diags);\n  Success &= ParseMigratorArgs(Res.getMigratorOpts(), Args, Diags);\n  Success &= ParseAnalyzerArgs(*Res.getAnalyzerOpts(), Args, Diags);\n  Success &= ParseDiagnosticArgs(Res.getDiagnosticOpts(), Args, &Diags,\n                                 /*DefaultDiagColor=*/false);\n  Success &= ParseFrontendArgs(Res.getFrontendOpts(), Args, Diags,\n                               LangOpts.IsHeaderFile);\n  // FIXME: We shouldn't have to pass the DashX option around here\n  InputKind DashX = Res.getFrontendOpts().DashX;\n  Success &= ParseTargetArgs(Res.getTargetOpts(), Args, Diags);\n  llvm::Triple T(Res.getTargetOpts().Triple);\n  ParseHeaderSearchArgs(Res.getHeaderSearchOpts(), Args, Diags,\n                        Res.getFileSystemOpts().WorkingDir);\n  if (DashX.getFormat() == InputKind::Precompiled ||\n      DashX.getLanguage() == Language::LLVM_IR) {\n    // ObjCAAutoRefCount and Sanitize LangOpts are used to setup the\n    // PassManager in BackendUtil.cpp. They need to be initializd no matter\n    // what the input type is.\n    if (Args.hasArg(OPT_fobjc_arc))\n      LangOpts.ObjCAutoRefCount = 1;\n    // PIClevel and PIELevel are needed during code generation and this should be\n    // set regardless of the input type.\n    LangOpts.PICLevel = getLastArgIntValue(Args, OPT_pic_level, 0, Diags);\n    LangOpts.PIE = Args.hasArg(OPT_pic_is_pie);\n    parseSanitizerKinds(\"-fsanitize=\", Args.getAllArgValues(OPT_fsanitize_EQ),\n                        Diags, LangOpts.Sanitize);\n  } else {\n    // Other LangOpts are only initialized when the input is not AST or LLVM IR.\n    // FIXME: Should we really be calling this for an Language::Asm input?\n    Success &= ParseLangArgs(LangOpts, Args, DashX, T,\n                             Res.getPreprocessorOpts().Includes, Diags);\n    if (Res.getFrontendOpts().ProgramAction == frontend::RewriteObjC)\n      LangOpts.ObjCExceptions = 1;\n  }\n\n  if (LangOpts.CUDA) {\n    // During CUDA device-side compilation, the aux triple is the\n    // triple used for host compilation.\n    if (LangOpts.CUDAIsDevice)\n      Res.getTargetOpts().HostTriple = Res.getFrontendOpts().AuxTriple;\n  }\n\n  // Set the triple of the host for OpenMP device compile.\n  if (LangOpts.OpenMPIsDevice)\n    Res.getTargetOpts().HostTriple = Res.getFrontendOpts().AuxTriple;\n\n  Success &= ParseCodeGenArgs(Res.getCodeGenOpts(), Args, DashX, Diags, T,\n                              Res.getFrontendOpts().OutputFile, LangOpts);\n\n  // FIXME: Override value name discarding when asan or msan is used because the\n  // backend passes depend on the name of the alloca in order to print out\n  // names.\n  Res.getCodeGenOpts().DiscardValueNames &=\n      !LangOpts.Sanitize.has(SanitizerKind::Address) &&\n      !LangOpts.Sanitize.has(SanitizerKind::KernelAddress) &&\n      !LangOpts.Sanitize.has(SanitizerKind::Memory) &&\n      !LangOpts.Sanitize.has(SanitizerKind::KernelMemory);\n\n  ParsePreprocessorArgs(Res.getPreprocessorOpts(), Args, Diags,\n                        Res.getFrontendOpts().ProgramAction,\n                        Res.getFrontendOpts());\n  ParsePreprocessorOutputArgs(Res.getPreprocessorOutputOpts(), Args, Diags,\n                              Res.getFrontendOpts().ProgramAction);\n\n  ParseDependencyOutputArgs(Res.getDependencyOutputOpts(), Args, Diags,\n                            Res.getFrontendOpts().ProgramAction,\n                            Res.getPreprocessorOutputOpts().ShowLineMarkers);\n  if (!Res.getDependencyOutputOpts().OutputFile.empty() &&\n      Res.getDependencyOutputOpts().Targets.empty()) {\n    Diags.Report(diag::err_fe_dependency_file_requires_MT);\n    Success = false;\n  }\n\n  // If sanitizer is enabled, disable OPT_ffine_grained_bitfield_accesses.\n  if (Res.getCodeGenOpts().FineGrainedBitfieldAccesses &&\n      !Res.getLangOpts()->Sanitize.empty()) {\n    Res.getCodeGenOpts().FineGrainedBitfieldAccesses = false;\n    Diags.Report(diag::warn_drv_fine_grained_bitfield_accesses_ignored);\n  }\n\n  // Store the command-line for using in the CodeView backend.\n  Res.getCodeGenOpts().Argv0 = Argv0;\n  Res.getCodeGenOpts().CommandLineArgs = CommandLineArgs;\n\n  Success &= FixupInvocation(Res, Diags, Args, DashX);\n\n  return Success;\n}\n\nbool CompilerInvocation::CreateFromArgs(CompilerInvocation &Invocation,\n                                        ArrayRef<const char *> CommandLineArgs,\n                                        DiagnosticsEngine &Diags,\n                                        const char *Argv0) {\n  CompilerInvocation DummyInvocation;\n\n  return RoundTrip(\n      [](CompilerInvocation &Invocation, ArrayRef<const char *> CommandLineArgs,\n         DiagnosticsEngine &Diags, const char *Argv0) {\n        return CreateFromArgsImpl(Invocation, CommandLineArgs, Diags, Argv0);\n      },\n      [](CompilerInvocation &Invocation, SmallVectorImpl<const char *> &Args,\n         StringAllocator SA) { Invocation.generateCC1CommandLine(Args, SA); },\n      Invocation, DummyInvocation, CommandLineArgs, Diags, Argv0);\n}\n\nstd::string CompilerInvocation::getModuleHash() const {\n  // Note: For QoI reasons, the things we use as a hash here should all be\n  // dumped via the -module-info flag.\n  using llvm::hash_code;\n  using llvm::hash_value;\n  using llvm::hash_combine;\n  using llvm::hash_combine_range;\n\n  // Start the signature with the compiler version.\n  // FIXME: We'd rather use something more cryptographically sound than\n  // CityHash, but this will do for now.\n  hash_code code = hash_value(getClangFullRepositoryVersion());\n\n  // Also include the serialization version, in case LLVM_APPEND_VC_REV is off\n  // and getClangFullRepositoryVersion() doesn't include git revision.\n  code = hash_combine(code, serialization::VERSION_MAJOR,\n                      serialization::VERSION_MINOR);\n\n  // Extend the signature with the language options\n#define LANGOPT(Name, Bits, Default, Description) \\\n   code = hash_combine(code, LangOpts->Name);\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  code = hash_combine(code, static_cast<unsigned>(LangOpts->get##Name()));\n#define BENIGN_LANGOPT(Name, Bits, Default, Description)\n#define BENIGN_ENUM_LANGOPT(Name, Type, Bits, Default, Description)\n#include \"clang/Basic/LangOptions.def\"\n\n  for (StringRef Feature : LangOpts->ModuleFeatures)\n    code = hash_combine(code, Feature);\n\n  code = hash_combine(code, LangOpts->ObjCRuntime);\n  const auto &BCN = LangOpts->CommentOpts.BlockCommandNames;\n  code = hash_combine(code, hash_combine_range(BCN.begin(), BCN.end()));\n\n  // Extend the signature with the target options.\n  code = hash_combine(code, TargetOpts->Triple, TargetOpts->CPU,\n                      TargetOpts->TuneCPU, TargetOpts->ABI);\n  for (const auto &FeatureAsWritten : TargetOpts->FeaturesAsWritten)\n    code = hash_combine(code, FeatureAsWritten);\n\n  // Extend the signature with preprocessor options.\n  const PreprocessorOptions &ppOpts = getPreprocessorOpts();\n  const HeaderSearchOptions &hsOpts = getHeaderSearchOpts();\n  code = hash_combine(code, ppOpts.UsePredefines, ppOpts.DetailedRecord);\n\n  for (const auto &I : getPreprocessorOpts().Macros) {\n    // If we're supposed to ignore this macro for the purposes of modules,\n    // don't put it into the hash.\n    if (!hsOpts.ModulesIgnoreMacros.empty()) {\n      // Check whether we're ignoring this macro.\n      StringRef MacroDef = I.first;\n      if (hsOpts.ModulesIgnoreMacros.count(\n              llvm::CachedHashString(MacroDef.split('=').first)))\n        continue;\n    }\n\n    code = hash_combine(code, I.first, I.second);\n  }\n\n  // Extend the signature with the sysroot and other header search options.\n  code = hash_combine(code, hsOpts.Sysroot,\n                      hsOpts.ModuleFormat,\n                      hsOpts.UseDebugInfo,\n                      hsOpts.UseBuiltinIncludes,\n                      hsOpts.UseStandardSystemIncludes,\n                      hsOpts.UseStandardCXXIncludes,\n                      hsOpts.UseLibcxx,\n                      hsOpts.ModulesValidateDiagnosticOptions);\n  code = hash_combine(code, hsOpts.ResourceDir);\n\n  if (hsOpts.ModulesStrictContextHash) {\n    hash_code SHPC = hash_combine_range(hsOpts.SystemHeaderPrefixes.begin(),\n                                        hsOpts.SystemHeaderPrefixes.end());\n    hash_code UEC = hash_combine_range(hsOpts.UserEntries.begin(),\n                                       hsOpts.UserEntries.end());\n    code = hash_combine(code, hsOpts.SystemHeaderPrefixes.size(), SHPC,\n                        hsOpts.UserEntries.size(), UEC);\n\n    const DiagnosticOptions &diagOpts = getDiagnosticOpts();\n    #define DIAGOPT(Name, Bits, Default) \\\n      code = hash_combine(code, diagOpts.Name);\n    #define ENUM_DIAGOPT(Name, Type, Bits, Default) \\\n      code = hash_combine(code, diagOpts.get##Name());\n    #include \"clang/Basic/DiagnosticOptions.def\"\n    #undef DIAGOPT\n    #undef ENUM_DIAGOPT\n  }\n\n  // Extend the signature with the user build path.\n  code = hash_combine(code, hsOpts.ModuleUserBuildPath);\n\n  // Extend the signature with the module file extensions.\n  const FrontendOptions &frontendOpts = getFrontendOpts();\n  for (const auto &ext : frontendOpts.ModuleFileExtensions) {\n    code = ext->hashExtension(code);\n  }\n\n  // When compiling with -gmodules, also hash -fdebug-prefix-map as it\n  // affects the debug info in the PCM.\n  if (getCodeGenOpts().DebugTypeExtRefs)\n    for (const auto &KeyValue : getCodeGenOpts().DebugPrefixMap)\n      code = hash_combine(code, KeyValue.first, KeyValue.second);\n\n  // Extend the signature with the enabled sanitizers, if at least one is\n  // enabled. Sanitizers which cannot affect AST generation aren't hashed.\n  SanitizerSet SanHash = LangOpts->Sanitize;\n  SanHash.clear(getPPTransparentSanitizers());\n  if (!SanHash.empty())\n    code = hash_combine(code, SanHash.Mask);\n\n  return llvm::APInt(64, code).toString(36, /*Signed=*/false);\n}\n\nvoid CompilerInvocation::generateCC1CommandLine(\n    SmallVectorImpl<const char *> &Args, StringAllocator SA) const {\n  llvm::Triple T(TargetOpts->Triple);\n\n  GenerateFileSystemArgs(FileSystemOpts, Args, SA);\n  GenerateMigratorArgs(MigratorOpts, Args, SA);\n  GenerateAnalyzerArgs(*AnalyzerOpts, Args, SA);\n  GenerateDiagnosticArgs(*DiagnosticOpts, Args, SA, false);\n  GenerateFrontendArgs(FrontendOpts, Args, SA, LangOpts->IsHeaderFile);\n  GenerateTargetArgs(*TargetOpts, Args, SA);\n  GenerateHeaderSearchArgs(*HeaderSearchOpts, Args, SA);\n\n  InputKind DashX = FrontendOpts.DashX;\n  if (DashX.getFormat() == InputKind::Precompiled ||\n      DashX.getLanguage() == Language::LLVM_IR) {\n    if (LangOpts->ObjCAutoRefCount)\n      GenerateArg(Args, OPT_fobjc_arc, SA);\n    if (LangOpts->PICLevel != 0)\n      GenerateArg(Args, OPT_pic_level, Twine(LangOpts->PICLevel), SA);\n    if (LangOpts->PIE)\n      GenerateArg(Args, OPT_pic_is_pie, SA);\n    for (StringRef Sanitizer : serializeSanitizerKinds(LangOpts->Sanitize))\n      GenerateArg(Args, OPT_fsanitize_EQ, Sanitizer, SA);\n  } else {\n    // FIXME: Move this whole condition into GenerateLangArgs. (And do the same\n    // for ParseLangArgs).\n    GenerateLangArgs(*LangOpts, Args, SA, T);\n  }\n\n  GenerateCodeGenArgs(CodeGenOpts, Args, SA, T, FrontendOpts.OutputFile,\n                      &*LangOpts);\n  GeneratePreprocessorArgs(*PreprocessorOpts, Args, SA, *LangOpts, FrontendOpts,\n                           CodeGenOpts);\n  GeneratePreprocessorOutputArgs(PreprocessorOutputOpts, Args, SA,\n                                 FrontendOpts.ProgramAction);\n  GenerateDependencyOutputArgs(DependencyOutputOpts, Args, SA);\n}\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem>\nclang::createVFSFromCompilerInvocation(const CompilerInvocation &CI,\n                                       DiagnosticsEngine &Diags) {\n  return createVFSFromCompilerInvocation(CI, Diags,\n                                         llvm::vfs::getRealFileSystem());\n}\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem>\nclang::createVFSFromCompilerInvocation(\n    const CompilerInvocation &CI, DiagnosticsEngine &Diags,\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS) {\n  if (CI.getHeaderSearchOpts().VFSOverlayFiles.empty())\n    return BaseFS;\n\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem> Result = BaseFS;\n  // earlier vfs files are on the bottom\n  for (const auto &File : CI.getHeaderSearchOpts().VFSOverlayFiles) {\n    llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> Buffer =\n        Result->getBufferForFile(File);\n    if (!Buffer) {\n      Diags.Report(diag::err_missing_vfs_overlay_file) << File;\n      continue;\n    }\n\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS = llvm::vfs::getVFSFromYAML(\n        std::move(Buffer.get()), /*DiagHandler*/ nullptr, File,\n        /*DiagContext*/ nullptr, Result);\n    if (!FS) {\n      Diags.Report(diag::err_invalid_vfs_overlay) << File;\n      continue;\n    }\n\n    Result = FS;\n  }\n  return Result;\n}\n"}}, "reports": [{"events": [{"location": {"col": 25, "file": 59, "line": 112}, "message": "mark 'noexcept'"}, {"location": {"col": 25, "file": 59, "line": 112}, "message": "default constructor 'CompilerInvocationBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp", "reportHash": "7c3d6bf633730b394b40769135974863", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
