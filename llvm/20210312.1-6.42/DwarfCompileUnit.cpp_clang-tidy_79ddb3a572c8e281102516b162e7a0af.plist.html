<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "content": "//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a hash set that can be used to remove duplication of nodes\n// in a graph.  This code was originally created by Chris Lattner for use with\n// SelectionDAGCSEMap, but was isolated to provide use across the llvm code set.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_FOLDINGSET_H\n#define LLVM_ADT_FOLDINGSET_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\n/// This folding set used for two purposes:\n///   1. Given information about a node we want to create, look up the unique\n///      instance of the node in the set.  If the node already exists, return\n///      it, otherwise return the bucket it should be inserted into.\n///   2. Given a node that has already been created, remove it from the set.\n///\n/// This class is implemented as a single-link chained hash table, where the\n/// \"buckets\" are actually the nodes themselves (the next pointer is in the\n/// node).  The last node points back to the bucket to simplify node removal.\n///\n/// Any node that is to be included in the folding set must be a subclass of\n/// FoldingSetNode.  The node class must also define a Profile method used to\n/// establish the unique bits of data for the node.  The Profile method is\n/// passed a FoldingSetNodeID object which is used to gather the bits.  Just\n/// call one of the Add* functions defined in the FoldingSetBase::NodeID class.\n/// NOTE: That the folding set does not own the nodes and it is the\n/// responsibility of the user to dispose of the nodes.\n///\n/// Eg.\n///    class MyNode : public FoldingSetNode {\n///    private:\n///      std::string Name;\n///      unsigned Value;\n///    public:\n///      MyNode(const char *N, unsigned V) : Name(N), Value(V) {}\n///       ...\n///      void Profile(FoldingSetNodeID &ID) const {\n///        ID.AddString(Name);\n///        ID.AddInteger(Value);\n///      }\n///      ...\n///    };\n///\n/// To define the folding set itself use the FoldingSet template;\n///\n/// Eg.\n///    FoldingSet<MyNode> MyFoldingSet;\n///\n/// Four public methods are available to manipulate the folding set;\n///\n/// 1) If you have an existing node that you want add to the set but unsure\n/// that the node might already exist then call;\n///\n///    MyNode *M = MyFoldingSet.GetOrInsertNode(N);\n///\n/// If The result is equal to the input then the node has been inserted.\n/// Otherwise, the result is the node existing in the folding set, and the\n/// input can be discarded (use the result instead.)\n///\n/// 2) If you are ready to construct a node but want to check if it already\n/// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to\n/// check;\n///\n///   FoldingSetNodeID ID;\n///   ID.AddString(Name);\n///   ID.AddInteger(Value);\n///   void *InsertPoint;\n///\n///    MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);\n///\n/// If found then M will be non-NULL, else InsertPoint will point to where it\n/// should be inserted using InsertNode.\n///\n/// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a\n/// new node with InsertNode;\n///\n///    MyFoldingSet.InsertNode(M, InsertPoint);\n///\n/// 4) Finally, if you want to remove a node from the folding set call;\n///\n///    bool WasRemoved = MyFoldingSet.RemoveNode(M);\n///\n/// The result indicates whether the node existed in the folding set.\n\nclass FoldingSetNodeID;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBase - Implements the folding set functionality.  The main\n/// structure is an array of buckets.  Each bucket is indexed by the hash of\n/// the nodes it contains.  The bucket itself points to the nodes contained\n/// in the bucket via a singly linked list.  The last node in the list points\n/// back to the bucket to facilitate node removal.\n///\nclass FoldingSetBase {\nprotected:\n  /// Buckets - Array of bucket chains.\n  void **Buckets;\n\n  /// NumBuckets - Length of the Buckets array.  Always a power of 2.\n  unsigned NumBuckets;\n\n  /// NumNodes - Number of nodes in the folding set. Growth occurs when NumNodes\n  /// is greater than twice the number of buckets.\n  unsigned NumNodes;\n\n  explicit FoldingSetBase(unsigned Log2InitSize = 6);\n  FoldingSetBase(FoldingSetBase &&Arg);\n  FoldingSetBase &operator=(FoldingSetBase &&RHS);\n  ~FoldingSetBase();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  /// Node - This class is used to maintain the singly linked bucket list in\n  /// a folding set.\n  class Node {\n  private:\n    // NextInFoldingSetBucket - next link in the bucket list.\n    void *NextInFoldingSetBucket = nullptr;\n\n  public:\n    Node() = default;\n\n    // Accessors\n    void *getNextInBucket() const { return NextInFoldingSetBucket; }\n    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }\n  };\n\n  /// clear - Remove all nodes from the folding set.\n  void clear();\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return NumNodes; }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return NumNodes == 0; }\n\n  /// capacity - Returns the number of nodes permitted in the folding set\n  /// before a rebucket operation is performed.\n  unsigned capacity() {\n    // We allow a load factor of up to 2.0,\n    // so that means our capacity is NumBuckets * 2\n    return NumBuckets * 2;\n  }\n\nprotected:\n  /// Functions provided by the derived class to compute folding properties.\n  /// This is effectively a vtable for FoldingSetBase, except that we don't\n  /// actually store a pointer to it in the object.\n  struct FoldingSetInfo {\n    /// GetNodeProfile - Instantiations of the FoldingSet template implement\n    /// this function to gather data bits for the given node.\n    void (*GetNodeProfile)(const FoldingSetBase *Self, Node *N,\n                           FoldingSetNodeID &ID);\n\n    /// NodeEquals - Instantiations of the FoldingSet template implement\n    /// this function to compare the given node with the given ID.\n    bool (*NodeEquals)(const FoldingSetBase *Self, Node *N,\n                       const FoldingSetNodeID &ID, unsigned IDHash,\n                       FoldingSetNodeID &TempID);\n\n    /// ComputeNodeHash - Instantiations of the FoldingSet template implement\n    /// this function to compute a hash value for the given node.\n    unsigned (*ComputeNodeHash)(const FoldingSetBase *Self, Node *N,\n                                FoldingSetNodeID &TempID);\n  };\n\nprivate:\n  /// GrowHashTable - Double the size of the hash table and rehash everything.\n  void GrowHashTable(const FoldingSetInfo &Info);\n\n  /// GrowBucketCount - resize the hash table and rehash everything.\n  /// NewBucketCount must be a power of two, and must be greater than the old\n  /// bucket count.\n  void GrowBucketCount(unsigned NewBucketCount, const FoldingSetInfo &Info);\n\nprotected:\n  // The below methods are protected to encourage subclasses to provide a more\n  // type-safe API.\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount, const FoldingSetInfo &Info);\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(Node *N);\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and return\n  /// it instead.\n  Node *GetOrInsertNode(Node *N, const FoldingSetInfo &Info);\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos,\n                            const FoldingSetInfo &Info);\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(Node *N, void *InsertPos, const FoldingSetInfo &Info);\n};\n\n//===----------------------------------------------------------------------===//\n\n/// DefaultFoldingSetTrait - This class provides default implementations\n/// for FoldingSetTrait implementations.\ntemplate<typename T> struct DefaultFoldingSetTrait {\n  static void Profile(const T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n  static void Profile(T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n\n  // Equals - Test if the profile for X would match ID, using TempID\n  // to compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular comparison. Implementations\n  // can override this to provide more efficient implementations.\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID);\n\n  // ComputeHash - Compute a hash value for X, using TempID to\n  // compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular hash computation.\n  // Implementations can override this to provide more efficient\n  // implementations.\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);\n};\n\n/// FoldingSetTrait - This trait class is used to define behavior of how\n/// to \"profile\" (in the FoldingSet parlance) an object of a given type.\n/// The default behavior is to invoke a 'Profile' method on an object, but\n/// through template specialization the behavior can be tailored for specific\n/// types.  Combined with the FoldingSetNodeWrapper class, one can add objects\n/// to FoldingSets that were not originally designed to have that behavior.\ntemplate<typename T> struct FoldingSetTrait\n  : public DefaultFoldingSetTrait<T> {};\n\n/// DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait, but\n/// for ContextualFoldingSets.\ntemplate<typename T, typename Ctx>\nstruct DefaultContextualFoldingSetTrait {\n  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {\n    X.Profile(ID, Context);\n  }\n\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID, Ctx Context);\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,\n                                     Ctx Context);\n};\n\n/// ContextualFoldingSetTrait - Like FoldingSetTrait, but for\n/// ContextualFoldingSets.\ntemplate<typename T, typename Ctx> struct ContextualFoldingSetTrait\n  : public DefaultContextualFoldingSetTrait<T, Ctx> {};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeIDRef - This class describes a reference to an interned\n/// FoldingSetNodeID, which can be a useful to store node id data rather\n/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector\n/// is often much larger than necessary, and the possibility of heap\n/// allocation means it requires a non-trivial destructor call.\nclass FoldingSetNodeIDRef {\n  const unsigned *Data = nullptr;\n  size_t Size = 0;\n\npublic:\n  FoldingSetNodeIDRef() = default;\n  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,\n  /// used to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  bool operator==(FoldingSetNodeIDRef) const;\n\n  bool operator!=(FoldingSetNodeIDRef RHS) const { return !(*this == RHS); }\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(FoldingSetNodeIDRef) const;\n\n  const unsigned *getData() const { return Data; }\n  size_t getSize() const { return Size; }\n};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeID - This class is used to gather all the unique data bits of\n/// a node.  When all the bits are gathered this class is used to produce a\n/// hash value for the node.\nclass FoldingSetNodeID {\n  /// Bits - Vector of all the data bits that make the node unique.\n  /// Use a SmallVector to avoid a heap allocation in the common case.\n  SmallVector<unsigned, 32> Bits;\n\npublic:\n  FoldingSetNodeID() = default;\n\n  FoldingSetNodeID(FoldingSetNodeIDRef Ref)\n    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}\n\n  /// Add* - Add various data types to Bit data.\n  void AddPointer(const void *Ptr);\n  void AddInteger(signed I);\n  void AddInteger(unsigned I);\n  void AddInteger(long I);\n  void AddInteger(unsigned long I);\n  void AddInteger(long long I);\n  void AddInteger(unsigned long long I);\n  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }\n  void AddString(StringRef String);\n  void AddNodeID(const FoldingSetNodeID &ID);\n\n  template <typename T>\n  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }\n\n  /// clear - Clear the accumulated profile, allowing this FoldingSetNodeID\n  /// object to be used to compute a new profile.\n  inline void clear() { Bits.clear(); }\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used\n  /// to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  /// operator== - Used to compare two nodes to each other.\n  bool operator==(const FoldingSetNodeID &RHS) const;\n  bool operator==(const FoldingSetNodeIDRef RHS) const;\n\n  bool operator!=(const FoldingSetNodeID &RHS) const { return !(*this == RHS); }\n  bool operator!=(const FoldingSetNodeIDRef RHS) const { return !(*this ==RHS);}\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(const FoldingSetNodeID &RHS) const;\n  bool operator<(const FoldingSetNodeIDRef RHS) const;\n\n  /// Intern - Copy this node's data to a memory region allocated from the\n  /// given allocator and return a FoldingSetNodeIDRef describing the\n  /// interned data.\n  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;\n};\n\n// Convenience type to hide the implementation of the folding set.\nusing FoldingSetNode = FoldingSetBase::Node;\ntemplate<class T> class FoldingSetIterator;\ntemplate<class T> class FoldingSetBucketIterator;\n\n// Definitions of FoldingSetTrait and ContextualFoldingSetTrait functions, which\n// require the definition of FoldingSetNodeID.\ntemplate<typename T>\ninline bool\nDefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,\n                                  unsigned /*IDHash*/,\n                                  FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID == ID;\n}\ntemplate<typename T>\ninline unsigned\nDefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID.ComputeHash();\n}\ntemplate<typename T, typename Ctx>\ninline bool\nDefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,\n                                                 const FoldingSetNodeID &ID,\n                                                 unsigned /*IDHash*/,\n                                                 FoldingSetNodeID &TempID,\n                                                 Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID == ID;\n}\ntemplate<typename T, typename Ctx>\ninline unsigned\nDefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,\n                                                      FoldingSetNodeID &TempID,\n                                                      Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID.ComputeHash();\n}\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetImpl - An implementation detail that lets us share code between\n/// FoldingSet and ContextualFoldingSet.\ntemplate <class Derived, class T> class FoldingSetImpl : public FoldingSetBase {\nprotected:\n  explicit FoldingSetImpl(unsigned Log2InitSize)\n      : FoldingSetBase(Log2InitSize) {}\n\n  FoldingSetImpl(FoldingSetImpl &&Arg) = default;\n  FoldingSetImpl &operator=(FoldingSetImpl &&RHS) = default;\n  ~FoldingSetImpl() = default;\n\npublic:\n  using iterator = FoldingSetIterator<T>;\n\n  iterator begin() { return iterator(Buckets); }\n  iterator end() { return iterator(Buckets+NumBuckets); }\n\n  using const_iterator = FoldingSetIterator<const T>;\n\n  const_iterator begin() const { return const_iterator(Buckets); }\n  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }\n\n  using bucket_iterator = FoldingSetBucketIterator<T>;\n\n  bucket_iterator bucket_begin(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));\n  }\n\n  bucket_iterator bucket_end(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);\n  }\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount) {\n    return FoldingSetBase::reserve(EltCount, Derived::getFoldingSetInfo());\n  }\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(T *N) {\n    return FoldingSetBase::RemoveNode(N);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    return static_cast<T *>(\n        FoldingSetBase::GetOrInsertNode(N, Derived::getFoldingSetInfo()));\n  }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return static_cast<T *>(FoldingSetBase::FindNodeOrInsertPos(\n        ID, InsertPos, Derived::getFoldingSetInfo()));\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    FoldingSetBase::InsertNode(N, InsertPos, Derived::getFoldingSetInfo());\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    T *Inserted = GetOrInsertNode(N);\n    (void)Inserted;\n    assert(Inserted == N && \"Node already inserted!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSet - This template class is used to instantiate a specialized\n/// implementation of the folding set to the node class T.  T must be a\n/// subclass of FoldingSetNode and implement a Profile function.\n///\n/// Note that this set type is movable and move-assignable. However, its\n/// moved-from state is not a valid state for anything other than\n/// move-assigning and destroying. This is primarily to enable movable APIs\n/// that incorporate these objects.\ntemplate <class T>\nclass FoldingSet : public FoldingSetImpl<FoldingSet<T>, T> {\n  using Super = FoldingSetImpl<FoldingSet, T>;\n  using Node = typename Super::Node;\n\n  /// GetNodeProfile - Each instantiation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    FoldingSetTrait<T>::Profile(*TN, ID);\n  }\n\n  /// NodeEquals - Instantiations may optionally provide a way to compare a\n  /// node with a specified ID.\n  static bool NodeEquals(const FoldingSetBase *, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);\n  }\n\n  /// ComputeNodeHash - Instantiations may optionally provide a way to compute a\n  /// hash value directly from a node.\n  static unsigned ComputeNodeHash(const FoldingSetBase *, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit FoldingSet(unsigned Log2InitSize = 6) : Super(Log2InitSize) {}\n  FoldingSet(FoldingSet &&Arg) = default;\n  FoldingSet &operator=(FoldingSet &&RHS) = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// ContextualFoldingSet - This template class is a further refinement\n/// of FoldingSet which provides a context argument when calling\n/// Profile on its nodes.  Currently, that argument is fixed at\n/// initialization time.\n///\n/// T must be a subclass of FoldingSetNode and implement a Profile\n/// function with signature\n///   void Profile(FoldingSetNodeID &, Ctx);\ntemplate <class T, class Ctx>\nclass ContextualFoldingSet\n    : public FoldingSetImpl<ContextualFoldingSet<T, Ctx>, T> {\n  // Unfortunately, this can't derive from FoldingSet<T> because the\n  // construction of the vtable for FoldingSet<T> requires\n  // FoldingSet<T>::GetNodeProfile to be instantiated, which in turn\n  // requires a single-argument T::Profile().\n\n  using Super = FoldingSetImpl<ContextualFoldingSet, T>;\n  using Node = typename Super::Node;\n\n  Ctx Context;\n\n  static const Ctx &getContext(const FoldingSetBase *Base) {\n    return static_cast<const ContextualFoldingSet*>(Base)->Context;\n  }\n\n  /// GetNodeProfile - Each instantiatation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *Base, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, getContext(Base));\n  }\n\n  static bool NodeEquals(const FoldingSetBase *Base, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,\n                                                     getContext(Base));\n  }\n\n  static unsigned ComputeNodeHash(const FoldingSetBase *Base, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID,\n                                                          getContext(Base));\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)\n      : Super(Log2InitSize), Context(Context) {}\n\n  Ctx getContext() const { return Context; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetVector - This template class combines a FoldingSet and a vector\n/// to provide the interface of FoldingSet but with deterministic iteration\n/// order based on the insertion order. T must be a subclass of FoldingSetNode\n/// and implement a Profile function.\ntemplate <class T, class VectorT = SmallVector<T*, 8>>\nclass FoldingSetVector {\n  FoldingSet<T> Set;\n  VectorT Vector;\n\npublic:\n  explicit FoldingSetVector(unsigned Log2InitSize = 6) : Set(Log2InitSize) {}\n\n  using iterator = pointee_iterator<typename VectorT::iterator>;\n\n  iterator begin() { return Vector.begin(); }\n  iterator end()   { return Vector.end(); }\n\n  using const_iterator = pointee_iterator<typename VectorT::const_iterator>;\n\n  const_iterator begin() const { return Vector.begin(); }\n  const_iterator end()   const { return Vector.end(); }\n\n  /// clear - Remove all nodes from the folding set.\n  void clear() { Set.clear(); Vector.clear(); }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return Set.FindNodeOrInsertPos(ID, InsertPos);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    T *Result = Set.GetOrInsertNode(N);\n    if (Result == N) Vector.push_back(N);\n    return Result;\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    Set.InsertNode(N, InsertPos);\n    Vector.push_back(N);\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    Set.InsertNode(N);\n    Vector.push_back(N);\n  }\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return Set.size(); }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return Set.empty(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetIteratorImpl - This is the common iterator support shared by all\n/// folding sets, which knows how to walk the folding set hash table.\nclass FoldingSetIteratorImpl {\nprotected:\n  FoldingSetNode *NodePtr;\n\n  FoldingSetIteratorImpl(void **Bucket);\n\n  void advance();\n\npublic:\n  bool operator==(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr == RHS.NodePtr;\n  }\n  bool operator!=(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr != RHS.NodePtr;\n  }\n};\n\ntemplate <class T> class FoldingSetIterator : public FoldingSetIteratorImpl {\npublic:\n  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}\n\n  T &operator*() const {\n    return *static_cast<T*>(NodePtr);\n  }\n\n  T *operator->() const {\n    return static_cast<T*>(NodePtr);\n  }\n\n  inline FoldingSetIterator &operator++() {          // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetIterator operator++(int) {        // Postincrement\n    FoldingSetIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBucketIteratorImpl - This is the common bucket iterator support\n/// shared by all folding sets, which knows how to walk a particular bucket\n/// of a folding set hash table.\nclass FoldingSetBucketIteratorImpl {\nprotected:\n  void *Ptr;\n\n  explicit FoldingSetBucketIteratorImpl(void **Bucket);\n\n  FoldingSetBucketIteratorImpl(void **Bucket, bool) : Ptr(Bucket) {}\n\n  void advance() {\n    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();\n    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;\n    Ptr = reinterpret_cast<void*>(x);\n  }\n\npublic:\n  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr == RHS.Ptr;\n  }\n  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr != RHS.Ptr;\n  }\n};\n\ntemplate <class T>\nclass FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {\npublic:\n  explicit FoldingSetBucketIterator(void **Bucket) :\n    FoldingSetBucketIteratorImpl(Bucket) {}\n\n  FoldingSetBucketIterator(void **Bucket, bool) :\n    FoldingSetBucketIteratorImpl(Bucket, true) {}\n\n  T &operator*() const { return *static_cast<T*>(Ptr); }\n  T *operator->() const { return static_cast<T*>(Ptr); }\n\n  inline FoldingSetBucketIterator &operator++() { // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetBucketIterator operator++(int) {      // Postincrement\n    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetNodeWrapper - This template class is used to \"wrap\" arbitrary\n/// types in an enclosing object so that they can be inserted into FoldingSets.\ntemplate <typename T>\nclass FoldingSetNodeWrapper : public FoldingSetNode {\n  T data;\n\npublic:\n  template <typename... Ts>\n  explicit FoldingSetNodeWrapper(Ts &&... Args)\n      : data(std::forward<Ts>(Args)...) {}\n\n  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }\n\n  T &getValue() { return data; }\n  const T &getValue() const { return data; }\n\n  operator T&() { return data; }\n  operator const T&() const { return data; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FastFoldingSetNode - This is a subclass of FoldingSetNode which stores\n/// a FoldingSetNodeID value rather than requiring the node to recompute it\n/// each time it is needed. This trades space for speed (which can be\n/// significant if the ID is long), and it also permits nodes to drop\n/// information that would otherwise only be required for recomputing an ID.\nclass FastFoldingSetNode : public FoldingSetNode {\n  FoldingSetNodeID FastID;\n\nprotected:\n  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}\n\npublic:\n  void Profile(FoldingSetNodeID &ID) const { ID.AddNodeID(FastID); }\n};\n\n//===----------------------------------------------------------------------===//\n// Partial specializations of FoldingSetTrait.\n\ntemplate<typename T> struct FoldingSetTrait<T*> {\n  static inline void Profile(T *X, FoldingSetNodeID &ID) {\n    ID.AddPointer(X);\n  }\n};\ntemplate <typename T1, typename T2>\nstruct FoldingSetTrait<std::pair<T1, T2>> {\n  static inline void Profile(const std::pair<T1, T2> &P,\n                             FoldingSetNodeID &ID) {\n    ID.Add(P.first);\n    ID.Add(P.second);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_FOLDINGSET_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "content": "//===- llvm/ADT/PointerSumType.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERSUMTYPE_H\n#define LLVM_ADT_POINTERSUMTYPE_H\n\n#include \"llvm/ADT/bit.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstdint>\n#include <type_traits>\n\nnamespace llvm {\n\n/// A compile time pair of an integer tag and the pointer-like type which it\n/// indexes within a sum type. Also allows the user to specify a particular\n/// traits class for pointer types with custom behavior such as over-aligned\n/// allocation.\ntemplate <uintptr_t N, typename PointerArgT,\n          typename TraitsArgT = PointerLikeTypeTraits<PointerArgT>>\nstruct PointerSumTypeMember {\n  enum { Tag = N };\n  using PointerT = PointerArgT;\n  using TraitsT = TraitsArgT;\n};\n\nnamespace detail {\n\ntemplate <typename TagT, typename... MemberTs> struct PointerSumTypeHelper;\n\n} // end namespace detail\n\n/// A sum type over pointer-like types.\n///\n/// This is a normal tagged union across pointer-like types that uses the low\n/// bits of the pointers to store the tag.\n///\n/// Each member of the sum type is specified by passing a \\c\n/// PointerSumTypeMember specialization in the variadic member argument list.\n/// This allows the user to control the particular tag value associated with\n/// a particular type, use the same type for multiple different tags, and\n/// customize the pointer-like traits used for a particular member. Note that\n/// these *must* be specializations of \\c PointerSumTypeMember, no other type\n/// will suffice, even if it provides a compatible interface.\n///\n/// This type implements all of the comparison operators and even hash table\n/// support by comparing the underlying storage of the pointer values. It\n/// doesn't support delegating to particular members for comparisons.\n///\n/// It also default constructs to a zero tag with a null pointer, whatever that\n/// would be. This means that the zero value for the tag type is significant\n/// and may be desirable to set to a state that is particularly desirable to\n/// default construct.\n///\n/// Having a supported zero-valued tag also enables getting the address of a\n/// pointer stored with that tag provided it is stored in its natural bit\n/// representation. This works because in the case of a zero-valued tag, the\n/// pointer's value is directly stored into this object and we can expose the\n/// address of that internal storage. This is especially useful when building an\n/// `ArrayRef` of a single pointer stored in a sum type.\n///\n/// There is no support for constructing or accessing with a dynamic tag as\n/// that would fundamentally violate the type safety provided by the sum type.\ntemplate <typename TagT, typename... MemberTs> class PointerSumType {\n  using HelperT = detail::PointerSumTypeHelper<TagT, MemberTs...>;\n\n  // We keep both the raw value and the min tag value's pointer in a union. When\n  // the minimum tag value is zero, this allows code below to cleanly expose the\n  // address of the zero-tag pointer instead of just the zero-tag pointer\n  // itself. This is especially useful when building `ArrayRef`s out of a single\n  // pointer. However, we have to carefully access the union due to the active\n  // member potentially changing. When we *store* a new value, we directly\n  // access the union to allow us to store using the obvious types. However,\n  // when we *read* a value, we copy the underlying storage out to avoid relying\n  // on one member or the other being active.\n  union StorageT {\n    // Ensure we get a null default constructed value. We don't use a member\n    // initializer because some compilers seem to not implement those correctly\n    // for a union.\n    StorageT() : Value(0) {}\n\n    uintptr_t Value;\n\n    typename HelperT::template Lookup<HelperT::MinTag>::PointerT MinTagPointer;\n  };\n\n  StorageT Storage;\n\npublic:\n  constexpr PointerSumType() = default;\n\n  /// A typed setter to a given tagged member of the sum type.\n  template <TagT N>\n  void set(typename HelperT::template Lookup<N>::PointerT Pointer) {\n    void *V = HelperT::template Lookup<N>::TraitsT::getAsVoidPointer(Pointer);\n    assert((reinterpret_cast<uintptr_t>(V) & HelperT::TagMask) == 0 &&\n           \"Pointer is insufficiently aligned to store the discriminant!\");\n    Storage.Value = reinterpret_cast<uintptr_t>(V) | N;\n  }\n\n  /// A typed constructor for a specific tagged member of the sum type.\n  template <TagT N>\n  static PointerSumType\n  create(typename HelperT::template Lookup<N>::PointerT Pointer) {\n    PointerSumType Result;\n    Result.set<N>(Pointer);\n    return Result;\n  }\n\n  /// Clear the value to null with the min tag type.\n  void clear() { set<HelperT::MinTag>(nullptr); }\n\n  TagT getTag() const {\n    return static_cast<TagT>(getOpaqueValue() & HelperT::TagMask);\n  }\n\n  template <TagT N> bool is() const { return N == getTag(); }\n\n  template <TagT N> typename HelperT::template Lookup<N>::PointerT get() const {\n    void *P = is<N>() ? getVoidPtr() : nullptr;\n    return HelperT::template Lookup<N>::TraitsT::getFromVoidPointer(P);\n  }\n\n  template <TagT N>\n  typename HelperT::template Lookup<N>::PointerT cast() const {\n    assert(is<N>() && \"This instance has a different active member.\");\n    return HelperT::template Lookup<N>::TraitsT::getFromVoidPointer(\n        getVoidPtr());\n  }\n\n  /// If the tag is zero and the pointer's value isn't changed when being\n  /// stored, get the address of the stored value type-punned to the zero-tag's\n  /// pointer type.\n  typename HelperT::template Lookup<HelperT::MinTag>::PointerT const *\n  getAddrOfZeroTagPointer() const {\n    return const_cast<PointerSumType *>(this)->getAddrOfZeroTagPointer();\n  }\n\n  /// If the tag is zero and the pointer's value isn't changed when being\n  /// stored, get the address of the stored value type-punned to the zero-tag's\n  /// pointer type.\n  typename HelperT::template Lookup<HelperT::MinTag>::PointerT *\n  getAddrOfZeroTagPointer() {\n    static_assert(HelperT::MinTag == 0, \"Non-zero minimum tag value!\");\n    assert(is<HelperT::MinTag>() && \"The active tag is not zero!\");\n    // Store the initial value of the pointer when read out of our storage.\n    auto InitialPtr = get<HelperT::MinTag>();\n    // Now update the active member of the union to be the actual pointer-typed\n    // member so that accessing it indirectly through the returned address is\n    // valid.\n    Storage.MinTagPointer = InitialPtr;\n    // Finally, validate that this was a no-op as expected by reading it back\n    // out using the same underlying-storage read as above.\n    assert(InitialPtr == get<HelperT::MinTag>() &&\n           \"Switching to typed storage changed the pointer returned!\");\n    // Now we can correctly return an address to typed storage.\n    return &Storage.MinTagPointer;\n  }\n\n  explicit operator bool() const {\n    return getOpaqueValue() & HelperT::PointerMask;\n  }\n  bool operator==(const PointerSumType &R) const {\n    return getOpaqueValue() == R.getOpaqueValue();\n  }\n  bool operator!=(const PointerSumType &R) const {\n    return getOpaqueValue() != R.getOpaqueValue();\n  }\n  bool operator<(const PointerSumType &R) const {\n    return getOpaqueValue() < R.getOpaqueValue();\n  }\n  bool operator>(const PointerSumType &R) const {\n    return getOpaqueValue() > R.getOpaqueValue();\n  }\n  bool operator<=(const PointerSumType &R) const {\n    return getOpaqueValue() <= R.getOpaqueValue();\n  }\n  bool operator>=(const PointerSumType &R) const {\n    return getOpaqueValue() >= R.getOpaqueValue();\n  }\n\n  uintptr_t getOpaqueValue() const {\n    // Read the underlying storage of the union, regardless of the active\n    // member.\n    return bit_cast<uintptr_t>(Storage);\n  }\n\nprotected:\n  void *getVoidPtr() const {\n    return reinterpret_cast<void *>(getOpaqueValue() & HelperT::PointerMask);\n  }\n};\n\nnamespace detail {\n\n/// A helper template for implementing \\c PointerSumType. It provides fast\n/// compile-time lookup of the member from a particular tag value, along with\n/// useful constants and compile time checking infrastructure..\ntemplate <typename TagT, typename... MemberTs>\nstruct PointerSumTypeHelper : MemberTs... {\n  // First we use a trick to allow quickly looking up information about\n  // a particular member of the sum type. This works because we arranged to\n  // have this type derive from all of the member type templates. We can select\n  // the matching member for a tag using type deduction during overload\n  // resolution.\n  template <TagT N, typename PointerT, typename TraitsT>\n  static PointerSumTypeMember<N, PointerT, TraitsT>\n  LookupOverload(PointerSumTypeMember<N, PointerT, TraitsT> *);\n  template <TagT N> static void LookupOverload(...);\n  template <TagT N> struct Lookup {\n    // Compute a particular member type by resolving the lookup helper overload.\n    using MemberT = decltype(\n        LookupOverload<N>(static_cast<PointerSumTypeHelper *>(nullptr)));\n\n    /// The Nth member's pointer type.\n    using PointerT = typename MemberT::PointerT;\n\n    /// The Nth member's traits type.\n    using TraitsT = typename MemberT::TraitsT;\n  };\n\n  // Next we need to compute the number of bits available for the discriminant\n  // by taking the min of the bits available for each member. Much of this\n  // would be amazingly easier with good constexpr support.\n  template <uintptr_t V, uintptr_t... Vs>\n  struct Min : std::integral_constant<\n                   uintptr_t, (V < Min<Vs...>::value ? V : Min<Vs...>::value)> {\n  };\n  template <uintptr_t V>\n  struct Min<V> : std::integral_constant<uintptr_t, V> {};\n  enum { NumTagBits = Min<MemberTs::TraitsT::NumLowBitsAvailable...>::value };\n\n  // Also compute the smallest discriminant and various masks for convenience.\n  constexpr static TagT MinTag =\n      static_cast<TagT>(Min<MemberTs::Tag...>::value);\n  enum : uint64_t {\n    PointerMask = static_cast<uint64_t>(-1) << NumTagBits,\n    TagMask = ~PointerMask\n  };\n\n  // Finally we need a recursive template to do static checks of each\n  // member.\n  template <typename MemberT, typename... InnerMemberTs>\n  struct Checker : Checker<InnerMemberTs...> {\n    static_assert(MemberT::Tag < (1 << NumTagBits),\n                  \"This discriminant value requires too many bits!\");\n  };\n  template <typename MemberT> struct Checker<MemberT> : std::true_type {\n    static_assert(MemberT::Tag < (1 << NumTagBits),\n                  \"This discriminant value requires too many bits!\");\n  };\n  static_assert(Checker<MemberTs...>::value,\n                \"Each member must pass the checker.\");\n};\n\n} // end namespace detail\n\n// Teach DenseMap how to use PointerSumTypes as keys.\ntemplate <typename TagT, typename... MemberTs>\nstruct DenseMapInfo<PointerSumType<TagT, MemberTs...>> {\n  using SumType = PointerSumType<TagT, MemberTs...>;\n  using HelperT = detail::PointerSumTypeHelper<TagT, MemberTs...>;\n  enum { SomeTag = HelperT::MinTag };\n  using SomePointerT =\n      typename HelperT::template Lookup<HelperT::MinTag>::PointerT;\n  using SomePointerInfo = DenseMapInfo<SomePointerT>;\n\n  static inline SumType getEmptyKey() {\n    return SumType::create<SomeTag>(SomePointerInfo::getEmptyKey());\n  }\n\n  static inline SumType getTombstoneKey() {\n    return SumType::create<SomeTag>(SomePointerInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const SumType &Arg) {\n    uintptr_t OpaqueValue = Arg.getOpaqueValue();\n    return DenseMapInfo<uintptr_t>::getHashValue(OpaqueValue);\n  }\n\n  static bool isEqual(const SumType &LHS, const SumType &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERSUMTYPE_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "content": "//===- llvm/ADT/SetVector.h - Set with insert order iteration ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a set that has insertion order iteration\n// characteristics. This is useful for keeping a set of things that need to be\n// visited later but in a deterministic order (insertion order). The interface\n// is purposefully minimal.\n//\n// This file defines SetVector and SmallSetVector, which performs no allocations\n// if the SetVector has less than a certain number of elements.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SETVECTOR_H\n#define LLVM_ADT_SETVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <vector>\n\nnamespace llvm {\n\n/// A vector that has set insertion semantics.\n///\n/// This adapter class provides a way to keep a set of things that also has the\n/// property of a deterministic iteration order. The order of iteration is the\n/// order of insertion.\ntemplate <typename T, typename Vector = std::vector<T>,\n          typename Set = DenseSet<T>>\nclass SetVector {\npublic:\n  using value_type = T;\n  using key_type = T;\n  using reference = T&;\n  using const_reference = const T&;\n  using set_type = Set;\n  using vector_type = Vector;\n  using iterator = typename vector_type::const_iterator;\n  using const_iterator = typename vector_type::const_iterator;\n  using reverse_iterator = typename vector_type::const_reverse_iterator;\n  using const_reverse_iterator = typename vector_type::const_reverse_iterator;\n  using size_type = typename vector_type::size_type;\n\n  /// Construct an empty SetVector\n  SetVector() = default;\n\n  /// Initialize a SetVector with a range of elements\n  template<typename It>\n  SetVector(It Start, It End) {\n    insert(Start, End);\n  }\n\n  ArrayRef<T> getArrayRef() const { return vector_; }\n\n  /// Clear the SetVector and return the underlying vector.\n  Vector takeVector() {\n    set_.clear();\n    return std::move(vector_);\n  }\n\n  /// Determine if the SetVector is empty or not.\n  bool empty() const {\n    return vector_.empty();\n  }\n\n  /// Determine the number of elements in the SetVector.\n  size_type size() const {\n    return vector_.size();\n  }\n\n  /// Get an iterator to the beginning of the SetVector.\n  iterator begin() {\n    return vector_.begin();\n  }\n\n  /// Get a const_iterator to the beginning of the SetVector.\n  const_iterator begin() const {\n    return vector_.begin();\n  }\n\n  /// Get an iterator to the end of the SetVector.\n  iterator end() {\n    return vector_.end();\n  }\n\n  /// Get a const_iterator to the end of the SetVector.\n  const_iterator end() const {\n    return vector_.end();\n  }\n\n  /// Get an reverse_iterator to the end of the SetVector.\n  reverse_iterator rbegin() {\n    return vector_.rbegin();\n  }\n\n  /// Get a const_reverse_iterator to the end of the SetVector.\n  const_reverse_iterator rbegin() const {\n    return vector_.rbegin();\n  }\n\n  /// Get a reverse_iterator to the beginning of the SetVector.\n  reverse_iterator rend() {\n    return vector_.rend();\n  }\n\n  /// Get a const_reverse_iterator to the beginning of the SetVector.\n  const_reverse_iterator rend() const {\n    return vector_.rend();\n  }\n\n  /// Return the first element of the SetVector.\n  const T &front() const {\n    assert(!empty() && \"Cannot call front() on empty SetVector!\");\n    return vector_.front();\n  }\n\n  /// Return the last element of the SetVector.\n  const T &back() const {\n    assert(!empty() && \"Cannot call back() on empty SetVector!\");\n    return vector_.back();\n  }\n\n  /// Index into the SetVector.\n  const_reference operator[](size_type n) const {\n    assert(n < vector_.size() && \"SetVector access out of range!\");\n    return vector_[n];\n  }\n\n  /// Insert a new element into the SetVector.\n  /// \\returns true if the element was inserted into the SetVector.\n  bool insert(const value_type &X) {\n    bool result = set_.insert(X).second;\n    if (result)\n      vector_.push_back(X);\n    return result;\n  }\n\n  /// Insert a range of elements into the SetVector.\n  template<typename It>\n  void insert(It Start, It End) {\n    for (; Start != End; ++Start)\n      if (set_.insert(*Start).second)\n        vector_.push_back(*Start);\n  }\n\n  /// Remove an item from the set vector.\n  bool remove(const value_type& X) {\n    if (set_.erase(X)) {\n      typename vector_type::iterator I = find(vector_, X);\n      assert(I != vector_.end() && \"Corrupted SetVector instances!\");\n      vector_.erase(I);\n      return true;\n    }\n    return false;\n  }\n\n  /// Erase a single element from the set vector.\n  /// \\returns an iterator pointing to the next element that followed the\n  /// element erased. This is the end of the SetVector if the last element is\n  /// erased.\n  iterator erase(iterator I) {\n    const key_type &V = *I;\n    assert(set_.count(V) && \"Corrupted SetVector instances!\");\n    set_.erase(V);\n\n    // FIXME: No need to use the non-const iterator when built with\n    // std::vector.erase(const_iterator) as defined in C++11. This is for\n    // compatibility with non-standard libstdc++ up to 4.8 (fixed in 4.9).\n    auto NI = vector_.begin();\n    std::advance(NI, std::distance<iterator>(NI, I));\n\n    return vector_.erase(NI);\n  }\n\n  /// Remove items from the set vector based on a predicate function.\n  ///\n  /// This is intended to be equivalent to the following code, if we could\n  /// write it:\n  ///\n  /// \\code\n  ///   V.erase(remove_if(V, P), V.end());\n  /// \\endcode\n  ///\n  /// However, SetVector doesn't expose non-const iterators, making any\n  /// algorithm like remove_if impossible to use.\n  ///\n  /// \\returns true if any element is removed.\n  template <typename UnaryPredicate>\n  bool remove_if(UnaryPredicate P) {\n    typename vector_type::iterator I =\n        llvm::remove_if(vector_, TestAndEraseFromSet<UnaryPredicate>(P, set_));\n    if (I == vector_.end())\n      return false;\n    vector_.erase(I, vector_.end());\n    return true;\n  }\n\n  /// Check if the SetVector contains the given key.\n  bool contains(const key_type &key) const {\n    return set_.find(key) != set_.end();\n  }\n\n  /// Count the number of elements of a given key in the SetVector.\n  /// \\returns 0 if the element is not in the SetVector, 1 if it is.\n  size_type count(const key_type &key) const {\n    return set_.count(key);\n  }\n\n  /// Completely clear the SetVector\n  void clear() {\n    set_.clear();\n    vector_.clear();\n  }\n\n  /// Remove the last element of the SetVector.\n  void pop_back() {\n    assert(!empty() && \"Cannot remove an element from an empty SetVector!\");\n    set_.erase(back());\n    vector_.pop_back();\n  }\n\n  LLVM_NODISCARD T pop_back_val() {\n    T Ret = back();\n    pop_back();\n    return Ret;\n  }\n\n  bool operator==(const SetVector &that) const {\n    return vector_ == that.vector_;\n  }\n\n  bool operator!=(const SetVector &that) const {\n    return vector_ != that.vector_;\n  }\n\n  /// Compute This := This u S, return whether 'This' changed.\n  /// TODO: We should be able to use set_union from SetOperations.h, but\n  ///       SetVector interface is inconsistent with DenseSet.\n  template <class STy>\n  bool set_union(const STy &S) {\n    bool Changed = false;\n\n    for (typename STy::const_iterator SI = S.begin(), SE = S.end(); SI != SE;\n         ++SI)\n      if (insert(*SI))\n        Changed = true;\n\n    return Changed;\n  }\n\n  /// Compute This := This - B\n  /// TODO: We should be able to use set_subtract from SetOperations.h, but\n  ///       SetVector interface is inconsistent with DenseSet.\n  template <class STy>\n  void set_subtract(const STy &S) {\n    for (typename STy::const_iterator SI = S.begin(), SE = S.end(); SI != SE;\n         ++SI)\n      remove(*SI);\n  }\n\n  void swap(SetVector<T, Vector, Set> &RHS) {\n    set_.swap(RHS.set_);\n    vector_.swap(RHS.vector_);\n  }\n\nprivate:\n  /// A wrapper predicate designed for use with std::remove_if.\n  ///\n  /// This predicate wraps a predicate suitable for use with std::remove_if to\n  /// call set_.erase(x) on each element which is slated for removal.\n  template <typename UnaryPredicate>\n  class TestAndEraseFromSet {\n    UnaryPredicate P;\n    set_type &set_;\n\n  public:\n    TestAndEraseFromSet(UnaryPredicate P, set_type &set_)\n        : P(std::move(P)), set_(set_) {}\n\n    template <typename ArgumentT>\n    bool operator()(const ArgumentT &Arg) {\n      if (P(Arg)) {\n        set_.erase(Arg);\n        return true;\n      }\n      return false;\n    }\n  };\n\n  set_type set_;         ///< The set.\n  vector_type vector_;   ///< The vector.\n};\n\n/// A SetVector that performs no allocations if smaller than\n/// a certain size.\ntemplate <typename T, unsigned N>\nclass SmallSetVector\n    : public SetVector<T, SmallVector<T, N>, SmallDenseSet<T, N>> {\npublic:\n  SmallSetVector() = default;\n\n  /// Initialize a SmallSetVector with a range of elements\n  template<typename It>\n  SmallSetVector(It Start, It End) {\n    this->insert(Start, End);\n  }\n};\n\n} // end namespace llvm\n\nnamespace std {\n\n/// Implement std::swap in terms of SetVector swap.\ntemplate<typename T, typename V, typename S>\ninline void\nswap(llvm::SetVector<T, V, S> &LHS, llvm::SetVector<T, V, S> &RHS) {\n  LHS.swap(RHS);\n}\n\n/// Implement std::swap in terms of SmallSetVector swap.\ntemplate<typename T, unsigned N>\ninline void\nswap(llvm::SmallSetVector<T, N> &LHS, llvm::SmallSetVector<T, N> &RHS) {\n  LHS.swap(RHS);\n}\n\n} // end namespace std\n\n#endif // LLVM_ADT_SETVECTOR_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "content": "//===- llvm/ADT/SmallSet.h - 'Normally small' sets --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallSet class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLSET_H\n#define LLVM_ADT_SMALLSET_H\n\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cstddef>\n#include <functional>\n#include <set>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// SmallSetIterator - This class implements a const_iterator for SmallSet by\n/// delegating to the underlying SmallVector or Set iterators.\ntemplate <typename T, unsigned N, typename C>\nclass SmallSetIterator\n    : public iterator_facade_base<SmallSetIterator<T, N, C>,\n                                  std::forward_iterator_tag, T> {\nprivate:\n  using SetIterTy = typename std::set<T, C>::const_iterator;\n  using VecIterTy = typename SmallVector<T, N>::const_iterator;\n  using SelfTy = SmallSetIterator<T, N, C>;\n\n  /// Iterators to the parts of the SmallSet containing the data. They are set\n  /// depending on isSmall.\n  union {\n    SetIterTy SetIter;\n    VecIterTy VecIter;\n  };\n\n  bool isSmall;\n\npublic:\n  SmallSetIterator(SetIterTy SetIter) : SetIter(SetIter), isSmall(false) {}\n\n  SmallSetIterator(VecIterTy VecIter) : VecIter(VecIter), isSmall(true) {}\n\n  // Spell out destructor, copy/move constructor and assignment operators for\n  // MSVC STL, where set<T>::const_iterator is not trivially copy constructible.\n  ~SmallSetIterator() {\n    if (isSmall)\n      VecIter.~VecIterTy();\n    else\n      SetIter.~SetIterTy();\n  }\n\n  SmallSetIterator(const SmallSetIterator &Other) : isSmall(Other.isSmall) {\n    if (isSmall)\n      VecIter = Other.VecIter;\n    else\n      // Use placement new, to make sure SetIter is properly constructed, even\n      // if it is not trivially copy-able (e.g. in MSVC).\n      new (&SetIter) SetIterTy(Other.SetIter);\n  }\n\n  SmallSetIterator(SmallSetIterator &&Other) : isSmall(Other.isSmall) {\n    if (isSmall)\n      VecIter = std::move(Other.VecIter);\n    else\n      // Use placement new, to make sure SetIter is properly constructed, even\n      // if it is not trivially copy-able (e.g. in MSVC).\n      new (&SetIter) SetIterTy(std::move(Other.SetIter));\n  }\n\n  SmallSetIterator& operator=(const SmallSetIterator& Other) {\n    // Call destructor for SetIter, so it gets properly destroyed if it is\n    // not trivially destructible in case we are setting VecIter.\n    if (!isSmall)\n      SetIter.~SetIterTy();\n\n    isSmall = Other.isSmall;\n    if (isSmall)\n      VecIter = Other.VecIter;\n    else\n      new (&SetIter) SetIterTy(Other.SetIter);\n    return *this;\n  }\n\n  SmallSetIterator& operator=(SmallSetIterator&& Other) {\n    // Call destructor for SetIter, so it gets properly destroyed if it is\n    // not trivially destructible in case we are setting VecIter.\n    if (!isSmall)\n      SetIter.~SetIterTy();\n\n    isSmall = Other.isSmall;\n    if (isSmall)\n      VecIter = std::move(Other.VecIter);\n    else\n      new (&SetIter) SetIterTy(std::move(Other.SetIter));\n    return *this;\n  }\n\n  bool operator==(const SmallSetIterator &RHS) const {\n    if (isSmall != RHS.isSmall)\n      return false;\n    if (isSmall)\n      return VecIter == RHS.VecIter;\n    return SetIter == RHS.SetIter;\n  }\n\n  SmallSetIterator &operator++() { // Preincrement\n    if (isSmall)\n      VecIter++;\n    else\n      SetIter++;\n    return *this;\n  }\n\n  const T &operator*() const { return isSmall ? *VecIter : *SetIter; }\n};\n\n/// SmallSet - This maintains a set of unique values, optimizing for the case\n/// when the set is small (less than N).  In this case, the set can be\n/// maintained with no mallocs.  If the set gets large, we expand to using an\n/// std::set to maintain reasonable lookup times.\ntemplate <typename T, unsigned N, typename C = std::less<T>>\nclass SmallSet {\n  /// Use a SmallVector to hold the elements here (even though it will never\n  /// reach its 'large' stage) to avoid calling the default ctors of elements\n  /// we will never use.\n  SmallVector<T, N> Vector;\n  std::set<T, C> Set;\n\n  using VIterator = typename SmallVector<T, N>::const_iterator;\n  using mutable_iterator = typename SmallVector<T, N>::iterator;\n\n  // In small mode SmallPtrSet uses linear search for the elements, so it is\n  // not a good idea to choose this value too high. You may consider using a\n  // DenseSet<> instead if you expect many elements in the set.\n  static_assert(N <= 32, \"N should be small\");\n\npublic:\n  using size_type = size_t;\n  using const_iterator = SmallSetIterator<T, N, C>;\n\n  SmallSet() = default;\n\n  LLVM_NODISCARD bool empty() const {\n    return Vector.empty() && Set.empty();\n  }\n\n  size_type size() const {\n    return isSmall() ? Vector.size() : Set.size();\n  }\n\n  /// count - Return 1 if the element is in the set, 0 otherwise.\n  size_type count(const T &V) const {\n    if (isSmall()) {\n      // Since the collection is small, just do a linear search.\n      return vfind(V) == Vector.end() ? 0 : 1;\n    } else {\n      return Set.count(V);\n    }\n  }\n\n  /// insert - Insert an element into the set if it isn't already there.\n  /// Returns true if the element is inserted (it was not in the set before).\n  /// The first value of the returned pair is unused and provided for\n  /// partial compatibility with the standard library self-associative container\n  /// concept.\n  // FIXME: Add iterators that abstract over the small and large form, and then\n  // return those here.\n  std::pair<NoneType, bool> insert(const T &V) {\n    if (!isSmall())\n      return std::make_pair(None, Set.insert(V).second);\n\n    VIterator I = vfind(V);\n    if (I != Vector.end())    // Don't reinsert if it already exists.\n      return std::make_pair(None, false);\n    if (Vector.size() < N) {\n      Vector.push_back(V);\n      return std::make_pair(None, true);\n    }\n\n    // Otherwise, grow from vector to set.\n    while (!Vector.empty()) {\n      Set.insert(Vector.back());\n      Vector.pop_back();\n    }\n    Set.insert(V);\n    return std::make_pair(None, true);\n  }\n\n  template <typename IterT>\n  void insert(IterT I, IterT E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const T &V) {\n    if (!isSmall())\n      return Set.erase(V);\n    for (mutable_iterator I = Vector.begin(), E = Vector.end(); I != E; ++I)\n      if (*I == V) {\n        Vector.erase(I);\n        return true;\n      }\n    return false;\n  }\n\n  void clear() {\n    Vector.clear();\n    Set.clear();\n  }\n\n  const_iterator begin() const {\n    if (isSmall())\n      return {Vector.begin()};\n    return {Set.begin()};\n  }\n\n  const_iterator end() const {\n    if (isSmall())\n      return {Vector.end()};\n    return {Set.end()};\n  }\n\n  /// Check if the SmallSet contains the given element.\n  bool contains(const T &V) const {\n    if (isSmall())\n      return vfind(V) != Vector.end();\n    return Set.find(V) != Set.end();\n  }\n\nprivate:\n  bool isSmall() const { return Set.empty(); }\n\n  VIterator vfind(const T &V) const {\n    for (VIterator I = Vector.begin(), E = Vector.end(); I != E; ++I)\n      if (*I == V)\n        return I;\n    return Vector.end();\n  }\n};\n\n/// If this set is of pointer values, transparently switch over to using\n/// SmallPtrSet for performance.\ntemplate <typename PointeeType, unsigned N>\nclass SmallSet<PointeeType*, N> : public SmallPtrSet<PointeeType*, N> {};\n\n/// Equality comparison for SmallSet.\n///\n/// Iterates over elements of LHS confirming that each element is also a member\n/// of RHS, and that RHS contains no additional values.\n/// Equivalent to N calls to RHS.count.\n/// For small-set mode amortized complexity is O(N^2)\n/// For large-set mode amortized complexity is linear, worst case is O(N^2) (if\n/// every hash collides).\ntemplate <typename T, unsigned LN, unsigned RN, typename C>\nbool operator==(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  // All elements in LHS must also be in RHS\n  return all_of(LHS, [&RHS](const T &E) { return RHS.count(E); });\n}\n\n/// Inequality comparison for SmallSet.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename T, unsigned LN, unsigned RN, typename C>\nbool operator!=(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SMALLSET_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallString.h", "content": "//===- llvm/ADT/SmallString.h - 'Normally small' strings --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallString class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLSTRING_H\n#define LLVM_ADT_SMALLSTRING_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cstddef>\n\nnamespace llvm {\n\n/// SmallString - A SmallString is just a SmallVector with methods and accessors\n/// that make it work better as a string (e.g. operator+ etc).\ntemplate<unsigned InternalLen>\nclass SmallString : public SmallVector<char, InternalLen> {\npublic:\n  /// Default ctor - Initialize to empty.\n  SmallString() = default;\n\n  /// Initialize from a StringRef.\n  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}\n\n  /// Initialize by concatenating a list of StringRefs.\n  SmallString(std::initializer_list<StringRef> Refs)\n      : SmallVector<char, InternalLen>() {\n    this->append(Refs);\n  }\n\n  /// Initialize with a range.\n  template<typename ItTy>\n  SmallString(ItTy S, ItTy E) : SmallVector<char, InternalLen>(S, E) {}\n\n  /// @}\n  /// @name String Assignment\n  /// @{\n\n  using SmallVector<char, InternalLen>::assign;\n\n  /// Assign from a StringRef.\n  void assign(StringRef RHS) {\n    SmallVectorImpl<char>::assign(RHS.begin(), RHS.end());\n  }\n\n  /// Assign from a list of StringRefs.\n  void assign(std::initializer_list<StringRef> Refs) {\n    this->clear();\n    append(Refs);\n  }\n\n  /// @}\n  /// @name String Concatenation\n  /// @{\n\n  using SmallVector<char, InternalLen>::append;\n\n  /// Append from a StringRef.\n  void append(StringRef RHS) {\n    SmallVectorImpl<char>::append(RHS.begin(), RHS.end());\n  }\n\n  /// Append from a list of StringRefs.\n  void append(std::initializer_list<StringRef> Refs) {\n    size_t SizeNeeded = this->size();\n    for (const StringRef &Ref : Refs)\n      SizeNeeded += Ref.size();\n    this->reserve(SizeNeeded);\n    auto CurEnd = this->end();\n    for (const StringRef &Ref : Refs) {\n      this->uninitialized_copy(Ref.begin(), Ref.end(), CurEnd);\n      CurEnd += Ref.size();\n    }\n    this->set_size(SizeNeeded);\n  }\n\n  /// @}\n  /// @name String Comparison\n  /// @{\n\n  /// Check for string equality.  This is more efficient than compare() when\n  /// the relative ordering of inequal strings isn't needed.\n  bool equals(StringRef RHS) const {\n    return str().equals(RHS);\n  }\n\n  /// Check for string equality, ignoring case.\n  bool equals_lower(StringRef RHS) const {\n    return str().equals_lower(RHS);\n  }\n\n  /// Compare two strings; the result is -1, 0, or 1 if this string is\n  /// lexicographically less than, equal to, or greater than the \\p RHS.\n  int compare(StringRef RHS) const {\n    return str().compare(RHS);\n  }\n\n  /// compare_lower - Compare two strings, ignoring case.\n  int compare_lower(StringRef RHS) const {\n    return str().compare_lower(RHS);\n  }\n\n  /// compare_numeric - Compare two strings, treating sequences of digits as\n  /// numbers.\n  int compare_numeric(StringRef RHS) const {\n    return str().compare_numeric(RHS);\n  }\n\n  /// @}\n  /// @name String Predicates\n  /// @{\n\n  /// startswith - Check if this string starts with the given \\p Prefix.\n  bool startswith(StringRef Prefix) const {\n    return str().startswith(Prefix);\n  }\n\n  /// endswith - Check if this string ends with the given \\p Suffix.\n  bool endswith(StringRef Suffix) const {\n    return str().endswith(Suffix);\n  }\n\n  /// @}\n  /// @name String Searching\n  /// @{\n\n  /// find - Search for the first character \\p C in the string.\n  ///\n  /// \\return - The index of the first occurrence of \\p C, or npos if not\n  /// found.\n  size_t find(char C, size_t From = 0) const {\n    return str().find(C, From);\n  }\n\n  /// Search for the first string \\p Str in the string.\n  ///\n  /// \\returns The index of the first occurrence of \\p Str, or npos if not\n  /// found.\n  size_t find(StringRef Str, size_t From = 0) const {\n    return str().find(Str, From);\n  }\n\n  /// Search for the last character \\p C in the string.\n  ///\n  /// \\returns The index of the last occurrence of \\p C, or npos if not\n  /// found.\n  size_t rfind(char C, size_t From = StringRef::npos) const {\n    return str().rfind(C, From);\n  }\n\n  /// Search for the last string \\p Str in the string.\n  ///\n  /// \\returns The index of the last occurrence of \\p Str, or npos if not\n  /// found.\n  size_t rfind(StringRef Str) const {\n    return str().rfind(Str);\n  }\n\n  /// Find the first character in the string that is \\p C, or npos if not\n  /// found. Same as find.\n  size_t find_first_of(char C, size_t From = 0) const {\n    return str().find_first_of(C, From);\n  }\n\n  /// Find the first character in the string that is in \\p Chars, or npos if\n  /// not found.\n  ///\n  /// Complexity: O(size() + Chars.size())\n  size_t find_first_of(StringRef Chars, size_t From = 0) const {\n    return str().find_first_of(Chars, From);\n  }\n\n  /// Find the first character in the string that is not \\p C or npos if not\n  /// found.\n  size_t find_first_not_of(char C, size_t From = 0) const {\n    return str().find_first_not_of(C, From);\n  }\n\n  /// Find the first character in the string that is not in the string\n  /// \\p Chars, or npos if not found.\n  ///\n  /// Complexity: O(size() + Chars.size())\n  size_t find_first_not_of(StringRef Chars, size_t From = 0) const {\n    return str().find_first_not_of(Chars, From);\n  }\n\n  /// Find the last character in the string that is \\p C, or npos if not\n  /// found.\n  size_t find_last_of(char C, size_t From = StringRef::npos) const {\n    return str().find_last_of(C, From);\n  }\n\n  /// Find the last character in the string that is in \\p C, or npos if not\n  /// found.\n  ///\n  /// Complexity: O(size() + Chars.size())\n  size_t find_last_of(\n      StringRef Chars, size_t From = StringRef::npos) const {\n    return str().find_last_of(Chars, From);\n  }\n\n  /// @}\n  /// @name Helpful Algorithms\n  /// @{\n\n  /// Return the number of occurrences of \\p C in the string.\n  size_t count(char C) const {\n    return str().count(C);\n  }\n\n  /// Return the number of non-overlapped occurrences of \\p Str in the\n  /// string.\n  size_t count(StringRef Str) const {\n    return str().count(Str);\n  }\n\n  /// @}\n  /// @name Substring Operations\n  /// @{\n\n  /// Return a reference to the substring from [Start, Start + N).\n  ///\n  /// \\param Start The index of the starting character in the substring; if\n  /// the index is npos or greater than the length of the string then the\n  /// empty substring will be returned.\n  ///\n  /// \\param N The number of characters to included in the substring. If \\p N\n  /// exceeds the number of characters remaining in the string, the string\n  /// suffix (starting with \\p Start) will be returned.\n  StringRef substr(size_t Start, size_t N = StringRef::npos) const {\n    return str().substr(Start, N);\n  }\n\n  /// Return a reference to the substring from [Start, End).\n  ///\n  /// \\param Start The index of the starting character in the substring; if\n  /// the index is npos or greater than the length of the string then the\n  /// empty substring will be returned.\n  ///\n  /// \\param End The index following the last character to include in the\n  /// substring. If this is npos, or less than \\p Start, or exceeds the\n  /// number of characters remaining in the string, the string suffix\n  /// (starting with \\p Start) will be returned.\n  StringRef slice(size_t Start, size_t End) const {\n    return str().slice(Start, End);\n  }\n\n  // Extra methods.\n\n  /// Explicit conversion to StringRef.\n  StringRef str() const { return StringRef(this->data(), this->size()); }\n\n  // TODO: Make this const, if it's safe...\n  const char* c_str() {\n    this->push_back(0);\n    this->pop_back();\n    return this->data();\n  }\n\n  /// Implicit conversion to StringRef.\n  operator StringRef() const { return str(); }\n\n  explicit operator std::string() const {\n    return std::string(this->data(), this->size());\n  }\n\n  // Extra operators.\n  SmallString &operator=(StringRef RHS) {\n    this->assign(RHS);\n    return *this;\n  }\n\n  SmallString &operator+=(StringRef RHS) {\n    this->append(RHS.begin(), RHS.end());\n    return *this;\n  }\n  SmallString &operator+=(char C) {\n    this->push_back(C);\n    return *this;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SMALLSTRING_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "content": "//===- llvm/ADT/SparseBitVector.h - Efficient Sparse BitVector --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SparseBitVector class.  See the doxygen comment for\n// SparseBitVector for more details on the algorithm used.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SPARSEBITVECTOR_H\n#define LLVM_ADT_SPARSEBITVECTOR_H\n\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <iterator>\n#include <list>\n\nnamespace llvm {\n\n/// SparseBitVector is an implementation of a bitvector that is sparse by only\n/// storing the elements that have non-zero bits set.  In order to make this\n/// fast for the most common cases, SparseBitVector is implemented as a linked\n/// list of SparseBitVectorElements.  We maintain a pointer to the last\n/// SparseBitVectorElement accessed (in the form of a list iterator), in order\n/// to make multiple in-order test/set constant time after the first one is\n/// executed.  Note that using vectors to store SparseBitVectorElement's does\n/// not work out very well because it causes insertion in the middle to take\n/// enormous amounts of time with a large amount of bits.  Other structures that\n/// have better worst cases for insertion in the middle (various balanced trees,\n/// etc) do not perform as well in practice as a linked list with this iterator\n/// kept up to date.  They are also significantly more memory intensive.\n\ntemplate <unsigned ElementSize = 128> struct SparseBitVectorElement {\npublic:\n  using BitWord = unsigned long;\n  using size_type = unsigned;\n  enum {\n    BITWORD_SIZE = sizeof(BitWord) * CHAR_BIT,\n    BITWORDS_PER_ELEMENT = (ElementSize + BITWORD_SIZE - 1) / BITWORD_SIZE,\n    BITS_PER_ELEMENT = ElementSize\n  };\n\nprivate:\n  // Index of Element in terms of where first bit starts.\n  unsigned ElementIndex;\n  BitWord Bits[BITWORDS_PER_ELEMENT];\n\n  SparseBitVectorElement() {\n    ElementIndex = ~0U;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\npublic:\n  explicit SparseBitVectorElement(unsigned Idx) {\n    ElementIndex = Idx;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\n  // Comparison.\n  bool operator==(const SparseBitVectorElement &RHS) const {\n    if (ElementIndex != RHS.ElementIndex)\n      return false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != RHS.Bits[i])\n        return false;\n    return true;\n  }\n\n  bool operator!=(const SparseBitVectorElement &RHS) const {\n    return !(*this == RHS);\n  }\n\n  // Return the bits that make up word Idx in our element.\n  BitWord word(unsigned Idx) const {\n    assert(Idx < BITWORDS_PER_ELEMENT);\n    return Bits[Idx];\n  }\n\n  unsigned index() const {\n    return ElementIndex;\n  }\n\n  bool empty() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i])\n        return false;\n    return true;\n  }\n\n  void set(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] |= 1L << (Idx % BITWORD_SIZE);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  void reset(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] &= ~(1L << (Idx % BITWORD_SIZE));\n  }\n\n  bool test(unsigned Idx) const {\n    return Bits[Idx / BITWORD_SIZE] & (1L << (Idx % BITWORD_SIZE));\n  }\n\n  size_type count() const {\n    unsigned NumBits = 0;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      NumBits += countPopulation(Bits[i]);\n    return NumBits;\n  }\n\n  /// find_first - Returns the index of the first set bit.\n  int find_first() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_last - Returns the index of the last set bit.\n  int find_last() const {\n    for (unsigned I = 0; I < BITWORDS_PER_ELEMENT; ++I) {\n      unsigned Idx = BITWORDS_PER_ELEMENT - I - 1;\n      if (Bits[Idx] != 0)\n        return Idx * BITWORD_SIZE + BITWORD_SIZE -\n               countLeadingZeros(Bits[Idx]) - 1;\n    }\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_next - Returns the index of the next set bit starting from the\n  /// \"Curr\" bit. Returns -1 if the next set bit is not found.\n  int find_next(unsigned Curr) const {\n    if (Curr >= BITS_PER_ELEMENT)\n      return -1;\n\n    unsigned WordPos = Curr / BITWORD_SIZE;\n    unsigned BitPos = Curr % BITWORD_SIZE;\n    BitWord Copy = Bits[WordPos];\n    assert(WordPos <= BITWORDS_PER_ELEMENT\n           && \"Word Position outside of element\");\n\n    // Mask off previous bits.\n    Copy &= ~0UL << BitPos;\n\n    if (Copy != 0)\n      return WordPos * BITWORD_SIZE + countTrailingZeros(Copy);\n\n    // Check subsequent words.\n    for (unsigned i = WordPos+1; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    return -1;\n  }\n\n  // Union this element with RHS and return true if this one changed.\n  bool unionWith(const SparseBitVectorElement &RHS) {\n    bool changed = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] |= RHS.Bits[i];\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    return changed;\n  }\n\n  // Return true if we have any bits in common with RHS\n  bool intersects(const SparseBitVectorElement &RHS) const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      if (RHS.Bits[i] & Bits[i])\n        return true;\n    }\n    return false;\n  }\n\n  // Intersect this Element with RHS and return true if this one changed.\n  // BecameZero is set to true if this element became all-zero bits.\n  bool intersectWith(const SparseBitVectorElement &RHS,\n                     bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Intersect this Element with the complement of RHS and return true if this\n  // one changed.  BecameZero is set to true if this element became all-zero\n  // bits.\n  bool intersectWithComplement(const SparseBitVectorElement &RHS,\n                               bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= ~RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Three argument version of intersectWithComplement that intersects\n  // RHS1 & ~RHS2 into this element\n  void intersectWithComplement(const SparseBitVectorElement &RHS1,\n                               const SparseBitVectorElement &RHS2,\n                               bool &BecameZero) {\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      Bits[i] = RHS1.Bits[i] & ~RHS2.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n    }\n    BecameZero = allzero;\n  }\n};\n\ntemplate <unsigned ElementSize = 128>\nclass SparseBitVector {\n  using ElementList = std::list<SparseBitVectorElement<ElementSize>>;\n  using ElementListIter = typename ElementList::iterator;\n  using ElementListConstIter = typename ElementList::const_iterator;\n  enum {\n    BITWORD_SIZE = SparseBitVectorElement<ElementSize>::BITWORD_SIZE\n  };\n\n  ElementList Elements;\n  // Pointer to our current Element. This has no visible effect on the external\n  // state of a SparseBitVector, it's just used to improve performance in the\n  // common case of testing/modifying bits with similar indices.\n  mutable ElementListIter CurrElementIter;\n\n  // This is like std::lower_bound, except we do linear searching from the\n  // current position.\n  ElementListIter FindLowerBoundImpl(unsigned ElementIndex) const {\n\n    // We cache a non-const iterator so we're forced to resort to const_cast to\n    // get the begin/end in the case where 'this' is const. To avoid duplication\n    // of code with the only difference being whether the const cast is present\n    // 'this' is always const in this particular function and we sort out the\n    // difference in FindLowerBound and FindLowerBoundConst.\n    ElementListIter Begin =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.begin();\n    ElementListIter End =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.end();\n\n    if (Elements.empty()) {\n      CurrElementIter = Begin;\n      return CurrElementIter;\n    }\n\n    // Make sure our current iterator is valid.\n    if (CurrElementIter == End)\n      --CurrElementIter;\n\n    // Search from our current iterator, either backwards or forwards,\n    // depending on what element we are looking for.\n    ElementListIter ElementIter = CurrElementIter;\n    if (CurrElementIter->index() == ElementIndex) {\n      return ElementIter;\n    } else if (CurrElementIter->index() > ElementIndex) {\n      while (ElementIter != Begin\n             && ElementIter->index() > ElementIndex)\n        --ElementIter;\n    } else {\n      while (ElementIter != End &&\n             ElementIter->index() < ElementIndex)\n        ++ElementIter;\n    }\n    CurrElementIter = ElementIter;\n    return ElementIter;\n  }\n  ElementListConstIter FindLowerBoundConst(unsigned ElementIndex) const {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n  ElementListIter FindLowerBound(unsigned ElementIndex) {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n\n  // Iterator to walk set bits in the bitmap.  This iterator is a lot uglier\n  // than it would be, in order to be efficient.\n  class SparseBitVectorIterator {\n  private:\n    bool AtEnd;\n\n    const SparseBitVector<ElementSize> *BitVector = nullptr;\n\n    // Current element inside of bitmap.\n    ElementListConstIter Iter;\n\n    // Current bit number inside of our bitmap.\n    unsigned BitNumber;\n\n    // Current word number inside of our element.\n    unsigned WordNumber;\n\n    // Current bits from the element.\n    typename SparseBitVectorElement<ElementSize>::BitWord Bits;\n\n    // Move our iterator to the first non-zero bit in the bitmap.\n    void AdvanceToFirstNonZero() {\n      if (AtEnd)\n        return;\n      if (BitVector->Elements.empty()) {\n        AtEnd = true;\n        return;\n      }\n      Iter = BitVector->Elements.begin();\n      BitNumber = Iter->index() * ElementSize;\n      unsigned BitPos = Iter->find_first();\n      BitNumber += BitPos;\n      WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n      Bits = Iter->word(WordNumber);\n      Bits >>= BitPos % BITWORD_SIZE;\n    }\n\n    // Move our iterator to the next non-zero bit.\n    void AdvanceToNextNonZero() {\n      if (AtEnd)\n        return;\n\n      while (Bits && !(Bits & 1)) {\n        Bits >>= 1;\n        BitNumber += 1;\n      }\n\n      // See if we ran out of Bits in this word.\n      if (!Bits) {\n        int NextSetBitNumber = Iter->find_next(BitNumber % ElementSize) ;\n        // If we ran out of set bits in this element, move to next element.\n        if (NextSetBitNumber == -1 || (BitNumber % ElementSize == 0)) {\n          ++Iter;\n          WordNumber = 0;\n\n          // We may run out of elements in the bitmap.\n          if (Iter == BitVector->Elements.end()) {\n            AtEnd = true;\n            return;\n          }\n          // Set up for next non-zero word in bitmap.\n          BitNumber = Iter->index() * ElementSize;\n          NextSetBitNumber = Iter->find_first();\n          BitNumber += NextSetBitNumber;\n          WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n        } else {\n          WordNumber = (NextSetBitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n          BitNumber = Iter->index() * ElementSize;\n          BitNumber += NextSetBitNumber;\n        }\n      }\n    }\n\n  public:\n    SparseBitVectorIterator() = default;\n\n    SparseBitVectorIterator(const SparseBitVector<ElementSize> *RHS,\n                            bool end = false):BitVector(RHS) {\n      Iter = BitVector->Elements.begin();\n      BitNumber = 0;\n      Bits = 0;\n      WordNumber = ~0;\n      AtEnd = end;\n      AdvanceToFirstNonZero();\n    }\n\n    // Preincrement.\n    inline SparseBitVectorIterator& operator++() {\n      ++BitNumber;\n      Bits >>= 1;\n      AdvanceToNextNonZero();\n      return *this;\n    }\n\n    // Postincrement.\n    inline SparseBitVectorIterator operator++(int) {\n      SparseBitVectorIterator tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Return the current set bit number.\n    unsigned operator*() const {\n      return BitNumber;\n    }\n\n    bool operator==(const SparseBitVectorIterator &RHS) const {\n      // If they are both at the end, ignore the rest of the fields.\n      if (AtEnd && RHS.AtEnd)\n        return true;\n      // Otherwise they are the same if they have the same bit number and\n      // bitmap.\n      return AtEnd == RHS.AtEnd && RHS.BitNumber == BitNumber;\n    }\n\n    bool operator!=(const SparseBitVectorIterator &RHS) const {\n      return !(*this == RHS);\n    }\n  };\n\npublic:\n  using iterator = SparseBitVectorIterator;\n\n  SparseBitVector() : Elements(), CurrElementIter(Elements.begin()) {}\n\n  SparseBitVector(const SparseBitVector &RHS)\n      : Elements(RHS.Elements), CurrElementIter(Elements.begin()) {}\n  SparseBitVector(SparseBitVector &&RHS)\n      : Elements(std::move(RHS.Elements)), CurrElementIter(Elements.begin()) {}\n\n  // Clear.\n  void clear() {\n    Elements.clear();\n  }\n\n  // Assignment\n  SparseBitVector& operator=(const SparseBitVector& RHS) {\n    if (this == &RHS)\n      return *this;\n\n    Elements = RHS.Elements;\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n  SparseBitVector &operator=(SparseBitVector &&RHS) {\n    Elements = std::move(RHS.Elements);\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n\n  // Test, Reset, and Set a bit in the bitmap.\n  bool test(unsigned Idx) const {\n    if (Elements.empty())\n      return false;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListConstIter ElementIter = FindLowerBoundConst(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return false;\n    return ElementIter->test(Idx % ElementSize);\n  }\n\n  void reset(unsigned Idx) {\n    if (Elements.empty())\n      return;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter = FindLowerBound(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return;\n    ElementIter->reset(Idx % ElementSize);\n\n    // When the element is zeroed out, delete it.\n    if (ElementIter->empty()) {\n      ++CurrElementIter;\n      Elements.erase(ElementIter);\n    }\n  }\n\n  void set(unsigned Idx) {\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter;\n    if (Elements.empty()) {\n      ElementIter = Elements.emplace(Elements.end(), ElementIndex);\n    } else {\n      ElementIter = FindLowerBound(ElementIndex);\n\n      if (ElementIter == Elements.end() ||\n          ElementIter->index() != ElementIndex) {\n        // We may have hit the beginning of our SparseBitVector, in which case,\n        // we may need to insert right after this element, which requires moving\n        // the current iterator forward one, because insert does insert before.\n        if (ElementIter != Elements.end() &&\n            ElementIter->index() < ElementIndex)\n          ++ElementIter;\n        ElementIter = Elements.emplace(ElementIter, ElementIndex);\n      }\n    }\n    CurrElementIter = ElementIter;\n\n    ElementIter->set(Idx % ElementSize);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  bool operator!=(const SparseBitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator==(const SparseBitVector &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    for (; Iter1 != Elements.end() && Iter2 != RHS.Elements.end();\n         ++Iter1, ++Iter2) {\n      if (*Iter1 != *Iter2)\n        return false;\n    }\n    return Iter1 == Elements.end() && Iter2 == RHS.Elements.end();\n  }\n\n  // Union our bitmap with the RHS and return true if we changed.\n  bool operator|=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If RHS is empty, we are done\n    if (RHS.Elements.empty())\n      return false;\n\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end() || Iter1->index() > Iter2->index()) {\n        Elements.insert(Iter1, *Iter2);\n        ++Iter2;\n        changed = true;\n      } else if (Iter1->index() == Iter2->index()) {\n        changed |= Iter1->unionWith(*Iter2);\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the RHS and return true if ours changed.\n  bool operator&=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWith(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ElementListIter IterTmp = Iter1;\n        ++Iter1;\n        Elements.erase(IterTmp);\n        changed = true;\n      }\n    }\n    if (Iter1 != Elements.end()) {\n      Elements.erase(Iter1, Elements.end());\n      changed = true;\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the complement of the RHS and return true\n  // if ours changed.\n  bool intersectWithComplement(const SparseBitVector &RHS) {\n    if (this == &RHS) {\n      if (!empty()) {\n        clear();\n        return true;\n      }\n      return false;\n    }\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If either our bitmap or RHS is empty, we are done\n    if (Elements.empty() || RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWithComplement(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  bool intersectWithComplement(const SparseBitVector<ElementSize> *RHS) const {\n    return intersectWithComplement(*RHS);\n  }\n\n  //  Three argument version of intersectWithComplement.\n  //  Result of RHS1 & ~RHS2 is stored into this bitmap.\n  void intersectWithComplement(const SparseBitVector<ElementSize> &RHS1,\n                               const SparseBitVector<ElementSize> &RHS2)\n  {\n    if (this == &RHS1) {\n      intersectWithComplement(RHS2);\n      return;\n    } else if (this == &RHS2) {\n      SparseBitVector RHS2Copy(RHS2);\n      intersectWithComplement(RHS1, RHS2Copy);\n      return;\n    }\n\n    Elements.clear();\n    CurrElementIter = Elements.begin();\n    ElementListConstIter Iter1 = RHS1.Elements.begin();\n    ElementListConstIter Iter2 = RHS2.Elements.begin();\n\n    // If RHS1 is empty, we are done\n    // If RHS2 is empty, we still have to copy RHS1\n    if (RHS1.Elements.empty())\n      return;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS2.Elements.end()) {\n      if (Iter1 == RHS1.Elements.end())\n        return;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero = false;\n        Elements.emplace_back(Iter1->index());\n        Elements.back().intersectWithComplement(*Iter1, *Iter2, BecameZero);\n        if (BecameZero)\n          Elements.pop_back();\n        ++Iter1;\n        ++Iter2;\n      } else {\n        Elements.push_back(*Iter1++);\n      }\n    }\n\n    // copy the remaining elements\n    std::copy(Iter1, RHS1.Elements.end(), std::back_inserter(Elements));\n  }\n\n  void intersectWithComplement(const SparseBitVector<ElementSize> *RHS1,\n                               const SparseBitVector<ElementSize> *RHS2) {\n    intersectWithComplement(*RHS1, *RHS2);\n  }\n\n  bool intersects(const SparseBitVector<ElementSize> *RHS) const {\n    return intersects(*RHS);\n  }\n\n  // Return true if we share any bits in common with RHS\n  bool intersects(const SparseBitVector<ElementSize> &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting stopping when we hit bits in common.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end())\n        return false;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        if (Iter1->intersects(*Iter2))\n          return true;\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    return false;\n  }\n\n  // Return true iff all bits set in this SparseBitVector are\n  // also set in RHS.\n  bool contains(const SparseBitVector<ElementSize> &RHS) const {\n    SparseBitVector<ElementSize> Result(*this);\n    Result &= RHS;\n    return (Result == RHS);\n  }\n\n  // Return the first set bit in the bitmap.  Return -1 if no bits are set.\n  int find_first() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &First = *(Elements.begin());\n    return (First.index() * ElementSize) + First.find_first();\n  }\n\n  // Return the last set bit in the bitmap.  Return -1 if no bits are set.\n  int find_last() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &Last = *(Elements.rbegin());\n    return (Last.index() * ElementSize) + Last.find_last();\n  }\n\n  // Return true if the SparseBitVector is empty\n  bool empty() const {\n    return Elements.empty();\n  }\n\n  unsigned count() const {\n    unsigned BitCount = 0;\n    for (ElementListConstIter Iter = Elements.begin();\n         Iter != Elements.end();\n         ++Iter)\n      BitCount += Iter->count();\n\n    return BitCount;\n  }\n\n  iterator begin() const {\n    return iterator(this);\n  }\n\n  iterator end() const {\n    return iterator(this, true);\n  }\n};\n\n// Convenience functions to allow Or and And without dereferencing in the user\n// code.\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS |= *RHS;\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator|=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator&=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS &= *RHS;\n}\n\n// Convenience functions for infix union, intersection, difference operators.\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator|(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result |= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator&(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result &= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator-(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result;\n  Result.intersectWithComplement(LHS, RHS);\n  return Result;\n}\n\n// Dump a SparseBitVector to a stream\ntemplate <unsigned ElementSize>\nvoid dump(const SparseBitVector<ElementSize> &LHS, raw_ostream &out) {\n  out << \"[\";\n\n  typename SparseBitVector<ElementSize>::iterator bi = LHS.begin(),\n    be = LHS.end();\n  if (bi != be) {\n    out << *bi;\n    for (++bi; bi != be; ++bi) {\n      out << \" \" << *bi;\n    }\n  }\n  out << \"]\\n\";\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SPARSEBITVECTOR_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "content": "//==-- llvm/ADT/ilist.h - Intrusive Linked List Template ---------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines classes to implement an intrusive doubly linked list class\n// (i.e. each node of the list must contain a next and previous field for the\n// list.\n//\n// The ilist class itself should be a plug in replacement for list.  This list\n// replacement does not provide a constant time size() method, so be careful to\n// use empty() when you really want to know if it's empty.\n//\n// The ilist class is implemented as a circular list.  The list itself contains\n// a sentinel node, whose Next points at begin() and whose Prev points at\n// rbegin().  The sentinel node itself serves as end() and rend().\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_H\n#define LLVM_ADT_ILIST_H\n\n#include \"llvm/ADT/simple_ilist.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace llvm {\n\n/// Use delete by default for iplist and ilist.\n///\n/// Specialize this to get different behaviour for ownership-related API.  (If\n/// you really want ownership semantics, consider using std::list or building\n/// something like \\a BumpPtrList.)\n///\n/// \\see ilist_noalloc_traits\ntemplate <typename NodeTy> struct ilist_alloc_traits {\n  static void deleteNode(NodeTy *V) { delete V; }\n};\n\n/// Custom traits to do nothing on deletion.\n///\n/// Specialize ilist_alloc_traits to inherit from this to disable the\n/// non-intrusive deletion in iplist (which implies ownership).\n///\n/// If you want purely intrusive semantics with no callbacks, consider using \\a\n/// simple_ilist instead.\n///\n/// \\code\n/// template <>\n/// struct ilist_alloc_traits<MyType> : ilist_noalloc_traits<MyType> {};\n/// \\endcode\ntemplate <typename NodeTy> struct ilist_noalloc_traits {\n  static void deleteNode(NodeTy *V) {}\n};\n\n/// Callbacks do nothing by default in iplist and ilist.\n///\n/// Specialize this for to use callbacks for when nodes change their list\n/// membership.\ntemplate <typename NodeTy> struct ilist_callback_traits {\n  void addNodeToList(NodeTy *) {}\n  void removeNodeFromList(NodeTy *) {}\n\n  /// Callback before transferring nodes to this list. The nodes may already be\n  /// in this same list.\n  template <class Iterator>\n  void transferNodesFromList(ilist_callback_traits &OldList, Iterator /*first*/,\n                             Iterator /*last*/) {\n    (void)OldList;\n  }\n};\n\n/// A fragment for template traits for intrusive list that provides default\n/// node related operations.\n///\n/// TODO: Remove this layer of indirection.  It's not necessary.\ntemplate <typename NodeTy>\nstruct ilist_node_traits : ilist_alloc_traits<NodeTy>,\n                           ilist_callback_traits<NodeTy> {};\n\n/// Template traits for intrusive list.\n///\n/// Customize callbacks and allocation semantics.\ntemplate <typename NodeTy>\nstruct ilist_traits : public ilist_node_traits<NodeTy> {};\n\n/// Const traits should never be instantiated.\ntemplate <typename Ty> struct ilist_traits<const Ty> {};\n\nnamespace ilist_detail {\n\ntemplate <class T> T &make();\n\n/// Type trait to check for a traits class that has a getNext member (as a\n/// canary for any of the ilist_nextprev_traits API).\ntemplate <class TraitsT, class NodeT> struct HasGetNext {\n  typedef char Yes[1];\n  typedef char No[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->getNext(&make<NodeT>())) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\n/// Type trait to check for a traits class that has a createSentinel member (as\n/// a canary for any of the ilist_sentinel_traits API).\ntemplate <class TraitsT> struct HasCreateSentinel {\n  typedef char Yes[1];\n  typedef char No[2];\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->createSentinel()) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\n/// Type trait to check for a traits class that has a createNode member.\n/// Allocation should be managed in a wrapper class, instead of in\n/// ilist_traits.\ntemplate <class TraitsT, class NodeT> struct HasCreateNode {\n  typedef char Yes[1];\n  typedef char No[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->createNode(make<NodeT>())) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\ntemplate <class TraitsT, class NodeT> struct HasObsoleteCustomization {\n  static const bool value = HasGetNext<TraitsT, NodeT>::value ||\n                            HasCreateSentinel<TraitsT>::value ||\n                            HasCreateNode<TraitsT, NodeT>::value;\n};\n\n} // end namespace ilist_detail\n\n//===----------------------------------------------------------------------===//\n//\n/// A wrapper around an intrusive list with callbacks and non-intrusive\n/// ownership.\n///\n/// This wraps a purely intrusive list (like simple_ilist) with a configurable\n/// traits class.  The traits can implement callbacks and customize the\n/// ownership semantics.\n///\n/// This is a subset of ilist functionality that can safely be used on nodes of\n/// polymorphic types, i.e. a heterogeneous list with a common base class that\n/// holds the next/prev pointers.  The only state of the list itself is an\n/// ilist_sentinel, which holds pointers to the first and last nodes in the\n/// list.\ntemplate <class IntrusiveListT, class TraitsT>\nclass iplist_impl : public TraitsT, IntrusiveListT {\n  typedef IntrusiveListT base_list_type;\n\npublic:\n  typedef typename base_list_type::pointer pointer;\n  typedef typename base_list_type::const_pointer const_pointer;\n  typedef typename base_list_type::reference reference;\n  typedef typename base_list_type::const_reference const_reference;\n  typedef typename base_list_type::value_type value_type;\n  typedef typename base_list_type::size_type size_type;\n  typedef typename base_list_type::difference_type difference_type;\n  typedef typename base_list_type::iterator iterator;\n  typedef typename base_list_type::const_iterator const_iterator;\n  typedef typename base_list_type::reverse_iterator reverse_iterator;\n  typedef\n      typename base_list_type::const_reverse_iterator const_reverse_iterator;\n\nprivate:\n  // TODO: Drop this assertion and the transitive type traits anytime after\n  // v4.0 is branched (i.e,. keep them for one release to help out-of-tree code\n  // update).\n  static_assert(\n      !ilist_detail::HasObsoleteCustomization<TraitsT, value_type>::value,\n      \"ilist customization points have changed!\");\n\n  static bool op_less(const_reference L, const_reference R) { return L < R; }\n  static bool op_equal(const_reference L, const_reference R) { return L == R; }\n\npublic:\n  iplist_impl() = default;\n\n  iplist_impl(const iplist_impl &) = delete;\n  iplist_impl &operator=(const iplist_impl &) = delete;\n\n  iplist_impl(iplist_impl &&X)\n      : TraitsT(std::move(static_cast<TraitsT &>(X))),\n        IntrusiveListT(std::move(static_cast<IntrusiveListT &>(X))) {}\n  iplist_impl &operator=(iplist_impl &&X) {\n    *static_cast<TraitsT *>(this) = std::move(static_cast<TraitsT &>(X));\n    *static_cast<IntrusiveListT *>(this) =\n        std::move(static_cast<IntrusiveListT &>(X));\n    return *this;\n  }\n\n  ~iplist_impl() { clear(); }\n\n  // Miscellaneous inspection routines.\n  size_type max_size() const { return size_type(-1); }\n\n  using base_list_type::begin;\n  using base_list_type::end;\n  using base_list_type::rbegin;\n  using base_list_type::rend;\n  using base_list_type::empty;\n  using base_list_type::front;\n  using base_list_type::back;\n\n  void swap(iplist_impl &RHS) {\n    assert(0 && \"Swap does not use list traits callback correctly yet!\");\n    base_list_type::swap(RHS);\n  }\n\n  iterator insert(iterator where, pointer New) {\n    this->addNodeToList(New); // Notify traits that we added a node...\n    return base_list_type::insert(where, *New);\n  }\n\n  iterator insert(iterator where, const_reference New) {\n    return this->insert(where, new value_type(New));\n  }\n\n  iterator insertAfter(iterator where, pointer New) {\n    if (empty())\n      return insert(begin(), New);\n    else\n      return insert(++where, New);\n  }\n\n  /// Clone another list.\n  template <class Cloner> void cloneFrom(const iplist_impl &L2, Cloner clone) {\n    clear();\n    for (const_reference V : L2)\n      push_back(clone(V));\n  }\n\n  pointer remove(iterator &IT) {\n    pointer Node = &*IT++;\n    this->removeNodeFromList(Node); // Notify traits that we removed a node...\n    base_list_type::remove(*Node);\n    return Node;\n  }\n\n  pointer remove(const iterator &IT) {\n    iterator MutIt = IT;\n    return remove(MutIt);\n  }\n\n  pointer remove(pointer IT) { return remove(iterator(IT)); }\n  pointer remove(reference IT) { return remove(iterator(IT)); }\n\n  // erase - remove a node from the controlled sequence... and delete it.\n  iterator erase(iterator where) {\n    this->deleteNode(remove(where));\n    return where;\n  }\n\n  iterator erase(pointer IT) { return erase(iterator(IT)); }\n  iterator erase(reference IT) { return erase(iterator(IT)); }\n\n  /// Remove all nodes from the list like clear(), but do not call\n  /// removeNodeFromList() or deleteNode().\n  ///\n  /// This should only be used immediately before freeing nodes in bulk to\n  /// avoid traversing the list and bringing all the nodes into cache.\n  void clearAndLeakNodesUnsafely() { base_list_type::clear(); }\n\nprivate:\n  // transfer - The heart of the splice function.  Move linked list nodes from\n  // [first, last) into position.\n  //\n  void transfer(iterator position, iplist_impl &L2, iterator first, iterator last) {\n    if (position == last)\n      return;\n\n    // Notify traits we moved the nodes...\n    this->transferNodesFromList(L2, first, last);\n\n    base_list_type::splice(position, L2, first, last);\n  }\n\npublic:\n  //===----------------------------------------------------------------------===\n  // Functionality derived from other functions defined above...\n  //\n\n  using base_list_type::size;\n\n  iterator erase(iterator first, iterator last) {\n    while (first != last)\n      first = erase(first);\n    return last;\n  }\n\n  void clear() { erase(begin(), end()); }\n\n  // Front and back inserters...\n  void push_front(pointer val) { insert(begin(), val); }\n  void push_back(pointer val) { insert(end(), val); }\n  void pop_front() {\n    assert(!empty() && \"pop_front() on empty list!\");\n    erase(begin());\n  }\n  void pop_back() {\n    assert(!empty() && \"pop_back() on empty list!\");\n    iterator t = end(); erase(--t);\n  }\n\n  // Special forms of insert...\n  template<class InIt> void insert(iterator where, InIt first, InIt last) {\n    for (; first != last; ++first) insert(where, *first);\n  }\n\n  // Splice members - defined in terms of transfer...\n  void splice(iterator where, iplist_impl &L2) {\n    if (!L2.empty())\n      transfer(where, L2, L2.begin(), L2.end());\n  }\n  void splice(iterator where, iplist_impl &L2, iterator first) {\n    iterator last = first; ++last;\n    if (where == first || where == last) return; // No change\n    transfer(where, L2, first, last);\n  }\n  void splice(iterator where, iplist_impl &L2, iterator first, iterator last) {\n    if (first != last) transfer(where, L2, first, last);\n  }\n  void splice(iterator where, iplist_impl &L2, reference N) {\n    splice(where, L2, iterator(N));\n  }\n  void splice(iterator where, iplist_impl &L2, pointer N) {\n    splice(where, L2, iterator(N));\n  }\n\n  template <class Compare>\n  void merge(iplist_impl &Right, Compare comp) {\n    if (this == &Right)\n      return;\n    this->transferNodesFromList(Right, Right.begin(), Right.end());\n    base_list_type::merge(Right, comp);\n  }\n  void merge(iplist_impl &Right) { return merge(Right, op_less); }\n\n  using base_list_type::sort;\n\n  /// Get the previous node, or \\c nullptr for the list head.\n  pointer getPrevNode(reference N) const {\n    auto I = N.getIterator();\n    if (I == begin())\n      return nullptr;\n    return &*std::prev(I);\n  }\n  /// Get the previous node, or \\c nullptr for the list head.\n  const_pointer getPrevNode(const_reference N) const {\n    return getPrevNode(const_cast<reference >(N));\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  pointer getNextNode(reference N) const {\n    auto Next = std::next(N.getIterator());\n    if (Next == end())\n      return nullptr;\n    return &*Next;\n  }\n  /// Get the next node, or \\c nullptr for the list tail.\n  const_pointer getNextNode(const_reference N) const {\n    return getNextNode(const_cast<reference >(N));\n  }\n};\n\n/// An intrusive list with ownership and callbacks specified/controlled by\n/// ilist_traits, only with API safe for polymorphic types.\n///\n/// The \\p Options parameters are the same as those for \\a simple_ilist.  See\n/// there for a description of what's available.\ntemplate <class T, class... Options>\nclass iplist\n    : public iplist_impl<simple_ilist<T, Options...>, ilist_traits<T>> {\n  using iplist_impl_type = typename iplist::iplist_impl;\n\npublic:\n  iplist() = default;\n\n  iplist(const iplist &X) = delete;\n  iplist &operator=(const iplist &X) = delete;\n\n  iplist(iplist &&X) : iplist_impl_type(std::move(X)) {}\n  iplist &operator=(iplist &&X) {\n    *static_cast<iplist_impl_type *>(this) = std::move(X);\n    return *this;\n  }\n};\n\ntemplate <class T, class... Options> using ilist = iplist<T, Options...>;\n\n} // end namespace llvm\n\nnamespace std {\n\n  // Ensure that swap uses the fast list swap...\n  template<class Ty>\n  void swap(llvm::iplist<Ty> &Left, llvm::iplist<Ty> &Right) {\n    Left.swap(Right);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_ILIST_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h", "content": "//===- llvm/ADT/ilist_iterator.h - Intrusive List Iterator ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_ITERATOR_H\n#define LLVM_ADT_ILIST_ITERATOR_H\n\n#include \"llvm/ADT/ilist_node.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n\nnamespace llvm {\n\nnamespace ilist_detail {\n\n/// Find const-correct node types.\ntemplate <class OptionsT, bool IsConst> struct IteratorTraits;\ntemplate <class OptionsT> struct IteratorTraits<OptionsT, false> {\n  using value_type = typename OptionsT::value_type;\n  using pointer = typename OptionsT::pointer;\n  using reference = typename OptionsT::reference;\n  using node_pointer = ilist_node_impl<OptionsT> *;\n  using node_reference = ilist_node_impl<OptionsT> &;\n};\ntemplate <class OptionsT> struct IteratorTraits<OptionsT, true> {\n  using value_type = const typename OptionsT::value_type;\n  using pointer = typename OptionsT::const_pointer;\n  using reference = typename OptionsT::const_reference;\n  using node_pointer = const ilist_node_impl<OptionsT> *;\n  using node_reference = const ilist_node_impl<OptionsT> &;\n};\n\ntemplate <bool IsReverse> struct IteratorHelper;\ntemplate <> struct IteratorHelper<false> : ilist_detail::NodeAccess {\n  using Access = ilist_detail::NodeAccess;\n\n  template <class T> static void increment(T *&I) { I = Access::getNext(*I); }\n  template <class T> static void decrement(T *&I) { I = Access::getPrev(*I); }\n};\ntemplate <> struct IteratorHelper<true> : ilist_detail::NodeAccess {\n  using Access = ilist_detail::NodeAccess;\n\n  template <class T> static void increment(T *&I) { I = Access::getPrev(*I); }\n  template <class T> static void decrement(T *&I) { I = Access::getNext(*I); }\n};\n\n} // end namespace ilist_detail\n\n/// Iterator for intrusive lists  based on ilist_node.\ntemplate <class OptionsT, bool IsReverse, bool IsConst>\nclass ilist_iterator : ilist_detail::SpecificNodeAccess<OptionsT> {\n  friend ilist_iterator<OptionsT, IsReverse, !IsConst>;\n  friend ilist_iterator<OptionsT, !IsReverse, IsConst>;\n  friend ilist_iterator<OptionsT, !IsReverse, !IsConst>;\n\n  using Traits = ilist_detail::IteratorTraits<OptionsT, IsConst>;\n  using Access = ilist_detail::SpecificNodeAccess<OptionsT>;\n\npublic:\n  using value_type = typename Traits::value_type;\n  using pointer = typename Traits::pointer;\n  using reference = typename Traits::reference;\n  using difference_type = ptrdiff_t;\n  using iterator_category = std::bidirectional_iterator_tag;\n  using const_pointer = typename OptionsT::const_pointer;\n  using const_reference = typename OptionsT::const_reference;\n\nprivate:\n  using node_pointer = typename Traits::node_pointer;\n  using node_reference = typename Traits::node_reference;\n\n  node_pointer NodePtr = nullptr;\n\npublic:\n  /// Create from an ilist_node.\n  explicit ilist_iterator(node_reference N) : NodePtr(&N) {}\n\n  explicit ilist_iterator(pointer NP) : NodePtr(Access::getNodePtr(NP)) {}\n  explicit ilist_iterator(reference NR) : NodePtr(Access::getNodePtr(&NR)) {}\n  ilist_iterator() = default;\n\n  // This is templated so that we can allow constructing a const iterator from\n  // a nonconst iterator...\n  template <bool RHSIsConst>\n  ilist_iterator(const ilist_iterator<OptionsT, IsReverse, RHSIsConst> &RHS,\n                 std::enable_if_t<IsConst || !RHSIsConst, void *> = nullptr)\n      : NodePtr(RHS.NodePtr) {}\n\n  // This is templated so that we can allow assigning to a const iterator from\n  // a nonconst iterator...\n  template <bool RHSIsConst>\n  std::enable_if_t<IsConst || !RHSIsConst, ilist_iterator &>\n  operator=(const ilist_iterator<OptionsT, IsReverse, RHSIsConst> &RHS) {\n    NodePtr = RHS.NodePtr;\n    return *this;\n  }\n\n  /// Explicit conversion between forward/reverse iterators.\n  ///\n  /// Translate between forward and reverse iterators without changing range\n  /// boundaries.  The resulting iterator will dereference (and have a handle)\n  /// to the previous node, which is somewhat unexpected; but converting the\n  /// two endpoints in a range will give the same range in reverse.\n  ///\n  /// This matches std::reverse_iterator conversions.\n  explicit ilist_iterator(\n      const ilist_iterator<OptionsT, !IsReverse, IsConst> &RHS)\n      : ilist_iterator(++RHS.getReverse()) {}\n\n  /// Get a reverse iterator to the same node.\n  ///\n  /// Gives a reverse iterator that will dereference (and have a handle) to the\n  /// same node.  Converting the endpoint iterators in a range will give a\n  /// different range; for range operations, use the explicit conversions.\n  ilist_iterator<OptionsT, !IsReverse, IsConst> getReverse() const {\n    if (NodePtr)\n      return ilist_iterator<OptionsT, !IsReverse, IsConst>(*NodePtr);\n    return ilist_iterator<OptionsT, !IsReverse, IsConst>();\n  }\n\n  /// Const-cast.\n  ilist_iterator<OptionsT, IsReverse, false> getNonConst() const {\n    if (NodePtr)\n      return ilist_iterator<OptionsT, IsReverse, false>(\n          const_cast<typename ilist_iterator<OptionsT, IsReverse,\n                                             false>::node_reference>(*NodePtr));\n    return ilist_iterator<OptionsT, IsReverse, false>();\n  }\n\n  // Accessors...\n  reference operator*() const {\n    assert(!NodePtr->isKnownSentinel());\n    return *Access::getValuePtr(NodePtr);\n  }\n  pointer operator->() const { return &operator*(); }\n\n  // Comparison operators\n  friend bool operator==(const ilist_iterator &LHS, const ilist_iterator &RHS) {\n    return LHS.NodePtr == RHS.NodePtr;\n  }\n  friend bool operator!=(const ilist_iterator &LHS, const ilist_iterator &RHS) {\n    return LHS.NodePtr != RHS.NodePtr;\n  }\n\n  // Increment and decrement operators...\n  ilist_iterator &operator--() {\n    NodePtr = IsReverse ? NodePtr->getNext() : NodePtr->getPrev();\n    return *this;\n  }\n  ilist_iterator &operator++() {\n    NodePtr = IsReverse ? NodePtr->getPrev() : NodePtr->getNext();\n    return *this;\n  }\n  ilist_iterator operator--(int) {\n    ilist_iterator tmp = *this;\n    --*this;\n    return tmp;\n  }\n  ilist_iterator operator++(int) {\n    ilist_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  /// Get the underlying ilist_node.\n  node_pointer getNodePtr() const { return static_cast<node_pointer>(NodePtr); }\n\n  /// Check for end.  Only valid if ilist_sentinel_tracking<true>.\n  bool isEnd() const { return NodePtr ? NodePtr->isSentinel() : false; }\n};\n\ntemplate <typename From> struct simplify_type;\n\n/// Allow ilist_iterators to convert into pointers to a node automatically when\n/// used by the dyn_cast, cast, isa mechanisms...\n///\n/// FIXME: remove this, since there is no implicit conversion to NodeTy.\ntemplate <class OptionsT, bool IsConst>\nstruct simplify_type<ilist_iterator<OptionsT, false, IsConst>> {\n  using iterator = ilist_iterator<OptionsT, false, IsConst>;\n  using SimpleType = typename iterator::pointer;\n\n  static SimpleType getSimplifiedValue(const iterator &Node) { return &*Node; }\n};\ntemplate <class OptionsT, bool IsConst>\nstruct simplify_type<const ilist_iterator<OptionsT, false, IsConst>>\n    : simplify_type<ilist_iterator<OptionsT, false, IsConst>> {};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ILIST_ITERATOR_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "content": "//===- llvm/ADT/simple_ilist.h - Simple Intrusive List ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SIMPLE_ILIST_H\n#define LLVM_ADT_SIMPLE_ILIST_H\n\n#include \"llvm/ADT/ilist_base.h\"\n#include \"llvm/ADT/ilist_iterator.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/ilist_node_options.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <functional>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// A simple intrusive list implementation.\n///\n/// This is a simple intrusive list for a \\c T that inherits from \\c\n/// ilist_node<T>.  The list never takes ownership of anything inserted in it.\n///\n/// Unlike \\a iplist<T> and \\a ilist<T>, \\a simple_ilist<T> never deletes\n/// values, and has no callback traits.\n///\n/// The API for adding nodes include \\a push_front(), \\a push_back(), and \\a\n/// insert().  These all take values by reference (not by pointer), except for\n/// the range version of \\a insert().\n///\n/// There are three sets of API for discarding nodes from the list: \\a\n/// remove(), which takes a reference to the node to remove, \\a erase(), which\n/// takes an iterator or iterator range and returns the next one, and \\a\n/// clear(), which empties out the container.  All three are constant time\n/// operations.  None of these deletes any nodes; in particular, if there is a\n/// single node in the list, then these have identical semantics:\n/// \\li \\c L.remove(L.front());\n/// \\li \\c L.erase(L.begin());\n/// \\li \\c L.clear();\n///\n/// As a convenience for callers, there are parallel APIs that take a \\c\n/// Disposer (such as \\c std::default_delete<T>): \\a removeAndDispose(), \\a\n/// eraseAndDispose(), and \\a clearAndDispose().  These have different names\n/// because the extra semantic is otherwise non-obvious.  They are equivalent\n/// to calling \\a std::for_each() on the range to be discarded.\n///\n/// The currently available \\p Options customize the nodes in the list.  The\n/// same options must be specified in the \\a ilist_node instantiation for\n/// compatibility (although the order is irrelevant).\n/// \\li Use \\a ilist_tag to designate which ilist_node for a given \\p T this\n/// list should use.  This is useful if a type \\p T is part of multiple,\n/// independent lists simultaneously.\n/// \\li Use \\a ilist_sentinel_tracking to always (or never) track whether a\n/// node is a sentinel.  Specifying \\c true enables the \\a\n/// ilist_node::isSentinel() API.  Unlike \\a ilist_node::isKnownSentinel(),\n/// which is only appropriate for assertions, \\a ilist_node::isSentinel() is\n/// appropriate for real logic.\n///\n/// Here are examples of \\p Options usage:\n/// \\li \\c simple_ilist<T> gives the defaults.  \\li \\c\n/// simple_ilist<T,ilist_sentinel_tracking<true>> enables the \\a\n/// ilist_node::isSentinel() API.\n/// \\li \\c simple_ilist<T,ilist_tag<A>,ilist_sentinel_tracking<false>>\n/// specifies a tag of A and that tracking should be off (even when\n/// LLVM_ENABLE_ABI_BREAKING_CHECKS are enabled).\n/// \\li \\c simple_ilist<T,ilist_sentinel_tracking<false>,ilist_tag<A>> is\n/// equivalent to the last.\n///\n/// See \\a is_valid_option for steps on adding a new option.\ntemplate <typename T, class... Options>\nclass simple_ilist\n    : ilist_detail::compute_node_options<T, Options...>::type::list_base_type,\n      ilist_detail::SpecificNodeAccess<\n          typename ilist_detail::compute_node_options<T, Options...>::type> {\n  static_assert(ilist_detail::check_options<Options...>::value,\n                \"Unrecognized node option!\");\n  using OptionsT =\n      typename ilist_detail::compute_node_options<T, Options...>::type;\n  using list_base_type = typename OptionsT::list_base_type;\n  ilist_sentinel<OptionsT> Sentinel;\n\npublic:\n  using value_type = typename OptionsT::value_type;\n  using pointer = typename OptionsT::pointer;\n  using reference = typename OptionsT::reference;\n  using const_pointer = typename OptionsT::const_pointer;\n  using const_reference = typename OptionsT::const_reference;\n  using iterator = ilist_iterator<OptionsT, false, false>;\n  using const_iterator = ilist_iterator<OptionsT, false, true>;\n  using reverse_iterator = ilist_iterator<OptionsT, true, false>;\n  using const_reverse_iterator = ilist_iterator<OptionsT, true, true>;\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n\n  simple_ilist() = default;\n  ~simple_ilist() = default;\n\n  // No copy constructors.\n  simple_ilist(const simple_ilist &) = delete;\n  simple_ilist &operator=(const simple_ilist &) = delete;\n\n  // Move constructors.\n  simple_ilist(simple_ilist &&X) { splice(end(), X); }\n  simple_ilist &operator=(simple_ilist &&X) {\n    clear();\n    splice(end(), X);\n    return *this;\n  }\n\n  iterator begin() { return ++iterator(Sentinel); }\n  const_iterator begin() const { return ++const_iterator(Sentinel); }\n  iterator end() { return iterator(Sentinel); }\n  const_iterator end() const { return const_iterator(Sentinel); }\n  reverse_iterator rbegin() { return ++reverse_iterator(Sentinel); }\n  const_reverse_iterator rbegin() const {\n    return ++const_reverse_iterator(Sentinel);\n  }\n  reverse_iterator rend() { return reverse_iterator(Sentinel); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(Sentinel);\n  }\n\n  /// Check if the list is empty in constant time.\n  LLVM_NODISCARD bool empty() const { return Sentinel.empty(); }\n\n  /// Calculate the size of the list in linear time.\n  LLVM_NODISCARD size_type size() const {\n    return std::distance(begin(), end());\n  }\n\n  reference front() { return *begin(); }\n  const_reference front() const { return *begin(); }\n  reference back() { return *rbegin(); }\n  const_reference back() const { return *rbegin(); }\n\n  /// Insert a node at the front; never copies.\n  void push_front(reference Node) { insert(begin(), Node); }\n\n  /// Insert a node at the back; never copies.\n  void push_back(reference Node) { insert(end(), Node); }\n\n  /// Remove the node at the front; never deletes.\n  void pop_front() { erase(begin()); }\n\n  /// Remove the node at the back; never deletes.\n  void pop_back() { erase(--end()); }\n\n  /// Swap with another list in place using std::swap.\n  void swap(simple_ilist &X) { std::swap(*this, X); }\n\n  /// Insert a node by reference; never copies.\n  iterator insert(iterator I, reference Node) {\n    list_base_type::insertBefore(*I.getNodePtr(), *this->getNodePtr(&Node));\n    return iterator(&Node);\n  }\n\n  /// Insert a range of nodes; never copies.\n  template <class Iterator>\n  void insert(iterator I, Iterator First, Iterator Last) {\n    for (; First != Last; ++First)\n      insert(I, *First);\n  }\n\n  /// Clone another list.\n  template <class Cloner, class Disposer>\n  void cloneFrom(const simple_ilist &L2, Cloner clone, Disposer dispose) {\n    clearAndDispose(dispose);\n    for (const_reference V : L2)\n      push_back(*clone(V));\n  }\n\n  /// Remove a node by reference; never deletes.\n  ///\n  /// \\see \\a erase() for removing by iterator.\n  /// \\see \\a removeAndDispose() if the node should be deleted.\n  void remove(reference N) { list_base_type::remove(*this->getNodePtr(&N)); }\n\n  /// Remove a node by reference and dispose of it.\n  template <class Disposer>\n  void removeAndDispose(reference N, Disposer dispose) {\n    remove(N);\n    dispose(&N);\n  }\n\n  /// Remove a node by iterator; never deletes.\n  ///\n  /// \\see \\a remove() for removing by reference.\n  /// \\see \\a eraseAndDispose() it the node should be deleted.\n  iterator erase(iterator I) {\n    assert(I != end() && \"Cannot remove end of list!\");\n    remove(*I++);\n    return I;\n  }\n\n  /// Remove a range of nodes; never deletes.\n  ///\n  /// \\see \\a eraseAndDispose() if the nodes should be deleted.\n  iterator erase(iterator First, iterator Last) {\n    list_base_type::removeRange(*First.getNodePtr(), *Last.getNodePtr());\n    return Last;\n  }\n\n  /// Remove a node by iterator and dispose of it.\n  template <class Disposer>\n  iterator eraseAndDispose(iterator I, Disposer dispose) {\n    auto Next = std::next(I);\n    erase(I);\n    dispose(&*I);\n    return Next;\n  }\n\n  /// Remove a range of nodes and dispose of them.\n  template <class Disposer>\n  iterator eraseAndDispose(iterator First, iterator Last, Disposer dispose) {\n    while (First != Last)\n      First = eraseAndDispose(First, dispose);\n    return Last;\n  }\n\n  /// Clear the list; never deletes.\n  ///\n  /// \\see \\a clearAndDispose() if the nodes should be deleted.\n  void clear() { Sentinel.reset(); }\n\n  /// Clear the list and dispose of the nodes.\n  template <class Disposer> void clearAndDispose(Disposer dispose) {\n    eraseAndDispose(begin(), end(), dispose);\n  }\n\n  /// Splice in another list.\n  void splice(iterator I, simple_ilist &L2) {\n    splice(I, L2, L2.begin(), L2.end());\n  }\n\n  /// Splice in a node from another list.\n  void splice(iterator I, simple_ilist &L2, iterator Node) {\n    splice(I, L2, Node, std::next(Node));\n  }\n\n  /// Splice in a range of nodes from another list.\n  void splice(iterator I, simple_ilist &, iterator First, iterator Last) {\n    list_base_type::transferBefore(*I.getNodePtr(), *First.getNodePtr(),\n                                   *Last.getNodePtr());\n  }\n\n  /// Merge in another list.\n  ///\n  /// \\pre \\c this and \\p RHS are sorted.\n  ///@{\n  void merge(simple_ilist &RHS) { merge(RHS, std::less<T>()); }\n  template <class Compare> void merge(simple_ilist &RHS, Compare comp);\n  ///@}\n\n  /// Sort the list.\n  ///@{\n  void sort() { sort(std::less<T>()); }\n  template <class Compare> void sort(Compare comp);\n  ///@}\n};\n\ntemplate <class T, class... Options>\ntemplate <class Compare>\nvoid simple_ilist<T, Options...>::merge(simple_ilist &RHS, Compare comp) {\n  if (this == &RHS || RHS.empty())\n    return;\n  iterator LI = begin(), LE = end();\n  iterator RI = RHS.begin(), RE = RHS.end();\n  while (LI != LE) {\n    if (comp(*RI, *LI)) {\n      // Transfer a run of at least size 1 from RHS to LHS.\n      iterator RunStart = RI++;\n      RI = std::find_if(RI, RE, [&](reference RV) { return !comp(RV, *LI); });\n      splice(LI, RHS, RunStart, RI);\n      if (RI == RE)\n        return;\n    }\n    ++LI;\n  }\n  // Transfer the remaining RHS nodes once LHS is finished.\n  splice(LE, RHS, RI, RE);\n}\n\ntemplate <class T, class... Options>\ntemplate <class Compare>\nvoid simple_ilist<T, Options...>::sort(Compare comp) {\n  // Vacuously sorted.\n  if (empty() || std::next(begin()) == end())\n    return;\n\n  // Split the list in the middle.\n  iterator Center = begin(), End = begin();\n  while (End != end() && ++End != end()) {\n    ++Center;\n    ++End;\n  }\n  simple_ilist RHS;\n  RHS.splice(RHS.end(), *this, Center, end());\n\n  // Sort the sublists and merge back together.\n  sort(comp);\n  RHS.sort(comp);\n  merge(RHS, comp);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SIMPLE_ILIST_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "content": "//==- include/llvm/CodeGen/AccelTable.h - Accelerator Tables -----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing accelerator tables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_ACCELTABLE_H\n#define LLVM_CODEGEN_ACCELTABLE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/DJB.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\n/// The DWARF and Apple accelerator tables are an indirect hash table optimized\n/// for null lookup rather than access to known data. The Apple accelerator\n/// tables are a precursor of the newer DWARF v5 accelerator tables. Both\n/// formats share common design ideas.\n///\n/// The Apple accelerator table are output into an on-disk format that looks\n/// like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  BUCKETS         |\n/// |------------------|\n/// |  HASHES          |\n/// |------------------|\n/// |  OFFSETS         |\n/// |------------------|\n/// |  DATA            |\n/// `------------------'\n///\n/// The header contains a magic number, version, type of hash function,\n/// the number of buckets, total number of hashes, and room for a special struct\n/// of data and the length of that struct.\n///\n/// The buckets contain an index (e.g. 6) into the hashes array. The hashes\n/// section contains all of the 32-bit hash values in contiguous memory, and the\n/// offsets contain the offset into the data area for the particular hash.\n///\n/// For a lookup example, we could hash a function name and take it modulo the\n/// number of buckets giving us our bucket. From there we take the bucket value\n/// as an index into the hashes table and look at each successive hash as long\n/// as the hash value is still the same modulo result (bucket value) as earlier.\n/// If we have a match we look at that same entry in the offsets table and grab\n/// the offset in the data for our final match.\n///\n/// The DWARF v5 accelerator table consists of zero or more name indices that\n/// are output into an on-disk format that looks like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  CU LIST         |\n/// |------------------|\n/// |  LOCAL TU LIST   |\n/// |------------------|\n/// |  FOREIGN TU LIST |\n/// |------------------|\n/// |  HASH TABLE      |\n/// |------------------|\n/// |  NAME TABLE      |\n/// |------------------|\n/// |  ABBREV TABLE    |\n/// |------------------|\n/// |  ENTRY POOL      |\n/// `------------------'\n///\n/// For the full documentation please refer to the DWARF 5 standard.\n///\n///\n/// This file defines the class template AccelTable, which is represents an\n/// abstract view of an Accelerator table, without any notion of an on-disk\n/// layout. This class is parameterized by an entry type, which should derive\n/// from AccelTableData. This is the type of individual entries in the table,\n/// and it should store the data necessary to emit them. AppleAccelTableData is\n/// the base class for Apple Accelerator Table entries, which have a uniform\n/// structure based on a sequence of Atoms. There are different sub-classes\n/// derived from AppleAccelTable, which differ in the set of Atoms and how they\n/// obtain their values.\n///\n/// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable\n/// function.\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DwarfCompileUnit;\nclass DwarfDebug;\n\n/// Interface which the different types of accelerator table data have to\n/// conform. It serves as a base class for different values of the template\n/// argument of the AccelTable class template.\nclass AccelTableData {\npublic:\n  virtual ~AccelTableData() = default;\n\n  bool operator<(const AccelTableData &Other) const {\n    return order() < Other.order();\n  }\n\n    // Subclasses should implement:\n    // static uint32_t hash(StringRef Name);\n\n#ifndef NDEBUG\n  virtual void print(raw_ostream &OS) const = 0;\n#endif\nprotected:\n  virtual uint64_t order() const = 0;\n};\n\n/// A base class holding non-template-dependant functionality of the AccelTable\n/// class. Clients should not use this class directly but rather instantiate\n/// AccelTable with a type derived from AccelTableData.\nclass AccelTableBase {\npublic:\n  using HashFn = uint32_t(StringRef);\n\n  /// Represents a group of entries with identical name (and hence, hash value).\n  struct HashData {\n    DwarfStringPoolEntryRef Name;\n    uint32_t HashValue;\n    std::vector<AccelTableData *> Values;\n    MCSymbol *Sym;\n\n    HashData(DwarfStringPoolEntryRef Name, HashFn *Hash)\n        : Name(Name), HashValue(Hash(Name.getString())) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  using HashList = std::vector<HashData *>;\n  using BucketList = std::vector<HashList>;\n\nprotected:\n  /// Allocator for HashData and Values.\n  BumpPtrAllocator Allocator;\n\n  using StringEntries = StringMap<HashData, BumpPtrAllocator &>;\n  StringEntries Entries;\n\n  HashFn *Hash;\n  uint32_t BucketCount;\n  uint32_t UniqueHashCount;\n\n  HashList Hashes;\n  BucketList Buckets;\n\n  void computeBucketCount();\n\n  AccelTableBase(HashFn *Hash) : Entries(Allocator), Hash(Hash) {}\n\npublic:\n  void finalize(AsmPrinter *Asm, StringRef Prefix);\n  ArrayRef<HashList> getBuckets() const { return Buckets; }\n  uint32_t getBucketCount() const { return BucketCount; }\n  uint32_t getUniqueHashCount() const { return UniqueHashCount; }\n  uint32_t getUniqueNameCount() const { return Entries.size(); }\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const;\n  void dump() const { print(dbgs()); }\n#endif\n\n  AccelTableBase(const AccelTableBase &) = delete;\n  void operator=(const AccelTableBase &) = delete;\n};\n\n/// This class holds an abstract representation of an Accelerator Table,\n/// consisting of a sequence of buckets, each bucket containint a sequence of\n/// HashData entries. The class is parameterized by the type of entries it\n/// holds. The type template parameter also defines the hash function to use for\n/// hashing names.\ntemplate <typename DataT> class AccelTable : public AccelTableBase {\npublic:\n  AccelTable() : AccelTableBase(DataT::hash) {}\n\n  template <typename... Types>\n  void addName(DwarfStringPoolEntryRef Name, Types &&... Args);\n};\n\ntemplate <typename AccelTableDataT>\ntemplate <typename... Types>\nvoid AccelTable<AccelTableDataT>::addName(DwarfStringPoolEntryRef Name,\n                                          Types &&... Args) {\n  assert(Buckets.empty() && \"Already finalized!\");\n  // If the string is in the list already then add this die to the list\n  // otherwise add a new one.\n  auto Iter = Entries.try_emplace(Name.getString(), Name, Hash).first;\n  assert(Iter->second.Name == Name);\n  Iter->second.Values.push_back(\n      new (Allocator) AccelTableDataT(std::forward<Types>(Args)...));\n}\n\n/// A base class for different implementations of Data classes for Apple\n/// Accelerator Tables. The columns in the table are defined by the static Atoms\n/// variable defined on the subclasses.\nclass AppleAccelTableData : public AccelTableData {\npublic:\n  /// An Atom defines the form of the data in an Apple accelerator table.\n  /// Conceptually it is a column in the accelerator consisting of a type and a\n  /// specification of the form of its data.\n  struct Atom {\n    /// Atom Type.\n    const uint16_t Type;\n    /// DWARF Form.\n    const uint16_t Form;\n\n    constexpr Atom(uint16_t Type, uint16_t Form) : Type(Type), Form(Form) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  // Subclasses should define:\n  // static constexpr Atom Atoms[];\n\n  virtual void emit(AsmPrinter *Asm) const = 0;\n\n  static uint32_t hash(StringRef Buffer) { return djbHash(Buffer); }\n};\n\n/// The Data class implementation for DWARF v5 accelerator table. Unlike the\n/// Apple Data classes, this class is just a DIE wrapper, and does not know to\n/// serialize itself. The complete serialization logic is in the\n/// emitDWARF5AccelTable function.\nclass DWARF5AccelTableData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableData(const DIE &Die) : Die(Die) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  const DIE &getDie() const { return Die; }\n  uint64_t getDieOffset() const { return Die.getOffset(); }\n  unsigned getDieTag() const { return Die.getTag(); }\n\nprotected:\n  const DIE &Die;\n\n  uint64_t order() const override { return Die.getOffset(); }\n};\n\nclass DWARF5AccelTableStaticData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableStaticData(uint64_t DieOffset, unsigned DieTag,\n                             unsigned CUIndex)\n      : DieOffset(DieOffset), DieTag(DieTag), CUIndex(CUIndex) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  uint64_t getDieOffset() const { return DieOffset; }\n  unsigned getDieTag() const { return DieTag; }\n  unsigned getCUIndex() const { return CUIndex; }\n\nprotected:\n  uint64_t DieOffset;\n  unsigned DieTag;\n  unsigned CUIndex;\n\n  uint64_t order() const override { return DieOffset; }\n};\n\nvoid emitAppleAccelTableImpl(AsmPrinter *Asm, AccelTableBase &Contents,\n                             StringRef Prefix, const MCSymbol *SecBegin,\n                             ArrayRef<AppleAccelTableData::Atom> Atoms);\n\n/// Emit an Apple Accelerator Table consisting of entries in the specified\n/// AccelTable. The DataT template parameter should be derived from\n/// AppleAccelTableData.\ntemplate <typename DataT>\nvoid emitAppleAccelTable(AsmPrinter *Asm, AccelTable<DataT> &Contents,\n                         StringRef Prefix, const MCSymbol *SecBegin) {\n  static_assert(std::is_convertible<DataT *, AppleAccelTableData *>::value, \"\");\n  emitAppleAccelTableImpl(Asm, Contents, Prefix, SecBegin, DataT::Atoms);\n}\n\nvoid emitDWARF5AccelTable(AsmPrinter *Asm,\n                          AccelTable<DWARF5AccelTableData> &Contents,\n                          const DwarfDebug &DD,\n                          ArrayRef<std::unique_ptr<DwarfCompileUnit>> CUs);\n\nvoid emitDWARF5AccelTable(\n    AsmPrinter *Asm, AccelTable<DWARF5AccelTableStaticData> &Contents,\n    ArrayRef<MCSymbol *> CUs,\n    llvm::function_ref<unsigned(const DWARF5AccelTableStaticData &)>\n        getCUIndexForEntry);\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with just a DIE reference.\nclass AppleAccelTableOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableOffsetData(const DIE &D) : Die(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Die.getOffset(); }\n\n  const DIE &Die;\n};\n\n/// Accelerator table data implementation for Apple type accelerator tables.\nclass AppleAccelTableTypeData : public AppleAccelTableOffsetData {\npublic:\n  AppleAccelTableTypeData(const DIE &D) : AppleAccelTableOffsetData(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(dwarf::DW_ATOM_type_flags, dwarf::DW_FORM_data1)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n};\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableStaticOffsetData(uint32_t Offset) : Offset(Offset) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t Offset;\n};\n\n/// Accelerator table data implementation for type accelerator tables with\n/// a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticTypeData : public AppleAccelTableStaticOffsetData {\npublic:\n  AppleAccelTableStaticTypeData(uint32_t Offset, uint16_t Tag,\n                                bool ObjCClassIsImplementation,\n                                uint32_t QualifiedNameHash)\n      : AppleAccelTableStaticOffsetData(Offset),\n        QualifiedNameHash(QualifiedNameHash), Tag(Tag),\n        ObjCClassIsImplementation(ObjCClassIsImplementation) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(5, dwarf::DW_FORM_data1), Atom(6, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t QualifiedNameHash;\n  uint16_t Tag;\n  bool ObjCClassIsImplementation;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_ACCELTABLE_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "content": "//===- lib/CodeGen/DIE.h - DWARF Info Entries -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Data structures for DWARF info entries.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DIE_H\n#define LLVM_CODEGEN_DIE_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DIE;\nclass DIEUnit;\nclass DwarfCompileUnit;\nclass MCExpr;\nclass MCSection;\nclass MCSymbol;\nclass raw_ostream;\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation data, describes one attribute of a Dwarf abbreviation.\nclass DIEAbbrevData {\n  /// Dwarf attribute code.\n  dwarf::Attribute Attribute;\n\n  /// Dwarf form code.\n  dwarf::Form Form;\n\n  /// Dwarf attribute value for DW_FORM_implicit_const\n  int64_t Value = 0;\n\npublic:\n  DIEAbbrevData(dwarf::Attribute A, dwarf::Form F)\n      : Attribute(A), Form(F) {}\n  DIEAbbrevData(dwarf::Attribute A, int64_t V)\n      : Attribute(A), Form(dwarf::DW_FORM_implicit_const), Value(V) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  int64_t getValue() const { return Value; }\n  /// @}\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation, describes the organization of a debug information\n/// object.\nclass DIEAbbrev : public FoldingSetNode {\n  /// Unique number for node.\n  unsigned Number = 0;\n\n  /// Dwarf tag code.\n  dwarf::Tag Tag;\n\n  /// Whether or not this node has children.\n  ///\n  /// This cheats a bit in all of the uses since the values in the standard\n  /// are 0 and 1 for no children and children respectively.\n  bool Children;\n\n  /// Raw data bytes for abbreviation.\n  SmallVector<DIEAbbrevData, 12> Data;\n\npublic:\n  DIEAbbrev(dwarf::Tag T, bool C) : Tag(T), Children(C) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Tag getTag() const { return Tag; }\n  unsigned getNumber() const { return Number; }\n  bool hasChildren() const { return Children; }\n  const SmallVectorImpl<DIEAbbrevData> &getData() const { return Data; }\n  void setChildrenFlag(bool hasChild) { Children = hasChild; }\n  void setNumber(unsigned N) { Number = N; }\n  /// @}\n\n  /// Adds another set of attribute information to the abbreviation.\n  void AddAttribute(dwarf::Attribute Attribute, dwarf::Form Form) {\n    Data.push_back(DIEAbbrevData(Attribute, Form));\n  }\n\n  /// Adds attribute with DW_FORM_implicit_const value\n  void AddImplicitConstAttribute(dwarf::Attribute Attribute, int64_t Value) {\n    Data.push_back(DIEAbbrevData(Attribute, Value));\n  }\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Print the abbreviation using the specified asm printer.\n  void Emit(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Helps unique DIEAbbrev objects and assigns abbreviation numbers.\n///\n/// This class will unique the DIE abbreviations for a llvm::DIE object and\n/// assign a unique abbreviation number to each unique DIEAbbrev object it\n/// finds. The resulting collection of DIEAbbrev objects can then be emitted\n/// into the .debug_abbrev section.\nclass DIEAbbrevSet {\n  /// The bump allocator to use when creating DIEAbbrev objects in the uniqued\n  /// storage container.\n  BumpPtrAllocator &Alloc;\n  /// FoldingSet that uniques the abbreviations.\n  FoldingSet<DIEAbbrev> AbbreviationsSet;\n  /// A list of all the unique abbreviations in use.\n  std::vector<DIEAbbrev *> Abbreviations;\n\npublic:\n  DIEAbbrevSet(BumpPtrAllocator &A) : Alloc(A) {}\n  ~DIEAbbrevSet();\n\n  /// Generate the abbreviation declaration for a DIE and return a pointer to\n  /// the generated abbreviation.\n  ///\n  /// \\param Die the debug info entry to generate the abbreviation for.\n  /// \\returns A reference to the uniqued abbreviation declaration that is\n  /// owned by this class.\n  DIEAbbrev &uniqueAbbreviation(DIE &Die);\n\n  /// Print all abbreviations using the specified asm printer.\n  void Emit(const AsmPrinter *AP, MCSection *Section) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An integer value DIE.\n///\nclass DIEInteger {\n  uint64_t Integer;\n\npublic:\n  explicit DIEInteger(uint64_t I) : Integer(I) {}\n\n  /// Choose the best form for integer.\n  static dwarf::Form BestForm(bool IsSigned, uint64_t Int) {\n    if (IsSigned) {\n      const int64_t SignedInt = Int;\n      if ((char)Int == SignedInt)\n        return dwarf::DW_FORM_data1;\n      if ((short)Int == SignedInt)\n        return dwarf::DW_FORM_data2;\n      if ((int)Int == SignedInt)\n        return dwarf::DW_FORM_data4;\n    } else {\n      if ((unsigned char)Int == Int)\n        return dwarf::DW_FORM_data1;\n      if ((unsigned short)Int == Int)\n        return dwarf::DW_FORM_data2;\n      if ((unsigned int)Int == Int)\n        return dwarf::DW_FORM_data4;\n    }\n    return dwarf::DW_FORM_data8;\n  }\n\n  uint64_t getValue() const { return Integer; }\n  void setValue(uint64_t Val) { Integer = Val; }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An expression DIE.\nclass DIEExpr {\n  const MCExpr *Expr;\n\npublic:\n  explicit DIEExpr(const MCExpr *E) : Expr(E) {}\n\n  /// Get MCExpr.\n  const MCExpr *getValue() const { return Expr; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A label DIE.\nclass DIELabel {\n  const MCSymbol *Label;\n\npublic:\n  explicit DIELabel(const MCSymbol *L) : Label(L) {}\n\n  /// Get MCSymbol.\n  const MCSymbol *getValue() const { return Label; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEBaseTypeRef {\n  const DwarfCompileUnit *CU;\n  const uint64_t Index;\n  static constexpr unsigned ULEB128PadSize = 4;\n\npublic:\n  explicit DIEBaseTypeRef(const DwarfCompileUnit *TheCU, uint64_t Idx)\n    : CU(TheCU), Index(Idx) {}\n\n  /// EmitValue - Emit base type reference.\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  /// SizeOf - Determine size of the base type reference in bytes.\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n  uint64_t getIndex() const { return Index; }\n};\n\n//===--------------------------------------------------------------------===//\n/// A simple label difference DIE.\n///\nclass DIEDelta {\n  const MCSymbol *LabelHi;\n  const MCSymbol *LabelLo;\n\npublic:\n  DIEDelta(const MCSymbol *Hi, const MCSymbol *Lo) : LabelHi(Hi), LabelLo(Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for string pool string values.\n///\n/// This class is used with the DW_FORM_strp and DW_FORM_GNU_str_index forms.\nclass DIEString {\n  DwarfStringPoolEntryRef S;\n\npublic:\n  DIEString(DwarfStringPoolEntryRef S) : S(S) {}\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S.getString(); }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for inline string values.\n///\n/// This class is used with the DW_FORM_string form.\nclass DIEInlineString {\n  StringRef S;\n\npublic:\n  template <typename Allocator>\n  explicit DIEInlineString(StringRef Str, Allocator &A) : S(Str.copy(A)) {}\n\n  ~DIEInlineString() = default;\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A pointer to another debug information entry.  An instance of this class can\n/// also be used as a proxy for a debug information entry not yet defined\n/// (ie. types.)\nclass DIEEntry {\n  DIE *Entry;\n\npublic:\n  DIEEntry() = delete;\n  explicit DIEEntry(DIE &E) : Entry(&E) {}\n\n  DIE &getEntry() const { return *Entry; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a pointer to a location list in the debug_loc\n/// section.\nclass DIELocList {\n  /// Index into the .debug_loc vector.\n  size_t Index;\n\npublic:\n  DIELocList(size_t I) : Index(I) {}\n\n  /// Grab the current index out.\n  size_t getValue() const { return Index; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEAddrOffset {\n  DIEInteger Addr;\n  DIEDelta Offset;\n\npublic:\n  explicit DIEAddrOffset(uint64_t Idx, const MCSymbol *Hi, const MCSymbol *Lo)\n      : Addr(Idx), Offset(Hi, Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A debug information entry value. Some of these roughly correlate\n/// to DWARF attribute classes.\nclass DIEBlock;\nclass DIELoc;\nclass DIEValue {\npublic:\n  enum Type {\n    isNone,\n#define HANDLE_DIEVALUE(T) is##T,\n#include \"llvm/CodeGen/DIEValue.def\"\n  };\n\nprivate:\n  /// Type of data stored in the value.\n  Type Ty = isNone;\n  dwarf::Attribute Attribute = (dwarf::Attribute)0;\n  dwarf::Form Form = (dwarf::Form)0;\n\n  /// Storage for the value.\n  ///\n  /// All values that aren't standard layout (or are larger than 8 bytes)\n  /// should be stored by reference instead of by value.\n  using ValTy =\n      AlignedCharArrayUnion<DIEInteger, DIEString, DIEExpr, DIELabel,\n                            DIEDelta *, DIEEntry, DIEBlock *, DIELoc *,\n                            DIELocList, DIEBaseTypeRef *, DIEAddrOffset *>;\n\n  static_assert(sizeof(ValTy) <= sizeof(uint64_t) ||\n                    sizeof(ValTy) <= sizeof(void *),\n                \"Expected all large types to be stored via pointer\");\n\n  /// Underlying stored value.\n  ValTy Val;\n\n  template <class T> void construct(T V) {\n    static_assert(std::is_standard_layout<T>::value ||\n                      std::is_pointer<T>::value,\n                  \"Expected standard layout or pointer\");\n    new (reinterpret_cast<void *>(&Val)) T(V);\n  }\n\n  template <class T> T *get() { return reinterpret_cast<T *>(&Val); }\n  template <class T> const T *get() const {\n    return reinterpret_cast<const T *>(&Val);\n  }\n  template <class T> void destruct() { get<T>()->~T(); }\n\n  /// Destroy the underlying value.\n  ///\n  /// This should get optimized down to a no-op.  We could skip it if we could\n  /// add a static assert on \\a std::is_trivially_copyable(), but we currently\n  /// support versions of GCC that don't understand that.\n  void destroyVal() {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<DIE##T>();                                                        \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<const DIE##T *>();                                                \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\n  /// Copy the underlying value.\n  ///\n  /// This should get optimized down to a simple copy.  We need to actually\n  /// construct the value, rather than calling memcpy, to satisfy strict\n  /// aliasing rules.\n  void copyVal(const DIEValue &X) {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    construct<DIE##T>(*X.get<DIE##T>());                                       \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    construct<const DIE##T *>(*X.get<const DIE##T *>());                       \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\npublic:\n  DIEValue() = default;\n\n  DIEValue(const DIEValue &X) : Ty(X.Ty), Attribute(X.Attribute), Form(X.Form) {\n    copyVal(X);\n  }\n\n  DIEValue &operator=(const DIEValue &X) {\n    destroyVal();\n    Ty = X.Ty;\n    Attribute = X.Attribute;\n    Form = X.Form;\n    copyVal(X);\n    return *this;\n  }\n\n  ~DIEValue() { destroyVal(); }\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T &V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    construct<DIE##T>(V);                                                      \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T *V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    assert(V && \"Expected valid value\");                                       \\\n    construct<const DIE##T *>(V);                                              \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Accessors.\n  /// @{\n  Type getType() const { return Ty; }\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  explicit operator bool() const { return Ty; }\n  /// @}\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return *get<DIE##T>();                                                     \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return **get<const DIE##T *>();                                            \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Emit value via the Dwarf writer.\n  void emitValue(const AsmPrinter *AP) const;\n\n  /// Return the size of a value in bytes.\n  unsigned SizeOf(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\nstruct IntrusiveBackListNode {\n  PointerIntPair<IntrusiveBackListNode *, 1> Next;\n\n  IntrusiveBackListNode() : Next(this, true) {}\n\n  IntrusiveBackListNode *getNext() const {\n    return Next.getInt() ? nullptr : Next.getPointer();\n  }\n};\n\nstruct IntrusiveBackListBase {\n  using Node = IntrusiveBackListNode;\n\n  Node *Last = nullptr;\n\n  bool empty() const { return !Last; }\n\n  void push_back(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next = Last->Next;\n      Last->Next.setPointerAndInt(&N, false);\n    }\n    Last = &N;\n  }\n\n  void push_front(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next.setPointerAndInt(Last->Next.getPointer(), false);\n      Last->Next.setPointerAndInt(&N, true);\n    } else {\n      Last = &N;\n    }\n  }\n};\n\ntemplate <class T> class IntrusiveBackList : IntrusiveBackListBase {\npublic:\n  using IntrusiveBackListBase::empty;\n\n  void push_back(T &N) { IntrusiveBackListBase::push_back(N); }\n  void push_front(T &N) { IntrusiveBackListBase::push_front(N); }\n  T &back() { return *static_cast<T *>(Last); }\n  const T &back() const { return *static_cast<T *>(Last); }\n  T &front() {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n  const T &front() const {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n\n  void takeNodes(IntrusiveBackList<T> &Other) {\n    if (Other.empty())\n      return;\n\n    T *FirstNode = static_cast<T *>(Other.Last->Next.getPointer());\n    T *IterNode = FirstNode;\n    do {\n      // Keep a pointer to the node and increment the iterator.\n      T *TmpNode = IterNode;\n      IterNode = static_cast<T *>(IterNode->Next.getPointer());\n\n      // Unlink the node and push it back to this list.\n      TmpNode->Next.setPointerAndInt(TmpNode, true);\n      push_back(*TmpNode);\n    } while (IterNode != FirstNode);\n\n    Other.Last = nullptr;\n  }\n\n  class const_iterator;\n  class iterator\n      : public iterator_facade_base<iterator, std::forward_iterator_tag, T> {\n    friend class const_iterator;\n\n    Node *N = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(T *N) : N(N) {}\n\n    iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    T &operator*() const { return *static_cast<T *>(N); }\n\n    bool operator==(const iterator &X) const { return N == X.N; }\n  };\n\n  class const_iterator\n      : public iterator_facade_base<const_iterator, std::forward_iterator_tag,\n                                    const T> {\n    const Node *N = nullptr;\n\n  public:\n    const_iterator() = default;\n    // Placate MSVC by explicitly scoping 'iterator'.\n    const_iterator(typename IntrusiveBackList<T>::iterator X) : N(X.N) {}\n    explicit const_iterator(const T *N) : N(N) {}\n\n    const_iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    const T &operator*() const { return *static_cast<const T *>(N); }\n\n    bool operator==(const const_iterator &X) const { return N == X.N; }\n  };\n\n  iterator begin() {\n    return Last ? iterator(static_cast<T *>(Last->Next.getPointer())) : end();\n  }\n  const_iterator begin() const {\n    return const_cast<IntrusiveBackList *>(this)->begin();\n  }\n  iterator end() { return iterator(); }\n  const_iterator end() const { return const_iterator(); }\n\n  static iterator toIterator(T &N) { return iterator(&N); }\n  static const_iterator toIterator(const T &N) { return const_iterator(&N); }\n};\n\n/// A list of DIE values.\n///\n/// This is a singly-linked list, but instead of reversing the order of\n/// insertion, we keep a pointer to the back of the list so we can push in\n/// order.\n///\n/// There are two main reasons to choose a linked list over a customized\n/// vector-like data structure.\n///\n///  1. For teardown efficiency, we want DIEs to be BumpPtrAllocated.  Using a\n///     linked list here makes this way easier to accomplish.\n///  2. Carrying an extra pointer per \\a DIEValue isn't expensive.  45% of DIEs\n///     have 2 or fewer values, and 90% have 5 or fewer.  A vector would be\n///     over-allocated by 50% on average anyway, the same cost as the\n///     linked-list node.\nclass DIEValueList {\n  struct Node : IntrusiveBackListNode {\n    DIEValue V;\n\n    explicit Node(DIEValue V) : V(V) {}\n  };\n\n  using ListTy = IntrusiveBackList<Node>;\n\n  ListTy List;\n\npublic:\n  class const_value_iterator;\n  class value_iterator\n      : public iterator_adaptor_base<value_iterator, ListTy::iterator,\n                                     std::forward_iterator_tag, DIEValue> {\n    friend class const_value_iterator;\n\n    using iterator_adaptor =\n        iterator_adaptor_base<value_iterator, ListTy::iterator,\n                              std::forward_iterator_tag, DIEValue>;\n\n  public:\n    value_iterator() = default;\n    explicit value_iterator(ListTy::iterator X) : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  class const_value_iterator : public iterator_adaptor_base<\n                                   const_value_iterator, ListTy::const_iterator,\n                                   std::forward_iterator_tag, const DIEValue> {\n    using iterator_adaptor =\n        iterator_adaptor_base<const_value_iterator, ListTy::const_iterator,\n                              std::forward_iterator_tag, const DIEValue>;\n\n  public:\n    const_value_iterator() = default;\n    const_value_iterator(DIEValueList::value_iterator X)\n        : iterator_adaptor(X.wrapped()) {}\n    explicit const_value_iterator(ListTy::const_iterator X)\n        : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    const DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  using value_range = iterator_range<value_iterator>;\n  using const_value_range = iterator_range<const_value_iterator>;\n\n  value_iterator addValue(BumpPtrAllocator &Alloc, const DIEValue &V) {\n    List.push_back(*new (Alloc) Node(V));\n    return value_iterator(ListTy::toIterator(List.back()));\n  }\n  template <class T>\n  value_iterator addValue(BumpPtrAllocator &Alloc, dwarf::Attribute Attribute,\n                    dwarf::Form Form, T &&Value) {\n    return addValue(Alloc, DIEValue(Attribute, Form, std::forward<T>(Value)));\n  }\n\n  /// Take ownership of the nodes in \\p Other, and append them to the back of\n  /// the list.\n  void takeValues(DIEValueList &Other) { List.takeNodes(Other.List); }\n\n  value_range values() {\n    return make_range(value_iterator(List.begin()), value_iterator(List.end()));\n  }\n  const_value_range values() const {\n    return make_range(const_value_iterator(List.begin()),\n                      const_value_iterator(List.end()));\n  }\n};\n\n//===--------------------------------------------------------------------===//\n/// A structured debug information entry.  Has an abbreviation which\n/// describes its organization.\nclass DIE : IntrusiveBackListNode, public DIEValueList {\n  friend class IntrusiveBackList<DIE>;\n  friend class DIEUnit;\n\n  /// Dwarf unit relative offset.\n  unsigned Offset = 0;\n  /// Size of instance + children.\n  unsigned Size = 0;\n  unsigned AbbrevNumber = ~0u;\n  /// Dwarf tag code.\n  dwarf::Tag Tag = (dwarf::Tag)0;\n  /// Set to true to force a DIE to emit an abbreviation that says it has\n  /// children even when it doesn't. This is used for unit testing purposes.\n  bool ForceChildren = false;\n  /// Children DIEs.\n  IntrusiveBackList<DIE> Children;\n\n  /// The owner is either the parent DIE for children of other DIEs, or a\n  /// DIEUnit which contains this DIE as its unit DIE.\n  PointerUnion<DIE *, DIEUnit *> Owner;\n\n  explicit DIE(dwarf::Tag Tag) : Tag(Tag) {}\n\npublic:\n  DIE() = delete;\n  DIE(const DIE &RHS) = delete;\n  DIE(DIE &&RHS) = delete;\n  DIE &operator=(const DIE &RHS) = delete;\n  DIE &operator=(const DIE &&RHS) = delete;\n\n  static DIE *get(BumpPtrAllocator &Alloc, dwarf::Tag Tag) {\n    return new (Alloc) DIE(Tag);\n  }\n\n  // Accessors.\n  unsigned getAbbrevNumber() const { return AbbrevNumber; }\n  dwarf::Tag getTag() const { return Tag; }\n  /// Get the compile/type unit relative offset of this DIE.\n  unsigned getOffset() const { return Offset; }\n  unsigned getSize() const { return Size; }\n  bool hasChildren() const { return ForceChildren || !Children.empty(); }\n  void setForceChildren(bool B) { ForceChildren = B; }\n\n  using child_iterator = IntrusiveBackList<DIE>::iterator;\n  using const_child_iterator = IntrusiveBackList<DIE>::const_iterator;\n  using child_range = iterator_range<child_iterator>;\n  using const_child_range = iterator_range<const_child_iterator>;\n\n  child_range children() {\n    return make_range(Children.begin(), Children.end());\n  }\n  const_child_range children() const {\n    return make_range(Children.begin(), Children.end());\n  }\n\n  DIE *getParent() const;\n\n  /// Generate the abbreviation for this DIE.\n  ///\n  /// Calculate the abbreviation for this, which should be uniqued and\n  /// eventually used to call \\a setAbbrevNumber().\n  DIEAbbrev generateAbbrev() const;\n\n  /// Set the abbreviation number for this DIE.\n  void setAbbrevNumber(unsigned I) { AbbrevNumber = I; }\n\n  /// Get the absolute offset within the .debug_info or .debug_types section\n  /// for this DIE.\n  uint64_t getDebugSectionOffset() const;\n\n  /// Compute the offset of this DIE and all its children.\n  ///\n  /// This function gets called just before we are going to generate the debug\n  /// information and gives each DIE a chance to figure out its CU relative DIE\n  /// offset, unique its abbreviation and fill in the abbreviation code, and\n  /// return the unit offset that points to where the next DIE will be emitted\n  /// within the debug unit section. After this function has been called for all\n  /// DIE objects, the DWARF can be generated since all DIEs will be able to\n  /// properly refer to other DIE objects since all DIEs have calculated their\n  /// offsets.\n  ///\n  /// \\param AP AsmPrinter to use when calculating sizes.\n  /// \\param AbbrevSet the abbreviation used to unique DIE abbreviations.\n  /// \\param CUOffset the compile/type unit relative offset in bytes.\n  /// \\returns the offset for the DIE that follows this DIE within the\n  /// current compile/type unit.\n  unsigned computeOffsetsAndAbbrevs(const AsmPrinter *AP,\n                                    DIEAbbrevSet &AbbrevSet, unsigned CUOffset);\n\n  /// Climb up the parent chain to get the compile unit or type unit DIE that\n  /// this DIE belongs to.\n  ///\n  /// \\returns the compile or type unit DIE that owns this DIE, or NULL if\n  /// this DIE hasn't been added to a unit DIE.\n  const DIE *getUnitDie() const;\n\n  /// Climb up the parent chain to get the compile unit or type unit that this\n  /// DIE belongs to.\n  ///\n  /// \\returns the DIEUnit that represents the compile or type unit that owns\n  /// this DIE, or NULL if this DIE hasn't been added to a unit DIE.\n  DIEUnit *getUnit() const;\n\n  void setOffset(unsigned O) { Offset = O; }\n  void setSize(unsigned S) { Size = S; }\n\n  /// Add a child to the DIE.\n  DIE &addChild(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_back(*Child);\n    return Children.back();\n  }\n\n  DIE &addChildFront(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_front(*Child);\n    return Children.front();\n  }\n\n  /// Find a value in the DIE with the attribute given.\n  ///\n  /// Returns a default-constructed DIEValue (where \\a DIEValue::getType()\n  /// gives \\a DIEValue::isNone) if no such attribute exists.\n  DIEValue findAttribute(dwarf::Attribute Attribute) const;\n\n  void print(raw_ostream &O, unsigned IndentCount = 0) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a compile or type unit.\nclass DIEUnit {\n  /// The compile unit or type unit DIE. This variable must be an instance of\n  /// DIE so that we can calculate the DIEUnit from any DIE by traversing the\n  /// parent backchain and getting the Unit DIE, and then casting itself to a\n  /// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without\n  /// having to store a pointer to the DIEUnit in each DIE instance.\n  DIE Die;\n  /// The section this unit will be emitted in. This may or may not be set to\n  /// a valid section depending on the client that is emitting DWARF.\n  MCSection *Section;\n  uint64_t Offset; /// .debug_info or .debug_types absolute section offset.\nprotected:\n  virtual ~DIEUnit() = default;\n\npublic:\n  explicit DIEUnit(dwarf::Tag UnitTag);\n  DIEUnit(const DIEUnit &RHS) = delete;\n  DIEUnit(DIEUnit &&RHS) = delete;\n  void operator=(const DIEUnit &RHS) = delete;\n  void operator=(const DIEUnit &&RHS) = delete;\n  /// Set the section that this DIEUnit will be emitted into.\n  ///\n  /// This function is used by some clients to set the section. Not all clients\n  /// that emit DWARF use this section variable.\n  void setSection(MCSection *Section) {\n    assert(!this->Section);\n    this->Section = Section;\n  }\n\n  virtual const MCSymbol *getCrossSectionRelativeBaseAddress() const {\n    return nullptr;\n  }\n\n  /// Return the section that this DIEUnit will be emitted into.\n  ///\n  /// \\returns Section pointer which can be NULL.\n  MCSection *getSection() const { return Section; }\n  void setDebugSectionOffset(uint64_t O) { Offset = O; }\n  uint64_t getDebugSectionOffset() const { return Offset; }\n  DIE &getUnitDie() { return Die; }\n  const DIE &getUnitDie() const { return Die; }\n};\n\nstruct BasicDIEUnit final : DIEUnit {\n  explicit BasicDIEUnit(dwarf::Tag UnitTag) : DIEUnit(UnitTag) {}\n};\n\n//===--------------------------------------------------------------------===//\n/// DIELoc - Represents an expression location.\n//\nclass DIELoc : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIELoc() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm(unsigned DwarfVersion) const {\n    if (DwarfVersion > 3)\n      return dwarf::DW_FORM_exprloc;\n    // Pre-DWARF4 location expressions were blocks and not exprloc.\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// DIEBlock - Represents a block of values.\n//\nclass DIEBlock : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIEBlock() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm() const {\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_DIE_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "content": "//===- llvm/CodeGen/MachineFunction.h ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Collect native machine code for a function.  This class contains a list of\n// MachineBasicBlock instances that make up the current compiled function.\n//\n// This class also contains pointers to various classes which hold\n// target-specific information about the generated code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEFUNCTION_H\n#define LLVM_CODEGEN_MACHINEFUNCTION_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ArrayRecycler.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Recycler.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass BlockAddress;\nclass DataLayout;\nclass DebugLoc;\nstruct DenormalMode;\nclass DIExpression;\nclass DILocalVariable;\nclass DILocation;\nclass Function;\nclass GISelChangeObserver;\nclass GlobalValue;\nclass LLVMTargetMachine;\nclass MachineConstantPool;\nclass MachineFrameInfo;\nclass MachineFunction;\nclass MachineJumpTableInfo;\nclass MachineModuleInfo;\nclass MachineRegisterInfo;\nclass MCContext;\nclass MCInstrDesc;\nclass MCSymbol;\nclass MCSection;\nclass Pass;\nclass PseudoSourceValueManager;\nclass raw_ostream;\nclass SlotIndexes;\nclass StringRef;\nclass TargetRegisterClass;\nclass TargetSubtargetInfo;\nstruct WasmEHFuncInfo;\nstruct WinEHFuncInfo;\n\ntemplate <> struct ilist_alloc_traits<MachineBasicBlock> {\n  void deleteNode(MachineBasicBlock *MBB);\n};\n\ntemplate <> struct ilist_callback_traits<MachineBasicBlock> {\n  void addNodeToList(MachineBasicBlock* N);\n  void removeNodeFromList(MachineBasicBlock* N);\n\n  template <class Iterator>\n  void transferNodesFromList(ilist_callback_traits &OldList, Iterator, Iterator) {\n    assert(this == &OldList && \"never transfer MBBs between functions\");\n  }\n};\n\n/// MachineFunctionInfo - This class can be derived from and used by targets to\n/// hold private target-specific information for each MachineFunction.  Objects\n/// of type are accessed/created with MF::getInfo and destroyed when the\n/// MachineFunction is destroyed.\nstruct MachineFunctionInfo {\n  virtual ~MachineFunctionInfo();\n\n  /// Factory function: default behavior is to call new using the\n  /// supplied allocator.\n  ///\n  /// This function can be overridden in a derive class.\n  template<typename Ty>\n  static Ty *create(BumpPtrAllocator &Allocator, MachineFunction &MF) {\n    return new (Allocator.Allocate<Ty>()) Ty(MF);\n  }\n};\n\n/// Properties which a MachineFunction may have at a given point in time.\n/// Each of these has checking code in the MachineVerifier, and passes can\n/// require that a property be set.\nclass MachineFunctionProperties {\n  // Possible TODO: Allow targets to extend this (perhaps by allowing the\n  // constructor to specify the size of the bit vector)\n  // Possible TODO: Allow requiring the negative (e.g. VRegsAllocated could be\n  // stated as the negative of \"has vregs\"\n\npublic:\n  // The properties are stated in \"positive\" form; i.e. a pass could require\n  // that the property hold, but not that it does not hold.\n\n  // Property descriptions:\n  // IsSSA: True when the machine function is in SSA form and virtual registers\n  //  have a single def.\n  // NoPHIs: The machine function does not contain any PHI instruction.\n  // TracksLiveness: True when tracking register liveness accurately.\n  //  While this property is set, register liveness information in basic block\n  //  live-in lists and machine instruction operands (e.g. kill flags, implicit\n  //  defs) is accurate. This means it can be used to change the code in ways\n  //  that affect the values in registers, for example by the register\n  //  scavenger.\n  //  When this property is clear, liveness is no longer reliable.\n  // NoVRegs: The machine function does not use any virtual registers.\n  // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic\n  //  instructions have been legalized; i.e., all instructions are now one of:\n  //   - generic and always legal (e.g., COPY)\n  //   - target-specific\n  //   - legal pre-isel generic instructions.\n  // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic\n  //  virtual registers have been assigned to a register bank.\n  // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel\n  //  generic instructions have been eliminated; i.e., all instructions are now\n  //  target-specific or non-pre-isel generic instructions (e.g., COPY).\n  //  Since only pre-isel generic instructions can have generic virtual register\n  //  operands, this also means that all generic virtual registers have been\n  //  constrained to virtual registers (assigned to register classes) and that\n  //  all sizes attached to them have been eliminated.\n  // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it\n  //  means that tied-def have been rewritten to meet the RegConstraint.\n  enum class Property : unsigned {\n    IsSSA,\n    NoPHIs,\n    TracksLiveness,\n    NoVRegs,\n    FailedISel,\n    Legalized,\n    RegBankSelected,\n    Selected,\n    TiedOpsRewritten,\n    LastProperty = TiedOpsRewritten,\n  };\n\n  bool hasProperty(Property P) const {\n    return Properties[static_cast<unsigned>(P)];\n  }\n\n  MachineFunctionProperties &set(Property P) {\n    Properties.set(static_cast<unsigned>(P));\n    return *this;\n  }\n\n  MachineFunctionProperties &reset(Property P) {\n    Properties.reset(static_cast<unsigned>(P));\n    return *this;\n  }\n\n  /// Reset all the properties.\n  MachineFunctionProperties &reset() {\n    Properties.reset();\n    return *this;\n  }\n\n  MachineFunctionProperties &set(const MachineFunctionProperties &MFP) {\n    Properties |= MFP.Properties;\n    return *this;\n  }\n\n  MachineFunctionProperties &reset(const MachineFunctionProperties &MFP) {\n    Properties.reset(MFP.Properties);\n    return *this;\n  }\n\n  // Returns true if all properties set in V (i.e. required by a pass) are set\n  // in this.\n  bool verifyRequiredProperties(const MachineFunctionProperties &V) const {\n    return !V.Properties.test(Properties);\n  }\n\n  /// Print the MachineFunctionProperties in human-readable form.\n  void print(raw_ostream &OS) const;\n\nprivate:\n  BitVector Properties =\n      BitVector(static_cast<unsigned>(Property::LastProperty)+1);\n};\n\nstruct SEHHandler {\n  /// Filter or finally function. Null indicates a catch-all.\n  const Function *FilterOrFinally;\n\n  /// Address of block to recover at. Null for a finally handler.\n  const BlockAddress *RecoverBA;\n};\n\n/// This structure is used to retain landing pad info for the current function.\nstruct LandingPadInfo {\n  MachineBasicBlock *LandingPadBlock;      // Landing pad block.\n  SmallVector<MCSymbol *, 1> BeginLabels;  // Labels prior to invoke.\n  SmallVector<MCSymbol *, 1> EndLabels;    // Labels after invoke.\n  SmallVector<SEHHandler, 1> SEHHandlers;  // SEH handlers active at this lpad.\n  MCSymbol *LandingPadLabel = nullptr;     // Label at beginning of landing pad.\n  std::vector<int> TypeIds;                // List of type ids (filters negative).\n\n  explicit LandingPadInfo(MachineBasicBlock *MBB)\n      : LandingPadBlock(MBB) {}\n};\n\nclass MachineFunction {\n  Function &F;\n  const LLVMTargetMachine &Target;\n  const TargetSubtargetInfo *STI;\n  MCContext &Ctx;\n  MachineModuleInfo &MMI;\n\n  // RegInfo - Information about each register in use in the function.\n  MachineRegisterInfo *RegInfo;\n\n  // Used to keep track of target-specific per-machine function information for\n  // the target implementation.\n  MachineFunctionInfo *MFInfo;\n\n  // Keep track of objects allocated on the stack.\n  MachineFrameInfo *FrameInfo;\n\n  // Keep track of constants which are spilled to memory\n  MachineConstantPool *ConstantPool;\n\n  // Keep track of jump tables for switch instructions\n  MachineJumpTableInfo *JumpTableInfo;\n\n  // Keep track of the function section.\n  MCSection *Section = nullptr;\n\n  // Keeps track of Wasm exception handling related data. This will be null for\n  // functions that aren't using a wasm EH personality.\n  WasmEHFuncInfo *WasmEHInfo = nullptr;\n\n  // Keeps track of Windows exception handling related data. This will be null\n  // for functions that aren't using a funclet-based EH personality.\n  WinEHFuncInfo *WinEHInfo = nullptr;\n\n  // Function-level unique numbering for MachineBasicBlocks.  When a\n  // MachineBasicBlock is inserted into a MachineFunction is it automatically\n  // numbered and this vector keeps track of the mapping from ID's to MBB's.\n  std::vector<MachineBasicBlock*> MBBNumbering;\n\n  // Unary encoding of basic block symbols is used to reduce size of \".strtab\".\n  // Basic block number 'i' gets a prefix of length 'i'.  The ith character also\n  // denotes the type of basic block number 'i'.  Return blocks are marked with\n  // 'r', landing pads with 'l' and regular blocks with 'a'.\n  std::vector<char> BBSectionsSymbolPrefix;\n\n  // Pool-allocate MachineFunction-lifetime and IR objects.\n  BumpPtrAllocator Allocator;\n\n  // Allocation management for instructions in function.\n  Recycler<MachineInstr> InstructionRecycler;\n\n  // Allocation management for operand arrays on instructions.\n  ArrayRecycler<MachineOperand> OperandRecycler;\n\n  // Allocation management for basic blocks in function.\n  Recycler<MachineBasicBlock> BasicBlockRecycler;\n\n  // List of machine basic blocks in function\n  using BasicBlockListType = ilist<MachineBasicBlock>;\n  BasicBlockListType BasicBlocks;\n\n  /// FunctionNumber - This provides a unique ID for each function emitted in\n  /// this translation unit.\n  ///\n  unsigned FunctionNumber;\n\n  /// Alignment - The alignment of the function.\n  Align Alignment;\n\n  /// ExposesReturnsTwice - True if the function calls setjmp or related\n  /// functions with attribute \"returns twice\", but doesn't have\n  /// the attribute itself.\n  /// This is used to limit optimizations which cannot reason\n  /// about the control flow of such functions.\n  bool ExposesReturnsTwice = false;\n\n  /// True if the function includes any inline assembly.\n  bool HasInlineAsm = false;\n\n  /// True if any WinCFI instruction have been emitted in this function.\n  bool HasWinCFI = false;\n\n  /// Current high-level properties of the IR of the function (e.g. is in SSA\n  /// form or whether registers have been allocated)\n  MachineFunctionProperties Properties;\n\n  // Allocation management for pseudo source values.\n  std::unique_ptr<PseudoSourceValueManager> PSVManager;\n\n  /// List of moves done by a function's prolog.  Used to construct frame maps\n  /// by debug and exception handling consumers.\n  std::vector<MCCFIInstruction> FrameInstructions;\n\n  /// List of basic blocks immediately following calls to _setjmp. Used to\n  /// construct a table of valid longjmp targets for Windows Control Flow Guard.\n  std::vector<MCSymbol *> LongjmpTargets;\n\n  /// List of basic blocks that are the target of catchrets. Used to construct\n  /// a table of valid targets for Windows EHCont Guard.\n  std::vector<MCSymbol *> CatchretTargets;\n\n  /// \\name Exception Handling\n  /// \\{\n\n  /// List of LandingPadInfo describing the landing pad information.\n  std::vector<LandingPadInfo> LandingPads;\n\n  /// Map a landing pad's EH symbol to the call site indexes.\n  DenseMap<MCSymbol*, SmallVector<unsigned, 4>> LPadToCallSiteMap;\n\n  /// Map a landing pad to its index.\n  DenseMap<const MachineBasicBlock *, unsigned> WasmLPadToIndexMap;\n\n  /// Map of invoke call site index values to associated begin EH_LABEL.\n  DenseMap<MCSymbol*, unsigned> CallSiteMap;\n\n  /// CodeView label annotations.\n  std::vector<std::pair<MCSymbol *, MDNode *>> CodeViewAnnotations;\n\n  bool CallsEHReturn = false;\n  bool CallsUnwindInit = false;\n  bool HasEHCatchret = false;\n  bool HasEHScopes = false;\n  bool HasEHFunclets = false;\n\n  /// Section Type for basic blocks, only relevant with basic block sections.\n  BasicBlockSection BBSectionsType = BasicBlockSection::None;\n\n  /// List of C++ TypeInfo used.\n  std::vector<const GlobalValue *> TypeInfos;\n\n  /// List of typeids encoding filters used.\n  std::vector<unsigned> FilterIds;\n\n  /// List of the indices in FilterIds corresponding to filter terminators.\n  std::vector<unsigned> FilterEnds;\n\n  EHPersonality PersonalityTypeCache = EHPersonality::Unknown;\n\n  /// \\}\n\n  /// Clear all the members of this MachineFunction, but the ones used\n  /// to initialize again the MachineFunction.\n  /// More specifically, this deallocates all the dynamically allocated\n  /// objects and get rid of all the XXXInfo data structure, but keep\n  /// unchanged the references to Fn, Target, MMI, and FunctionNumber.\n  void clear();\n  /// Allocate and initialize the different members.\n  /// In particular, the XXXInfo data structure.\n  /// \\pre Fn, Target, MMI, and FunctionNumber are properly set.\n  void init();\n\npublic:\n  struct VariableDbgInfo {\n    const DILocalVariable *Var;\n    const DIExpression *Expr;\n    // The Slot can be negative for fixed stack objects.\n    int Slot;\n    const DILocation *Loc;\n\n    VariableDbgInfo(const DILocalVariable *Var, const DIExpression *Expr,\n                    int Slot, const DILocation *Loc)\n        : Var(Var), Expr(Expr), Slot(Slot), Loc(Loc) {}\n  };\n\n  class Delegate {\n    virtual void anchor();\n\n  public:\n    virtual ~Delegate() = default;\n    /// Callback after an insertion. This should not modify the MI directly.\n    virtual void MF_HandleInsertion(MachineInstr &MI) = 0;\n    /// Callback before a removal. This should not modify the MI directly.\n    virtual void MF_HandleRemoval(MachineInstr &MI) = 0;\n  };\n\n  /// Structure used to represent pair of argument number after call lowering\n  /// and register used to transfer that argument.\n  /// For now we support only cases when argument is transferred through one\n  /// register.\n  struct ArgRegPair {\n    Register Reg;\n    uint16_t ArgNo;\n    ArgRegPair(Register R, unsigned Arg) : Reg(R), ArgNo(Arg) {\n      assert(Arg < (1 << 16) && \"Arg out of range\");\n    }\n  };\n  /// Vector of call argument and its forwarding register.\n  using CallSiteInfo = SmallVector<ArgRegPair, 1>;\n  using CallSiteInfoImpl = SmallVectorImpl<ArgRegPair>;\n\nprivate:\n  Delegate *TheDelegate = nullptr;\n  GISelChangeObserver *Observer = nullptr;\n\n  using CallSiteInfoMap = DenseMap<const MachineInstr *, CallSiteInfo>;\n  /// Map a call instruction to call site arguments forwarding info.\n  CallSiteInfoMap CallSitesInfo;\n\n  /// A helper function that returns call site info for a give call\n  /// instruction if debug entry value support is enabled.\n  CallSiteInfoMap::iterator getCallSiteInfo(const MachineInstr *MI);\n\n  // Callbacks for insertion and removal.\n  void handleInsertion(MachineInstr &MI);\n  void handleRemoval(MachineInstr &MI);\n  friend struct ilist_traits<MachineInstr>;\n\npublic:\n  using VariableDbgInfoMapTy = SmallVector<VariableDbgInfo, 4>;\n  VariableDbgInfoMapTy VariableDbgInfos;\n\n  /// A count of how many instructions in the function have had numbers\n  /// assigned to them. Used for debug value tracking, to determine the\n  /// next instruction number.\n  unsigned DebugInstrNumberingCount = 0;\n\n  /// Set value of DebugInstrNumberingCount field. Avoid using this unless\n  /// you're deserializing this data.\n  void setDebugInstrNumberingCount(unsigned Num);\n\n  /// Pair of instruction number and operand number.\n  using DebugInstrOperandPair = std::pair<unsigned, unsigned>;\n\n  /// Substitution map: from one <inst,operand> pair to another. Used to\n  /// record changes in where a value is defined, so that debug variable\n  /// locations can find it later.\n  std::map<DebugInstrOperandPair, DebugInstrOperandPair>\n      DebugValueSubstitutions;\n\n  /// Create a substitution between one <instr,operand> value to a different,\n  /// new value.\n  void makeDebugValueSubstitution(DebugInstrOperandPair, DebugInstrOperandPair);\n\n  /// Create substitutions for any tracked values in \\p Old, to point at\n  /// \\p New. Needed when we re-create an instruction during optimization,\n  /// which has the same signature (i.e., def operands in the same place) but\n  /// a modified instruction type, flags, or otherwise. An example: X86 moves\n  /// are sometimes transformed into equivalent LEAs.\n  /// If the two instructions are not the same opcode, limit which operands to\n  /// examine for substitutions to the first N operands by setting\n  /// \\p MaxOperand.\n  void substituteDebugValuesForInst(const MachineInstr &Old, MachineInstr &New,\n                                    unsigned MaxOperand = UINT_MAX);\n\n  MachineFunction(Function &F, const LLVMTargetMachine &Target,\n                  const TargetSubtargetInfo &STI, unsigned FunctionNum,\n                  MachineModuleInfo &MMI);\n  MachineFunction(const MachineFunction &) = delete;\n  MachineFunction &operator=(const MachineFunction &) = delete;\n  ~MachineFunction();\n\n  /// Reset the instance as if it was just created.\n  void reset() {\n    clear();\n    init();\n  }\n\n  /// Reset the currently registered delegate - otherwise assert.\n  void resetDelegate(Delegate *delegate) {\n    assert(TheDelegate == delegate &&\n           \"Only the current delegate can perform reset!\");\n    TheDelegate = nullptr;\n  }\n\n  /// Set the delegate. resetDelegate must be called before attempting\n  /// to set.\n  void setDelegate(Delegate *delegate) {\n    assert(delegate && !TheDelegate &&\n           \"Attempted to set delegate to null, or to change it without \"\n           \"first resetting it!\");\n\n    TheDelegate = delegate;\n  }\n\n  void setObserver(GISelChangeObserver *O) { Observer = O; }\n\n  GISelChangeObserver *getObserver() const { return Observer; }\n\n  MachineModuleInfo &getMMI() const { return MMI; }\n  MCContext &getContext() const { return Ctx; }\n\n  /// Returns the Section this function belongs to.\n  MCSection *getSection() const { return Section; }\n\n  /// Indicates the Section this function belongs to.\n  void setSection(MCSection *S) { Section = S; }\n\n  PseudoSourceValueManager &getPSVManager() const { return *PSVManager; }\n\n  /// Return the DataLayout attached to the Module associated to this MF.\n  const DataLayout &getDataLayout() const;\n\n  /// Return the LLVM function that this machine code represents\n  Function &getFunction() { return F; }\n\n  /// Return the LLVM function that this machine code represents\n  const Function &getFunction() const { return F; }\n\n  /// getName - Return the name of the corresponding LLVM function.\n  StringRef getName() const;\n\n  /// getFunctionNumber - Return a unique ID for the current function.\n  unsigned getFunctionNumber() const { return FunctionNumber; }\n\n  /// Returns true if this function has basic block sections enabled.\n  bool hasBBSections() const {\n    return (BBSectionsType == BasicBlockSection::All ||\n            BBSectionsType == BasicBlockSection::List ||\n            BBSectionsType == BasicBlockSection::Preset);\n  }\n\n  /// Returns true if basic block labels are to be generated for this function.\n  bool hasBBLabels() const {\n    return BBSectionsType == BasicBlockSection::Labels;\n  }\n\n  void setBBSectionsType(BasicBlockSection V) { BBSectionsType = V; }\n\n  /// Assign IsBeginSection IsEndSection fields for basic blocks in this\n  /// function.\n  void assignBeginEndSections();\n\n  /// getTarget - Return the target machine this machine code is compiled with\n  const LLVMTargetMachine &getTarget() const { return Target; }\n\n  /// getSubtarget - Return the subtarget for which this machine code is being\n  /// compiled.\n  const TargetSubtargetInfo &getSubtarget() const { return *STI; }\n\n  /// getSubtarget - This method returns a pointer to the specified type of\n  /// TargetSubtargetInfo.  In debug builds, it verifies that the object being\n  /// returned is of the correct type.\n  template<typename STC> const STC &getSubtarget() const {\n    return *static_cast<const STC *>(STI);\n  }\n\n  /// getRegInfo - Return information about the registers currently in use.\n  MachineRegisterInfo &getRegInfo() { return *RegInfo; }\n  const MachineRegisterInfo &getRegInfo() const { return *RegInfo; }\n\n  /// getFrameInfo - Return the frame info object for the current function.\n  /// This object contains information about objects allocated on the stack\n  /// frame of the current function in an abstract way.\n  MachineFrameInfo &getFrameInfo() { return *FrameInfo; }\n  const MachineFrameInfo &getFrameInfo() const { return *FrameInfo; }\n\n  /// getJumpTableInfo - Return the jump table info object for the current\n  /// function.  This object contains information about jump tables in the\n  /// current function.  If the current function has no jump tables, this will\n  /// return null.\n  const MachineJumpTableInfo *getJumpTableInfo() const { return JumpTableInfo; }\n  MachineJumpTableInfo *getJumpTableInfo() { return JumpTableInfo; }\n\n  /// getOrCreateJumpTableInfo - Get the JumpTableInfo for this function, if it\n  /// does already exist, allocate one.\n  MachineJumpTableInfo *getOrCreateJumpTableInfo(unsigned JTEntryKind);\n\n  /// getConstantPool - Return the constant pool object for the current\n  /// function.\n  MachineConstantPool *getConstantPool() { return ConstantPool; }\n  const MachineConstantPool *getConstantPool() const { return ConstantPool; }\n\n  /// getWasmEHFuncInfo - Return information about how the current function uses\n  /// Wasm exception handling. Returns null for functions that don't use wasm\n  /// exception handling.\n  const WasmEHFuncInfo *getWasmEHFuncInfo() const { return WasmEHInfo; }\n  WasmEHFuncInfo *getWasmEHFuncInfo() { return WasmEHInfo; }\n\n  /// getWinEHFuncInfo - Return information about how the current function uses\n  /// Windows exception handling. Returns null for functions that don't use\n  /// funclets for exception handling.\n  const WinEHFuncInfo *getWinEHFuncInfo() const { return WinEHInfo; }\n  WinEHFuncInfo *getWinEHFuncInfo() { return WinEHInfo; }\n\n  /// getAlignment - Return the alignment of the function.\n  Align getAlignment() const { return Alignment; }\n\n  /// setAlignment - Set the alignment of the function.\n  void setAlignment(Align A) { Alignment = A; }\n\n  /// ensureAlignment - Make sure the function is at least A bytes aligned.\n  void ensureAlignment(Align A) {\n    if (Alignment < A)\n      Alignment = A;\n  }\n\n  /// exposesReturnsTwice - Returns true if the function calls setjmp or\n  /// any other similar functions with attribute \"returns twice\" without\n  /// having the attribute itself.\n  bool exposesReturnsTwice() const {\n    return ExposesReturnsTwice;\n  }\n\n  /// setCallsSetJmp - Set a flag that indicates if there's a call to\n  /// a \"returns twice\" function.\n  void setExposesReturnsTwice(bool B) {\n    ExposesReturnsTwice = B;\n  }\n\n  /// Returns true if the function contains any inline assembly.\n  bool hasInlineAsm() const {\n    return HasInlineAsm;\n  }\n\n  /// Set a flag that indicates that the function contains inline assembly.\n  void setHasInlineAsm(bool B) {\n    HasInlineAsm = B;\n  }\n\n  bool hasWinCFI() const {\n    return HasWinCFI;\n  }\n  void setHasWinCFI(bool v) { HasWinCFI = v; }\n\n  /// True if this function needs frame moves for debug or exceptions.\n  bool needsFrameMoves() const;\n\n  /// Get the function properties\n  const MachineFunctionProperties &getProperties() const { return Properties; }\n  MachineFunctionProperties &getProperties() { return Properties; }\n\n  /// getInfo - Keep track of various per-function pieces of information for\n  /// backends that would like to do so.\n  ///\n  template<typename Ty>\n  Ty *getInfo() {\n    if (!MFInfo)\n      MFInfo = Ty::template create<Ty>(Allocator, *this);\n    return static_cast<Ty*>(MFInfo);\n  }\n\n  template<typename Ty>\n  const Ty *getInfo() const {\n     return const_cast<MachineFunction*>(this)->getInfo<Ty>();\n  }\n\n  /// Returns the denormal handling type for the default rounding mode of the\n  /// function.\n  DenormalMode getDenormalMode(const fltSemantics &FPType) const;\n\n  /// getBlockNumbered - MachineBasicBlocks are automatically numbered when they\n  /// are inserted into the machine function.  The block number for a machine\n  /// basic block can be found by using the MBB::getNumber method, this method\n  /// provides the inverse mapping.\n  MachineBasicBlock *getBlockNumbered(unsigned N) const {\n    assert(N < MBBNumbering.size() && \"Illegal block number\");\n    assert(MBBNumbering[N] && \"Block was removed from the machine function!\");\n    return MBBNumbering[N];\n  }\n\n  /// Should we be emitting segmented stack stuff for the function\n  bool shouldSplitStack() const;\n\n  /// getNumBlockIDs - Return the number of MBB ID's allocated.\n  unsigned getNumBlockIDs() const { return (unsigned)MBBNumbering.size(); }\n\n  /// RenumberBlocks - This discards all of the MachineBasicBlock numbers and\n  /// recomputes them.  This guarantees that the MBB numbers are sequential,\n  /// dense, and match the ordering of the blocks within the function.  If a\n  /// specific MachineBasicBlock is specified, only that block and those after\n  /// it are renumbered.\n  void RenumberBlocks(MachineBasicBlock *MBBFrom = nullptr);\n\n  /// print - Print out the MachineFunction in a format suitable for debugging\n  /// to the specified stream.\n  void print(raw_ostream &OS, const SlotIndexes* = nullptr) const;\n\n  /// viewCFG - This function is meant for use from the debugger.  You can just\n  /// say 'call F->viewCFG()' and a ghostview window should pop up from the\n  /// program, displaying the CFG of the current function with the code for each\n  /// basic block inside.  This depends on there being a 'dot' and 'gv' program\n  /// in your path.\n  void viewCFG() const;\n\n  /// viewCFGOnly - This function is meant for use from the debugger.  It works\n  /// just like viewCFG, but it does not include the contents of basic blocks\n  /// into the nodes, just the label.  If you are only interested in the CFG\n  /// this can make the graph smaller.\n  ///\n  void viewCFGOnly() const;\n\n  /// dump - Print the current MachineFunction to cerr, useful for debugger use.\n  void dump() const;\n\n  /// Run the current MachineFunction through the machine code verifier, useful\n  /// for debugger use.\n  /// \\returns true if no problems were found.\n  bool verify(Pass *p = nullptr, const char *Banner = nullptr,\n              bool AbortOnError = true) const;\n\n  // Provide accessors for the MachineBasicBlock list...\n  using iterator = BasicBlockListType::iterator;\n  using const_iterator = BasicBlockListType::const_iterator;\n  using const_reverse_iterator = BasicBlockListType::const_reverse_iterator;\n  using reverse_iterator = BasicBlockListType::reverse_iterator;\n\n  /// Support for MachineBasicBlock::getNextNode().\n  static BasicBlockListType MachineFunction::*\n  getSublistAccess(MachineBasicBlock *) {\n    return &MachineFunction::BasicBlocks;\n  }\n\n  /// addLiveIn - Add the specified physical register as a live-in value and\n  /// create a corresponding virtual register for it.\n  Register addLiveIn(MCRegister PReg, const TargetRegisterClass *RC);\n\n  //===--------------------------------------------------------------------===//\n  // BasicBlock accessor functions.\n  //\n  iterator                 begin()       { return BasicBlocks.begin(); }\n  const_iterator           begin() const { return BasicBlocks.begin(); }\n  iterator                 end  ()       { return BasicBlocks.end();   }\n  const_iterator           end  () const { return BasicBlocks.end();   }\n\n  reverse_iterator        rbegin()       { return BasicBlocks.rbegin(); }\n  const_reverse_iterator  rbegin() const { return BasicBlocks.rbegin(); }\n  reverse_iterator        rend  ()       { return BasicBlocks.rend();   }\n  const_reverse_iterator  rend  () const { return BasicBlocks.rend();   }\n\n  unsigned                  size() const { return (unsigned)BasicBlocks.size();}\n  bool                     empty() const { return BasicBlocks.empty(); }\n  const MachineBasicBlock &front() const { return BasicBlocks.front(); }\n        MachineBasicBlock &front()       { return BasicBlocks.front(); }\n  const MachineBasicBlock & back() const { return BasicBlocks.back(); }\n        MachineBasicBlock & back()       { return BasicBlocks.back(); }\n\n  void push_back (MachineBasicBlock *MBB) { BasicBlocks.push_back (MBB); }\n  void push_front(MachineBasicBlock *MBB) { BasicBlocks.push_front(MBB); }\n  void insert(iterator MBBI, MachineBasicBlock *MBB) {\n    BasicBlocks.insert(MBBI, MBB);\n  }\n  void splice(iterator InsertPt, iterator MBBI) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBBI);\n  }\n  void splice(iterator InsertPt, MachineBasicBlock *MBB) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBB);\n  }\n  void splice(iterator InsertPt, iterator MBBI, iterator MBBE) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBBI, MBBE);\n  }\n\n  void remove(iterator MBBI) { BasicBlocks.remove(MBBI); }\n  void remove(MachineBasicBlock *MBBI) { BasicBlocks.remove(MBBI); }\n  void erase(iterator MBBI) { BasicBlocks.erase(MBBI); }\n  void erase(MachineBasicBlock *MBBI) { BasicBlocks.erase(MBBI); }\n\n  template <typename Comp>\n  void sort(Comp comp) {\n    BasicBlocks.sort(comp);\n  }\n\n  /// Return the number of \\p MachineInstrs in this \\p MachineFunction.\n  unsigned getInstructionCount() const {\n    unsigned InstrCount = 0;\n    for (const MachineBasicBlock &MBB : BasicBlocks)\n      InstrCount += MBB.size();\n    return InstrCount;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Internal functions used to automatically number MachineBasicBlocks\n\n  /// Adds the MBB to the internal numbering. Returns the unique number\n  /// assigned to the MBB.\n  unsigned addToMBBNumbering(MachineBasicBlock *MBB) {\n    MBBNumbering.push_back(MBB);\n    return (unsigned)MBBNumbering.size()-1;\n  }\n\n  /// removeFromMBBNumbering - Remove the specific machine basic block from our\n  /// tracker, this is only really to be used by the MachineBasicBlock\n  /// implementation.\n  void removeFromMBBNumbering(unsigned N) {\n    assert(N < MBBNumbering.size() && \"Illegal basic block #\");\n    MBBNumbering[N] = nullptr;\n  }\n\n  /// CreateMachineInstr - Allocate a new MachineInstr. Use this instead\n  /// of `new MachineInstr'.\n  MachineInstr *CreateMachineInstr(const MCInstrDesc &MCID, const DebugLoc &DL,\n                                   bool NoImplicit = false);\n\n  /// Create a new MachineInstr which is a copy of \\p Orig, identical in all\n  /// ways except the instruction has no parent, prev, or next. Bundling flags\n  /// are reset.\n  ///\n  /// Note: Clones a single instruction, not whole instruction bundles.\n  /// Does not perform target specific adjustments; consider using\n  /// TargetInstrInfo::duplicate() instead.\n  MachineInstr *CloneMachineInstr(const MachineInstr *Orig);\n\n  /// Clones instruction or the whole instruction bundle \\p Orig and insert\n  /// into \\p MBB before \\p InsertBefore.\n  ///\n  /// Note: Does not perform target specific adjustments; consider using\n  /// TargetInstrInfo::duplicate() intead.\n  MachineInstr &CloneMachineInstrBundle(MachineBasicBlock &MBB,\n      MachineBasicBlock::iterator InsertBefore, const MachineInstr &Orig);\n\n  /// DeleteMachineInstr - Delete the given MachineInstr.\n  void DeleteMachineInstr(MachineInstr *MI);\n\n  /// CreateMachineBasicBlock - Allocate a new MachineBasicBlock. Use this\n  /// instead of `new MachineBasicBlock'.\n  MachineBasicBlock *CreateMachineBasicBlock(const BasicBlock *bb = nullptr);\n\n  /// DeleteMachineBasicBlock - Delete the given MachineBasicBlock.\n  void DeleteMachineBasicBlock(MachineBasicBlock *MBB);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(\n      MachinePointerInfo PtrInfo, MachineMemOperand::Flags f, uint64_t s,\n      Align base_alignment, const AAMDNodes &AAInfo = AAMDNodes(),\n      const MDNode *Ranges = nullptr, SyncScope::ID SSID = SyncScope::System,\n      AtomicOrdering Ordering = AtomicOrdering::NotAtomic,\n      AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand by copying\n  /// an existing one, adjusting by an offset and using the given size.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          int64_t Offset, uint64_t Size);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand by copying\n  /// an existing one, replacing only the MachinePointerInfo and size.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          MachinePointerInfo &PtrInfo,\n                                          uint64_t Size);\n\n  /// Allocate a new MachineMemOperand by copying an existing one,\n  /// replacing only AliasAnalysis information. MachineMemOperands are owned\n  /// by the MachineFunction and need not be explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          const AAMDNodes &AAInfo);\n\n  /// Allocate a new MachineMemOperand by copying an existing one,\n  /// replacing the flags. MachineMemOperands are owned\n  /// by the MachineFunction and need not be explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          MachineMemOperand::Flags Flags);\n\n  using OperandCapacity = ArrayRecycler<MachineOperand>::Capacity;\n\n  /// Allocate an array of MachineOperands. This is only intended for use by\n  /// internal MachineInstr functions.\n  MachineOperand *allocateOperandArray(OperandCapacity Cap) {\n    return OperandRecycler.allocate(Cap, Allocator);\n  }\n\n  /// Dellocate an array of MachineOperands and recycle the memory. This is\n  /// only intended for use by internal MachineInstr functions.\n  /// Cap must be the same capacity that was used to allocate the array.\n  void deallocateOperandArray(OperandCapacity Cap, MachineOperand *Array) {\n    OperandRecycler.deallocate(Cap, Array);\n  }\n\n  /// Allocate and initialize a register mask with @p NumRegister bits.\n  uint32_t *allocateRegMask();\n\n  ArrayRef<int> allocateShuffleMask(ArrayRef<int> Mask);\n\n  /// Allocate and construct an extra info structure for a `MachineInstr`.\n  ///\n  /// This is allocated on the function's allocator and so lives the life of\n  /// the function.\n  MachineInstr::ExtraInfo *createMIExtraInfo(\n      ArrayRef<MachineMemOperand *> MMOs, MCSymbol *PreInstrSymbol = nullptr,\n      MCSymbol *PostInstrSymbol = nullptr, MDNode *HeapAllocMarker = nullptr);\n\n  /// Allocate a string and populate it with the given external symbol name.\n  const char *createExternalSymbolName(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Label Manipulation.\n\n  /// getJTISymbol - Return the MCSymbol for the specified non-empty jump table.\n  /// If isLinkerPrivate is specified, an 'l' label is returned, otherwise a\n  /// normal 'L' label is returned.\n  MCSymbol *getJTISymbol(unsigned JTI, MCContext &Ctx,\n                         bool isLinkerPrivate = false) const;\n\n  /// getPICBaseSymbol - Return a function-local symbol to represent the PIC\n  /// base.\n  MCSymbol *getPICBaseSymbol() const;\n\n  /// Returns a reference to a list of cfi instructions in the function's\n  /// prologue.  Used to construct frame maps for debug and exception handling\n  /// comsumers.\n  const std::vector<MCCFIInstruction> &getFrameInstructions() const {\n    return FrameInstructions;\n  }\n\n  LLVM_NODISCARD unsigned addFrameInst(const MCCFIInstruction &Inst);\n\n  /// Returns a reference to a list of symbols immediately following calls to\n  /// _setjmp in the function. Used to construct the longjmp target table used\n  /// by Windows Control Flow Guard.\n  const std::vector<MCSymbol *> &getLongjmpTargets() const {\n    return LongjmpTargets;\n  }\n\n  /// Add the specified symbol to the list of valid longjmp targets for Windows\n  /// Control Flow Guard.\n  void addLongjmpTarget(MCSymbol *Target) { LongjmpTargets.push_back(Target); }\n\n  /// Returns a reference to a list of symbols that we have catchrets.\n  /// Used to construct the catchret target table used by Windows EHCont Guard.\n  const std::vector<MCSymbol *> &getCatchretTargets() const {\n    return CatchretTargets;\n  }\n\n  /// Add the specified symbol to the list of valid catchret targets for Windows\n  /// EHCont Guard.\n  void addCatchretTarget(MCSymbol *Target) {\n    CatchretTargets.push_back(Target);\n  }\n\n  /// \\name Exception Handling\n  /// \\{\n\n  bool callsEHReturn() const { return CallsEHReturn; }\n  void setCallsEHReturn(bool b) { CallsEHReturn = b; }\n\n  bool callsUnwindInit() const { return CallsUnwindInit; }\n  void setCallsUnwindInit(bool b) { CallsUnwindInit = b; }\n\n  bool hasEHCatchret() const { return HasEHCatchret; }\n  void setHasEHCatchret(bool V) { HasEHCatchret = V; }\n\n  bool hasEHScopes() const { return HasEHScopes; }\n  void setHasEHScopes(bool V) { HasEHScopes = V; }\n\n  bool hasEHFunclets() const { return HasEHFunclets; }\n  void setHasEHFunclets(bool V) { HasEHFunclets = V; }\n\n  /// Find or create an LandingPadInfo for the specified MachineBasicBlock.\n  LandingPadInfo &getOrCreateLandingPadInfo(MachineBasicBlock *LandingPad);\n\n  /// Remap landing pad labels and remove any deleted landing pads.\n  void tidyLandingPads(DenseMap<MCSymbol *, uintptr_t> *LPMap = nullptr,\n                       bool TidyIfNoBeginLabels = true);\n\n  /// Return a reference to the landing pad info for the current function.\n  const std::vector<LandingPadInfo> &getLandingPads() const {\n    return LandingPads;\n  }\n\n  /// Provide the begin and end labels of an invoke style call and associate it\n  /// with a try landing pad block.\n  void addInvoke(MachineBasicBlock *LandingPad,\n                 MCSymbol *BeginLabel, MCSymbol *EndLabel);\n\n  /// Add a new panding pad, and extract the exception handling information from\n  /// the landingpad instruction. Returns the label ID for the landing pad\n  /// entry.\n  MCSymbol *addLandingPad(MachineBasicBlock *LandingPad);\n\n  /// Provide the catch typeinfo for a landing pad.\n  void addCatchTypeInfo(MachineBasicBlock *LandingPad,\n                        ArrayRef<const GlobalValue *> TyInfo);\n\n  /// Provide the filter typeinfo for a landing pad.\n  void addFilterTypeInfo(MachineBasicBlock *LandingPad,\n                         ArrayRef<const GlobalValue *> TyInfo);\n\n  /// Add a cleanup action for a landing pad.\n  void addCleanup(MachineBasicBlock *LandingPad);\n\n  void addSEHCatchHandler(MachineBasicBlock *LandingPad, const Function *Filter,\n                          const BlockAddress *RecoverBA);\n\n  void addSEHCleanupHandler(MachineBasicBlock *LandingPad,\n                            const Function *Cleanup);\n\n  /// Return the type id for the specified typeinfo.  This is function wide.\n  unsigned getTypeIDFor(const GlobalValue *TI);\n\n  /// Return the id of the filter encoded by TyIds.  This is function wide.\n  int getFilterIDFor(std::vector<unsigned> &TyIds);\n\n  /// Map the landing pad's EH symbol to the call site indexes.\n  void setCallSiteLandingPad(MCSymbol *Sym, ArrayRef<unsigned> Sites);\n\n  /// Map the landing pad to its index. Used for Wasm exception handling.\n  void setWasmLandingPadIndex(const MachineBasicBlock *LPad, unsigned Index) {\n    WasmLPadToIndexMap[LPad] = Index;\n  }\n\n  /// Returns true if the landing pad has an associate index in wasm EH.\n  bool hasWasmLandingPadIndex(const MachineBasicBlock *LPad) const {\n    return WasmLPadToIndexMap.count(LPad);\n  }\n\n  /// Get the index in wasm EH for a given landing pad.\n  unsigned getWasmLandingPadIndex(const MachineBasicBlock *LPad) const {\n    assert(hasWasmLandingPadIndex(LPad));\n    return WasmLPadToIndexMap.lookup(LPad);\n  }\n\n  /// Get the call site indexes for a landing pad EH symbol.\n  SmallVectorImpl<unsigned> &getCallSiteLandingPad(MCSymbol *Sym) {\n    assert(hasCallSiteLandingPad(Sym) &&\n           \"missing call site number for landing pad!\");\n    return LPadToCallSiteMap[Sym];\n  }\n\n  /// Return true if the landing pad Eh symbol has an associated call site.\n  bool hasCallSiteLandingPad(MCSymbol *Sym) {\n    return !LPadToCallSiteMap[Sym].empty();\n  }\n\n  /// Map the begin label for a call site.\n  void setCallSiteBeginLabel(MCSymbol *BeginLabel, unsigned Site) {\n    CallSiteMap[BeginLabel] = Site;\n  }\n\n  /// Get the call site number for a begin label.\n  unsigned getCallSiteBeginLabel(MCSymbol *BeginLabel) const {\n    assert(hasCallSiteBeginLabel(BeginLabel) &&\n           \"Missing call site number for EH_LABEL!\");\n    return CallSiteMap.lookup(BeginLabel);\n  }\n\n  /// Return true if the begin label has a call site number associated with it.\n  bool hasCallSiteBeginLabel(MCSymbol *BeginLabel) const {\n    return CallSiteMap.count(BeginLabel);\n  }\n\n  /// Record annotations associated with a particular label.\n  void addCodeViewAnnotation(MCSymbol *Label, MDNode *MD) {\n    CodeViewAnnotations.push_back({Label, MD});\n  }\n\n  ArrayRef<std::pair<MCSymbol *, MDNode *>> getCodeViewAnnotations() const {\n    return CodeViewAnnotations;\n  }\n\n  /// Return a reference to the C++ typeinfo for the current function.\n  const std::vector<const GlobalValue *> &getTypeInfos() const {\n    return TypeInfos;\n  }\n\n  /// Return a reference to the typeids encoding filters used in the current\n  /// function.\n  const std::vector<unsigned> &getFilterIds() const {\n    return FilterIds;\n  }\n\n  /// \\}\n\n  /// Collect information used to emit debugging information of a variable.\n  void setVariableDbgInfo(const DILocalVariable *Var, const DIExpression *Expr,\n                          int Slot, const DILocation *Loc) {\n    VariableDbgInfos.emplace_back(Var, Expr, Slot, Loc);\n  }\n\n  VariableDbgInfoMapTy &getVariableDbgInfo() { return VariableDbgInfos; }\n  const VariableDbgInfoMapTy &getVariableDbgInfo() const {\n    return VariableDbgInfos;\n  }\n\n  /// Start tracking the arguments passed to the call \\p CallI.\n  void addCallArgsForwardingRegs(const MachineInstr *CallI,\n                                 CallSiteInfoImpl &&CallInfo) {\n    assert(CallI->isCandidateForCallSiteEntry());\n    bool Inserted =\n        CallSitesInfo.try_emplace(CallI, std::move(CallInfo)).second;\n    (void)Inserted;\n    assert(Inserted && \"Call site info not unique\");\n  }\n\n  const CallSiteInfoMap &getCallSitesInfo() const {\n    return CallSitesInfo;\n  }\n\n  /// Following functions update call site info. They should be called before\n  /// removing, replacing or copying call instruction.\n\n  /// Erase the call site info for \\p MI. It is used to remove a call\n  /// instruction from the instruction stream.\n  void eraseCallSiteInfo(const MachineInstr *MI);\n  /// Copy the call site info from \\p Old to \\ New. Its usage is when we are\n  /// making a copy of the instruction that will be inserted at different point\n  /// of the instruction stream.\n  void copyCallSiteInfo(const MachineInstr *Old,\n                        const MachineInstr *New);\n\n  const std::vector<char> &getBBSectionsSymbolPrefix() const {\n    return BBSectionsSymbolPrefix;\n  }\n\n  /// Move the call site info from \\p Old to \\New call site info. This function\n  /// is used when we are replacing one call instruction with another one to\n  /// the same callee.\n  void moveCallSiteInfo(const MachineInstr *Old,\n                        const MachineInstr *New);\n\n  unsigned getNewDebugInstrNum() {\n    return ++DebugInstrNumberingCount;\n  }\n};\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for function basic block graphs (CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a\n// machine function as a graph of machine basic blocks... these are\n// the same as the machine basic block iterators, except that the root\n// node is implicitly the first node of the function.\n//\ntemplate <> struct GraphTraits<MachineFunction*> :\n  public GraphTraits<MachineBasicBlock*> {\n  static NodeRef getEntryNode(MachineFunction *F) { return &F->front(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<MachineFunction::iterator>;\n\n  static nodes_iterator nodes_begin(MachineFunction *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end(MachineFunction *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static unsigned       size       (MachineFunction *F) { return F->size(); }\n};\ntemplate <> struct GraphTraits<const MachineFunction*> :\n  public GraphTraits<const MachineBasicBlock*> {\n  static NodeRef getEntryNode(const MachineFunction *F) { return &F->front(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<MachineFunction::const_iterator>;\n\n  static nodes_iterator nodes_begin(const MachineFunction *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end  (const MachineFunction *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static unsigned       size       (const MachineFunction *F)  {\n    return F->size();\n  }\n};\n\n// Provide specializations of GraphTraits to be able to treat a function as a\n// graph of basic blocks... and to walk it in inverse order.  Inverse order for\n// a function is considered to be when traversing the predecessor edges of a BB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<MachineFunction*>> :\n  public GraphTraits<Inverse<MachineBasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<MachineFunction *> G) {\n    return &G.Graph->front();\n  }\n};\ntemplate <> struct GraphTraits<Inverse<const MachineFunction*>> :\n  public GraphTraits<Inverse<const MachineBasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<const MachineFunction *> G) {\n    return &G.Graph->front();\n  }\n};\n\nclass MachineFunctionAnalysisManager;\nvoid verifyMachineFunction(MachineFunctionAnalysisManager *,\n                           const std::string &Banner,\n                           const MachineFunction &MF);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEFUNCTION_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "content": "//===- llvm/CodeGen/MachineInstrBundleIterator.h ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Defines an iterator class that bundles MachineInstr.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H\n#define LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H\n\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/simple_ilist.h\"\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n\nnamespace llvm {\n\ntemplate <class T, bool IsReverse> struct MachineInstrBundleIteratorTraits;\ntemplate <class T> struct MachineInstrBundleIteratorTraits<T, false> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::iterator;\n  using nonconst_instr_iterator = typename list_type::iterator;\n  using const_instr_iterator = typename list_type::const_iterator;\n};\ntemplate <class T> struct MachineInstrBundleIteratorTraits<T, true> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::reverse_iterator;\n  using nonconst_instr_iterator = typename list_type::reverse_iterator;\n  using const_instr_iterator = typename list_type::const_reverse_iterator;\n};\ntemplate <class T> struct MachineInstrBundleIteratorTraits<const T, false> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::const_iterator;\n  using nonconst_instr_iterator = typename list_type::iterator;\n  using const_instr_iterator = typename list_type::const_iterator;\n};\ntemplate <class T> struct MachineInstrBundleIteratorTraits<const T, true> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::const_reverse_iterator;\n  using nonconst_instr_iterator = typename list_type::reverse_iterator;\n  using const_instr_iterator = typename list_type::const_reverse_iterator;\n};\n\ntemplate <bool IsReverse> struct MachineInstrBundleIteratorHelper;\ntemplate <> struct MachineInstrBundleIteratorHelper<false> {\n  /// Get the beginning of the current bundle.\n  template <class Iterator> static Iterator getBundleBegin(Iterator I) {\n    if (!I.isEnd())\n      while (I->isBundledWithPred())\n        --I;\n    return I;\n  }\n\n  /// Get the final node of the current bundle.\n  template <class Iterator> static Iterator getBundleFinal(Iterator I) {\n    if (!I.isEnd())\n      while (I->isBundledWithSucc())\n        ++I;\n    return I;\n  }\n\n  /// Increment forward ilist iterator.\n  template <class Iterator> static void increment(Iterator &I) {\n    I = std::next(getBundleFinal(I));\n  }\n\n  /// Decrement forward ilist iterator.\n  template <class Iterator> static void decrement(Iterator &I) {\n    I = getBundleBegin(std::prev(I));\n  }\n};\n\ntemplate <> struct MachineInstrBundleIteratorHelper<true> {\n  /// Get the beginning of the current bundle.\n  template <class Iterator> static Iterator getBundleBegin(Iterator I) {\n    return MachineInstrBundleIteratorHelper<false>::getBundleBegin(\n               I.getReverse())\n        .getReverse();\n  }\n\n  /// Get the final node of the current bundle.\n  template <class Iterator> static Iterator getBundleFinal(Iterator I) {\n    return MachineInstrBundleIteratorHelper<false>::getBundleFinal(\n               I.getReverse())\n        .getReverse();\n  }\n\n  /// Increment reverse ilist iterator.\n  template <class Iterator> static void increment(Iterator &I) {\n    I = getBundleBegin(std::next(I));\n  }\n\n  /// Decrement reverse ilist iterator.\n  template <class Iterator> static void decrement(Iterator &I) {\n    I = std::prev(getBundleFinal(I));\n  }\n};\n\n/// MachineBasicBlock iterator that automatically skips over MIs that are\n/// inside bundles (i.e. walk top level MIs only).\ntemplate <typename Ty, bool IsReverse = false>\nclass MachineInstrBundleIterator : MachineInstrBundleIteratorHelper<IsReverse> {\n  using Traits = MachineInstrBundleIteratorTraits<Ty, IsReverse>;\n  using instr_iterator = typename Traits::instr_iterator;\n\n  instr_iterator MII;\n\npublic:\n  using value_type = typename instr_iterator::value_type;\n  using difference_type = typename instr_iterator::difference_type;\n  using pointer = typename instr_iterator::pointer;\n  using reference = typename instr_iterator::reference;\n  using const_pointer = typename instr_iterator::const_pointer;\n  using const_reference = typename instr_iterator::const_reference;\n  using iterator_category = std::bidirectional_iterator_tag;\n\nprivate:\n  using nonconst_instr_iterator = typename Traits::nonconst_instr_iterator;\n  using const_instr_iterator = typename Traits::const_instr_iterator;\n  using nonconst_iterator =\n      MachineInstrBundleIterator<typename nonconst_instr_iterator::value_type,\n                                 IsReverse>;\n  using reverse_iterator = MachineInstrBundleIterator<Ty, !IsReverse>;\n\npublic:\n  MachineInstrBundleIterator(instr_iterator MI) : MII(MI) {\n    assert((!MI.getNodePtr() || MI.isEnd() || !MI->isBundledWithPred()) &&\n           \"It's not legal to initialize MachineInstrBundleIterator with a \"\n           \"bundled MI\");\n  }\n\n  MachineInstrBundleIterator(reference MI) : MII(MI) {\n    assert(!MI.isBundledWithPred() && \"It's not legal to initialize \"\n                                      \"MachineInstrBundleIterator with a \"\n                                      \"bundled MI\");\n  }\n\n  MachineInstrBundleIterator(pointer MI) : MII(MI) {\n    // FIXME: This conversion should be explicit.\n    assert((!MI || !MI->isBundledWithPred()) && \"It's not legal to initialize \"\n                                                \"MachineInstrBundleIterator \"\n                                                \"with a bundled MI\");\n  }\n\n  // Template allows conversion from const to nonconst.\n  template <class OtherTy>\n  MachineInstrBundleIterator(\n      const MachineInstrBundleIterator<OtherTy, IsReverse> &I,\n      std::enable_if_t<std::is_convertible<OtherTy *, Ty *>::value, void *> =\n          nullptr)\n      : MII(I.getInstrIterator()) {}\n\n  MachineInstrBundleIterator() : MII(nullptr) {}\n\n  /// Explicit conversion between forward/reverse iterators.\n  ///\n  /// Translate between forward and reverse iterators without changing range\n  /// boundaries.  The resulting iterator will dereference (and have a handle)\n  /// to the previous node, which is somewhat unexpected; but converting the\n  /// two endpoints in a range will give the same range in reverse.\n  ///\n  /// This matches std::reverse_iterator conversions.\n  explicit MachineInstrBundleIterator(\n      const MachineInstrBundleIterator<Ty, !IsReverse> &I)\n      : MachineInstrBundleIterator(++I.getReverse()) {}\n\n  /// Get the bundle iterator for the given instruction's bundle.\n  static MachineInstrBundleIterator getAtBundleBegin(instr_iterator MI) {\n    return MachineInstrBundleIteratorHelper<IsReverse>::getBundleBegin(MI);\n  }\n\n  reference operator*() const { return *MII; }\n  pointer operator->() const { return &operator*(); }\n\n  /// Check for null.\n  bool isValid() const { return MII.getNodePtr(); }\n\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return L.MII == R.MII;\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const const_instr_iterator &R) {\n    return L.MII == R; // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const const_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return L == R.MII; // Avoid assertion about validity of L.\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const nonconst_instr_iterator &R) {\n    return L.MII == R; // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const nonconst_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return L == R.MII; // Avoid assertion about validity of L.\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L, const_pointer R) {\n    return L == const_instr_iterator(R); // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const_pointer L, const MachineInstrBundleIterator &R) {\n    return const_instr_iterator(L) == R; // Avoid assertion about validity of L.\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const_reference R) {\n    return L == &R; // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const_reference L,\n                         const MachineInstrBundleIterator &R) {\n    return &L == R; // Avoid assertion about validity of L.\n  }\n\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const const_instr_iterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const const_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const nonconst_instr_iterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const nonconst_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L, const_pointer R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const_pointer L, const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const_reference R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const_reference L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n\n  // Increment and decrement operators...\n  MachineInstrBundleIterator &operator--() {\n    this->decrement(MII);\n    return *this;\n  }\n  MachineInstrBundleIterator &operator++() {\n    this->increment(MII);\n    return *this;\n  }\n  MachineInstrBundleIterator operator--(int) {\n    MachineInstrBundleIterator Temp = *this;\n    --*this;\n    return Temp;\n  }\n  MachineInstrBundleIterator operator++(int) {\n    MachineInstrBundleIterator Temp = *this;\n    ++*this;\n    return Temp;\n  }\n\n  instr_iterator getInstrIterator() const { return MII; }\n\n  nonconst_iterator getNonConstIterator() const { return MII.getNonConst(); }\n\n  /// Get a reverse iterator to the same node.\n  ///\n  /// Gives a reverse iterator that will dereference (and have a handle) to the\n  /// same node.  Converting the endpoint iterators in a range will give a\n  /// different range; for range operations, use the explicit conversions.\n  reverse_iterator getReverse() const { return MII.getReverse(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "content": "//==- llvm/CodeGen/MachineMemOperand.h - MachineMemOperand class -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineMemOperand class, which is a\n// description of a memory reference. It is used to help track dependencies\n// in the backend.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEMEMOPERAND_H\n#define LLVM_CODEGEN_MACHINEMEMOPERAND_H\n\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/CodeGen/PseudoSourceValue.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Value.h\" // PointerLikeTypeTraits<Value*>\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/DataTypes.h\"\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\nclass MDNode;\nclass raw_ostream;\nclass MachineFunction;\nclass ModuleSlotTracker;\n\n/// This class contains a discriminated union of information about pointers in\n/// memory operands, relating them back to LLVM IR or to virtual locations (such\n/// as frame indices) that are exposed during codegen.\nstruct MachinePointerInfo {\n  /// This is the IR pointer value for the access, or it is null if unknown.\n  /// If this is null, then the access is to a pointer in the default address\n  /// space.\n  PointerUnion<const Value *, const PseudoSourceValue *> V;\n\n  /// Offset - This is an offset from the base Value*.\n  int64_t Offset;\n\n  uint8_t StackID;\n\n  unsigned AddrSpace = 0;\n\n  explicit MachinePointerInfo(const Value *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getType()->getPointerAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(const PseudoSourceValue *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(unsigned AddressSpace = 0, int64_t offset = 0)\n      : V((const Value *)nullptr), Offset(offset), StackID(0),\n        AddrSpace(AddressSpace) {}\n\n  explicit MachinePointerInfo(\n    PointerUnion<const Value *, const PseudoSourceValue *> v,\n    int64_t offset = 0,\n    uint8_t ID = 0)\n    : V(v), Offset(offset), StackID(ID) {\n    if (V) {\n      if (const auto *ValPtr = V.dyn_cast<const Value*>())\n        AddrSpace = ValPtr->getType()->getPointerAddressSpace();\n      else\n        AddrSpace = V.get<const PseudoSourceValue*>()->getAddressSpace();\n    }\n  }\n\n  MachinePointerInfo getWithOffset(int64_t O) const {\n    if (V.isNull())\n      return MachinePointerInfo(AddrSpace, Offset + O);\n    if (V.is<const Value*>())\n      return MachinePointerInfo(V.get<const Value*>(), Offset + O, StackID);\n    return MachinePointerInfo(V.get<const PseudoSourceValue*>(), Offset + O,\n                              StackID);\n  }\n\n  /// Return true if memory region [V, V+Offset+Size) is known to be\n  /// dereferenceable.\n  bool isDereferenceable(unsigned Size, LLVMContext &C,\n                         const DataLayout &DL) const;\n\n  /// Return the LLVM IR address space number that this pointer points into.\n  unsigned getAddrSpace() const;\n\n  /// Return a MachinePointerInfo record that refers to the constant pool.\n  static MachinePointerInfo getConstantPool(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to the specified\n  /// FrameIndex.\n  static MachinePointerInfo getFixedStack(MachineFunction &MF, int FI,\n                                          int64_t Offset = 0);\n\n  /// Return a MachinePointerInfo record that refers to a jump table entry.\n  static MachinePointerInfo getJumpTable(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to a GOT entry.\n  static MachinePointerInfo getGOT(MachineFunction &MF);\n\n  /// Stack pointer relative access.\n  static MachinePointerInfo getStack(MachineFunction &MF, int64_t Offset,\n                                     uint8_t ID = 0);\n\n  /// Stack memory without other information.\n  static MachinePointerInfo getUnknownStack(MachineFunction &MF);\n};\n\n\n//===----------------------------------------------------------------------===//\n/// A description of a memory reference used in the backend.\n/// Instead of holding a StoreInst or LoadInst, this class holds the address\n/// Value of the reference along with a byte size and offset. This allows it\n/// to describe lowered loads and stores. Also, the special PseudoSourceValue\n/// objects can be used to represent loads and stores to memory locations\n/// that aren't explicit in the regular LLVM IR.\n///\nclass MachineMemOperand {\npublic:\n  /// Flags values. These may be or'd together.\n  enum Flags : uint16_t {\n    // No flags set.\n    MONone = 0,\n    /// The memory access reads data.\n    MOLoad = 1u << 0,\n    /// The memory access writes data.\n    MOStore = 1u << 1,\n    /// The memory access is volatile.\n    MOVolatile = 1u << 2,\n    /// The memory access is non-temporal.\n    MONonTemporal = 1u << 3,\n    /// The memory access is dereferenceable (i.e., doesn't trap).\n    MODereferenceable = 1u << 4,\n    /// The memory access always returns the same value (or traps).\n    MOInvariant = 1u << 5,\n\n    // Reserved for use by target-specific passes.\n    // Targets may override getSerializableMachineMemOperandTargetFlags() to\n    // enable MIR serialization/parsing of these flags.  If more of these flags\n    // are added, the MIR printing/parsing code will need to be updated as well.\n    MOTargetFlag1 = 1u << 6,\n    MOTargetFlag2 = 1u << 7,\n    MOTargetFlag3 = 1u << 8,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/* LargestFlag = */ MOTargetFlag3)\n  };\n\nprivate:\n  /// Atomic information for this memory operation.\n  struct MachineAtomicInfo {\n    /// Synchronization scope ID for this memory operation.\n    unsigned SSID : 8;            // SyncScope::ID\n    /// Atomic ordering requirements for this memory operation. For cmpxchg\n    /// atomic operations, atomic ordering requirements when store occurs.\n    unsigned Ordering : 4;        // enum AtomicOrdering\n    /// For cmpxchg atomic operations, atomic ordering requirements when store\n    /// does not occur.\n    unsigned FailureOrdering : 4; // enum AtomicOrdering\n  };\n\n  MachinePointerInfo PtrInfo;\n  uint64_t Size;\n  Flags FlagVals;\n  Align BaseAlign;\n  MachineAtomicInfo AtomicInfo;\n  AAMDNodes AAInfo;\n  const MDNode *Ranges;\n\npublic:\n  /// Construct a MachineMemOperand object with the specified PtrInfo, flags,\n  /// size, and base alignment. For atomic operations the synchronization scope\n  /// and atomic ordering requirements must also be specified. For cmpxchg\n  /// atomic operations the atomic ordering requirements when store does not\n  /// occur must also be specified.\n  MachineMemOperand(MachinePointerInfo PtrInfo, Flags flags, uint64_t s,\n                    Align a, const AAMDNodes &AAInfo = AAMDNodes(),\n                    const MDNode *Ranges = nullptr,\n                    SyncScope::ID SSID = SyncScope::System,\n                    AtomicOrdering Ordering = AtomicOrdering::NotAtomic,\n                    AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);\n\n  const MachinePointerInfo &getPointerInfo() const { return PtrInfo; }\n\n  /// Return the base address of the memory access. This may either be a normal\n  /// LLVM IR Value, or one of the special values used in CodeGen.\n  /// Special values are those obtained via\n  /// PseudoSourceValue::getFixedStack(int), PseudoSourceValue::getStack, and\n  /// other PseudoSourceValue member functions which return objects which stand\n  /// for frame/stack pointer relative references and other special references\n  /// which are not representable in the high-level IR.\n  const Value *getValue() const { return PtrInfo.V.dyn_cast<const Value*>(); }\n\n  const PseudoSourceValue *getPseudoValue() const {\n    return PtrInfo.V.dyn_cast<const PseudoSourceValue*>();\n  }\n\n  const void *getOpaqueValue() const { return PtrInfo.V.getOpaqueValue(); }\n\n  /// Return the raw flags of the source value, \\see Flags.\n  Flags getFlags() const { return FlagVals; }\n\n  /// Bitwise OR the current flags with the given flags.\n  void setFlags(Flags f) { FlagVals |= f; }\n\n  /// For normal values, this is a byte offset added to the base address.\n  /// For PseudoSourceValue::FPRel values, this is the FrameIndex number.\n  int64_t getOffset() const { return PtrInfo.Offset; }\n\n  unsigned getAddrSpace() const { return PtrInfo.getAddrSpace(); }\n\n  /// Return the size in bytes of the memory reference.\n  uint64_t getSize() const { return Size; }\n\n  /// Return the size in bits of the memory reference.\n  uint64_t getSizeInBits() const { return Size * 8; }\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getAlignment() const,\n                            \"Use getAlign instead\");\n\n  /// Return the minimum known alignment in bytes of the actual memory\n  /// reference.\n  Align getAlign() const;\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getBaseAlignment() const,\n                            \"Use getBaseAlign instead\") {\n    return BaseAlign.value();\n  }\n\n  /// Return the minimum known alignment in bytes of the base address, without\n  /// the offset.\n  Align getBaseAlign() const { return BaseAlign; }\n\n  /// Return the AA tags for the memory reference.\n  AAMDNodes getAAInfo() const { return AAInfo; }\n\n  /// Return the range tag for the memory reference.\n  const MDNode *getRanges() const { return Ranges; }\n\n  /// Returns the synchronization scope ID for this memory operation.\n  SyncScope::ID getSyncScopeID() const {\n    return static_cast<SyncScope::ID>(AtomicInfo.SSID);\n  }\n\n  /// Return the atomic ordering requirements for this memory operation. For\n  /// cmpxchg atomic operations, return the atomic ordering requirements when\n  /// store occurs.\n  AtomicOrdering getOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.Ordering);\n  }\n\n  /// For cmpxchg atomic operations, return the atomic ordering requirements\n  /// when store does not occur.\n  AtomicOrdering getFailureOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.FailureOrdering);\n  }\n\n  bool isLoad() const { return FlagVals & MOLoad; }\n  bool isStore() const { return FlagVals & MOStore; }\n  bool isVolatile() const { return FlagVals & MOVolatile; }\n  bool isNonTemporal() const { return FlagVals & MONonTemporal; }\n  bool isDereferenceable() const { return FlagVals & MODereferenceable; }\n  bool isInvariant() const { return FlagVals & MOInvariant; }\n\n  /// Returns true if this operation has an atomic ordering requirement of\n  /// unordered or higher, false otherwise.\n  bool isAtomic() const { return getOrdering() != AtomicOrdering::NotAtomic; }\n\n  /// Returns true if this memory operation doesn't have any ordering\n  /// constraints other than normal aliasing. Volatile and (ordered) atomic\n  /// memory operations can't be reordered. \n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  /// Update this MachineMemOperand to reflect the alignment of MMO, if it has a\n  /// greater alignment. This must only be used when the new alignment applies\n  /// to all users of this MachineMemOperand.\n  void refineAlignment(const MachineMemOperand *MMO);\n\n  /// Change the SourceValue for this MachineMemOperand. This should only be\n  /// used when an object is being relocated and all references to it are being\n  /// updated.\n  void setValue(const Value *NewSV) { PtrInfo.V = NewSV; }\n  void setValue(const PseudoSourceValue *NewSV) { PtrInfo.V = NewSV; }\n  void setOffset(int64_t NewOffset) { PtrInfo.Offset = NewOffset; }\n\n  /// Profile - Gather unique data for the object.\n  ///\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Support for operator<<.\n  /// @{\n  void print(raw_ostream &OS, ModuleSlotTracker &MST,\n             SmallVectorImpl<StringRef> &SSNs, const LLVMContext &Context,\n             const MachineFrameInfo *MFI, const TargetInstrInfo *TII) const;\n  /// @}\n\n  friend bool operator==(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return LHS.getValue() == RHS.getValue() &&\n           LHS.getPseudoValue() == RHS.getPseudoValue() &&\n           LHS.getSize() == RHS.getSize() &&\n           LHS.getOffset() == RHS.getOffset() &&\n           LHS.getFlags() == RHS.getFlags() &&\n           LHS.getAAInfo() == RHS.getAAInfo() &&\n           LHS.getRanges() == RHS.getRanges() &&\n           LHS.getAlign() == RHS.getAlign() &&\n           LHS.getAddrSpace() == RHS.getAddrSpace();\n  }\n\n  friend bool operator!=(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h", "content": "//===-- llvm/CodeGen/MachineOperand.h - MachineOperand class ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineOperand class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEOPERAND_H\n#define LLVM_CODEGEN_MACHINEOPERAND_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/CodeGen/Register.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/LowLevelTypeImpl.h\"\n#include <cassert>\n\nnamespace llvm {\n\nclass BlockAddress;\nclass Constant;\nclass ConstantFP;\nclass ConstantInt;\nclass GlobalValue;\nclass MachineBasicBlock;\nclass MachineInstr;\nclass MachineRegisterInfo;\nclass MCCFIInstruction;\nclass MDNode;\nclass ModuleSlotTracker;\nclass TargetIntrinsicInfo;\nclass TargetRegisterInfo;\nclass hash_code;\nclass raw_ostream;\nclass MCSymbol;\n\n/// MachineOperand class - Representation of each machine instruction operand.\n///\n/// This class isn't a POD type because it has a private constructor, but its\n/// destructor must be trivial. Functions like MachineInstr::addOperand(),\n/// MachineRegisterInfo::moveOperands(), and MF::DeleteMachineInstr() depend on\n/// not having to call the MachineOperand destructor.\n///\nclass MachineOperand {\npublic:\n  enum MachineOperandType : unsigned char {\n    MO_Register,          ///< Register operand.\n    MO_Immediate,         ///< Immediate operand\n    MO_CImmediate,        ///< Immediate >64bit operand\n    MO_FPImmediate,       ///< Floating-point immediate operand\n    MO_MachineBasicBlock, ///< MachineBasicBlock reference\n    MO_FrameIndex,        ///< Abstract Stack Frame Index\n    MO_ConstantPoolIndex, ///< Address of indexed Constant in Constant Pool\n    MO_TargetIndex,       ///< Target-dependent index+offset operand.\n    MO_JumpTableIndex,    ///< Address of indexed Jump Table for switch\n    MO_ExternalSymbol,    ///< Name of external global symbol\n    MO_GlobalAddress,     ///< Address of a global value\n    MO_BlockAddress,      ///< Address of a basic block\n    MO_RegisterMask,      ///< Mask of preserved registers.\n    MO_RegisterLiveOut,   ///< Mask of live-out registers.\n    MO_Metadata,          ///< Metadata reference (for debug info)\n    MO_MCSymbol,          ///< MCSymbol reference (for debug/eh info)\n    MO_CFIIndex,          ///< MCCFIInstruction index.\n    MO_IntrinsicID,       ///< Intrinsic ID for ISel\n    MO_Predicate,         ///< Generic predicate for ISel\n    MO_ShuffleMask,       ///< Other IR Constant for ISel (shuffle masks)\n    MO_Last = MO_ShuffleMask\n  };\n\nprivate:\n  /// OpKind - Specify what kind of operand this is.  This discriminates the\n  /// union.\n  unsigned OpKind : 8;\n\n  /// Subregister number for MO_Register.  A value of 0 indicates the\n  /// MO_Register has no subReg.\n  ///\n  /// For all other kinds of operands, this field holds target-specific flags.\n  unsigned SubReg_TargetFlags : 12;\n\n  /// TiedTo - Non-zero when this register operand is tied to another register\n  /// operand. The encoding of this field is described in the block comment\n  /// before MachineInstr::tieOperands().\n  unsigned TiedTo : 4;\n\n  /// IsDef - True if this is a def, false if this is a use of the register.\n  /// This is only valid on register operands.\n  ///\n  unsigned IsDef : 1;\n\n  /// IsImp - True if this is an implicit def or use, false if it is explicit.\n  /// This is only valid on register opderands.\n  ///\n  unsigned IsImp : 1;\n\n  /// IsDeadOrKill\n  /// For uses: IsKill - True if this instruction is the last use of the\n  /// register on this path through the function.\n  /// For defs: IsDead - True if this register is never used by a subsequent\n  /// instruction.\n  /// This is only valid on register operands.\n  unsigned IsDeadOrKill : 1;\n\n  /// See isRenamable().\n  unsigned IsRenamable : 1;\n\n  /// IsUndef - True if this register operand reads an \"undef\" value, i.e. the\n  /// read value doesn't matter.  This flag can be set on both use and def\n  /// operands.  On a sub-register def operand, it refers to the part of the\n  /// register that isn't written.  On a full-register def operand, it is a\n  /// noop.  See readsReg().\n  ///\n  /// This is only valid on registers.\n  ///\n  /// Note that an instruction may have multiple <undef> operands referring to\n  /// the same register.  In that case, the instruction may depend on those\n  /// operands reading the same dont-care value.  For example:\n  ///\n  ///   %1 = XOR undef %2, undef %2\n  ///\n  /// Any register can be used for %2, and its value doesn't matter, but\n  /// the two operands must be the same register.\n  ///\n  unsigned IsUndef : 1;\n\n  /// IsInternalRead - True if this operand reads a value that was defined\n  /// inside the same instruction or bundle.  This flag can be set on both use\n  /// and def operands.  On a sub-register def operand, it refers to the part\n  /// of the register that isn't written.  On a full-register def operand, it\n  /// is a noop.\n  ///\n  /// When this flag is set, the instruction bundle must contain at least one\n  /// other def of the register.  If multiple instructions in the bundle define\n  /// the register, the meaning is target-defined.\n  unsigned IsInternalRead : 1;\n\n  /// IsEarlyClobber - True if this MO_Register 'def' operand is written to\n  /// by the MachineInstr before all input registers are read.  This is used to\n  /// model the GCC inline asm '&' constraint modifier.\n  unsigned IsEarlyClobber : 1;\n\n  /// IsDebug - True if this MO_Register 'use' operand is in a debug pseudo,\n  /// not a real instruction.  Such uses should be ignored during codegen.\n  unsigned IsDebug : 1;\n\n  /// SmallContents - This really should be part of the Contents union, but\n  /// lives out here so we can get a better packed struct.\n  /// MO_Register: Register number.\n  /// OffsetedInfo: Low bits of offset.\n  union {\n    unsigned RegNo;           // For MO_Register.\n    unsigned OffsetLo;        // Matches Contents.OffsetedInfo.OffsetHi.\n  } SmallContents;\n\n  /// ParentMI - This is the instruction that this operand is embedded into.\n  /// This is valid for all operand types, when the operand is in an instr.\n  MachineInstr *ParentMI;\n\n  /// Contents union - This contains the payload for the various operand types.\n  union ContentsUnion {\n    ContentsUnion() {}\n    MachineBasicBlock *MBB;  // For MO_MachineBasicBlock.\n    const ConstantFP *CFP;   // For MO_FPImmediate.\n    const ConstantInt *CI;   // For MO_CImmediate. Integers > 64bit.\n    int64_t ImmVal;          // For MO_Immediate.\n    const uint32_t *RegMask; // For MO_RegisterMask and MO_RegisterLiveOut.\n    const MDNode *MD;        // For MO_Metadata.\n    MCSymbol *Sym;           // For MO_MCSymbol.\n    unsigned CFIIndex;       // For MO_CFI.\n    Intrinsic::ID IntrinsicID; // For MO_IntrinsicID.\n    unsigned Pred;           // For MO_Predicate\n    ArrayRef<int> ShuffleMask; // For MO_ShuffleMask\n\n    struct {                  // For MO_Register.\n      // Register number is in SmallContents.RegNo.\n      MachineOperand *Prev;   // Access list for register. See MRI.\n      MachineOperand *Next;\n    } Reg;\n\n    /// OffsetedInfo - This struct contains the offset and an object identifier.\n    /// this represent the object as with an optional offset from it.\n    struct {\n      union {\n        int Index;                // For MO_*Index - The index itself.\n        const char *SymbolName;   // For MO_ExternalSymbol.\n        const GlobalValue *GV;    // For MO_GlobalAddress.\n        const BlockAddress *BA;   // For MO_BlockAddress.\n      } Val;\n      // Low bits of offset are in SmallContents.OffsetLo.\n      int OffsetHi;               // An offset from the object, high 32 bits.\n    } OffsetedInfo;\n  } Contents;\n\n  explicit MachineOperand(MachineOperandType K)\n    : OpKind(K), SubReg_TargetFlags(0), ParentMI(nullptr) {\n    // Assert that the layout is what we expect. It's easy to grow this object.\n    static_assert(alignof(MachineOperand) <= alignof(int64_t),\n                  \"MachineOperand shouldn't be more than 8 byte aligned\");\n    static_assert(sizeof(Contents) <= 2 * sizeof(void *),\n                  \"Contents should be at most two pointers\");\n    static_assert(sizeof(MachineOperand) <=\n                      alignTo<alignof(int64_t)>(2 * sizeof(unsigned) +\n                                                3 * sizeof(void *)),\n                  \"MachineOperand too big. Should be Kind, SmallContents, \"\n                  \"ParentMI, and Contents\");\n  }\n\npublic:\n  /// getType - Returns the MachineOperandType for this operand.\n  ///\n  MachineOperandType getType() const { return (MachineOperandType)OpKind; }\n\n  unsigned getTargetFlags() const {\n    return isReg() ? 0 : SubReg_TargetFlags;\n  }\n  void setTargetFlags(unsigned F) {\n    assert(!isReg() && \"Register operands can't have target flags\");\n    SubReg_TargetFlags = F;\n    assert(SubReg_TargetFlags == F && \"Target flags out of range\");\n  }\n  void addTargetFlag(unsigned F) {\n    assert(!isReg() && \"Register operands can't have target flags\");\n    SubReg_TargetFlags |= F;\n    assert((SubReg_TargetFlags & F) && \"Target flags out of range\");\n  }\n\n\n  /// getParent - Return the instruction that this operand belongs to.\n  ///\n  MachineInstr *getParent() { return ParentMI; }\n  const MachineInstr *getParent() const { return ParentMI; }\n\n  /// clearParent - Reset the parent pointer.\n  ///\n  /// The MachineOperand copy constructor also copies ParentMI, expecting the\n  /// original to be deleted. If a MachineOperand is ever stored outside a\n  /// MachineInstr, the parent pointer must be cleared.\n  ///\n  /// Never call clearParent() on an operand in a MachineInstr.\n  ///\n  void clearParent() { ParentMI = nullptr; }\n\n  /// Print a subreg index operand.\n  /// MO_Immediate operands can also be subreg idices. If it's the case, the\n  /// subreg index name will be printed. MachineInstr::isOperandSubregIdx can be\n  /// called to check this.\n  static void printSubRegIdx(raw_ostream &OS, uint64_t Index,\n                             const TargetRegisterInfo *TRI);\n\n  /// Print operand target flags.\n  static void printTargetFlags(raw_ostream& OS, const MachineOperand &Op);\n\n  /// Print a MCSymbol as an operand.\n  static void printSymbol(raw_ostream &OS, MCSymbol &Sym);\n\n  /// Print a stack object reference.\n  static void printStackObjectReference(raw_ostream &OS, unsigned FrameIndex,\n                                        bool IsFixed, StringRef Name);\n\n  /// Print the offset with explicit +/- signs.\n  static void printOperandOffset(raw_ostream &OS, int64_t Offset);\n\n  /// Print an IRSlotNumber.\n  static void printIRSlotNumber(raw_ostream &OS, int Slot);\n\n  /// Print the MachineOperand to \\p os.\n  /// Providing a valid \\p TRI and \\p IntrinsicInfo results in a more\n  /// target-specific printing. If \\p TRI and \\p IntrinsicInfo are null, the\n  /// function will try to pick it up from the parent.\n  void print(raw_ostream &os, const TargetRegisterInfo *TRI = nullptr,\n             const TargetIntrinsicInfo *IntrinsicInfo = nullptr) const;\n\n  /// More complex way of printing a MachineOperand.\n  /// \\param TypeToPrint specifies the generic type to be printed on uses and\n  /// defs. It can be determined using MachineInstr::getTypeToPrint.\n  /// \\param OpIdx - specifies the index of the operand in machine instruction.\n  /// This will be used by target dependent MIR formatter. Could be None if the\n  /// index is unknown, e.g. called by dump().\n  /// \\param PrintDef - whether we want to print `def` on an operand which\n  /// isDef. Sometimes, if the operand is printed before '=', we don't print\n  /// `def`.\n  /// \\param IsStandalone - whether we want a verbose output of the MO. This\n  /// prints extra information that can be easily inferred when printing the\n  /// whole function, but not when printing only a fragment of it.\n  /// \\param ShouldPrintRegisterTies - whether we want to print register ties.\n  /// Sometimes they are easily determined by the instruction's descriptor\n  /// (MachineInstr::hasComplexRegiterTies can determine if it's needed).\n  /// \\param TiedOperandIdx - if we need to print register ties this needs to\n  /// provide the index of the tied register. If not, it will be ignored.\n  /// \\param TRI - provide more target-specific information to the printer.\n  /// Unlike the previous function, this one will not try and get the\n  /// information from it's parent.\n  /// \\param IntrinsicInfo - same as \\p TRI.\n  void print(raw_ostream &os, ModuleSlotTracker &MST, LLT TypeToPrint,\n             Optional<unsigned> OpIdx, bool PrintDef, bool IsStandalone,\n             bool ShouldPrintRegisterTies, unsigned TiedOperandIdx,\n             const TargetRegisterInfo *TRI,\n             const TargetIntrinsicInfo *IntrinsicInfo) const;\n\n  /// Same as print(os, TRI, IntrinsicInfo), but allows to specify the low-level\n  /// type to be printed the same way the full version of print(...) does it.\n  void print(raw_ostream &os, LLT TypeToPrint,\n             const TargetRegisterInfo *TRI = nullptr,\n             const TargetIntrinsicInfo *IntrinsicInfo = nullptr) const;\n\n  void dump() const;\n\n  //===--------------------------------------------------------------------===//\n  // Accessors that tell you what kind of MachineOperand you're looking at.\n  //===--------------------------------------------------------------------===//\n\n  /// isReg - Tests if this is a MO_Register operand.\n  bool isReg() const { return OpKind == MO_Register; }\n  /// isImm - Tests if this is a MO_Immediate operand.\n  bool isImm() const { return OpKind == MO_Immediate; }\n  /// isCImm - Test if this is a MO_CImmediate operand.\n  bool isCImm() const { return OpKind == MO_CImmediate; }\n  /// isFPImm - Tests if this is a MO_FPImmediate operand.\n  bool isFPImm() const { return OpKind == MO_FPImmediate; }\n  /// isMBB - Tests if this is a MO_MachineBasicBlock operand.\n  bool isMBB() const { return OpKind == MO_MachineBasicBlock; }\n  /// isFI - Tests if this is a MO_FrameIndex operand.\n  bool isFI() const { return OpKind == MO_FrameIndex; }\n  /// isCPI - Tests if this is a MO_ConstantPoolIndex operand.\n  bool isCPI() const { return OpKind == MO_ConstantPoolIndex; }\n  /// isTargetIndex - Tests if this is a MO_TargetIndex operand.\n  bool isTargetIndex() const { return OpKind == MO_TargetIndex; }\n  /// isJTI - Tests if this is a MO_JumpTableIndex operand.\n  bool isJTI() const { return OpKind == MO_JumpTableIndex; }\n  /// isGlobal - Tests if this is a MO_GlobalAddress operand.\n  bool isGlobal() const { return OpKind == MO_GlobalAddress; }\n  /// isSymbol - Tests if this is a MO_ExternalSymbol operand.\n  bool isSymbol() const { return OpKind == MO_ExternalSymbol; }\n  /// isBlockAddress - Tests if this is a MO_BlockAddress operand.\n  bool isBlockAddress() const { return OpKind == MO_BlockAddress; }\n  /// isRegMask - Tests if this is a MO_RegisterMask operand.\n  bool isRegMask() const { return OpKind == MO_RegisterMask; }\n  /// isRegLiveOut - Tests if this is a MO_RegisterLiveOut operand.\n  bool isRegLiveOut() const { return OpKind == MO_RegisterLiveOut; }\n  /// isMetadata - Tests if this is a MO_Metadata operand.\n  bool isMetadata() const { return OpKind == MO_Metadata; }\n  bool isMCSymbol() const { return OpKind == MO_MCSymbol; }\n  bool isCFIIndex() const { return OpKind == MO_CFIIndex; }\n  bool isIntrinsicID() const { return OpKind == MO_IntrinsicID; }\n  bool isPredicate() const { return OpKind == MO_Predicate; }\n  bool isShuffleMask() const { return OpKind == MO_ShuffleMask; }\n  //===--------------------------------------------------------------------===//\n  // Accessors for Register Operands\n  //===--------------------------------------------------------------------===//\n\n  /// getReg - Returns the register number.\n  Register getReg() const {\n    assert(isReg() && \"This is not a register operand!\");\n    return Register(SmallContents.RegNo);\n  }\n\n  unsigned getSubReg() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return SubReg_TargetFlags;\n  }\n\n  bool isUse() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return !IsDef;\n  }\n\n  bool isDef() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDef;\n  }\n\n  bool isImplicit() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsImp;\n  }\n\n  bool isDead() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDeadOrKill & IsDef;\n  }\n\n  bool isKill() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDeadOrKill & !IsDef;\n  }\n\n  bool isUndef() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsUndef;\n  }\n\n  /// isRenamable - Returns true if this register may be renamed, i.e. it does\n  /// not generate a value that is somehow read in a way that is not represented\n  /// by the Machine IR (e.g. to meet an ABI or ISA requirement).  This is only\n  /// valid on physical register operands.  Virtual registers are assumed to\n  /// always be renamable regardless of the value of this field.\n  ///\n  /// Operands that are renamable can freely be changed to any other register\n  /// that is a member of the register class returned by\n  /// MI->getRegClassConstraint().\n  ///\n  /// isRenamable can return false for several different reasons:\n  ///\n  /// - ABI constraints (since liveness is not always precisely modeled).  We\n  ///   conservatively handle these cases by setting all physical register\n  ///   operands that didn\u2019t start out as virtual regs to not be renamable.\n  ///   Also any physical register operands created after register allocation or\n  ///   whose register is changed after register allocation will not be\n  ///   renamable.  This state is tracked in the MachineOperand::IsRenamable\n  ///   bit.\n  ///\n  /// - Opcode/target constraints: for opcodes that have complex register class\n  ///   requirements (e.g. that depend on other operands/instructions), we set\n  ///   hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq in the machine opcode\n  ///   description.  Operands belonging to instructions with opcodes that are\n  ///   marked hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq return false from\n  ///   isRenamable().  Additionally, the AllowRegisterRenaming target property\n  ///   prevents any operands from being marked renamable for targets that don't\n  ///   have detailed opcode hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq\n  ///   values.\n  bool isRenamable() const;\n\n  bool isInternalRead() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsInternalRead;\n  }\n\n  bool isEarlyClobber() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsEarlyClobber;\n  }\n\n  bool isTied() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return TiedTo;\n  }\n\n  bool isDebug() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return IsDebug;\n  }\n\n  /// readsReg - Returns true if this operand reads the previous value of its\n  /// register.  A use operand with the <undef> flag set doesn't read its\n  /// register.  A sub-register def implicitly reads the other parts of the\n  /// register being redefined unless the <undef> flag is set.\n  ///\n  /// This refers to reading the register value from before the current\n  /// instruction or bundle. Internal bundle reads are not included.\n  bool readsReg() const {\n    assert(isReg() && \"Wrong MachineOperand accessor\");\n    return !isUndef() && !isInternalRead() && (isUse() || getSubReg());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Mutators for Register Operands\n  //===--------------------------------------------------------------------===//\n\n  /// Change the register this operand corresponds to.\n  ///\n  void setReg(Register Reg);\n\n  void setSubReg(unsigned subReg) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    SubReg_TargetFlags = subReg;\n    assert(SubReg_TargetFlags == subReg && \"SubReg out of range\");\n  }\n\n  /// substVirtReg - Substitute the current register with the virtual\n  /// subregister Reg:SubReg. Take any existing SubReg index into account,\n  /// using TargetRegisterInfo to compose the subreg indices if necessary.\n  /// Reg must be a virtual register, SubIdx can be 0.\n  ///\n  void substVirtReg(Register Reg, unsigned SubIdx, const TargetRegisterInfo&);\n\n  /// substPhysReg - Substitute the current register with the physical register\n  /// Reg, taking any existing SubReg into account. For instance,\n  /// substPhysReg(%eax) will change %reg1024:sub_8bit to %al.\n  ///\n  void substPhysReg(MCRegister Reg, const TargetRegisterInfo&);\n\n  void setIsUse(bool Val = true) { setIsDef(!Val); }\n\n  /// Change a def to a use, or a use to a def.\n  void setIsDef(bool Val = true);\n\n  void setImplicit(bool Val = true) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    IsImp = Val;\n  }\n\n  void setIsKill(bool Val = true) {\n    assert(isReg() && !IsDef && \"Wrong MachineOperand mutator\");\n    assert((!Val || !isDebug()) && \"Marking a debug operation as kill\");\n    IsDeadOrKill = Val;\n  }\n\n  void setIsDead(bool Val = true) {\n    assert(isReg() && IsDef && \"Wrong MachineOperand mutator\");\n    IsDeadOrKill = Val;\n  }\n\n  void setIsUndef(bool Val = true) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    IsUndef = Val;\n  }\n\n  void setIsRenamable(bool Val = true);\n\n  void setIsInternalRead(bool Val = true) {\n    assert(isReg() && \"Wrong MachineOperand mutator\");\n    IsInternalRead = Val;\n  }\n\n  void setIsEarlyClobber(bool Val = true) {\n    assert(isReg() && IsDef && \"Wrong MachineOperand mutator\");\n    IsEarlyClobber = Val;\n  }\n\n  void setIsDebug(bool Val = true) {\n    assert(isReg() && !IsDef && \"Wrong MachineOperand mutator\");\n    IsDebug = Val;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Accessors for various operand types.\n  //===--------------------------------------------------------------------===//\n\n  int64_t getImm() const {\n    assert(isImm() && \"Wrong MachineOperand accessor\");\n    return Contents.ImmVal;\n  }\n\n  const ConstantInt *getCImm() const {\n    assert(isCImm() && \"Wrong MachineOperand accessor\");\n    return Contents.CI;\n  }\n\n  const ConstantFP *getFPImm() const {\n    assert(isFPImm() && \"Wrong MachineOperand accessor\");\n    return Contents.CFP;\n  }\n\n  MachineBasicBlock *getMBB() const {\n    assert(isMBB() && \"Wrong MachineOperand accessor\");\n    return Contents.MBB;\n  }\n\n  int getIndex() const {\n    assert((isFI() || isCPI() || isTargetIndex() || isJTI()) &&\n           \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.Index;\n  }\n\n  const GlobalValue *getGlobal() const {\n    assert(isGlobal() && \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.GV;\n  }\n\n  const BlockAddress *getBlockAddress() const {\n    assert(isBlockAddress() && \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.BA;\n  }\n\n  MCSymbol *getMCSymbol() const {\n    assert(isMCSymbol() && \"Wrong MachineOperand accessor\");\n    return Contents.Sym;\n  }\n\n  unsigned getCFIIndex() const {\n    assert(isCFIIndex() && \"Wrong MachineOperand accessor\");\n    return Contents.CFIIndex;\n  }\n\n  Intrinsic::ID getIntrinsicID() const {\n    assert(isIntrinsicID() && \"Wrong MachineOperand accessor\");\n    return Contents.IntrinsicID;\n  }\n\n  unsigned getPredicate() const {\n    assert(isPredicate() && \"Wrong MachineOperand accessor\");\n    return Contents.Pred;\n  }\n\n  ArrayRef<int> getShuffleMask() const {\n    assert(isShuffleMask() && \"Wrong MachineOperand accessor\");\n    return Contents.ShuffleMask;\n  }\n\n  /// Return the offset from the symbol in this operand. This always returns 0\n  /// for ExternalSymbol operands.\n  int64_t getOffset() const {\n    assert((isGlobal() || isSymbol() || isMCSymbol() || isCPI() ||\n            isTargetIndex() || isBlockAddress()) &&\n           \"Wrong MachineOperand accessor\");\n    return int64_t(uint64_t(Contents.OffsetedInfo.OffsetHi) << 32) |\n           SmallContents.OffsetLo;\n  }\n\n  const char *getSymbolName() const {\n    assert(isSymbol() && \"Wrong MachineOperand accessor\");\n    return Contents.OffsetedInfo.Val.SymbolName;\n  }\n\n  /// clobbersPhysReg - Returns true if this RegMask clobbers PhysReg.\n  /// It is sometimes necessary to detach the register mask pointer from its\n  /// machine operand. This static method can be used for such detached bit\n  /// mask pointers.\n  static bool clobbersPhysReg(const uint32_t *RegMask, MCRegister PhysReg) {\n    // See TargetRegisterInfo.h.\n    assert(PhysReg < (1u << 30) && \"Not a physical register\");\n    return !(RegMask[PhysReg / 32] & (1u << PhysReg % 32));\n  }\n\n  /// clobbersPhysReg - Returns true if this RegMask operand clobbers PhysReg.\n  bool clobbersPhysReg(MCRegister PhysReg) const {\n     return clobbersPhysReg(getRegMask(), PhysReg);\n  }\n\n  /// getRegMask - Returns a bit mask of registers preserved by this RegMask\n  /// operand.\n  const uint32_t *getRegMask() const {\n    assert(isRegMask() && \"Wrong MachineOperand accessor\");\n    return Contents.RegMask;\n  }\n\n  /// Returns number of elements needed for a regmask array.\n  static unsigned getRegMaskSize(unsigned NumRegs) {\n    return (NumRegs + 31) / 32;\n  }\n\n  /// getRegLiveOut - Returns a bit mask of live-out registers.\n  const uint32_t *getRegLiveOut() const {\n    assert(isRegLiveOut() && \"Wrong MachineOperand accessor\");\n    return Contents.RegMask;\n  }\n\n  const MDNode *getMetadata() const {\n    assert(isMetadata() && \"Wrong MachineOperand accessor\");\n    return Contents.MD;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Mutators for various operand types.\n  //===--------------------------------------------------------------------===//\n\n  void setImm(int64_t immVal) {\n    assert(isImm() && \"Wrong MachineOperand mutator\");\n    Contents.ImmVal = immVal;\n  }\n\n  void setCImm(const ConstantInt *CI) {\n    assert(isCImm() && \"Wrong MachineOperand mutator\");\n    Contents.CI = CI;\n  }\n\n  void setFPImm(const ConstantFP *CFP) {\n    assert(isFPImm() && \"Wrong MachineOperand mutator\");\n    Contents.CFP = CFP;\n  }\n\n  void setOffset(int64_t Offset) {\n    assert((isGlobal() || isSymbol() || isMCSymbol() || isCPI() ||\n            isTargetIndex() || isBlockAddress()) &&\n           \"Wrong MachineOperand mutator\");\n    SmallContents.OffsetLo = unsigned(Offset);\n    Contents.OffsetedInfo.OffsetHi = int(Offset >> 32);\n  }\n\n  void setIndex(int Idx) {\n    assert((isFI() || isCPI() || isTargetIndex() || isJTI()) &&\n           \"Wrong MachineOperand mutator\");\n    Contents.OffsetedInfo.Val.Index = Idx;\n  }\n\n  void setMetadata(const MDNode *MD) {\n    assert(isMetadata() && \"Wrong MachineOperand mutator\");\n    Contents.MD = MD;\n  }\n\n  void setMBB(MachineBasicBlock *MBB) {\n    assert(isMBB() && \"Wrong MachineOperand mutator\");\n    Contents.MBB = MBB;\n  }\n\n  /// Sets value of register mask operand referencing Mask.  The\n  /// operand does not take ownership of the memory referenced by Mask, it must\n  /// remain valid for the lifetime of the operand. See CreateRegMask().\n  /// Any physreg with a 0 bit in the mask is clobbered by the instruction.\n  void setRegMask(const uint32_t *RegMaskPtr) {\n    assert(isRegMask() && \"Wrong MachineOperand mutator\");\n    Contents.RegMask = RegMaskPtr;\n  }\n\n  void setIntrinsicID(Intrinsic::ID IID) {\n    assert(isIntrinsicID() && \"Wrong MachineOperand mutator\");\n    Contents.IntrinsicID = IID;\n  }\n\n  void setPredicate(unsigned Predicate) {\n    assert(isPredicate() && \"Wrong MachineOperand mutator\");\n    Contents.Pred = Predicate;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Other methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns true if this operand is identical to the specified operand except\n  /// for liveness related flags (isKill, isUndef and isDead). Note that this\n  /// should stay in sync with the hash_value overload below.\n  bool isIdenticalTo(const MachineOperand &Other) const;\n\n  /// MachineOperand hash_value overload.\n  ///\n  /// Note that this includes the same information in the hash that\n  /// isIdenticalTo uses for comparison. It is thus suited for use in hash\n  /// tables which use that function for equality comparisons only. This must\n  /// stay exactly in sync with isIdenticalTo above.\n  friend hash_code hash_value(const MachineOperand &MO);\n\n  /// ChangeToImmediate - Replace this operand with a new immediate operand of\n  /// the specified value.  If an operand is known to be an immediate already,\n  /// the setImm method should be used.\n  void ChangeToImmediate(int64_t ImmVal, unsigned TargetFlags = 0);\n\n  /// ChangeToFPImmediate - Replace this operand with a new FP immediate operand\n  /// of the specified value.  If an operand is known to be an FP immediate\n  /// already, the setFPImm method should be used.\n  void ChangeToFPImmediate(const ConstantFP *FPImm, unsigned TargetFlags = 0);\n\n  /// ChangeToES - Replace this operand with a new external symbol operand.\n  void ChangeToES(const char *SymName, unsigned TargetFlags = 0);\n\n  /// ChangeToGA - Replace this operand with a new global address operand.\n  void ChangeToGA(const GlobalValue *GV, int64_t Offset,\n                  unsigned TargetFlags = 0);\n\n  /// ChangeToMCSymbol - Replace this operand with a new MC symbol operand.\n  void ChangeToMCSymbol(MCSymbol *Sym, unsigned TargetFlags = 0);\n\n  /// Replace this operand with a frame index.\n  void ChangeToFrameIndex(int Idx, unsigned TargetFlags = 0);\n\n  /// Replace this operand with a target index.\n  void ChangeToTargetIndex(unsigned Idx, int64_t Offset,\n                           unsigned TargetFlags = 0);\n\n  /// ChangeToRegister - Replace this operand with a new register operand of\n  /// the specified value.  If an operand is known to be an register already,\n  /// the setReg method should be used.\n  void ChangeToRegister(Register Reg, bool isDef, bool isImp = false,\n                        bool isKill = false, bool isDead = false,\n                        bool isUndef = false, bool isDebug = false);\n\n  /// getTargetIndexName - If this MachineOperand is a TargetIndex that has a\n  /// name, attempt to get the name. Returns nullptr if the TargetIndex does not\n  /// have a name. Asserts if MO is not a TargetIndex.\n  const char *getTargetIndexName() const;\n\n  //===--------------------------------------------------------------------===//\n  // Construction methods.\n  //===--------------------------------------------------------------------===//\n\n  static MachineOperand CreateImm(int64_t Val) {\n    MachineOperand Op(MachineOperand::MO_Immediate);\n    Op.setImm(Val);\n    return Op;\n  }\n\n  static MachineOperand CreateCImm(const ConstantInt *CI) {\n    MachineOperand Op(MachineOperand::MO_CImmediate);\n    Op.Contents.CI = CI;\n    return Op;\n  }\n\n  static MachineOperand CreateFPImm(const ConstantFP *CFP) {\n    MachineOperand Op(MachineOperand::MO_FPImmediate);\n    Op.Contents.CFP = CFP;\n    return Op;\n  }\n\n  static MachineOperand CreateReg(Register Reg, bool isDef, bool isImp = false,\n                                  bool isKill = false, bool isDead = false,\n                                  bool isUndef = false,\n                                  bool isEarlyClobber = false,\n                                  unsigned SubReg = 0, bool isDebug = false,\n                                  bool isInternalRead = false,\n                                  bool isRenamable = false) {\n    assert(!(isDead && !isDef) && \"Dead flag on non-def\");\n    assert(!(isKill && isDef) && \"Kill flag on def\");\n    MachineOperand Op(MachineOperand::MO_Register);\n    Op.IsDef = isDef;\n    Op.IsImp = isImp;\n    Op.IsDeadOrKill = isKill | isDead;\n    Op.IsRenamable = isRenamable;\n    Op.IsUndef = isUndef;\n    Op.IsInternalRead = isInternalRead;\n    Op.IsEarlyClobber = isEarlyClobber;\n    Op.TiedTo = 0;\n    Op.IsDebug = isDebug;\n    Op.SmallContents.RegNo = Reg;\n    Op.Contents.Reg.Prev = nullptr;\n    Op.Contents.Reg.Next = nullptr;\n    Op.setSubReg(SubReg);\n    return Op;\n  }\n  static MachineOperand CreateMBB(MachineBasicBlock *MBB,\n                                  unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_MachineBasicBlock);\n    Op.setMBB(MBB);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateFI(int Idx) {\n    MachineOperand Op(MachineOperand::MO_FrameIndex);\n    Op.setIndex(Idx);\n    return Op;\n  }\n  static MachineOperand CreateCPI(unsigned Idx, int Offset,\n                                  unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_ConstantPoolIndex);\n    Op.setIndex(Idx);\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateTargetIndex(unsigned Idx, int64_t Offset,\n                                          unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_TargetIndex);\n    Op.setIndex(Idx);\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateJTI(unsigned Idx, unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_JumpTableIndex);\n    Op.setIndex(Idx);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateGA(const GlobalValue *GV, int64_t Offset,\n                                 unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_GlobalAddress);\n    Op.Contents.OffsetedInfo.Val.GV = GV;\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateES(const char *SymName,\n                                 unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_ExternalSymbol);\n    Op.Contents.OffsetedInfo.Val.SymbolName = SymName;\n    Op.setOffset(0); // Offset is always 0.\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  static MachineOperand CreateBA(const BlockAddress *BA, int64_t Offset,\n                                 unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_BlockAddress);\n    Op.Contents.OffsetedInfo.Val.BA = BA;\n    Op.setOffset(Offset);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n  /// CreateRegMask - Creates a register mask operand referencing Mask.  The\n  /// operand does not take ownership of the memory referenced by Mask, it\n  /// must remain valid for the lifetime of the operand.\n  ///\n  /// A RegMask operand represents a set of non-clobbered physical registers\n  /// on an instruction that clobbers many registers, typically a call.  The\n  /// bit mask has a bit set for each physreg that is preserved by this\n  /// instruction, as described in the documentation for\n  /// TargetRegisterInfo::getCallPreservedMask().\n  ///\n  /// Any physreg with a 0 bit in the mask is clobbered by the instruction.\n  ///\n  static MachineOperand CreateRegMask(const uint32_t *Mask) {\n    assert(Mask && \"Missing register mask\");\n    MachineOperand Op(MachineOperand::MO_RegisterMask);\n    Op.Contents.RegMask = Mask;\n    return Op;\n  }\n  static MachineOperand CreateRegLiveOut(const uint32_t *Mask) {\n    assert(Mask && \"Missing live-out register mask\");\n    MachineOperand Op(MachineOperand::MO_RegisterLiveOut);\n    Op.Contents.RegMask = Mask;\n    return Op;\n  }\n  static MachineOperand CreateMetadata(const MDNode *Meta) {\n    MachineOperand Op(MachineOperand::MO_Metadata);\n    Op.Contents.MD = Meta;\n    return Op;\n  }\n\n  static MachineOperand CreateMCSymbol(MCSymbol *Sym,\n                                       unsigned TargetFlags = 0) {\n    MachineOperand Op(MachineOperand::MO_MCSymbol);\n    Op.Contents.Sym = Sym;\n    Op.setOffset(0);\n    Op.setTargetFlags(TargetFlags);\n    return Op;\n  }\n\n  static MachineOperand CreateCFIIndex(unsigned CFIIndex) {\n    MachineOperand Op(MachineOperand::MO_CFIIndex);\n    Op.Contents.CFIIndex = CFIIndex;\n    return Op;\n  }\n\n  static MachineOperand CreateIntrinsicID(Intrinsic::ID ID) {\n    MachineOperand Op(MachineOperand::MO_IntrinsicID);\n    Op.Contents.IntrinsicID = ID;\n    return Op;\n  }\n\n  static MachineOperand CreatePredicate(unsigned Pred) {\n    MachineOperand Op(MachineOperand::MO_Predicate);\n    Op.Contents.Pred = Pred;\n    return Op;\n  }\n\n  static MachineOperand CreateShuffleMask(ArrayRef<int> Mask) {\n    MachineOperand Op(MachineOperand::MO_ShuffleMask);\n    Op.Contents.ShuffleMask = Mask;\n    return Op;\n  }\n\n  friend class MachineInstr;\n  friend class MachineRegisterInfo;\n\nprivate:\n  // If this operand is currently a register operand, and if this is in a\n  // function, deregister the operand from the register's use/def list.\n  void removeRegFromUses();\n\n  /// Artificial kinds for DenseMap usage.\n  enum : unsigned char {\n    MO_Empty = MO_Last + 1,\n    MO_Tombstone,\n  };\n\n  friend struct DenseMapInfo<MachineOperand>;\n\n  //===--------------------------------------------------------------------===//\n  // Methods for handling register use/def lists.\n  //===--------------------------------------------------------------------===//\n\n  /// isOnRegUseList - Return true if this operand is on a register use/def\n  /// list or false if not.  This can only be called for register operands\n  /// that are part of a machine instruction.\n  bool isOnRegUseList() const {\n    assert(isReg() && \"Can only add reg operand to use lists\");\n    return Contents.Reg.Prev != nullptr;\n  }\n};\n\ntemplate <> struct DenseMapInfo<MachineOperand> {\n  static MachineOperand getEmptyKey() {\n    return MachineOperand(static_cast<MachineOperand::MachineOperandType>(\n        MachineOperand::MO_Empty));\n  }\n  static MachineOperand getTombstoneKey() {\n    return MachineOperand(static_cast<MachineOperand::MachineOperandType>(\n        MachineOperand::MO_Tombstone));\n  }\n  static unsigned getHashValue(const MachineOperand &MO) {\n    return hash_value(MO);\n  }\n  static bool isEqual(const MachineOperand &LHS, const MachineOperand &RHS) {\n    if (LHS.getType() == static_cast<MachineOperand::MachineOperandType>(\n                             MachineOperand::MO_Empty) ||\n        LHS.getType() == static_cast<MachineOperand::MachineOperandType>(\n                             MachineOperand::MO_Tombstone))\n      return LHS.getType() == RHS.getType();\n    return LHS.isIdenticalTo(RHS);\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const MachineOperand &MO) {\n  MO.print(OS);\n  return OS;\n}\n\n// See friend declaration above. This additional declaration is required in\n// order to compile LLVM with IBM xlC compiler.\nhash_code hash_value(const MachineOperand &MO);\n} // namespace llvm\n\n#endif\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h", "content": "//===- llvm/CodeGen/MachinePassRegistry.h -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the mechanics for machine function pass registries.  A\n// function pass registry (MachinePassRegistry) is auto filled by the static\n// constructors of MachinePassRegistryNode.  Further there is a command line\n// parser (RegisterPassParser) which listens to each registry for additions\n// and deletions, so that the appropriate command option is updated.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEPASSREGISTRY_H\n#define LLVM_CODEGEN_MACHINEPASSREGISTRY_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/CodeGen/Passes.h\"\n#include \"llvm/Support/CommandLine.h\"\n\nnamespace llvm {\n\n//===----------------------------------------------------------------------===//\n///\n/// MachinePassRegistryListener - Listener to adds and removals of nodes in\n/// registration list.\n///\n//===----------------------------------------------------------------------===//\ntemplate <class PassCtorTy> class MachinePassRegistryListener {\n  virtual void anchor() {}\n\npublic:\n  MachinePassRegistryListener() = default;\n  virtual ~MachinePassRegistryListener() = default;\n\n  virtual void NotifyAdd(StringRef N, PassCtorTy C, StringRef D) = 0;\n  virtual void NotifyRemove(StringRef N) = 0;\n};\n\n//===----------------------------------------------------------------------===//\n///\n/// MachinePassRegistryNode - Machine pass node stored in registration list.\n///\n//===----------------------------------------------------------------------===//\ntemplate <typename PassCtorTy> class MachinePassRegistryNode {\nprivate:\n  MachinePassRegistryNode *Next = nullptr; // Next function pass in list.\n  StringRef Name;                       // Name of function pass.\n  StringRef Description;                // Description string.\n  PassCtorTy Ctor;                      // Pass creator.\n\npublic:\n  MachinePassRegistryNode(const char *N, const char *D, PassCtorTy C)\n      : Name(N), Description(D), Ctor(C) {}\n\n  // Accessors\n  MachinePassRegistryNode *getNext()      const { return Next; }\n  MachinePassRegistryNode **getNextAddress()    { return &Next; }\n  StringRef getName()                   const { return Name; }\n  StringRef getDescription()            const { return Description; }\n  PassCtorTy getCtor() const { return Ctor; }\n  void setNext(MachinePassRegistryNode *N)      { Next = N; }\n};\n\n//===----------------------------------------------------------------------===//\n///\n/// MachinePassRegistry - Track the registration of machine passes.\n///\n//===----------------------------------------------------------------------===//\ntemplate <typename PassCtorTy> class MachinePassRegistry {\nprivate:\n  MachinePassRegistryNode<PassCtorTy> *List; // List of registry nodes.\n  PassCtorTy Default;                        // Default function pass creator.\n  MachinePassRegistryListener<PassCtorTy>\n      *Listener; // Listener for list adds are removes.\n\npublic:\n  // NO CONSTRUCTOR - we don't want static constructor ordering to mess\n  // with the registry.\n\n  // Accessors.\n  //\n  MachinePassRegistryNode<PassCtorTy> *getList() { return List; }\n  PassCtorTy getDefault() { return Default; }\n  void setDefault(PassCtorTy C) { Default = C; }\n  /// setDefault - Set the default constructor by name.\n  void setDefault(StringRef Name) {\n    PassCtorTy Ctor = nullptr;\n    for (MachinePassRegistryNode<PassCtorTy> *R = getList(); R;\n         R = R->getNext()) {\n      if (R->getName() == Name) {\n        Ctor = R->getCtor();\n        break;\n      }\n    }\n    assert(Ctor && \"Unregistered pass name\");\n    setDefault(Ctor);\n  }\n  void setListener(MachinePassRegistryListener<PassCtorTy> *L) { Listener = L; }\n\n  /// Add - Adds a function pass to the registration list.\n  ///\n  void Add(MachinePassRegistryNode<PassCtorTy> *Node) {\n    Node->setNext(List);\n    List = Node;\n    if (Listener)\n      Listener->NotifyAdd(Node->getName(), Node->getCtor(),\n                          Node->getDescription());\n  }\n\n  /// Remove - Removes a function pass from the registration list.\n  ///\n  void Remove(MachinePassRegistryNode<PassCtorTy> *Node) {\n    for (MachinePassRegistryNode<PassCtorTy> **I = &List; *I;\n         I = (*I)->getNextAddress()) {\n      if (*I == Node) {\n        if (Listener)\n          Listener->NotifyRemove(Node->getName());\n        *I = (*I)->getNext();\n        break;\n      }\n    }\n  }\n};\n\n//===----------------------------------------------------------------------===//\n///\n/// RegisterPassParser class - Handle the addition of new machine passes.\n///\n//===----------------------------------------------------------------------===//\ntemplate <class RegistryClass>\nclass RegisterPassParser\n    : public MachinePassRegistryListener<\n          typename RegistryClass::FunctionPassCtor>,\n      public cl::parser<typename RegistryClass::FunctionPassCtor> {\npublic:\n  RegisterPassParser(cl::Option &O)\n      : cl::parser<typename RegistryClass::FunctionPassCtor>(O) {}\n  ~RegisterPassParser() override { RegistryClass::setListener(nullptr); }\n\n  void initialize() {\n    cl::parser<typename RegistryClass::FunctionPassCtor>::initialize();\n\n    // Add existing passes to option.\n    for (RegistryClass *Node = RegistryClass::getList();\n         Node; Node = Node->getNext()) {\n      this->addLiteralOption(Node->getName(),\n                      (typename RegistryClass::FunctionPassCtor)Node->getCtor(),\n                             Node->getDescription());\n    }\n\n    // Make sure we listen for list changes.\n    RegistryClass::setListener(this);\n  }\n\n  // Implement the MachinePassRegistryListener callbacks.\n  void NotifyAdd(StringRef N, typename RegistryClass::FunctionPassCtor C,\n                 StringRef D) override {\n    this->addLiteralOption(N, C, D);\n  }\n  void NotifyRemove(StringRef N) override {\n    this->removeLiteralOption(N);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEPASSREGISTRY_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "content": "//===-- llvm/CodeGen/Register.h ---------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_REGISTER_H\n#define LLVM_CODEGEN_REGISTER_H\n\n#include \"llvm/MC/MCRegister.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// Wrapper class representing virtual and physical registers. Should be passed\n/// by value.\nclass Register {\n  unsigned Reg;\n\npublic:\n  constexpr Register(unsigned Val = 0): Reg(Val) {}\n  constexpr Register(MCRegister Val): Reg(Val) {}\n\n  // Register numbers can represent physical registers, virtual registers, and\n  // sometimes stack slots. The unsigned values are divided into these ranges:\n  //\n  //   0           Not a register, can be used as a sentinel.\n  //   [1;2^30)    Physical registers assigned by TableGen.\n  //   [2^30;2^31) Stack slots. (Rarely used.)\n  //   [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.\n  //\n  // Further sentinels can be allocated from the small negative integers.\n  // DenseMapInfo<unsigned> uses -1u and -2u.\n  static_assert(std::numeric_limits<decltype(Reg)>::max() >= 0xFFFFFFFF,\n                \"Reg isn't large enough to hold full range.\");\n\n  /// isStackSlot - Sometimes it is useful the be able to store a non-negative\n  /// frame index in a variable that normally holds a register. isStackSlot()\n  /// returns true if Reg is in the range used for stack slots.\n  ///\n  /// FIXME: remove in favor of member.\n  static bool isStackSlot(unsigned Reg) {\n    return MCRegister::isStackSlot(Reg);\n  }\n\n  /// Return true if this is a stack slot.\n  bool isStack() const { return MCRegister::isStackSlot(Reg); }\n\n  /// Compute the frame index from a register value representing a stack slot.\n  static int stackSlot2Index(Register Reg) {\n    assert(Reg.isStack() && \"Not a stack slot\");\n    return int(Reg - MCRegister::FirstStackSlot);\n  }\n\n  /// Convert a non-negative frame index to a stack slot register value.\n  static Register index2StackSlot(int FI) {\n    assert(FI >= 0 && \"Cannot hold a negative frame index.\");\n    return Register(FI + MCRegister::FirstStackSlot);\n  }\n\n  /// Return true if the specified register number is in\n  /// the physical register namespace.\n  static bool isPhysicalRegister(unsigned Reg) {\n    return MCRegister::isPhysicalRegister(Reg);\n  }\n\n  /// Return true if the specified register number is in\n  /// the virtual register namespace.\n  static bool isVirtualRegister(unsigned Reg) {\n    return Reg & MCRegister::VirtualRegFlag && !isStackSlot(Reg);\n  }\n\n  /// Convert a virtual register number to a 0-based index.\n  /// The first virtual register in a function will get the index 0.\n  static unsigned virtReg2Index(Register Reg) {\n    assert(isVirtualRegister(Reg) && \"Not a virtual register\");\n    return Reg & ~MCRegister::VirtualRegFlag;\n  }\n\n  /// Convert a 0-based index to a virtual register number.\n  /// This is the inverse operation of VirtReg2IndexFunctor below.\n  static Register index2VirtReg(unsigned Index) {\n    assert(Index < (1u << 31) && \"Index too large for virtual register range.\");\n    return Index | MCRegister::VirtualRegFlag;\n  }\n\n  /// Return true if the specified register number is in the virtual register\n  /// namespace.\n  bool isVirtual() const {\n    return isVirtualRegister(Reg);\n  }\n\n  /// Return true if the specified register number is in the physical register\n  /// namespace.\n  bool isPhysical() const {\n    return isPhysicalRegister(Reg);\n  }\n\n  /// Convert a virtual register number to a 0-based index. The first virtual\n  /// register in a function will get the index 0.\n  unsigned virtRegIndex() const {\n    return virtReg2Index(Reg);\n  }\n\n  constexpr operator unsigned() const {\n    return Reg;\n  }\n\n  unsigned id() const { return Reg; }\n\n  operator MCRegister() const {\n    return MCRegister(Reg);\n  }\n\n  /// Utility to check-convert this value to a MCRegister. The caller is\n  /// expected to have already validated that this Register is, indeed,\n  /// physical.\n  MCRegister asMCReg() const {\n    assert(Reg == MCRegister::NoRegister ||\n           MCRegister::isPhysicalRegister(Reg));\n    return MCRegister(Reg);\n  }\n\n  bool isValid() const { return Reg != MCRegister::NoRegister; }\n\n  /// Comparisons between register objects\n  bool operator==(const Register &Other) const { return Reg == Other.Reg; }\n  bool operator!=(const Register &Other) const { return Reg != Other.Reg; }\n  bool operator==(const MCRegister &Other) const { return Reg == Other.id(); }\n  bool operator!=(const MCRegister &Other) const { return Reg != Other.id(); }\n\n  /// Comparisons against register constants. E.g.\n  /// * R == AArch64::WZR\n  /// * R == 0\n  /// * R == VirtRegMap::NO_PHYS_REG\n  bool operator==(unsigned Other) const { return Reg == Other; }\n  bool operator!=(unsigned Other) const { return Reg != Other; }\n  bool operator==(int Other) const { return Reg == unsigned(Other); }\n  bool operator!=(int Other) const { return Reg != unsigned(Other); }\n  // MSVC requires that we explicitly declare these two as well.\n  bool operator==(MCPhysReg Other) const { return Reg == unsigned(Other); }\n  bool operator!=(MCPhysReg Other) const { return Reg != unsigned(Other); }\n};\n\n// Provide DenseMapInfo for Register\ntemplate<> struct DenseMapInfo<Register> {\n  static inline unsigned getEmptyKey() {\n    return DenseMapInfo<unsigned>::getEmptyKey();\n  }\n  static inline unsigned getTombstoneKey() {\n    return DenseMapInfo<unsigned>::getTombstoneKey();\n  }\n  static unsigned getHashValue(const Register &Val) {\n    return DenseMapInfo<unsigned>::getHashValue(Val.id());\n  }\n  static bool isEqual(const Register &LHS, const Register &RHS) {\n    return DenseMapInfo<unsigned>::isEqual(LHS.id(), RHS.id());\n  }\n};\n\n}\n\n#endif // LLVM_CODEGEN_REGISTER_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h", "content": "//===- llvm/CodeGen/TargetSubtargetInfo.h - Target Information --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes the subtarget options of a Target machine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_TARGETSUBTARGETINFO_H\n#define LLVM_CODEGEN_TARGETSUBTARGETINFO_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/CodeGen/PBQPRAConstraint.h\"\n#include \"llvm/CodeGen/ScheduleDAGMutation.h\"\n#include \"llvm/CodeGen/SchedulerRegistry.h\"\n#include \"llvm/MC/MCSubtargetInfo.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include <memory>\n#include <vector>\n\nnamespace llvm {\n\nclass CallLowering;\nclass InlineAsmLowering;\nclass InstrItineraryData;\nstruct InstrStage;\nclass InstructionSelector;\nclass LegalizerInfo;\nclass MachineInstr;\nstruct MachineSchedPolicy;\nstruct MCReadAdvanceEntry;\nstruct MCWriteLatencyEntry;\nstruct MCWriteProcResEntry;\nclass RegisterBankInfo;\nclass SDep;\nclass SelectionDAGTargetInfo;\nclass SUnit;\nclass TargetFrameLowering;\nclass TargetInstrInfo;\nclass TargetLowering;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\nclass TargetSchedModel;\nclass Triple;\n\n//===----------------------------------------------------------------------===//\n///\n/// TargetSubtargetInfo - Generic base class for all target subtargets.  All\n/// Target-specific options that control code generation and printing should\n/// be exposed through a TargetSubtargetInfo-derived class.\n///\nclass TargetSubtargetInfo : public MCSubtargetInfo {\nprotected: // Can only create subclasses...\n  TargetSubtargetInfo(const Triple &TT, StringRef CPU, StringRef TuneCPU,\n                      StringRef FS, ArrayRef<SubtargetFeatureKV> PF,\n                      ArrayRef<SubtargetSubTypeKV> PD,\n                      const MCWriteProcResEntry *WPR,\n                      const MCWriteLatencyEntry *WL,\n                      const MCReadAdvanceEntry *RA, const InstrStage *IS,\n                      const unsigned *OC, const unsigned *FP);\n\npublic:\n  // AntiDepBreakMode - Type of anti-dependence breaking that should\n  // be performed before post-RA scheduling.\n  using AntiDepBreakMode = enum { ANTIDEP_NONE, ANTIDEP_CRITICAL, ANTIDEP_ALL };\n  using RegClassVector = SmallVectorImpl<const TargetRegisterClass *>;\n\n  TargetSubtargetInfo() = delete;\n  TargetSubtargetInfo(const TargetSubtargetInfo &) = delete;\n  TargetSubtargetInfo &operator=(const TargetSubtargetInfo &) = delete;\n  ~TargetSubtargetInfo() override;\n\n  virtual bool isXRaySupported() const { return false; }\n\n  // Interfaces to the major aspects of target machine information:\n  //\n  // -- Instruction opcode and operand information\n  // -- Pipelines and scheduling information\n  // -- Stack frame information\n  // -- Selection DAG lowering information\n  // -- Call lowering information\n  //\n  // N.B. These objects may change during compilation. It's not safe to cache\n  // them between functions.\n  virtual const TargetInstrInfo *getInstrInfo() const { return nullptr; }\n  virtual const TargetFrameLowering *getFrameLowering() const {\n    return nullptr;\n  }\n  virtual const TargetLowering *getTargetLowering() const { return nullptr; }\n  virtual const SelectionDAGTargetInfo *getSelectionDAGInfo() const {\n    return nullptr;\n  }\n  virtual const CallLowering *getCallLowering() const { return nullptr; }\n\n  virtual const InlineAsmLowering *getInlineAsmLowering() const {\n    return nullptr;\n  }\n\n  // FIXME: This lets targets specialize the selector by subtarget (which lets\n  // us do things like a dedicated avx512 selector).  However, we might want\n  // to also specialize selectors by MachineFunction, which would let us be\n  // aware of optsize/optnone and such.\n  virtual InstructionSelector *getInstructionSelector() const {\n    return nullptr;\n  }\n\n  /// Target can subclass this hook to select a different DAG scheduler.\n  virtual RegisterScheduler::FunctionPassCtor\n      getDAGScheduler(CodeGenOpt::Level) const {\n    return nullptr;\n  }\n\n  virtual const LegalizerInfo *getLegalizerInfo() const { return nullptr; }\n\n  /// getRegisterInfo - If register information is available, return it.  If\n  /// not, return null.\n  virtual const TargetRegisterInfo *getRegisterInfo() const { return nullptr; }\n\n  /// If the information for the register banks is available, return it.\n  /// Otherwise return nullptr.\n  virtual const RegisterBankInfo *getRegBankInfo() const { return nullptr; }\n\n  /// getInstrItineraryData - Returns instruction itinerary data for the target\n  /// or specific subtarget.\n  virtual const InstrItineraryData *getInstrItineraryData() const {\n    return nullptr;\n  }\n\n  /// Resolve a SchedClass at runtime, where SchedClass identifies an\n  /// MCSchedClassDesc with the isVariant property. This may return the ID of\n  /// another variant SchedClass, but repeated invocation must quickly terminate\n  /// in a nonvariant SchedClass.\n  virtual unsigned resolveSchedClass(unsigned SchedClass,\n                                     const MachineInstr *MI,\n                                     const TargetSchedModel *SchedModel) const {\n    return 0;\n  }\n\n  /// Returns true if MI is a dependency breaking zero-idiom instruction for the\n  /// subtarget.\n  ///\n  /// This function also sets bits in Mask related to input operands that\n  /// are not in a data dependency relationship.  There is one bit for each\n  /// machine operand; implicit operands follow explicit operands in the bit\n  /// representation used for Mask.  An empty (i.e. a mask with all bits\n  /// cleared) means: data dependencies are \"broken\" for all the explicit input\n  /// machine operands of MI.\n  virtual bool isZeroIdiom(const MachineInstr *MI, APInt &Mask) const {\n    return false;\n  }\n\n  /// Returns true if MI is a dependency breaking instruction for the subtarget.\n  ///\n  /// Similar in behavior to `isZeroIdiom`. However, it knows how to identify\n  /// all dependency breaking instructions (i.e. not just zero-idioms).\n  /// \n  /// As for `isZeroIdiom`, this method returns a mask of \"broken\" dependencies.\n  /// (See method `isZeroIdiom` for a detailed description of Mask).\n  virtual bool isDependencyBreaking(const MachineInstr *MI, APInt &Mask) const {\n    return isZeroIdiom(MI, Mask);\n  }\n\n  /// Returns true if MI is a candidate for move elimination.\n  ///\n  /// A candidate for move elimination may be optimized out at register renaming\n  /// stage. Subtargets can specify the set of optimizable moves by\n  /// instantiating tablegen class `IsOptimizableRegisterMove` (see\n  /// llvm/Target/TargetInstrPredicate.td).\n  ///\n  /// SubtargetEmitter is responsible for processing all the definitions of class\n  /// IsOptimizableRegisterMove, and auto-generate an override for this method.\n  virtual bool isOptimizableRegisterMove(const MachineInstr *MI) const {\n    return false;\n  }\n\n  /// True if the subtarget should run MachineScheduler after aggressive\n  /// coalescing.\n  ///\n  /// This currently replaces the SelectionDAG scheduler with the \"source\" order\n  /// scheduler (though see below for an option to turn this off and use the\n  /// TargetLowering preference). It does not yet disable the postRA scheduler.\n  virtual bool enableMachineScheduler() const;\n\n  /// True if the machine scheduler should disable the TLI preference\n  /// for preRA scheduling with the source level scheduler.\n  virtual bool enableMachineSchedDefaultSched() const { return true; }\n\n  /// True if the subtarget should run MachinePipeliner\n  virtual bool enableMachinePipeliner() const { return true; };\n\n  /// True if the subtarget should enable joining global copies.\n  ///\n  /// By default this is enabled if the machine scheduler is enabled, but\n  /// can be overridden.\n  virtual bool enableJoinGlobalCopies() const;\n\n  /// True if the subtarget should run a scheduler after register allocation.\n  ///\n  /// By default this queries the PostRAScheduling bit in the scheduling model\n  /// which is the preferred way to influence this.\n  virtual bool enablePostRAScheduler() const;\n\n  /// True if the subtarget should run a machine scheduler after register\n  /// allocation.\n  virtual bool enablePostRAMachineScheduler() const;\n\n  /// True if the subtarget should run the atomic expansion pass.\n  virtual bool enableAtomicExpand() const;\n\n  /// True if the subtarget should run the indirectbr expansion pass.\n  virtual bool enableIndirectBrExpand() const;\n\n  /// Override generic scheduling policy within a region.\n  ///\n  /// This is a convenient way for targets that don't provide any custom\n  /// scheduling heuristics (no custom MachineSchedStrategy) to make\n  /// changes to the generic scheduling policy.\n  virtual void overrideSchedPolicy(MachineSchedPolicy &Policy,\n                                   unsigned NumRegionInstrs) const {}\n\n  // Perform target-specific adjustments to the latency of a schedule\n  // dependency.\n  // If a pair of operands is associated with the schedule dependency, DefOpIdx\n  // and UseOpIdx are the indices of the operands in Def and Use, respectively.\n  // Otherwise, either may be -1.\n  virtual void adjustSchedDependency(SUnit *Def, int DefOpIdx, SUnit *Use,\n                                     int UseOpIdx, SDep &Dep) const {}\n\n  // For use with PostRAScheduling: get the anti-dependence breaking that should\n  // be performed before post-RA scheduling.\n  virtual AntiDepBreakMode getAntiDepBreakMode() const { return ANTIDEP_NONE; }\n\n  // For use with PostRAScheduling: in CriticalPathRCs, return any register\n  // classes that should only be considered for anti-dependence breaking if they\n  // are on the critical path.\n  virtual void getCriticalPathRCs(RegClassVector &CriticalPathRCs) const {\n    return CriticalPathRCs.clear();\n  }\n\n  // Provide an ordered list of schedule DAG mutations for the post-RA\n  // scheduler.\n  virtual void getPostRAMutations(\n      std::vector<std::unique_ptr<ScheduleDAGMutation>> &Mutations) const {\n  }\n\n  // Provide an ordered list of schedule DAG mutations for the machine\n  // pipeliner.\n  virtual void getSMSMutations(\n      std::vector<std::unique_ptr<ScheduleDAGMutation>> &Mutations) const {\n  }\n\n  /// Default to DFA for resource management, return false when target will use\n  /// ProcResource in InstrSchedModel instead.\n  virtual bool useDFAforSMS() const { return true; }\n\n  // For use with PostRAScheduling: get the minimum optimization level needed\n  // to enable post-RA scheduling.\n  virtual CodeGenOpt::Level getOptLevelToEnablePostRAScheduler() const {\n    return CodeGenOpt::Default;\n  }\n\n  /// True if the subtarget should run the local reassignment\n  /// heuristic of the register allocator.\n  /// This heuristic may be compile time intensive, \\p OptLevel provides\n  /// a finer grain to tune the register allocator.\n  virtual bool enableRALocalReassignment(CodeGenOpt::Level OptLevel) const;\n\n  /// True if the subtarget should consider the cost of local intervals\n  /// created by a split candidate when choosing the best split candidate. This\n  /// heuristic may be compile time intensive.\n  virtual bool enableAdvancedRASplitCost() const;\n\n  /// Enable use of alias analysis during code generation (during MI\n  /// scheduling, DAGCombine, etc.).\n  virtual bool useAA() const;\n\n  /// \\brief Sink addresses into blocks using GEP instructions rather than\n  /// pointer casts and arithmetic.\n  virtual bool addrSinkUsingGEPs() const {\n    return useAA();\n  }\n\n  /// Enable the use of the early if conversion pass.\n  virtual bool enableEarlyIfConversion() const { return false; }\n\n  /// Return PBQPConstraint(s) for the target.\n  ///\n  /// Override to provide custom PBQP constraints.\n  virtual std::unique_ptr<PBQPRAConstraint> getCustomPBQPConstraints() const {\n    return nullptr;\n  }\n\n  /// Enable tracking of subregister liveness in register allocator.\n  /// Please use MachineRegisterInfo::subRegLivenessEnabled() instead where\n  /// possible.\n  virtual bool enableSubRegLiveness() const { return false; }\n\n  /// This is called after a .mir file was loaded.\n  virtual void mirFileLoaded(MachineFunction &MF) const;\n\n  /// True if the register allocator should use the allocation orders exactly as\n  /// written in the tablegen descriptions, false if it should allocate\n  /// the specified physical register later if is it callee-saved.\n  virtual bool ignoreCSRForAllocationOrder(const MachineFunction &MF,\n                                           unsigned PhysReg) const {\n    return false;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_TARGETSUBTARGETINFO_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "content": "//===- llvm/BasicBlock.h - Represent a basic block in the VM ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the BasicBlock class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_BASICBLOCK_H\n#define LLVM_IR_BASICBLOCK_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/SymbolTableListTraits.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace llvm {\n\nclass AssemblyAnnotationWriter;\nclass CallInst;\nclass Function;\nclass LandingPadInst;\nclass LLVMContext;\nclass Module;\nclass PHINode;\nclass ValueSymbolTable;\n\n/// LLVM Basic Block Representation\n///\n/// This represents a single basic block in LLVM. A basic block is simply a\n/// container of instructions that execute sequentially. Basic blocks are Values\n/// because they are referenced by instructions such as branches and switch\n/// tables. The type of a BasicBlock is \"Type::LabelTy\" because the basic block\n/// represents a label to which a branch can jump.\n///\n/// A well formed basic block is formed of a list of non-terminating\n/// instructions followed by a single terminator instruction. Terminator\n/// instructions may not occur in the middle of basic blocks, and must terminate\n/// the blocks. The BasicBlock class allows malformed basic blocks to occur\n/// because it may be useful in the intermediate stage of constructing or\n/// modifying a program. However, the verifier will ensure that basic blocks are\n/// \"well formed\".\nclass BasicBlock final : public Value, // Basic blocks are data objects also\n                         public ilist_node_with_parent<BasicBlock, Function> {\npublic:\n  using InstListType = SymbolTableList<Instruction>;\n\nprivate:\n  friend class BlockAddress;\n  friend class SymbolTableListTraits<BasicBlock>;\n\n  InstListType InstList;\n  Function *Parent;\n\n  void setParent(Function *parent);\n\n  /// Constructor.\n  ///\n  /// If the function parameter is specified, the basic block is automatically\n  /// inserted at either the end of the function (if InsertBefore is null), or\n  /// before the specified basic block.\n  explicit BasicBlock(LLVMContext &C, const Twine &Name = \"\",\n                      Function *Parent = nullptr,\n                      BasicBlock *InsertBefore = nullptr);\n\npublic:\n  BasicBlock(const BasicBlock &) = delete;\n  BasicBlock &operator=(const BasicBlock &) = delete;\n  ~BasicBlock();\n\n  /// Get the context in which this basic block lives.\n  LLVMContext &getContext() const;\n\n  /// Instruction iterators...\n  using iterator = InstListType::iterator;\n  using const_iterator = InstListType::const_iterator;\n  using reverse_iterator = InstListType::reverse_iterator;\n  using const_reverse_iterator = InstListType::const_reverse_iterator;\n\n  /// Creates a new BasicBlock.\n  ///\n  /// If the Parent parameter is specified, the basic block is automatically\n  /// inserted at either the end of the function (if InsertBefore is 0), or\n  /// before the specified basic block.\n  static BasicBlock *Create(LLVMContext &Context, const Twine &Name = \"\",\n                            Function *Parent = nullptr,\n                            BasicBlock *InsertBefore = nullptr) {\n    return new BasicBlock(Context, Name, Parent, InsertBefore);\n  }\n\n  /// Return the enclosing method, or null if none.\n  const Function *getParent() const { return Parent; }\n        Function *getParent()       { return Parent; }\n\n  /// Return the module owning the function this basic block belongs to, or\n  /// nullptr if the function does not have a module.\n  ///\n  /// Note: this is undefined behavior if the block does not have a parent.\n  const Module *getModule() const;\n  Module *getModule() {\n    return const_cast<Module *>(\n                            static_cast<const BasicBlock *>(this)->getModule());\n  }\n\n  /// Returns the terminator instruction if the block is well formed or null\n  /// if the block is not well formed.\n  const Instruction *getTerminator() const LLVM_READONLY;\n  Instruction *getTerminator() {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getTerminator());\n  }\n\n  /// Returns the call instruction calling \\@llvm.experimental.deoptimize\n  /// prior to the terminating return instruction of this basic block, if such\n  /// a call is present.  Otherwise, returns null.\n  const CallInst *getTerminatingDeoptimizeCall() const;\n  CallInst *getTerminatingDeoptimizeCall() {\n    return const_cast<CallInst *>(\n         static_cast<const BasicBlock *>(this)->getTerminatingDeoptimizeCall());\n  }\n\n  /// Returns the call instruction calling \\@llvm.experimental.deoptimize\n  /// that is present either in current basic block or in block that is a unique\n  /// successor to current block, if such call is present. Otherwise, returns null.\n  const CallInst *getPostdominatingDeoptimizeCall() const;\n  CallInst *getPostdominatingDeoptimizeCall() {\n    return const_cast<CallInst *>(\n         static_cast<const BasicBlock *>(this)->getPostdominatingDeoptimizeCall());\n  }\n\n  /// Returns the call instruction marked 'musttail' prior to the terminating\n  /// return instruction of this basic block, if such a call is present.\n  /// Otherwise, returns null.\n  const CallInst *getTerminatingMustTailCall() const;\n  CallInst *getTerminatingMustTailCall() {\n    return const_cast<CallInst *>(\n           static_cast<const BasicBlock *>(this)->getTerminatingMustTailCall());\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode instruction.\n  ///\n  /// When adding instructions to the beginning of the basic block, they should\n  /// be added before the returned value, not before the first instruction,\n  /// which might be PHI. Returns 0 is there's no non-PHI instruction.\n  const Instruction* getFirstNonPHI() const;\n  Instruction* getFirstNonPHI() {\n    return const_cast<Instruction *>(\n                       static_cast<const BasicBlock *>(this)->getFirstNonPHI());\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode or a debug intrinsic, or any pseudo operation if \\c SkipPseudoOp\n  /// is true.\n  const Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = false) const;\n  Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = false) {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbg(\n            SkipPseudoOp));\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode, a debug intrinsic, or a lifetime intrinsic, or any pseudo\n  /// operation if \\c SkipPseudoOp is true.\n  const Instruction *\n  getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = false) const;\n  Instruction *getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = false) {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbgOrLifetime(\n            SkipPseudoOp));\n  }\n\n  /// Returns an iterator to the first instruction in this block that is\n  /// suitable for inserting a non-PHI instruction.\n  ///\n  /// In particular, it skips all PHIs and LandingPad instructions.\n  const_iterator getFirstInsertionPt() const;\n  iterator getFirstInsertionPt() {\n    return static_cast<const BasicBlock *>(this)\n                                          ->getFirstInsertionPt().getNonConst();\n  }\n\n  /// Return a const iterator range over the instructions in the block, skipping\n  /// any debug instructions. Skip any pseudo operations as well if \\c\n  /// SkipPseudoOp is true.\n  iterator_range<filter_iterator<BasicBlock::const_iterator,\n                                 std::function<bool(const Instruction &)>>>\n  instructionsWithoutDebug(bool SkipPseudoOp = false) const;\n\n  /// Return an iterator range over the instructions in the block, skipping any\n  /// debug instructions. Skip and any pseudo operations as well if \\c\n  /// SkipPseudoOp is true.\n  iterator_range<\n      filter_iterator<BasicBlock::iterator, std::function<bool(Instruction &)>>>\n  instructionsWithoutDebug(bool SkipPseudoOp = false);\n\n  /// Return the size of the basic block ignoring debug instructions\n  filter_iterator<BasicBlock::const_iterator,\n                  std::function<bool(const Instruction &)>>::difference_type\n  sizeWithoutDebug() const;\n\n  /// Unlink 'this' from the containing function, but do not delete it.\n  void removeFromParent();\n\n  /// Unlink 'this' from the containing function and delete it.\n  ///\n  // \\returns an iterator pointing to the element after the erased one.\n  SymbolTableList<BasicBlock>::iterator eraseFromParent();\n\n  /// Unlink this basic block from its current function and insert it into\n  /// the function that \\p MovePos lives in, right before \\p MovePos.\n  void moveBefore(BasicBlock *MovePos);\n\n  /// Unlink this basic block from its current function and insert it\n  /// right after \\p MovePos in the function \\p MovePos lives in.\n  void moveAfter(BasicBlock *MovePos);\n\n  /// Insert unlinked basic block into a function.\n  ///\n  /// Inserts an unlinked basic block into \\c Parent.  If \\c InsertBefore is\n  /// provided, inserts before that basic block, otherwise inserts at the end.\n  ///\n  /// \\pre \\a getParent() is \\c nullptr.\n  void insertInto(Function *Parent, BasicBlock *InsertBefore = nullptr);\n\n  /// Return the predecessor of this block if it has a single predecessor\n  /// block. Otherwise return a null pointer.\n  const BasicBlock *getSinglePredecessor() const;\n  BasicBlock *getSinglePredecessor() {\n    return const_cast<BasicBlock *>(\n                 static_cast<const BasicBlock *>(this)->getSinglePredecessor());\n  }\n\n  /// Return the predecessor of this block if it has a unique predecessor\n  /// block. Otherwise return a null pointer.\n  ///\n  /// Note that unique predecessor doesn't mean single edge, there can be\n  /// multiple edges from the unique predecessor to this block (for example a\n  /// switch statement with multiple cases having the same destination).\n  const BasicBlock *getUniquePredecessor() const;\n  BasicBlock *getUniquePredecessor() {\n    return const_cast<BasicBlock *>(\n                 static_cast<const BasicBlock *>(this)->getUniquePredecessor());\n  }\n\n  /// Return true if this block has exactly N predecessors.\n  bool hasNPredecessors(unsigned N) const;\n\n  /// Return true if this block has N predecessors or more.\n  bool hasNPredecessorsOrMore(unsigned N) const;\n\n  /// Return the successor of this block if it has a single successor.\n  /// Otherwise return a null pointer.\n  ///\n  /// This method is analogous to getSinglePredecessor above.\n  const BasicBlock *getSingleSuccessor() const;\n  BasicBlock *getSingleSuccessor() {\n    return const_cast<BasicBlock *>(\n                   static_cast<const BasicBlock *>(this)->getSingleSuccessor());\n  }\n\n  /// Return the successor of this block if it has a unique successor.\n  /// Otherwise return a null pointer.\n  ///\n  /// This method is analogous to getUniquePredecessor above.\n  const BasicBlock *getUniqueSuccessor() const;\n  BasicBlock *getUniqueSuccessor() {\n    return const_cast<BasicBlock *>(\n                   static_cast<const BasicBlock *>(this)->getUniqueSuccessor());\n  }\n\n  /// Print the basic block to an output stream with an optional\n  /// AssemblyAnnotationWriter.\n  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,\n             bool ShouldPreserveUseListOrder = false,\n             bool IsForDebug = false) const;\n\n  //===--------------------------------------------------------------------===//\n  /// Instruction iterator methods\n  ///\n  inline iterator                begin()       { return InstList.begin(); }\n  inline const_iterator          begin() const { return InstList.begin(); }\n  inline iterator                end  ()       { return InstList.end();   }\n  inline const_iterator          end  () const { return InstList.end();   }\n\n  inline reverse_iterator        rbegin()       { return InstList.rbegin(); }\n  inline const_reverse_iterator  rbegin() const { return InstList.rbegin(); }\n  inline reverse_iterator        rend  ()       { return InstList.rend();   }\n  inline const_reverse_iterator  rend  () const { return InstList.rend();   }\n\n  inline size_t                   size() const { return InstList.size();  }\n  inline bool                    empty() const { return InstList.empty(); }\n  inline const Instruction      &front() const { return InstList.front(); }\n  inline       Instruction      &front()       { return InstList.front(); }\n  inline const Instruction       &back() const { return InstList.back();  }\n  inline       Instruction       &back()       { return InstList.back();  }\n\n  /// Iterator to walk just the phi nodes in the basic block.\n  template <typename PHINodeT = PHINode, typename BBIteratorT = iterator>\n  class phi_iterator_impl\n      : public iterator_facade_base<phi_iterator_impl<PHINodeT, BBIteratorT>,\n                                    std::forward_iterator_tag, PHINodeT> {\n    friend BasicBlock;\n\n    PHINodeT *PN;\n\n    phi_iterator_impl(PHINodeT *PN) : PN(PN) {}\n\n  public:\n    // Allow default construction to build variables, but this doesn't build\n    // a useful iterator.\n    phi_iterator_impl() = default;\n\n    // Allow conversion between instantiations where valid.\n    template <typename PHINodeU, typename BBIteratorU,\n              typename = std::enable_if_t<\n                  std::is_convertible<PHINodeU *, PHINodeT *>::value>>\n    phi_iterator_impl(const phi_iterator_impl<PHINodeU, BBIteratorU> &Arg)\n        : PN(Arg.PN) {}\n\n    bool operator==(const phi_iterator_impl &Arg) const { return PN == Arg.PN; }\n\n    PHINodeT &operator*() const { return *PN; }\n\n    using phi_iterator_impl::iterator_facade_base::operator++;\n    phi_iterator_impl &operator++() {\n      assert(PN && \"Cannot increment the end iterator!\");\n      PN = dyn_cast<PHINodeT>(std::next(BBIteratorT(PN)));\n      return *this;\n    }\n  };\n  using phi_iterator = phi_iterator_impl<>;\n  using const_phi_iterator =\n      phi_iterator_impl<const PHINode, BasicBlock::const_iterator>;\n\n  /// Returns a range that iterates over the phis in the basic block.\n  ///\n  /// Note that this cannot be used with basic blocks that have no terminator.\n  iterator_range<const_phi_iterator> phis() const {\n    return const_cast<BasicBlock *>(this)->phis();\n  }\n  iterator_range<phi_iterator> phis();\n\n  /// Return the underlying instruction list container.\n  ///\n  /// Currently you need to access the underlying instruction list container\n  /// directly if you want to modify it.\n  const InstListType &getInstList() const { return InstList; }\n        InstListType &getInstList()       { return InstList; }\n\n  /// Returns a pointer to a member of the instruction list.\n  static InstListType BasicBlock::*getSublistAccess(Instruction*) {\n    return &BasicBlock::InstList;\n  }\n\n  /// Returns a pointer to the symbol table if one exists.\n  ValueSymbolTable *getValueSymbolTable();\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == Value::BasicBlockVal;\n  }\n\n  /// Cause all subinstructions to \"let go\" of all the references that said\n  /// subinstructions are maintaining.\n  ///\n  /// This allows one to 'delete' a whole class at a time, even though there may\n  /// be circular references... first all references are dropped, and all use\n  /// counts go to zero.  Then everything is delete'd for real.  Note that no\n  /// operations are valid on an object that has \"dropped all references\",\n  /// except operator delete.\n  void dropAllReferences();\n\n  /// Update PHI nodes in this BasicBlock before removal of predecessor \\p Pred.\n  /// Note that this function does not actually remove the predecessor.\n  ///\n  /// If \\p KeepOneInputPHIs is true then don't remove PHIs that are left with\n  /// zero or one incoming values, and don't simplify PHIs with all incoming\n  /// values the same.\n  void removePredecessor(BasicBlock *Pred, bool KeepOneInputPHIs = false);\n\n  bool canSplitPredecessors() const;\n\n  /// Split the basic block into two basic blocks at the specified instruction.\n  ///\n  /// If \\p Before is true, splitBasicBlockBefore handles the\n  /// block splitting. Otherwise, execution proceeds as described below.\n  ///\n  /// Note that all instructions BEFORE the specified iterator\n  /// stay as part of the original basic block, an unconditional branch is added\n  /// to the original BB, and the rest of the instructions in the BB are moved\n  /// to the new BB, including the old terminator.  The newly formed basic block\n  /// is returned. This function invalidates the specified iterator.\n  ///\n  /// Note that this only works on well formed basic blocks (must have a\n  /// terminator), and \\p 'I' must not be the end of instruction list (which\n  /// would cause a degenerate basic block to be formed, having a terminator\n  /// inside of the basic block).\n  ///\n  /// Also note that this doesn't preserve any passes. To split blocks while\n  /// keeping loop information consistent, use the SplitBlock utility function.\n  BasicBlock *splitBasicBlock(iterator I, const Twine &BBName = \"\",\n                              bool Before = false);\n  BasicBlock *splitBasicBlock(Instruction *I, const Twine &BBName = \"\",\n                              bool Before = false) {\n    return splitBasicBlock(I->getIterator(), BBName, Before);\n  }\n\n  /// Split the basic block into two basic blocks at the specified instruction\n  /// and insert the new basic blocks as the predecessor of the current block.\n  ///\n  /// This function ensures all instructions AFTER and including the specified\n  /// iterator \\p I are part of the original basic block. All Instructions\n  /// BEFORE the iterator \\p I are moved to the new BB and an unconditional\n  /// branch is added to the new BB. The new basic block is returned.\n  ///\n  /// Note that this only works on well formed basic blocks (must have a\n  /// terminator), and \\p 'I' must not be the end of instruction list (which\n  /// would cause a degenerate basic block to be formed, having a terminator\n  /// inside of the basic block).  \\p 'I' cannot be a iterator for a PHINode\n  /// with multiple incoming blocks.\n  ///\n  /// Also note that this doesn't preserve any passes. To split blocks while\n  /// keeping loop information consistent, use the SplitBlockBefore utility\n  /// function.\n  BasicBlock *splitBasicBlockBefore(iterator I, const Twine &BBName = \"\");\n  BasicBlock *splitBasicBlockBefore(Instruction *I, const Twine &BBName = \"\") {\n    return splitBasicBlockBefore(I->getIterator(), BBName);\n  }\n\n  /// Returns true if there are any uses of this basic block other than\n  /// direct branches, switches, etc. to it.\n  bool hasAddressTaken() const {\n    return getBasicBlockBits().BlockAddressRefCount != 0;\n  }\n\n  /// Update all phi nodes in this basic block to refer to basic block \\p New\n  /// instead of basic block \\p Old.\n  void replacePhiUsesWith(BasicBlock *Old, BasicBlock *New);\n\n  /// Update all phi nodes in this basic block's successors to refer to basic\n  /// block \\p New instead of basic block \\p Old.\n  void replaceSuccessorsPhiUsesWith(BasicBlock *Old, BasicBlock *New);\n\n  /// Update all phi nodes in this basic block's successors to refer to basic\n  /// block \\p New instead of to it.\n  void replaceSuccessorsPhiUsesWith(BasicBlock *New);\n\n  /// Return true if this basic block is an exception handling block.\n  bool isEHPad() const { return getFirstNonPHI()->isEHPad(); }\n\n  /// Return true if this basic block is a landing pad.\n  ///\n  /// Being a ``landing pad'' means that the basic block is the destination of\n  /// the 'unwind' edge of an invoke instruction.\n  bool isLandingPad() const;\n\n  /// Return the landingpad instruction associated with the landing pad.\n  const LandingPadInst *getLandingPadInst() const;\n  LandingPadInst *getLandingPadInst() {\n    return const_cast<LandingPadInst *>(\n                    static_cast<const BasicBlock *>(this)->getLandingPadInst());\n  }\n\n  /// Return true if it is legal to hoist instructions into this block.\n  bool isLegalToHoistInto() const;\n\n  Optional<uint64_t> getIrrLoopHeaderWeight() const;\n\n  /// Returns true if the Order field of child Instructions is valid.\n  bool isInstrOrderValid() const {\n    return getBasicBlockBits().InstrOrderValid;\n  }\n\n  /// Mark instruction ordering invalid. Done on every instruction insert.\n  void invalidateOrders() {\n    validateInstrOrdering();\n    BasicBlockBits Bits = getBasicBlockBits();\n    Bits.InstrOrderValid = false;\n    setBasicBlockBits(Bits);\n  }\n\n  /// Renumber instructions and mark the ordering as valid.\n  void renumberInstructions();\n\n  /// Asserts that instruction order numbers are marked invalid, or that they\n  /// are in ascending order. This is constant time if the ordering is invalid,\n  /// and linear in the number of instructions if the ordering is valid. Callers\n  /// should be careful not to call this in ways that make common operations\n  /// O(n^2). For example, it takes O(n) time to assign order numbers to\n  /// instructions, so the order should be validated no more than once after\n  /// each ordering to ensure that transforms have the same algorithmic\n  /// complexity when asserts are enabled as when they are disabled.\n  void validateInstrOrdering() const;\n\nprivate:\n#if defined(_AIX) && (!defined(__GNUC__) || defined(__ibmxl__))\n// Except for GCC; by default, AIX compilers store bit-fields in 4-byte words\n// and give the `pack` pragma push semantics.\n#define BEGIN_TWO_BYTE_PACK() _Pragma(\"pack(2)\")\n#define END_TWO_BYTE_PACK() _Pragma(\"pack(pop)\")\n#else\n#define BEGIN_TWO_BYTE_PACK()\n#define END_TWO_BYTE_PACK()\n#endif\n\n  BEGIN_TWO_BYTE_PACK()\n  /// Bitfield to help interpret the bits in Value::SubclassData.\n  struct BasicBlockBits {\n    unsigned short BlockAddressRefCount : 15;\n    unsigned short InstrOrderValid : 1;\n  };\n  END_TWO_BYTE_PACK()\n\n#undef BEGIN_TWO_BYTE_PACK\n#undef END_TWO_BYTE_PACK\n\n  /// Safely reinterpret the subclass data bits to a more useful form.\n  BasicBlockBits getBasicBlockBits() const {\n    static_assert(sizeof(BasicBlockBits) == sizeof(unsigned short),\n                  \"too many bits for Value::SubclassData\");\n    unsigned short ValueData = getSubclassDataFromValue();\n    BasicBlockBits AsBits;\n    memcpy(&AsBits, &ValueData, sizeof(AsBits));\n    return AsBits;\n  }\n\n  /// Reinterpret our subclass bits and store them back into Value.\n  void setBasicBlockBits(BasicBlockBits AsBits) {\n    unsigned short D;\n    memcpy(&D, &AsBits, sizeof(D));\n    Value::setValueSubclassData(D);\n  }\n\n  /// Increment the internal refcount of the number of BlockAddresses\n  /// referencing this BasicBlock by \\p Amt.\n  ///\n  /// This is almost always 0, sometimes one possibly, but almost never 2, and\n  /// inconceivably 3 or more.\n  void AdjustBlockAddressRefCount(int Amt) {\n    BasicBlockBits Bits = getBasicBlockBits();\n    Bits.BlockAddressRefCount += Amt;\n    setBasicBlockBits(Bits);\n    assert(Bits.BlockAddressRefCount < 255 && \"Refcount wrap-around\");\n  }\n\n  /// Shadow Value::setValueSubclassData with a private forwarding method so\n  /// that any future subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(BasicBlock, LLVMBasicBlockRef)\n\n/// Advance \\p It while it points to a debug instruction and return the result.\n/// This assumes that \\p It is not at the end of a block.\nBasicBlock::iterator skipDebugIntrinsics(BasicBlock::iterator It);\n\n#ifdef NDEBUG\n/// In release builds, this is a no-op. For !NDEBUG builds, the checks are\n/// implemented in the .cpp file to avoid circular header deps.\ninline void BasicBlock::validateInstrOrdering() const {}\n#endif\n\n} // end namespace llvm\n\n#endif // LLVM_IR_BASICBLOCK_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Comdat.h", "content": "//===- llvm/IR/Comdat.h - Comdat definitions --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declaration of the Comdat class, which represents a\n/// single COMDAT in LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_COMDAT_H\n#define LLVM_IR_COMDAT_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\nclass StringRef;\ntemplate <typename ValueTy> class StringMapEntry;\n\n// This is a Name X SelectionKind pair. The reason for having this be an\n// independent object instead of just adding the name and the SelectionKind\n// to a GlobalObject is that it is invalid to have two Comdats with the same\n// name but different SelectionKind. This structure makes that unrepresentable.\nclass Comdat {\npublic:\n  enum SelectionKind {\n    Any,          ///< The linker may choose any COMDAT.\n    ExactMatch,   ///< The data referenced by the COMDAT must be the same.\n    Largest,      ///< The linker will choose the largest COMDAT.\n    NoDuplicates, ///< No other Module may specify this COMDAT.\n    SameSize,     ///< The data referenced by the COMDAT must be the same size.\n  };\n\n  Comdat(const Comdat &) = delete;\n  Comdat(Comdat &&C);\n\n  SelectionKind getSelectionKind() const { return SK; }\n  void setSelectionKind(SelectionKind Val) { SK = Val; }\n  StringRef getName() const;\n  void print(raw_ostream &OS, bool IsForDebug = false) const;\n  void dump() const;\n\nprivate:\n  friend class Module;\n\n  Comdat();\n\n  // Points to the map in Module.\n  StringMapEntry<Comdat> *Name = nullptr;\n  SelectionKind SK = Any;\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(Comdat, LLVMComdatRef)\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Comdat &C) {\n  C.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_COMDAT_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "content": "//===- llvm/IR/DebugInfoMetadata.h - Debug info metadata --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Declarations for metadata specific to debug info.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DEBUGINFOMETADATA_H\n#define LLVM_IR_DEBUGINFOMETADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <type_traits>\n#include <vector>\n\n// Helper macros for defining get() overrides.\n#define DEFINE_MDNODE_GET_UNPACK_IMPL(...) __VA_ARGS__\n#define DEFINE_MDNODE_GET_UNPACK(ARGS) DEFINE_MDNODE_GET_UNPACK_IMPL ARGS\n#define DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)              \\\n  static CLASS *getDistinct(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Distinct);         \\\n  }                                                                            \\\n  static Temp##CLASS getTemporary(LLVMContext &Context,                        \\\n                                  DEFINE_MDNODE_GET_UNPACK(FORMAL)) {          \\\n    return Temp##CLASS(                                                        \\\n        getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Temporary));          \\\n  }\n#define DEFINE_MDNODE_GET(CLASS, FORMAL, ARGS)                                 \\\n  static CLASS *get(LLVMContext &Context, DEFINE_MDNODE_GET_UNPACK(FORMAL)) {  \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued);          \\\n  }                                                                            \\\n  static CLASS *getIfExists(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued,           \\\n                   /* ShouldCreate */ false);                                  \\\n  }                                                                            \\\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)\n\nnamespace llvm {\n\nclass DITypeRefArray {\n  const MDTuple *N = nullptr;\n\npublic:\n  DITypeRefArray() = default;\n  DITypeRefArray(const MDTuple *N) : N(N) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  DIType *operator[](unsigned I) const {\n    return cast_or_null<DIType>(N->getOperand(I));\n  }\n\n  class iterator : std::iterator<std::input_iterator_tag, DIType *,\n                                 std::ptrdiff_t, void, DIType *> {\n    MDNode::op_iterator I = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(MDNode::op_iterator I) : I(I) {}\n\n    DIType *operator*() const { return cast_or_null<DIType>(*I); }\n\n    iterator &operator++() {\n      ++I;\n      return *this;\n    }\n\n    iterator operator++(int) {\n      iterator Temp(*this);\n      ++I;\n      return Temp;\n    }\n\n    bool operator==(const iterator &X) const { return I == X.I; }\n    bool operator!=(const iterator &X) const { return I != X.I; }\n  };\n\n  // FIXME: Fix callers and remove condition on N.\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n/// Tagged DWARF-like metadata node.\n///\n/// A metadata node with a DWARF tag (i.e., a constant named \\c DW_TAG_*,\n/// defined in llvm/BinaryFormat/Dwarf.h).  Called \\a DINode because it's\n/// potentially used for non-DWARF output.\nclass DINode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DINode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(Tag < 1u << 16);\n    SubclassData16 = Tag;\n  }\n  ~DINode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\n  /// Allow subclasses to mutate the tag.\n  void setTag(unsigned Tag) { SubclassData16 = Tag; }\n\npublic:\n  unsigned getTag() const { return SubclassData16; }\n\n  /// Debug info flags.\n  ///\n  /// The three accessibility flags are mutually exclusive and rolled together\n  /// in the first two bits.\n  enum DIFlags : uint32_t {\n#define HANDLE_DI_FLAG(ID, NAME) Flag##NAME = ID,\n#define DI_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    FlagAccessibility = FlagPrivate | FlagProtected | FlagPublic,\n    FlagPtrToMemberRep = FlagSingleInheritance | FlagMultipleInheritance |\n                         FlagVirtualInheritance,\n    LLVM_MARK_AS_BITMASK_ENUM(FlagLargest)\n  };\n\n  static DIFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DIFlags Flag);\n\n  /// Split up a flags bitfield.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DIFlags splitFlags(DIFlags Flags,\n                            SmallVectorImpl<DIFlags> &SplitFlags);\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case GenericDINodeKind:\n    case DISubrangeKind:\n    case DIEnumeratorKind:\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DITemplateTypeParameterKind:\n    case DITemplateValueParameterKind:\n    case DIGlobalVariableKind:\n    case DILocalVariableKind:\n    case DILabelKind:\n    case DIObjCPropertyKind:\n    case DIImportedEntityKind:\n    case DIModuleKind:\n    case DIGenericSubrangeKind:\n      return true;\n    }\n  }\n};\n\n/// Generic tagged DWARF-like metadata node.\n///\n/// An un-specialized DWARF-like metadata node.  The first operand is a\n/// (possibly empty) null-separated \\a MDString header that contains arbitrary\n/// fields.  The remaining operands are \\a dwarf_operands(), and are pointers\n/// to other metadata.\nclass GenericDINode : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  GenericDINode(LLVMContext &C, StorageType Storage, unsigned Hash,\n                unsigned Tag, ArrayRef<Metadata *> Ops1,\n                ArrayRef<Metadata *> Ops2)\n      : DINode(C, GenericDINodeKind, Storage, Tag, Ops1, Ops2) {\n    setHash(Hash);\n  }\n  ~GenericDINode() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                StringRef Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Header),\n                   DwarfOps, Storage, ShouldCreate);\n  }\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempGenericDINode cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getHeader(),\n                        SmallVector<Metadata *, 4>(dwarf_operands()));\n  }\n\npublic:\n  unsigned getHash() const { return SubclassData32; }\n\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, StringRef Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, MDString *Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n\n  /// Return a (temporary) clone of this.\n  TempGenericDINode clone() const { return cloneImpl(); }\n\n  unsigned getTag() const { return SubclassData16; }\n  StringRef getHeader() const { return getStringOperand(0); }\n  MDString *getRawHeader() const { return getOperandAs<MDString>(0); }\n\n  op_iterator dwarf_op_begin() const { return op_begin() + 1; }\n  op_iterator dwarf_op_end() const { return op_end(); }\n  op_range dwarf_operands() const {\n    return op_range(dwarf_op_begin(), dwarf_op_end());\n  }\n\n  unsigned getNumDwarfOperands() const { return getNumOperands() - 1; }\n  const MDOperand &getDwarfOperand(unsigned I) const {\n    return getOperand(I + 1);\n  }\n  void replaceDwarfOperandWith(unsigned I, Metadata *New) {\n    replaceOperandWith(I + 1, New);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == GenericDINodeKind;\n  }\n};\n\n/// Array subrange.\n///\n/// TODO: Merge into node for DW_TAG_array_type, which should have a custom\n/// type.\nclass DISubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DISubrange(LLVMContext &C, StorageType Storage, ArrayRef<Metadata *> Ops)\n      : DINode(C, DISubrangeKind, Storage, dwarf::DW_TAG_subrange_type, Ops) {}\n\n  ~DISubrange() = default;\n\n  static DISubrange *getImpl(LLVMContext &Context, int64_t Count,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             Metadata *LowerBound, Metadata *UpperBound,\n                             Metadata *Stride, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  TempDISubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubrange, (int64_t Count, int64_t LowerBound = 0),\n                    (Count, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange, (Metadata *CountNode, int64_t LowerBound = 0),\n                    (CountNode, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDISubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const {\n    return getOperand(0).get();\n  }\n\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  typedef PointerUnion<ConstantInt*, DIVariable*> CountType;\n  typedef PointerUnion<ConstantInt *, DIVariable *, DIExpression *> BoundType;\n\n  CountType getCount() const;\n\n  BoundType getLowerBound() const;\n\n  BoundType getUpperBound() const;\n\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubrangeKind;\n  }\n};\n\nclass DIGenericSubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGenericSubrange(LLVMContext &C, StorageType Storage,\n                    ArrayRef<Metadata *> Ops)\n      : DINode(C, DIGenericSubrangeKind, Storage,\n               dwarf::DW_TAG_generic_subrange, Ops) {}\n\n  ~DIGenericSubrange() = default;\n\n  static DIGenericSubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                                    Metadata *LowerBound, Metadata *UpperBound,\n                                    Metadata *Stride, StorageType Storage,\n                                    bool ShouldCreate = true);\n\n  TempDIGenericSubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGenericSubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDIGenericSubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const { return getOperand(0).get(); }\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  using BoundType = PointerUnion<DIVariable *, DIExpression *>;\n\n  BoundType getCount() const;\n  BoundType getLowerBound() const;\n  BoundType getUpperBound() const;\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGenericSubrangeKind;\n  }\n};\n\n/// Enumeration value.\n///\n/// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no\n/// longer creates a type cycle.\nclass DIEnumerator : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  APInt Value;\n  DIEnumerator(LLVMContext &C, StorageType Storage, const APInt &Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIEnumeratorKind, Storage, dwarf::DW_TAG_enumerator, Ops),\n        Value(Value) {\n    SubclassData32 = IsUnsigned;\n  }\n  DIEnumerator(LLVMContext &C, StorageType Storage, int64_t Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DIEnumerator(C, Storage, APInt(64, Value, !IsUnsigned), IsUnsigned,\n                     Ops) {}\n  ~DIEnumerator() = default;\n\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, StringRef Name,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Value, IsUnsigned,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, MDString *Name,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIEnumerator cloneImpl() const {\n    return getTemporary(getContext(), getValue(), isUnsigned(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, StringRef Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, MDString *Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, StringRef Name),\n                    (Value, IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, MDString *Name),\n                    (Value, IsUnsigned, Name))\n\n  TempDIEnumerator clone() const { return cloneImpl(); }\n\n  const APInt &getValue() const { return Value; }\n  bool isUnsigned() const { return SubclassData32; }\n  StringRef getName() const { return getStringOperand(0); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIEnumeratorKind;\n  }\n};\n\n/// Base class for scope-like contexts.\n///\n/// Base class for lexical scopes and types (which are also declaration\n/// contexts).\n///\n/// TODO: Separate the concepts of declaration contexts and lexical scopes.\nclass DIScope : public DINode {\nprotected:\n  DIScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, ID, Storage, Tag, Ops) {}\n  ~DIScope() = default;\n\npublic:\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  inline StringRef getFilename() const;\n  inline StringRef getDirectory() const;\n  inline Optional<StringRef> getSource() const;\n\n  StringRef getName() const;\n  DIScope *getScope() const;\n\n  /// Return the raw underlying file.\n  ///\n  /// A \\a DIFile is a \\a DIScope, but it doesn't point at a separate file (it\n  /// \\em is the file).  If \\c this is an \\a DIFile, we need to return \\c this.\n  /// Otherwise, return the first operand, which is where all other subclasses\n  /// store their file pointer.\n  Metadata *getRawFile() const {\n    return isa<DIFile>(this) ? const_cast<DIScope *>(this)\n                             : static_cast<Metadata *>(getOperand(0));\n  }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DIModuleKind:\n      return true;\n    }\n  }\n};\n\n/// File.\n///\n/// TODO: Merge with directory/file node (including users).\n/// TODO: Canonicalize paths on creation.\nclass DIFile : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  /// Which algorithm (e.g. MD5) a checksum was generated with.\n  ///\n  /// The encoding is explicit because it is used directly in Bitcode. The\n  /// value 0 is reserved to indicate the absence of a checksum in Bitcode.\n  enum ChecksumKind {\n    // The first variant was originally CSK_None, encoded as 0. The new\n    // internal representation removes the need for this by wrapping the\n    // ChecksumInfo in an Optional, but to preserve Bitcode compatibility the 0\n    // encoding is reserved.\n    CSK_MD5 = 1,\n    CSK_SHA1 = 2,\n    CSK_SHA256 = 3,\n    CSK_Last = CSK_SHA256 // Should be last enumeration.\n  };\n\n  /// A single checksum, represented by a \\a Kind and a \\a Value (a string).\n  template <typename T>\n  struct ChecksumInfo {\n    /// The kind of checksum which \\a Value encodes.\n    ChecksumKind Kind;\n    /// The string value of the checksum.\n    T Value;\n\n    ChecksumInfo(ChecksumKind Kind, T Value) : Kind(Kind), Value(Value) { }\n    ~ChecksumInfo() = default;\n    bool operator==(const ChecksumInfo<T> &X) const {\n      return Kind == X.Kind && Value == X.Value;\n    }\n    bool operator!=(const ChecksumInfo<T> &X) const { return !(*this == X); }\n    StringRef getKindAsString() const { return getChecksumKindAsString(Kind); }\n  };\n\nprivate:\n  Optional<ChecksumInfo<MDString *>> Checksum;\n  Optional<MDString *> Source;\n\n  DIFile(LLVMContext &C, StorageType Storage,\n         Optional<ChecksumInfo<MDString *>> CS, Optional<MDString *> Src,\n         ArrayRef<Metadata *> Ops)\n      : DIScope(C, DIFileKind, Storage, dwarf::DW_TAG_file_type, Ops),\n        Checksum(CS), Source(Src) {}\n  ~DIFile() = default;\n\n  static DIFile *getImpl(LLVMContext &Context, StringRef Filename,\n                         StringRef Directory,\n                         Optional<ChecksumInfo<StringRef>> CS,\n                         Optional<StringRef> Source,\n                         StorageType Storage, bool ShouldCreate = true) {\n    Optional<ChecksumInfo<MDString *>> MDChecksum;\n    if (CS)\n      MDChecksum.emplace(CS->Kind, getCanonicalMDString(Context, CS->Value));\n    return getImpl(Context, getCanonicalMDString(Context, Filename),\n                   getCanonicalMDString(Context, Directory), MDChecksum,\n                   Source ? Optional<MDString *>(getCanonicalMDString(Context, *Source)) : None,\n                   Storage, ShouldCreate);\n  }\n  static DIFile *getImpl(LLVMContext &Context, MDString *Filename,\n                         MDString *Directory,\n                         Optional<ChecksumInfo<MDString *>> CS,\n                         Optional<MDString *> Source, StorageType Storage,\n                         bool ShouldCreate = true);\n\n  TempDIFile cloneImpl() const {\n    return getTemporary(getContext(), getFilename(), getDirectory(),\n                        getChecksum(), getSource());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIFile, (StringRef Filename, StringRef Directory,\n                             Optional<ChecksumInfo<StringRef>> CS = None,\n                             Optional<StringRef> Source = None),\n                    (Filename, Directory, CS, Source))\n  DEFINE_MDNODE_GET(DIFile, (MDString * Filename, MDString *Directory,\n                             Optional<ChecksumInfo<MDString *>> CS = None,\n                             Optional<MDString *> Source = None),\n                    (Filename, Directory, CS, Source))\n\n  TempDIFile clone() const { return cloneImpl(); }\n\n  StringRef getFilename() const { return getStringOperand(0); }\n  StringRef getDirectory() const { return getStringOperand(1); }\n  Optional<ChecksumInfo<StringRef>> getChecksum() const {\n    Optional<ChecksumInfo<StringRef>> StringRefChecksum;\n    if (Checksum)\n      StringRefChecksum.emplace(Checksum->Kind, Checksum->Value->getString());\n    return StringRefChecksum;\n  }\n  Optional<StringRef> getSource() const {\n    return Source ? Optional<StringRef>((*Source)->getString()) : None;\n  }\n\n  MDString *getRawFilename() const { return getOperandAs<MDString>(0); }\n  MDString *getRawDirectory() const { return getOperandAs<MDString>(1); }\n  Optional<ChecksumInfo<MDString *>> getRawChecksum() const { return Checksum; }\n  Optional<MDString *> getRawSource() const { return Source; }\n\n  static StringRef getChecksumKindAsString(ChecksumKind CSKind);\n  static Optional<ChecksumKind> getChecksumKind(StringRef CSKindStr);\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIFileKind;\n  }\n};\n\nStringRef DIScope::getFilename() const {\n  if (auto *F = getFile())\n    return F->getFilename();\n  return \"\";\n}\n\nStringRef DIScope::getDirectory() const {\n  if (auto *F = getFile())\n    return F->getDirectory();\n  return \"\";\n}\n\nOptional<StringRef> DIScope::getSource() const {\n  if (auto *F = getFile())\n    return F->getSource();\n  return None;\n}\n\n/// Base class for types.\n///\n/// TODO: Remove the hardcoded name and context, since many types don't use\n/// them.\n/// TODO: Split up flags.\nclass DIType : public DIScope {\n  unsigned Line;\n  DIFlags Flags;\n  uint64_t SizeInBits;\n  uint64_t OffsetInBits;\n  uint32_t AlignInBits;\n\nprotected:\n  DIType(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n         uint64_t OffsetInBits, DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n  ~DIType() = default;\n\n  void init(unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n            uint64_t OffsetInBits, DIFlags Flags) {\n    this->Line = Line;\n    this->Flags = Flags;\n    this->SizeInBits = SizeInBits;\n    this->AlignInBits = AlignInBits;\n    this->OffsetInBits = OffsetInBits;\n  }\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, uint64_t SizeInBits,\n              uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    setTag(Tag);\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\npublic:\n  TempDIType clone() const {\n    return TempDIType(cast<DIType>(MDNode::clone().release()));\n  }\n\n  unsigned getLine() const { return Line; }\n  uint64_t getSizeInBits() const { return SizeInBits; }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  uint64_t getOffsetInBits() const { return OffsetInBits; }\n  DIFlags getFlags() const { return Flags; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  /// Returns a new temporary DIType with updated Flags\n  TempDIType cloneWithFlags(DIFlags NewFlags) const {\n    auto NewTy = clone();\n    NewTy->Flags = NewFlags;\n    return NewTy;\n  }\n\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isForwardDecl() const { return getFlags() & FlagFwdDecl; }\n  bool isAppleBlockExtension() const { return getFlags() & FlagAppleBlock; }\n  bool isVirtual() const { return getFlags() & FlagVirtual; }\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n  bool isObjcClassComplete() const {\n    return getFlags() & FlagObjcClassComplete;\n  }\n  bool isVector() const { return getFlags() & FlagVector; }\n  bool isBitField() const { return getFlags() & FlagBitField; }\n  bool isStaticMember() const { return getFlags() & FlagStaticMember; }\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n  bool isTypePassByValue() const { return getFlags() & FlagTypePassByValue; }\n  bool isTypePassByReference() const {\n    return getFlags() & FlagTypePassByReference;\n  }\n  bool isBigEndian() const { return getFlags() & FlagBigEndian; }\n  bool isLittleEndian() const { return getFlags() & FlagLittleEndian; }\n  bool getExportSymbols() const { return getFlags() & FlagExportSymbols; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n      return true;\n    }\n  }\n};\n\n/// Basic type, like 'int' or 'float'.\n///\n/// TODO: Split out DW_TAG_unspecified_type.\n/// TODO: Drop unused accessors.\nclass DIBasicType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIBasicType(LLVMContext &C, StorageType Storage, unsigned Tag,\n              uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n              DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIBasicTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               Flags, Ops),\n        Encoding(Encoding) {}\n  ~DIBasicType() = default;\n\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              StringRef Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   SizeInBits, AlignInBits, Encoding, Flags, Storage,\n                   ShouldCreate);\n  }\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              MDString *Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true);\n\n  TempDIBasicType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getSizeInBits(),\n                        getAlignInBits(), getEncoding(), getFlags());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIBasicType, (unsigned Tag, StringRef Name),\n                    (Tag, Name, 0, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n\n  TempDIBasicType clone() const { return cloneImpl(); }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  enum class Signedness { Signed, Unsigned };\n\n  /// Return the signedness of this type, or None if this type is neither\n  /// signed nor unsigned.\n  Optional<Signedness> getSignedness() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIBasicTypeKind;\n  }\n};\n\n/// String type, Fortran CHARACTER(n)\nclass DIStringType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIStringType(LLVMContext &C, StorageType Storage, unsigned Tag,\n               uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n               ArrayRef<Metadata *> Ops)\n      : DIType(C, DIStringTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               FlagZero, Ops),\n        Encoding(Encoding) {}\n  ~DIStringType() = default;\n\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               StringRef Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   StringLength, StrLenExp, SizeInBits, AlignInBits, Encoding,\n                   Storage, ShouldCreate);\n  }\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               MDString *Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIStringType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getRawName(),\n                        getRawStringLength(), getRawStringLengthExp(),\n                        getSizeInBits(), getAlignInBits(), getEncoding());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits),\n                    (Tag, Name, nullptr, nullptr, SizeInBits, AlignInBits, 0))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, MDString *Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n\n  TempDIStringType clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIStringTypeKind;\n  }\n\n  DIVariable *getStringLength() const {\n    return cast_or_null<DIVariable>(getRawStringLength());\n  }\n\n  DIExpression *getStringLengthExp() const {\n    return cast_or_null<DIExpression>(getRawStringLengthExp());\n  }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  Metadata *getRawStringLength() const { return getOperand(3); }\n\n  Metadata *getRawStringLengthExp() const { return getOperand(4); }\n};\n\n/// Derived types.\n///\n/// This includes qualified types, pointers, references, friends, typedefs, and\n/// class members.\n///\n/// TODO: Split out members (inheritance, fields, methods, etc.).\nclass DIDerivedType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The DWARF address space of the memory pointed to or referenced by a\n  /// pointer or reference type respectively.\n  Optional<unsigned> DWARFAddressSpace;\n\n  DIDerivedType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n                uint64_t OffsetInBits, Optional<unsigned> DWARFAddressSpace,\n                DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIDerivedTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        DWARFAddressSpace(DWARFAddressSpace) {}\n  ~DIDerivedType() = default;\n\n  static DIDerivedType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, DIFile *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits,\n          Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n          Metadata *ExtraData, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), File,\n                   Line, Scope, BaseType, SizeInBits, AlignInBits, OffsetInBits,\n                   DWARFAddressSpace, Flags, ExtraData, Storage, ShouldCreate);\n  }\n  static DIDerivedType *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Name, Metadata *File, unsigned Line,\n                                Metadata *Scope, Metadata *BaseType,\n                                uint64_t SizeInBits, uint32_t AlignInBits,\n                                uint64_t OffsetInBits,\n                                Optional<unsigned> DWARFAddressSpace,\n                                DIFlags Flags, Metadata *ExtraData,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDIDerivedType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(),\n                        getDWARFAddressSpace(), getFlags(), getExtraData());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Scope, Metadata *BaseType,\n                     uint64_t SizeInBits, uint32_t AlignInBits,\n                     uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n                     DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n                     uint32_t AlignInBits, uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n\n  TempDIDerivedType clone() const { return cloneImpl(); }\n\n  /// Get the base type this is derived from.\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  Metadata *getRawBaseType() const { return getOperand(3); }\n\n  /// \\returns The DWARF address space of the memory pointed to or referenced by\n  /// a pointer or reference type respectively.\n  Optional<unsigned> getDWARFAddressSpace() const { return DWARFAddressSpace; }\n\n  /// Get extra data associated with this derived type.\n  ///\n  /// Class type for pointer-to-members, objective-c property node for ivars,\n  /// global constant wrapper for static members, or virtual base pointer offset\n  /// for inheritance.\n  ///\n  /// TODO: Separate out types that need this extra operand: pointer-to-member\n  /// types and member fields (static members and ivars).\n  Metadata *getExtraData() const { return getRawExtraData(); }\n  Metadata *getRawExtraData() const { return getOperand(4); }\n\n  /// Get casted version of extra data.\n  /// @{\n  DIType *getClassType() const {\n    assert(getTag() == dwarf::DW_TAG_ptr_to_member_type);\n    return cast_or_null<DIType>(getExtraData());\n  }\n\n  DIObjCProperty *getObjCProperty() const {\n    return dyn_cast_or_null<DIObjCProperty>(getExtraData());\n  }\n\n  uint32_t getVBPtrOffset() const {\n    assert(getTag() == dwarf::DW_TAG_inheritance);\n    if (auto *CM = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      if (auto *CI = dyn_cast_or_null<ConstantInt>(CM->getValue()))\n        return static_cast<uint32_t>(CI->getZExtValue());\n    return 0;\n  }\n\n  Constant *getStorageOffsetInBits() const {\n    assert(getTag() == dwarf::DW_TAG_member && isBitField());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n\n  Constant *getConstant() const {\n    assert(getTag() == dwarf::DW_TAG_member && isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  Constant *getDiscriminantValue() const {\n    assert(getTag() == dwarf::DW_TAG_member && !isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIDerivedTypeKind;\n  }\n};\n\n/// Composite types.\n///\n/// TODO: Detach from DerivedTypeBase (split out MDEnumType?).\n/// TODO: Create a custom, unrelated node for DW_TAG_array_type.\nclass DICompositeType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned RuntimeLang;\n\n  DICompositeType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                  unsigned Line, unsigned RuntimeLang, uint64_t SizeInBits,\n                  uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n                  ArrayRef<Metadata *> Ops)\n      : DIType(C, DICompositeTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        RuntimeLang(RuntimeLang) {}\n  ~DICompositeType() = default;\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, unsigned RuntimeLang,\n              uint64_t SizeInBits, uint32_t AlignInBits,\n              uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    assert(getRawIdentifier() && \"Only ODR-uniqued nodes should mutate\");\n    this->RuntimeLang = RuntimeLang;\n    DIType::mutate(Tag, Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, Metadata *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n          DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n          DITemplateParameterArray TemplateParams, StringRef Identifier,\n          DIDerivedType *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, Tag, getCanonicalMDString(Context, Name), File, Line, Scope,\n        BaseType, SizeInBits, AlignInBits, OffsetInBits, Flags, Elements.get(),\n        RuntimeLang, VTableHolder, TemplateParams.get(),\n        getCanonicalMDString(Context, Identifier), Discriminator, DataLocation,\n        Associated, Allocated, Rank, Storage, ShouldCreate);\n  }\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,\n          unsigned Line, Metadata *Scope, Metadata *BaseType,\n          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,\n          DIFlags Flags, Metadata *Elements, unsigned RuntimeLang,\n          Metadata *VTableHolder, Metadata *TemplateParams,\n          MDString *Identifier, Metadata *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompositeType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(), getFlags(),\n                        getElements(), getRuntimeLang(), getVTableHolder(),\n                        getTemplateParams(), getIdentifier(),\n                        getDiscriminator(), getRawDataLocation(),\n                        getRawAssociated(), getRawAllocated(), getRawRank());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n       DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n       DITemplateParameterArray TemplateParams = nullptr,\n       StringRef Identifier = \"\", DIDerivedType *Discriminator = nullptr,\n       Metadata *DataLocation = nullptr, Metadata *Associated = nullptr,\n       Metadata *Allocated = nullptr, Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, MDString *Name, Metadata *File, unsigned Line,\n       Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       Metadata *Elements, unsigned RuntimeLang, Metadata *VTableHolder,\n       Metadata *TemplateParams = nullptr, MDString *Identifier = nullptr,\n       Metadata *Discriminator = nullptr, Metadata *DataLocation = nullptr,\n       Metadata *Associated = nullptr, Metadata *Allocated = nullptr,\n       Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n\n  TempDICompositeType clone() const { return cloneImpl(); }\n\n  /// Get a DICompositeType with the given ODR identifier.\n  ///\n  /// If \\a LLVMContext::isODRUniquingDebugTypes(), gets the mapped\n  /// DICompositeType for the given ODR \\c Identifier.  If none exists, creates\n  /// a new node.\n  ///\n  /// Else, returns \\c nullptr.\n  static DICompositeType *\n  getODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n             MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n             Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n             uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n             unsigned RuntimeLang, Metadata *VTableHolder,\n             Metadata *TemplateParams, Metadata *Discriminator,\n             Metadata *DataLocation, Metadata *Associated, Metadata *Allocated,\n             Metadata *Rank);\n  static DICompositeType *getODRTypeIfExists(LLVMContext &Context,\n                                             MDString &Identifier);\n\n  /// Build a DICompositeType with the given ODR identifier.\n  ///\n  /// Looks up the mapped DICompositeType for the given ODR \\c Identifier.  If\n  /// it doesn't exist, creates a new one.  If it does exist and \\a\n  /// isForwardDecl(), and the new arguments would be a definition, mutates the\n  /// the type in place.  In either case, returns the type.\n  ///\n  /// If not \\a LLVMContext::isODRUniquingDebugTypes(), this function returns\n  /// nullptr.\n  static DICompositeType *\n  buildODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n               MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n               Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n               uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n               unsigned RuntimeLang, Metadata *VTableHolder,\n               Metadata *TemplateParams, Metadata *Discriminator,\n               Metadata *DataLocation, Metadata *Associated,\n               Metadata *Allocated, Metadata *Rank);\n\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  DINodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n  DIType *getVTableHolder() const {\n    return cast_or_null<DIType>(getRawVTableHolder());\n  }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  StringRef getIdentifier() const { return getStringOperand(7); }\n  unsigned getRuntimeLang() const { return RuntimeLang; }\n\n  Metadata *getRawBaseType() const { return getOperand(3); }\n  Metadata *getRawElements() const { return getOperand(4); }\n  Metadata *getRawVTableHolder() const { return getOperand(5); }\n  Metadata *getRawTemplateParams() const { return getOperand(6); }\n  MDString *getRawIdentifier() const { return getOperandAs<MDString>(7); }\n  Metadata *getRawDiscriminator() const { return getOperand(8); }\n  DIDerivedType *getDiscriminator() const { return getOperandAs<DIDerivedType>(8); }\n  Metadata *getRawDataLocation() const { return getOperand(9); }\n  DIVariable *getDataLocation() const {\n    return dyn_cast_or_null<DIVariable>(getRawDataLocation());\n  }\n  DIExpression *getDataLocationExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawDataLocation());\n  }\n  Metadata *getRawAssociated() const { return getOperand(10); }\n  DIVariable *getAssociated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAssociated());\n  }\n  DIExpression *getAssociatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAssociated());\n  }\n  Metadata *getRawAllocated() const { return getOperand(11); }\n  DIVariable *getAllocated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAllocated());\n  }\n  DIExpression *getAllocatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAllocated());\n  }\n  Metadata *getRawRank() const { return getOperand(12); }\n  ConstantInt *getRankConst() const {\n    if (auto *MD = dyn_cast_or_null<ConstantAsMetadata>(getRawRank()))\n      return dyn_cast_or_null<ConstantInt>(MD->getValue());\n    return nullptr;\n  }\n  DIExpression *getRankExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawRank());\n  }\n\n  /// Replace operands.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), on a uniquing collision\n  /// this will be RAUW'ed and deleted.  Use a \\a TrackingMDRef to keep track\n  /// of its movement if necessary.\n  /// @{\n  void replaceElements(DINodeArray Elements) {\n#ifndef NDEBUG\n    for (DINode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a member during member list replacement\");\n#endif\n    replaceOperandWith(4, Elements.get());\n  }\n\n  void replaceVTableHolder(DIType *VTableHolder) {\n    replaceOperandWith(5, VTableHolder);\n  }\n\n  void replaceTemplateParams(DITemplateParameterArray TemplateParams) {\n    replaceOperandWith(6, TemplateParams.get());\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompositeTypeKind;\n  }\n};\n\n/// Type array for a subprogram.\n///\n/// TODO: Fold the array of types in directly as operands.\nclass DISubroutineType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The calling convention used with DW_AT_calling_convention. Actually of\n  /// type dwarf::CallingConvention.\n  uint8_t CC;\n\n  DISubroutineType(LLVMContext &C, StorageType Storage, DIFlags Flags,\n                   uint8_t CC, ArrayRef<Metadata *> Ops)\n      : DIType(C, DISubroutineTypeKind, Storage, dwarf::DW_TAG_subroutine_type,\n               0, 0, 0, 0, Flags, Ops),\n        CC(CC) {}\n  ~DISubroutineType() = default;\n\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, DITypeRefArray TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Flags, CC, TypeArray.get(), Storage, ShouldCreate);\n  }\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, Metadata *TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDISubroutineType cloneImpl() const {\n    return getTemporary(getContext(), getFlags(), getCC(), getTypeArray());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, DITypeRefArray TypeArray),\n                    (Flags, CC, TypeArray))\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, Metadata *TypeArray),\n                    (Flags, CC, TypeArray))\n\n  TempDISubroutineType clone() const { return cloneImpl(); }\n\n  uint8_t getCC() const { return CC; }\n\n  DITypeRefArray getTypeArray() const {\n    return cast_or_null<MDTuple>(getRawTypeArray());\n  }\n\n  Metadata *getRawTypeArray() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubroutineTypeKind;\n  }\n};\n\n/// Compile unit.\nclass DICompileUnit : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  enum DebugEmissionKind : unsigned {\n    NoDebug = 0,\n    FullDebug,\n    LineTablesOnly,\n    DebugDirectivesOnly,\n    LastEmissionKind = DebugDirectivesOnly\n  };\n\n  enum class DebugNameTableKind : unsigned {\n    Default = 0,\n    GNU = 1,\n    None = 2,\n    LastDebugNameTableKind = None\n  };\n\n  static Optional<DebugEmissionKind> getEmissionKind(StringRef Str);\n  static const char *emissionKindString(DebugEmissionKind EK);\n  static Optional<DebugNameTableKind> getNameTableKind(StringRef Str);\n  static const char *nameTableKindString(DebugNameTableKind PK);\n\nprivate:\n  unsigned SourceLanguage;\n  bool IsOptimized;\n  unsigned RuntimeVersion;\n  unsigned EmissionKind;\n  uint64_t DWOId;\n  bool SplitDebugInlining;\n  bool DebugInfoForProfiling;\n  unsigned NameTableKind;\n  bool RangesBaseAddress;\n\n  DICompileUnit(LLVMContext &C, StorageType Storage, unsigned SourceLanguage,\n                bool IsOptimized, unsigned RuntimeVersion,\n                unsigned EmissionKind, uint64_t DWOId, bool SplitDebugInlining,\n                bool DebugInfoForProfiling, unsigned NameTableKind,\n                bool RangesBaseAddress, ArrayRef<Metadata *> Ops)\n      : DIScope(C, DICompileUnitKind, Storage, dwarf::DW_TAG_compile_unit, Ops),\n        SourceLanguage(SourceLanguage), IsOptimized(IsOptimized),\n        RuntimeVersion(RuntimeVersion), EmissionKind(EmissionKind),\n        DWOId(DWOId), SplitDebugInlining(SplitDebugInlining),\n        DebugInfoForProfiling(DebugInfoForProfiling),\n        NameTableKind(NameTableKind), RangesBaseAddress(RangesBaseAddress) {\n    assert(Storage != Uniqued);\n  }\n  ~DICompileUnit() = default;\n\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, DIFile *File,\n          StringRef Producer, bool IsOptimized, StringRef Flags,\n          unsigned RuntimeVersion, StringRef SplitDebugFilename,\n          unsigned EmissionKind, DICompositeTypeArray EnumTypes,\n          DIScopeArray RetainedTypes,\n          DIGlobalVariableExpressionArray GlobalVariables,\n          DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n          uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n          unsigned NameTableKind, bool RangesBaseAddress, StringRef SysRoot,\n          StringRef SDK, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, SourceLanguage, File, getCanonicalMDString(Context, Producer),\n        IsOptimized, getCanonicalMDString(Context, Flags), RuntimeVersion,\n        getCanonicalMDString(Context, SplitDebugFilename), EmissionKind,\n        EnumTypes.get(), RetainedTypes.get(), GlobalVariables.get(),\n        ImportedEntities.get(), Macros.get(), DWOId, SplitDebugInlining,\n        DebugInfoForProfiling, NameTableKind, RangesBaseAddress,\n        getCanonicalMDString(Context, SysRoot),\n        getCanonicalMDString(Context, SDK), Storage, ShouldCreate);\n  }\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, Metadata *File,\n          MDString *Producer, bool IsOptimized, MDString *Flags,\n          unsigned RuntimeVersion, MDString *SplitDebugFilename,\n          unsigned EmissionKind, Metadata *EnumTypes, Metadata *RetainedTypes,\n          Metadata *GlobalVariables, Metadata *ImportedEntities,\n          Metadata *Macros, uint64_t DWOId, bool SplitDebugInlining,\n          bool DebugInfoForProfiling, unsigned NameTableKind,\n          bool RangesBaseAddress, MDString *SysRoot, MDString *SDK,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompileUnit cloneImpl() const {\n    return getTemporary(\n        getContext(), getSourceLanguage(), getFile(), getProducer(),\n        isOptimized(), getFlags(), getRuntimeVersion(), getSplitDebugFilename(),\n        getEmissionKind(), getEnumTypes(), getRetainedTypes(),\n        getGlobalVariables(), getImportedEntities(), getMacros(), DWOId,\n        getSplitDebugInlining(), getDebugInfoForProfiling(), getNameTableKind(),\n        getRangesBaseAddress(), getSysRoot(), getSDK());\n  }\n\npublic:\n  static void get() = delete;\n  static void getIfExists() = delete;\n\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, DIFile *File, StringRef Producer,\n       bool IsOptimized, StringRef Flags, unsigned RuntimeVersion,\n       StringRef SplitDebugFilename, DebugEmissionKind EmissionKind,\n       DICompositeTypeArray EnumTypes, DIScopeArray RetainedTypes,\n       DIGlobalVariableExpressionArray GlobalVariables,\n       DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n       uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n       DebugNameTableKind NameTableKind, bool RangesBaseAddress,\n       StringRef SysRoot, StringRef SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, (unsigned)NameTableKind, RangesBaseAddress,\n       SysRoot, SDK))\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, Metadata *File, MDString *Producer,\n       bool IsOptimized, MDString *Flags, unsigned RuntimeVersion,\n       MDString *SplitDebugFilename, unsigned EmissionKind, Metadata *EnumTypes,\n       Metadata *RetainedTypes, Metadata *GlobalVariables,\n       Metadata *ImportedEntities, Metadata *Macros, uint64_t DWOId,\n       bool SplitDebugInlining, bool DebugInfoForProfiling,\n       unsigned NameTableKind, bool RangesBaseAddress, MDString *SysRoot,\n       MDString *SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, NameTableKind, RangesBaseAddress, SysRoot, SDK))\n\n  TempDICompileUnit clone() const { return cloneImpl(); }\n\n  unsigned getSourceLanguage() const { return SourceLanguage; }\n  bool isOptimized() const { return IsOptimized; }\n  unsigned getRuntimeVersion() const { return RuntimeVersion; }\n  DebugEmissionKind getEmissionKind() const {\n    return (DebugEmissionKind)EmissionKind;\n  }\n  bool isDebugDirectivesOnly() const {\n    return EmissionKind == DebugDirectivesOnly;\n  }\n  bool getDebugInfoForProfiling() const { return DebugInfoForProfiling; }\n  DebugNameTableKind getNameTableKind() const {\n    return (DebugNameTableKind)NameTableKind;\n  }\n  bool getRangesBaseAddress() const { return RangesBaseAddress; }\n  StringRef getProducer() const { return getStringOperand(1); }\n  StringRef getFlags() const { return getStringOperand(2); }\n  StringRef getSplitDebugFilename() const { return getStringOperand(3); }\n  DICompositeTypeArray getEnumTypes() const {\n    return cast_or_null<MDTuple>(getRawEnumTypes());\n  }\n  DIScopeArray getRetainedTypes() const {\n    return cast_or_null<MDTuple>(getRawRetainedTypes());\n  }\n  DIGlobalVariableExpressionArray getGlobalVariables() const {\n    return cast_or_null<MDTuple>(getRawGlobalVariables());\n  }\n  DIImportedEntityArray getImportedEntities() const {\n    return cast_or_null<MDTuple>(getRawImportedEntities());\n  }\n  DIMacroNodeArray getMacros() const {\n    return cast_or_null<MDTuple>(getRawMacros());\n  }\n  uint64_t getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t DwoId) { DWOId = DwoId; }\n  bool getSplitDebugInlining() const { return SplitDebugInlining; }\n  void setSplitDebugInlining(bool SplitDebugInlining) {\n    this->SplitDebugInlining = SplitDebugInlining;\n  }\n  StringRef getSysRoot() const { return getStringOperand(9); }\n  StringRef getSDK() const { return getStringOperand(10); }\n\n  MDString *getRawProducer() const { return getOperandAs<MDString>(1); }\n  MDString *getRawFlags() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSplitDebugFilename() const {\n    return getOperandAs<MDString>(3);\n  }\n  Metadata *getRawEnumTypes() const { return getOperand(4); }\n  Metadata *getRawRetainedTypes() const { return getOperand(5); }\n  Metadata *getRawGlobalVariables() const { return getOperand(6); }\n  Metadata *getRawImportedEntities() const { return getOperand(7); }\n  Metadata *getRawMacros() const { return getOperand(8); }\n  MDString *getRawSysRoot() const { return getOperandAs<MDString>(9); }\n  MDString *getRawSDK() const { return getOperandAs<MDString>(10); }\n\n  /// Replace arrays.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), it will be RAUW'ed and\n  /// deleted on a uniquing collision.  In practice, uniquing collisions on \\a\n  /// DICompileUnit should be fairly rare.\n  /// @{\n  void replaceEnumTypes(DICompositeTypeArray N) {\n    replaceOperandWith(4, N.get());\n  }\n  void replaceRetainedTypes(DITypeArray N) {\n    replaceOperandWith(5, N.get());\n  }\n  void replaceGlobalVariables(DIGlobalVariableExpressionArray N) {\n    replaceOperandWith(6, N.get());\n  }\n  void replaceImportedEntities(DIImportedEntityArray N) {\n    replaceOperandWith(7, N.get());\n  }\n  void replaceMacros(DIMacroNodeArray N) { replaceOperandWith(8, N.get()); }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompileUnitKind;\n  }\n};\n\n/// A scope for locals.\n///\n/// A legal scope for lexical blocks, local variables, and debug info\n/// locations.  Subclasses are \\a DISubprogram, \\a DILexicalBlock, and \\a\n/// DILexicalBlockFile.\nclass DILocalScope : public DIScope {\nprotected:\n  DILocalScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n               ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {}\n  ~DILocalScope() = default;\n\npublic:\n  /// Get the subprogram for this scope.\n  ///\n  /// Return this if it's an \\a DISubprogram; otherwise, look up the scope\n  /// chain.\n  DISubprogram *getSubprogram() const;\n\n  /// Get the first non DILexicalBlockFile scope of this scope.\n  ///\n  /// Return this if it's not a \\a DILexicalBlockFIle; otherwise, look up the\n  /// scope chain.\n  DILocalScope *getNonLexicalBlockFileScope() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind ||\n           MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\n/// Debug location.\n///\n/// A debug location in source code, used for debug info and otherwise.\nclass DILocation : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DILocation(LLVMContext &C, StorageType Storage, unsigned Line,\n             unsigned Column, ArrayRef<Metadata *> MDs, bool ImplicitCode);\n  ~DILocation() { dropAllReferences(); }\n\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, Metadata *Scope,\n                             Metadata *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true);\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, DILocalScope *Scope,\n                             DILocation *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Line, Column, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(InlinedAt), ImplicitCode, Storage,\n                   ShouldCreate);\n  }\n\n  /// With a given unsigned int \\p U, use up to 13 bits to represent it.\n  /// old_bit 1~5  --> new_bit 1~5\n  /// old_bit 6~12 --> new_bit 7~13\n  /// new_bit_6 is 0 if higher bits (7~13) are all 0\n  static unsigned getPrefixEncodingFromUnsigned(unsigned U) {\n    U &= 0xfff;\n    return U > 0x1f ? (((U & 0xfe0) << 1) | (U & 0x1f) | 0x20) : U;\n  }\n\n  /// Reverse transformation as getPrefixEncodingFromUnsigned.\n  static unsigned getUnsignedFromPrefixEncoding(unsigned U) {\n    if (U & 1)\n      return 0;\n    U >>= 1;\n    return (U & 0x20) ? (((U >> 1) & 0xfe0) | (U & 0x1f)) : (U & 0x1f);\n  }\n\n  /// Returns the next component stored in discriminator.\n  static unsigned getNextComponentInDiscriminator(unsigned D) {\n    if ((D & 1) == 0)\n      return D >> ((D & 0x40) ? 14 : 7);\n    else\n      return D >> 1;\n  }\n\n  TempDILocation cloneImpl() const {\n    // Get the raw scope/inlinedAt since it is possible to invoke this on\n    // a DILocation containing temporary metadata.\n    return getTemporary(getContext(), getLine(), getColumn(), getRawScope(),\n                        getRawInlinedAt(), isImplicitCode());\n  }\n\n  static unsigned encodeComponent(unsigned C) {\n    return (C == 0) ? 1U : (getPrefixEncodingFromUnsigned(C) << 1);\n  }\n\n  static unsigned encodingBits(unsigned C) {\n    return (C == 0) ? 1 : (C > 0x1f ? 14 : 7);\n  }\n\npublic:\n  // Disallow replacing operands.\n  void replaceOperandWith(unsigned I, Metadata *New) = delete;\n\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, Metadata *Scope,\n                     Metadata *InlinedAt = nullptr, bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, DILocalScope *Scope,\n                     DILocation *InlinedAt = nullptr,\n                     bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n\n  /// Return a (temporary) clone of this.\n  TempDILocation clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return SubclassData32; }\n  unsigned getColumn() const { return SubclassData16; }\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  DILocation *getInlinedAt() const {\n    return cast_or_null<DILocation>(getRawInlinedAt());\n  }\n\n  /// Check if the location corresponds to an implicit code.\n  /// When the ImplicitCode flag is true, it means that the Instruction\n  /// with this DILocation has been added by the front-end but it hasn't been\n  /// written explicitly by the user (e.g. cleanup stuff in C++ put on a closing\n  /// bracket). It's useful for code coverage to not show a counter on \"empty\"\n  /// lines.\n  bool isImplicitCode() const { return SubclassData1; }\n  void setImplicitCode(bool ImplicitCode) { SubclassData1 = ImplicitCode; }\n\n  DIFile *getFile() const { return getScope()->getFile(); }\n  StringRef getFilename() const { return getScope()->getFilename(); }\n  StringRef getDirectory() const { return getScope()->getDirectory(); }\n  Optional<StringRef> getSource() const { return getScope()->getSource(); }\n\n  /// Get the scope where this is inlined.\n  ///\n  /// Walk through \\a getInlinedAt() and return \\a getScope() from the deepest\n  /// location.\n  DILocalScope *getInlinedAtScope() const {\n    if (auto *IA = getInlinedAt())\n      return IA->getInlinedAtScope();\n    return getScope();\n  }\n\n  /// Get the DWARF discriminator.\n  ///\n  /// DWARF discriminators distinguish identical file locations between\n  /// instructions that are on different basic blocks.\n  ///\n  /// There are 3 components stored in discriminator, from lower bits:\n  ///\n  /// Base discriminator: assigned by AddDiscriminators pass to identify IRs\n  ///                     that are defined by the same source line, but\n  ///                     different basic blocks.\n  /// Duplication factor: assigned by optimizations that will scale down\n  ///                     the execution frequency of the original IR.\n  /// Copy Identifier: assigned by optimizations that clones the IR.\n  ///                  Each copy of the IR will be assigned an identifier.\n  ///\n  /// Encoding:\n  ///\n  /// The above 3 components are encoded into a 32bit unsigned integer in\n  /// order. If the lowest bit is 1, the current component is empty, and the\n  /// next component will start in the next bit. Otherwise, the current\n  /// component is non-empty, and its content starts in the next bit. The\n  /// value of each components is either 5 bit or 12 bit: if the 7th bit\n  /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the\n  /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to\n  /// represent the component. Thus, the number of bits used for a component\n  /// is either 0 (if it and all the next components are empty); 1 - if it is\n  /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both\n  /// 0); or 14, if its value is up to and including 0x1ff. Note that the last\n  /// component is also capped at 0x1ff, even in the case when both first\n  /// components are 0, and we'd technically have 29 bits available.\n  ///\n  /// For precise control over the data being encoded in the discriminator,\n  /// use encodeDiscriminator/decodeDiscriminator.\n\n  inline unsigned getDiscriminator() const;\n\n  // For the regular discriminator, it stands for all empty components if all\n  // the lowest 3 bits are non-zero and all higher 29 bits are unused(zero by\n  // default). Here we fully leverage the higher 29 bits for pseudo probe use.\n  // This is the format:\n  // [2:0] - 0x7\n  // [31:3] - pseudo probe fields guaranteed to be non-zero as a whole\n  // So if the lower 3 bits is non-zero and the others has at least one\n  // non-zero bit, it guarantees to be a pseudo probe discriminator\n  inline static bool isPseudoProbeDiscriminator(unsigned Discriminator) {\n    return ((Discriminator & 0x7) == 0x7) && (Discriminator & 0xFFFFFFF8);\n  }\n\n  /// Returns a new DILocation with updated \\p Discriminator.\n  inline const DILocation *cloneWithDiscriminator(unsigned Discriminator) const;\n\n  /// Returns a new DILocation with updated base discriminator \\p BD. Only the\n  /// base discriminator is set in the new DILocation, the other encoded values\n  /// are elided.\n  /// If the discriminator cannot be encoded, the function returns None.\n  inline Optional<const DILocation *> cloneWithBaseDiscriminator(unsigned BD) const;\n\n  /// Returns the duplication factor stored in the discriminator, or 1 if no\n  /// duplication factor (or 0) is encoded.\n  inline unsigned getDuplicationFactor() const;\n\n  /// Returns the copy identifier stored in the discriminator.\n  inline unsigned getCopyIdentifier() const;\n\n  /// Returns the base discriminator stored in the discriminator.\n  inline unsigned getBaseDiscriminator() const;\n\n  /// Returns a new DILocation with duplication factor \\p DF * current\n  /// duplication factor encoded in the discriminator. The current duplication\n  /// factor is as defined by getDuplicationFactor().\n  /// Returns None if encoding failed.\n  inline Optional<const DILocation *> cloneByMultiplyingDuplicationFactor(unsigned DF) const;\n\n  /// When two instructions are combined into a single instruction we also\n  /// need to combine the original locations into a single location.\n  ///\n  /// When the locations are the same we can use either location. When they\n  /// differ, we need a third location which is distinct from either. If they\n  /// have the same file/line but have a different discriminator we could\n  /// create a location with a new discriminator. If they are from different\n  /// files/lines the location is ambiguous and can't be represented in a line\n  /// entry. In this case, if \\p GenerateLocation is true, we will set the\n  /// merged debug location as line 0 of the nearest common scope where the two\n  /// locations are inlined from.\n  ///\n  /// \\p GenerateLocation: Whether the merged location can be generated when\n  /// \\p LocA and \\p LocB differ.\n  static const DILocation *getMergedLocation(const DILocation *LocA,\n                                             const DILocation *LocB);\n\n  /// Try to combine the vector of locations passed as input in a single one.\n  /// This function applies getMergedLocation() repeatedly left-to-right.\n  ///\n  /// \\p Locs: The locations to be merged.\n  static\n  const DILocation *getMergedLocations(ArrayRef<const DILocation *> Locs);\n\n  /// Returns the base discriminator for a given encoded discriminator \\p D.\n  static unsigned getBaseDiscriminatorFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(D);\n  }\n\n  /// Raw encoding of the discriminator. APIs such as cloneWithDuplicationFactor\n  /// have certain special case behavior (e.g. treating empty duplication factor\n  /// as the value '1').\n  /// This API, in conjunction with cloneWithDiscriminator, may be used to encode\n  /// the raw values provided. \\p BD: base discriminator \\p DF: duplication factor\n  /// \\p CI: copy index\n  /// The return is None if the values cannot be encoded in 32 bits - for\n  /// example, values for BD or DF larger than 12 bits. Otherwise, the return\n  /// is the encoded value.\n  static Optional<unsigned> encodeDiscriminator(unsigned BD, unsigned DF, unsigned CI);\n\n  /// Raw decoder for values in an encoded discriminator D.\n  static void decodeDiscriminator(unsigned D, unsigned &BD, unsigned &DF,\n                                  unsigned &CI);\n\n  /// Returns the duplication factor for a given encoded discriminator \\p D, or\n  /// 1 if no value or 0 is encoded.\n  static unsigned getDuplicationFactorFromDiscriminator(unsigned D) {\n    D = getNextComponentInDiscriminator(D);\n    unsigned Ret = getUnsignedFromPrefixEncoding(D);\n    if (Ret == 0)\n      return 1;\n    return Ret;\n  }\n\n  /// Returns the copy identifier for a given encoded discriminator \\p D.\n  static unsigned getCopyIdentifierFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(getNextComponentInDiscriminator(\n        getNextComponentInDiscriminator(D)));\n  }\n\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawInlinedAt() const {\n    if (getNumOperands() == 2)\n      return getOperand(1);\n    return nullptr;\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocationKind;\n  }\n};\n\n/// Subprogram description.\nclass DISubprogram : public DILocalScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned ScopeLine;\n  unsigned VirtualIndex;\n\n  /// In the MS ABI, the implicit 'this' parameter is adjusted in the prologue\n  /// of method overrides from secondary bases by this amount. It may be\n  /// negative.\n  int ThisAdjustment;\n\npublic:\n  /// Debug info subprogram flags.\n  enum DISPFlags : uint32_t {\n#define HANDLE_DISP_FLAG(ID, NAME) SPFlag##NAME = ID,\n#define DISP_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    SPFlagNonvirtual = SPFlagZero,\n    SPFlagVirtuality = SPFlagVirtual | SPFlagPureVirtual,\n    LLVM_MARK_AS_BITMASK_ENUM(SPFlagLargest)\n  };\n\n  static DISPFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DISPFlags Flag);\n\n  /// Split up a flags bitfield for easier printing.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DISPFlags splitFlags(DISPFlags Flags,\n                              SmallVectorImpl<DISPFlags> &SplitFlags);\n\n  // Helper for converting old bitfields to new flags word.\n  static DISPFlags toSPFlags(bool IsLocalToUnit, bool IsDefinition,\n                             bool IsOptimized,\n                             unsigned Virtuality = SPFlagNonvirtual,\n                             bool IsMainSubprogram = false) {\n    // We're assuming virtuality is the low-order field.\n    static_assert(\n        int(SPFlagVirtual) == int(dwarf::DW_VIRTUALITY_virtual) &&\n            int(SPFlagPureVirtual) == int(dwarf::DW_VIRTUALITY_pure_virtual),\n        \"Virtuality constant mismatch\");\n    return static_cast<DISPFlags>(\n        (Virtuality & SPFlagVirtuality) |\n        (IsLocalToUnit ? SPFlagLocalToUnit : SPFlagZero) |\n        (IsDefinition ? SPFlagDefinition : SPFlagZero) |\n        (IsOptimized ? SPFlagOptimized : SPFlagZero) |\n        (IsMainSubprogram ? SPFlagMainSubprogram : SPFlagZero));\n  }\n\nprivate:\n  DIFlags Flags;\n  DISPFlags SPFlags;\n\n  DISubprogram(LLVMContext &C, StorageType Storage, unsigned Line,\n               unsigned ScopeLine, unsigned VirtualIndex, int ThisAdjustment,\n               DIFlags Flags, DISPFlags SPFlags, ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, DISubprogramKind, Storage, dwarf::DW_TAG_subprogram,\n                     Ops),\n        Line(Line), ScopeLine(ScopeLine), VirtualIndex(VirtualIndex),\n        ThisAdjustment(ThisAdjustment), Flags(Flags), SPFlags(SPFlags) {\n    static_assert(dwarf::DW_VIRTUALITY_max < 4, \"Virtuality out of range\");\n  }\n  ~DISubprogram() = default;\n\n  static DISubprogram *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line,\n          DISubroutineType *Type, unsigned ScopeLine, DIType *ContainingType,\n          unsigned VirtualIndex, int ThisAdjustment, DIFlags Flags,\n          DISPFlags SPFlags, DICompileUnit *Unit,\n          DITemplateParameterArray TemplateParams, DISubprogram *Declaration,\n          DINodeArray RetainedNodes, DITypeArray ThrownTypes,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   ScopeLine, ContainingType, VirtualIndex, ThisAdjustment,\n                   Flags, SPFlags, Unit, TemplateParams.get(), Declaration,\n                   RetainedNodes.get(), ThrownTypes.get(), Storage,\n                   ShouldCreate);\n  }\n  static DISubprogram *getImpl(LLVMContext &Context, Metadata *Scope,\n                               MDString *Name, MDString *LinkageName,\n                               Metadata *File, unsigned Line, Metadata *Type,\n                               unsigned ScopeLine, Metadata *ContainingType,\n                               unsigned VirtualIndex, int ThisAdjustment,\n                               DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n                               Metadata *TemplateParams, Metadata *Declaration,\n                               Metadata *RetainedNodes, Metadata *ThrownTypes,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDISubprogram cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), getScopeLine(),\n                        getContainingType(), getVirtualIndex(),\n                        getThisAdjustment(), getFlags(), getSPFlags(),\n                        getUnit(), getTemplateParams(), getDeclaration(),\n                        getRetainedNodes(), getThrownTypes());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (DIScope * Scope, StringRef Name, StringRef LinkageName, DIFile *File,\n       unsigned Line, DISubroutineType *Type, unsigned ScopeLine,\n       DIType *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, DICompileUnit *Unit,\n       DITemplateParameterArray TemplateParams = nullptr,\n       DISubprogram *Declaration = nullptr, DINodeArray RetainedNodes = nullptr,\n       DITypeArray ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,\n       unsigned Line, Metadata *Type, unsigned ScopeLine,\n       Metadata *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n       Metadata *TemplateParams = nullptr, Metadata *Declaration = nullptr,\n       Metadata *RetainedNodes = nullptr, Metadata *ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  TempDISubprogram clone() const { return cloneImpl(); }\n\n  /// Returns a new temporary DISubprogram with updated Flags\n  TempDISubprogram cloneWithFlags(DIFlags NewFlags) const {\n    auto NewSP = clone();\n    NewSP->Flags = NewFlags;\n    return NewSP;\n  }\n\npublic:\n  unsigned getLine() const { return Line; }\n  unsigned getVirtuality() const { return getSPFlags() & SPFlagVirtuality; }\n  unsigned getVirtualIndex() const { return VirtualIndex; }\n  int getThisAdjustment() const { return ThisAdjustment; }\n  unsigned getScopeLine() const { return ScopeLine; }\n  void setScopeLine(unsigned L) { assert(isDistinct()); ScopeLine = L; }\n  DIFlags getFlags() const { return Flags; }\n  DISPFlags getSPFlags() const { return SPFlags; }\n  bool isLocalToUnit() const { return getSPFlags() & SPFlagLocalToUnit; }\n  bool isDefinition() const { return getSPFlags() & SPFlagDefinition; }\n  bool isOptimized() const { return getSPFlags() & SPFlagOptimized; }\n  bool isMainSubprogram() const { return getSPFlags() & SPFlagMainSubprogram; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isExplicit() const { return getFlags() & FlagExplicit; }\n  bool isPrototyped() const { return getFlags() & FlagPrototyped; }\n  bool areAllCallsDescribed() const {\n    return getFlags() & FlagAllCallsDescribed;\n  }\n  bool isPure() const { return getSPFlags() & SPFlagPure; }\n  bool isElemental() const { return getSPFlags() & SPFlagElemental; }\n  bool isRecursive() const { return getSPFlags() & SPFlagRecursive; }\n  bool isObjCDirect() const { return getSPFlags() & SPFlagObjCDirect; }\n\n  /// Check if this is deleted member function.\n  ///\n  /// Return true if this subprogram is a C++11 special\n  /// member function declared deleted.\n  bool isDeleted() const { return getSPFlags() & SPFlagDeleted; }\n\n  /// Check if this is reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 reference-qualified non-static\n  /// member function (void foo() &).\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n\n  /// Check if this is rvalue-reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 rvalue-reference-qualified\n  /// non-static member function (void foo() &&).\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n\n  /// Check if this is marked as noreturn.\n  ///\n  /// Return true if this subprogram is C++11 noreturn or C11 _Noreturn\n  bool isNoReturn() const { return getFlags() & FlagNoReturn; }\n\n  // Check if this routine is a compiler-generated thunk.\n  //\n  // Returns true if this subprogram is a thunk generated by the compiler.\n  bool isThunk() const { return getFlags() & FlagThunk; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getLinkageName() const { return getStringOperand(3); }\n\n  DISubroutineType *getType() const {\n    return cast_or_null<DISubroutineType>(getRawType());\n  }\n  DIType *getContainingType() const {\n    return cast_or_null<DIType>(getRawContainingType());\n  }\n\n  DICompileUnit *getUnit() const {\n    return cast_or_null<DICompileUnit>(getRawUnit());\n  }\n  void replaceUnit(DICompileUnit *CU) { replaceOperandWith(5, CU); }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  DISubprogram *getDeclaration() const {\n    return cast_or_null<DISubprogram>(getRawDeclaration());\n  }\n  DINodeArray getRetainedNodes() const {\n    return cast_or_null<MDTuple>(getRawRetainedNodes());\n  }\n  DITypeArray getThrownTypes() const {\n    return cast_or_null<MDTuple>(getRawThrownTypes());\n  }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n  Metadata *getRawUnit() const { return getOperand(5); }\n  Metadata *getRawDeclaration() const { return getOperand(6); }\n  Metadata *getRawRetainedNodes() const { return getOperand(7); }\n  Metadata *getRawContainingType() const {\n    return getNumOperands() > 8 ? getOperandAs<Metadata>(8) : nullptr;\n  }\n  Metadata *getRawTemplateParams() const {\n    return getNumOperands() > 9 ? getOperandAs<Metadata>(9) : nullptr;\n  }\n  Metadata *getRawThrownTypes() const {\n    return getNumOperands() > 10 ? getOperandAs<Metadata>(10) : nullptr;\n  }\n\n  void replaceRawLinkageName(MDString *LinkageName) {\n    replaceOperandWith(3, LinkageName);\n  }\n\n  /// Check if this subprogram describes the given function.\n  ///\n  /// FIXME: Should this be looking through bitcasts?\n  bool describes(const Function *F) const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind;\n  }\n};\n\nclass DILexicalBlockBase : public DILocalScope {\nprotected:\n  DILexicalBlockBase(LLVMContext &C, unsigned ID, StorageType Storage,\n                     ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, ID, Storage, dwarf::DW_TAG_lexical_block, Ops) {}\n  ~DILexicalBlockBase() = default;\n\npublic:\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nclass DILexicalBlock : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  uint16_t Column;\n\n  DILexicalBlock(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Column, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockKind, Storage, Ops), Line(Line),\n        Column(Column) {\n    assert(Column < (1u << 16) && \"Expected 16-bit column\");\n  }\n  ~DILexicalBlock() = default;\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                 DIFile *File, unsigned Line, unsigned Column,\n                                 StorageType Storage,\n                                 bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Line, Column, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                 Metadata *File, unsigned Line, unsigned Column,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDILexicalBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(), getLine(),\n                        getColumn());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlock, (DILocalScope * Scope, DIFile *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n  DEFINE_MDNODE_GET(DILexicalBlock, (Metadata * Scope, Metadata *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n\n  TempDILexicalBlock clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getColumn() const { return Column; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind;\n  }\n};\n\nclass DILexicalBlockFile : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Discriminator;\n\n  DILexicalBlockFile(LLVMContext &C, StorageType Storage,\n                     unsigned Discriminator, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockFileKind, Storage, Ops),\n        Discriminator(Discriminator) {}\n  ~DILexicalBlockFile() = default;\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                     DIFile *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Discriminator, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, Metadata *Scope,\n                                     Metadata *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true);\n\n  TempDILexicalBlockFile cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(),\n                        getDiscriminator());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlockFile, (DILocalScope * Scope, DIFile *File,\n                                         unsigned Discriminator),\n                    (Scope, File, Discriminator))\n  DEFINE_MDNODE_GET(DILexicalBlockFile,\n                    (Metadata * Scope, Metadata *File, unsigned Discriminator),\n                    (Scope, File, Discriminator))\n\n  TempDILexicalBlockFile clone() const { return cloneImpl(); }\n  unsigned getDiscriminator() const { return Discriminator; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nunsigned DILocation::getDiscriminator() const {\n  if (auto *F = dyn_cast<DILexicalBlockFile>(getScope()))\n    return F->getDiscriminator();\n  return 0;\n}\n\nconst DILocation *\nDILocation::cloneWithDiscriminator(unsigned Discriminator) const {\n  DIScope *Scope = getScope();\n  // Skip all parent DILexicalBlockFile that already have a discriminator\n  // assigned. We do not want to have nested DILexicalBlockFiles that have\n  // mutliple discriminators because only the leaf DILexicalBlockFile's\n  // dominator will be used.\n  for (auto *LBF = dyn_cast<DILexicalBlockFile>(Scope);\n       LBF && LBF->getDiscriminator() != 0;\n       LBF = dyn_cast<DILexicalBlockFile>(Scope))\n    Scope = LBF->getScope();\n  DILexicalBlockFile *NewScope =\n      DILexicalBlockFile::get(getContext(), Scope, getFile(), Discriminator);\n  return DILocation::get(getContext(), getLine(), getColumn(), NewScope,\n                         getInlinedAt());\n}\n\nunsigned DILocation::getBaseDiscriminator() const {\n  return getBaseDiscriminatorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getDuplicationFactor() const {\n  return getDuplicationFactorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getCopyIdentifier() const {\n  return getCopyIdentifierFromDiscriminator(getDiscriminator());\n}\n\nOptional<const DILocation *> DILocation::cloneWithBaseDiscriminator(unsigned D) const {\n  unsigned BD, DF, CI;\n  decodeDiscriminator(getDiscriminator(), BD, DF, CI);\n  if (D == BD)\n    return this;\n  if (Optional<unsigned> Encoded = encodeDiscriminator(D, DF, CI))\n    return cloneWithDiscriminator(*Encoded);\n  return None;\n}\n\nOptional<const DILocation *> DILocation::cloneByMultiplyingDuplicationFactor(unsigned DF) const {\n  DF *= getDuplicationFactor();\n  if (DF <= 1)\n    return this;\n\n  unsigned BD = getBaseDiscriminator();\n  unsigned CI = getCopyIdentifier();\n  if (Optional<unsigned> D = encodeDiscriminator(BD, DF, CI))\n    return cloneWithDiscriminator(*D);\n  return None;\n}\n\nclass DINamespace : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned ExportSymbols : 1;\n\n  DINamespace(LLVMContext &Context, StorageType Storage, bool ExportSymbols,\n              ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DINamespaceKind, Storage, dwarf::DW_TAG_namespace,\n                Ops),\n        ExportSymbols(ExportSymbols) {}\n  ~DINamespace() = default;\n\n  static DINamespace *getImpl(LLVMContext &Context, DIScope *Scope,\n                              StringRef Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   ExportSymbols, Storage, ShouldCreate);\n  }\n  static DINamespace *getImpl(LLVMContext &Context, Metadata *Scope,\n                              MDString *Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDINamespace cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(),\n                        getExportSymbols());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DINamespace,\n                    (DIScope *Scope, StringRef Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n  DEFINE_MDNODE_GET(DINamespace,\n                    (Metadata *Scope, MDString *Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n\n  TempDINamespace clone() const { return cloneImpl(); }\n\n  bool getExportSymbols() const { return ExportSymbols; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DINamespaceKind;\n  }\n};\n\n/// Represents a module in the programming language, for example, a Clang\n/// module, or a Fortran module.\nclass DIModule : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  unsigned LineNo;\n  bool IsDecl;\n\n  DIModule(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n           bool IsDecl, ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DIModuleKind, Storage, dwarf::DW_TAG_module, Ops),\n        LineNo(LineNo), IsDecl(IsDecl) {}\n  ~DIModule() = default;\n\n  static DIModule *getImpl(LLVMContext &Context, DIFile *File, DIScope *Scope,\n                           StringRef Name, StringRef ConfigurationMacros,\n                           StringRef IncludePath, StringRef APINotesFile,\n                           unsigned LineNo, bool IsDecl, StorageType Storage,\n                           bool ShouldCreate = true) {\n    return getImpl(Context, File, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, ConfigurationMacros),\n                   getCanonicalMDString(Context, IncludePath),\n                   getCanonicalMDString(Context, APINotesFile), LineNo, IsDecl,\n                   Storage, ShouldCreate);\n  }\n  static DIModule *getImpl(LLVMContext &Context, Metadata *File,\n                           Metadata *Scope, MDString *Name,\n                           MDString *ConfigurationMacros, MDString *IncludePath,\n                           MDString *APINotesFile, unsigned LineNo, bool IsDecl,\n                           StorageType Storage, bool ShouldCreate = true);\n\n  TempDIModule cloneImpl() const {\n    return getTemporary(getContext(), getFile(), getScope(), getName(),\n                        getConfigurationMacros(), getIncludePath(),\n                        getAPINotesFile(), getLineNo(), getIsDecl());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIModule,\n                    (DIFile * File, DIScope *Scope, StringRef Name,\n                     StringRef ConfigurationMacros, StringRef IncludePath,\n                     StringRef APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n  DEFINE_MDNODE_GET(DIModule,\n                    (Metadata * File, Metadata *Scope, MDString *Name,\n                     MDString *ConfigurationMacros, MDString *IncludePath,\n                     MDString *APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n\n  TempDIModule clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getConfigurationMacros() const { return getStringOperand(3); }\n  StringRef getIncludePath() const { return getStringOperand(4); }\n  StringRef getAPINotesFile() const { return getStringOperand(5); }\n  unsigned getLineNo() const { return LineNo; }\n  bool getIsDecl() const { return IsDecl; }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawConfigurationMacros() const {\n    return getOperandAs<MDString>(3);\n  }\n  MDString *getRawIncludePath() const { return getOperandAs<MDString>(4); }\n  MDString *getRawAPINotesFile() const { return getOperandAs<MDString>(5); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIModuleKind;\n  }\n};\n\n/// Base class for template parameters.\nclass DITemplateParameter : public DINode {\nprotected:\n  bool IsDefault;\n\n  DITemplateParameter(LLVMContext &Context, unsigned ID, StorageType Storage,\n                      unsigned Tag, bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DINode(Context, ID, Storage, Tag, Ops), IsDefault(IsDefault) {}\n  ~DITemplateParameter() = default;\n\npublic:\n  StringRef getName() const { return getStringOperand(0); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawType() const { return getOperand(1); }\n  bool isDefault() const { return IsDefault; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind ||\n           MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\nclass DITemplateTypeParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateTypeParameter(LLVMContext &Context, StorageType Storage,\n                          bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateTypeParameterKind, Storage,\n                            dwarf::DW_TAG_template_type_parameter, IsDefault,\n                            Ops) {}\n  ~DITemplateTypeParameter() = default;\n\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, StringRef Name,\n                                          DIType *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Storage, ShouldCreate);\n  }\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, MDString *Name,\n                                          Metadata *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true);\n\n  TempDITemplateTypeParameter cloneImpl() const {\n    return getTemporary(getContext(), getName(), getType(), isDefault());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (StringRef Name, DIType *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (MDString *Name, Metadata *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n\n  TempDITemplateTypeParameter clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind;\n  }\n};\n\nclass DITemplateValueParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateValueParameter(LLVMContext &Context, StorageType Storage,\n                           unsigned Tag, bool IsDefault,\n                           ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateValueParameterKind, Storage, Tag,\n                            IsDefault, Ops) {}\n  ~DITemplateValueParameter() = default;\n\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           StringRef Name, DIType *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Value, Storage, ShouldCreate);\n  }\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           MDString *Name, Metadata *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true);\n\n  TempDITemplateValueParameter cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getType(),\n                        isDefault(), getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, StringRef Name, DIType *Type, bool IsDefault,\n                     Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, MDString *Name, Metadata *Type,\n                     bool IsDefault, Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n\n  TempDITemplateValueParameter clone() const { return cloneImpl(); }\n\n  Metadata *getValue() const { return getOperand(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\n/// Base class for variables.\nclass DIVariable : public DINode {\n  unsigned Line;\n  uint32_t AlignInBits;\n\nprotected:\n  DIVariable(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Line,\n             ArrayRef<Metadata *> Ops, uint32_t AlignInBits = 0)\n      : DINode(C, ID, Storage, dwarf::DW_TAG_variable, Ops), Line(Line),\n        AlignInBits(AlignInBits) {}\n  ~DIVariable() = default;\n\npublic:\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  /// Determines the size of the variable's type.\n  Optional<uint64_t> getSizeInBits() const;\n\n  /// Return the signedness of this variable's type, or None if this type is\n  /// neither signed nor unsigned.\n  Optional<DIBasicType::Signedness> getSignedness() const {\n    if (auto *BT = dyn_cast<DIBasicType>(getType()))\n      return BT->getSignedness();\n    return None;\n  }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  Optional<StringRef> getSource() const {\n    if (auto *F = getFile())\n      return F->getSource();\n    return None;\n  }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n  Metadata *getRawType() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind ||\n           MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\n/// DWARF expression.\n///\n/// This is (almost) a DWARF expression that modifies the location of a\n/// variable, or the location of a single piece of a variable, or (when using\n/// DW_OP_stack_value) is the constant variable value.\n///\n/// TODO: Co-allocate the expression elements.\n/// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary\n/// storage types.\nclass DIExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  std::vector<uint64_t> Elements;\n\n  DIExpression(LLVMContext &C, StorageType Storage, ArrayRef<uint64_t> Elements)\n      : MDNode(C, DIExpressionKind, Storage, None),\n        Elements(Elements.begin(), Elements.end()) {}\n  ~DIExpression() = default;\n\n  static DIExpression *getImpl(LLVMContext &Context,\n                               ArrayRef<uint64_t> Elements, StorageType Storage,\n                               bool ShouldCreate = true);\n\n  TempDIExpression cloneImpl() const {\n    return getTemporary(getContext(), getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIExpression, (ArrayRef<uint64_t> Elements), (Elements))\n\n  TempDIExpression clone() const { return cloneImpl(); }\n\n  ArrayRef<uint64_t> getElements() const { return Elements; }\n\n  unsigned getNumElements() const { return Elements.size(); }\n\n  uint64_t getElement(unsigned I) const {\n    assert(I < Elements.size() && \"Index out of range\");\n    return Elements[I];\n  }\n\n  /// Determine whether this represents a standalone constant value.\n  bool isConstant() const;\n\n  /// Determine whether this represents a standalone signed constant value.\n  bool isSignedConstant() const;\n\n  using element_iterator = ArrayRef<uint64_t>::iterator;\n\n  element_iterator elements_begin() const { return getElements().begin(); }\n  element_iterator elements_end() const { return getElements().end(); }\n\n  /// A lightweight wrapper around an expression operand.\n  ///\n  /// TODO: Store arguments directly and change \\a DIExpression to store a\n  /// range of these.\n  class ExprOperand {\n    const uint64_t *Op = nullptr;\n\n  public:\n    ExprOperand() = default;\n    explicit ExprOperand(const uint64_t *Op) : Op(Op) {}\n\n    const uint64_t *get() const { return Op; }\n\n    /// Get the operand code.\n    uint64_t getOp() const { return *Op; }\n\n    /// Get an argument to the operand.\n    ///\n    /// Never returns the operand itself.\n    uint64_t getArg(unsigned I) const { return Op[I + 1]; }\n\n    unsigned getNumArgs() const { return getSize() - 1; }\n\n    /// Return the size of the operand.\n    ///\n    /// Return the number of elements in the operand (1 + args).\n    unsigned getSize() const;\n\n    /// Append the elements of this operand to \\p V.\n    void appendToVector(SmallVectorImpl<uint64_t> &V) const {\n      V.append(get(), get() + getSize());\n    }\n  };\n\n  /// An iterator for expression operands.\n  class expr_op_iterator\n      : public std::iterator<std::input_iterator_tag, ExprOperand> {\n    ExprOperand Op;\n\n  public:\n    expr_op_iterator() = default;\n    explicit expr_op_iterator(element_iterator I) : Op(I) {}\n\n    element_iterator getBase() const { return Op.get(); }\n    const ExprOperand &operator*() const { return Op; }\n    const ExprOperand *operator->() const { return &Op; }\n\n    expr_op_iterator &operator++() {\n      increment();\n      return *this;\n    }\n    expr_op_iterator operator++(int) {\n      expr_op_iterator T(*this);\n      increment();\n      return T;\n    }\n\n    /// Get the next iterator.\n    ///\n    /// \\a std::next() doesn't work because this is technically an\n    /// input_iterator, but it's a perfectly valid operation.  This is an\n    /// accessor to provide the same functionality.\n    expr_op_iterator getNext() const { return ++expr_op_iterator(*this); }\n\n    bool operator==(const expr_op_iterator &X) const {\n      return getBase() == X.getBase();\n    }\n    bool operator!=(const expr_op_iterator &X) const {\n      return getBase() != X.getBase();\n    }\n\n  private:\n    void increment() { Op = ExprOperand(getBase() + Op.getSize()); }\n  };\n\n  /// Visit the elements via ExprOperand wrappers.\n  ///\n  /// These range iterators visit elements through \\a ExprOperand wrappers.\n  /// This is not guaranteed to be a valid range unless \\a isValid() gives \\c\n  /// true.\n  ///\n  /// \\pre \\a isValid() gives \\c true.\n  /// @{\n  expr_op_iterator expr_op_begin() const {\n    return expr_op_iterator(elements_begin());\n  }\n  expr_op_iterator expr_op_end() const {\n    return expr_op_iterator(elements_end());\n  }\n  iterator_range<expr_op_iterator> expr_ops() const {\n    return {expr_op_begin(), expr_op_end()};\n  }\n  /// @}\n\n  bool isValid() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIExpressionKind;\n  }\n\n  /// Return whether the first element a DW_OP_deref.\n  bool startsWithDeref() const {\n    return getNumElements() > 0 && getElement(0) == dwarf::DW_OP_deref;\n  }\n\n  /// Holds the characteristics of one fragment of a larger variable.\n  struct FragmentInfo {\n    uint64_t SizeInBits;\n    uint64_t OffsetInBits;\n  };\n\n  /// Retrieve the details of this fragment expression.\n  static Optional<FragmentInfo> getFragmentInfo(expr_op_iterator Start,\n                                                expr_op_iterator End);\n\n  /// Retrieve the details of this fragment expression.\n  Optional<FragmentInfo> getFragmentInfo() const {\n    return getFragmentInfo(expr_op_begin(), expr_op_end());\n  }\n\n  /// Return whether this is a piece of an aggregate variable.\n  bool isFragment() const { return getFragmentInfo().hasValue(); }\n\n  /// Return whether this is an implicit location description.\n  bool isImplicit() const;\n\n  /// Return whether the location is computed on the expression stack, meaning\n  /// it cannot be a simple register location.\n  bool isComplex() const;\n\n  /// Append \\p Ops with operations to apply the \\p Offset.\n  static void appendOffset(SmallVectorImpl<uint64_t> &Ops, int64_t Offset);\n\n  /// If this is a constant offset, extract it. If there is no expression,\n  /// return true with an offset of zero.\n  bool extractIfOffset(int64_t &Offset) const;\n\n  /// Checks if the last 4 elements of the expression are DW_OP_constu <DWARF\n  /// Address Space> DW_OP_swap DW_OP_xderef and extracts the <DWARF Address\n  /// Space>.\n  static const DIExpression *extractAddressClass(const DIExpression *Expr,\n                                                 unsigned &AddrClass);\n\n  /// Used for DIExpression::prepend.\n  enum PrependOps : uint8_t {\n    ApplyOffset = 0,\n    DerefBefore = 1 << 0,\n    DerefAfter = 1 << 1,\n    StackValue = 1 << 2,\n    EntryValue = 1 << 3\n  };\n\n  /// Prepend \\p DIExpr with a deref and offset operation and optionally turn it\n  /// into a stack value or/and an entry value.\n  static DIExpression *prepend(const DIExpression *Expr, uint8_t Flags,\n                               int64_t Offset = 0);\n\n  /// Prepend \\p DIExpr with the given opcodes and optionally turn it into a\n  /// stack value.\n  static DIExpression *prependOpcodes(const DIExpression *Expr,\n                                      SmallVectorImpl<uint64_t> &Ops,\n                                      bool StackValue = false,\n                                      bool EntryValue = false);\n\n  /// Append the opcodes \\p Ops to \\p DIExpr. Unlike \\ref appendToStack, the\n  /// returned expression is a stack value only if \\p DIExpr is a stack value.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *append(const DIExpression *Expr, ArrayRef<uint64_t> Ops);\n\n  /// Convert \\p DIExpr into a stack value if it isn't one already by appending\n  /// DW_OP_deref if needed, and appending \\p Ops to the resulting expression.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *appendToStack(const DIExpression *Expr,\n                                     ArrayRef<uint64_t> Ops);\n\n  /// Create a copy of \\p Expr by appending the given list of \\p Ops to each\n  /// instance of the operand `DW_OP_LLVM_arg, \\p ArgNo`. This is used to\n  /// modify a specific location used by \\p Expr, such as when salvaging that\n  /// location.\n  static DIExpression *appendOpsToArg(const DIExpression *Expr,\n                                      ArrayRef<uint64_t> Ops, unsigned ArgNo,\n                                      bool StackValue = false);\n\n  /// Create a copy of \\p Expr with each instance of\n  /// `DW_OP_LLVM_arg, \\p OldArg` replaced with `DW_OP_LLVM_arg, \\p NewArg`,\n  /// and each instance of `DW_OP_LLVM_arg, Arg` with `DW_OP_LLVM_arg, Arg - 1`\n  /// for all Arg > \\p OldArg.\n  /// This is used when replacing one of the operands of a debug value list\n  /// with another operand in the same list and deleting the old operand.\n  static DIExpression *replaceArg(const DIExpression *Expr, uint64_t OldArg,\n                                  uint64_t NewArg);\n\n  /// Create a DIExpression to describe one part of an aggregate variable that\n  /// is fragmented across multiple Values. The DW_OP_LLVM_fragment operation\n  /// will be appended to the elements of \\c Expr. If \\c Expr already contains\n  /// a \\c DW_OP_LLVM_fragment \\c OffsetInBits is interpreted as an offset\n  /// into the existing fragment.\n  ///\n  /// \\param OffsetInBits Offset of the piece in bits.\n  /// \\param SizeInBits   Size of the piece in bits.\n  /// \\return             Creating a fragment expression may fail if \\c Expr\n  ///                     contains arithmetic operations that would be truncated.\n  static Optional<DIExpression *>\n  createFragmentExpression(const DIExpression *Expr, unsigned OffsetInBits,\n                           unsigned SizeInBits);\n\n  /// Determine the relative position of the fragments passed in.\n  /// Returns -1 if this is entirely before Other, 0 if this and Other overlap,\n  /// 1 if this is entirely after Other.\n  static int fragmentCmp(const FragmentInfo &A, const FragmentInfo &B) {\n    uint64_t l1 = A.OffsetInBits;\n    uint64_t l2 = B.OffsetInBits;\n    uint64_t r1 = l1 + A.SizeInBits;\n    uint64_t r2 = l2 + B.SizeInBits;\n    if (r1 <= l2)\n      return -1;\n    else if (r2 <= l1)\n      return 1;\n    else\n      return 0;\n  }\n\n  using ExtOps = std::array<uint64_t, 6>;\n\n  /// Returns the ops for a zero- or sign-extension in a DIExpression.\n  static ExtOps getExtOps(unsigned FromSize, unsigned ToSize, bool Signed);\n\n  /// Append a zero- or sign-extension to \\p Expr. Converts the expression to a\n  /// stack value if it isn't one already.\n  static DIExpression *appendExt(const DIExpression *Expr, unsigned FromSize,\n                                 unsigned ToSize, bool Signed);\n\n  /// Check if fragments overlap between a pair of FragmentInfos.\n  static bool fragmentsOverlap(const FragmentInfo &A, const FragmentInfo &B) {\n    return fragmentCmp(A, B) == 0;\n  }\n\n  /// Determine the relative position of the fragments described by this\n  /// DIExpression and \\p Other. Calls static fragmentCmp implementation.\n  int fragmentCmp(const DIExpression *Other) const {\n    auto Fragment1 = *getFragmentInfo();\n    auto Fragment2 = *Other->getFragmentInfo();\n    return fragmentCmp(Fragment1, Fragment2);\n  }\n\n  /// Check if fragments overlap between this DIExpression and \\p Other.\n  bool fragmentsOverlap(const DIExpression *Other) const {\n    if (!isFragment() || !Other->isFragment())\n      return true;\n    return fragmentCmp(Other) == 0;\n  }\n\n  /// Check if the expression consists of exactly one entry value operand.\n  /// (This is the only configuration of entry values that is supported.)\n  bool isEntryValue() const {\n    return getNumElements() > 0 &&\n           getElement(0) == dwarf::DW_OP_LLVM_entry_value;\n  }\n};\n\ninline bool operator==(const DIExpression::FragmentInfo &A,\n                       const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) ==\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ninline bool operator<(const DIExpression::FragmentInfo &A,\n                      const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) <\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ntemplate <> struct DenseMapInfo<DIExpression::FragmentInfo> {\n  using FragInfo = DIExpression::FragmentInfo;\n  static const uint64_t MaxVal = std::numeric_limits<uint64_t>::max();\n\n  static inline FragInfo getEmptyKey() { return {MaxVal, MaxVal}; }\n\n  static inline FragInfo getTombstoneKey() { return {MaxVal - 1, MaxVal - 1}; }\n\n  static unsigned getHashValue(const FragInfo &Frag) {\n    return (Frag.SizeInBits & 0xffff) << 16 | (Frag.OffsetInBits & 0xffff);\n  }\n\n  static bool isEqual(const FragInfo &A, const FragInfo &B) { return A == B; }\n};\n\n/// Global variables.\n///\n/// TODO: Remove DisplayName.  It's always equal to Name.\nclass DIGlobalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  bool IsLocalToUnit;\n  bool IsDefinition;\n\n  DIGlobalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                   bool IsLocalToUnit, bool IsDefinition, uint32_t AlignInBits,\n                   ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DIGlobalVariableKind, Storage, Line, Ops, AlignInBits),\n        IsLocalToUnit(IsLocalToUnit), IsDefinition(IsDefinition) {}\n  ~DIGlobalVariable() = default;\n\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line, DIType *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          DIDerivedType *StaticDataMemberDeclaration, MDTuple *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   IsLocalToUnit, IsDefinition, StaticDataMemberDeclaration,\n                   cast_or_null<Metadata>(TemplateParams), AlignInBits, Storage,\n                   ShouldCreate);\n  }\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, Metadata *Scope, MDString *Name,\n          MDString *LinkageName, Metadata *File, unsigned Line, Metadata *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          Metadata *StaticDataMemberDeclaration, Metadata *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), isLocalToUnit(),\n                        isDefinition(), getStaticDataMemberDeclaration(),\n                        getTemplateParams(), getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (DIScope * Scope, StringRef Name, StringRef LinkageName,\n                     DIFile *File, unsigned Line, DIType *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     DIDerivedType *StaticDataMemberDeclaration,\n                     MDTuple *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (Metadata * Scope, MDString *Name, MDString *LinkageName,\n                     Metadata *File, unsigned Line, Metadata *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     Metadata *StaticDataMemberDeclaration,\n                     Metadata *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n\n  TempDIGlobalVariable clone() const { return cloneImpl(); }\n\n  bool isLocalToUnit() const { return IsLocalToUnit; }\n  bool isDefinition() const { return IsDefinition; }\n  StringRef getDisplayName() const { return getStringOperand(4); }\n  StringRef getLinkageName() const { return getStringOperand(5); }\n  DIDerivedType *getStaticDataMemberDeclaration() const {\n    return cast_or_null<DIDerivedType>(getRawStaticDataMemberDeclaration());\n  }\n\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(5); }\n  Metadata *getRawStaticDataMemberDeclaration() const { return getOperand(6); }\n  Metadata *getRawTemplateParams() const { return getOperand(7); }\n  MDTuple *getTemplateParams() const { return getOperandAs<MDTuple>(7); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\nclass DICommonBlock : public DIScope {\n  unsigned LineNo;\n\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DICommonBlock(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n                ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DICommonBlockKind, Storage, dwarf::DW_TAG_common_block,\n                Ops), LineNo(LineNo) {}\n\n  static DICommonBlock *getImpl(LLVMContext &Context, DIScope *Scope,\n                                DIGlobalVariable *Decl, StringRef Name,\n                                DIFile *File, unsigned LineNo,\n                                StorageType Storage,\n                                bool ShouldCreate = true) {\n    return getImpl(Context, Scope, Decl, getCanonicalMDString(Context, Name),\n                   File, LineNo, Storage, ShouldCreate);\n  }\n  static DICommonBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                Metadata *Decl, MDString *Name, Metadata *File,\n                                unsigned LineNo, \n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDICommonBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getDecl(), getName(),\n                        getFile(), getLineNo());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (DIScope *Scope, DIGlobalVariable *Decl, StringRef Name,\n                     DIFile *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (Metadata *Scope, Metadata *Decl, MDString *Name,\n                     Metadata *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n\n  TempDICommonBlock clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DIGlobalVariable *getDecl() const {\n    return cast_or_null<DIGlobalVariable>(getRawDecl());\n  }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  unsigned getLineNo() const { return LineNo; }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawDecl() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICommonBlockKind;\n  }\n};\n\n/// Local variable.\n///\n/// TODO: Split up flags.\nclass DILocalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Arg : 16;\n  DIFlags Flags;\n\n  DILocalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                  unsigned Arg, DIFlags Flags, uint32_t AlignInBits,\n                  ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DILocalVariableKind, Storage, Line, Ops, AlignInBits),\n        Arg(Arg), Flags(Flags) {\n    assert(Arg < (1 << 16) && \"DILocalVariable: Arg out of range\");\n  }\n  ~DILocalVariable() = default;\n\n  static DILocalVariable *getImpl(LLVMContext &Context, DIScope *Scope,\n                                  StringRef Name, DIFile *File, unsigned Line,\n                                  DIType *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Type, Arg, Flags, AlignInBits, Storage, ShouldCreate);\n  }\n  static DILocalVariable *getImpl(LLVMContext &Context, Metadata *Scope,\n                                  MDString *Name, Metadata *File, unsigned Line,\n                                  Metadata *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true);\n\n  TempDILocalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine(), getType(), getArg(), getFlags(),\n                        getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line, DIType *Type, unsigned Arg, DIFlags Flags,\n                     uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Type, unsigned Arg,\n                     DIFlags Flags, uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n\n  TempDILocalVariable clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this variable.\n  ///\n  /// Variables must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast<DILocalScope>(DIVariable::getScope());\n  }\n\n  bool isParameter() const { return Arg; }\n  unsigned getArg() const { return Arg; }\n  DIFlags getFlags() const { return Flags; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n\n  /// Check that a location is valid for this variable.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind;\n  }\n};\n\n/// Label.\n///\nclass DILabel : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DILabel(LLVMContext &C, StorageType Storage, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, DILabelKind, Storage, dwarf::DW_TAG_label, Ops), Line(Line) {}\n  ~DILabel() = default;\n\n  static DILabel *getImpl(LLVMContext &Context, DIScope *Scope,\n                          StringRef Name, DIFile *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Storage, ShouldCreate);\n  }\n  static DILabel *getImpl(LLVMContext &Context, Metadata *Scope,\n                          MDString *Name, Metadata *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDILabel cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILabel,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n  DEFINE_MDNODE_GET(DILabel,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n\n  TempDILabel clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this label.\n  ///\n  /// Labels must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast_or_null<DILocalScope>(getRawScope());\n  }\n  unsigned getLine() const { return Line; }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n\n  /// Check that a location is valid for this label.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILabelKind;\n  }\n};\n\nclass DIObjCProperty : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned Attributes;\n\n  DIObjCProperty(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Attributes, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIObjCPropertyKind, Storage, dwarf::DW_TAG_APPLE_property,\n               Ops),\n        Line(Line), Attributes(Attributes) {}\n  ~DIObjCProperty() = default;\n\n  static DIObjCProperty *\n  getImpl(LLVMContext &Context, StringRef Name, DIFile *File, unsigned Line,\n          StringRef GetterName, StringRef SetterName, unsigned Attributes,\n          DIType *Type, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), File, Line,\n                   getCanonicalMDString(Context, GetterName),\n                   getCanonicalMDString(Context, SetterName), Attributes, Type,\n                   Storage, ShouldCreate);\n  }\n  static DIObjCProperty *getImpl(LLVMContext &Context, MDString *Name,\n                                 Metadata *File, unsigned Line,\n                                 MDString *GetterName, MDString *SetterName,\n                                 unsigned Attributes, Metadata *Type,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDIObjCProperty cloneImpl() const {\n    return getTemporary(getContext(), getName(), getFile(), getLine(),\n                        getGetterName(), getSetterName(), getAttributes(),\n                        getType());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (StringRef Name, DIFile *File, unsigned Line,\n                     StringRef GetterName, StringRef SetterName,\n                     unsigned Attributes, DIType *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (MDString * Name, Metadata *File, unsigned Line,\n                     MDString *GetterName, MDString *SetterName,\n                     unsigned Attributes, Metadata *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n\n  TempDIObjCProperty clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getAttributes() const { return Attributes; }\n  StringRef getName() const { return getStringOperand(0); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  StringRef getGetterName() const { return getStringOperand(2); }\n  StringRef getSetterName() const { return getStringOperand(3); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawFile() const { return getOperand(1); }\n  MDString *getRawGetterName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSetterName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIObjCPropertyKind;\n  }\n};\n\n/// An imported module (C++ using directive or similar).\nclass DIImportedEntity : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIImportedEntity(LLVMContext &C, StorageType Storage, unsigned Tag,\n                   unsigned Line, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIImportedEntityKind, Storage, Tag, Ops), Line(Line) {}\n  ~DIImportedEntity() = default;\n\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   DIScope *Scope, DINode *Entity, DIFile *File,\n                                   unsigned Line, StringRef Name,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Tag, Scope, Entity, File, Line,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   Metadata *Scope, Metadata *Entity,\n                                   Metadata *File, unsigned Line,\n                                   MDString *Name, StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDIImportedEntity cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getScope(), getEntity(),\n                        getFile(), getLine(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, DIScope *Scope, DINode *Entity, DIFile *File,\n                     unsigned Line, StringRef Name = \"\"),\n                    (Tag, Scope, Entity, File, Line, Name))\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, Metadata *Scope, Metadata *Entity,\n                     Metadata *File, unsigned Line, MDString *Name),\n                    (Tag, Scope, Entity, File, Line, Name))\n\n  TempDIImportedEntity clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DINode *getEntity() const { return cast_or_null<DINode>(getRawEntity()); }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawEntity() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIImportedEntityKind;\n  }\n};\n\n/// A pair of DIGlobalVariable and DIExpression.\nclass DIGlobalVariableExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGlobalVariableExpression(LLVMContext &C, StorageType Storage,\n                             ArrayRef<Metadata *> Ops)\n      : MDNode(C, DIGlobalVariableExpressionKind, Storage, Ops) {}\n  ~DIGlobalVariableExpression() = default;\n\n  static DIGlobalVariableExpression *\n  getImpl(LLVMContext &Context, Metadata *Variable, Metadata *Expression,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariableExpression cloneImpl() const {\n    return getTemporary(getContext(), getVariable(), getExpression());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariableExpression,\n                    (Metadata * Variable, Metadata *Expression),\n                    (Variable, Expression))\n\n  TempDIGlobalVariableExpression clone() const { return cloneImpl(); }\n\n  Metadata *getRawVariable() const { return getOperand(0); }\n\n  DIGlobalVariable *getVariable() const {\n    return cast_or_null<DIGlobalVariable>(getRawVariable());\n  }\n\n  Metadata *getRawExpression() const { return getOperand(1); }\n\n  DIExpression *getExpression() const {\n    return cast<DIExpression>(getRawExpression());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableExpressionKind;\n  }\n};\n\n/// Macro Info DWARF-like metadata node.\n///\n/// A metadata node with a DWARF macro info (i.e., a constant named\n/// \\c DW_MACINFO_*, defined in llvm/BinaryFormat/Dwarf.h).  Called \\a\n/// DIMacroNode\n/// because it's potentially used for non-DWARF output.\nclass DIMacroNode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DIMacroNode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned MIType,\n              ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(MIType < 1u << 16);\n    SubclassData16 = MIType;\n  }\n  ~DIMacroNode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\npublic:\n  unsigned getMacinfoType() const { return SubclassData16; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIMacroKind:\n    case DIMacroFileKind:\n      return true;\n    }\n  }\n};\n\nclass DIMacro : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacro(LLVMContext &C, StorageType Storage, unsigned MIType, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacro() = default;\n\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          StringRef Name, StringRef Value, StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, Value), Storage, ShouldCreate);\n  }\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          MDString *Name, MDString *Value, StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDIMacro cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getName(),\n                        getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, StringRef Name,\n                              StringRef Value = \"\"),\n                    (MIType, Line, Name, Value))\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, MDString *Name,\n                              MDString *Value),\n                    (MIType, Line, Name, Value))\n\n  TempDIMacro clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n\n  StringRef getName() const { return getStringOperand(0); }\n  StringRef getValue() const { return getStringOperand(1); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  MDString *getRawValue() const { return getOperandAs<MDString>(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroKind;\n  }\n};\n\nclass DIMacroFile : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacroFile(LLVMContext &C, StorageType Storage, unsigned MIType,\n              unsigned Line, ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroFileKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacroFile() = default;\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, DIFile *File,\n                              DIMacroNodeArray Elements, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, static_cast<Metadata *>(File),\n                   Elements.get(), Storage, ShouldCreate);\n  }\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, Metadata *File, Metadata *Elements,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDIMacroFile cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getFile(),\n                        getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line, DIFile *File,\n                                  DIMacroNodeArray Elements),\n                    (MIType, Line, File, Elements))\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line,\n                                  Metadata *File, Metadata *Elements),\n                    (MIType, Line, File, Elements))\n\n  TempDIMacroFile clone() const { return cloneImpl(); }\n\n  void replaceElements(DIMacroNodeArray Elements) {\n#ifndef NDEBUG\n    for (DIMacroNode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a macro node during macro node list replacement\");\n#endif\n    replaceOperandWith(1, Elements.get());\n  }\n\n  unsigned getLine() const { return Line; }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  DIMacroNodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n\n  Metadata *getRawFile() const { return getOperand(0); }\n  Metadata *getRawElements() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroFileKind;\n  }\n};\n\n/// List of ValueAsMetadata, to be used as an argument to a dbg.value\n/// intrinsic.\nclass DIArgList : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  using iterator = SmallVectorImpl<ValueAsMetadata *>::iterator;\n\n  SmallVector<ValueAsMetadata *, 4> Args;\n\n  DIArgList(LLVMContext &C, StorageType Storage,\n            ArrayRef<ValueAsMetadata *> Args)\n      : MDNode(C, DIArgListKind, Storage, None),\n        Args(Args.begin(), Args.end()) {\n    track();\n  }\n  ~DIArgList() { untrack(); }\n\n  static DIArgList *getImpl(LLVMContext &Context,\n                            ArrayRef<ValueAsMetadata *> Args,\n                            StorageType Storage, bool ShouldCreate = true);\n\n  TempDIArgList cloneImpl() const {\n    return getTemporary(getContext(), getArgs());\n  }\n\n  void track();\n  void untrack();\n  void dropAllReferences();\n\npublic:\n  DEFINE_MDNODE_GET(DIArgList, (ArrayRef<ValueAsMetadata *> Args), (Args))\n\n  TempDIArgList clone() const { return cloneImpl(); }\n\n  ArrayRef<ValueAsMetadata *> getArgs() const { return Args; }\n\n  iterator args_begin() { return Args.begin(); }\n  iterator args_end() { return Args.end(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIArgListKind;\n  }\n\n  void handleChangedOperand(void *Ref, Metadata *New);\n};\n\n/// Identifies a unique instance of a variable.\n///\n/// Storage for identifying a potentially inlined instance of a variable,\n/// or a fragment thereof. This guarantees that exactly one variable instance\n/// may be identified by this class, even when that variable is a fragment of\n/// an aggregate variable and/or there is another inlined instance of the same\n/// source code variable nearby.\n/// This class does not necessarily uniquely identify that variable: it is\n/// possible that a DebugVariable with different parameters may point to the\n/// same variable instance, but not that one DebugVariable points to multiple\n/// variable instances.\nclass DebugVariable {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  const DILocalVariable *Variable;\n  Optional<FragmentInfo> Fragment;\n  const DILocation *InlinedAt;\n\n  /// Fragment that will overlap all other fragments. Used as default when\n  /// caller demands a fragment.\n  static const FragmentInfo DefaultFragment;\n\npublic:\n  DebugVariable(const DILocalVariable *Var, Optional<FragmentInfo> FragmentInfo,\n                const DILocation *InlinedAt)\n      : Variable(Var), Fragment(FragmentInfo), InlinedAt(InlinedAt) {}\n\n  DebugVariable(const DILocalVariable *Var, const DIExpression *DIExpr,\n                const DILocation *InlinedAt)\n      : Variable(Var),\n        Fragment(DIExpr ? DIExpr->getFragmentInfo() : NoneType()),\n        InlinedAt(InlinedAt) {}\n\n  const DILocalVariable *getVariable() const { return Variable; }\n  Optional<FragmentInfo> getFragment() const { return Fragment; }\n  const DILocation *getInlinedAt() const { return InlinedAt; }\n\n  FragmentInfo getFragmentOrDefault() const {\n    return Fragment.getValueOr(DefaultFragment);\n  }\n\n  static bool isDefaultFragment(const FragmentInfo F) {\n    return F == DefaultFragment;\n  }\n\n  bool operator==(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) ==\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n\n  bool operator<(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) <\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n};\n\ntemplate <> struct DenseMapInfo<DebugVariable> {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  /// Empty key: no key should be generated that has no DILocalVariable.\n  static inline DebugVariable getEmptyKey() {\n    return DebugVariable(nullptr, NoneType(), nullptr);\n  }\n\n  /// Difference in tombstone is that the Optional is meaningful.\n  static inline DebugVariable getTombstoneKey() {\n    return DebugVariable(nullptr, {{0, 0}}, nullptr);\n  }\n\n  static unsigned getHashValue(const DebugVariable &D) {\n    unsigned HV = 0;\n    const Optional<FragmentInfo> Fragment = D.getFragment();\n    if (Fragment)\n      HV = DenseMapInfo<FragmentInfo>::getHashValue(*Fragment);\n\n    return hash_combine(D.getVariable(), HV, D.getInlinedAt());\n  }\n\n  static bool isEqual(const DebugVariable &A, const DebugVariable &B) {\n    return A == B;\n  }\n};\n\n} // end namespace llvm\n\n#undef DEFINE_MDNODE_GET_UNPACK_IMPL\n#undef DEFINE_MDNODE_GET_UNPACK\n#undef DEFINE_MDNODE_GET\n\n#endif // LLVM_IR_DEBUGINFOMETADATA_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h", "content": "//===- DiagnosticHandler.h - DiagnosticHandler class for LLVM ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Base DiagnosticHandler class declaration. Derive from this class to provide\n// custom diagnostic reporting.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DIAGNOSTICHANDLER_H\n#define LLVM_IR_DIAGNOSTICHANDLER_H\n\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\nclass DiagnosticInfo;\n\n/// This is the base class for diagnostic handling in LLVM.\n/// The handleDiagnostics method must be overriden by the subclasses to handle\n/// diagnostic. The *RemarkEnabled methods can be overriden to control\n/// which remarks are enabled.\nstruct DiagnosticHandler {\n  void *DiagnosticContext = nullptr;\n  DiagnosticHandler(void *DiagContext = nullptr)\n      : DiagnosticContext(DiagContext) {}\n  virtual ~DiagnosticHandler() = default;\n\n  using DiagnosticHandlerTy = void (*)(const DiagnosticInfo &DI, void *Context);\n\n  /// DiagHandlerCallback is settable from the C API and base implementation\n  /// of DiagnosticHandler will call it from handleDiagnostics(). Any derived\n  /// class of DiagnosticHandler should not use callback but\n  /// implement handleDiagnostics().\n  DiagnosticHandlerTy DiagHandlerCallback = nullptr;\n\n  /// Override handleDiagnostics to provide custom implementation.\n  /// Return true if it handles diagnostics reporting properly otherwise\n  /// return false to make LLVMContext::diagnose() to print the message\n  /// with a prefix based on the severity.\n  virtual bool handleDiagnostics(const DiagnosticInfo &DI) {\n    if (DiagHandlerCallback) {\n      DiagHandlerCallback(DI, DiagnosticContext);\n      return true;\n    }\n    return false;\n  }\n\n  /// Return true if analysis remarks are enabled, override\n  /// to provide different implementation.\n  virtual bool isAnalysisRemarkEnabled(StringRef PassName) const;\n\n  /// Return true if missed optimization remarks are enabled, override\n  /// to provide different implementation.\n  virtual bool isMissedOptRemarkEnabled(StringRef PassName) const;\n\n  /// Return true if passed optimization remarks are enabled, override\n  /// to provide different implementation.\n  virtual bool isPassedOptRemarkEnabled(StringRef PassName) const;\n\n  /// Return true if any type of remarks are enabled for this pass.\n  bool isAnyRemarkEnabled(StringRef PassName) const {\n    return (isMissedOptRemarkEnabled(PassName) ||\n            isPassedOptRemarkEnabled(PassName) ||\n            isAnalysisRemarkEnabled(PassName));\n  }\n\n  /// Return true if any type of remarks are enabled for any pass.\n  virtual bool isAnyRemarkEnabled() const;\n};\n} // namespace llvm\n\n#endif // LLVM_IR_DIAGNOSTICHANDLER_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Function.h", "content": "//===- llvm/Function.h - Class to represent a single function ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the Function class, which represents a\n// single function/procedure in LLVM.\n//\n// A function basically consists of a list of basic blocks, a list of arguments,\n// and a symbol table.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_FUNCTION_H\n#define LLVM_IR_FUNCTION_H\n\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/GlobalObject.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/SymbolTableListTraits.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n#include <string>\n\nnamespace llvm {\n\nnamespace Intrinsic {\ntypedef unsigned ID;\n}\n\nclass AssemblyAnnotationWriter;\nclass Constant;\nclass DISubprogram;\nclass LLVMContext;\nclass Module;\ntemplate <typename T> class Optional;\nclass raw_ostream;\nclass Type;\nclass User;\nclass BranchProbabilityInfo;\nclass BlockFrequencyInfo;\n\nclass Function : public GlobalObject, public ilist_node<Function> {\npublic:\n  using BasicBlockListType = SymbolTableList<BasicBlock>;\n\n  // BasicBlock iterators...\n  using iterator = BasicBlockListType::iterator;\n  using const_iterator = BasicBlockListType::const_iterator;\n\n  using arg_iterator = Argument *;\n  using const_arg_iterator = const Argument *;\n\nprivate:\n  // Important things that make up a function!\n  BasicBlockListType BasicBlocks;         ///< The basic blocks\n  mutable Argument *Arguments = nullptr;  ///< The formal arguments\n  size_t NumArgs;\n  std::unique_ptr<ValueSymbolTable>\n      SymTab;                             ///< Symbol table of args/instructions\n  AttributeList AttributeSets;            ///< Parameter attributes\n\n  /*\n   * Value::SubclassData\n   *\n   * bit 0      : HasLazyArguments\n   * bit 1      : HasPrefixData\n   * bit 2      : HasPrologueData\n   * bit 3      : HasPersonalityFn\n   * bits 4-13  : CallingConvention\n   * bits 14    : HasGC\n   * bits 15 : [reserved]\n   */\n\n  /// Bits from GlobalObject::GlobalObjectSubclassData.\n  enum {\n    /// Whether this function is materializable.\n    IsMaterializableBit = 0,\n  };\n\n  friend class SymbolTableListTraits<Function>;\n\n  /// hasLazyArguments/CheckLazyArguments - The argument list of a function is\n  /// built on demand, so that the list isn't allocated until the first client\n  /// needs it.  The hasLazyArguments predicate returns true if the arg list\n  /// hasn't been set up yet.\npublic:\n  bool hasLazyArguments() const {\n    return getSubclassDataFromValue() & (1<<0);\n  }\n\nprivate:\n  void CheckLazyArguments() const {\n    if (hasLazyArguments())\n      BuildLazyArguments();\n  }\n\n  void BuildLazyArguments() const;\n\n  void clearArguments();\n\n  /// Function ctor - If the (optional) Module argument is specified, the\n  /// function is automatically inserted into the end of the function list for\n  /// the module.\n  ///\n  Function(FunctionType *Ty, LinkageTypes Linkage, unsigned AddrSpace,\n           const Twine &N = \"\", Module *M = nullptr);\n\npublic:\n  Function(const Function&) = delete;\n  void operator=(const Function&) = delete;\n  ~Function();\n\n  // This is here to help easily convert from FunctionT * (Function * or\n  // MachineFunction *) in BlockFrequencyInfoImpl to Function * by calling\n  // FunctionT->getFunction().\n  const Function &getFunction() const { return *this; }\n\n  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,\n                          unsigned AddrSpace, const Twine &N = \"\",\n                          Module *M = nullptr) {\n    return new Function(Ty, Linkage, AddrSpace, N, M);\n  }\n\n  // TODO: remove this once all users have been updated to pass an AddrSpace\n  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,\n                          const Twine &N = \"\", Module *M = nullptr) {\n    return new Function(Ty, Linkage, static_cast<unsigned>(-1), N, M);\n  }\n\n  /// Creates a new function and attaches it to a module.\n  ///\n  /// Places the function in the program address space as specified\n  /// by the module's data layout.\n  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,\n                          const Twine &N, Module &M);\n\n  // Provide fast operand accessors.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Returns the number of non-debug IR instructions in this function.\n  /// This is equivalent to the sum of the sizes of each basic block contained\n  /// within this function.\n  unsigned getInstructionCount() const;\n\n  /// Returns the FunctionType for me.\n  FunctionType *getFunctionType() const {\n    return cast<FunctionType>(getValueType());\n  }\n\n  /// Returns the type of the ret val.\n  Type *getReturnType() const { return getFunctionType()->getReturnType(); }\n\n  /// getContext - Return a reference to the LLVMContext associated with this\n  /// function.\n  LLVMContext &getContext() const;\n\n  /// isVarArg - Return true if this function takes a variable number of\n  /// arguments.\n  bool isVarArg() const { return getFunctionType()->isVarArg(); }\n\n  bool isMaterializable() const {\n    return getGlobalObjectSubClassData() & (1 << IsMaterializableBit);\n  }\n  void setIsMaterializable(bool V) {\n    unsigned Mask = 1 << IsMaterializableBit;\n    setGlobalObjectSubClassData((~Mask & getGlobalObjectSubClassData()) |\n                                (V ? Mask : 0u));\n  }\n\n  /// getIntrinsicID - This method returns the ID number of the specified\n  /// function, or Intrinsic::not_intrinsic if the function is not an\n  /// intrinsic, or if the pointer is null.  This value is always defined to be\n  /// zero to allow easy checking for whether a function is intrinsic or not.\n  /// The particular intrinsic functions which correspond to this value are\n  /// defined in llvm/Intrinsics.h.\n  Intrinsic::ID getIntrinsicID() const LLVM_READONLY { return IntID; }\n\n  /// isIntrinsic - Returns true if the function's name starts with \"llvm.\".\n  /// It's possible for this function to return true while getIntrinsicID()\n  /// returns Intrinsic::not_intrinsic!\n  bool isIntrinsic() const { return HasLLVMReservedName; }\n\n  /// isTargetIntrinsic - Returns true if IID is an intrinsic specific to a\n  /// certain target. If it is a generic intrinsic false is returned.\n  static bool isTargetIntrinsic(Intrinsic::ID IID);\n\n  /// isTargetIntrinsic - Returns true if this function is an intrinsic and the\n  /// intrinsic is specific to a certain target. If this is not an intrinsic\n  /// or a generic intrinsic, false is returned.\n  bool isTargetIntrinsic() const;\n\n  /// Returns true if the function is one of the \"Constrained Floating-Point\n  /// Intrinsics\". Returns false if not, and returns false when\n  /// getIntrinsicID() returns Intrinsic::not_intrinsic.\n  bool isConstrainedFPIntrinsic() const;\n\n  static Intrinsic::ID lookupIntrinsicID(StringRef Name);\n\n  /// Recalculate the ID for this function if it is an Intrinsic defined\n  /// in llvm/Intrinsics.h.  Sets the intrinsic ID to Intrinsic::not_intrinsic\n  /// if the name of this function does not match an intrinsic in that header.\n  /// Note, this method does not need to be called directly, as it is called\n  /// from Value::setName() whenever the name of this function changes.\n  void recalculateIntrinsicID();\n\n  /// getCallingConv()/setCallingConv(CC) - These method get and set the\n  /// calling convention of this function.  The enum values for the known\n  /// calling conventions are defined in CallingConv.h.\n  CallingConv::ID getCallingConv() const {\n    return static_cast<CallingConv::ID>((getSubclassDataFromValue() >> 4) &\n                                        CallingConv::MaxID);\n  }\n  void setCallingConv(CallingConv::ID CC) {\n    auto ID = static_cast<unsigned>(CC);\n    assert(!(ID & ~CallingConv::MaxID) && \"Unsupported calling convention\");\n    setValueSubclassData((getSubclassDataFromValue() & 0xc00f) | (ID << 4));\n  }\n\n  /// Return the attribute list for this Function.\n  AttributeList getAttributes() const { return AttributeSets; }\n\n  /// Set the attribute list for this Function.\n  void setAttributes(AttributeList Attrs) { AttributeSets = Attrs; }\n\n  /// Add function attributes to this function.\n  void addFnAttr(Attribute::AttrKind Kind) {\n    addAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Add function attributes to this function.\n  void addFnAttr(StringRef Kind, StringRef Val = StringRef()) {\n    addAttribute(AttributeList::FunctionIndex,\n                 Attribute::get(getContext(), Kind, Val));\n  }\n\n  /// Add function attributes to this function.\n  void addFnAttr(Attribute Attr) {\n    addAttribute(AttributeList::FunctionIndex, Attr);\n  }\n\n  /// Remove function attributes from this function.\n  void removeFnAttr(Attribute::AttrKind Kind) {\n    removeAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Remove function attribute from this function.\n  void removeFnAttr(StringRef Kind) {\n    setAttributes(getAttributes().removeAttribute(\n        getContext(), AttributeList::FunctionIndex, Kind));\n  }\n\n  /// A function will have the \"coroutine.presplit\" attribute if it's\n  /// a coroutine and has not gone through full CoroSplit pass.\n  bool isPresplitCoroutine() const {\n    return hasFnAttribute(\"coroutine.presplit\");\n  }\n\n  enum ProfileCountType { PCT_Invalid, PCT_Real, PCT_Synthetic };\n\n  /// Class to represent profile counts.\n  ///\n  /// This class represents both real and synthetic profile counts.\n  class ProfileCount {\n  private:\n    uint64_t Count;\n    ProfileCountType PCT;\n    static ProfileCount Invalid;\n\n  public:\n    ProfileCount() : Count(-1), PCT(PCT_Invalid) {}\n    ProfileCount(uint64_t Count, ProfileCountType PCT)\n        : Count(Count), PCT(PCT) {}\n    bool hasValue() const { return PCT != PCT_Invalid; }\n    uint64_t getCount() const { return Count; }\n    ProfileCountType getType() const { return PCT; }\n    bool isSynthetic() const { return PCT == PCT_Synthetic; }\n    explicit operator bool() { return hasValue(); }\n    bool operator!() const { return !hasValue(); }\n    // Update the count retaining the same profile count type.\n    ProfileCount &setCount(uint64_t C) {\n      Count = C;\n      return *this;\n    }\n    static ProfileCount getInvalid() { return ProfileCount(-1, PCT_Invalid); }\n  };\n\n  /// Set the entry count for this function.\n  ///\n  /// Entry count is the number of times this function was executed based on\n  /// pgo data. \\p Imports points to a set of GUIDs that needs to\n  /// be imported by the function for sample PGO, to enable the same inlines as\n  /// the profiled optimized binary.\n  void setEntryCount(ProfileCount Count,\n                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);\n\n  /// A convenience wrapper for setting entry count\n  void setEntryCount(uint64_t Count, ProfileCountType Type = PCT_Real,\n                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);\n\n  /// Get the entry count for this function.\n  ///\n  /// Entry count is the number of times the function was executed.\n  /// When AllowSynthetic is false, only pgo_data will be returned.\n  ProfileCount getEntryCount(bool AllowSynthetic = false) const;\n\n  /// Return true if the function is annotated with profile data.\n  ///\n  /// Presence of entry counts from a profile run implies the function has\n  /// profile annotations. If IncludeSynthetic is false, only return true\n  /// when the profile data is real.\n  bool hasProfileData(bool IncludeSynthetic = false) const {\n    return getEntryCount(IncludeSynthetic).hasValue();\n  }\n\n  /// Returns the set of GUIDs that needs to be imported to the function for\n  /// sample PGO, to enable the same inlines as the profiled optimized binary.\n  DenseSet<GlobalValue::GUID> getImportGUIDs() const;\n\n  /// Set the section prefix for this function.\n  void setSectionPrefix(StringRef Prefix);\n\n  /// Get the section prefix for this function.\n  Optional<StringRef> getSectionPrefix() const;\n\n  /// Return true if the function has the attribute.\n  bool hasFnAttribute(Attribute::AttrKind Kind) const {\n    return AttributeSets.hasFnAttribute(Kind);\n  }\n\n  /// Return true if the function has the attribute.\n  bool hasFnAttribute(StringRef Kind) const {\n    return AttributeSets.hasFnAttribute(Kind);\n  }\n\n  /// Return the attribute for the given attribute kind.\n  Attribute getFnAttribute(Attribute::AttrKind Kind) const {\n    return getAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Return the attribute for the given attribute kind.\n  Attribute getFnAttribute(StringRef Kind) const {\n    return getAttribute(AttributeList::FunctionIndex, Kind);\n  }\n\n  /// Return the stack alignment for the function.\n  unsigned getFnStackAlignment() const {\n    if (!hasFnAttribute(Attribute::StackAlignment))\n      return 0;\n    if (const auto MA =\n            AttributeSets.getStackAlignment(AttributeList::FunctionIndex))\n      return MA->value();\n    return 0;\n  }\n\n  /// Return the stack alignment for the function.\n  MaybeAlign getFnStackAlign() const {\n    if (!hasFnAttribute(Attribute::StackAlignment))\n      return None;\n    return AttributeSets.getStackAlignment(AttributeList::FunctionIndex);\n  }\n\n  /// hasGC/getGC/setGC/clearGC - The name of the garbage collection algorithm\n  ///                             to use during code generation.\n  bool hasGC() const {\n    return getSubclassDataFromValue() & (1<<14);\n  }\n  const std::string &getGC() const;\n  void setGC(std::string Str);\n  void clearGC();\n\n  /// Returns true if the function has ssp, sspstrong, or sspreq fn attrs.\n  bool hasStackProtectorFnAttr() const;\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute::AttrKind Kind);\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute Attr);\n\n  /// adds the attributes to the list of attributes.\n  void addAttributes(unsigned i, const AttrBuilder &Attrs);\n\n  /// adds the attribute to the list of attributes for the given arg.\n  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);\n\n  /// adds the attribute to the list of attributes for the given arg.\n  void addParamAttr(unsigned ArgNo, Attribute Attr);\n\n  /// adds the attributes to the list of attributes for the given arg.\n  void addParamAttrs(unsigned ArgNo, const AttrBuilder &Attrs);\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, Attribute::AttrKind Kind);\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, StringRef Kind);\n\n  /// removes the attributes from the list of attributes.\n  void removeAttributes(unsigned i, const AttrBuilder &Attrs);\n\n  /// removes the attribute from the list of attributes.\n  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);\n\n  /// removes the attribute from the list of attributes.\n  void removeParamAttr(unsigned ArgNo, StringRef Kind);\n\n  /// removes the attribute from the list of attributes.\n  void removeParamAttrs(unsigned ArgNo, const AttrBuilder &Attrs);\n\n  /// check if an attributes is in the list of attributes.\n  bool hasAttribute(unsigned i, Attribute::AttrKind Kind) const {\n    return getAttributes().hasAttribute(i, Kind);\n  }\n\n  /// check if an attributes is in the list of attributes.\n  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttributes().hasParamAttribute(ArgNo, Kind);\n  }\n\n  /// gets the specified attribute from the list of attributes.\n  Attribute getParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// gets the attribute from the list of attributes.\n  Attribute getAttribute(unsigned i, Attribute::AttrKind Kind) const {\n    return AttributeSets.getAttribute(i, Kind);\n  }\n\n  /// gets the attribute from the list of attributes.\n  Attribute getAttribute(unsigned i, StringRef Kind) const {\n    return AttributeSets.getAttribute(i, Kind);\n  }\n\n  /// adds the dereferenceable attribute to the list of attributes.\n  void addDereferenceableAttr(unsigned i, uint64_t Bytes);\n\n  /// adds the dereferenceable attribute to the list of attributes for\n  /// the given arg.\n  void addDereferenceableParamAttr(unsigned ArgNo, uint64_t Bytes);\n\n  /// adds the dereferenceable_or_null attribute to the list of\n  /// attributes.\n  void addDereferenceableOrNullAttr(unsigned i, uint64_t Bytes);\n\n  /// adds the dereferenceable_or_null attribute to the list of\n  /// attributes for the given arg.\n  void addDereferenceableOrNullParamAttr(unsigned ArgNo, uint64_t Bytes);\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getParamAlign() instead.\n  unsigned getParamAlignment(unsigned ArgNo) const {\n    if (const auto MA = getParamAlign(ArgNo))\n      return MA->value();\n    return 0;\n  }\n\n  MaybeAlign getParamAlign(unsigned ArgNo) const {\n    return AttributeSets.getParamAlignment(ArgNo);\n  }\n\n  /// Extract the byval type for a parameter.\n  Type *getParamByValType(unsigned ArgNo) const {\n    return AttributeSets.getParamByValType(ArgNo);\n  }\n\n  /// Extract the sret type for a parameter.\n  Type *getParamStructRetType(unsigned ArgNo) const {\n    return AttributeSets.getParamStructRetType(ArgNo);\n  }\n\n  /// Extract the byref type for a parameter.\n  Type *getParamByRefType(unsigned ArgNo) const {\n    return AttributeSets.getParamByRefType(ArgNo);\n  }\n\n  /// Extract the number of dereferenceable bytes for a call or\n  /// parameter (0=unknown).\n  /// @param i AttributeList index, referring to a return value or argument.\n  uint64_t getDereferenceableBytes(unsigned i) const {\n    return AttributeSets.getDereferenceableBytes(i);\n  }\n\n  /// Extract the number of dereferenceable bytes for a parameter.\n  /// @param ArgNo Index of an argument, with 0 being the first function arg.\n  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {\n    return AttributeSets.getParamDereferenceableBytes(ArgNo);\n  }\n\n  /// Extract the number of dereferenceable_or_null bytes for a call or\n  /// parameter (0=unknown).\n  /// @param i AttributeList index, referring to a return value or argument.\n  uint64_t getDereferenceableOrNullBytes(unsigned i) const {\n    return AttributeSets.getDereferenceableOrNullBytes(i);\n  }\n\n  /// Extract the number of dereferenceable_or_null bytes for a\n  /// parameter.\n  /// @param ArgNo AttributeList ArgNo, referring to an argument.\n  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {\n    return AttributeSets.getParamDereferenceableOrNullBytes(ArgNo);\n  }\n\n  /// Determine if the function does not access memory.\n  bool doesNotAccessMemory() const {\n    return hasFnAttribute(Attribute::ReadNone);\n  }\n  void setDoesNotAccessMemory() {\n    addFnAttr(Attribute::ReadNone);\n  }\n\n  /// Determine if the function does not access or only reads memory.\n  bool onlyReadsMemory() const {\n    return doesNotAccessMemory() || hasFnAttribute(Attribute::ReadOnly);\n  }\n  void setOnlyReadsMemory() {\n    addFnAttr(Attribute::ReadOnly);\n  }\n\n  /// Determine if the function does not access or only writes memory.\n  bool doesNotReadMemory() const {\n    return doesNotAccessMemory() || hasFnAttribute(Attribute::WriteOnly);\n  }\n  void setDoesNotReadMemory() {\n    addFnAttr(Attribute::WriteOnly);\n  }\n\n  /// Determine if the call can access memmory only using pointers based\n  /// on its arguments.\n  bool onlyAccessesArgMemory() const {\n    return hasFnAttribute(Attribute::ArgMemOnly);\n  }\n  void setOnlyAccessesArgMemory() { addFnAttr(Attribute::ArgMemOnly); }\n\n  /// Determine if the function may only access memory that is\n  ///  inaccessible from the IR.\n  bool onlyAccessesInaccessibleMemory() const {\n    return hasFnAttribute(Attribute::InaccessibleMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemory() {\n    addFnAttr(Attribute::InaccessibleMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  ///  either inaccessible from the IR or pointed to by its arguments.\n  bool onlyAccessesInaccessibleMemOrArgMem() const {\n    return hasFnAttribute(Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemOrArgMem() {\n    addFnAttr(Attribute::InaccessibleMemOrArgMemOnly);\n  }\n\n  /// Determine if the function cannot return.\n  bool doesNotReturn() const {\n    return hasFnAttribute(Attribute::NoReturn);\n  }\n  void setDoesNotReturn() {\n    addFnAttr(Attribute::NoReturn);\n  }\n\n  /// Determine if the function should not perform indirect branch tracking.\n  bool doesNoCfCheck() const { return hasFnAttribute(Attribute::NoCfCheck); }\n\n  /// Determine if the function cannot unwind.\n  bool doesNotThrow() const {\n    return hasFnAttribute(Attribute::NoUnwind);\n  }\n  void setDoesNotThrow() {\n    addFnAttr(Attribute::NoUnwind);\n  }\n\n  /// Determine if the call cannot be duplicated.\n  bool cannotDuplicate() const {\n    return hasFnAttribute(Attribute::NoDuplicate);\n  }\n  void setCannotDuplicate() {\n    addFnAttr(Attribute::NoDuplicate);\n  }\n\n  /// Determine if the call is convergent.\n  bool isConvergent() const {\n    return hasFnAttribute(Attribute::Convergent);\n  }\n  void setConvergent() {\n    addFnAttr(Attribute::Convergent);\n  }\n  void setNotConvergent() {\n    removeFnAttr(Attribute::Convergent);\n  }\n\n  /// Determine if the call has sideeffects.\n  bool isSpeculatable() const {\n    return hasFnAttribute(Attribute::Speculatable);\n  }\n  void setSpeculatable() {\n    addFnAttr(Attribute::Speculatable);\n  }\n\n  /// Determine if the call might deallocate memory.\n  bool doesNotFreeMemory() const {\n    return onlyReadsMemory() || hasFnAttribute(Attribute::NoFree);\n  }\n  void setDoesNotFreeMemory() {\n    addFnAttr(Attribute::NoFree);\n  }\n\n  /// Determine if the function is known not to recurse, directly or\n  /// indirectly.\n  bool doesNotRecurse() const {\n    return hasFnAttribute(Attribute::NoRecurse);\n  }\n  void setDoesNotRecurse() {\n    addFnAttr(Attribute::NoRecurse);\n  }\n\n  /// Determine if the function is required to make forward progress.\n  bool mustProgress() const {\n    return hasFnAttribute(Attribute::MustProgress) ||\n           hasFnAttribute(Attribute::WillReturn);\n  }\n  void setMustProgress() { addFnAttr(Attribute::MustProgress); }\n\n  /// Determine if the function will return.\n  bool willReturn() const { return hasFnAttribute(Attribute::WillReturn); }\n  void setWillReturn() { addFnAttr(Attribute::WillReturn); }\n\n  /// True if the ABI mandates (or the user requested) that this\n  /// function be in a unwind table.\n  bool hasUWTable() const {\n    return hasFnAttribute(Attribute::UWTable);\n  }\n  void setHasUWTable() {\n    addFnAttr(Attribute::UWTable);\n  }\n\n  /// True if this function needs an unwind table.\n  bool needsUnwindTableEntry() const {\n    return hasUWTable() || !doesNotThrow() || hasPersonalityFn();\n  }\n\n  /// Determine if the function returns a structure through first\n  /// or second pointer argument.\n  bool hasStructRetAttr() const {\n    return AttributeSets.hasParamAttribute(0, Attribute::StructRet) ||\n           AttributeSets.hasParamAttribute(1, Attribute::StructRet);\n  }\n\n  /// Determine if the parameter or return value is marked with NoAlias\n  /// attribute.\n  bool returnDoesNotAlias() const {\n    return AttributeSets.hasAttribute(AttributeList::ReturnIndex,\n                                      Attribute::NoAlias);\n  }\n  void setReturnDoesNotAlias() {\n    addAttribute(AttributeList::ReturnIndex, Attribute::NoAlias);\n  }\n\n  /// Do not optimize this function (-O0).\n  bool hasOptNone() const { return hasFnAttribute(Attribute::OptimizeNone); }\n\n  /// Optimize this function for minimum size (-Oz).\n  bool hasMinSize() const { return hasFnAttribute(Attribute::MinSize); }\n\n  /// Optimize this function for size (-Os) or minimum size (-Oz).\n  bool hasOptSize() const {\n    return hasFnAttribute(Attribute::OptimizeForSize) || hasMinSize();\n  }\n\n  /// Returns the denormal handling type for the default rounding mode of the\n  /// function.\n  DenormalMode getDenormalMode(const fltSemantics &FPType) const;\n\n  /// copyAttributesFrom - copy all additional attributes (those not needed to\n  /// create a Function) from the Function Src to this one.\n  void copyAttributesFrom(const Function *Src);\n\n  /// deleteBody - This method deletes the body of the function, and converts\n  /// the linkage to external.\n  ///\n  void deleteBody() {\n    dropAllReferences();\n    setLinkage(ExternalLinkage);\n  }\n\n  /// removeFromParent - This method unlinks 'this' from the containing module,\n  /// but does not delete it.\n  ///\n  void removeFromParent();\n\n  /// eraseFromParent - This method unlinks 'this' from the containing module\n  /// and deletes it.\n  ///\n  void eraseFromParent();\n\n  /// Steal arguments from another function.\n  ///\n  /// Drop this function's arguments and splice in the ones from \\c Src.\n  /// Requires that this has no function body.\n  void stealArgumentListFrom(Function &Src);\n\n  /// Get the underlying elements of the Function... the basic block list is\n  /// empty for external functions.\n  ///\n  const BasicBlockListType &getBasicBlockList() const { return BasicBlocks; }\n        BasicBlockListType &getBasicBlockList()       { return BasicBlocks; }\n\n  static BasicBlockListType Function::*getSublistAccess(BasicBlock*) {\n    return &Function::BasicBlocks;\n  }\n\n  const BasicBlock       &getEntryBlock() const   { return front(); }\n        BasicBlock       &getEntryBlock()         { return front(); }\n\n  //===--------------------------------------------------------------------===//\n  // Symbol Table Accessing functions...\n\n  /// getSymbolTable() - Return the symbol table if any, otherwise nullptr.\n  ///\n  inline ValueSymbolTable *getValueSymbolTable() { return SymTab.get(); }\n  inline const ValueSymbolTable *getValueSymbolTable() const {\n    return SymTab.get();\n  }\n\n  //===--------------------------------------------------------------------===//\n  // BasicBlock iterator forwarding functions\n  //\n  iterator                begin()       { return BasicBlocks.begin(); }\n  const_iterator          begin() const { return BasicBlocks.begin(); }\n  iterator                end  ()       { return BasicBlocks.end();   }\n  const_iterator          end  () const { return BasicBlocks.end();   }\n\n  size_t                   size() const { return BasicBlocks.size();  }\n  bool                    empty() const { return BasicBlocks.empty(); }\n  const BasicBlock       &front() const { return BasicBlocks.front(); }\n        BasicBlock       &front()       { return BasicBlocks.front(); }\n  const BasicBlock        &back() const { return BasicBlocks.back();  }\n        BasicBlock        &back()       { return BasicBlocks.back();  }\n\n/// @name Function Argument Iteration\n/// @{\n\n  arg_iterator arg_begin() {\n    CheckLazyArguments();\n    return Arguments;\n  }\n  const_arg_iterator arg_begin() const {\n    CheckLazyArguments();\n    return Arguments;\n  }\n\n  arg_iterator arg_end() {\n    CheckLazyArguments();\n    return Arguments + NumArgs;\n  }\n  const_arg_iterator arg_end() const {\n    CheckLazyArguments();\n    return Arguments + NumArgs;\n  }\n\n  Argument* getArg(unsigned i) const {\n    assert (i < NumArgs && \"getArg() out of range!\");\n    CheckLazyArguments();\n    return Arguments + i;\n  }\n\n  iterator_range<arg_iterator> args() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<const_arg_iterator> args() const {\n    return make_range(arg_begin(), arg_end());\n  }\n\n/// @}\n\n  size_t arg_size() const { return NumArgs; }\n  bool arg_empty() const { return arg_size() == 0; }\n\n  /// Check whether this function has a personality function.\n  bool hasPersonalityFn() const {\n    return getSubclassDataFromValue() & (1<<3);\n  }\n\n  /// Get the personality function associated with this function.\n  Constant *getPersonalityFn() const;\n  void setPersonalityFn(Constant *Fn);\n\n  /// Check whether this function has prefix data.\n  bool hasPrefixData() const {\n    return getSubclassDataFromValue() & (1<<1);\n  }\n\n  /// Get the prefix data associated with this function.\n  Constant *getPrefixData() const;\n  void setPrefixData(Constant *PrefixData);\n\n  /// Check whether this function has prologue data.\n  bool hasPrologueData() const {\n    return getSubclassDataFromValue() & (1<<2);\n  }\n\n  /// Get the prologue data associated with this function.\n  Constant *getPrologueData() const;\n  void setPrologueData(Constant *PrologueData);\n\n  /// Print the function to an output stream with an optional\n  /// AssemblyAnnotationWriter.\n  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,\n             bool ShouldPreserveUseListOrder = false,\n             bool IsForDebug = false) const;\n\n  /// viewCFG - This function is meant for use from the debugger.  You can just\n  /// say 'call F->viewCFG()' and a ghostview window should pop up from the\n  /// program, displaying the CFG of the current function with the code for each\n  /// basic block inside.  This depends on there being a 'dot' and 'gv' program\n  /// in your path.\n  ///\n  void viewCFG() const;\n\n  /// Extended form to print edge weights.\n  void viewCFG(bool ViewCFGOnly, const BlockFrequencyInfo *BFI,\n               const BranchProbabilityInfo *BPI) const;\n\n  /// viewCFGOnly - This function is meant for use from the debugger.  It works\n  /// just like viewCFG, but it does not include the contents of basic blocks\n  /// into the nodes, just the label.  If you are only interested in the CFG\n  /// this can make the graph smaller.\n  ///\n  void viewCFGOnly() const;\n\n  /// Extended form to print edge weights.\n  void viewCFGOnly(const BlockFrequencyInfo *BFI,\n                   const BranchProbabilityInfo *BPI) const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == Value::FunctionVal;\n  }\n\n  /// dropAllReferences() - This method causes all the subinstructions to \"let\n  /// go\" of all references that they are maintaining.  This allows one to\n  /// 'delete' a whole module at a time, even though there may be circular\n  /// references... first all references are dropped, and all use counts go to\n  /// zero.  Then everything is deleted for real.  Note that no operations are\n  /// valid on an object that has \"dropped all references\", except operator\n  /// delete.\n  ///\n  /// Since no other object in the module can have references into the body of a\n  /// function, dropping all references deletes the entire body of the function,\n  /// including any contained basic blocks.\n  ///\n  void dropAllReferences();\n\n  /// hasAddressTaken - returns true if there are any uses of this function\n  /// other than direct calls or invokes to it, or blockaddress expressions.\n  /// Optionally passes back an offending user for diagnostic purposes,\n  /// ignores callback uses, assume like pointer annotation calls, and\n  /// references in llvm.used and llvm.compiler.used variables.\n  ///\n  bool hasAddressTaken(const User ** = nullptr,\n                       bool IgnoreCallbackUses = false,\n                       bool IgnoreAssumeLikeCalls = false,\n                       bool IngoreLLVMUsed = false) const;\n\n  /// isDefTriviallyDead - Return true if it is trivially safe to remove\n  /// this function definition from the module (because it isn't externally\n  /// visible, does not have its address taken, and has no callers).  To make\n  /// this more accurate, call removeDeadConstantUsers first.\n  bool isDefTriviallyDead() const;\n\n  /// callsFunctionThatReturnsTwice - Return true if the function has a call to\n  /// setjmp or other function that gcc recognizes as \"returning twice\".\n  bool callsFunctionThatReturnsTwice() const;\n\n  /// Set the attached subprogram.\n  ///\n  /// Calls \\a setMetadata() with \\a LLVMContext::MD_dbg.\n  void setSubprogram(DISubprogram *SP);\n\n  /// Get the attached subprogram.\n  ///\n  /// Calls \\a getMetadata() with \\a LLVMContext::MD_dbg and casts the result\n  /// to \\a DISubprogram.\n  DISubprogram *getSubprogram() const;\n\n  /// Returns true if we should emit debug info for profiling.\n  bool isDebugInfoForProfiling() const;\n\n  /// Check if null pointer dereferencing is considered undefined behavior for\n  /// the function.\n  /// Return value: false => null pointer dereference is undefined.\n  /// Return value: true =>  null pointer dereference is not undefined.\n  bool nullPointerIsDefined() const;\n\nprivate:\n  void allocHungoffUselist();\n  template<int Idx> void setHungoffOperand(Constant *C);\n\n  /// Shadow Value::setValueSubclassData with a private forwarding method so\n  /// that subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n  void setValueSubclassDataBit(unsigned Bit, bool On);\n};\n\n/// Check whether null pointer dereferencing is considered undefined behavior\n/// for a given function or an address space.\n/// Null pointer access in non-zero address space is not considered undefined.\n/// Return value: false => null pointer dereference is undefined.\n/// Return value: true =>  null pointer dereference is not undefined.\nbool NullPointerIsDefined(const Function *F, unsigned AS = 0);\n\ntemplate <>\nstruct OperandTraits<Function> : public HungoffOperandTraits<3> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(Function, Value)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_FUNCTION_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "content": "//===- Intrinsics.h - LLVM Intrinsic Function Handling ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a set of enums which allow processing of intrinsic\n// functions.  Values of these enum types are returned by\n// Function::getIntrinsicID.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INTRINSICS_H\n#define LLVM_IR_INTRINSICS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <string>\n\nnamespace llvm {\n\nclass Type;\nclass FunctionType;\nclass Function;\nclass LLVMContext;\nclass Module;\nclass AttributeList;\n\n/// This namespace contains an enum with a value for every intrinsic/builtin\n/// function known by LLVM. The enum values are returned by\n/// Function::getIntrinsicID().\nnamespace Intrinsic {\n  // Abstraction for the arguments of the noalias intrinsics\n  static const int NoAliasScopeDeclScopeArg = 0;\n\n  // Intrinsic ID type. This is an opaque typedef to facilitate splitting up\n  // the enum into target-specific enums.\n  typedef unsigned ID;\n\n  enum IndependentIntrinsics : unsigned {\n    not_intrinsic = 0, // Must be zero\n\n  // Get the intrinsic enums generated from Intrinsics.td\n#define GET_INTRINSIC_ENUM_VALUES\n#include \"llvm/IR/IntrinsicEnums.inc\"\n#undef GET_INTRINSIC_ENUM_VALUES\n  };\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version is for intrinsics with no overloads.  Use the other\n  /// version of getName if overloads are required.\n  StringRef getName(ID id);\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version of getName supports overloads, but is less efficient\n  /// than the StringRef version of this function.  If no overloads are\n  /// requried, it is safe to use this version, but better to use the StringRef\n  /// version.\n  std::string getName(ID id, ArrayRef<Type*> Tys);\n\n  /// Return the function type for an intrinsic.\n  FunctionType *getType(LLVMContext &Context, ID id,\n                        ArrayRef<Type*> Tys = None);\n\n  /// Returns true if the intrinsic can be overloaded.\n  bool isOverloaded(ID id);\n\n  /// Returns true if the intrinsic is a leaf, i.e. it does not make any calls\n  /// itself.  Most intrinsics are leafs, the exceptions being the patchpoint\n  /// and statepoint intrinsics. These call (or invoke) their \"target\" argument.\n  bool isLeaf(ID id);\n\n  /// Return the attributes for an intrinsic.\n  AttributeList getAttributes(LLVMContext &C, ID id);\n\n  /// Create or insert an LLVM Function declaration for an intrinsic, and return\n  /// it.\n  ///\n  /// The Tys parameter is for intrinsics with overloaded types (e.g., those\n  /// using iAny, fAny, vAny, or iPTRAny).  For a declaration of an overloaded\n  /// intrinsic, Tys must provide exactly one type for each overloaded type in\n  /// the intrinsic.\n  Function *getDeclaration(Module *M, ID id, ArrayRef<Type*> Tys = None);\n\n  /// Looks up Name in NameTable via binary search. NameTable must be sorted\n  /// and all entries must start with \"llvm.\".  If NameTable contains an exact\n  /// match for Name or a prefix of Name followed by a dot, its index in\n  /// NameTable is returned. Otherwise, -1 is returned.\n  int lookupLLVMIntrinsicByName(ArrayRef<const char *> NameTable,\n                                StringRef Name);\n\n  /// Map a GCC builtin name to an intrinsic ID.\n  ID getIntrinsicForGCCBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// Map a MS builtin name to an intrinsic ID.\n  ID getIntrinsicForMSBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// This is a type descriptor which explains the type requirements of an\n  /// intrinsic. This is returned by getIntrinsicInfoTableEntries.\n  struct IITDescriptor {\n    enum IITDescriptorKind {\n      Void,\n      VarArg,\n      MMX,\n      Token,\n      Metadata,\n      Half,\n      BFloat,\n      Float,\n      Double,\n      Quad,\n      Integer,\n      Vector,\n      Pointer,\n      Struct,\n      Argument,\n      ExtendArgument,\n      TruncArgument,\n      HalfVecArgument,\n      SameVecWidthArgument,\n      PtrToArgument,\n      PtrToElt,\n      VecOfAnyPtrsToElt,\n      VecElementArgument,\n      Subdivide2Argument,\n      Subdivide4Argument,\n      VecOfBitcastsToInt,\n      AMX\n    } Kind;\n\n    union {\n      unsigned Integer_Width;\n      unsigned Float_Width;\n      unsigned Pointer_AddressSpace;\n      unsigned Struct_NumElements;\n      unsigned Argument_Info;\n      ElementCount Vector_Width;\n    };\n\n    enum ArgKind {\n      AK_Any,\n      AK_AnyInteger,\n      AK_AnyFloat,\n      AK_AnyVector,\n      AK_AnyPointer,\n      AK_MatchType = 7\n    };\n\n    unsigned getArgumentNumber() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == PtrToElt || Kind == VecElementArgument ||\n             Kind == Subdivide2Argument || Kind == Subdivide4Argument ||\n             Kind == VecOfBitcastsToInt);\n      return Argument_Info >> 3;\n    }\n    ArgKind getArgumentKind() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == VecElementArgument || Kind == Subdivide2Argument ||\n             Kind == Subdivide4Argument || Kind == VecOfBitcastsToInt);\n      return (ArgKind)(Argument_Info & 7);\n    }\n\n    // VecOfAnyPtrsToElt uses both an overloaded argument (for address space)\n    // and a reference argument (for matching vector width and element types)\n    unsigned getOverloadArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info >> 16;\n    }\n    unsigned getRefArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info & 0xFFFF;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned Field) {\n      IITDescriptor Result = { K, { Field } };\n      return Result;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned short Hi,\n                             unsigned short Lo) {\n      unsigned Field = Hi << 16 | Lo;\n      IITDescriptor Result = {K, {Field}};\n      return Result;\n    }\n\n    static IITDescriptor getVector(unsigned Width, bool IsScalable) {\n      IITDescriptor Result = {Vector, {0}};\n      Result.Vector_Width = ElementCount::get(Width, IsScalable);\n      return Result;\n    }\n  };\n\n  /// Return the IIT table descriptor for the specified intrinsic into an array\n  /// of IITDescriptors.\n  void getIntrinsicInfoTableEntries(ID id, SmallVectorImpl<IITDescriptor> &T);\n\n  enum MatchIntrinsicTypesResult {\n    MatchIntrinsicTypes_Match = 0,\n    MatchIntrinsicTypes_NoMatchRet = 1,\n    MatchIntrinsicTypes_NoMatchArg = 2,\n  };\n\n  /// Match the specified function type with the type constraints specified by\n  /// the .td file. If the given type is an overloaded type it is pushed to the\n  /// ArgTys vector.\n  ///\n  /// Returns false if the given type matches with the constraints, true\n  /// otherwise.\n  MatchIntrinsicTypesResult\n  matchIntrinsicSignature(FunctionType *FTy, ArrayRef<IITDescriptor> &Infos,\n                          SmallVectorImpl<Type *> &ArgTys);\n\n  /// Verify if the intrinsic has variable arguments. This method is intended to\n  /// be called after all the fixed arguments have been matched first.\n  ///\n  /// This method returns true on error.\n  bool matchIntrinsicVarArg(bool isVarArg, ArrayRef<IITDescriptor> &Infos);\n\n  /// Gets the type arguments of an intrinsic call by matching type contraints\n  /// specified by the .td file. The overloaded types are pushed into the\n  /// AgTys vector.\n  ///\n  /// Returns false if the given function is not a valid intrinsic call.\n  bool getIntrinsicSignature(Function *F, SmallVectorImpl<Type *> &ArgTys);\n\n  // Checks if the intrinsic name matches with its signature and if not\n  // returns the declaration with the same signature and remangled name.\n  llvm::Optional<Function*> remangleIntrinsicFunction(Function *F);\n\n} // End Intrinsic namespace\n\n} // End llvm namespace\n\n#endif\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/LLVMContext.h", "content": "//===- llvm/LLVMContext.h - Class for managing \"global\" state ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares LLVMContext, a container of \"global\" state in LLVM, such\n// as the global type and constant uniquing tables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_LLVMCONTEXT_H\n#define LLVM_IR_LLVMCONTEXT_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/IR/DiagnosticHandler.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include <cstdint>\n#include <memory>\n#include <string>\n\nnamespace llvm {\n\nclass DiagnosticInfo;\nenum DiagnosticSeverity : char;\nclass Function;\nclass Instruction;\nclass LLVMContextImpl;\nclass Module;\nclass OptPassGate;\ntemplate <typename T> class SmallVectorImpl;\ntemplate <typename T> class StringMapEntry;\nclass SMDiagnostic;\nclass StringRef;\nclass Twine;\nclass LLVMRemarkStreamer;\nclass raw_ostream;\n\nnamespace remarks {\nclass RemarkStreamer;\n}\n\nnamespace SyncScope {\n\ntypedef uint8_t ID;\n\n/// Known synchronization scope IDs, which always have the same value.  All\n/// synchronization scope IDs that LLVM has special knowledge of are listed\n/// here.  Additionally, this scheme allows LLVM to efficiently check for\n/// specific synchronization scope ID without comparing strings.\nenum {\n  /// Synchronized with respect to signal handlers executing in the same thread.\n  SingleThread = 0,\n\n  /// Synchronized with respect to all concurrently executing threads.\n  System = 1\n};\n\n} // end namespace SyncScope\n\n/// This is an important class for using LLVM in a threaded context.  It\n/// (opaquely) owns and manages the core \"global\" data of LLVM's core\n/// infrastructure, including the type and constant uniquing tables.\n/// LLVMContext itself provides no locking guarantees, so you should be careful\n/// to have one context per thread.\nclass LLVMContext {\npublic:\n  LLVMContextImpl *const pImpl;\n  LLVMContext();\n  LLVMContext(LLVMContext &) = delete;\n  LLVMContext &operator=(const LLVMContext &) = delete;\n  ~LLVMContext();\n\n  // Pinned metadata names, which always have the same value.  This is a\n  // compile-time performance optimization, not a correctness optimization.\n  enum : unsigned {\n#define LLVM_FIXED_MD_KIND(EnumID, Name, Value) EnumID = Value,\n#include \"llvm/IR/FixedMetadataKinds.def\"\n#undef LLVM_FIXED_MD_KIND\n  };\n\n  /// Known operand bundle tag IDs, which always have the same value.  All\n  /// operand bundle tags that LLVM has special knowledge of are listed here.\n  /// Additionally, this scheme allows LLVM to efficiently check for specific\n  /// operand bundle tags without comparing strings. Keep this in sync with\n  /// LLVMContext::LLVMContext().\n  enum : unsigned {\n    OB_deopt = 0,                  // \"deopt\"\n    OB_funclet = 1,                // \"funclet\"\n    OB_gc_transition = 2,          // \"gc-transition\"\n    OB_cfguardtarget = 3,          // \"cfguardtarget\"\n    OB_preallocated = 4,           // \"preallocated\"\n    OB_gc_live = 5,                // \"gc-live\"\n    OB_clang_arc_attachedcall = 6, // \"clang.arc.attachedcall\"\n  };\n\n  /// getMDKindID - Return a unique non-zero ID for the specified metadata kind.\n  /// This ID is uniqued across modules in the current LLVMContext.\n  unsigned getMDKindID(StringRef Name) const;\n\n  /// getMDKindNames - Populate client supplied SmallVector with the name for\n  /// custom metadata IDs registered in this LLVMContext.\n  void getMDKindNames(SmallVectorImpl<StringRef> &Result) const;\n\n  /// getOperandBundleTags - Populate client supplied SmallVector with the\n  /// bundle tags registered in this LLVMContext.  The bundle tags are ordered\n  /// by increasing bundle IDs.\n  /// \\see LLVMContext::getOperandBundleTagID\n  void getOperandBundleTags(SmallVectorImpl<StringRef> &Result) const;\n\n  /// getOrInsertBundleTag - Returns the Tag to use for an operand bundle of\n  /// name TagName.\n  StringMapEntry<uint32_t> *getOrInsertBundleTag(StringRef TagName) const;\n\n  /// getOperandBundleTagID - Maps a bundle tag to an integer ID.  Every bundle\n  /// tag registered with an LLVMContext has an unique ID.\n  uint32_t getOperandBundleTagID(StringRef Tag) const;\n\n  /// getOrInsertSyncScopeID - Maps synchronization scope name to\n  /// synchronization scope ID.  Every synchronization scope registered with\n  /// LLVMContext has unique ID except pre-defined ones.\n  SyncScope::ID getOrInsertSyncScopeID(StringRef SSN);\n\n  /// getSyncScopeNames - Populates client supplied SmallVector with\n  /// synchronization scope names registered with LLVMContext.  Synchronization\n  /// scope names are ordered by increasing synchronization scope IDs.\n  void getSyncScopeNames(SmallVectorImpl<StringRef> &SSNs) const;\n\n  /// Define the GC for a function\n  void setGC(const Function &Fn, std::string GCName);\n\n  /// Return the GC for a function\n  const std::string &getGC(const Function &Fn);\n\n  /// Remove the GC for a function\n  void deleteGC(const Function &Fn);\n\n  /// Return true if the Context runtime configuration is set to discard all\n  /// value names. When true, only GlobalValue names will be available in the\n  /// IR.\n  bool shouldDiscardValueNames() const;\n\n  /// Set the Context runtime configuration to discard all value name (but\n  /// GlobalValue). Clients can use this flag to save memory and runtime,\n  /// especially in release mode.\n  void setDiscardValueNames(bool Discard);\n\n  /// Whether there is a string map for uniquing debug info\n  /// identifiers across the context.  Off by default.\n  bool isODRUniquingDebugTypes() const;\n  void enableDebugTypeODRUniquing();\n  void disableDebugTypeODRUniquing();\n\n  /// Defines the type of a yield callback.\n  /// \\see LLVMContext::setYieldCallback.\n  using YieldCallbackTy = void (*)(LLVMContext *Context, void *OpaqueHandle);\n\n  /// setDiagnosticHandlerCallBack - This method sets a handler call back\n  /// that is invoked when the backend needs to report anything to the user.\n  /// The first argument is a function pointer and the second is a context pointer\n  /// that gets passed into the DiagHandler.  The third argument should be set to\n  /// true if the handler only expects enabled diagnostics.\n  ///\n  /// LLVMContext doesn't take ownership or interpret either of these\n  /// pointers.\n  void setDiagnosticHandlerCallBack(\n      DiagnosticHandler::DiagnosticHandlerTy DiagHandler,\n      void *DiagContext = nullptr, bool RespectFilters = false);\n\n  /// setDiagnosticHandler - This method sets unique_ptr to object of\n  /// DiagnosticHandler to provide custom diagnostic handling. The first\n  /// argument is unique_ptr of object of type DiagnosticHandler or a derived\n  /// of that. The second argument should be set to true if the handler only\n  /// expects enabled diagnostics.\n  ///\n  /// Ownership of this pointer is moved to LLVMContextImpl.\n  void setDiagnosticHandler(std::unique_ptr<DiagnosticHandler> &&DH,\n                            bool RespectFilters = false);\n\n  /// getDiagnosticHandlerCallBack - Return the diagnostic handler call back set by\n  /// setDiagnosticHandlerCallBack.\n  DiagnosticHandler::DiagnosticHandlerTy getDiagnosticHandlerCallBack() const;\n\n  /// getDiagnosticContext - Return the diagnostic context set by\n  /// setDiagnosticContext.\n  void *getDiagnosticContext() const;\n\n  /// getDiagHandlerPtr - Returns const raw pointer of DiagnosticHandler set by\n  /// setDiagnosticHandler.\n  const DiagnosticHandler *getDiagHandlerPtr() const;\n\n  /// getDiagnosticHandler - transfers ownership of DiagnosticHandler unique_ptr\n  /// to caller.\n  std::unique_ptr<DiagnosticHandler> getDiagnosticHandler();\n\n  /// Return if a code hotness metric should be included in optimization\n  /// diagnostics.\n  bool getDiagnosticsHotnessRequested() const;\n  /// Set if a code hotness metric should be included in optimization\n  /// diagnostics.\n  void setDiagnosticsHotnessRequested(bool Requested);\n\n  /// Return the minimum hotness value a diagnostic would need in order\n  /// to be included in optimization diagnostics.\n  ///\n  /// Three possible return values:\n  /// 0            - threshold is disabled. Everything will be printed out.\n  /// positive int - threshold is set.\n  /// UINT64_MAX   - threshold is not yet set, and needs to be synced from\n  ///                profile summary. Note that in case of missing profile\n  ///                summary, threshold will be kept at \"MAX\", effectively\n  ///                suppresses all remarks output.\n  uint64_t getDiagnosticsHotnessThreshold() const;\n\n  /// Set the minimum hotness value a diagnostic needs in order to be\n  /// included in optimization diagnostics.\n  void setDiagnosticsHotnessThreshold(Optional<uint64_t> Threshold);\n\n  /// Return if hotness threshold is requested from PSI.\n  bool isDiagnosticsHotnessThresholdSetFromPSI() const;\n\n  /// The \"main remark streamer\" used by all the specialized remark streamers.\n  /// This streamer keeps generic remark metadata in memory throughout the life\n  /// of the LLVMContext. This metadata may be emitted in a section in object\n  /// files depending on the format requirements.\n  ///\n  /// All specialized remark streamers should convert remarks to\n  /// llvm::remarks::Remark and emit them through this streamer.\n  remarks::RemarkStreamer *getMainRemarkStreamer();\n  const remarks::RemarkStreamer *getMainRemarkStreamer() const;\n  void setMainRemarkStreamer(\n      std::unique_ptr<remarks::RemarkStreamer> MainRemarkStreamer);\n\n  /// The \"LLVM remark streamer\" used by LLVM to serialize remark diagnostics\n  /// comming from IR and MIR passes.\n  ///\n  /// If it does not exist, diagnostics are not saved in a file but only emitted\n  /// via the diagnostic handler.\n  LLVMRemarkStreamer *getLLVMRemarkStreamer();\n  const LLVMRemarkStreamer *getLLVMRemarkStreamer() const;\n  void\n  setLLVMRemarkStreamer(std::unique_ptr<LLVMRemarkStreamer> RemarkStreamer);\n\n  /// Get the prefix that should be printed in front of a diagnostic of\n  ///        the given \\p Severity\n  static const char *getDiagnosticMessagePrefix(DiagnosticSeverity Severity);\n\n  /// Report a message to the currently installed diagnostic handler.\n  ///\n  /// This function returns, in particular in the case of error reporting\n  /// (DI.Severity == \\a DS_Error), so the caller should leave the compilation\n  /// process in a self-consistent state, even though the generated code\n  /// need not be correct.\n  ///\n  /// The diagnostic message will be implicitly prefixed with a severity keyword\n  /// according to \\p DI.getSeverity(), i.e., \"error: \" for \\a DS_Error,\n  /// \"warning: \" for \\a DS_Warning, and \"note: \" for \\a DS_Note.\n  void diagnose(const DiagnosticInfo &DI);\n\n  /// Registers a yield callback with the given context.\n  ///\n  /// The yield callback function may be called by LLVM to transfer control back\n  /// to the client that invoked the LLVM compilation. This can be used to yield\n  /// control of the thread, or perform periodic work needed by the client.\n  /// There is no guaranteed frequency at which callbacks must occur; in fact,\n  /// the client is not guaranteed to ever receive this callback. It is at the\n  /// sole discretion of LLVM to do so and only if it can guarantee that\n  /// suspending the thread won't block any forward progress in other LLVM\n  /// contexts in the same process.\n  ///\n  /// At a suspend point, the state of the current LLVM context is intentionally\n  /// undefined. No assumptions about it can or should be made. Only LLVM\n  /// context API calls that explicitly state that they can be used during a\n  /// yield callback are allowed to be used. Any other API calls into the\n  /// context are not supported until the yield callback function returns\n  /// control to LLVM. Other LLVM contexts are unaffected by this restriction.\n  void setYieldCallback(YieldCallbackTy Callback, void *OpaqueHandle);\n\n  /// Calls the yield callback (if applicable).\n  ///\n  /// This transfers control of the current thread back to the client, which may\n  /// suspend the current thread. Only call this method when LLVM doesn't hold\n  /// any global mutex or cannot block the execution in another LLVM context.\n  void yield();\n\n  /// emitError - Emit an error message to the currently installed error handler\n  /// with optional location information.  This function returns, so code should\n  /// be prepared to drop the erroneous construct on the floor and \"not crash\".\n  /// The generated code need not be correct.  The error message will be\n  /// implicitly prefixed with \"error: \" and should not end with a \".\".\n  void emitError(unsigned LocCookie, const Twine &ErrorStr);\n  void emitError(const Instruction *I, const Twine &ErrorStr);\n  void emitError(const Twine &ErrorStr);\n\n  /// Access the object which can disable optional passes and individual\n  /// optimizations at compile time.\n  OptPassGate &getOptPassGate() const;\n\n  /// Set the object which can disable optional passes and individual\n  /// optimizations at compile time.\n  ///\n  /// The lifetime of the object must be guaranteed to extend as long as the\n  /// LLVMContext is used by compilation.\n  void setOptPassGate(OptPassGate&);\n\nprivate:\n  // Module needs access to the add/removeModule methods.\n  friend class Module;\n\n  /// addModule - Register a module as being instantiated in this context.  If\n  /// the context is deleted, the module will be deleted as well.\n  void addModule(Module*);\n\n  /// removeModule - Unregister a module from this context.\n  void removeModule(Module*);\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(LLVMContext, LLVMContextRef)\n\n/* Specialized opaque context conversions.\n */\ninline LLVMContext **unwrap(LLVMContextRef* Tys) {\n  return reinterpret_cast<LLVMContext**>(Tys);\n}\n\ninline LLVMContextRef *wrap(const LLVMContext **Tys) {\n  return reinterpret_cast<LLVMContextRef*>(const_cast<LLVMContext**>(Tys));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_LLVMCONTEXT_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "content": "//===- llvm/IR/Metadata.h - Metadata definitions ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declarations for metadata subclasses.\n/// They represent the different flavors of metadata that live in LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_METADATA_H\n#define LLVM_IR_METADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\nclass Type;\n\nenum LLVMConstants : uint32_t {\n  DEBUG_METADATA_VERSION = 3 // Current debug info version number.\n};\n\n/// Root of the metadata hierarchy.\n///\n/// This is a root class for typeless data in the IR.\nclass Metadata {\n  friend class ReplaceableMetadataImpl;\n\n  /// RTTI.\n  const unsigned char SubclassID;\n\nprotected:\n  /// Active type of storage.\n  enum StorageType { Uniqued, Distinct, Temporary };\n\n  /// Storage flag for non-uniqued, otherwise unowned, metadata.\n  unsigned char Storage : 7;\n\n  unsigned char SubclassData1 : 1;\n  unsigned short SubclassData16 = 0;\n  unsigned SubclassData32 = 0;\n\npublic:\n  enum MetadataKind {\n#define HANDLE_METADATA_LEAF(CLASS) CLASS##Kind,\n#include \"llvm/IR/Metadata.def\"\n  };\n\nprotected:\n  Metadata(unsigned ID, StorageType Storage)\n      : SubclassID(ID), Storage(Storage), SubclassData1(false) {\n    static_assert(sizeof(*this) == 8, \"Metadata fields poorly packed\");\n  }\n\n  ~Metadata() = default;\n\n  /// Default handling of a changed operand, which asserts.\n  ///\n  /// If subclasses pass themselves in as owners to a tracking node reference,\n  /// they must provide an implementation of this method.\n  void handleChangedOperand(void *, Metadata *) {\n    llvm_unreachable(\"Unimplemented in Metadata subclass\");\n  }\n\npublic:\n  unsigned getMetadataID() const { return SubclassID; }\n\n  /// User-friendly dump.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  ///\n  /// Note: this uses an explicit overload instead of default arguments so that\n  /// the nullptr version is easy to call from a debugger.\n  ///\n  /// @{\n  void dump() const;\n  void dump(const Module *M) const;\n  /// @}\n\n  /// Print.\n  ///\n  /// Prints definition of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void print(raw_ostream &OS, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print as operand.\n  ///\n  /// Prints reference of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void printAsOperand(raw_ostream &OS, const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &OS, ModuleSlotTracker &MST,\n                      const Module *M = nullptr) const;\n  /// @}\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMMetadataRef)\n\n// Specialized opaque metadata conversions.\ninline Metadata **unwrap(LLVMMetadataRef *MDs) {\n  return reinterpret_cast<Metadata**>(MDs);\n}\n\n#define HANDLE_METADATA(CLASS) class CLASS;\n#include \"llvm/IR/Metadata.def\"\n\n// Provide specializations of isa so that we don't need definitions of\n// subclasses to see if the metadata is a subclass.\n#define HANDLE_METADATA_LEAF(CLASS)                                            \\\n  template <> struct isa_impl<CLASS, Metadata> {                               \\\n    static inline bool doit(const Metadata &MD) {                              \\\n      return MD.getMetadataID() == Metadata::CLASS##Kind;                      \\\n    }                                                                          \\\n  };\n#include \"llvm/IR/Metadata.def\"\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Metadata &MD) {\n  MD.print(OS);\n  return OS;\n}\n\n/// Metadata wrapper in the Value hierarchy.\n///\n/// A member of the \\a Value hierarchy to represent a reference to metadata.\n/// This allows, e.g., instrinsics to have metadata as operands.\n///\n/// Notably, this is the only thing in either hierarchy that is allowed to\n/// reference \\a LocalAsMetadata.\nclass MetadataAsValue : public Value {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Metadata *MD;\n\n  MetadataAsValue(Type *Ty, Metadata *MD);\n\n  /// Drop use of metadata (during teardown).\n  void dropUse() { MD = nullptr; }\n\npublic:\n  ~MetadataAsValue();\n\n  static MetadataAsValue *get(LLVMContext &Context, Metadata *MD);\n  static MetadataAsValue *getIfExists(LLVMContext &Context, Metadata *MD);\n\n  Metadata *getMetadata() const { return MD; }\n\n  static bool classof(const Value *V) {\n    return V->getValueID() == MetadataAsValueVal;\n  }\n\nprivate:\n  void handleChangedMetadata(Metadata *MD);\n  void track();\n  void untrack();\n};\n\n/// API for tracking metadata references through RAUW and deletion.\n///\n/// Shared API for updating \\a Metadata pointers in subclasses that support\n/// RAUW.\n///\n/// This API is not meant to be used directly.  See \\a TrackingMDRef for a\n/// user-friendly tracking reference.\nclass MetadataTracking {\npublic:\n  /// Track the reference to metadata.\n  ///\n  /// Register \\c MD with \\c *MD, if the subclass supports tracking.  If \\c *MD\n  /// gets RAUW'ed, \\c MD will be updated to the new address.  If \\c *MD gets\n  /// deleted, \\c MD will be set to \\c nullptr.\n  ///\n  /// If tracking isn't supported, \\c *MD will not change.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool track(Metadata *&MD) {\n    return track(&MD, *MD, static_cast<Metadata *>(nullptr));\n  }\n\n  /// Track the reference to metadata for \\a Metadata.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, Metadata &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Track the reference to metadata for \\a MetadataAsValue.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, MetadataAsValue &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Stop tracking a reference to metadata.\n  ///\n  /// Stops \\c *MD from tracking \\c MD.\n  static void untrack(Metadata *&MD) { untrack(&MD, *MD); }\n  static void untrack(void *Ref, Metadata &MD);\n\n  /// Move tracking from one reference to another.\n  ///\n  /// Semantically equivalent to \\c untrack(MD) followed by \\c track(New),\n  /// except that ownership callbacks are maintained.\n  ///\n  /// Note: it is an error if \\c *MD does not equal \\c New.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool retrack(Metadata *&MD, Metadata *&New) {\n    return retrack(&MD, *MD, &New);\n  }\n  static bool retrack(void *Ref, Metadata &MD, void *New);\n\n  /// Check whether metadata is replaceable.\n  static bool isReplaceable(const Metadata &MD);\n\n  using OwnerTy = PointerUnion<MetadataAsValue *, Metadata *>;\n\nprivate:\n  /// Track a reference to metadata for an owner.\n  ///\n  /// Generalized version of tracking.\n  static bool track(void *Ref, Metadata &MD, OwnerTy Owner);\n};\n\n/// Shared implementation of use-lists for replaceable metadata.\n///\n/// Most metadata cannot be RAUW'ed.  This is a shared implementation of\n/// use-lists and associated API for the two that support it (\\a ValueAsMetadata\n/// and \\a TempMDNode).\nclass ReplaceableMetadataImpl {\n  friend class MetadataTracking;\n\npublic:\n  using OwnerTy = MetadataTracking::OwnerTy;\n\nprivate:\n  LLVMContext &Context;\n  uint64_t NextIndex = 0;\n  SmallDenseMap<void *, std::pair<OwnerTy, uint64_t>, 4> UseMap;\n\npublic:\n  ReplaceableMetadataImpl(LLVMContext &Context) : Context(Context) {}\n\n  ~ReplaceableMetadataImpl() {\n    assert(UseMap.empty() && \"Cannot destroy in-use replaceable metadata\");\n  }\n\n  LLVMContext &getContext() const { return Context; }\n\n  /// Replace all uses of this with MD.\n  ///\n  /// Replace all uses of this with \\c MD, which is allowed to be null.\n  void replaceAllUsesWith(Metadata *MD);\n\n  /// Returns the list of all DIArgList users of this.\n  SmallVector<Metadata *, 4> getAllArgListUsers();\n\n  /// Resolve all uses of this.\n  ///\n  /// Resolve all uses of this, turning off RAUW permanently.  If \\c\n  /// ResolveUsers, call \\a MDNode::resolve() on any users whose last operand\n  /// is resolved.\n  void resolveAllUses(bool ResolveUsers = true);\n\nprivate:\n  void addRef(void *Ref, OwnerTy Owner);\n  void dropRef(void *Ref);\n  void moveRef(void *Ref, void *New, const Metadata &MD);\n\n  /// Lazily construct RAUW support on MD.\n  ///\n  /// If this is an unresolved MDNode, RAUW support will be created on-demand.\n  /// ValueAsMetadata always has RAUW support.\n  static ReplaceableMetadataImpl *getOrCreate(Metadata &MD);\n\n  /// Get RAUW support on MD, if it exists.\n  static ReplaceableMetadataImpl *getIfExists(Metadata &MD);\n\n  /// Check whether this node will support RAUW.\n  ///\n  /// Returns \\c true unless getOrCreate() would return null.\n  static bool isReplaceable(const Metadata &MD);\n};\n\n/// Value wrapper in the Metadata hierarchy.\n///\n/// This is a custom value handle that allows other metadata to refer to\n/// classes in the Value hierarchy.\n///\n/// Because of full uniquing support, each value is only wrapped by a single \\a\n/// ValueAsMetadata object, so the lookup maps are far more efficient than\n/// those using ValueHandleBase.\nclass ValueAsMetadata : public Metadata, ReplaceableMetadataImpl {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Value *V;\n\n  /// Drop users without RAUW (during teardown).\n  void dropUsers() {\n    ReplaceableMetadataImpl::resolveAllUses(/* ResolveUsers */ false);\n  }\n\nprotected:\n  ValueAsMetadata(unsigned ID, Value *V)\n      : Metadata(ID, Uniqued), ReplaceableMetadataImpl(V->getContext()), V(V) {\n    assert(V && \"Expected valid value\");\n  }\n\n  ~ValueAsMetadata() = default;\n\npublic:\n  static ValueAsMetadata *get(Value *V);\n\n  static ConstantAsMetadata *getConstant(Value *C) {\n    return cast<ConstantAsMetadata>(get(C));\n  }\n\n  static LocalAsMetadata *getLocal(Value *Local) {\n    return cast<LocalAsMetadata>(get(Local));\n  }\n\n  static ValueAsMetadata *getIfExists(Value *V);\n\n  static ConstantAsMetadata *getConstantIfExists(Value *C) {\n    return cast_or_null<ConstantAsMetadata>(getIfExists(C));\n  }\n\n  static LocalAsMetadata *getLocalIfExists(Value *Local) {\n    return cast_or_null<LocalAsMetadata>(getIfExists(Local));\n  }\n\n  Value *getValue() const { return V; }\n  Type *getType() const { return V->getType(); }\n  LLVMContext &getContext() const { return V->getContext(); }\n\n  SmallVector<Metadata *, 4> getAllArgListUsers() {\n    return ReplaceableMetadataImpl::getAllArgListUsers();\n  }\n\n  static void handleDeletion(Value *V);\n  static void handleRAUW(Value *From, Value *To);\n\nprotected:\n  /// Handle collisions after \\a Value::replaceAllUsesWith().\n  ///\n  /// RAUW isn't supported directly for \\a ValueAsMetadata, but if the wrapped\n  /// \\a Value gets RAUW'ed and the target already exists, this is used to\n  /// merge the two metadata nodes.\n  void replaceAllUsesWith(Metadata *MD) {\n    ReplaceableMetadataImpl::replaceAllUsesWith(MD);\n  }\n\npublic:\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind ||\n           MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass ConstantAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  ConstantAsMetadata(Constant *C)\n      : ValueAsMetadata(ConstantAsMetadataKind, C) {}\n\npublic:\n  static ConstantAsMetadata *get(Constant *C) {\n    return ValueAsMetadata::getConstant(C);\n  }\n\n  static ConstantAsMetadata *getIfExists(Constant *C) {\n    return ValueAsMetadata::getConstantIfExists(C);\n  }\n\n  Constant *getValue() const {\n    return cast<Constant>(ValueAsMetadata::getValue());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass LocalAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  LocalAsMetadata(Value *Local)\n      : ValueAsMetadata(LocalAsMetadataKind, Local) {\n    assert(!isa<Constant>(Local) && \"Expected local value\");\n  }\n\npublic:\n  static LocalAsMetadata *get(Value *Local) {\n    return ValueAsMetadata::getLocal(Local);\n  }\n\n  static LocalAsMetadata *getIfExists(Value *Local) {\n    return ValueAsMetadata::getLocalIfExists(Local);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind;\n  }\n};\n\n/// Transitional API for extracting constants from Metadata.\n///\n/// This namespace contains transitional functions for metadata that points to\n/// \\a Constants.\n///\n/// In prehistory -- when metadata was a subclass of \\a Value -- \\a MDNode\n/// operands could refer to any \\a Value.  There's was a lot of code like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = dyn_cast<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// Now that \\a Value and \\a Metadata are in separate hierarchies, maintaining\n/// the semantics for \\a isa(), \\a cast(), \\a dyn_cast() (etc.) requires three\n/// steps: cast in the \\a Metadata hierarchy, extraction of the \\a Value, and\n/// cast in the \\a Value hierarchy.  Besides creating boiler-plate, this\n/// requires subtle control flow changes.\n///\n/// The end-goal is to create a new type of metadata, called (e.g.) \\a MDInt,\n/// so that metadata can refer to numbers without traversing a bridge to the \\a\n/// Value hierarchy.  In this final state, the code above would look like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *MI = dyn_cast<MDInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The API in this namespace supports the transition.  \\a MDInt doesn't exist\n/// yet, and even once it does, changing each metadata schema to use it is its\n/// own mini-project.  In the meantime this API prevents us from introducing\n/// complex and bug-prone control flow that will disappear in the end.  In\n/// particular, the above code looks like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = mdconst::dyn_extract<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The full set of provided functions includes:\n///\n///   mdconst::hasa                <=> isa\n///   mdconst::extract             <=> cast\n///   mdconst::extract_or_null     <=> cast_or_null\n///   mdconst::dyn_extract         <=> dyn_cast\n///   mdconst::dyn_extract_or_null <=> dyn_cast_or_null\n///\n/// The target of the cast must be a subclass of \\a Constant.\nnamespace mdconst {\n\nnamespace detail {\n\ntemplate <class T> T &make();\ntemplate <class T, class Result> struct HasDereference {\n  using Yes = char[1];\n  using No = char[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U, class V>\n  static Yes &hasDereference(SFINAE<sizeof(static_cast<V>(*make<U>()))> * = 0);\n  template <class U, class V> static No &hasDereference(...);\n\n  static const bool value =\n      sizeof(hasDereference<T, Result>(nullptr)) == sizeof(Yes);\n};\ntemplate <class V, class M> struct IsValidPointer {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            HasDereference<M, const Metadata &>::value;\n};\ntemplate <class V, class M> struct IsValidReference {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            std::is_convertible<M, const Metadata &>::value;\n};\n\n} // end namespace detail\n\n/// Check whether Metadata has a Value.\n///\n/// As an analogue to \\a isa(), check whether \\c MD has an \\a Value inside of\n/// type \\c X.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, bool>\nhasa(Y &&MD) {\n  assert(MD && \"Null pointer sent into hasa\");\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return isa<X>(V->getValue());\n  return false;\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, bool>\nhasa(Y &MD) {\n  return hasa(&MD);\n}\n\n/// Extract a Value from Metadata.\n///\n/// As an analogue to \\a cast(), extract the \\a Value subclass \\c X from \\c MD.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract(Y &&MD) {\n  return cast<X>(cast<ConstantAsMetadata>(MD)->getValue());\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, X *>\nextract(Y &MD) {\n  return extract(&MD);\n}\n\n/// Extract a Value from Metadata, allowing null.\n///\n/// As an analogue to \\a cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract_or_null(Y &&MD) {\n  if (auto *V = cast_or_null<ConstantAsMetadata>(MD))\n    return cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract(Y &&MD) {\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any, allowing null.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract_or_null(Y &&MD) {\n  if (auto *V = dyn_cast_or_null<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n} // end namespace mdconst\n\n//===----------------------------------------------------------------------===//\n/// A single uniqued string.\n///\n/// These are used to efficiently contain a byte sequence for metadata.\n/// MDString is always unnamed.\nclass MDString : public Metadata {\n  friend class StringMapEntryStorage<MDString>;\n\n  StringMapEntry<MDString> *Entry = nullptr;\n\n  MDString() : Metadata(MDStringKind, Uniqued) {}\n\npublic:\n  MDString(const MDString &) = delete;\n  MDString &operator=(MDString &&) = delete;\n  MDString &operator=(const MDString &) = delete;\n\n  static MDString *get(LLVMContext &Context, StringRef Str);\n  static MDString *get(LLVMContext &Context, const char *Str) {\n    return get(Context, Str ? StringRef(Str) : StringRef());\n  }\n\n  StringRef getString() const;\n\n  unsigned getLength() const { return (unsigned)getString().size(); }\n\n  using iterator = StringRef::iterator;\n\n  /// Pointer to the first byte of the string.\n  iterator begin() const { return getString().begin(); }\n\n  /// Pointer to one byte past the end of the string.\n  iterator end() const { return getString().end(); }\n\n  const unsigned char *bytes_begin() const { return getString().bytes_begin(); }\n  const unsigned char *bytes_end() const { return getString().bytes_end(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDStringKind;\n  }\n};\n\n/// A collection of metadata nodes that might be associated with a\n/// memory access used by the alias-analysis infrastructure.\nstruct AAMDNodes {\n  explicit AAMDNodes() = default;\n  explicit AAMDNodes(MDNode *T, MDNode *TS, MDNode *S, MDNode *N)\n      : TBAA(T), TBAAStruct(TS), Scope(S), NoAlias(N) {}\n\n  bool operator==(const AAMDNodes &A) const {\n    return TBAA == A.TBAA && TBAAStruct == A.TBAAStruct && Scope == A.Scope &&\n           NoAlias == A.NoAlias;\n  }\n\n  bool operator!=(const AAMDNodes &A) const { return !(*this == A); }\n\n  explicit operator bool() const {\n    return TBAA || TBAAStruct || Scope || NoAlias;\n  }\n\n  /// The tag for type-based alias analysis.\n  MDNode *TBAA = nullptr;\n\n  /// The tag for type-based alias analysis (tbaa struct).\n  MDNode *TBAAStruct = nullptr;\n\n  /// The tag for alias scope specification (used with noalias).\n  MDNode *Scope = nullptr;\n\n  /// The tag specifying the noalias scope.\n  MDNode *NoAlias = nullptr;\n\n  // Shift tbaa Metadata node to start off bytes later\n  static MDNode *ShiftTBAA(MDNode *M, size_t off);\n\n  // Shift tbaa.struct Metadata node to start off bytes later\n  static MDNode *ShiftTBAAStruct(MDNode *M, size_t off);\n\n  /// Given two sets of AAMDNodes that apply to the same pointer,\n  /// give the best AAMDNodes that are compatible with both (i.e. a set of\n  /// nodes whose allowable aliasing conclusions are a subset of those\n  /// allowable by both of the inputs). However, for efficiency\n  /// reasons, do not create any new MDNodes.\n  AAMDNodes intersect(const AAMDNodes &Other) {\n    AAMDNodes Result;\n    Result.TBAA = Other.TBAA == TBAA ? TBAA : nullptr;\n    Result.TBAAStruct = Other.TBAAStruct == TBAAStruct ? TBAAStruct : nullptr;\n    Result.Scope = Other.Scope == Scope ? Scope : nullptr;\n    Result.NoAlias = Other.NoAlias == NoAlias ? NoAlias : nullptr;\n    return Result;\n  }\n\n  /// Create a new AAMDNode that describes this AAMDNode after applying a\n  /// constant offset to the start of the pointer\n  AAMDNodes shift(size_t Offset) {\n    AAMDNodes Result;\n    Result.TBAA = TBAA ? ShiftTBAA(TBAA, Offset) : nullptr;\n    Result.TBAAStruct =\n        TBAAStruct ? ShiftTBAAStruct(TBAAStruct, Offset) : nullptr;\n    Result.Scope = Scope;\n    Result.NoAlias = NoAlias;\n    return Result;\n  }\n};\n\n// Specialize DenseMapInfo for AAMDNodes.\ntemplate<>\nstruct DenseMapInfo<AAMDNodes> {\n  static inline AAMDNodes getEmptyKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getEmptyKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static inline AAMDNodes getTombstoneKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getTombstoneKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static unsigned getHashValue(const AAMDNodes &Val) {\n    return DenseMapInfo<MDNode *>::getHashValue(Val.TBAA) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.TBAAStruct) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.Scope) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.NoAlias);\n  }\n\n  static bool isEqual(const AAMDNodes &LHS, const AAMDNodes &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// Tracking metadata reference owned by Metadata.\n///\n/// Similar to \\a TrackingMDRef, but it's expected to be owned by an instance\n/// of \\a Metadata, which has the option of registering itself for callbacks to\n/// re-unique itself.\n///\n/// In particular, this is used by \\a MDNode.\nclass MDOperand {\n  Metadata *MD = nullptr;\n\npublic:\n  MDOperand() = default;\n  MDOperand(MDOperand &&) = delete;\n  MDOperand(const MDOperand &) = delete;\n  MDOperand &operator=(MDOperand &&) = delete;\n  MDOperand &operator=(const MDOperand &) = delete;\n  ~MDOperand() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD, Metadata *Owner) {\n    untrack();\n    this->MD = MD;\n    track(Owner);\n  }\n\nprivate:\n  void track(Metadata *Owner) {\n    if (MD) {\n      if (Owner)\n        MetadataTracking::track(this, *MD, *Owner);\n      else\n        MetadataTracking::track(MD);\n    }\n  }\n\n  void untrack() {\n    assert(static_cast<void *>(this) == &MD && \"Expected same address\");\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n};\n\ntemplate <> struct simplify_type<MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(MDOperand &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const MDOperand &MD) { return MD.get(); }\n};\n\n/// Pointer to the context, with optional RAUW support.\n///\n/// Either a raw (non-null) pointer to the \\a LLVMContext, or an owned pointer\n/// to \\a ReplaceableMetadataImpl (which has a reference to \\a LLVMContext).\nclass ContextAndReplaceableUses {\n  PointerUnion<LLVMContext *, ReplaceableMetadataImpl *> Ptr;\n\npublic:\n  ContextAndReplaceableUses(LLVMContext &Context) : Ptr(&Context) {}\n  ContextAndReplaceableUses(\n      std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses)\n      : Ptr(ReplaceableUses.release()) {\n    assert(getReplaceableUses() && \"Expected non-null replaceable uses\");\n  }\n  ContextAndReplaceableUses() = delete;\n  ContextAndReplaceableUses(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses(const ContextAndReplaceableUses &) = delete;\n  ContextAndReplaceableUses &operator=(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses &\n  operator=(const ContextAndReplaceableUses &) = delete;\n  ~ContextAndReplaceableUses() { delete getReplaceableUses(); }\n\n  operator LLVMContext &() { return getContext(); }\n\n  /// Whether this contains RAUW support.\n  bool hasReplaceableUses() const {\n    return Ptr.is<ReplaceableMetadataImpl *>();\n  }\n\n  LLVMContext &getContext() const {\n    if (hasReplaceableUses())\n      return getReplaceableUses()->getContext();\n    return *Ptr.get<LLVMContext *>();\n  }\n\n  ReplaceableMetadataImpl *getReplaceableUses() const {\n    if (hasReplaceableUses())\n      return Ptr.get<ReplaceableMetadataImpl *>();\n    return nullptr;\n  }\n\n  /// Ensure that this has RAUW support, and then return it.\n  ReplaceableMetadataImpl *getOrCreateReplaceableUses() {\n    if (!hasReplaceableUses())\n      makeReplaceable(std::make_unique<ReplaceableMetadataImpl>(getContext()));\n    return getReplaceableUses();\n  }\n\n  /// Assign RAUW support to this.\n  ///\n  /// Make this replaceable, taking ownership of \\c ReplaceableUses (which must\n  /// not be null).\n  void\n  makeReplaceable(std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses) {\n    assert(ReplaceableUses && \"Expected non-null replaceable uses\");\n    assert(&ReplaceableUses->getContext() == &getContext() &&\n           \"Expected same context\");\n    delete getReplaceableUses();\n    Ptr = ReplaceableUses.release();\n  }\n\n  /// Drop RAUW support.\n  ///\n  /// Cede ownership of RAUW support, returning it.\n  std::unique_ptr<ReplaceableMetadataImpl> takeReplaceableUses() {\n    assert(hasReplaceableUses() && \"Expected to own replaceable uses\");\n    std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses(\n        getReplaceableUses());\n    Ptr = &ReplaceableUses->getContext();\n    return ReplaceableUses;\n  }\n};\n\nstruct TempMDNodeDeleter {\n  inline void operator()(MDNode *Node) const;\n};\n\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  using Temp##CLASS = std::unique_ptr<CLASS, TempMDNodeDeleter>;\n#define HANDLE_MDNODE_BRANCH(CLASS) HANDLE_MDNODE_LEAF(CLASS)\n#include \"llvm/IR/Metadata.def\"\n\n/// Metadata node.\n///\n/// Metadata nodes can be uniqued, like constants, or distinct.  Temporary\n/// metadata nodes (with full support for RAUW) can be used to delay uniquing\n/// until forward references are known.  The basic metadata node is an \\a\n/// MDTuple.\n///\n/// There is limited support for RAUW at construction time.  At construction\n/// time, if any operand is a temporary node (or an unresolved uniqued node,\n/// which indicates a transitive temporary operand), the node itself will be\n/// unresolved.  As soon as all operands become resolved, it will drop RAUW\n/// support permanently.\n///\n/// If an unresolved node is part of a cycle, \\a resolveCycles() needs\n/// to be called on some member of the cycle once all temporary nodes have been\n/// replaced.\nclass MDNode : public Metadata {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  unsigned NumOperands;\n  unsigned NumUnresolved;\n\n  ContextAndReplaceableUses Context;\n\nprotected:\n  MDNode(LLVMContext &Context, unsigned ID, StorageType Storage,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None);\n  ~MDNode() = default;\n\n  void *operator new(size_t Size, unsigned NumOps);\n  void operator delete(void *Mem);\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned, bool) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  void dropAllReferences();\n\n  MDOperand *mutable_begin() { return mutable_end() - NumOperands; }\n  MDOperand *mutable_end() { return reinterpret_cast<MDOperand *>(this); }\n\n  using mutable_op_range = iterator_range<MDOperand *>;\n\n  mutable_op_range mutable_operands() {\n    return mutable_op_range(mutable_begin(), mutable_end());\n  }\n\npublic:\n  MDNode(const MDNode &) = delete;\n  void operator=(const MDNode &) = delete;\n  void *operator new(size_t) = delete;\n\n  static inline MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getIfExists(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getDistinct(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline TempMDTuple getTemporary(LLVMContext &Context,\n                                         ArrayRef<Metadata *> MDs);\n\n  /// Create a (temporary) clone of this.\n  TempMDNode clone() const;\n\n  /// Deallocate a node created by getTemporary.\n  ///\n  /// Calls \\c replaceAllUsesWith(nullptr) before deleting, so any remaining\n  /// references will be reset.\n  static void deleteTemporary(MDNode *N);\n\n  LLVMContext &getContext() const { return Context.getContext(); }\n\n  /// Replace a specific operand.\n  void replaceOperandWith(unsigned I, Metadata *New);\n\n  /// Check if node is fully resolved.\n  ///\n  /// If \\a isTemporary(), this always returns \\c false; if \\a isDistinct(),\n  /// this always returns \\c true.\n  ///\n  /// If \\a isUniqued(), returns \\c true if this has already dropped RAUW\n  /// support (because all operands are resolved).\n  ///\n  /// As forward declarations are resolved, their containers should get\n  /// resolved automatically.  However, if this (or one of its operands) is\n  /// involved in a cycle, \\a resolveCycles() needs to be called explicitly.\n  bool isResolved() const { return !isTemporary() && !NumUnresolved; }\n\n  bool isUniqued() const { return Storage == Uniqued; }\n  bool isDistinct() const { return Storage == Distinct; }\n  bool isTemporary() const { return Storage == Temporary; }\n\n  /// RAUW a temporary.\n  ///\n  /// \\pre \\a isTemporary() must be \\c true.\n  void replaceAllUsesWith(Metadata *MD) {\n    assert(isTemporary() && \"Expected temporary node\");\n    if (Context.hasReplaceableUses())\n      Context.getReplaceableUses()->replaceAllUsesWith(MD);\n  }\n\n  /// Resolve cycles.\n  ///\n  /// Once all forward declarations have been resolved, force cycles to be\n  /// resolved.\n  ///\n  /// \\pre No operands (or operands' operands, etc.) have \\a isTemporary().\n  void resolveCycles();\n\n  /// Resolve a unique, unresolved node.\n  void resolve();\n\n  /// Replace a temporary node with a permanent one.\n  ///\n  /// Try to create a uniqued version of \\c N -- in place, if possible -- and\n  /// return it.  If \\c N cannot be uniqued, return a distinct node instead.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithPermanent(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithPermanentImpl());\n  }\n\n  /// Replace a temporary node with a uniqued one.\n  ///\n  /// Create a uniqued version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  ///\n  /// \\pre N does not self-reference.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithUniqued(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithUniquedImpl());\n  }\n\n  /// Replace a temporary node with a distinct one.\n  ///\n  /// Create a distinct version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithDistinct(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithDistinctImpl());\n  }\n\nprivate:\n  MDNode *replaceWithPermanentImpl();\n  MDNode *replaceWithUniquedImpl();\n  MDNode *replaceWithDistinctImpl();\n\nprotected:\n  /// Set an operand.\n  ///\n  /// Sets the operand directly, without worrying about uniquing.\n  void setOperand(unsigned I, Metadata *New);\n\n  void storeDistinctInContext();\n  template <class T, class StoreT>\n  static T *storeImpl(T *N, StorageType Storage, StoreT &Store);\n  template <class T> static T *storeImpl(T *N, StorageType Storage);\n\nprivate:\n  void handleChangedOperand(void *Ref, Metadata *New);\n\n  /// Drop RAUW support, if any.\n  void dropReplaceableUses();\n\n  void resolveAfterOperandChange(Metadata *Old, Metadata *New);\n  void decrementUnresolvedOperandCount();\n  void countUnresolvedOperands();\n\n  /// Mutate this to be \"uniqued\".\n  ///\n  /// Mutate this so that \\a isUniqued().\n  /// \\pre \\a isTemporary().\n  /// \\pre already added to uniquing set.\n  void makeUniqued();\n\n  /// Mutate this to be \"distinct\".\n  ///\n  /// Mutate this so that \\a isDistinct().\n  /// \\pre \\a isTemporary().\n  void makeDistinct();\n\n  void deleteAsSubclass();\n  MDNode *uniquify();\n  void eraseFromStore();\n\n  template <class NodeTy> struct HasCachedHash;\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *N, std::true_type) {\n    N->recalculateHash();\n  }\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *, std::false_type) {}\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *N, std::true_type) {\n    N->setHash(0);\n  }\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *, std::false_type) {}\n\npublic:\n  using op_iterator = const MDOperand *;\n  using op_range = iterator_range<op_iterator>;\n\n  op_iterator op_begin() const {\n    return const_cast<MDNode *>(this)->mutable_begin();\n  }\n\n  op_iterator op_end() const {\n    return const_cast<MDNode *>(this)->mutable_end();\n  }\n\n  op_range operands() const { return op_range(op_begin(), op_end()); }\n\n  const MDOperand &getOperand(unsigned I) const {\n    assert(I < NumOperands && \"Out of range\");\n    return op_begin()[I];\n  }\n\n  /// Return number of MDNode operands.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  case CLASS##Kind:                                                            \\\n    return true;\n#include \"llvm/IR/Metadata.def\"\n    }\n  }\n\n  /// Check whether MDNode is a vtable access.\n  bool isTBAAVtableAccess() const;\n\n  /// Methods for metadata merging.\n  static MDNode *concatenate(MDNode *A, MDNode *B);\n  static MDNode *intersect(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericTBAA(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericFPMath(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericRange(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAliasScope(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAlignmentOrDereferenceable(MDNode *A, MDNode *B);\n};\n\n/// Tuple of metadata.\n///\n/// This is the simple \\a MDNode arbitrary tuple.  Nodes are uniqued by\n/// default based on their operands.\nclass MDTuple : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  MDTuple(LLVMContext &C, StorageType Storage, unsigned Hash,\n          ArrayRef<Metadata *> Vals)\n      : MDNode(C, MDTupleKind, Storage, Vals) {\n    setHash(Hash);\n  }\n\n  ~MDTuple() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static MDTuple *getImpl(LLVMContext &Context, ArrayRef<Metadata *> MDs,\n                          StorageType Storage, bool ShouldCreate = true);\n\n  TempMDTuple cloneImpl() const {\n    return getTemporary(getContext(), SmallVector<Metadata *, 4>(operands()));\n  }\n\npublic:\n  /// Get the hash, if any.\n  unsigned getHash() const { return SubclassData32; }\n\n  static MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued);\n  }\n\n  static MDTuple *getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued, /* ShouldCreate */ false);\n  }\n\n  /// Return a distinct node.\n  ///\n  /// Return a distinct node -- i.e., a node that is not uniqued.\n  static MDTuple *getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Distinct);\n  }\n\n  /// Return a temporary node.\n  ///\n  /// For use in constructing cyclic MDNode structures. A temporary MDNode is\n  /// not uniqued, may be RAUW'd, and must be manually deleted with\n  /// deleteTemporary.\n  static TempMDTuple getTemporary(LLVMContext &Context,\n                                  ArrayRef<Metadata *> MDs) {\n    return TempMDTuple(getImpl(Context, MDs, Temporary));\n  }\n\n  /// Return a (temporary) clone of this.\n  TempMDTuple clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDTupleKind;\n  }\n};\n\nMDTuple *MDNode::get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::get(Context, MDs);\n}\n\nMDTuple *MDNode::getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getIfExists(Context, MDs);\n}\n\nMDTuple *MDNode::getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getDistinct(Context, MDs);\n}\n\nTempMDTuple MDNode::getTemporary(LLVMContext &Context,\n                                 ArrayRef<Metadata *> MDs) {\n  return MDTuple::getTemporary(Context, MDs);\n}\n\nvoid TempMDNodeDeleter::operator()(MDNode *Node) const {\n  MDNode::deleteTemporary(Node);\n}\n\n/// This is a simple wrapper around an MDNode which provides a higher-level\n/// interface by hiding the details of how alias analysis information is encoded\n/// in its operands.\nclass AliasScopeNode {\n  const MDNode *Node = nullptr;\n\npublic:\n  AliasScopeNode() = default;\n  explicit AliasScopeNode(const MDNode *N) : Node(N) {}\n\n  /// Get the MDNode for this AliasScopeNode.\n  const MDNode *getNode() const { return Node; }\n\n  /// Get the MDNode for this AliasScopeNode's domain.\n  const MDNode *getDomain() const {\n    if (Node->getNumOperands() < 2)\n      return nullptr;\n    return dyn_cast_or_null<MDNode>(Node->getOperand(1));\n  }\n  StringRef getName() const {\n    if (Node->getNumOperands() > 2)\n      if (MDString *N = dyn_cast_or_null<MDString>(Node->getOperand(2)))\n        return N->getString();\n    return StringRef();\n  }\n};\n\n/// Typed iterator through MDNode operands.\n///\n/// An iterator that transforms an \\a MDNode::iterator into an iterator over a\n/// particular Metadata subclass.\ntemplate <class T>\nclass TypedMDOperandIterator\n    : public std::iterator<std::input_iterator_tag, T *, std::ptrdiff_t, void,\n                           T *> {\n  MDNode::op_iterator I = nullptr;\n\npublic:\n  TypedMDOperandIterator() = default;\n  explicit TypedMDOperandIterator(MDNode::op_iterator I) : I(I) {}\n\n  T *operator*() const { return cast_or_null<T>(*I); }\n\n  TypedMDOperandIterator &operator++() {\n    ++I;\n    return *this;\n  }\n\n  TypedMDOperandIterator operator++(int) {\n    TypedMDOperandIterator Temp(*this);\n    ++I;\n    return Temp;\n  }\n\n  bool operator==(const TypedMDOperandIterator &X) const { return I == X.I; }\n  bool operator!=(const TypedMDOperandIterator &X) const { return I != X.I; }\n};\n\n/// Typed, array-like tuple of metadata.\n///\n/// This is a wrapper for \\a MDTuple that makes it act like an array holding a\n/// particular type of metadata.\ntemplate <class T> class MDTupleTypedArrayWrapper {\n  const MDTuple *N = nullptr;\n\npublic:\n  MDTupleTypedArrayWrapper() = default;\n  MDTupleTypedArrayWrapper(const MDTuple *N) : N(N) {}\n\n  template <class U>\n  MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  template <class U>\n  explicit MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<!std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  bool empty() const { return N ? N->getNumOperands() == 0 : true; }\n  T *operator[](unsigned I) const { return cast_or_null<T>(N->getOperand(I)); }\n\n  // FIXME: Fix callers and remove condition on N.\n  using iterator = TypedMDOperandIterator<T>;\n\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n#define HANDLE_METADATA(CLASS)                                                 \\\n  using CLASS##Array = MDTupleTypedArrayWrapper<CLASS>;\n#include \"llvm/IR/Metadata.def\"\n\n/// Placeholder metadata for operands of distinct MDNodes.\n///\n/// This is a lightweight placeholder for an operand of a distinct node.  It's\n/// purpose is to help track forward references when creating a distinct node.\n/// This allows distinct nodes involved in a cycle to be constructed before\n/// their operands without requiring a heavyweight temporary node with\n/// full-blown RAUW support.\n///\n/// Each placeholder supports only a single MDNode user.  Clients should pass\n/// an ID, retrieved via \\a getID(), to indicate the \"real\" operand that this\n/// should be replaced with.\n///\n/// While it would be possible to implement move operators, they would be\n/// fairly expensive.  Leave them unimplemented to discourage their use\n/// (clients can use std::deque, std::list, BumpPtrAllocator, etc.).\nclass DistinctMDOperandPlaceholder : public Metadata {\n  friend class MetadataTracking;\n\n  Metadata **Use = nullptr;\n\npublic:\n  explicit DistinctMDOperandPlaceholder(unsigned ID)\n      : Metadata(DistinctMDOperandPlaceholderKind, Distinct) {\n    SubclassData32 = ID;\n  }\n\n  DistinctMDOperandPlaceholder() = delete;\n  DistinctMDOperandPlaceholder(DistinctMDOperandPlaceholder &&) = delete;\n  DistinctMDOperandPlaceholder(const DistinctMDOperandPlaceholder &) = delete;\n\n  ~DistinctMDOperandPlaceholder() {\n    if (Use)\n      *Use = nullptr;\n  }\n\n  unsigned getID() const { return SubclassData32; }\n\n  /// Replace the use of this with MD.\n  void replaceUseWith(Metadata *MD) {\n    if (!Use)\n      return;\n    *Use = MD;\n\n    if (*Use)\n      MetadataTracking::track(*Use);\n\n    Metadata *T = cast<Metadata>(this);\n    MetadataTracking::untrack(T);\n    assert(!Use && \"Use is still being tracked despite being untracked!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A tuple of MDNodes.\n///\n/// Despite its name, a NamedMDNode isn't itself an MDNode.\n///\n/// NamedMDNodes are named module-level entities that contain lists of MDNodes.\n///\n/// It is illegal for a NamedMDNode to appear as an operand of an MDNode.\nclass NamedMDNode : public ilist_node<NamedMDNode> {\n  friend class LLVMContextImpl;\n  friend class Module;\n\n  std::string Name;\n  Module *Parent = nullptr;\n  void *Operands; // SmallVector<TrackingMDRef, 4>\n\n  void setParent(Module *M) { Parent = M; }\n\n  explicit NamedMDNode(const Twine &N);\n\n  template<class T1, class T2>\n  class op_iterator_impl :\n      public std::iterator<std::bidirectional_iterator_tag, T2> {\n    friend class NamedMDNode;\n\n    const NamedMDNode *Node = nullptr;\n    unsigned Idx = 0;\n\n    op_iterator_impl(const NamedMDNode *N, unsigned i) : Node(N), Idx(i) {}\n\n  public:\n    op_iterator_impl() = default;\n\n    bool operator==(const op_iterator_impl &o) const { return Idx == o.Idx; }\n    bool operator!=(const op_iterator_impl &o) const { return Idx != o.Idx; }\n\n    op_iterator_impl &operator++() {\n      ++Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator++(int) {\n      op_iterator_impl tmp(*this);\n      operator++();\n      return tmp;\n    }\n\n    op_iterator_impl &operator--() {\n      --Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator--(int) {\n      op_iterator_impl tmp(*this);\n      operator--();\n      return tmp;\n    }\n\n    T1 operator*() const { return Node->getOperand(Idx); }\n  };\n\npublic:\n  NamedMDNode(const NamedMDNode &) = delete;\n  ~NamedMDNode();\n\n  /// Drop all references and remove the node from parent module.\n  void eraseFromParent();\n\n  /// Remove all uses and clear node vector.\n  void dropAllReferences() { clearOperands(); }\n  /// Drop all references to this node's operands.\n  void clearOperands();\n\n  /// Get the module that holds this named metadata collection.\n  inline Module *getParent() { return Parent; }\n  inline const Module *getParent() const { return Parent; }\n\n  MDNode *getOperand(unsigned i) const;\n  unsigned getNumOperands() const;\n  void addOperand(MDNode *M);\n  void setOperand(unsigned I, MDNode *New);\n  StringRef getName() const;\n  void print(raw_ostream &ROS, bool IsForDebug = false) const;\n  void print(raw_ostream &ROS, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  void dump() const;\n\n  // ---------------------------------------------------------------------------\n  // Operand Iterator interface...\n  //\n  using op_iterator = op_iterator_impl<MDNode *, MDNode>;\n\n  op_iterator op_begin() { return op_iterator(this, 0); }\n  op_iterator op_end()   { return op_iterator(this, getNumOperands()); }\n\n  using const_op_iterator = op_iterator_impl<const MDNode *, MDNode>;\n\n  const_op_iterator op_begin() const { return const_op_iterator(this, 0); }\n  const_op_iterator op_end()   const { return const_op_iterator(this, getNumOperands()); }\n\n  inline iterator_range<op_iterator>  operands() {\n    return make_range(op_begin(), op_end());\n  }\n  inline iterator_range<const_op_iterator> operands() const {\n    return make_range(op_begin(), op_end());\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(NamedMDNode, LLVMNamedMDNodeRef)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_METADATA_H\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h", "content": "//===- llvm/IR/PassInstrumentation.h ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This file defines the Pass Instrumentation classes that provide\n/// instrumentation points into the pass execution by PassManager.\n///\n/// There are two main classes:\n///   - PassInstrumentation provides a set of instrumentation points for\n///     pass managers to call on.\n///\n///   - PassInstrumentationCallbacks registers callbacks and provides access\n///     to them for PassInstrumentation.\n///\n/// PassInstrumentation object is being used as a result of\n/// PassInstrumentationAnalysis (so it is intended to be easily copyable).\n///\n/// Intended scheme of use for Pass Instrumentation is as follows:\n///    - register instrumentation callbacks in PassInstrumentationCallbacks\n///      instance. PassBuilder provides helper for that.\n///\n///    - register PassInstrumentationAnalysis with all the PassManagers.\n///      PassBuilder handles that automatically when registering analyses.\n///\n///    - Pass Manager requests PassInstrumentationAnalysis from analysis manager\n///      and gets PassInstrumentation as its result.\n///\n///    - Pass Manager invokes PassInstrumentation entry points appropriately,\n///      passing StringRef identification (\"name\") of the pass currently being\n///      executed and IRUnit it works on. There can be different schemes of\n///      providing names in future, currently it is just a name() of the pass.\n///\n///    - PassInstrumentation wraps address of IRUnit into llvm::Any and passes\n///      control to all the registered callbacks. Note that we specifically wrap\n///      'const IRUnitT*' so as to avoid any accidental changes to IR in\n///      instrumenting callbacks.\n///\n///    - Some instrumentation points (BeforePass) allow to control execution\n///      of a pass. For those callbacks returning false means pass will not be\n///      executed.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PASSINSTRUMENTATION_H\n#define LLVM_IR_PASSINSTRUMENTATION_H\n\n#include \"llvm/ADT/Any.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include <type_traits>\n\nnamespace llvm {\n\nclass PreservedAnalyses;\nclass StringRef;\n\n/// This class manages callbacks registration, as well as provides a way for\n/// PassInstrumentation to pass control to the registered callbacks.\nclass PassInstrumentationCallbacks {\npublic:\n  // Before/After callbacks accept IRUnits whenever appropriate, so they need\n  // to take them as constant pointers, wrapped with llvm::Any.\n  // For the case when IRUnit has been invalidated there is a different\n  // callback to use - AfterPassInvalidated.\n  // We call all BeforePassFuncs to determine if a pass should run or not.\n  // BeforeNonSkippedPassFuncs are called only if the pass should run.\n  // TODO: currently AfterPassInvalidated does not accept IRUnit, since passing\n  // already invalidated IRUnit is unsafe. There are ways to handle invalidated\n  // IRUnits in a safe way, and we might pursue that as soon as there is a\n  // useful instrumentation that needs it.\n  using BeforePassFunc = bool(StringRef, Any);\n  using BeforeSkippedPassFunc = void(StringRef, Any);\n  using BeforeNonSkippedPassFunc = void(StringRef, Any);\n  using AfterPassFunc = void(StringRef, Any, const PreservedAnalyses &);\n  using AfterPassInvalidatedFunc = void(StringRef, const PreservedAnalyses &);\n  using BeforeAnalysisFunc = void(StringRef, Any);\n  using AfterAnalysisFunc = void(StringRef, Any);\n\npublic:\n  PassInstrumentationCallbacks() {}\n\n  /// Copying PassInstrumentationCallbacks is not intended.\n  PassInstrumentationCallbacks(const PassInstrumentationCallbacks &) = delete;\n  void operator=(const PassInstrumentationCallbacks &) = delete;\n\n  template <typename CallableT>\n  void registerShouldRunOptionalPassCallback(CallableT C) {\n    ShouldRunOptionalPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerBeforeSkippedPassCallback(CallableT C) {\n    BeforeSkippedPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerBeforeNonSkippedPassCallback(CallableT C) {\n    BeforeNonSkippedPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT> void registerAfterPassCallback(CallableT C) {\n    AfterPassCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerAfterPassInvalidatedCallback(CallableT C) {\n    AfterPassInvalidatedCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerBeforeAnalysisCallback(CallableT C) {\n    BeforeAnalysisCallbacks.emplace_back(std::move(C));\n  }\n\n  template <typename CallableT>\n  void registerAfterAnalysisCallback(CallableT C) {\n    AfterAnalysisCallbacks.emplace_back(std::move(C));\n  }\n\n  /// Add a class name to pass name mapping for use by pass instrumentation.\n  void addClassToPassName(StringRef ClassName, StringRef PassName);\n  /// Get the pass name for a given pass class name.\n  StringRef getPassNameForClassName(StringRef ClassName);\n\nprivate:\n  friend class PassInstrumentation;\n\n  /// These are only run on passes that are not required. They return false when\n  /// an optional pass should be skipped.\n  SmallVector<llvm::unique_function<BeforePassFunc>, 4>\n      ShouldRunOptionalPassCallbacks;\n  /// These are run on passes that are skipped.\n  SmallVector<llvm::unique_function<BeforeSkippedPassFunc>, 4>\n      BeforeSkippedPassCallbacks;\n  /// These are run on passes that are about to be run.\n  SmallVector<llvm::unique_function<BeforeNonSkippedPassFunc>, 4>\n      BeforeNonSkippedPassCallbacks;\n  /// These are run on passes that have just run.\n  SmallVector<llvm::unique_function<AfterPassFunc>, 4> AfterPassCallbacks;\n  /// These are run passes that have just run on invalidated IR.\n  SmallVector<llvm::unique_function<AfterPassInvalidatedFunc>, 4>\n      AfterPassInvalidatedCallbacks;\n  /// These are run on analyses that are about to be run.\n  SmallVector<llvm::unique_function<BeforeAnalysisFunc>, 4>\n      BeforeAnalysisCallbacks;\n  /// These are run on analyses that have been run.\n  SmallVector<llvm::unique_function<AfterAnalysisFunc>, 4>\n      AfterAnalysisCallbacks;\n\n  StringMap<std::string> ClassToPassName;\n};\n\n/// This class provides instrumentation entry points for the Pass Manager,\n/// doing calls to callbacks registered in PassInstrumentationCallbacks.\nclass PassInstrumentation {\n  PassInstrumentationCallbacks *Callbacks;\n\n  // Template argument PassT of PassInstrumentation::runBeforePass could be two\n  // kinds: (1) a regular pass inherited from PassInfoMixin (happen when\n  // creating a adaptor pass for a regular pass); (2) a type-erased PassConcept\n  // created from (1). Here we want to make case (1) skippable unconditionally\n  // since they are regular passes. We call PassConcept::isRequired to decide\n  // for case (2).\n  template <typename PassT>\n  using has_required_t = decltype(std::declval<PassT &>().isRequired());\n\n  template <typename PassT>\n  static std::enable_if_t<is_detected<has_required_t, PassT>::value, bool>\n  isRequired(const PassT &Pass) {\n    return Pass.isRequired();\n  }\n  template <typename PassT>\n  static std::enable_if_t<!is_detected<has_required_t, PassT>::value, bool>\n  isRequired(const PassT &Pass) {\n    return false;\n  }\n\npublic:\n  /// Callbacks object is not owned by PassInstrumentation, its life-time\n  /// should at least match the life-time of corresponding\n  /// PassInstrumentationAnalysis (which usually is till the end of current\n  /// compilation).\n  PassInstrumentation(PassInstrumentationCallbacks *CB = nullptr)\n      : Callbacks(CB) {}\n\n  /// BeforePass instrumentation point - takes \\p Pass instance to be executed\n  /// and constant reference to IR it operates on. \\Returns true if pass is\n  /// allowed to be executed. These are only run on optional pass since required\n  /// passes must always be run. This allows these callbacks to print info when\n  /// they want to skip a pass.\n  template <typename IRUnitT, typename PassT>\n  bool runBeforePass(const PassT &Pass, const IRUnitT &IR) const {\n    if (!Callbacks)\n      return true;\n\n    bool ShouldRun = true;\n    if (!isRequired(Pass)) {\n      for (auto &C : Callbacks->ShouldRunOptionalPassCallbacks)\n        ShouldRun &= C(Pass.name(), llvm::Any(&IR));\n    }\n\n    if (ShouldRun) {\n      for (auto &C : Callbacks->BeforeNonSkippedPassCallbacks)\n        C(Pass.name(), llvm::Any(&IR));\n    } else {\n      for (auto &C : Callbacks->BeforeSkippedPassCallbacks)\n        C(Pass.name(), llvm::Any(&IR));\n    }\n\n    return ShouldRun;\n  }\n\n  /// AfterPass instrumentation point - takes \\p Pass instance that has\n  /// just been executed and constant reference to \\p IR it operates on.\n  /// \\p IR is guaranteed to be valid at this point.\n  template <typename IRUnitT, typename PassT>\n  void runAfterPass(const PassT &Pass, const IRUnitT &IR,\n                    const PreservedAnalyses &PA) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->AfterPassCallbacks)\n        C(Pass.name(), llvm::Any(&IR), PA);\n  }\n\n  /// AfterPassInvalidated instrumentation point - takes \\p Pass instance\n  /// that has just been executed. For use when IR has been invalidated\n  /// by \\p Pass execution.\n  template <typename IRUnitT, typename PassT>\n  void runAfterPassInvalidated(const PassT &Pass,\n                               const PreservedAnalyses &PA) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->AfterPassInvalidatedCallbacks)\n        C(Pass.name(), PA);\n  }\n\n  /// BeforeAnalysis instrumentation point - takes \\p Analysis instance\n  /// to be executed and constant reference to IR it operates on.\n  template <typename IRUnitT, typename PassT>\n  void runBeforeAnalysis(const PassT &Analysis, const IRUnitT &IR) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->BeforeAnalysisCallbacks)\n        C(Analysis.name(), llvm::Any(&IR));\n  }\n\n  /// AfterAnalysis instrumentation point - takes \\p Analysis instance\n  /// that has just been executed and constant reference to IR it operated on.\n  template <typename IRUnitT, typename PassT>\n  void runAfterAnalysis(const PassT &Analysis, const IRUnitT &IR) const {\n    if (Callbacks)\n      for (auto &C : Callbacks->AfterAnalysisCallbacks)\n        C(Analysis.name(), llvm::Any(&IR));\n  }\n\n  /// Handle invalidation from the pass manager when PassInstrumentation\n  /// is used as the result of PassInstrumentationAnalysis.\n  ///\n  /// On attempt to invalidate just return false. There is nothing to become\n  /// invalid here.\n  template <typename IRUnitT, typename... ExtraArgsT>\n  bool invalidate(IRUnitT &, const class llvm::PreservedAnalyses &,\n                  ExtraArgsT...) {\n    return false;\n  }\n\n  template <typename CallableT>\n  void pushBeforeNonSkippedPassCallback(CallableT C) {\n    if (Callbacks)\n      Callbacks->BeforeNonSkippedPassCallbacks.emplace_back(std::move(C));\n  }\n  void popBeforeNonSkippedPassCallback() {\n    if (Callbacks)\n      Callbacks->BeforeNonSkippedPassCallbacks.pop_back();\n  }\n};\n\nbool isSpecialPass(StringRef PassID, const std::vector<StringRef> &Specials);\n\n} // namespace llvm\n\n#endif\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "content": "//===- PassManager.h - Pass management infrastructure -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This header defines various interfaces for pass management in LLVM. There\n/// is no \"pass\" interface in LLVM per se. Instead, an instance of any class\n/// which supports a method to 'run' it over a unit of IR can be used as\n/// a pass. A pass manager is generally a tool to collect a sequence of passes\n/// which run over a particular IR construct, and run each of them in sequence\n/// over each such construct in the containing IR construct. As there is no\n/// containing IR construct for a Module, a manager for passes over modules\n/// forms the base case which runs its managed passes in sequence over the\n/// single module provided.\n///\n/// The core IR library provides managers for running passes over\n/// modules and functions.\n///\n/// * FunctionPassManager can run over a Module, runs each pass over\n///   a Function.\n/// * ModulePassManager must be directly run, runs each pass over the Module.\n///\n/// Note that the implementations of the pass managers use concept-based\n/// polymorphism as outlined in the \"Value Semantics and Concept-based\n/// Polymorphism\" talk (or its abbreviated sibling \"Inheritance Is The Base\n/// Class of Evil\") by Sean Parent:\n/// * http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations\n/// * http://www.youtube.com/watch?v=_BpMYeUFXv8\n/// * http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PASSMANAGER_H\n#define LLVM_IR_PASSMANAGER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassInstrumentation.h\"\n#include \"llvm/IR/PassManagerInternal.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/TimeProfiler.h\"\n#include \"llvm/Support/TypeName.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iterator>\n#include <list>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n/// A special type used by analysis passes to provide an address that\n/// identifies that particular analysis pass type.\n///\n/// Analysis passes should have a static data member of this type and derive\n/// from the \\c AnalysisInfoMixin to get a static ID method used to identify\n/// the analysis in the pass management infrastructure.\nstruct alignas(8) AnalysisKey {};\n\n/// A special type used to provide an address that identifies a set of related\n/// analyses.  These sets are primarily used below to mark sets of analyses as\n/// preserved.\n///\n/// For example, a transformation can indicate that it preserves the CFG of a\n/// function by preserving the appropriate AnalysisSetKey.  An analysis that\n/// depends only on the CFG can then check if that AnalysisSetKey is preserved;\n/// if it is, the analysis knows that it itself is preserved.\nstruct alignas(8) AnalysisSetKey {};\n\n/// This templated class represents \"all analyses that operate over \\<a\n/// particular IR unit\\>\" (e.g. a Function or a Module) in instances of\n/// PreservedAnalysis.\n///\n/// This lets a transformation say e.g. \"I preserved all function analyses\".\n///\n/// Note that you must provide an explicit instantiation declaration and\n/// definition for this template in order to get the correct behavior on\n/// Windows. Otherwise, the address of SetKey will not be stable.\ntemplate <typename IRUnitT> class AllAnalysesOn {\npublic:\n  static AnalysisSetKey *ID() { return &SetKey; }\n\nprivate:\n  static AnalysisSetKey SetKey;\n};\n\ntemplate <typename IRUnitT> AnalysisSetKey AllAnalysesOn<IRUnitT>::SetKey;\n\nextern template class AllAnalysesOn<Module>;\nextern template class AllAnalysesOn<Function>;\n\n/// Represents analyses that only rely on functions' control flow.\n///\n/// This can be used with \\c PreservedAnalyses to mark the CFG as preserved and\n/// to query whether it has been preserved.\n///\n/// The CFG of a function is defined as the set of basic blocks and the edges\n/// between them. Changing the set of basic blocks in a function is enough to\n/// mutate the CFG. Mutating the condition of a branch or argument of an\n/// invoked function does not mutate the CFG, but changing the successor labels\n/// of those instructions does.\nclass CFGAnalyses {\npublic:\n  static AnalysisSetKey *ID() { return &SetKey; }\n\nprivate:\n  static AnalysisSetKey SetKey;\n};\n\n/// A set of analyses that are preserved following a run of a transformation\n/// pass.\n///\n/// Transformation passes build and return these objects to communicate which\n/// analyses are still valid after the transformation. For most passes this is\n/// fairly simple: if they don't change anything all analyses are preserved,\n/// otherwise only a short list of analyses that have been explicitly updated\n/// are preserved.\n///\n/// This class also lets transformation passes mark abstract *sets* of analyses\n/// as preserved. A transformation that (say) does not alter the CFG can\n/// indicate such by marking a particular AnalysisSetKey as preserved, and\n/// then analyses can query whether that AnalysisSetKey is preserved.\n///\n/// Finally, this class can represent an \"abandoned\" analysis, which is\n/// not preserved even if it would be covered by some abstract set of analyses.\n///\n/// Given a `PreservedAnalyses` object, an analysis will typically want to\n/// figure out whether it is preserved. In the example below, MyAnalysisType is\n/// preserved if it's not abandoned, and (a) it's explicitly marked as\n/// preserved, (b), the set AllAnalysesOn<MyIRUnit> is preserved, or (c) both\n/// AnalysisSetA and AnalysisSetB are preserved.\n///\n/// ```\n///   auto PAC = PA.getChecker<MyAnalysisType>();\n///   if (PAC.preserved() || PAC.preservedSet<AllAnalysesOn<MyIRUnit>>() ||\n///       (PAC.preservedSet<AnalysisSetA>() &&\n///        PAC.preservedSet<AnalysisSetB>())) {\n///     // The analysis has been successfully preserved ...\n///   }\n/// ```\nclass PreservedAnalyses {\npublic:\n  /// Convenience factory function for the empty preserved set.\n  static PreservedAnalyses none() { return PreservedAnalyses(); }\n\n  /// Construct a special preserved set that preserves all passes.\n  static PreservedAnalyses all() {\n    PreservedAnalyses PA;\n    PA.PreservedIDs.insert(&AllAnalysesKey);\n    return PA;\n  }\n\n  /// Construct a preserved analyses object with a single preserved set.\n  template <typename AnalysisSetT>\n  static PreservedAnalyses allInSet() {\n    PreservedAnalyses PA;\n    PA.preserveSet<AnalysisSetT>();\n    return PA;\n  }\n\n  /// Mark an analysis as preserved.\n  template <typename AnalysisT> void preserve() { preserve(AnalysisT::ID()); }\n\n  /// Given an analysis's ID, mark the analysis as preserved, adding it\n  /// to the set.\n  void preserve(AnalysisKey *ID) {\n    // Clear this ID from the explicit not-preserved set if present.\n    NotPreservedAnalysisIDs.erase(ID);\n\n    // If we're not already preserving all analyses (other than those in\n    // NotPreservedAnalysisIDs).\n    if (!areAllPreserved())\n      PreservedIDs.insert(ID);\n  }\n\n  /// Mark an analysis set as preserved.\n  template <typename AnalysisSetT> void preserveSet() {\n    preserveSet(AnalysisSetT::ID());\n  }\n\n  /// Mark an analysis set as preserved using its ID.\n  void preserveSet(AnalysisSetKey *ID) {\n    // If we're not already in the saturated 'all' state, add this set.\n    if (!areAllPreserved())\n      PreservedIDs.insert(ID);\n  }\n\n  /// Mark an analysis as abandoned.\n  ///\n  /// An abandoned analysis is not preserved, even if it is nominally covered\n  /// by some other set or was previously explicitly marked as preserved.\n  ///\n  /// Note that you can only abandon a specific analysis, not a *set* of\n  /// analyses.\n  template <typename AnalysisT> void abandon() { abandon(AnalysisT::ID()); }\n\n  /// Mark an analysis as abandoned using its ID.\n  ///\n  /// An abandoned analysis is not preserved, even if it is nominally covered\n  /// by some other set or was previously explicitly marked as preserved.\n  ///\n  /// Note that you can only abandon a specific analysis, not a *set* of\n  /// analyses.\n  void abandon(AnalysisKey *ID) {\n    PreservedIDs.erase(ID);\n    NotPreservedAnalysisIDs.insert(ID);\n  }\n\n  /// Intersect this set with another in place.\n  ///\n  /// This is a mutating operation on this preserved set, removing all\n  /// preserved passes which are not also preserved in the argument.\n  void intersect(const PreservedAnalyses &Arg) {\n    if (Arg.areAllPreserved())\n      return;\n    if (areAllPreserved()) {\n      *this = Arg;\n      return;\n    }\n    // The intersection requires the *union* of the explicitly not-preserved\n    // IDs and the *intersection* of the preserved IDs.\n    for (auto ID : Arg.NotPreservedAnalysisIDs) {\n      PreservedIDs.erase(ID);\n      NotPreservedAnalysisIDs.insert(ID);\n    }\n    for (auto ID : PreservedIDs)\n      if (!Arg.PreservedIDs.count(ID))\n        PreservedIDs.erase(ID);\n  }\n\n  /// Intersect this set with a temporary other set in place.\n  ///\n  /// This is a mutating operation on this preserved set, removing all\n  /// preserved passes which are not also preserved in the argument.\n  void intersect(PreservedAnalyses &&Arg) {\n    if (Arg.areAllPreserved())\n      return;\n    if (areAllPreserved()) {\n      *this = std::move(Arg);\n      return;\n    }\n    // The intersection requires the *union* of the explicitly not-preserved\n    // IDs and the *intersection* of the preserved IDs.\n    for (auto ID : Arg.NotPreservedAnalysisIDs) {\n      PreservedIDs.erase(ID);\n      NotPreservedAnalysisIDs.insert(ID);\n    }\n    for (auto ID : PreservedIDs)\n      if (!Arg.PreservedIDs.count(ID))\n        PreservedIDs.erase(ID);\n  }\n\n  /// A checker object that makes it easy to query for whether an analysis or\n  /// some set covering it is preserved.\n  class PreservedAnalysisChecker {\n    friend class PreservedAnalyses;\n\n    const PreservedAnalyses &PA;\n    AnalysisKey *const ID;\n    const bool IsAbandoned;\n\n    /// A PreservedAnalysisChecker is tied to a particular Analysis because\n    /// `preserved()` and `preservedSet()` both return false if the Analysis\n    /// was abandoned.\n    PreservedAnalysisChecker(const PreservedAnalyses &PA, AnalysisKey *ID)\n        : PA(PA), ID(ID), IsAbandoned(PA.NotPreservedAnalysisIDs.count(ID)) {}\n\n  public:\n    /// Returns true if the checker's analysis was not abandoned and either\n    ///  - the analysis is explicitly preserved or\n    ///  - all analyses are preserved.\n    bool preserved() {\n      return !IsAbandoned && (PA.PreservedIDs.count(&AllAnalysesKey) ||\n                              PA.PreservedIDs.count(ID));\n    }\n\n    /// Return true if the checker's analysis was not abandoned, i.e. it was not\n    /// explicitly invalidated. Even if the analysis is not explicitly\n    /// preserved, if the analysis is known stateless, then it is preserved.\n    bool preservedWhenStateless() {\n      return !IsAbandoned;\n    }\n\n    /// Returns true if the checker's analysis was not abandoned and either\n    ///  - \\p AnalysisSetT is explicitly preserved or\n    ///  - all analyses are preserved.\n    template <typename AnalysisSetT> bool preservedSet() {\n      AnalysisSetKey *SetID = AnalysisSetT::ID();\n      return !IsAbandoned && (PA.PreservedIDs.count(&AllAnalysesKey) ||\n                              PA.PreservedIDs.count(SetID));\n    }\n  };\n\n  /// Build a checker for this `PreservedAnalyses` and the specified analysis\n  /// type.\n  ///\n  /// You can use the returned object to query whether an analysis was\n  /// preserved. See the example in the comment on `PreservedAnalysis`.\n  template <typename AnalysisT> PreservedAnalysisChecker getChecker() const {\n    return PreservedAnalysisChecker(*this, AnalysisT::ID());\n  }\n\n  /// Build a checker for this `PreservedAnalyses` and the specified analysis\n  /// ID.\n  ///\n  /// You can use the returned object to query whether an analysis was\n  /// preserved. See the example in the comment on `PreservedAnalysis`.\n  PreservedAnalysisChecker getChecker(AnalysisKey *ID) const {\n    return PreservedAnalysisChecker(*this, ID);\n  }\n\n  /// Test whether all analyses are preserved (and none are abandoned).\n  ///\n  /// This is used primarily to optimize for the common case of a transformation\n  /// which makes no changes to the IR.\n  bool areAllPreserved() const {\n    return NotPreservedAnalysisIDs.empty() &&\n           PreservedIDs.count(&AllAnalysesKey);\n  }\n\n  /// Directly test whether a set of analyses is preserved.\n  ///\n  /// This is only true when no analyses have been explicitly abandoned.\n  template <typename AnalysisSetT> bool allAnalysesInSetPreserved() const {\n    return allAnalysesInSetPreserved(AnalysisSetT::ID());\n  }\n\n  /// Directly test whether a set of analyses is preserved.\n  ///\n  /// This is only true when no analyses have been explicitly abandoned.\n  bool allAnalysesInSetPreserved(AnalysisSetKey *SetID) const {\n    return NotPreservedAnalysisIDs.empty() &&\n           (PreservedIDs.count(&AllAnalysesKey) || PreservedIDs.count(SetID));\n  }\n\nprivate:\n  /// A special key used to indicate all analyses.\n  static AnalysisSetKey AllAnalysesKey;\n\n  /// The IDs of analyses and analysis sets that are preserved.\n  SmallPtrSet<void *, 2> PreservedIDs;\n\n  /// The IDs of explicitly not-preserved analyses.\n  ///\n  /// If an analysis in this set is covered by a set in `PreservedIDs`, we\n  /// consider it not-preserved. That is, `NotPreservedAnalysisIDs` always\n  /// \"wins\" over analysis sets in `PreservedIDs`.\n  ///\n  /// Also, a given ID should never occur both here and in `PreservedIDs`.\n  SmallPtrSet<AnalysisKey *, 2> NotPreservedAnalysisIDs;\n};\n\n// Forward declare the analysis manager template.\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager;\n\n/// A CRTP mix-in to automatically provide informational APIs needed for\n/// passes.\n///\n/// This provides some boilerplate for types that are passes.\ntemplate <typename DerivedT> struct PassInfoMixin {\n  /// Gets the name of the pass we are mixed into.\n  static StringRef name() {\n    static_assert(std::is_base_of<PassInfoMixin, DerivedT>::value,\n                  \"Must pass the derived type as the template argument!\");\n    StringRef Name = getTypeName<DerivedT>();\n    if (Name.startswith(\"llvm::\"))\n      Name = Name.drop_front(strlen(\"llvm::\"));\n    return Name;\n  }\n};\n\n/// A CRTP mix-in that provides informational APIs needed for analysis passes.\n///\n/// This provides some boilerplate for types that are analysis passes. It\n/// automatically mixes in \\c PassInfoMixin.\ntemplate <typename DerivedT>\nstruct AnalysisInfoMixin : PassInfoMixin<DerivedT> {\n  /// Returns an opaque, unique ID for this analysis type.\n  ///\n  /// This ID is a pointer type that is guaranteed to be 8-byte aligned and thus\n  /// suitable for use in sets, maps, and other data structures that use the low\n  /// bits of pointers.\n  ///\n  /// Note that this requires the derived type provide a static \\c AnalysisKey\n  /// member called \\c Key.\n  ///\n  /// FIXME: The only reason the mixin type itself can't declare the Key value\n  /// is that some compilers cannot correctly unique a templated static variable\n  /// so it has the same addresses in each instantiation. The only currently\n  /// known platform with this limitation is Windows DLL builds, specifically\n  /// building each part of LLVM as a DLL. If we ever remove that build\n  /// configuration, this mixin can provide the static key as well.\n  static AnalysisKey *ID() {\n    static_assert(std::is_base_of<AnalysisInfoMixin, DerivedT>::value,\n                  \"Must pass the derived type as the template argument!\");\n    return &DerivedT::Key;\n  }\n};\n\nnamespace detail {\n\n/// Actual unpacker of extra arguments in getAnalysisResult,\n/// passes only those tuple arguments that are mentioned in index_sequence.\ntemplate <typename PassT, typename IRUnitT, typename AnalysisManagerT,\n          typename... ArgTs, size_t... Ns>\ntypename PassT::Result\ngetAnalysisResultUnpackTuple(AnalysisManagerT &AM, IRUnitT &IR,\n                             std::tuple<ArgTs...> Args,\n                             std::index_sequence<Ns...>) {\n  (void)Args;\n  return AM.template getResult<PassT>(IR, std::get<Ns>(Args)...);\n}\n\n/// Helper for *partial* unpacking of extra arguments in getAnalysisResult.\n///\n/// Arguments passed in tuple come from PassManager, so they might have extra\n/// arguments after those AnalysisManager's ExtraArgTs ones that we need to\n/// pass to getResult.\ntemplate <typename PassT, typename IRUnitT, typename... AnalysisArgTs,\n          typename... MainArgTs>\ntypename PassT::Result\ngetAnalysisResult(AnalysisManager<IRUnitT, AnalysisArgTs...> &AM, IRUnitT &IR,\n                  std::tuple<MainArgTs...> Args) {\n  return (getAnalysisResultUnpackTuple<\n          PassT, IRUnitT>)(AM, IR, Args,\n                           std::index_sequence_for<AnalysisArgTs...>{});\n}\n\n} // namespace detail\n\n// Forward declare the pass instrumentation analysis explicitly queried in\n// generic PassManager code.\n// FIXME: figure out a way to move PassInstrumentationAnalysis into its own\n// header.\nclass PassInstrumentationAnalysis;\n\n/// Manages a sequence of passes over a particular unit of IR.\n///\n/// A pass manager contains a sequence of passes to run over a particular unit\n/// of IR (e.g. Functions, Modules). It is itself a valid pass over that unit of\n/// IR, and when run over some given IR will run each of its contained passes in\n/// sequence. Pass managers are the primary and most basic building block of a\n/// pass pipeline.\n///\n/// When you run a pass manager, you provide an \\c AnalysisManager<IRUnitT>\n/// argument. The pass manager will propagate that analysis manager to each\n/// pass it runs, and will call the analysis manager's invalidation routine with\n/// the PreservedAnalyses of each pass it runs.\ntemplate <typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nclass PassManager : public PassInfoMixin<\n                        PassManager<IRUnitT, AnalysisManagerT, ExtraArgTs...>> {\npublic:\n  /// Construct a pass manager.\n  ///\n  /// If \\p DebugLogging is true, we'll log our progress to llvm::dbgs().\n  explicit PassManager(bool DebugLogging = false) : DebugLogging(DebugLogging) {}\n\n  // FIXME: These are equivalent to the default move constructor/move\n  // assignment. However, using = default triggers linker errors due to the\n  // explicit instantiations below. Find away to use the default and remove the\n  // duplicated code here.\n  PassManager(PassManager &&Arg)\n      : Passes(std::move(Arg.Passes)),\n        DebugLogging(std::move(Arg.DebugLogging)) {}\n\n  PassManager &operator=(PassManager &&RHS) {\n    Passes = std::move(RHS.Passes);\n    DebugLogging = std::move(RHS.DebugLogging);\n    return *this;\n  }\n\n  /// Run all of the passes in this manager over the given unit of IR.\n  /// ExtraArgs are passed to each pass.\n  PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM,\n                        ExtraArgTs... ExtraArgs) {\n    PreservedAnalyses PA = PreservedAnalyses::all();\n\n    // Request PassInstrumentation from analysis manager, will use it to run\n    // instrumenting callbacks for the passes later.\n    // Here we use std::tuple wrapper over getResult which helps to extract\n    // AnalysisManager's arguments out of the whole ExtraArgs set.\n    PassInstrumentation PI =\n        detail::getAnalysisResult<PassInstrumentationAnalysis>(\n            AM, IR, std::tuple<ExtraArgTs...>(ExtraArgs...));\n\n    if (DebugLogging)\n      dbgs() << \"Starting \" << getTypeName<IRUnitT>() << \" pass manager run.\\n\";\n\n    for (unsigned Idx = 0, Size = Passes.size(); Idx != Size; ++Idx) {\n      auto *P = Passes[Idx].get();\n\n      // Check the PassInstrumentation's BeforePass callbacks before running the\n      // pass, skip its execution completely if asked to (callback returns\n      // false).\n      if (!PI.runBeforePass<IRUnitT>(*P, IR))\n        continue;\n\n      PreservedAnalyses PassPA;\n      {\n        TimeTraceScope TimeScope(P->name(), IR.getName());\n        PassPA = P->run(IR, AM, ExtraArgs...);\n      }\n\n      // Call onto PassInstrumentation's AfterPass callbacks immediately after\n      // running the pass.\n      PI.runAfterPass<IRUnitT>(*P, IR, PassPA);\n\n      // Update the analysis manager as each pass runs and potentially\n      // invalidates analyses.\n      AM.invalidate(IR, PassPA);\n\n      // Finally, intersect the preserved analyses to compute the aggregate\n      // preserved set for this pass manager.\n      PA.intersect(std::move(PassPA));\n\n      // FIXME: Historically, the pass managers all called the LLVM context's\n      // yield function here. We don't have a generic way to acquire the\n      // context and it isn't yet clear what the right pattern is for yielding\n      // in the new pass manager so it is currently omitted.\n      //IR.getContext().yield();\n    }\n\n    // Invalidation was handled after each pass in the above loop for the\n    // current unit of IR. Therefore, the remaining analysis results in the\n    // AnalysisManager are preserved. We mark this with a set so that we don't\n    // need to inspect each one individually.\n    PA.preserveSet<AllAnalysesOn<IRUnitT>>();\n\n    if (DebugLogging)\n      dbgs() << \"Finished \" << getTypeName<IRUnitT>() << \" pass manager run.\\n\";\n\n    return PA;\n  }\n\n  template <typename PassT>\n  std::enable_if_t<!std::is_same<PassT, PassManager>::value>\n  addPass(PassT Pass) {\n    using PassModelT =\n        detail::PassModel<IRUnitT, PassT, PreservedAnalyses, AnalysisManagerT,\n                          ExtraArgTs...>;\n\n    Passes.emplace_back(new PassModelT(std::move(Pass)));\n  }\n\n  /// When adding a pass manager pass that has the same type as this pass\n  /// manager, simply move the passes over. This is because we don't have use\n  /// cases rely on executing nested pass managers. Doing this could reduce\n  /// implementation complexity and avoid potential invalidation issues that may\n  /// happen with nested pass managers of the same type.\n  template <typename PassT>\n  std::enable_if_t<std::is_same<PassT, PassManager>::value>\n  addPass(PassT &&Pass) {\n    for (auto &P : Pass.Passes)\n      Passes.emplace_back(std::move(P));\n  }\n\n  /// Returns if the pass manager contains any passes.\n  bool isEmpty() const { return Passes.empty(); }\n\n  static bool isRequired() { return true; }\n\nprotected:\n  using PassConceptT =\n      detail::PassConcept<IRUnitT, AnalysisManagerT, ExtraArgTs...>;\n\n  std::vector<std::unique_ptr<PassConceptT>> Passes;\n\n  /// Flag indicating whether we should do debug logging.\n  bool DebugLogging;\n};\n\nextern template class PassManager<Module>;\n\n/// Convenience typedef for a pass manager over modules.\nusing ModulePassManager = PassManager<Module>;\n\nextern template class PassManager<Function>;\n\n/// Convenience typedef for a pass manager over functions.\nusing FunctionPassManager = PassManager<Function>;\n\n/// Pseudo-analysis pass that exposes the \\c PassInstrumentation to pass\n/// managers. Goes before AnalysisManager definition to provide its\n/// internals (e.g PassInstrumentationAnalysis::ID) for use there if needed.\n/// FIXME: figure out a way to move PassInstrumentationAnalysis into its own\n/// header.\nclass PassInstrumentationAnalysis\n    : public AnalysisInfoMixin<PassInstrumentationAnalysis> {\n  friend AnalysisInfoMixin<PassInstrumentationAnalysis>;\n  static AnalysisKey Key;\n\n  PassInstrumentationCallbacks *Callbacks;\n\npublic:\n  /// PassInstrumentationCallbacks object is shared, owned by something else,\n  /// not this analysis.\n  PassInstrumentationAnalysis(PassInstrumentationCallbacks *Callbacks = nullptr)\n      : Callbacks(Callbacks) {}\n\n  using Result = PassInstrumentation;\n\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  Result run(IRUnitT &, AnalysisManagerT &, ExtraArgTs &&...) {\n    return PassInstrumentation(Callbacks);\n  }\n};\n\n/// A container for analyses that lazily runs them and caches their\n/// results.\n///\n/// This class can manage analyses for any IR unit where the address of the IR\n/// unit sufficies as its identity.\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager {\npublic:\n  class Invalidator;\n\nprivate:\n  // Now that we've defined our invalidator, we can define the concept types.\n  using ResultConceptT =\n      detail::AnalysisResultConcept<IRUnitT, PreservedAnalyses, Invalidator>;\n  using PassConceptT =\n      detail::AnalysisPassConcept<IRUnitT, PreservedAnalyses, Invalidator,\n                                  ExtraArgTs...>;\n\n  /// List of analysis pass IDs and associated concept pointers.\n  ///\n  /// Requires iterators to be valid across appending new entries and arbitrary\n  /// erases. Provides the analysis ID to enable finding iterators to a given\n  /// entry in maps below, and provides the storage for the actual result\n  /// concept.\n  using AnalysisResultListT =\n      std::list<std::pair<AnalysisKey *, std::unique_ptr<ResultConceptT>>>;\n\n  /// Map type from IRUnitT pointer to our custom list type.\n  using AnalysisResultListMapT = DenseMap<IRUnitT *, AnalysisResultListT>;\n\n  /// Map type from a pair of analysis ID and IRUnitT pointer to an\n  /// iterator into a particular result list (which is where the actual analysis\n  /// result is stored).\n  using AnalysisResultMapT =\n      DenseMap<std::pair<AnalysisKey *, IRUnitT *>,\n               typename AnalysisResultListT::iterator>;\n\npublic:\n  /// API to communicate dependencies between analyses during invalidation.\n  ///\n  /// When an analysis result embeds handles to other analysis results, it\n  /// needs to be invalidated both when its own information isn't preserved and\n  /// when any of its embedded analysis results end up invalidated. We pass an\n  /// \\c Invalidator object as an argument to \\c invalidate() in order to let\n  /// the analysis results themselves define the dependency graph on the fly.\n  /// This lets us avoid building an explicit representation of the\n  /// dependencies between analysis results.\n  class Invalidator {\n  public:\n    /// Trigger the invalidation of some other analysis pass if not already\n    /// handled and return whether it was in fact invalidated.\n    ///\n    /// This is expected to be called from within a given analysis result's \\c\n    /// invalidate method to trigger a depth-first walk of all inter-analysis\n    /// dependencies. The same \\p IR unit and \\p PA passed to that result's \\c\n    /// invalidate method should in turn be provided to this routine.\n    ///\n    /// The first time this is called for a given analysis pass, it will call\n    /// the corresponding result's \\c invalidate method.  Subsequent calls will\n    /// use a cache of the results of that initial call.  It is an error to form\n    /// cyclic dependencies between analysis results.\n    ///\n    /// This returns true if the given analysis's result is invalid. Any\n    /// dependecies on it will become invalid as a result.\n    template <typename PassT>\n    bool invalidate(IRUnitT &IR, const PreservedAnalyses &PA) {\n      using ResultModelT =\n          detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                      PreservedAnalyses, Invalidator>;\n\n      return invalidateImpl<ResultModelT>(PassT::ID(), IR, PA);\n    }\n\n    /// A type-erased variant of the above invalidate method with the same core\n    /// API other than passing an analysis ID rather than an analysis type\n    /// parameter.\n    ///\n    /// This is sadly less efficient than the above routine, which leverages\n    /// the type parameter to avoid the type erasure overhead.\n    bool invalidate(AnalysisKey *ID, IRUnitT &IR, const PreservedAnalyses &PA) {\n      return invalidateImpl<>(ID, IR, PA);\n    }\n\n  private:\n    friend class AnalysisManager;\n\n    template <typename ResultT = ResultConceptT>\n    bool invalidateImpl(AnalysisKey *ID, IRUnitT &IR,\n                        const PreservedAnalyses &PA) {\n      // If we've already visited this pass, return true if it was invalidated\n      // and false otherwise.\n      auto IMapI = IsResultInvalidated.find(ID);\n      if (IMapI != IsResultInvalidated.end())\n        return IMapI->second;\n\n      // Otherwise look up the result object.\n      auto RI = Results.find({ID, &IR});\n      assert(RI != Results.end() &&\n             \"Trying to invalidate a dependent result that isn't in the \"\n             \"manager's cache is always an error, likely due to a stale result \"\n             \"handle!\");\n\n      auto &Result = static_cast<ResultT &>(*RI->second->second);\n\n      // Insert into the map whether the result should be invalidated and return\n      // that. Note that we cannot reuse IMapI and must do a fresh insert here,\n      // as calling invalidate could (recursively) insert things into the map,\n      // making any iterator or reference invalid.\n      bool Inserted;\n      std::tie(IMapI, Inserted) =\n          IsResultInvalidated.insert({ID, Result.invalidate(IR, PA, *this)});\n      (void)Inserted;\n      assert(Inserted && \"Should not have already inserted this ID, likely \"\n                         \"indicates a dependency cycle!\");\n      return IMapI->second;\n    }\n\n    Invalidator(SmallDenseMap<AnalysisKey *, bool, 8> &IsResultInvalidated,\n                const AnalysisResultMapT &Results)\n        : IsResultInvalidated(IsResultInvalidated), Results(Results) {}\n\n    SmallDenseMap<AnalysisKey *, bool, 8> &IsResultInvalidated;\n    const AnalysisResultMapT &Results;\n  };\n\n  /// Construct an empty analysis manager.\n  ///\n  /// If \\p DebugLogging is true, we'll log our progress to llvm::dbgs().\n  AnalysisManager(bool DebugLogging = false);\n  AnalysisManager(AnalysisManager &&);\n  AnalysisManager &operator=(AnalysisManager &&);\n\n  /// Returns true if the analysis manager has an empty results cache.\n  bool empty() const {\n    assert(AnalysisResults.empty() == AnalysisResultLists.empty() &&\n           \"The storage and index of analysis results disagree on how many \"\n           \"there are!\");\n    return AnalysisResults.empty();\n  }\n\n  /// Clear any cached analysis results for a single unit of IR.\n  ///\n  /// This doesn't invalidate, but instead simply deletes, the relevant results.\n  /// It is useful when the IR is being removed and we want to clear out all the\n  /// memory pinned for it.\n  void clear(IRUnitT &IR, llvm::StringRef Name);\n\n  /// Clear all analysis results cached by this AnalysisManager.\n  ///\n  /// Like \\c clear(IRUnitT&), this doesn't invalidate the results; it simply\n  /// deletes them.  This lets you clean up the AnalysisManager when the set of\n  /// IR units itself has potentially changed, and thus we can't even look up a\n  /// a result and invalidate/clear it directly.\n  void clear() {\n    AnalysisResults.clear();\n    AnalysisResultLists.clear();\n  }\n\n  /// Get the result of an analysis pass for a given IR unit.\n  ///\n  /// Runs the analysis if a cached result is not available.\n  template <typename PassT>\n  typename PassT::Result &getResult(IRUnitT &IR, ExtraArgTs... ExtraArgs) {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being queried\");\n    ResultConceptT &ResultConcept =\n        getResultImpl(PassT::ID(), IR, ExtraArgs...);\n\n    using ResultModelT =\n        detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                    PreservedAnalyses, Invalidator>;\n\n    return static_cast<ResultModelT &>(ResultConcept).Result;\n  }\n\n  /// Get the cached result of an analysis pass for a given IR unit.\n  ///\n  /// This method never runs the analysis.\n  ///\n  /// \\returns null if there is no cached result.\n  template <typename PassT>\n  typename PassT::Result *getCachedResult(IRUnitT &IR) const {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being queried\");\n\n    ResultConceptT *ResultConcept = getCachedResultImpl(PassT::ID(), IR);\n    if (!ResultConcept)\n      return nullptr;\n\n    using ResultModelT =\n        detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                    PreservedAnalyses, Invalidator>;\n\n    return &static_cast<ResultModelT *>(ResultConcept)->Result;\n  }\n\n  /// Verify that the given Result cannot be invalidated, assert otherwise.\n  template <typename PassT>\n  void verifyNotInvalidated(IRUnitT &IR, typename PassT::Result *Result) const {\n    PreservedAnalyses PA = PreservedAnalyses::none();\n    SmallDenseMap<AnalysisKey *, bool, 8> IsResultInvalidated;\n    Invalidator Inv(IsResultInvalidated, AnalysisResults);\n    assert(!Result->invalidate(IR, PA, Inv) &&\n           \"Cached result cannot be invalidated\");\n  }\n\n  /// Register an analysis pass with the manager.\n  ///\n  /// The parameter is a callable whose result is an analysis pass. This allows\n  /// passing in a lambda to construct the analysis.\n  ///\n  /// The analysis type to register is the type returned by calling the \\c\n  /// PassBuilder argument. If that type has already been registered, then the\n  /// argument will not be called and this function will return false.\n  /// Otherwise, we register the analysis returned by calling \\c PassBuilder(),\n  /// and this function returns true.\n  ///\n  /// (Note: Although the return value of this function indicates whether or not\n  /// an analysis was previously registered, there intentionally isn't a way to\n  /// query this directly.  Instead, you should just register all the analyses\n  /// you might want and let this class run them lazily.  This idiom lets us\n  /// minimize the number of times we have to look up analyses in our\n  /// hashtable.)\n  template <typename PassBuilderT>\n  bool registerPass(PassBuilderT &&PassBuilder) {\n    using PassT = decltype(PassBuilder());\n    using PassModelT =\n        detail::AnalysisPassModel<IRUnitT, PassT, PreservedAnalyses,\n                                  Invalidator, ExtraArgTs...>;\n\n    auto &PassPtr = AnalysisPasses[PassT::ID()];\n    if (PassPtr)\n      // Already registered this pass type!\n      return false;\n\n    // Construct a new model around the instance returned by the builder.\n    PassPtr.reset(new PassModelT(PassBuilder()));\n    return true;\n  }\n\n  /// Invalidate a specific analysis pass for an IR unit.\n  ///\n  /// Note that the analysis result can disregard invalidation, if it determines\n  /// it is in fact still valid.\n  template <typename PassT> void invalidate(IRUnitT &IR) {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being invalidated\");\n    invalidateImpl(PassT::ID(), IR);\n  }\n\n  /// Invalidate cached analyses for an IR unit.\n  ///\n  /// Walk through all of the analyses pertaining to this unit of IR and\n  /// invalidate them, unless they are preserved by the PreservedAnalyses set.\n  void invalidate(IRUnitT &IR, const PreservedAnalyses &PA);\n\nprivate:\n  /// Look up a registered analysis pass.\n  PassConceptT &lookUpPass(AnalysisKey *ID) {\n    typename AnalysisPassMapT::iterator PI = AnalysisPasses.find(ID);\n    assert(PI != AnalysisPasses.end() &&\n           \"Analysis passes must be registered prior to being queried!\");\n    return *PI->second;\n  }\n\n  /// Look up a registered analysis pass.\n  const PassConceptT &lookUpPass(AnalysisKey *ID) const {\n    typename AnalysisPassMapT::const_iterator PI = AnalysisPasses.find(ID);\n    assert(PI != AnalysisPasses.end() &&\n           \"Analysis passes must be registered prior to being queried!\");\n    return *PI->second;\n  }\n\n  /// Get an analysis result, running the pass if necessary.\n  ResultConceptT &getResultImpl(AnalysisKey *ID, IRUnitT &IR,\n                                ExtraArgTs... ExtraArgs);\n\n  /// Get a cached analysis result or return null.\n  ResultConceptT *getCachedResultImpl(AnalysisKey *ID, IRUnitT &IR) const {\n    typename AnalysisResultMapT::const_iterator RI =\n        AnalysisResults.find({ID, &IR});\n    return RI == AnalysisResults.end() ? nullptr : &*RI->second->second;\n  }\n\n  /// Invalidate a pass result for a IR unit.\n  void invalidateImpl(AnalysisKey *ID, IRUnitT &IR) {\n    typename AnalysisResultMapT::iterator RI =\n        AnalysisResults.find({ID, &IR});\n    if (RI == AnalysisResults.end())\n      return;\n\n    if (DebugLogging)\n      dbgs() << \"Invalidating analysis: \" << this->lookUpPass(ID).name()\n             << \" on \" << IR.getName() << \"\\n\";\n    AnalysisResultLists[&IR].erase(RI->second);\n    AnalysisResults.erase(RI);\n  }\n\n  /// Map type from analysis pass ID to pass concept pointer.\n  using AnalysisPassMapT =\n      DenseMap<AnalysisKey *, std::unique_ptr<PassConceptT>>;\n\n  /// Collection of analysis passes, indexed by ID.\n  AnalysisPassMapT AnalysisPasses;\n\n  /// Map from IR unit to a list of analysis results.\n  ///\n  /// Provides linear time removal of all analysis results for a IR unit and\n  /// the ultimate storage for a particular cached analysis result.\n  AnalysisResultListMapT AnalysisResultLists;\n\n  /// Map from an analysis ID and IR unit to a particular cached\n  /// analysis result.\n  AnalysisResultMapT AnalysisResults;\n\n  /// Indicates whether we log to \\c llvm::dbgs().\n  bool DebugLogging;\n};\n\nextern template class AnalysisManager<Module>;\n\n/// Convenience typedef for the Module analysis manager.\nusing ModuleAnalysisManager = AnalysisManager<Module>;\n\nextern template class AnalysisManager<Function>;\n\n/// Convenience typedef for the Function analysis manager.\nusing FunctionAnalysisManager = AnalysisManager<Function>;\n\n/// An analysis over an \"outer\" IR unit that provides access to an\n/// analysis manager over an \"inner\" IR unit.  The inner unit must be contained\n/// in the outer unit.\n///\n/// For example, InnerAnalysisManagerProxy<FunctionAnalysisManager, Module> is\n/// an analysis over Modules (the \"outer\" unit) that provides access to a\n/// Function analysis manager.  The FunctionAnalysisManager is the \"inner\"\n/// manager being proxied, and Functions are the \"inner\" unit.  The inner/outer\n/// relationship is valid because each Function is contained in one Module.\n///\n/// If you're (transitively) within a pass manager for an IR unit U that\n/// contains IR unit V, you should never use an analysis manager over V, except\n/// via one of these proxies.\n///\n/// Note that the proxy's result is a move-only RAII object.  The validity of\n/// the analyses in the inner analysis manager is tied to its lifetime.\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nclass InnerAnalysisManagerProxy\n    : public AnalysisInfoMixin<\n          InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT>> {\npublic:\n  class Result {\n  public:\n    explicit Result(AnalysisManagerT &InnerAM) : InnerAM(&InnerAM) {}\n\n    Result(Result &&Arg) : InnerAM(std::move(Arg.InnerAM)) {\n      // We have to null out the analysis manager in the moved-from state\n      // because we are taking ownership of the responsibilty to clear the\n      // analysis state.\n      Arg.InnerAM = nullptr;\n    }\n\n    ~Result() {\n      // InnerAM is cleared in a moved from state where there is nothing to do.\n      if (!InnerAM)\n        return;\n\n      // Clear out the analysis manager if we're being destroyed -- it means we\n      // didn't even see an invalidate call when we got invalidated.\n      InnerAM->clear();\n    }\n\n    Result &operator=(Result &&RHS) {\n      InnerAM = RHS.InnerAM;\n      // We have to null out the analysis manager in the moved-from state\n      // because we are taking ownership of the responsibilty to clear the\n      // analysis state.\n      RHS.InnerAM = nullptr;\n      return *this;\n    }\n\n    /// Accessor for the analysis manager.\n    AnalysisManagerT &getManager() { return *InnerAM; }\n\n    /// Handler for invalidation of the outer IR unit, \\c IRUnitT.\n    ///\n    /// If the proxy analysis itself is not preserved, we assume that the set of\n    /// inner IR objects contained in IRUnit may have changed.  In this case,\n    /// we have to call \\c clear() on the inner analysis manager, as it may now\n    /// have stale pointers to its inner IR objects.\n    ///\n    /// Regardless of whether the proxy analysis is marked as preserved, all of\n    /// the analyses in the inner analysis manager are potentially invalidated\n    /// based on the set of preserved analyses.\n    bool invalidate(\n        IRUnitT &IR, const PreservedAnalyses &PA,\n        typename AnalysisManager<IRUnitT, ExtraArgTs...>::Invalidator &Inv);\n\n  private:\n    AnalysisManagerT *InnerAM;\n  };\n\n  explicit InnerAnalysisManagerProxy(AnalysisManagerT &InnerAM)\n      : InnerAM(&InnerAM) {}\n\n  /// Run the analysis pass and create our proxy result object.\n  ///\n  /// This doesn't do any interesting work; it is primarily used to insert our\n  /// proxy result object into the outer analysis cache so that we can proxy\n  /// invalidation to the inner analysis manager.\n  Result run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n             ExtraArgTs...) {\n    return Result(*InnerAM);\n  }\n\nprivate:\n  friend AnalysisInfoMixin<\n      InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT>>;\n\n  static AnalysisKey Key;\n\n  AnalysisManagerT *InnerAM;\n};\n\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nAnalysisKey\n    InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>::Key;\n\n/// Provide the \\c FunctionAnalysisManager to \\c Module proxy.\nusing FunctionAnalysisManagerModuleProxy =\n    InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>;\n\n/// Specialization of the invalidate method for the \\c\n/// FunctionAnalysisManagerModuleProxy's result.\ntemplate <>\nbool FunctionAnalysisManagerModuleProxy::Result::invalidate(\n    Module &M, const PreservedAnalyses &PA,\n    ModuleAnalysisManager::Invalidator &Inv);\n\n// Ensure the \\c FunctionAnalysisManagerModuleProxy is provided as an extern\n// template.\nextern template class InnerAnalysisManagerProxy<FunctionAnalysisManager,\n                                                Module>;\n\n/// An analysis over an \"inner\" IR unit that provides access to an\n/// analysis manager over a \"outer\" IR unit.  The inner unit must be contained\n/// in the outer unit.\n///\n/// For example OuterAnalysisManagerProxy<ModuleAnalysisManager, Function> is an\n/// analysis over Functions (the \"inner\" unit) which provides access to a Module\n/// analysis manager.  The ModuleAnalysisManager is the \"outer\" manager being\n/// proxied, and Modules are the \"outer\" IR unit.  The inner/outer relationship\n/// is valid because each Function is contained in one Module.\n///\n/// This proxy only exposes the const interface of the outer analysis manager,\n/// to indicate that you cannot cause an outer analysis to run from within an\n/// inner pass.  Instead, you must rely on the \\c getCachedResult API.  This is\n/// due to keeping potential future concurrency in mind. To give an example,\n/// running a module analysis before any function passes may give a different\n/// result than running it in a function pass. Both may be valid, but it would\n/// produce non-deterministic results. GlobalsAA is a good analysis example,\n/// because the cached information has the mod/ref info for all memory for each\n/// function at the time the analysis was computed. The information is still\n/// valid after a function transformation, but it may be *different* if\n/// recomputed after that transform. GlobalsAA is never invalidated.\n\n///\n/// This proxy doesn't manage invalidation in any way -- that is handled by the\n/// recursive return path of each layer of the pass manager.  A consequence of\n/// this is the outer analyses may be stale.  We invalidate the outer analyses\n/// only when we're done running passes over the inner IR units.\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nclass OuterAnalysisManagerProxy\n    : public AnalysisInfoMixin<\n          OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>> {\npublic:\n  /// Result proxy object for \\c OuterAnalysisManagerProxy.\n  class Result {\n  public:\n    explicit Result(const AnalysisManagerT &OuterAM) : OuterAM(&OuterAM) {}\n\n    /// Get a cached analysis. If the analysis can be invalidated, this will\n    /// assert.\n    template <typename PassT, typename IRUnitTParam>\n    typename PassT::Result *getCachedResult(IRUnitTParam &IR) const {\n      typename PassT::Result *Res =\n          OuterAM->template getCachedResult<PassT>(IR);\n      if (Res)\n        OuterAM->template verifyNotInvalidated<PassT>(IR, Res);\n      return Res;\n    }\n\n    /// Method provided for unit testing, not intended for general use.\n    template <typename PassT, typename IRUnitTParam>\n    bool cachedResultExists(IRUnitTParam &IR) const {\n      typename PassT::Result *Res =\n          OuterAM->template getCachedResult<PassT>(IR);\n      return Res != nullptr;\n    }\n\n    /// When invalidation occurs, remove any registered invalidation events.\n    bool invalidate(\n        IRUnitT &IRUnit, const PreservedAnalyses &PA,\n        typename AnalysisManager<IRUnitT, ExtraArgTs...>::Invalidator &Inv) {\n      // Loop over the set of registered outer invalidation mappings and if any\n      // of them map to an analysis that is now invalid, clear it out.\n      SmallVector<AnalysisKey *, 4> DeadKeys;\n      for (auto &KeyValuePair : OuterAnalysisInvalidationMap) {\n        AnalysisKey *OuterID = KeyValuePair.first;\n        auto &InnerIDs = KeyValuePair.second;\n        llvm::erase_if(InnerIDs, [&](AnalysisKey *InnerID) {\n          return Inv.invalidate(InnerID, IRUnit, PA);\n        });\n        if (InnerIDs.empty())\n          DeadKeys.push_back(OuterID);\n      }\n\n      for (auto OuterID : DeadKeys)\n        OuterAnalysisInvalidationMap.erase(OuterID);\n\n      // The proxy itself remains valid regardless of anything else.\n      return false;\n    }\n\n    /// Register a deferred invalidation event for when the outer analysis\n    /// manager processes its invalidations.\n    template <typename OuterAnalysisT, typename InvalidatedAnalysisT>\n    void registerOuterAnalysisInvalidation() {\n      AnalysisKey *OuterID = OuterAnalysisT::ID();\n      AnalysisKey *InvalidatedID = InvalidatedAnalysisT::ID();\n\n      auto &InvalidatedIDList = OuterAnalysisInvalidationMap[OuterID];\n      // Note, this is a linear scan. If we end up with large numbers of\n      // analyses that all trigger invalidation on the same outer analysis,\n      // this entire system should be changed to some other deterministic\n      // data structure such as a `SetVector` of a pair of pointers.\n      if (!llvm::is_contained(InvalidatedIDList, InvalidatedID))\n        InvalidatedIDList.push_back(InvalidatedID);\n    }\n\n    /// Access the map from outer analyses to deferred invalidation requiring\n    /// analyses.\n    const SmallDenseMap<AnalysisKey *, TinyPtrVector<AnalysisKey *>, 2> &\n    getOuterInvalidations() const {\n      return OuterAnalysisInvalidationMap;\n    }\n\n  private:\n    const AnalysisManagerT *OuterAM;\n\n    /// A map from an outer analysis ID to the set of this IR-unit's analyses\n    /// which need to be invalidated.\n    SmallDenseMap<AnalysisKey *, TinyPtrVector<AnalysisKey *>, 2>\n        OuterAnalysisInvalidationMap;\n  };\n\n  OuterAnalysisManagerProxy(const AnalysisManagerT &OuterAM)\n      : OuterAM(&OuterAM) {}\n\n  /// Run the analysis pass and create our proxy result object.\n  /// Nothing to see here, it just forwards the \\c OuterAM reference into the\n  /// result.\n  Result run(IRUnitT &, AnalysisManager<IRUnitT, ExtraArgTs...> &,\n             ExtraArgTs...) {\n    return Result(*OuterAM);\n  }\n\nprivate:\n  friend AnalysisInfoMixin<\n      OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>>;\n\n  static AnalysisKey Key;\n\n  const AnalysisManagerT *OuterAM;\n};\n\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nAnalysisKey\n    OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>::Key;\n\nextern template class OuterAnalysisManagerProxy<ModuleAnalysisManager,\n                                                Function>;\n/// Provide the \\c ModuleAnalysisManager to \\c Function proxy.\nusing ModuleAnalysisManagerFunctionProxy =\n    OuterAnalysisManagerProxy<ModuleAnalysisManager, Function>;\n\n/// Trivial adaptor that maps from a module to its functions.\n///\n/// Designed to allow composition of a FunctionPass(Manager) and\n/// a ModulePassManager, by running the FunctionPass(Manager) over every\n/// function in the module.\n///\n/// Function passes run within this adaptor can rely on having exclusive access\n/// to the function they are run over. They should not read or modify any other\n/// functions! Other threads or systems may be manipulating other functions in\n/// the module, and so their state should never be relied on.\n/// FIXME: Make the above true for all of LLVM's actual passes, some still\n/// violate this principle.\n///\n/// Function passes can also read the module containing the function, but they\n/// should not modify that module outside of the use lists of various globals.\n/// For example, a function pass is not permitted to add functions to the\n/// module.\n/// FIXME: Make the above true for all of LLVM's actual passes, some still\n/// violate this principle.\n///\n/// Note that although function passes can access module analyses, module\n/// analyses are not invalidated while the function passes are running, so they\n/// may be stale.  Function analyses will not be stale.\nclass ModuleToFunctionPassAdaptor\n    : public PassInfoMixin<ModuleToFunctionPassAdaptor> {\npublic:\n  using PassConceptT = detail::PassConcept<Function, FunctionAnalysisManager>;\n\n  explicit ModuleToFunctionPassAdaptor(std::unique_ptr<PassConceptT> Pass)\n      : Pass(std::move(Pass)) {}\n\n  /// Runs the function pass across every function in the module.\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\n  static bool isRequired() { return true; }\n\nprivate:\n  std::unique_ptr<PassConceptT> Pass;\n};\n\n/// A function to deduce a function pass type and wrap it in the\n/// templated adaptor.\ntemplate <typename FunctionPassT>\nModuleToFunctionPassAdaptor\ncreateModuleToFunctionPassAdaptor(FunctionPassT Pass) {\n  using PassModelT =\n      detail::PassModel<Function, FunctionPassT, PreservedAnalyses,\n                        FunctionAnalysisManager>;\n\n  return ModuleToFunctionPassAdaptor(\n      std::make_unique<PassModelT>(std::move(Pass)));\n}\n\n/// A utility pass template to force an analysis result to be available.\n///\n/// If there are extra arguments at the pass's run level there may also be\n/// extra arguments to the analysis manager's \\c getResult routine. We can't\n/// guess how to effectively map the arguments from one to the other, and so\n/// this specialization just ignores them.\n///\n/// Specific patterns of run-method extra arguments and analysis manager extra\n/// arguments will have to be defined as appropriate specializations.\ntemplate <typename AnalysisT, typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nstruct RequireAnalysisPass\n    : PassInfoMixin<RequireAnalysisPass<AnalysisT, IRUnitT, AnalysisManagerT,\n                                        ExtraArgTs...>> {\n  /// Run this pass over some unit of IR.\n  ///\n  /// This pass can be run over any unit of IR and use any analysis manager\n  /// provided they satisfy the basic API requirements. When this pass is\n  /// created, these methods can be instantiated to satisfy whatever the\n  /// context requires.\n  PreservedAnalyses run(IRUnitT &Arg, AnalysisManagerT &AM,\n                        ExtraArgTs &&... Args) {\n    (void)AM.template getResult<AnalysisT>(Arg,\n                                           std::forward<ExtraArgTs>(Args)...);\n\n    return PreservedAnalyses::all();\n  }\n  static bool isRequired() { return true; }\n};\n\n/// A no-op pass template which simply forces a specific analysis result\n/// to be invalidated.\ntemplate <typename AnalysisT>\nstruct InvalidateAnalysisPass\n    : PassInfoMixin<InvalidateAnalysisPass<AnalysisT>> {\n  /// Run this pass over some unit of IR.\n  ///\n  /// This pass can be run over any unit of IR and use any analysis manager,\n  /// provided they satisfy the basic API requirements. When this pass is\n  /// created, these methods can be instantiated to satisfy whatever the\n  /// context requires.\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  PreservedAnalyses run(IRUnitT &Arg, AnalysisManagerT &AM, ExtraArgTs &&...) {\n    auto PA = PreservedAnalyses::all();\n    PA.abandon<AnalysisT>();\n    return PA;\n  }\n};\n\n/// A utility pass that does nothing, but preserves no analyses.\n///\n/// Because this preserves no analyses, any analysis passes queried after this\n/// pass runs will recompute fresh results.\nstruct InvalidateAllAnalysesPass : PassInfoMixin<InvalidateAllAnalysesPass> {\n  /// Run this pass over some unit of IR.\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  PreservedAnalyses run(IRUnitT &, AnalysisManagerT &, ExtraArgTs &&...) {\n    return PreservedAnalyses::none();\n  }\n};\n\n/// A utility pass template that simply runs another pass multiple times.\n///\n/// This can be useful when debugging or testing passes. It also serves as an\n/// example of how to extend the pass manager in ways beyond composition.\ntemplate <typename PassT>\nclass RepeatedPass : public PassInfoMixin<RepeatedPass<PassT>> {\npublic:\n  RepeatedPass(int Count, PassT P) : Count(Count), P(std::move(P)) {}\n\n  template <typename IRUnitT, typename AnalysisManagerT, typename... Ts>\n  PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM, Ts &&... Args) {\n\n    // Request PassInstrumentation from analysis manager, will use it to run\n    // instrumenting callbacks for the passes later.\n    // Here we use std::tuple wrapper over getResult which helps to extract\n    // AnalysisManager's arguments out of the whole Args set.\n    PassInstrumentation PI =\n        detail::getAnalysisResult<PassInstrumentationAnalysis>(\n            AM, IR, std::tuple<Ts...>(Args...));\n\n    auto PA = PreservedAnalyses::all();\n    for (int i = 0; i < Count; ++i) {\n      // Check the PassInstrumentation's BeforePass callbacks before running the\n      // pass, skip its execution completely if asked to (callback returns\n      // false).\n      if (!PI.runBeforePass<IRUnitT>(P, IR))\n        continue;\n      PreservedAnalyses IterPA = P.run(IR, AM, std::forward<Ts>(Args)...);\n      PA.intersect(IterPA);\n      PI.runAfterPass(P, IR, IterPA);\n    }\n    return PA;\n  }\n\nprivate:\n  int Count;\n  PassT P;\n};\n\ntemplate <typename PassT>\nRepeatedPass<PassT> createRepeatedPass(int Count, PassT P) {\n  return RepeatedPass<PassT>(Count, std::move(P));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_PASSMANAGER_H\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "content": "//===- PassManager internal APIs and implementation details -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This header provides internal APIs and implementation details used by the\n/// pass management interfaces exposed in PassManager.h. To understand more\n/// context of why these particular interfaces are needed, see that header\n/// file. None of these APIs should be used elsewhere.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PASSMANAGERINTERNAL_H\n#define LLVM_IR_PASSMANAGERINTERNAL_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\ntemplate <typename IRUnitT> class AllAnalysesOn;\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager;\nclass PreservedAnalyses;\n\n/// Implementation details of the pass manager interfaces.\nnamespace detail {\n\n/// Template for the abstract base class used to dispatch\n/// polymorphically over pass objects.\ntemplate <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\nstruct PassConcept {\n  // Boiler plate necessary for the container of derived classes.\n  virtual ~PassConcept() = default;\n\n  /// The polymorphic API which runs the pass over a given IR entity.\n  ///\n  /// Note that actual pass object can omit the analysis manager argument if\n  /// desired. Also that the analysis manager may be null if there is no\n  /// analysis manager in the pass pipeline.\n  virtual PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM,\n                                ExtraArgTs... ExtraArgs) = 0;\n\n  /// Polymorphic method to access the name of a pass.\n  virtual StringRef name() const = 0;\n\n  /// Polymorphic method to to let a pass optionally exempted from skipping by\n  /// PassInstrumentation.\n  /// To opt-in, pass should implement `static bool isRequired()`. It's no-op\n  /// to have `isRequired` always return false since that is the default.\n  virtual bool isRequired() const = 0;\n};\n\n/// A template wrapper used to implement the polymorphic API.\n///\n/// Can be instantiated for any object which provides a \\c run method accepting\n/// an \\c IRUnitT& and an \\c AnalysisManager<IRUnit>&. It requires the pass to\n/// be a copyable object.\ntemplate <typename IRUnitT, typename PassT, typename PreservedAnalysesT,\n          typename AnalysisManagerT, typename... ExtraArgTs>\nstruct PassModel : PassConcept<IRUnitT, AnalysisManagerT, ExtraArgTs...> {\n  explicit PassModel(PassT Pass) : Pass(std::move(Pass)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  PassModel(const PassModel &Arg) : Pass(Arg.Pass) {}\n  PassModel(PassModel &&Arg) : Pass(std::move(Arg.Pass)) {}\n\n  friend void swap(PassModel &LHS, PassModel &RHS) {\n    using std::swap;\n    swap(LHS.Pass, RHS.Pass);\n  }\n\n  PassModel &operator=(PassModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  PreservedAnalysesT run(IRUnitT &IR, AnalysisManagerT &AM,\n                         ExtraArgTs... ExtraArgs) override {\n    return Pass.run(IR, AM, ExtraArgs...);\n  }\n\n  StringRef name() const override { return PassT::name(); }\n\n  template <typename T>\n  using has_required_t = decltype(std::declval<T &>().isRequired());\n\n  template <typename T>\n  static std::enable_if_t<is_detected<has_required_t, T>::value, bool>\n  passIsRequiredImpl() {\n    return T::isRequired();\n  }\n  template <typename T>\n  static std::enable_if_t<!is_detected<has_required_t, T>::value, bool>\n  passIsRequiredImpl() {\n    return false;\n  }\n\n  bool isRequired() const override { return passIsRequiredImpl<PassT>(); }\n\n  PassT Pass;\n};\n\n/// Abstract concept of an analysis result.\n///\n/// This concept is parameterized over the IR unit that this result pertains\n/// to.\ntemplate <typename IRUnitT, typename PreservedAnalysesT, typename InvalidatorT>\nstruct AnalysisResultConcept {\n  virtual ~AnalysisResultConcept() = default;\n\n  /// Method to try and mark a result as invalid.\n  ///\n  /// When the outer analysis manager detects a change in some underlying\n  /// unit of the IR, it will call this method on all of the results cached.\n  ///\n  /// \\p PA is a set of preserved analyses which can be used to avoid\n  /// invalidation because the pass which changed the underlying IR took care\n  /// to update or preserve the analysis result in some way.\n  ///\n  /// \\p Inv is typically a \\c AnalysisManager::Invalidator object that can be\n  /// used by a particular analysis result to discover if other analyses\n  /// results are also invalidated in the event that this result depends on\n  /// them. See the documentation in the \\c AnalysisManager for more details.\n  ///\n  /// \\returns true if the result is indeed invalid (the default).\n  virtual bool invalidate(IRUnitT &IR, const PreservedAnalysesT &PA,\n                          InvalidatorT &Inv) = 0;\n};\n\n/// SFINAE metafunction for computing whether \\c ResultT provides an\n/// \\c invalidate member function.\ntemplate <typename IRUnitT, typename ResultT> class ResultHasInvalidateMethod {\n  using EnabledType = char;\n  struct DisabledType {\n    char a, b;\n  };\n\n  // Purely to help out MSVC which fails to disable the below specialization,\n  // explicitly enable using the result type's invalidate routine if we can\n  // successfully call that routine.\n  template <typename T> struct Nonce { using Type = EnabledType; };\n  template <typename T>\n  static typename Nonce<decltype(std::declval<T>().invalidate(\n      std::declval<IRUnitT &>(), std::declval<PreservedAnalyses>()))>::Type\n      check(rank<2>);\n\n  // First we define an overload that can only be taken if there is no\n  // invalidate member. We do this by taking the address of an invalidate\n  // member in an adjacent base class of a derived class. This would be\n  // ambiguous if there were an invalidate member in the result type.\n  template <typename T, typename U> static DisabledType NonceFunction(T U::*);\n  struct CheckerBase { int invalidate; };\n  template <typename T> struct Checker : CheckerBase, T {};\n  template <typename T>\n  static decltype(NonceFunction(&Checker<T>::invalidate)) check(rank<1>);\n\n  // Now we have the fallback that will only be reached when there is an\n  // invalidate member, and enables the trait.\n  template <typename T>\n  static EnabledType check(rank<0>);\n\npublic:\n  enum { Value = sizeof(check<ResultT>(rank<2>())) == sizeof(EnabledType) };\n};\n\n/// Wrapper to model the analysis result concept.\n///\n/// By default, this will implement the invalidate method with a trivial\n/// implementation so that the actual analysis result doesn't need to provide\n/// an invalidation handler. It is only selected when the invalidation handler\n/// is not part of the ResultT's interface.\ntemplate <typename IRUnitT, typename PassT, typename ResultT,\n          typename PreservedAnalysesT, typename InvalidatorT,\n          bool HasInvalidateHandler =\n              ResultHasInvalidateMethod<IRUnitT, ResultT>::Value>\nstruct AnalysisResultModel;\n\n/// Specialization of \\c AnalysisResultModel which provides the default\n/// invalidate functionality.\ntemplate <typename IRUnitT, typename PassT, typename ResultT,\n          typename PreservedAnalysesT, typename InvalidatorT>\nstruct AnalysisResultModel<IRUnitT, PassT, ResultT, PreservedAnalysesT,\n                           InvalidatorT, false>\n    : AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT> {\n  explicit AnalysisResultModel(ResultT Result) : Result(std::move(Result)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  AnalysisResultModel(const AnalysisResultModel &Arg) : Result(Arg.Result) {}\n  AnalysisResultModel(AnalysisResultModel &&Arg)\n      : Result(std::move(Arg.Result)) {}\n\n  friend void swap(AnalysisResultModel &LHS, AnalysisResultModel &RHS) {\n    using std::swap;\n    swap(LHS.Result, RHS.Result);\n  }\n\n  AnalysisResultModel &operator=(AnalysisResultModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  /// The model bases invalidation solely on being in the preserved set.\n  //\n  // FIXME: We should actually use two different concepts for analysis results\n  // rather than two different models, and avoid the indirect function call for\n  // ones that use the trivial behavior.\n  bool invalidate(IRUnitT &, const PreservedAnalysesT &PA,\n                  InvalidatorT &) override {\n    auto PAC = PA.template getChecker<PassT>();\n    return !PAC.preserved() &&\n           !PAC.template preservedSet<AllAnalysesOn<IRUnitT>>();\n  }\n\n  ResultT Result;\n};\n\n/// Specialization of \\c AnalysisResultModel which delegates invalidate\n/// handling to \\c ResultT.\ntemplate <typename IRUnitT, typename PassT, typename ResultT,\n          typename PreservedAnalysesT, typename InvalidatorT>\nstruct AnalysisResultModel<IRUnitT, PassT, ResultT, PreservedAnalysesT,\n                           InvalidatorT, true>\n    : AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT> {\n  explicit AnalysisResultModel(ResultT Result) : Result(std::move(Result)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  AnalysisResultModel(const AnalysisResultModel &Arg) : Result(Arg.Result) {}\n  AnalysisResultModel(AnalysisResultModel &&Arg)\n      : Result(std::move(Arg.Result)) {}\n\n  friend void swap(AnalysisResultModel &LHS, AnalysisResultModel &RHS) {\n    using std::swap;\n    swap(LHS.Result, RHS.Result);\n  }\n\n  AnalysisResultModel &operator=(AnalysisResultModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  /// The model delegates to the \\c ResultT method.\n  bool invalidate(IRUnitT &IR, const PreservedAnalysesT &PA,\n                  InvalidatorT &Inv) override {\n    return Result.invalidate(IR, PA, Inv);\n  }\n\n  ResultT Result;\n};\n\n/// Abstract concept of an analysis pass.\n///\n/// This concept is parameterized over the IR unit that it can run over and\n/// produce an analysis result.\ntemplate <typename IRUnitT, typename PreservedAnalysesT, typename InvalidatorT,\n          typename... ExtraArgTs>\nstruct AnalysisPassConcept {\n  virtual ~AnalysisPassConcept() = default;\n\n  /// Method to run this analysis over a unit of IR.\n  /// \\returns A unique_ptr to the analysis result object to be queried by\n  /// users.\n  virtual std::unique_ptr<\n      AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT>>\n  run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n      ExtraArgTs... ExtraArgs) = 0;\n\n  /// Polymorphic method to access the name of a pass.\n  virtual StringRef name() const = 0;\n};\n\n/// Wrapper to model the analysis pass concept.\n///\n/// Can wrap any type which implements a suitable \\c run method. The method\n/// must accept an \\c IRUnitT& and an \\c AnalysisManager<IRUnitT>& as arguments\n/// and produce an object which can be wrapped in a \\c AnalysisResultModel.\ntemplate <typename IRUnitT, typename PassT, typename PreservedAnalysesT,\n          typename InvalidatorT, typename... ExtraArgTs>\nstruct AnalysisPassModel : AnalysisPassConcept<IRUnitT, PreservedAnalysesT,\n                                               InvalidatorT, ExtraArgTs...> {\n  explicit AnalysisPassModel(PassT Pass) : Pass(std::move(Pass)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  AnalysisPassModel(const AnalysisPassModel &Arg) : Pass(Arg.Pass) {}\n  AnalysisPassModel(AnalysisPassModel &&Arg) : Pass(std::move(Arg.Pass)) {}\n\n  friend void swap(AnalysisPassModel &LHS, AnalysisPassModel &RHS) {\n    using std::swap;\n    swap(LHS.Pass, RHS.Pass);\n  }\n\n  AnalysisPassModel &operator=(AnalysisPassModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  // FIXME: Replace PassT::Result with type traits when we use C++11.\n  using ResultModelT =\n      AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                          PreservedAnalysesT, InvalidatorT>;\n\n  /// The model delegates to the \\c PassT::run method.\n  ///\n  /// The return is wrapped in an \\c AnalysisResultModel.\n  std::unique_ptr<\n      AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT>>\n  run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n      ExtraArgTs... ExtraArgs) override {\n    return std::make_unique<ResultModelT>(\n        Pass.run(IR, AM, std::forward<ExtraArgTs>(ExtraArgs)...));\n  }\n\n  /// The model delegates to a static \\c PassT::name method.\n  ///\n  /// The returned string ref must point to constant immutable data!\n  StringRef name() const override { return PassT::name(); }\n\n  PassT Pass;\n};\n\n} // end namespace detail\n\n} // end namespace llvm\n\n#endif // LLVM_IR_PASSMANAGERINTERNAL_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/SymbolTableListTraits.h", "content": "//===- llvm/SymbolTableListTraits.h - Traits for iplist ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a generic class that is used to implement the automatic\n// symbol table manipulation that occurs when you put (for example) a named\n// instruction into a basic block.\n//\n// The way that this is implemented is by using a special traits class with the\n// intrusive list that makes up the list of instructions in a basic block.  When\n// a new element is added to the list of instructions, the traits class is\n// notified, allowing the symbol table to be updated.\n//\n// This generic class implements the traits class.  It must be generic so that\n// it can work for all uses it, which include lists of instructions, basic\n// blocks, arguments, functions, global variables, etc...\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_SYMBOLTABLELISTTRAITS_H\n#define LLVM_IR_SYMBOLTABLELISTTRAITS_H\n\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/simple_ilist.h\"\n#include <cstddef>\n\nnamespace llvm {\n\nclass Argument;\nclass BasicBlock;\nclass Function;\nclass GlobalAlias;\nclass GlobalIFunc;\nclass GlobalVariable;\nclass Instruction;\nclass Module;\nclass ValueSymbolTable;\n\n/// Template metafunction to get the parent type for a symbol table list.\n///\n/// Implementations create a typedef called \\c type so that we only need a\n/// single template parameter for the list and traits.\ntemplate <typename NodeTy> struct SymbolTableListParentType {};\n\n#define DEFINE_SYMBOL_TABLE_PARENT_TYPE(NODE, PARENT)                          \\\n  template <> struct SymbolTableListParentType<NODE> { using type = PARENT; };\nDEFINE_SYMBOL_TABLE_PARENT_TYPE(Instruction, BasicBlock)\nDEFINE_SYMBOL_TABLE_PARENT_TYPE(BasicBlock, Function)\nDEFINE_SYMBOL_TABLE_PARENT_TYPE(Argument, Function)\nDEFINE_SYMBOL_TABLE_PARENT_TYPE(Function, Module)\nDEFINE_SYMBOL_TABLE_PARENT_TYPE(GlobalVariable, Module)\nDEFINE_SYMBOL_TABLE_PARENT_TYPE(GlobalAlias, Module)\nDEFINE_SYMBOL_TABLE_PARENT_TYPE(GlobalIFunc, Module)\n#undef DEFINE_SYMBOL_TABLE_PARENT_TYPE\n\ntemplate <typename NodeTy> class SymbolTableList;\n\n// ValueSubClass   - The type of objects that I hold, e.g. Instruction.\n// ItemParentClass - The type of object that owns the list, e.g. BasicBlock.\n//\ntemplate <typename ValueSubClass>\nclass SymbolTableListTraits : public ilist_alloc_traits<ValueSubClass> {\n  using ListTy = SymbolTableList<ValueSubClass>;\n  using iterator = typename simple_ilist<ValueSubClass>::iterator;\n  using ItemParentClass =\n      typename SymbolTableListParentType<ValueSubClass>::type;\n\npublic:\n  SymbolTableListTraits() = default;\n\nprivate:\n  /// getListOwner - Return the object that owns this list.  If this is a list\n  /// of instructions, it returns the BasicBlock that owns them.\n  ItemParentClass *getListOwner() {\n    size_t Offset = reinterpret_cast<size_t>(\n        &((ItemParentClass *)nullptr->*ItemParentClass::getSublistAccess(\n                                           static_cast<ValueSubClass *>(\n                                               nullptr))));\n    ListTy *Anchor = static_cast<ListTy *>(this);\n    return reinterpret_cast<ItemParentClass*>(reinterpret_cast<char*>(Anchor)-\n                                              Offset);\n  }\n\n  static ListTy &getList(ItemParentClass *Par) {\n    return Par->*(Par->getSublistAccess((ValueSubClass*)nullptr));\n  }\n\n  static ValueSymbolTable *getSymTab(ItemParentClass *Par) {\n    return Par ? toPtr(Par->getValueSymbolTable()) : nullptr;\n  }\n\npublic:\n  void addNodeToList(ValueSubClass *V);\n  void removeNodeFromList(ValueSubClass *V);\n  void transferNodesFromList(SymbolTableListTraits &L2, iterator first,\n                             iterator last);\n  // private:\n  template<typename TPtr>\n  void setSymTabObject(TPtr *, TPtr);\n  static ValueSymbolTable *toPtr(ValueSymbolTable *P) { return P; }\n  static ValueSymbolTable *toPtr(ValueSymbolTable &R) { return &R; }\n};\n\n/// List that automatically updates parent links and symbol tables.\n///\n/// When nodes are inserted into and removed from this list, the associated\n/// symbol table will be automatically updated.  Similarly, parent links get\n/// updated automatically.\ntemplate <class T>\nclass SymbolTableList\n    : public iplist_impl<simple_ilist<T>, SymbolTableListTraits<T>> {};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_SYMBOLTABLELISTTRAITS_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "content": "//===- llvm/IR/TrackingMDRef.h - Tracking Metadata references ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// References to metadata that track RAUW.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_TRACKINGMDREF_H\n#define LLVM_IR_TRACKINGMDREF_H\n\n#include \"llvm/IR/Metadata.h\"\n#include <algorithm>\n#include <cassert>\n\nnamespace llvm {\n\n/// Tracking metadata reference.\n///\n/// This class behaves like \\a TrackingVH, but for metadata.\nclass TrackingMDRef {\n  Metadata *MD = nullptr;\n\npublic:\n  TrackingMDRef() = default;\n  explicit TrackingMDRef(Metadata *MD) : MD(MD) { track(); }\n\n  TrackingMDRef(TrackingMDRef &&X) : MD(X.MD) { retrack(X); }\n  TrackingMDRef(const TrackingMDRef &X) : MD(X.MD) { track(); }\n\n  TrackingMDRef &operator=(TrackingMDRef &&X) {\n    if (&X == this)\n      return *this;\n\n    untrack();\n    MD = X.MD;\n    retrack(X);\n    return *this;\n  }\n\n  TrackingMDRef &operator=(const TrackingMDRef &X) {\n    if (&X == this)\n      return *this;\n\n    untrack();\n    MD = X.MD;\n    track();\n    return *this;\n  }\n\n  ~TrackingMDRef() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD) {\n    untrack();\n    this->MD = MD;\n    track();\n  }\n\n  /// Check whether this has a trivial destructor.\n  ///\n  /// If \\c MD isn't replaceable, the destructor will be a no-op.\n  bool hasTrivialDestructor() const {\n    return !MD || !MetadataTracking::isReplaceable(*MD);\n  }\n\n  bool operator==(const TrackingMDRef &X) const { return MD == X.MD; }\n  bool operator!=(const TrackingMDRef &X) const { return MD != X.MD; }\n\nprivate:\n  void track() {\n    if (MD)\n      MetadataTracking::track(MD);\n  }\n\n  void untrack() {\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n\n  void retrack(TrackingMDRef &X) {\n    assert(MD == X.MD && \"Expected values to match\");\n    if (X.MD) {\n      MetadataTracking::retrack(X.MD, MD);\n      X.MD = nullptr;\n    }\n  }\n};\n\n/// Typed tracking ref.\n///\n/// Track refererences of a particular type.  It's useful to use this for \\a\n/// MDNode and \\a ValueAsMetadata.\ntemplate <class T> class TypedTrackingMDRef {\n  TrackingMDRef Ref;\n\npublic:\n  TypedTrackingMDRef() = default;\n  explicit TypedTrackingMDRef(T *MD) : Ref(static_cast<Metadata *>(MD)) {}\n\n  TypedTrackingMDRef(TypedTrackingMDRef &&X) : Ref(std::move(X.Ref)) {}\n  TypedTrackingMDRef(const TypedTrackingMDRef &X) : Ref(X.Ref) {}\n\n  TypedTrackingMDRef &operator=(TypedTrackingMDRef &&X) {\n    Ref = std::move(X.Ref);\n    return *this;\n  }\n\n  TypedTrackingMDRef &operator=(const TypedTrackingMDRef &X) {\n    Ref = X.Ref;\n    return *this;\n  }\n\n  T *get() const { return (T *)Ref.get(); }\n  operator T *() const { return get(); }\n  T *operator->() const { return get(); }\n  T &operator*() const { return *get(); }\n\n  bool operator==(const TypedTrackingMDRef &X) const { return Ref == X.Ref; }\n  bool operator!=(const TypedTrackingMDRef &X) const { return Ref != X.Ref; }\n\n  void reset() { Ref.reset(); }\n  void reset(T *MD) { Ref.reset(static_cast<Metadata *>(MD)); }\n\n  /// Check whether this has a trivial destructor.\n  bool hasTrivialDestructor() const { return Ref.hasTrivialDestructor(); }\n};\n\nusing TrackingMDNodeRef = TypedTrackingMDRef<MDNode>;\nusing TrackingValueAsMetadataRef = TypedTrackingMDRef<ValueAsMetadata>;\n\n// Expose the underlying metadata to casting.\ntemplate <> struct simplify_type<TrackingMDRef> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(TrackingMDRef &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const TrackingMDRef> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const TrackingMDRef &MD) {\n    return MD.get();\n  }\n};\n\ntemplate <class T> struct simplify_type<TypedTrackingMDRef<T>> {\n  using SimpleType = T *;\n\n  static SimpleType getSimplifiedValue(TypedTrackingMDRef<T> &MD) {\n    return MD.get();\n  }\n};\n\ntemplate <class T> struct simplify_type<const TypedTrackingMDRef<T>> {\n  using SimpleType = T *;\n\n  static SimpleType getSimplifiedValue(const TypedTrackingMDRef<T> &MD) {\n    return MD.get();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_TRACKINGMDREF_H\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Use.h", "content": "//===- llvm/Use.h - Definition of the Use class -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This defines the Use class.  The Use class represents the operand of an\n/// instruction or some other User instance which refers to a Value.  The Use\n/// class keeps the \"use list\" of the referenced value up to date.\n///\n/// Pointer tagging is used to efficiently find the User corresponding to a Use\n/// without having to store a User pointer in every Use. A User is preceded in\n/// memory by all the Uses corresponding to its operands, and the low bits of\n/// one of the fields (Prev) of the Use class are used to encode offsets to be\n/// able to find that User given a pointer to any Use. For details, see:\n///\n///   http://www.llvm.org/docs/ProgrammersManual.html#UserLayout\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_USE_H\n#define LLVM_IR_USE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Compiler.h\"\n\nnamespace llvm {\n\ntemplate <typename> struct simplify_type;\nclass User;\nclass Value;\n\n/// A Use represents the edge between a Value definition and its users.\n///\n/// This is notionally a two-dimensional linked list. It supports traversing\n/// all of the uses for a particular value definition. It also supports jumping\n/// directly to the used value when we arrive from the User's operands, and\n/// jumping directly to the User when we arrive from the Value's uses.\nclass Use {\npublic:\n  Use(const Use &U) = delete;\n\n  /// Provide a fast substitute to std::swap<Use>\n  /// that also works with less standard-compliant compilers\n  void swap(Use &RHS);\n\nprivate:\n  /// Destructor - Only for zap()\n  ~Use() {\n    if (Val)\n      removeFromList();\n  }\n\n  /// Constructor\n  Use(User *Parent) : Parent(Parent) {}\n\npublic:\n  friend class Value;\n  friend class User;\n\n  operator Value *() const { return Val; }\n  Value *get() const { return Val; }\n\n  /// Returns the User that contains this Use.\n  ///\n  /// For an instruction operand, for example, this will return the\n  /// instruction.\n  User *getUser() const { return Parent; };\n\n  inline void set(Value *Val);\n\n  inline Value *operator=(Value *RHS);\n  inline const Use &operator=(const Use &RHS);\n\n  Value *operator->() { return Val; }\n  const Value *operator->() const { return Val; }\n\n  Use *getNext() const { return Next; }\n\n  /// Return the operand # of this use in its User.\n  unsigned getOperandNo() const;\n\n  /// Destroys Use operands when the number of operands of\n  /// a User changes.\n  static void zap(Use *Start, const Use *Stop, bool del = false);\n\nprivate:\n\n  Value *Val = nullptr;\n  Use *Next = nullptr;\n  Use **Prev = nullptr;\n  User *Parent = nullptr;\n\n  void addToList(Use **List) {\n    Next = *List;\n    if (Next)\n      Next->Prev = &Next;\n    Prev = List;\n    *Prev = this;\n  }\n\n  void removeFromList() {\n    *Prev = Next;\n    if (Next)\n      Next->Prev = Prev;\n  }\n};\n\n/// Allow clients to treat uses just like values when using\n/// casting operators.\ntemplate <> struct simplify_type<Use> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(Use &Val) { return Val.get(); }\n};\ntemplate <> struct simplify_type<const Use> {\n  using SimpleType = /*const*/ Value *;\n\n  static SimpleType getSimplifiedValue(const Use &Val) { return Val.get(); }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(Use, LLVMUseRef)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_USE_H\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "content": "//===- llvm/User.h - User class definition ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class defines the interface that one who uses a Value must implement.\n// Each instance of the Value class keeps track of what User's have handles\n// to it.\n//\n//  * Instructions are the largest class of Users.\n//  * Constants may be users of other constants (think arrays and stuff)\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_USER_H\n#define LLVM_IR_USER_H\n\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\ntemplate <typename T> class MutableArrayRef;\n\n/// Compile-time customization of User operands.\n///\n/// Customizes operand-related allocators and accessors.\ntemplate <class>\nstruct OperandTraits;\n\nclass User : public Value {\n  template <unsigned>\n  friend struct HungoffOperandTraits;\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE static void *\n  allocateFixedOperandUser(size_t, unsigned, unsigned);\n\nprotected:\n  /// Allocate a User with an operand pointer co-allocated.\n  ///\n  /// This is used for subclasses which need to allocate a variable number\n  /// of operands, ie, 'hung off uses'.\n  void *operator new(size_t Size);\n\n  /// Allocate a User with the operands co-allocated.\n  ///\n  /// This is used for subclasses which have a fixed number of operands.\n  void *operator new(size_t Size, unsigned Us);\n\n  /// Allocate a User with the operands co-allocated.  If DescBytes is non-zero\n  /// then allocate an additional DescBytes bytes before the operands. These\n  /// bytes can be accessed by calling getDescriptor.\n  ///\n  /// DescBytes needs to be divisible by sizeof(void *).  The allocated\n  /// descriptor, if any, is aligned to sizeof(void *) bytes.\n  ///\n  /// This is used for subclasses which have a fixed number of operands.\n  void *operator new(size_t Size, unsigned Us, unsigned DescBytes);\n\n  User(Type *ty, unsigned vty, Use *, unsigned NumOps)\n      : Value(ty, vty) {\n    assert(NumOps < (1u << NumUserOperandsBits) && \"Too many operands\");\n    NumUserOperands = NumOps;\n    // If we have hung off uses, then the operand list should initially be\n    // null.\n    assert((!HasHungOffUses || !getOperandList()) &&\n           \"Error in initializing hung off uses for User\");\n  }\n\n  /// Allocate the array of Uses, followed by a pointer\n  /// (with bottom bit set) to the User.\n  /// \\param IsPhi identifies callers which are phi nodes and which need\n  /// N BasicBlock* allocated along with N\n  void allocHungoffUses(unsigned N, bool IsPhi = false);\n\n  /// Grow the number of hung off uses.  Note that allocHungoffUses\n  /// should be called if there are no uses.\n  void growHungoffUses(unsigned N, bool IsPhi = false);\n\nprotected:\n  ~User() = default; // Use deleteValue() to delete a generic Instruction.\n\npublic:\n  User(const User &) = delete;\n\n  /// Free memory allocated for User and Use objects.\n  void operator delete(void *Usr);\n  /// Placement delete - required by std, called if the ctor throws.\n  void operator delete(void *Usr, unsigned) {\n    // Note: If a subclass manipulates the information which is required to calculate the\n    // Usr memory pointer, e.g. NumUserOperands, the operator delete of that subclass has\n    // to restore the changed information to the original value, since the dtor of that class\n    // is not called if the ctor fails.\n    User::operator delete(Usr);\n\n#ifndef LLVM_ENABLE_EXCEPTIONS\n    llvm_unreachable(\"Constructor throws?\");\n#endif\n  }\n  /// Placement delete - required by std, called if the ctor throws.\n  void operator delete(void *Usr, unsigned, unsigned) {\n    // Note: If a subclass manipulates the information which is required to calculate the\n    // Usr memory pointer, e.g. NumUserOperands, the operator delete of that subclass has\n    // to restore the changed information to the original value, since the dtor of that class\n    // is not called if the ctor fails.\n    User::operator delete(Usr);\n\n#ifndef LLVM_ENABLE_EXCEPTIONS\n    llvm_unreachable(\"Constructor throws?\");\n#endif\n  }\n\nprotected:\n  template <int Idx, typename U> static Use &OpFrom(const U *that) {\n    return Idx < 0\n      ? OperandTraits<U>::op_end(const_cast<U*>(that))[Idx]\n      : OperandTraits<U>::op_begin(const_cast<U*>(that))[Idx];\n  }\n\n  template <int Idx> Use &Op() {\n    return OpFrom<Idx>(this);\n  }\n  template <int Idx> const Use &Op() const {\n    return OpFrom<Idx>(this);\n  }\n\nprivate:\n  const Use *getHungOffOperands() const {\n    return *(reinterpret_cast<const Use *const *>(this) - 1);\n  }\n\n  Use *&getHungOffOperands() { return *(reinterpret_cast<Use **>(this) - 1); }\n\n  const Use *getIntrusiveOperands() const {\n    return reinterpret_cast<const Use *>(this) - NumUserOperands;\n  }\n\n  Use *getIntrusiveOperands() {\n    return reinterpret_cast<Use *>(this) - NumUserOperands;\n  }\n\n  void setOperandList(Use *NewList) {\n    assert(HasHungOffUses &&\n           \"Setting operand list only required for hung off uses\");\n    getHungOffOperands() = NewList;\n  }\n\npublic:\n  const Use *getOperandList() const {\n    return HasHungOffUses ? getHungOffOperands() : getIntrusiveOperands();\n  }\n  Use *getOperandList() {\n    return const_cast<Use *>(static_cast<const User *>(this)->getOperandList());\n  }\n\n  Value *getOperand(unsigned i) const {\n    assert(i < NumUserOperands && \"getOperand() out of range!\");\n    return getOperandList()[i];\n  }\n\n  void setOperand(unsigned i, Value *Val) {\n    assert(i < NumUserOperands && \"setOperand() out of range!\");\n    assert((!isa<Constant>((const Value*)this) ||\n            isa<GlobalValue>((const Value*)this)) &&\n           \"Cannot mutate a constant with setOperand!\");\n    getOperandList()[i] = Val;\n  }\n\n  const Use &getOperandUse(unsigned i) const {\n    assert(i < NumUserOperands && \"getOperandUse() out of range!\");\n    return getOperandList()[i];\n  }\n  Use &getOperandUse(unsigned i) {\n    assert(i < NumUserOperands && \"getOperandUse() out of range!\");\n    return getOperandList()[i];\n  }\n\n  unsigned getNumOperands() const { return NumUserOperands; }\n\n  /// Returns the descriptor co-allocated with this User instance.\n  ArrayRef<const uint8_t> getDescriptor() const;\n\n  /// Returns the descriptor co-allocated with this User instance.\n  MutableArrayRef<uint8_t> getDescriptor();\n\n  /// Set the number of operands on a GlobalVariable.\n  ///\n  /// GlobalVariable always allocates space for a single operands, but\n  /// doesn't always use it.\n  ///\n  /// FIXME: As that the number of operands is used to find the start of\n  /// the allocated memory in operator delete, we need to always think we have\n  /// 1 operand before delete.\n  void setGlobalVariableNumOperands(unsigned NumOps) {\n    assert(NumOps <= 1 && \"GlobalVariable can only have 0 or 1 operands\");\n    NumUserOperands = NumOps;\n  }\n\n  /// Subclasses with hung off uses need to manage the operand count\n  /// themselves.  In these instances, the operand count isn't used to find the\n  /// OperandList, so there's no issue in having the operand count change.\n  void setNumHungOffUseOperands(unsigned NumOps) {\n    assert(HasHungOffUses && \"Must have hung off uses to use this method\");\n    assert(NumOps < (1u << NumUserOperandsBits) && \"Too many operands\");\n    NumUserOperands = NumOps;\n  }\n\n  /// A droppable user is a user for which uses can be dropped without affecting\n  /// correctness and should be dropped rather than preventing a transformation\n  /// from happening.\n  bool isDroppable() const;\n\n  // ---------------------------------------------------------------------------\n  // Operand Iterator interface...\n  //\n  using op_iterator = Use*;\n  using const_op_iterator = const Use*;\n  using op_range = iterator_range<op_iterator>;\n  using const_op_range = iterator_range<const_op_iterator>;\n\n  op_iterator       op_begin()       { return getOperandList(); }\n  const_op_iterator op_begin() const { return getOperandList(); }\n  op_iterator       op_end()         {\n    return getOperandList() + NumUserOperands;\n  }\n  const_op_iterator op_end()   const {\n    return getOperandList() + NumUserOperands;\n  }\n  op_range operands() {\n    return op_range(op_begin(), op_end());\n  }\n  const_op_range operands() const {\n    return const_op_range(op_begin(), op_end());\n  }\n\n  /// Iterator for directly iterating over the operand Values.\n  struct value_op_iterator\n      : iterator_adaptor_base<value_op_iterator, op_iterator,\n                              std::random_access_iterator_tag, Value *,\n                              ptrdiff_t, Value *, Value *> {\n    explicit value_op_iterator(Use *U = nullptr) : iterator_adaptor_base(U) {}\n\n    Value *operator*() const { return *I; }\n    Value *operator->() const { return operator*(); }\n  };\n\n  value_op_iterator value_op_begin() {\n    return value_op_iterator(op_begin());\n  }\n  value_op_iterator value_op_end() {\n    return value_op_iterator(op_end());\n  }\n  iterator_range<value_op_iterator> operand_values() {\n    return make_range(value_op_begin(), value_op_end());\n  }\n\n  struct const_value_op_iterator\n      : iterator_adaptor_base<const_value_op_iterator, const_op_iterator,\n                              std::random_access_iterator_tag, const Value *,\n                              ptrdiff_t, const Value *, const Value *> {\n    explicit const_value_op_iterator(const Use *U = nullptr) :\n      iterator_adaptor_base(U) {}\n\n    const Value *operator*() const { return *I; }\n    const Value *operator->() const { return operator*(); }\n  };\n\n  const_value_op_iterator value_op_begin() const {\n    return const_value_op_iterator(op_begin());\n  }\n  const_value_op_iterator value_op_end() const {\n    return const_value_op_iterator(op_end());\n  }\n  iterator_range<const_value_op_iterator> operand_values() const {\n    return make_range(value_op_begin(), value_op_end());\n  }\n\n  /// Drop all references to operands.\n  ///\n  /// This function is in charge of \"letting go\" of all objects that this User\n  /// refers to.  This allows one to 'delete' a whole class at a time, even\n  /// though there may be circular references...  First all references are\n  /// dropped, and all use counts go to zero.  Then everything is deleted for\n  /// real.  Note that no operations are valid on an object that has \"dropped\n  /// all references\", except operator delete.\n  void dropAllReferences() {\n    for (Use &U : operands())\n      U.set(nullptr);\n  }\n\n  /// Replace uses of one Value with another.\n  ///\n  /// Replaces all references to the \"From\" definition with references to the\n  /// \"To\" definition.\n  void replaceUsesOfWith(Value *From, Value *To);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) || isa<Constant>(V);\n  }\n};\n\n// Either Use objects, or a Use pointer can be prepended to User.\nstatic_assert(alignof(Use) >= alignof(User),\n              \"Alignment is insufficient after objects prepended to User\");\nstatic_assert(alignof(Use *) >= alignof(User),\n              \"Alignment is insufficient after objects prepended to User\");\n\ntemplate<> struct simplify_type<User::op_iterator> {\n  using SimpleType = Value*;\n\n  static SimpleType getSimplifiedValue(User::op_iterator &Val) {\n    return Val->get();\n  }\n};\ntemplate<> struct simplify_type<User::const_op_iterator> {\n  using SimpleType = /*const*/ Value*;\n\n  static SimpleType getSimplifiedValue(User::const_op_iterator &Val) {\n    return Val->get();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_USER_H\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "content": "//===- llvm/Value.h - Definition of the Value class -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Value class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUE_H\n#define LLVM_IR_VALUE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <iterator>\n#include <memory>\n\nnamespace llvm {\n\nclass APInt;\nclass Argument;\nclass BasicBlock;\nclass Constant;\nclass ConstantData;\nclass ConstantAggregate;\nclass DataLayout;\nclass Function;\nclass GlobalAlias;\nclass GlobalIFunc;\nclass GlobalIndirectSymbol;\nclass GlobalObject;\nclass GlobalValue;\nclass GlobalVariable;\nclass InlineAsm;\nclass Instruction;\nclass LLVMContext;\nclass MDNode;\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\ntemplate<typename ValueTy> class StringMapEntry;\nclass Twine;\nclass Type;\nclass User;\n\nusing ValueName = StringMapEntry<Value *>;\n\n//===----------------------------------------------------------------------===//\n//                                 Value Class\n//===----------------------------------------------------------------------===//\n\n/// LLVM Value Representation\n///\n/// This is a very important LLVM class. It is the base class of all values\n/// computed by a program that may be used as operands to other values. Value is\n/// the super class of other important classes such as Instruction and Function.\n/// All Values have a Type. Type is not a subclass of Value. Some values can\n/// have a name and they belong to some Module.  Setting the name on the Value\n/// automatically updates the module's symbol table.\n///\n/// Every value has a \"use list\" that keeps track of which other Values are\n/// using this Value.  A Value can also have an arbitrary number of ValueHandle\n/// objects that watch it and listen to RAUW and Destroy events.  See\n/// llvm/IR/ValueHandle.h for details.\nclass Value {\n  Type *VTy;\n  Use *UseList;\n\n  friend class ValueAsMetadata; // Allow access to IsUsedByMD.\n  friend class ValueHandleBase;\n\n  const unsigned char SubclassID;   // Subclass identifier (for isa/dyn_cast)\n  unsigned char HasValueHandle : 1; // Has a ValueHandle pointing to this?\n\nprotected:\n  /// Hold subclass data that can be dropped.\n  ///\n  /// This member is similar to SubclassData, however it is for holding\n  /// information which may be used to aid optimization, but which may be\n  /// cleared to zero without affecting conservative interpretation.\n  unsigned char SubclassOptionalData : 7;\n\nprivate:\n  /// Hold arbitrary subclass data.\n  ///\n  /// This member is defined by this class, but is not used for anything.\n  /// Subclasses can use it to hold whatever state they find useful.  This\n  /// field is initialized to zero by the ctor.\n  unsigned short SubclassData;\n\nprotected:\n  /// The number of operands in the subclass.\n  ///\n  /// This member is defined by this class, but not used for anything.\n  /// Subclasses can use it to store their number of operands, if they have\n  /// any.\n  ///\n  /// This is stored here to save space in User on 64-bit hosts.  Since most\n  /// instances of Value have operands, 32-bit hosts aren't significantly\n  /// affected.\n  ///\n  /// Note, this should *NOT* be used directly by any class other than User.\n  /// User uses this value to find the Use list.\n  enum : unsigned { NumUserOperandsBits = 27 };\n  unsigned NumUserOperands : NumUserOperandsBits;\n\n  // Use the same type as the bitfield above so that MSVC will pack them.\n  unsigned IsUsedByMD : 1;\n  unsigned HasName : 1;\n  unsigned HasMetadata : 1; // Has metadata attached to this?\n  unsigned HasHungOffUses : 1;\n  unsigned HasDescriptor : 1;\n\nprivate:\n  template <typename UseT> // UseT == 'Use' or 'const Use'\n  class use_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UseT *> {\n    friend class Value;\n\n    UseT *U;\n\n    explicit use_iterator_impl(UseT *u) : U(u) {}\n\n  public:\n    use_iterator_impl() : U() {}\n\n    bool operator==(const use_iterator_impl &x) const { return U == x.U; }\n    bool operator!=(const use_iterator_impl &x) const { return !operator==(x); }\n\n    use_iterator_impl &operator++() { // Preincrement\n      assert(U && \"Cannot increment end iterator!\");\n      U = U->getNext();\n      return *this;\n    }\n\n    use_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    UseT &operator*() const {\n      assert(U && \"Cannot dereference end iterator!\");\n      return *U;\n    }\n\n    UseT *operator->() const { return &operator*(); }\n\n    operator use_iterator_impl<const UseT>() const {\n      return use_iterator_impl<const UseT>(U);\n    }\n  };\n\n  template <typename UserTy> // UserTy == 'User' or 'const User'\n  class user_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UserTy *> {\n    use_iterator_impl<Use> UI;\n    explicit user_iterator_impl(Use *U) : UI(U) {}\n    friend class Value;\n\n  public:\n    user_iterator_impl() = default;\n\n    bool operator==(const user_iterator_impl &x) const { return UI == x.UI; }\n    bool operator!=(const user_iterator_impl &x) const { return !operator==(x); }\n\n    /// Returns true if this iterator is equal to user_end() on the value.\n    bool atEnd() const { return *this == user_iterator_impl(); }\n\n    user_iterator_impl &operator++() { // Preincrement\n      ++UI;\n      return *this;\n    }\n\n    user_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Retrieve a pointer to the current User.\n    UserTy *operator*() const {\n      return UI->getUser();\n    }\n\n    UserTy *operator->() const { return operator*(); }\n\n    operator user_iterator_impl<const UserTy>() const {\n      return user_iterator_impl<const UserTy>(*UI);\n    }\n\n    Use &getUse() const { return *UI; }\n  };\n\nprotected:\n  Value(Type *Ty, unsigned scid);\n\n  /// Value's destructor should be virtual by design, but that would require\n  /// that Value and all of its subclasses have a vtable that effectively\n  /// duplicates the information in the value ID. As a size optimization, the\n  /// destructor has been protected, and the caller should manually call\n  /// deleteValue.\n  ~Value(); // Use deleteValue() to delete a generic Value.\n\npublic:\n  Value(const Value &) = delete;\n  Value &operator=(const Value &) = delete;\n\n  /// Delete a pointer to a generic Value.\n  void deleteValue();\n\n  /// Support for debugging, callable in GDB: V->dump()\n  void dump() const;\n\n  /// Implement operator<< on Value.\n  /// @{\n  void print(raw_ostream &O, bool IsForDebug = false) const;\n  void print(raw_ostream &O, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print the name of this Value out to the specified raw_ostream.\n  ///\n  /// This is useful when you just want to print 'int %reg126', not the\n  /// instruction that generated it. If you specify a Module for context, then\n  /// even constanst get pretty-printed; for example, the type of a null\n  /// pointer is printed symbolically.\n  /// @{\n  void printAsOperand(raw_ostream &O, bool PrintType = true,\n                      const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &O, bool PrintType,\n                      ModuleSlotTracker &MST) const;\n  /// @}\n\n  /// All values are typed, get the type of this value.\n  Type *getType() const { return VTy; }\n\n  /// All values hold a context through their type.\n  LLVMContext &getContext() const;\n\n  // All values can potentially be named.\n  bool hasName() const { return HasName; }\n  ValueName *getValueName() const;\n  void setValueName(ValueName *VN);\n\nprivate:\n  void destroyValueName();\n  enum class ReplaceMetadataUses { No, Yes };\n  void doRAUW(Value *New, ReplaceMetadataUses);\n  void setNameImpl(const Twine &Name);\n\npublic:\n  /// Return a constant reference to the value's name.\n  ///\n  /// This guaranteed to return the same reference as long as the value is not\n  /// modified.  If the value has a name, this does a hashtable lookup, so it's\n  /// not free.\n  StringRef getName() const;\n\n  /// Change the name of the value.\n  ///\n  /// Choose a new unique name if the provided name is taken.\n  ///\n  /// \\param Name The new name; or \"\" if the value's name should be removed.\n  void setName(const Twine &Name);\n\n  /// Transfer the name from V to this value.\n  ///\n  /// After taking V's name, sets V's name to empty.\n  ///\n  /// \\note It is an error to call V->takeName(V).\n  void takeName(Value *V);\n\n#ifndef NDEBUG\n  std::string getNameOrAsOperand() const;\n#endif\n\n  /// Change all uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\".  After this completes, 'this's use list is\n  /// guaranteed to be empty.\n  void replaceAllUsesWith(Value *V);\n\n  /// Change non-metadata uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\". This function skips metadata entries in the list.\n  void replaceNonMetadataUsesWith(Value *V);\n\n  /// Go through the uses list for this definition and make each use point\n  /// to \"V\" if the callback ShouldReplace returns true for the given Use.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesWithIf(Value *New,\n                         llvm::function_ref<bool(Use &U)> ShouldReplace) {\n    assert(New && \"Value::replaceUsesWithIf(<null>) is invalid!\");\n    assert(New->getType() == getType() &&\n           \"replaceUses of value with new value of different type!\");\n\n    for (use_iterator UI = use_begin(), E = use_end(); UI != E;) {\n      Use &U = *UI;\n      ++UI;\n      if (!ShouldReplace(U))\n        continue;\n      U.set(New);\n    }\n  }\n\n  /// replaceUsesOutsideBlock - Go through the uses list for this definition and\n  /// make each use point to \"V\" instead of \"this\" when the use is outside the\n  /// block. 'This's use list is expected to have at least one element.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesOutsideBlock(Value *V, BasicBlock *BB);\n\n  //----------------------------------------------------------------------\n  // Methods for handling the chain of uses of this Value.\n  //\n  // Materializing a function can introduce new uses, so these methods come in\n  // two variants:\n  // The methods that start with materialized_ check the uses that are\n  // currently known given which functions are materialized. Be very careful\n  // when using them since you might not get all uses.\n  // The methods that don't start with materialized_ assert that modules is\n  // fully materialized.\n  void assertModuleIsMaterializedImpl() const;\n  // This indirection exists so we can keep assertModuleIsMaterializedImpl()\n  // around in release builds of Value.cpp to be linked with other code built\n  // in debug mode. But this avoids calling it in any of the release built code.\n  void assertModuleIsMaterialized() const {\n#ifndef NDEBUG\n    assertModuleIsMaterializedImpl();\n#endif\n  }\n\n  bool use_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  bool materialized_use_empty() const {\n    return UseList == nullptr;\n  }\n\n  using use_iterator = use_iterator_impl<Use>;\n  using const_use_iterator = use_iterator_impl<const Use>;\n\n  use_iterator materialized_use_begin() { return use_iterator(UseList); }\n  const_use_iterator materialized_use_begin() const {\n    return const_use_iterator(UseList);\n  }\n  use_iterator use_begin() {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  const_use_iterator use_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  use_iterator use_end() { return use_iterator(); }\n  const_use_iterator use_end() const { return const_use_iterator(); }\n  iterator_range<use_iterator> materialized_uses() {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<const_use_iterator> materialized_uses() const {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<use_iterator> uses() {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n  iterator_range<const_use_iterator> uses() const {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n\n  bool user_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  using user_iterator = user_iterator_impl<User>;\n  using const_user_iterator = user_iterator_impl<const User>;\n\n  user_iterator materialized_user_begin() { return user_iterator(UseList); }\n  const_user_iterator materialized_user_begin() const {\n    return const_user_iterator(UseList);\n  }\n  user_iterator user_begin() {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  const_user_iterator user_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  user_iterator user_end() { return user_iterator(); }\n  const_user_iterator user_end() const { return const_user_iterator(); }\n  User *user_back() {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  const User *user_back() const {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  iterator_range<user_iterator> materialized_users() {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<const_user_iterator> materialized_users() const {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<user_iterator> users() {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n  iterator_range<const_user_iterator> users() const {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n\n  /// Return true if there is exactly one use of this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasOneUse() const { return hasSingleElement(uses()); }\n\n  /// Return true if this Value has exactly N uses.\n  bool hasNUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUsesOrMore(unsigned N) const;\n\n  /// Return true if there is exactly one user of this value.\n  ///\n  /// Note that this is not the same as \"has one use\". If a value has one use,\n  /// then there certainly is a single user. But if value has several uses,\n  /// it is possible that all uses are in a single user, or not.\n  ///\n  /// This check is potentially costly, since it requires traversing,\n  /// in the worst case, the whole use list of a value.\n  bool hasOneUser() const;\n\n  /// Return true if there is exactly one use of this value that cannot be\n  /// dropped.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  Use *getSingleUndroppableUse();\n  const Use *getSingleUndroppableUse() const {\n    return const_cast<Value *>(this)->getSingleUndroppableUse();\n  }\n\n  /// Return true if there this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasNUndroppableUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUndroppableUsesOrMore(unsigned N) const;\n\n  /// Remove every uses that can safely be removed.\n  ///\n  /// This will remove for example uses in llvm.assume.\n  /// This should be used when performing want to perform a tranformation but\n  /// some Droppable uses pervent it.\n  /// This function optionally takes a filter to only remove some droppable\n  /// uses.\n  void dropDroppableUses(llvm::function_ref<bool(const Use *)> ShouldDrop =\n                             [](const Use *) { return true; });\n\n  /// Remove every use of this value in \\p User that can safely be removed.\n  void dropDroppableUsesIn(User &Usr);\n\n  /// Remove the droppable use \\p U.\n  static void dropDroppableUse(Use &U);\n\n  /// Check if this value is used in the specified basic block.\n  bool isUsedInBasicBlock(const BasicBlock *BB) const;\n\n  /// This method computes the number of uses of this Value.\n  ///\n  /// This is a linear time operation.  Use hasOneUse, hasNUses, or\n  /// hasNUsesOrMore to check for specific values.\n  unsigned getNumUses() const;\n\n  /// This method should only be used by the Use class.\n  void addUse(Use &U) { U.addToList(&UseList); }\n\n  /// Concrete subclass of this.\n  ///\n  /// An enumeration for keeping track of the concrete subclass of Value that\n  /// is actually instantiated. Values of this enumeration are kept in the\n  /// Value classes SubclassID field. They are used for concrete type\n  /// identification.\n  enum ValueTy {\n#define HANDLE_VALUE(Name) Name##Val,\n#include \"llvm/IR/Value.def\"\n\n    // Markers:\n#define HANDLE_CONSTANT_MARKER(Marker, Constant) Marker = Constant##Val,\n#include \"llvm/IR/Value.def\"\n  };\n\n  /// Return an ID for the concrete type of this object.\n  ///\n  /// This is used to implement the classof checks.  This should not be used\n  /// for any other purpose, as the values may change as LLVM evolves.  Also,\n  /// note that for instructions, the Instruction's opcode is added to\n  /// InstructionVal. So this means three things:\n  /// # there is no value with code InstructionVal (no opcode==0).\n  /// # there are more possible values for the value type than in ValueTy enum.\n  /// # the InstructionVal enumerator must be the highest valued enumerator in\n  ///   the ValueTy enum.\n  unsigned getValueID() const {\n    return SubclassID;\n  }\n\n  /// Return the raw optional flags value contained in this value.\n  ///\n  /// This should only be used when testing two Values for equivalence.\n  unsigned getRawSubclassOptionalData() const {\n    return SubclassOptionalData;\n  }\n\n  /// Clear the optional flags contained in this value.\n  void clearSubclassOptionalData() {\n    SubclassOptionalData = 0;\n  }\n\n  /// Check the optional flags for equality.\n  bool hasSameSubclassOptionalData(const Value *V) const {\n    return SubclassOptionalData == V->SubclassOptionalData;\n  }\n\n  /// Return true if there is a value handle associated with this value.\n  bool hasValueHandle() const { return HasValueHandle; }\n\n  /// Return true if there is metadata referencing this value.\n  bool isUsedByMetadata() const { return IsUsedByMD; }\n\nprotected:\n  /// Get the current metadata attachments for the given kind, if any.\n  ///\n  /// These functions require that the value have at most a single attachment\n  /// of the given kind, and return \\c nullptr if such an attachment is missing.\n  /// @{\n  MDNode *getMetadata(unsigned KindID) const;\n  MDNode *getMetadata(StringRef Kind) const;\n  /// @}\n\n  /// Appends all attachments with the given ID to \\c MDs in insertion order.\n  /// If the Value has no attachments with the given ID, or if ID is invalid,\n  /// leaves MDs unchanged.\n  /// @{\n  void getMetadata(unsigned KindID, SmallVectorImpl<MDNode *> &MDs) const;\n  void getMetadata(StringRef Kind, SmallVectorImpl<MDNode *> &MDs) const;\n  /// @}\n\n  /// Appends all metadata attached to this value to \\c MDs, sorting by\n  /// KindID. The first element of each pair returned is the KindID, the second\n  /// element is the metadata value. Attachments with the same ID appear in\n  /// insertion order.\n  void\n  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const;\n\n  /// Return true if this value has any metadata attached to it.\n  bool hasMetadata() const { return (bool)HasMetadata; }\n\n  /// Return true if this value has the given type of metadata attached.\n  /// @{\n  bool hasMetadata(unsigned KindID) const {\n    return getMetadata(KindID) != nullptr;\n  }\n  bool hasMetadata(StringRef Kind) const {\n    return getMetadata(Kind) != nullptr;\n  }\n  /// @}\n\n  /// Set a particular kind of metadata attachment.\n  ///\n  /// Sets the given attachment to \\c MD, erasing it if \\c MD is \\c nullptr or\n  /// replacing it if it already exists.\n  /// @{\n  void setMetadata(unsigned KindID, MDNode *Node);\n  void setMetadata(StringRef Kind, MDNode *Node);\n  /// @}\n\n  /// Add a metadata attachment.\n  /// @{\n  void addMetadata(unsigned KindID, MDNode &MD);\n  void addMetadata(StringRef Kind, MDNode &MD);\n  /// @}\n\n  /// Erase all metadata attachments with the given kind.\n  ///\n  /// \\returns true if any metadata was removed.\n  bool eraseMetadata(unsigned KindID);\n\n  /// Erase all metadata attached to this Value.\n  void clearMetadata();\n\npublic:\n  /// Return true if this value is a swifterror value.\n  ///\n  /// swifterror values can be either a function argument or an alloca with a\n  /// swifterror attribute.\n  bool isSwiftError() const;\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCasts() const;\n  Value *stripPointerCasts() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCasts());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, address space casts, and aliases.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCastsAndAliases() const;\n  Value *stripPointerCastsAndAliases() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCastsAndAliases());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts\n  /// but ensures the representation of the result stays the same.\n  ///\n  /// Returns the original uncasted value with the same representation. If this\n  /// is called on a non-pointer value, it returns 'this'.\n  const Value *stripPointerCastsSameRepresentation() const;\n  Value *stripPointerCastsSameRepresentation() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsSameRepresentation());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, single-argument phi nodes and\n  /// invariant group info.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'. This function should be used only in\n  /// Alias analysis.\n  const Value *stripPointerCastsForAliasAnalysis() const;\n  Value *stripPointerCastsForAliasAnalysis() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsForAliasAnalysis());\n  }\n\n  /// Strip off pointer casts and all-constant inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsConstantOffsets() const;\n  Value *stripInBoundsConstantOffsets() {\n    return const_cast<Value *>(\n              static_cast<const Value *>(this)->stripInBoundsConstantOffsets());\n  }\n\n  /// Accumulate the constant offset this value has compared to a base pointer.\n  /// Only 'getelementptr' instructions (GEPs) are accumulated but other\n  /// instructions, e.g., casts, are stripped away as well.\n  /// The accumulated constant offset is added to \\p Offset and the base\n  /// pointer is returned.\n  ///\n  /// The APInt \\p Offset has to have a bit-width equal to the IntPtr type for\n  /// the address space of 'this' pointer value, e.g., use\n  /// DataLayout::getIndexTypeSizeInBits(Ty).\n  ///\n  /// If \\p AllowNonInbounds is true, offsets in GEPs are stripped and\n  /// accumulated even if the GEP is not \"inbounds\".\n  ///\n  /// If \\p ExternalAnalysis is provided it will be used to calculate a offset\n  /// when a operand of GEP is not constant.\n  /// For example, for a value \\p ExternalAnalysis might try to calculate a\n  /// lower bound. If \\p ExternalAnalysis is successful, it should return true.\n  ///\n  /// If this is called on a non-pointer value, it returns 'this' and the\n  /// \\p Offset is not modified.\n  ///\n  /// Note that this function will never return a nullptr. It will also never\n  /// manipulate the \\p Offset in a way that would not match the difference\n  /// between the underlying value and the returned one. Thus, if no constant\n  /// offset was found, the returned value is the underlying one and \\p Offset\n  /// is unchanged.\n  const Value *stripAndAccumulateConstantOffsets(\n      const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,\n      function_ref<bool(Value &Value, APInt &Offset)> ExternalAnalysis =\n          nullptr) const;\n  Value *stripAndAccumulateConstantOffsets(const DataLayout &DL, APInt &Offset,\n                                           bool AllowNonInbounds) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripAndAccumulateConstantOffsets(\n            DL, Offset, AllowNonInbounds));\n  }\n\n  /// This is a wrapper around stripAndAccumulateConstantOffsets with the\n  /// in-bounds requirement set to false.\n  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                         APInt &Offset) const {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                   APInt &Offset) {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n\n  /// Strip off pointer casts and inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                        [](const Value *) {}) const;\n  inline Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                  [](const Value *) {}) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripInBoundsOffsets(Func));\n  }\n\n  /// Returns the number of bytes known to be dereferenceable for the\n  /// pointer value.\n  ///\n  /// If CanBeNull is set by this function the pointer can either be null or be\n  /// dereferenceable up to the returned number of bytes.\n  uint64_t getPointerDereferenceableBytes(const DataLayout &DL,\n                                          bool &CanBeNull) const;\n\n  /// Returns an alignment of the pointer value.\n  ///\n  /// Returns an alignment which is either specified explicitly, e.g. via\n  /// align attribute of a function argument, or guaranteed by DataLayout.\n  Align getPointerAlignment(const DataLayout &DL) const;\n\n  /// Translate PHI node to its predecessor from the given basic block.\n  ///\n  /// If this value is a PHI node with CurBB as its parent, return the value in\n  /// the PHI node corresponding to PredBB.  If not, return ourself.  This is\n  /// useful if you want to know the value something has in a predecessor\n  /// block.\n  const Value *DoPHITranslation(const BasicBlock *CurBB,\n                                const BasicBlock *PredBB) const;\n  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB) {\n    return const_cast<Value *>(\n             static_cast<const Value *>(this)->DoPHITranslation(CurBB, PredBB));\n  }\n\n  /// The maximum alignment for instructions.\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  /// Mutate the type of this Value to be of the specified type.\n  ///\n  /// Note that this is an extremely dangerous operation which can create\n  /// completely invalid IR very easily.  It is strongly recommended that you\n  /// recreate IR objects with the right types instead of mutating them in\n  /// place.\n  void mutateType(Type *Ty) {\n    VTy = Ty;\n  }\n\n  /// Sort the use-list.\n  ///\n  /// Sorts the Value's use-list by Cmp using a stable mergesort.  Cmp is\n  /// expected to compare two \\a Use references.\n  template <class Compare> void sortUseList(Compare Cmp);\n\n  /// Reverse the use-list.\n  void reverseUseList();\n\nprivate:\n  /// Merge two lists together.\n  ///\n  /// Merges \\c L and \\c R using \\c Cmp.  To enable stable sorts, always pushes\n  /// \"equal\" items from L before items from R.\n  ///\n  /// \\return the first element in the list.\n  ///\n  /// \\note Completely ignores \\a Use::Prev (doesn't read, doesn't update).\n  template <class Compare>\n  static Use *mergeUseLists(Use *L, Use *R, Compare Cmp) {\n    Use *Merged;\n    Use **Next = &Merged;\n\n    while (true) {\n      if (!L) {\n        *Next = R;\n        break;\n      }\n      if (!R) {\n        *Next = L;\n        break;\n      }\n      if (Cmp(*R, *L)) {\n        *Next = R;\n        Next = &R->Next;\n        R = R->Next;\n      } else {\n        *Next = L;\n        Next = &L->Next;\n        L = L->Next;\n      }\n    }\n\n    return Merged;\n  }\n\nprotected:\n  unsigned short getSubclassDataFromValue() const { return SubclassData; }\n  void setValueSubclassData(unsigned short D) { SubclassData = D; }\n};\n\nstruct ValueDeleter { void operator()(Value *V) { V->deleteValue(); } };\n\n/// Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.\n/// Those don't work because Value and Instruction's destructors are protected,\n/// aren't virtual, and won't destroy the complete object.\nusing unique_value = std::unique_ptr<Value, ValueDeleter>;\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {\n  V.print(OS);\n  return OS;\n}\n\nvoid Use::set(Value *V) {\n  if (Val) removeFromList();\n  Val = V;\n  if (V) V->addUse(*this);\n}\n\nValue *Use::operator=(Value *RHS) {\n  set(RHS);\n  return RHS;\n}\n\nconst Use &Use::operator=(const Use &RHS) {\n  set(RHS.Val);\n  return *this;\n}\n\ntemplate <class Compare> void Value::sortUseList(Compare Cmp) {\n  if (!UseList || !UseList->Next)\n    // No need to sort 0 or 1 uses.\n    return;\n\n  // Note: this function completely ignores Prev pointers until the end when\n  // they're fixed en masse.\n\n  // Create a binomial vector of sorted lists, visiting uses one at a time and\n  // merging lists as necessary.\n  const unsigned MaxSlots = 32;\n  Use *Slots[MaxSlots];\n\n  // Collect the first use, turning it into a single-item list.\n  Use *Next = UseList->Next;\n  UseList->Next = nullptr;\n  unsigned NumSlots = 1;\n  Slots[0] = UseList;\n\n  // Collect all but the last use.\n  while (Next->Next) {\n    Use *Current = Next;\n    Next = Current->Next;\n\n    // Turn Current into a single-item list.\n    Current->Next = nullptr;\n\n    // Save Current in the first available slot, merging on collisions.\n    unsigned I;\n    for (I = 0; I < NumSlots; ++I) {\n      if (!Slots[I])\n        break;\n\n      // Merge two lists, doubling the size of Current and emptying slot I.\n      //\n      // Since the uses in Slots[I] originally preceded those in Current, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      Current = mergeUseLists(Slots[I], Current, Cmp);\n      Slots[I] = nullptr;\n    }\n    // Check if this is a new slot.\n    if (I == NumSlots) {\n      ++NumSlots;\n      assert(NumSlots <= MaxSlots && \"Use list bigger than 2^32\");\n    }\n\n    // Found an open slot.\n    Slots[I] = Current;\n  }\n\n  // Merge all the lists together.\n  assert(Next && \"Expected one more Use\");\n  assert(!Next->Next && \"Expected only one Use\");\n  UseList = Next;\n  for (unsigned I = 0; I < NumSlots; ++I)\n    if (Slots[I])\n      // Since the uses in Slots[I] originally preceded those in UseList, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      UseList = mergeUseLists(Slots[I], UseList, Cmp);\n\n  // Fix the Prev pointers.\n  for (Use *I = UseList, **Prev = &UseList; I; I = I->Next) {\n    I->Prev = Prev;\n    Prev = &I->Next;\n  }\n}\n\n// isa - Provide some specializations of isa so that we don't have to include\n// the subtype header files to test to see if the value is a subclass...\n//\ntemplate <> struct isa_impl<Constant, Value> {\n  static inline bool doit(const Value &Val) {\n    static_assert(Value::ConstantFirstVal == 0, \"Val.getValueID() >= Value::ConstantFirstVal\");\n    return Val.getValueID() <= Value::ConstantLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantData, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantDataFirstVal &&\n           Val.getValueID() <= Value::ConstantDataLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantAggregate, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantAggregateFirstVal &&\n           Val.getValueID() <= Value::ConstantAggregateLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<Argument, Value> {\n  static inline bool doit (const Value &Val) {\n    return Val.getValueID() == Value::ArgumentVal;\n  }\n};\n\ntemplate <> struct isa_impl<InlineAsm, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::InlineAsmVal;\n  }\n};\n\ntemplate <> struct isa_impl<Instruction, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::InstructionVal;\n  }\n};\n\ntemplate <> struct isa_impl<BasicBlock, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::BasicBlockVal;\n  }\n};\n\ntemplate <> struct isa_impl<Function, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::FunctionVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalVariable, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalVariableVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalAlias, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalAliasVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIFunc, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalIFuncVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIndirectSymbol, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalAlias>(Val) || isa<GlobalIFunc>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalValue, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalObject>(Val) || isa<GlobalIndirectSymbol>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalObject, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalVariable>(Val) || isa<Function>(Val);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef)\n\n// Specialized opaque value conversions.\ninline Value **unwrap(LLVMValueRef *Vals) {\n  return reinterpret_cast<Value**>(Vals);\n}\n\ntemplate<typename T>\ninline T **unwrap(LLVMValueRef *Vals, unsigned Length) {\n#ifndef NDEBUG\n  for (LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I)\n    unwrap<T>(*I); // For side effect of calling assert on invalid usage.\n#endif\n  (void)Length;\n  return reinterpret_cast<T**>(Vals);\n}\n\ninline LLVMValueRef *wrap(const Value **Vals) {\n  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUE_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "content": "//===- ValueHandle.h - Value Smart Pointer classes --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ValueHandle class and its sub-classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUEHANDLE_H\n#define LLVM_IR_VALUEHANDLE_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// This is the common base class of value handles.\n///\n/// ValueHandle's are smart pointers to Value's that have special behavior when\n/// the value is deleted or ReplaceAllUsesWith'd.  See the specific handles\n/// below for details.\nclass ValueHandleBase {\n  friend class Value;\n\nprotected:\n  /// This indicates what sub class the handle actually is.\n  ///\n  /// This is to avoid having a vtable for the light-weight handle pointers. The\n  /// fully general Callback version does have a vtable.\n  enum HandleBaseKind { Assert, Callback, Weak, WeakTracking };\n\n  ValueHandleBase(const ValueHandleBase &RHS)\n      : ValueHandleBase(RHS.PrevPair.getInt(), RHS) {}\n\n  ValueHandleBase(HandleBaseKind Kind, const ValueHandleBase &RHS)\n      : PrevPair(nullptr, Kind), Val(RHS.getValPtr()) {\n    if (isValid(getValPtr()))\n      AddToExistingUseList(RHS.getPrevPtr());\n  }\n\nprivate:\n  PointerIntPair<ValueHandleBase**, 2, HandleBaseKind> PrevPair;\n  ValueHandleBase *Next = nullptr;\n  Value *Val = nullptr;\n\n  void setValPtr(Value *V) { Val = V; }\n\npublic:\n  explicit ValueHandleBase(HandleBaseKind Kind)\n      : PrevPair(nullptr, Kind) {}\n  ValueHandleBase(HandleBaseKind Kind, Value *V)\n      : PrevPair(nullptr, Kind), Val(V) {\n    if (isValid(getValPtr()))\n      AddToUseList();\n  }\n\n  ~ValueHandleBase() {\n    if (isValid(getValPtr()))\n      RemoveFromUseList();\n  }\n\n  Value *operator=(Value *RHS) {\n    if (getValPtr() == RHS)\n      return RHS;\n    if (isValid(getValPtr()))\n      RemoveFromUseList();\n    setValPtr(RHS);\n    if (isValid(getValPtr()))\n      AddToUseList();\n    return RHS;\n  }\n\n  Value *operator=(const ValueHandleBase &RHS) {\n    if (getValPtr() == RHS.getValPtr())\n      return RHS.getValPtr();\n    if (isValid(getValPtr()))\n      RemoveFromUseList();\n    setValPtr(RHS.getValPtr());\n    if (isValid(getValPtr()))\n      AddToExistingUseList(RHS.getPrevPtr());\n    return getValPtr();\n  }\n\n  Value *operator->() const { return getValPtr(); }\n  Value &operator*() const {\n    Value *V = getValPtr();\n    assert(V && \"Dereferencing deleted ValueHandle\");\n    return *V;\n  }\n\nprotected:\n  Value *getValPtr() const { return Val; }\n\n  static bool isValid(Value *V) {\n    return V &&\n           V != DenseMapInfo<Value *>::getEmptyKey() &&\n           V != DenseMapInfo<Value *>::getTombstoneKey();\n  }\n\n  /// Remove this ValueHandle from its current use list.\n  void RemoveFromUseList();\n\n  /// Clear the underlying pointer without clearing the use list.\n  ///\n  /// This should only be used if a derived class has manually removed the\n  /// handle from the use list.\n  void clearValPtr() { setValPtr(nullptr); }\n\npublic:\n  // Callbacks made from Value.\n  static void ValueIsDeleted(Value *V);\n  static void ValueIsRAUWd(Value *Old, Value *New);\n\nprivate:\n  // Internal implementation details.\n  ValueHandleBase **getPrevPtr() const { return PrevPair.getPointer(); }\n  HandleBaseKind getKind() const { return PrevPair.getInt(); }\n  void setPrevPtr(ValueHandleBase **Ptr) { PrevPair.setPointer(Ptr); }\n\n  /// Add this ValueHandle to the use list for V.\n  ///\n  /// List is the address of either the head of the list or a Next node within\n  /// the existing use list.\n  void AddToExistingUseList(ValueHandleBase **List);\n\n  /// Add this ValueHandle to the use list after Node.\n  void AddToExistingUseListAfter(ValueHandleBase *Node);\n\n  /// Add this ValueHandle to the use list for V.\n  void AddToUseList();\n};\n\n/// A nullable Value handle that is nullable.\n///\n/// This is a value handle that points to a value, and nulls itself\n/// out if that value is deleted.\nclass WeakVH : public ValueHandleBase {\npublic:\n  WeakVH() : ValueHandleBase(Weak) {}\n  WeakVH(Value *P) : ValueHandleBase(Weak, P) {}\n  WeakVH(const WeakVH &RHS)\n      : ValueHandleBase(Weak, RHS) {}\n\n  WeakVH &operator=(const WeakVH &RHS) = default;\n\n  Value *operator=(Value *RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n  Value *operator=(const ValueHandleBase &RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n\n  operator Value*() const {\n    return getValPtr();\n  }\n};\n\n// Specialize simplify_type to allow WeakVH to participate in\n// dyn_cast, isa, etc.\ntemplate <> struct simplify_type<WeakVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(WeakVH &WVH) { return WVH; }\n};\ntemplate <> struct simplify_type<const WeakVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(const WeakVH &WVH) { return WVH; }\n};\n\n// Specialize DenseMapInfo to allow WeakVH to participate in DenseMap.\ntemplate <> struct DenseMapInfo<WeakVH> {\n  static inline WeakVH getEmptyKey() {\n    return WeakVH(DenseMapInfo<Value *>::getEmptyKey());\n  }\n\n  static inline WeakVH getTombstoneKey() {\n    return WeakVH(DenseMapInfo<Value *>::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const WeakVH &Val) {\n    return DenseMapInfo<Value *>::getHashValue(Val);\n  }\n\n  static bool isEqual(const WeakVH &LHS, const WeakVH &RHS) {\n    return DenseMapInfo<Value *>::isEqual(LHS, RHS);\n  }\n};\n\n/// Value handle that is nullable, but tries to track the Value.\n///\n/// This is a value handle that tries hard to point to a Value, even across\n/// RAUW operations, but will null itself out if the value is destroyed.  this\n/// is useful for advisory sorts of information, but should not be used as the\n/// key of a map (since the map would have to rearrange itself when the pointer\n/// changes).\nclass WeakTrackingVH : public ValueHandleBase {\npublic:\n  WeakTrackingVH() : ValueHandleBase(WeakTracking) {}\n  WeakTrackingVH(Value *P) : ValueHandleBase(WeakTracking, P) {}\n  WeakTrackingVH(const WeakTrackingVH &RHS)\n      : ValueHandleBase(WeakTracking, RHS) {}\n\n  WeakTrackingVH &operator=(const WeakTrackingVH &RHS) = default;\n\n  Value *operator=(Value *RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n  Value *operator=(const ValueHandleBase &RHS) {\n    return ValueHandleBase::operator=(RHS);\n  }\n\n  operator Value*() const {\n    return getValPtr();\n  }\n\n  bool pointsToAliveValue() const {\n    return ValueHandleBase::isValid(getValPtr());\n  }\n};\n\n// Specialize simplify_type to allow WeakTrackingVH to participate in\n// dyn_cast, isa, etc.\ntemplate <> struct simplify_type<WeakTrackingVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(WeakTrackingVH &WVH) { return WVH; }\n};\ntemplate <> struct simplify_type<const WeakTrackingVH> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(const WeakTrackingVH &WVH) {\n    return WVH;\n  }\n};\n\n/// Value handle that asserts if the Value is deleted.\n///\n/// This is a Value Handle that points to a value and asserts out if the value\n/// is destroyed while the handle is still live.  This is very useful for\n/// catching dangling pointer bugs and other things which can be non-obvious.\n/// One particularly useful place to use this is as the Key of a map.  Dangling\n/// pointer bugs often lead to really subtle bugs that only occur if another\n/// object happens to get allocated to the same address as the old one.  Using\n/// an AssertingVH ensures that an assert is triggered as soon as the bad\n/// delete occurs.\n///\n/// Note that an AssertingVH handle does *not* follow values across RAUW\n/// operations.  This means that RAUW's need to explicitly update the\n/// AssertingVH's as it moves.  This is required because in non-assert mode this\n/// class turns into a trivial wrapper around a pointer.\ntemplate <typename ValueTy>\nclass AssertingVH\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    : public ValueHandleBase\n#endif\n{\n  friend struct DenseMapInfo<AssertingVH<ValueTy>>;\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  Value *getRawValPtr() const { return ValueHandleBase::getValPtr(); }\n  void setRawValPtr(Value *P) { ValueHandleBase::operator=(P); }\n#else\n  Value *ThePtr;\n  Value *getRawValPtr() const { return ThePtr; }\n  void setRawValPtr(Value *P) { ThePtr = P; }\n#endif\n  // Convert a ValueTy*, which may be const, to the raw Value*.\n  static Value *GetAsValue(Value *V) { return V; }\n  static Value *GetAsValue(const Value *V) { return const_cast<Value*>(V); }\n\n  ValueTy *getValPtr() const { return static_cast<ValueTy *>(getRawValPtr()); }\n  void setValPtr(ValueTy *P) { setRawValPtr(GetAsValue(P)); }\n\npublic:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  AssertingVH() : ValueHandleBase(Assert) {}\n  AssertingVH(ValueTy *P) : ValueHandleBase(Assert, GetAsValue(P)) {}\n  AssertingVH(const AssertingVH &RHS) : ValueHandleBase(Assert, RHS) {}\n#else\n  AssertingVH() : ThePtr(nullptr) {}\n  AssertingVH(ValueTy *P) : ThePtr(GetAsValue(P)) {}\n  AssertingVH(const AssertingVH &) = default;\n#endif\n\n  operator ValueTy*() const {\n    return getValPtr();\n  }\n\n  ValueTy *operator=(ValueTy *RHS) {\n    setValPtr(RHS);\n    return getValPtr();\n  }\n  ValueTy *operator=(const AssertingVH<ValueTy> &RHS) {\n    setValPtr(RHS.getValPtr());\n    return getValPtr();\n  }\n\n  ValueTy *operator->() const { return getValPtr(); }\n  ValueTy &operator*() const { return *getValPtr(); }\n};\n\n// Treat AssertingVH<T> like T* inside maps. This also allows using find_as()\n// to look up a value without constructing a value handle.\ntemplate<typename T>\nstruct DenseMapInfo<AssertingVH<T>> : DenseMapInfo<T *> {};\n\n/// Value handle that tracks a Value across RAUW.\n///\n/// TrackingVH is designed for situations where a client needs to hold a handle\n/// to a Value (or subclass) across some operations which may move that value,\n/// but should never destroy it or replace it with some unacceptable type.\n///\n/// It is an error to attempt to replace a value with one of a type which is\n/// incompatible with any of its outstanding TrackingVHs.\n///\n/// It is an error to read from a TrackingVH that does not point to a valid\n/// value.  A TrackingVH is said to not point to a valid value if either it\n/// hasn't yet been assigned a value yet or because the value it was tracking\n/// has since been deleted.\n///\n/// Assigning a value to a TrackingVH is always allowed, even if said TrackingVH\n/// no longer points to a valid value.\ntemplate <typename ValueTy> class TrackingVH {\n  WeakTrackingVH InnerHandle;\n\npublic:\n  ValueTy *getValPtr() const {\n    assert(InnerHandle.pointsToAliveValue() &&\n           \"TrackingVH must be non-null and valid on dereference!\");\n\n    // Check that the value is a member of the correct subclass. We would like\n    // to check this property on assignment for better debugging, but we don't\n    // want to require a virtual interface on this VH. Instead we allow RAUW to\n    // replace this value with a value of an invalid type, and check it here.\n    assert(isa<ValueTy>(InnerHandle) &&\n           \"Tracked Value was replaced by one with an invalid type!\");\n    return cast<ValueTy>(InnerHandle);\n  }\n\n  void setValPtr(ValueTy *P) {\n    // Assigning to non-valid TrackingVH's are fine so we just unconditionally\n    // assign here.\n    InnerHandle = GetAsValue(P);\n  }\n\n  // Convert a ValueTy*, which may be const, to the type the base\n  // class expects.\n  static Value *GetAsValue(Value *V) { return V; }\n  static Value *GetAsValue(const Value *V) { return const_cast<Value*>(V); }\n\npublic:\n  TrackingVH() = default;\n  TrackingVH(ValueTy *P) { setValPtr(P); }\n\n  operator ValueTy*() const {\n    return getValPtr();\n  }\n\n  ValueTy *operator=(ValueTy *RHS) {\n    setValPtr(RHS);\n    return getValPtr();\n  }\n\n  ValueTy *operator->() const { return getValPtr(); }\n  ValueTy &operator*() const { return *getValPtr(); }\n};\n\n/// Value handle with callbacks on RAUW and destruction.\n///\n/// This is a value handle that allows subclasses to define callbacks that run\n/// when the underlying Value has RAUW called on it or is destroyed.  This\n/// class can be used as the key of a map, as long as the user takes it out of\n/// the map before calling setValPtr() (since the map has to rearrange itself\n/// when the pointer changes).  Unlike ValueHandleBase, this class has a vtable.\nclass CallbackVH : public ValueHandleBase {\n  virtual void anchor();\nprotected:\n  ~CallbackVH() = default;\n  CallbackVH(const CallbackVH &) = default;\n  CallbackVH &operator=(const CallbackVH &) = default;\n\n  void setValPtr(Value *P) {\n    ValueHandleBase::operator=(P);\n  }\n\npublic:\n  CallbackVH() : ValueHandleBase(Callback) {}\n  CallbackVH(Value *P) : ValueHandleBase(Callback, P) {}\n  CallbackVH(const Value *P) : CallbackVH(const_cast<Value *>(P)) {}\n\n  operator Value*() const {\n    return getValPtr();\n  }\n\n  /// Callback for Value destruction.\n  ///\n  /// Called when this->getValPtr() is destroyed, inside ~Value(), so you\n  /// may call any non-virtual Value method on getValPtr(), but no subclass\n  /// methods.  If WeakTrackingVH were implemented as a CallbackVH, it would use\n  /// this\n  /// method to call setValPtr(NULL).  AssertingVH would use this method to\n  /// cause an assertion failure.\n  ///\n  /// All implementations must remove the reference from this object to the\n  /// Value that's being destroyed.\n  virtual void deleted() { setValPtr(nullptr); }\n\n  /// Callback for Value RAUW.\n  ///\n  /// Called when this->getValPtr()->replaceAllUsesWith(new_value) is called,\n  /// _before_ any of the uses have actually been replaced.  If WeakTrackingVH\n  /// were\n  /// implemented as a CallbackVH, it would use this method to call\n  /// setValPtr(new_value).  AssertingVH would do nothing in this method.\n  virtual void allUsesReplacedWith(Value *) {}\n};\n\n/// Value handle that poisons itself if the Value is deleted.\n///\n/// This is a Value Handle that points to a value and poisons itself if the\n/// value is destroyed while the handle is still live.  This is very useful for\n/// catching dangling pointer bugs where an \\c AssertingVH cannot be used\n/// because the dangling handle needs to outlive the value without ever being\n/// used.\n///\n/// One particularly useful place to use this is as the Key of a map. Dangling\n/// pointer bugs often lead to really subtle bugs that only occur if another\n/// object happens to get allocated to the same address as the old one. Using\n/// a PoisoningVH ensures that an assert is triggered if looking up a new value\n/// in the map finds a handle from the old value.\n///\n/// Note that a PoisoningVH handle does *not* follow values across RAUW\n/// operations. This means that RAUW's need to explicitly update the\n/// PoisoningVH's as it moves. This is required because in non-assert mode this\n/// class turns into a trivial wrapper around a pointer.\ntemplate <typename ValueTy>\nclass PoisoningVH final\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    : public CallbackVH\n#endif\n{\n  friend struct DenseMapInfo<PoisoningVH<ValueTy>>;\n\n  // Convert a ValueTy*, which may be const, to the raw Value*.\n  static Value *GetAsValue(Value *V) { return V; }\n  static Value *GetAsValue(const Value *V) { return const_cast<Value *>(V); }\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  /// A flag tracking whether this value has been poisoned.\n  ///\n  /// On delete and RAUW, we leave the value pointer alone so that as a raw\n  /// pointer it produces the same value (and we fit into the same key of\n  /// a hash table, etc), but we poison the handle so that any top-level usage\n  /// will fail.\n  bool Poisoned = false;\n\n  Value *getRawValPtr() const { return ValueHandleBase::getValPtr(); }\n  void setRawValPtr(Value *P) { ValueHandleBase::operator=(P); }\n\n  /// Handle deletion by poisoning the handle.\n  void deleted() override {\n    assert(!Poisoned && \"Tried to delete an already poisoned handle!\");\n    Poisoned = true;\n    RemoveFromUseList();\n  }\n\n  /// Handle RAUW by poisoning the handle.\n  void allUsesReplacedWith(Value *) override {\n    assert(!Poisoned && \"Tried to RAUW an already poisoned handle!\");\n    Poisoned = true;\n    RemoveFromUseList();\n  }\n#else // LLVM_ENABLE_ABI_BREAKING_CHECKS\n  Value *ThePtr = nullptr;\n\n  Value *getRawValPtr() const { return ThePtr; }\n  void setRawValPtr(Value *P) { ThePtr = P; }\n#endif\n\n  ValueTy *getValPtr() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!Poisoned && \"Accessed a poisoned value handle!\");\n#endif\n    return static_cast<ValueTy *>(getRawValPtr());\n  }\n  void setValPtr(ValueTy *P) { setRawValPtr(GetAsValue(P)); }\n\npublic:\n  PoisoningVH() = default;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  PoisoningVH(ValueTy *P) : CallbackVH(GetAsValue(P)) {}\n  PoisoningVH(const PoisoningVH &RHS)\n      : CallbackVH(RHS), Poisoned(RHS.Poisoned) {}\n\n  ~PoisoningVH() {\n    if (Poisoned)\n      clearValPtr();\n  }\n\n  PoisoningVH &operator=(const PoisoningVH &RHS) {\n    if (Poisoned)\n      clearValPtr();\n    CallbackVH::operator=(RHS);\n    Poisoned = RHS.Poisoned;\n    return *this;\n  }\n#else\n  PoisoningVH(ValueTy *P) : ThePtr(GetAsValue(P)) {}\n#endif\n\n  operator ValueTy *() const { return getValPtr(); }\n\n  ValueTy *operator->() const { return getValPtr(); }\n  ValueTy &operator*() const { return *getValPtr(); }\n};\n\n// Specialize DenseMapInfo to allow PoisoningVH to participate in DenseMap.\ntemplate <typename T> struct DenseMapInfo<PoisoningVH<T>> {\n  static inline PoisoningVH<T> getEmptyKey() {\n    PoisoningVH<T> Res;\n    Res.setRawValPtr(DenseMapInfo<Value *>::getEmptyKey());\n    return Res;\n  }\n\n  static inline PoisoningVH<T> getTombstoneKey() {\n    PoisoningVH<T> Res;\n    Res.setRawValPtr(DenseMapInfo<Value *>::getTombstoneKey());\n    return Res;\n  }\n\n  static unsigned getHashValue(const PoisoningVH<T> &Val) {\n    return DenseMapInfo<Value *>::getHashValue(Val.getRawValPtr());\n  }\n\n  static bool isEqual(const PoisoningVH<T> &LHS, const PoisoningVH<T> &RHS) {\n    return DenseMapInfo<Value *>::isEqual(LHS.getRawValPtr(),\n                                          RHS.getRawValPtr());\n  }\n\n  // Allow lookup by T* via find_as(), without constructing a temporary\n  // value handle.\n\n  static unsigned getHashValue(const T *Val) {\n    return DenseMapInfo<Value *>::getHashValue(Val);\n  }\n\n  static bool isEqual(const T *LHS, const PoisoningVH<T> &RHS) {\n    return DenseMapInfo<Value *>::isEqual(LHS, RHS.getRawValPtr());\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUEHANDLE_H\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "content": "//===- ValueMap.h - Safe map from Values to data ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ValueMap class.  ValueMap maps Value* or any subclass\n// to an arbitrary other type.  It provides the DenseMap interface but updates\n// itself to remain safe when keys are RAUWed or deleted.  By default, when a\n// key is RAUWed from V1 to V2, the old mapping V1->target is removed, and a new\n// mapping V2->target is added.  If V2 already existed, its old target is\n// overwritten.  When a key is deleted, its mapping is removed.\n//\n// You can override a ValueMap's Config parameter to control exactly what\n// happens on RAUW and destruction and to get called back on each event.  It's\n// legal to call back into the ValueMap from a Config's callbacks.  Config\n// parameters should inherit from ValueMapConfig<KeyT> to get default\n// implementations of all the methods ValueMap uses.  See ValueMapConfig for\n// documentation of the functions you can override.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUEMAP_H\n#define LLVM_IR_VALUEMAP_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/TrackingMDRef.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Mutex.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <mutex>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\ntemplate<typename KeyT, typename ValueT, typename Config>\nclass ValueMapCallbackVH;\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapIterator;\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapConstIterator;\n\n/// This class defines the default behavior for configurable aspects of\n/// ValueMap<>.  User Configs should inherit from this class to be as compatible\n/// as possible with future versions of ValueMap.\ntemplate<typename KeyT, typename MutexT = sys::Mutex>\nstruct ValueMapConfig {\n  using mutex_type = MutexT;\n\n  /// If FollowRAUW is true, the ValueMap will update mappings on RAUW. If it's\n  /// false, the ValueMap will leave the original mapping in place.\n  enum { FollowRAUW = true };\n\n  // All methods will be called with a first argument of type ExtraData.  The\n  // default implementations in this class take a templated first argument so\n  // that users' subclasses can use any type they want without having to\n  // override all the defaults.\n  struct ExtraData {};\n\n  template<typename ExtraDataT>\n  static void onRAUW(const ExtraDataT & /*Data*/, KeyT /*Old*/, KeyT /*New*/) {}\n  template<typename ExtraDataT>\n  static void onDelete(const ExtraDataT &/*Data*/, KeyT /*Old*/) {}\n\n  /// Returns a mutex that should be acquired around any changes to the map.\n  /// This is only acquired from the CallbackVH (and held around calls to onRAUW\n  /// and onDelete) and not inside other ValueMap methods.  NULL means that no\n  /// mutex is necessary.\n  template<typename ExtraDataT>\n  static mutex_type *getMutex(const ExtraDataT &/*Data*/) { return nullptr; }\n};\n\n/// See the file comment.\ntemplate<typename KeyT, typename ValueT, typename Config =ValueMapConfig<KeyT>>\nclass ValueMap {\n  friend class ValueMapCallbackVH<KeyT, ValueT, Config>;\n\n  using ValueMapCVH = ValueMapCallbackVH<KeyT, ValueT, Config>;\n  using MapT = DenseMap<ValueMapCVH, ValueT, DenseMapInfo<ValueMapCVH>>;\n  using MDMapT = DenseMap<const Metadata *, TrackingMDRef>;\n  using ExtraData = typename Config::ExtraData;\n\n  MapT Map;\n  Optional<MDMapT> MDMap;\n  ExtraData Data;\n\npublic:\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = std::pair<KeyT, ValueT>;\n  using size_type = unsigned;\n\n  explicit ValueMap(unsigned NumInitBuckets = 64)\n      : Map(NumInitBuckets), Data() {}\n  explicit ValueMap(const ExtraData &Data, unsigned NumInitBuckets = 64)\n      : Map(NumInitBuckets), Data(Data) {}\n  // ValueMap can't be copied nor moved, beucase the callbacks store pointer\n  // to it.\n  ValueMap(const ValueMap &) = delete;\n  ValueMap(ValueMap &&) = delete;\n  ValueMap &operator=(const ValueMap &) = delete;\n  ValueMap &operator=(ValueMap &&) = delete;\n\n  bool hasMD() const { return bool(MDMap); }\n  MDMapT &MD() {\n    if (!MDMap)\n      MDMap.emplace();\n    return *MDMap;\n  }\n  Optional<MDMapT> &getMDMap() { return MDMap; }\n\n  /// Get the mapped metadata, if it's in the map.\n  Optional<Metadata *> getMappedMD(const Metadata *MD) const {\n    if (!MDMap)\n      return None;\n    auto Where = MDMap->find(MD);\n    if (Where == MDMap->end())\n      return None;\n    return Where->second.get();\n  }\n\n  using iterator = ValueMapIterator<MapT, KeyT>;\n  using const_iterator = ValueMapConstIterator<MapT, KeyT>;\n\n  inline iterator begin() { return iterator(Map.begin()); }\n  inline iterator end() { return iterator(Map.end()); }\n  inline const_iterator begin() const { return const_iterator(Map.begin()); }\n  inline const_iterator end() const { return const_iterator(Map.end()); }\n\n  bool empty() const { return Map.empty(); }\n  size_type size() const { return Map.size(); }\n\n  /// Grow the map so that it has at least Size buckets. Does not shrink\n  void resize(size_t Size) { Map.resize(Size); }\n\n  void clear() {\n    Map.clear();\n    MDMap.reset();\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const KeyT &Val) const {\n    return Map.find_as(Val) == Map.end() ? 0 : 1;\n  }\n\n  iterator find(const KeyT &Val) {\n    return iterator(Map.find_as(Val));\n  }\n  const_iterator find(const KeyT &Val) const {\n    return const_iterator(Map.find_as(Val));\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const KeyT &Val) const {\n    typename MapT::const_iterator I = Map.find_as(Val);\n    return I != Map.end() ? I->second : ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    auto MapResult = Map.insert(std::make_pair(Wrap(KV.first), KV.second));\n    return std::make_pair(iterator(MapResult.first), MapResult.second);\n  }\n\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    auto MapResult =\n        Map.insert(std::make_pair(Wrap(KV.first), std::move(KV.second)));\n    return std::make_pair(iterator(MapResult.first), MapResult.second);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    typename MapT::iterator I = Map.find_as(Val);\n    if (I == Map.end())\n      return false;\n\n    Map.erase(I);\n    return true;\n  }\n  void erase(iterator I) {\n    return Map.erase(I.base());\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    return Map.FindAndConstruct(Wrap(Key));\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return Map[Wrap(Key)];\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the ValueMap's array of buckets (i.e. either to a key or\n  /// value in the ValueMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Map.isPointerIntoBucketsArray(Ptr);\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the ValueMap to reallocate.\n  const void *getPointerIntoBucketsArray() const {\n    return Map.getPointerIntoBucketsArray();\n  }\n\nprivate:\n  // Takes a key being looked up in the map and wraps it into a\n  // ValueMapCallbackVH, the actual key type of the map.  We use a helper\n  // function because ValueMapCVH is constructed with a second parameter.\n  ValueMapCVH Wrap(KeyT key) const {\n    // The only way the resulting CallbackVH could try to modify *this (making\n    // the const_cast incorrect) is if it gets inserted into the map.  But then\n    // this function must have been called from a non-const method, making the\n    // const_cast ok.\n    return ValueMapCVH(key, const_cast<ValueMap*>(this));\n  }\n};\n\n// This CallbackVH updates its ValueMap when the contained Value changes,\n// according to the user's preferences expressed through the Config object.\ntemplate <typename KeyT, typename ValueT, typename Config>\nclass ValueMapCallbackVH final : public CallbackVH {\n  friend class ValueMap<KeyT, ValueT, Config>;\n  friend struct DenseMapInfo<ValueMapCallbackVH>;\n\n  using ValueMapT = ValueMap<KeyT, ValueT, Config>;\n  using KeySansPointerT = std::remove_pointer_t<KeyT>;\n\n  ValueMapT *Map;\n\n  ValueMapCallbackVH(KeyT Key, ValueMapT *Map)\n      : CallbackVH(const_cast<Value*>(static_cast<const Value*>(Key))),\n        Map(Map) {}\n\n  // Private constructor used to create empty/tombstone DenseMap keys.\n  ValueMapCallbackVH(Value *V) : CallbackVH(V), Map(nullptr) {}\n\npublic:\n  KeyT Unwrap() const { return cast_or_null<KeySansPointerT>(getValPtr()); }\n\n  void deleted() override {\n    // Make a copy that won't get changed even when *this is destroyed.\n    ValueMapCallbackVH Copy(*this);\n    typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);\n    std::unique_lock<typename Config::mutex_type> Guard;\n    if (M)\n      Guard = std::unique_lock<typename Config::mutex_type>(*M);\n    Config::onDelete(Copy.Map->Data, Copy.Unwrap());  // May destroy *this.\n    Copy.Map->Map.erase(Copy);  // Definitely destroys *this.\n  }\n\n  void allUsesReplacedWith(Value *new_key) override {\n    assert(isa<KeySansPointerT>(new_key) &&\n           \"Invalid RAUW on key of ValueMap<>\");\n    // Make a copy that won't get changed even when *this is destroyed.\n    ValueMapCallbackVH Copy(*this);\n    typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);\n    std::unique_lock<typename Config::mutex_type> Guard;\n    if (M)\n      Guard = std::unique_lock<typename Config::mutex_type>(*M);\n\n    KeyT typed_new_key = cast<KeySansPointerT>(new_key);\n    // Can destroy *this:\n    Config::onRAUW(Copy.Map->Data, Copy.Unwrap(), typed_new_key);\n    if (Config::FollowRAUW) {\n      typename ValueMapT::MapT::iterator I = Copy.Map->Map.find(Copy);\n      // I could == Copy.Map->Map.end() if the onRAUW callback already\n      // removed the old mapping.\n      if (I != Copy.Map->Map.end()) {\n        ValueT Target(std::move(I->second));\n        Copy.Map->Map.erase(I);  // Definitely destroys *this.\n        Copy.Map->insert(std::make_pair(typed_new_key, std::move(Target)));\n      }\n    }\n  }\n};\n\ntemplate<typename KeyT, typename ValueT, typename Config>\nstruct DenseMapInfo<ValueMapCallbackVH<KeyT, ValueT, Config>> {\n  using VH = ValueMapCallbackVH<KeyT, ValueT, Config>;\n\n  static inline VH getEmptyKey() {\n    return VH(DenseMapInfo<Value *>::getEmptyKey());\n  }\n\n  static inline VH getTombstoneKey() {\n    return VH(DenseMapInfo<Value *>::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const VH &Val) {\n    return DenseMapInfo<KeyT>::getHashValue(Val.Unwrap());\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return DenseMapInfo<KeyT>::getHashValue(Val);\n  }\n\n  static bool isEqual(const VH &LHS, const VH &RHS) {\n    return LHS == RHS;\n  }\n\n  static bool isEqual(const KeyT &LHS, const VH &RHS) {\n    return LHS == RHS.getValPtr();\n  }\n};\n\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapIterator :\n    public std::iterator<std::forward_iterator_tag,\n                         std::pair<KeyT, typename DenseMapT::mapped_type>,\n                         ptrdiff_t> {\n  using BaseT = typename DenseMapT::iterator;\n  using ValueT = typename DenseMapT::mapped_type;\n\n  BaseT I;\n\npublic:\n  ValueMapIterator() : I() {}\n  ValueMapIterator(BaseT I) : I(I) {}\n\n  BaseT base() const { return I; }\n\n  struct ValueTypeProxy {\n    const KeyT first;\n    ValueT& second;\n\n    ValueTypeProxy *operator->() { return this; }\n\n    operator std::pair<KeyT, ValueT>() const {\n      return std::make_pair(first, second);\n    }\n  };\n\n  ValueTypeProxy operator*() const {\n    ValueTypeProxy Result = {I->first.Unwrap(), I->second};\n    return Result;\n  }\n\n  ValueTypeProxy operator->() const {\n    return operator*();\n  }\n\n  bool operator==(const ValueMapIterator &RHS) const {\n    return I == RHS.I;\n  }\n  bool operator!=(const ValueMapIterator &RHS) const {\n    return I != RHS.I;\n  }\n\n  inline ValueMapIterator& operator++() {  // Preincrement\n    ++I;\n    return *this;\n  }\n  ValueMapIterator operator++(int) {  // Postincrement\n    ValueMapIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapConstIterator :\n    public std::iterator<std::forward_iterator_tag,\n                         std::pair<KeyT, typename DenseMapT::mapped_type>,\n                         ptrdiff_t> {\n  using BaseT = typename DenseMapT::const_iterator;\n  using ValueT = typename DenseMapT::mapped_type;\n\n  BaseT I;\n\npublic:\n  ValueMapConstIterator() : I() {}\n  ValueMapConstIterator(BaseT I) : I(I) {}\n  ValueMapConstIterator(ValueMapIterator<DenseMapT, KeyT> Other)\n    : I(Other.base()) {}\n\n  BaseT base() const { return I; }\n\n  struct ValueTypeProxy {\n    const KeyT first;\n    const ValueT& second;\n    ValueTypeProxy *operator->() { return this; }\n    operator std::pair<KeyT, ValueT>() const {\n      return std::make_pair(first, second);\n    }\n  };\n\n  ValueTypeProxy operator*() const {\n    ValueTypeProxy Result = {I->first.Unwrap(), I->second};\n    return Result;\n  }\n\n  ValueTypeProxy operator->() const {\n    return operator*();\n  }\n\n  bool operator==(const ValueMapConstIterator &RHS) const {\n    return I == RHS.I;\n  }\n  bool operator!=(const ValueMapConstIterator &RHS) const {\n    return I != RHS.I;\n  }\n\n  inline ValueMapConstIterator& operator++() {  // Preincrement\n    ++I;\n    return *this;\n  }\n  ValueMapConstIterator operator++(int) {  // Postincrement\n    ValueMapConstIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUEMAP_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "content": "//===-- llvm/MC/Register.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCREGISTER_H\n#define LLVM_MC_MCREGISTER_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// An unsigned integer type large enough to represent all physical registers,\n/// but not necessarily virtual registers.\nusing MCPhysReg = uint16_t;\n\n/// Wrapper class representing physical registers. Should be passed by value.\nclass MCRegister {\n  friend hash_code hash_value(const MCRegister &);\n  unsigned Reg;\n\npublic:\n  constexpr MCRegister(unsigned Val = 0): Reg(Val) {}\n\n  // Register numbers can represent physical registers, virtual registers, and\n  // sometimes stack slots. The unsigned values are divided into these ranges:\n  //\n  //   0           Not a register, can be used as a sentinel.\n  //   [1;2^30)    Physical registers assigned by TableGen.\n  //   [2^30;2^31) Stack slots. (Rarely used.)\n  //   [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.\n  //\n  // Further sentinels can be allocated from the small negative integers.\n  // DenseMapInfo<unsigned> uses -1u and -2u.\n  static_assert(std::numeric_limits<decltype(Reg)>::max() >= 0xFFFFFFFF,\n                \"Reg isn't large enough to hold full range.\");\n  static constexpr unsigned NoRegister = 0u;\n  static constexpr unsigned FirstPhysicalReg = 1u;\n  static constexpr unsigned FirstStackSlot = 1u << 30;\n  static constexpr unsigned VirtualRegFlag = 1u << 31;\n\n  /// This is the portion of the positive number space that is not a physical\n  /// register. StackSlot values do not exist in the MC layer, see\n  /// Register::isStackSlot() for the more information on them.\n  ///\n  static bool isStackSlot(unsigned Reg) {\n    return FirstStackSlot <= Reg && Reg < VirtualRegFlag;\n  }\n\n  /// Return true if the specified register number is in\n  /// the physical register namespace.\n  static bool isPhysicalRegister(unsigned Reg) {\n    return FirstPhysicalReg <= Reg && Reg < FirstStackSlot;\n  }\n\n  constexpr operator unsigned() const {\n    return Reg;\n  }\n\n  /// Check the provided unsigned value is a valid MCRegister.\n  static MCRegister from(unsigned Val) {\n    assert(Val == NoRegister || isPhysicalRegister(Val));\n    return MCRegister(Val);\n  }\n\n  unsigned id() const {\n    return Reg;\n  }\n\n  bool isValid() const { return Reg != NoRegister; }\n\n  /// Comparisons between register objects\n  bool operator==(const MCRegister &Other) const { return Reg == Other.Reg; }\n  bool operator!=(const MCRegister &Other) const { return Reg != Other.Reg; }\n\n  /// Comparisons against register constants. E.g.\n  /// * R == AArch64::WZR\n  /// * R == 0\n  /// * R == VirtRegMap::NO_PHYS_REG\n  bool operator==(unsigned Other) const { return Reg == Other; }\n  bool operator!=(unsigned Other) const { return Reg != Other; }\n  bool operator==(int Other) const { return Reg == unsigned(Other); }\n  bool operator!=(int Other) const { return Reg != unsigned(Other); }\n  // MSVC requires that we explicitly declare these two as well.\n  bool operator==(MCPhysReg Other) const { return Reg == unsigned(Other); }\n  bool operator!=(MCPhysReg Other) const { return Reg != unsigned(Other); }\n};\n\n// Provide DenseMapInfo for MCRegister\ntemplate<> struct DenseMapInfo<MCRegister> {\n  static inline unsigned getEmptyKey() {\n    return DenseMapInfo<unsigned>::getEmptyKey();\n  }\n  static inline unsigned getTombstoneKey() {\n    return DenseMapInfo<unsigned>::getTombstoneKey();\n  }\n  static unsigned getHashValue(const MCRegister &Val) {\n    return DenseMapInfo<unsigned>::getHashValue(Val.id());\n  }\n  static bool isEqual(const MCRegister &LHS, const MCRegister &RHS) {\n    return DenseMapInfo<unsigned>::isEqual(LHS.id(), RHS.id());\n  }\n};\n\ninline hash_code hash_value(const MCRegister &Reg) {\n  return hash_value(Reg.id());\n}\n}\n\n#endif // LLVM_MC_MCREGISTER_H\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "content": "//===- MC/MCRegisterInfo.h - Target Register Description --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes an abstract interface used to get information about a\n// target machines register file.  This information is used for a variety of\n// purposed, especially register allocation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCREGISTERINFO_H\n#define LLVM_MC_MCREGISTERINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/MC/MCRegister.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// MCRegisterClass - Base class of TargetRegisterClass.\nclass MCRegisterClass {\npublic:\n  using iterator = const MCPhysReg*;\n  using const_iterator = const MCPhysReg*;\n\n  const iterator RegsBegin;\n  const uint8_t *const RegSet;\n  const uint32_t NameIdx;\n  const uint16_t RegsSize;\n  const uint16_t RegSetSize;\n  const uint16_t ID;\n  const int8_t CopyCost;\n  const bool Allocatable;\n\n  /// getID() - Return the register class ID number.\n  ///\n  unsigned getID() const { return ID; }\n\n  /// begin/end - Return all of the registers in this class.\n  ///\n  iterator       begin() const { return RegsBegin; }\n  iterator         end() const { return RegsBegin + RegsSize; }\n\n  /// getNumRegs - Return the number of registers in this class.\n  ///\n  unsigned getNumRegs() const { return RegsSize; }\n\n  /// getRegister - Return the specified register in the class.\n  ///\n  unsigned getRegister(unsigned i) const {\n    assert(i < getNumRegs() && \"Register number out of range!\");\n    return RegsBegin[i];\n  }\n\n  /// contains - Return true if the specified register is included in this\n  /// register class.  This does not include virtual registers.\n  bool contains(MCRegister Reg) const {\n    unsigned RegNo = unsigned(Reg);\n    unsigned InByte = RegNo % 8;\n    unsigned Byte = RegNo / 8;\n    if (Byte >= RegSetSize)\n      return false;\n    return (RegSet[Byte] & (1 << InByte)) != 0;\n  }\n\n  /// contains - Return true if both registers are in this class.\n  bool contains(MCRegister Reg1, MCRegister Reg2) const {\n    return contains(Reg1) && contains(Reg2);\n  }\n\n  /// getCopyCost - Return the cost of copying a value between two registers in\n  /// this class. A negative number means the register class is very expensive\n  /// to copy e.g. status flag register classes.\n  int getCopyCost() const { return CopyCost; }\n\n  /// isAllocatable - Return true if this register class may be used to create\n  /// virtual registers.\n  bool isAllocatable() const { return Allocatable; }\n};\n\n/// MCRegisterDesc - This record contains information about a particular\n/// register.  The SubRegs field is a zero terminated array of registers that\n/// are sub-registers of the specific register, e.g. AL, AH are sub-registers\n/// of AX. The SuperRegs field is a zero terminated array of registers that are\n/// super-registers of the specific register, e.g. RAX, EAX, are\n/// super-registers of AX.\n///\nstruct MCRegisterDesc {\n  uint32_t Name;      // Printable name for the reg (for debugging)\n  uint32_t SubRegs;   // Sub-register set, described above\n  uint32_t SuperRegs; // Super-register set, described above\n\n  // Offset into MCRI::SubRegIndices of a list of sub-register indices for each\n  // sub-register in SubRegs.\n  uint32_t SubRegIndices;\n\n  // RegUnits - Points to the list of register units. The low 4 bits holds the\n  // Scale, the high bits hold an offset into DiffLists. See MCRegUnitIterator.\n  uint32_t RegUnits;\n\n  /// Index into list with lane mask sequences. The sequence contains a lanemask\n  /// for every register unit.\n  uint16_t RegUnitLaneMasks;\n};\n\n/// MCRegisterInfo base class - We assume that the target defines a static\n/// array of MCRegisterDesc objects that represent all of the machine\n/// registers that the target has.  As such, we simply have to track a pointer\n/// to this array so that we can turn register number into a register\n/// descriptor.\n///\n/// Note this class is designed to be a base class of TargetRegisterInfo, which\n/// is the interface used by codegen. However, specific targets *should never*\n/// specialize this class. MCRegisterInfo should only contain getters to access\n/// TableGen generated physical register data. It must not be extended with\n/// virtual methods.\n///\nclass MCRegisterInfo {\npublic:\n  using regclass_iterator = const MCRegisterClass *;\n\n  /// DwarfLLVMRegPair - Emitted by tablegen so Dwarf<->LLVM reg mappings can be\n  /// performed with a binary search.\n  struct DwarfLLVMRegPair {\n    unsigned FromReg;\n    unsigned ToReg;\n\n    bool operator<(DwarfLLVMRegPair RHS) const { return FromReg < RHS.FromReg; }\n  };\n\n  /// SubRegCoveredBits - Emitted by tablegen: bit range covered by a subreg\n  /// index, -1 in any being invalid.\n  struct SubRegCoveredBits {\n    uint16_t Offset;\n    uint16_t Size;\n  };\n\nprivate:\n  const MCRegisterDesc *Desc;                 // Pointer to the descriptor array\n  unsigned NumRegs;                           // Number of entries in the array\n  MCRegister RAReg;                           // Return address register\n  MCRegister PCReg;                           // Program counter register\n  const MCRegisterClass *Classes;             // Pointer to the regclass array\n  unsigned NumClasses;                        // Number of entries in the array\n  unsigned NumRegUnits;                       // Number of regunits.\n  const MCPhysReg (*RegUnitRoots)[2];         // Pointer to regunit root table.\n  const MCPhysReg *DiffLists;                 // Pointer to the difflists array\n  const LaneBitmask *RegUnitMaskSequences;    // Pointer to lane mask sequences\n                                              // for register units.\n  const char *RegStrings;                     // Pointer to the string table.\n  const char *RegClassStrings;                // Pointer to the class strings.\n  const uint16_t *SubRegIndices;              // Pointer to the subreg lookup\n                                              // array.\n  const SubRegCoveredBits *SubRegIdxRanges;   // Pointer to the subreg covered\n                                              // bit ranges array.\n  unsigned NumSubRegIndices;                  // Number of subreg indices.\n  const uint16_t *RegEncodingTable;           // Pointer to array of register\n                                              // encodings.\n\n  unsigned L2DwarfRegsSize;\n  unsigned EHL2DwarfRegsSize;\n  unsigned Dwarf2LRegsSize;\n  unsigned EHDwarf2LRegsSize;\n  const DwarfLLVMRegPair *L2DwarfRegs;        // LLVM to Dwarf regs mapping\n  const DwarfLLVMRegPair *EHL2DwarfRegs;      // LLVM to Dwarf regs mapping EH\n  const DwarfLLVMRegPair *Dwarf2LRegs;        // Dwarf to LLVM regs mapping\n  const DwarfLLVMRegPair *EHDwarf2LRegs;      // Dwarf to LLVM regs mapping EH\n  DenseMap<MCRegister, int> L2SEHRegs;        // LLVM to SEH regs mapping\n  DenseMap<MCRegister, int> L2CVRegs;         // LLVM to CV regs mapping\n\npublic:\n  // Forward declaration to become a friend class of DiffListIterator.\n  template <class SubT> class mc_difflist_iterator;\n\n  /// DiffListIterator - Base iterator class that can traverse the\n  /// differentially encoded register and regunit lists in DiffLists.\n  /// Don't use this class directly, use one of the specialized sub-classes\n  /// defined below.\n  class DiffListIterator {\n    uint16_t Val = 0;\n    const MCPhysReg *List = nullptr;\n\n  protected:\n    /// Create an invalid iterator. Call init() to point to something useful.\n    DiffListIterator() = default;\n\n    /// init - Point the iterator to InitVal, decoding subsequent values from\n    /// DiffList. The iterator will initially point to InitVal, sub-classes are\n    /// responsible for skipping the seed value if it is not part of the list.\n    void init(MCPhysReg InitVal, const MCPhysReg *DiffList) {\n      Val = InitVal;\n      List = DiffList;\n    }\n\n    /// advance - Move to the next list position, return the applied\n    /// differential. This function does not detect the end of the list, that\n    /// is the caller's responsibility (by checking for a 0 return value).\n    MCRegister advance() {\n      assert(isValid() && \"Cannot move off the end of the list.\");\n      MCPhysReg D = *List++;\n      Val += D;\n      return D;\n    }\n\n  public:\n    /// isValid - returns true if this iterator is not yet at the end.\n    bool isValid() const { return List; }\n\n    /// Dereference the iterator to get the value at the current position.\n    MCRegister operator*() const { return Val; }\n\n    /// Pre-increment to move to the next position.\n    void operator++() {\n      // The end of the list is encoded as a 0 differential.\n      if (!advance())\n        List = nullptr;\n    }\n\n    template <class SubT> friend class MCRegisterInfo::mc_difflist_iterator;\n  };\n\n  /// Forward iterator using DiffListIterator.\n  template <class SubT>\n  class mc_difflist_iterator\n      : public iterator_facade_base<mc_difflist_iterator<SubT>,\n                                    std::forward_iterator_tag, MCPhysReg> {\n    MCRegisterInfo::DiffListIterator Iter;\n    /// Current value as MCPhysReg, so we can return a reference to it.\n    MCPhysReg Val;\n\n  protected:\n    mc_difflist_iterator(MCRegisterInfo::DiffListIterator Iter) : Iter(Iter) {}\n\n    // Allow conversion between instantiations where valid.\n    mc_difflist_iterator(MCRegister Reg, const MCPhysReg *DiffList) {\n      Iter.init(Reg, DiffList);\n      Val = *Iter;\n    }\n\n  public:\n    // Allow default construction to build variables, but this doesn't build\n    // a useful iterator.\n    mc_difflist_iterator() = default;\n\n    /// Return an iterator past the last element.\n    static SubT end() {\n      SubT End;\n      End.Iter.List = nullptr;\n      return End;\n    }\n\n    bool operator==(const mc_difflist_iterator &Arg) const {\n      return Iter.List == Arg.Iter.List;\n    }\n\n    const MCPhysReg &operator*() const { return Val; }\n\n    using mc_difflist_iterator::iterator_facade_base::operator++;\n    void operator++() {\n      assert(Iter.List && \"Cannot increment the end iterator!\");\n      ++Iter;\n      Val = *Iter;\n    }\n  };\n\n  /// Forward iterator over all sub-registers.\n  /// TODO: Replace remaining uses of MCSubRegIterator.\n  class mc_subreg_iterator : public mc_difflist_iterator<mc_subreg_iterator> {\n  public:\n    mc_subreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_subreg_iterator() = default;\n    mc_subreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs) {}\n  };\n\n  /// Forward iterator over all super-registers.\n  /// TODO: Replace remaining uses of MCSuperRegIterator.\n  class mc_superreg_iterator\n      : public mc_difflist_iterator<mc_superreg_iterator> {\n  public:\n    mc_superreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_superreg_iterator() = default;\n    mc_superreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg,\n                               MCRI->DiffLists + MCRI->get(Reg).SuperRegs) {}\n  };\n\n  /// Return an iterator range over all sub-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs(MCRegister Reg) const {\n    return make_range(std::next(mc_subreg_iterator(Reg, this)),\n                      mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator> superregs(MCRegister Reg) const {\n    return make_range(std::next(mc_superreg_iterator(Reg, this)),\n                      mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator>\n  superregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub- and super-registers of \\p Reg,\n  /// including \\p Reg.\n  detail::concat_range<const MCPhysReg, iterator_range<mc_subreg_iterator>,\n                       iterator_range<mc_superreg_iterator>>\n  sub_and_superregs_inclusive(MCRegister Reg) const {\n    return concat<const MCPhysReg>(subregs_inclusive(Reg), superregs(Reg));\n  }\n\n  // These iterators are allowed to sub-class DiffListIterator and access\n  // internal list pointers.\n  friend class MCSubRegIterator;\n  friend class MCSubRegIndexIterator;\n  friend class MCSuperRegIterator;\n  friend class MCRegUnitIterator;\n  friend class MCRegUnitMaskIterator;\n  friend class MCRegUnitRootIterator;\n\n  /// Initialize MCRegisterInfo, called by TableGen\n  /// auto-generated routines. *DO NOT USE*.\n  void InitMCRegisterInfo(const MCRegisterDesc *D, unsigned NR, unsigned RA,\n                          unsigned PC,\n                          const MCRegisterClass *C, unsigned NC,\n                          const MCPhysReg (*RURoots)[2],\n                          unsigned NRU,\n                          const MCPhysReg *DL,\n                          const LaneBitmask *RUMS,\n                          const char *Strings,\n                          const char *ClassStrings,\n                          const uint16_t *SubIndices,\n                          unsigned NumIndices,\n                          const SubRegCoveredBits *SubIdxRanges,\n                          const uint16_t *RET) {\n    Desc = D;\n    NumRegs = NR;\n    RAReg = RA;\n    PCReg = PC;\n    Classes = C;\n    DiffLists = DL;\n    RegUnitMaskSequences = RUMS;\n    RegStrings = Strings;\n    RegClassStrings = ClassStrings;\n    NumClasses = NC;\n    RegUnitRoots = RURoots;\n    NumRegUnits = NRU;\n    SubRegIndices = SubIndices;\n    NumSubRegIndices = NumIndices;\n    SubRegIdxRanges = SubIdxRanges;\n    RegEncodingTable = RET;\n\n    // Initialize DWARF register mapping variables\n    EHL2DwarfRegs = nullptr;\n    EHL2DwarfRegsSize = 0;\n    L2DwarfRegs = nullptr;\n    L2DwarfRegsSize = 0;\n    EHDwarf2LRegs = nullptr;\n    EHDwarf2LRegsSize = 0;\n    Dwarf2LRegs = nullptr;\n    Dwarf2LRegsSize = 0;\n  }\n\n  /// Used to initialize LLVM register to Dwarf\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapLLVMRegsToDwarfRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHL2DwarfRegs = Map;\n      EHL2DwarfRegsSize = Size;\n    } else {\n      L2DwarfRegs = Map;\n      L2DwarfRegsSize = Size;\n    }\n  }\n\n  /// Used to initialize Dwarf register to LLVM\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapDwarfRegsToLLVMRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHDwarf2LRegs = Map;\n      EHDwarf2LRegsSize = Size;\n    } else {\n      Dwarf2LRegs = Map;\n      Dwarf2LRegsSize = Size;\n    }\n  }\n\n  /// mapLLVMRegToSEHReg - Used to initialize LLVM register to SEH register\n  /// number mapping. By default the SEH register number is just the same\n  /// as the LLVM register number.\n  /// FIXME: TableGen these numbers. Currently this requires target specific\n  /// initialization code.\n  void mapLLVMRegToSEHReg(MCRegister LLVMReg, int SEHReg) {\n    L2SEHRegs[LLVMReg] = SEHReg;\n  }\n\n  void mapLLVMRegToCVReg(MCRegister LLVMReg, int CVReg) {\n    L2CVRegs[LLVMReg] = CVReg;\n  }\n\n  /// This method should return the register where the return\n  /// address can be found.\n  MCRegister getRARegister() const {\n    return RAReg;\n  }\n\n  /// Return the register which is the program counter.\n  MCRegister getProgramCounter() const {\n    return PCReg;\n  }\n\n  const MCRegisterDesc &operator[](MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to access record for invalid register number!\");\n    return Desc[RegNo];\n  }\n\n  /// Provide a get method, equivalent to [], but more useful with a\n  /// pointer to this object.\n  const MCRegisterDesc &get(MCRegister RegNo) const {\n    return operator[](RegNo);\n  }\n\n  /// Returns the physical register number of sub-register \"Index\"\n  /// for physical register RegNo. Return zero if the sub-register does not\n  /// exist.\n  MCRegister getSubReg(MCRegister Reg, unsigned Idx) const;\n\n  /// Return a super-register of the specified register\n  /// Reg so its sub-register of index SubIdx is Reg.\n  MCRegister getMatchingSuperReg(MCRegister Reg, unsigned SubIdx,\n                                 const MCRegisterClass *RC) const;\n\n  /// For a given register pair, return the sub-register index\n  /// if the second register is a sub-register of the first. Return zero\n  /// otherwise.\n  unsigned getSubRegIndex(MCRegister RegNo, MCRegister SubRegNo) const;\n\n  /// Get the size of the bit range covered by a sub-register index.\n  /// If the index isn't continuous, return the sum of the sizes of its parts.\n  /// If the index is used to access subregisters of different sizes, return -1.\n  unsigned getSubRegIdxSize(unsigned Idx) const;\n\n  /// Get the offset of the bit range covered by a sub-register index.\n  /// If an Offset doesn't make sense (the index isn't continuous, or is used to\n  /// access sub-registers at different offsets), return -1.\n  unsigned getSubRegIdxOffset(unsigned Idx) const;\n\n  /// Return the human-readable symbolic target-specific name for the\n  /// specified physical register.\n  const char *getName(MCRegister RegNo) const {\n    return RegStrings + get(RegNo).Name;\n  }\n\n  /// Return the number of registers this target has (useful for\n  /// sizing arrays holding per register information)\n  unsigned getNumRegs() const {\n    return NumRegs;\n  }\n\n  /// Return the number of sub-register indices\n  /// understood by the target. Index 0 is reserved for the no-op sub-register,\n  /// while 1 to getNumSubRegIndices() - 1 represent real sub-registers.\n  unsigned getNumSubRegIndices() const {\n    return NumSubRegIndices;\n  }\n\n  /// Return the number of (native) register units in the\n  /// target. Register units are numbered from 0 to getNumRegUnits() - 1. They\n  /// can be accessed through MCRegUnitIterator defined below.\n  unsigned getNumRegUnits() const {\n    return NumRegUnits;\n  }\n\n  /// Map a target register to an equivalent dwarf register\n  /// number.  Returns -1 if there is no equivalent value.  The second\n  /// parameter allows targets to use different numberings for EH info and\n  /// debugging info.\n  int getDwarfRegNum(MCRegister RegNum, bool isEH) const;\n\n  /// Map a dwarf register back to a target register. Returns None is there is\n  /// no mapping.\n  Optional<unsigned> getLLVMRegNum(unsigned RegNum, bool isEH) const;\n\n  /// Map a target EH register number to an equivalent DWARF register\n  /// number.\n  int getDwarfRegNumFromDwarfEHRegNum(unsigned RegNum) const;\n\n  /// Map a target register to an equivalent SEH register\n  /// number.  Returns LLVM register number if there is no equivalent value.\n  int getSEHRegNum(MCRegister RegNum) const;\n\n  /// Map a target register to an equivalent CodeView register\n  /// number.\n  int getCodeViewRegNum(MCRegister RegNum) const;\n\n  regclass_iterator regclass_begin() const { return Classes; }\n  regclass_iterator regclass_end() const { return Classes+NumClasses; }\n  iterator_range<regclass_iterator> regclasses() const {\n    return make_range(regclass_begin(), regclass_end());\n  }\n\n  unsigned getNumRegClasses() const {\n    return (unsigned)(regclass_end()-regclass_begin());\n  }\n\n  /// Returns the register class associated with the enumeration\n  /// value.  See class MCOperandInfo.\n  const MCRegisterClass& getRegClass(unsigned i) const {\n    assert(i < getNumRegClasses() && \"Register Class ID out of range\");\n    return Classes[i];\n  }\n\n  const char *getRegClassName(const MCRegisterClass *Class) const {\n    return RegClassStrings + Class->NameIdx;\n  }\n\n   /// Returns the encoding for RegNo\n  uint16_t getEncodingValue(MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to get encoding for invalid register number!\");\n    return RegEncodingTable[RegNo];\n  }\n\n  /// Returns true if RegB is a sub-register of RegA.\n  bool isSubRegister(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegister(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA.\n  bool isSuperRegister(MCRegister RegA, MCRegister RegB) const;\n\n  /// Returns true if RegB is a sub-register of RegA or if RegB == RegA.\n  bool isSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegisterEq(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA or if\n  /// RegB == RegA.\n  bool isSuperRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return RegA == RegB || isSuperRegister(RegA, RegB);\n  }\n\n  /// Returns true if RegB is a super-register or sub-register of RegA\n  /// or if RegB == RegA.\n  bool isSuperOrSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSubRegisterEq(RegA, RegB) || isSuperRegister(RegA, RegB);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                          Register List Iterators\n//===----------------------------------------------------------------------===//\n\n// MCRegisterInfo provides lists of super-registers, sub-registers, and\n// aliasing registers. Use these iterator classes to traverse the lists.\n\n/// MCSubRegIterator enumerates all sub-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSubRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSubRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                   bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n/// Iterator that enumerates the sub-registers of a Reg and the associated\n/// sub-register indices.\nclass MCSubRegIndexIterator {\n  MCSubRegIterator SRIter;\n  const uint16_t *SRIndex;\n\npublic:\n  /// Constructs an iterator that traverses subregisters and their\n  /// associated subregister indices.\n  MCSubRegIndexIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : SRIter(Reg, MCRI) {\n    SRIndex = MCRI->SubRegIndices + MCRI->get(Reg).SubRegIndices;\n  }\n\n  /// Returns current sub-register.\n  MCRegister getSubReg() const {\n    return *SRIter;\n  }\n\n  /// Returns sub-register index of the current sub-register.\n  unsigned getSubRegIndex() const {\n    return *SRIndex;\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return SRIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++SRIter;\n    ++SRIndex;\n  }\n};\n\n/// MCSuperRegIterator enumerates all super-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSuperRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSuperRegIterator() = default;\n\n  MCSuperRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SuperRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n// Definition for isSuperRegister. Put it down here since it needs the\n// iterator defined above in addition to the MCRegisterInfo class itself.\ninline bool MCRegisterInfo::isSuperRegister(MCRegister RegA, MCRegister RegB) const{\n  for (MCSuperRegIterator I(RegA, this); I.isValid(); ++I)\n    if (*I == RegB)\n      return true;\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n//                               Register Units\n//===----------------------------------------------------------------------===//\n\n// Register units are used to compute register aliasing. Every register has at\n// least one register unit, but it can have more. Two registers overlap if and\n// only if they have a common register unit.\n//\n// A target with a complicated sub-register structure will typically have many\n// fewer register units than actual registers. MCRI::getNumRegUnits() returns\n// the number of register units in the target.\n\n// MCRegUnitIterator enumerates a list of register units for Reg. The list is\n// in ascending numerical order.\nclass MCRegUnitIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  /// MCRegUnitIterator - Create an iterator that traverses the register units\n  /// in Reg.\n  MCRegUnitIterator() = default;\n\n  MCRegUnitIterator(MCRegister Reg, const MCRegisterInfo *MCRI) {\n    assert(Reg && \"Null register has no regunits\");\n    assert(MCRegister::isPhysicalRegister(Reg.id()));\n    // Decode the RegUnits MCRegisterDesc field.\n    unsigned RU = MCRI->get(Reg).RegUnits;\n    unsigned Scale = RU & 15;\n    unsigned Offset = RU >> 4;\n\n    // Initialize the iterator to Reg * Scale, and the List pointer to\n    // DiffLists + Offset.\n    init(Reg * Scale, MCRI->DiffLists + Offset);\n\n    // That may not be a valid unit, we need to advance by one to get the real\n    // unit number. The first differential can be 0 which would normally\n    // terminate the list, but since we know every register has at least one\n    // unit, we can allow a 0 differential here.\n    advance();\n  }\n};\n\n/// MCRegUnitMaskIterator enumerates a list of register units and their\n/// associated lane masks for Reg. The register units are in ascending\n/// numerical order.\nclass MCRegUnitMaskIterator {\n  MCRegUnitIterator RUIter;\n  const LaneBitmask *MaskListIter;\n\npublic:\n  MCRegUnitMaskIterator() = default;\n\n  /// Constructs an iterator that traverses the register units and their\n  /// associated LaneMasks in Reg.\n  MCRegUnitMaskIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : RUIter(Reg, MCRI) {\n      uint16_t Idx = MCRI->get(Reg).RegUnitLaneMasks;\n      MaskListIter = &MCRI->RegUnitMaskSequences[Idx];\n  }\n\n  /// Returns a (RegUnit, LaneMask) pair.\n  std::pair<unsigned,LaneBitmask> operator*() const {\n    return std::make_pair(*RUIter, *MaskListIter);\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return RUIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++MaskListIter;\n    ++RUIter;\n  }\n};\n\n// Each register unit has one or two root registers. The complete set of\n// registers containing a register unit is the union of the roots and their\n// super-registers. All registers aliasing Unit can be visited like this:\n//\n//   for (MCRegUnitRootIterator RI(Unit, MCRI); RI.isValid(); ++RI) {\n//     for (MCSuperRegIterator SI(*RI, MCRI, true); SI.isValid(); ++SI)\n//       visit(*SI);\n//    }\n\n/// MCRegUnitRootIterator enumerates the root registers of a register unit.\nclass MCRegUnitRootIterator {\n  uint16_t Reg0 = 0;\n  uint16_t Reg1 = 0;\n\npublic:\n  MCRegUnitRootIterator() = default;\n\n  MCRegUnitRootIterator(unsigned RegUnit, const MCRegisterInfo *MCRI) {\n    assert(RegUnit < MCRI->getNumRegUnits() && \"Invalid register unit\");\n    Reg0 = MCRI->RegUnitRoots[RegUnit][0];\n    Reg1 = MCRI->RegUnitRoots[RegUnit][1];\n  }\n\n  /// Dereference to get the current root register.\n  unsigned operator*() const {\n    return Reg0;\n  }\n\n  /// Check if the iterator is at the end of the list.\n  bool isValid() const {\n    return Reg0;\n  }\n\n  /// Preincrement to move to the next root register.\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    Reg0 = Reg1;\n    Reg1 = 0;\n  }\n};\n\n/// MCRegAliasIterator enumerates all registers aliasing Reg.  If IncludeSelf is\n/// set, Reg itself is included in the list.  This iterator does not guarantee\n/// any ordering or that entries are unique.\nclass MCRegAliasIterator {\nprivate:\n  MCRegister Reg;\n  const MCRegisterInfo *MCRI;\n  bool IncludeSelf;\n\n  MCRegUnitIterator RI;\n  MCRegUnitRootIterator RRI;\n  MCSuperRegIterator SI;\n\npublic:\n  MCRegAliasIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf)\n    : Reg(Reg), MCRI(MCRI), IncludeSelf(IncludeSelf) {\n    // Initialize the iterators.\n    for (RI = MCRegUnitIterator(Reg, MCRI); RI.isValid(); ++RI) {\n      for (RRI = MCRegUnitRootIterator(*RI, MCRI); RRI.isValid(); ++RRI) {\n        for (SI = MCSuperRegIterator(*RRI, MCRI, true); SI.isValid(); ++SI) {\n          if (!(!IncludeSelf && Reg == *SI))\n            return;\n        }\n      }\n    }\n  }\n\n  bool isValid() const { return RI.isValid(); }\n\n  MCRegister operator*() const {\n    assert(SI.isValid() && \"Cannot dereference an invalid iterator.\");\n    return *SI;\n  }\n\n  void advance() {\n    // Assuming SI is valid.\n    ++SI;\n    if (SI.isValid()) return;\n\n    ++RRI;\n    if (RRI.isValid()) {\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n      return;\n    }\n\n    ++RI;\n    if (RI.isValid()) {\n      RRI = MCRegUnitRootIterator(*RI, MCRI);\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n    }\n  }\n\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    do advance();\n    while (!IncludeSelf && isValid() && *SI == Reg);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCREGISTERINFO_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "content": "//===- llvm/MC/MCSubtargetInfo.h - Subtarget Information --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes the subtarget options of a Target machine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCSUBTARGETINFO_H\n#define LLVM_MC_MCSUBTARGETINFO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/MC/MCInstrItineraries.h\"\n#include \"llvm/MC/MCSchedule.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <string>\n\nnamespace llvm {\n\nclass MCInst;\n\n//===----------------------------------------------------------------------===//\n\n/// Used to provide key value pairs for feature and CPU bit flags.\nstruct SubtargetFeatureKV {\n  const char *Key;                      ///< K-V key string\n  const char *Desc;                     ///< Help descriptor\n  unsigned Value;                       ///< K-V integer value\n  FeatureBitArray Implies;              ///< K-V bit mask\n\n  /// Compare routine for std::lower_bound\n  bool operator<(StringRef S) const {\n    return StringRef(Key) < S;\n  }\n\n  /// Compare routine for std::is_sorted.\n  bool operator<(const SubtargetFeatureKV &Other) const {\n    return StringRef(Key) < StringRef(Other.Key);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n\n/// Used to provide key value pairs for feature and CPU bit flags.\nstruct SubtargetSubTypeKV {\n  const char *Key;                      ///< K-V key string\n  FeatureBitArray Implies;              ///< K-V bit mask\n  FeatureBitArray TuneImplies;          ///< K-V bit mask\n  const MCSchedModel *SchedModel;\n\n  /// Compare routine for std::lower_bound\n  bool operator<(StringRef S) const {\n    return StringRef(Key) < S;\n  }\n\n  /// Compare routine for std::is_sorted.\n  bool operator<(const SubtargetSubTypeKV &Other) const {\n    return StringRef(Key) < StringRef(Other.Key);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n///\n/// Generic base class for all target subtargets.\n///\nclass MCSubtargetInfo {\n  Triple TargetTriple;\n  std::string CPU; // CPU being targeted.\n  std::string TuneCPU; // CPU being tuned for.\n  ArrayRef<SubtargetFeatureKV> ProcFeatures;  // Processor feature list\n  ArrayRef<SubtargetSubTypeKV> ProcDesc;  // Processor descriptions\n\n  // Scheduler machine model\n  const MCWriteProcResEntry *WriteProcResTable;\n  const MCWriteLatencyEntry *WriteLatencyTable;\n  const MCReadAdvanceEntry *ReadAdvanceTable;\n  const MCSchedModel *CPUSchedModel;\n\n  const InstrStage *Stages;            // Instruction itinerary stages\n  const unsigned *OperandCycles;       // Itinerary operand cycles\n  const unsigned *ForwardingPaths;\n  FeatureBitset FeatureBits;           // Feature bits for current CPU + FS\n\npublic:\n  MCSubtargetInfo(const MCSubtargetInfo &) = default;\n  MCSubtargetInfo(const Triple &TT, StringRef CPU, StringRef TuneCPU,\n                  StringRef FS, ArrayRef<SubtargetFeatureKV> PF,\n                  ArrayRef<SubtargetSubTypeKV> PD,\n                  const MCWriteProcResEntry *WPR, const MCWriteLatencyEntry *WL,\n                  const MCReadAdvanceEntry *RA, const InstrStage *IS,\n                  const unsigned *OC, const unsigned *FP);\n  MCSubtargetInfo() = delete;\n  MCSubtargetInfo &operator=(const MCSubtargetInfo &) = delete;\n  MCSubtargetInfo &operator=(MCSubtargetInfo &&) = delete;\n  virtual ~MCSubtargetInfo() = default;\n\n  const Triple &getTargetTriple() const { return TargetTriple; }\n  StringRef getCPU() const { return CPU; }\n  StringRef getTuneCPU() const { return TuneCPU; }\n\n  const FeatureBitset& getFeatureBits() const { return FeatureBits; }\n  void setFeatureBits(const FeatureBitset &FeatureBits_) {\n    FeatureBits = FeatureBits_;\n  }\n\n  bool hasFeature(unsigned Feature) const {\n    return FeatureBits[Feature];\n  }\n\nprotected:\n  /// Initialize the scheduling model and feature bits.\n  ///\n  /// FIXME: Find a way to stick this in the constructor, since it should only\n  /// be called during initialization.\n  void InitMCProcessorInfo(StringRef CPU, StringRef TuneCPU, StringRef FS);\n\npublic:\n  /// Set the features to the default for the given CPU and TuneCPU, with ano\n  /// appended feature string.\n  void setDefaultFeatures(StringRef CPU, StringRef TuneCPU, StringRef FS);\n\n  /// Toggle a feature and return the re-computed feature bits.\n  /// This version does not change the implied bits.\n  FeatureBitset ToggleFeature(uint64_t FB);\n\n  /// Toggle a feature and return the re-computed feature bits.\n  /// This version does not change the implied bits.\n  FeatureBitset ToggleFeature(const FeatureBitset& FB);\n\n  /// Toggle a set of features and return the re-computed feature bits.\n  /// This version will also change all implied bits.\n  FeatureBitset ToggleFeature(StringRef FS);\n\n  /// Apply a feature flag and return the re-computed feature bits, including\n  /// all feature bits implied by the flag.\n  FeatureBitset ApplyFeatureFlag(StringRef FS);\n\n  /// Set/clear additional feature bits, including all other bits they imply.\n  FeatureBitset SetFeatureBitsTransitively(const FeatureBitset& FB);\n  FeatureBitset ClearFeatureBitsTransitively(const FeatureBitset &FB);\n\n  /// Check whether the subtarget features are enabled/disabled as per\n  /// the provided string, ignoring all other features.\n  bool checkFeatures(StringRef FS) const;\n\n  /// Get the machine model of a CPU.\n  const MCSchedModel &getSchedModelForCPU(StringRef CPU) const;\n\n  /// Get the machine model for this subtarget's CPU.\n  const MCSchedModel &getSchedModel() const { return *CPUSchedModel; }\n\n  /// Return an iterator at the first process resource consumed by the given\n  /// scheduling class.\n  const MCWriteProcResEntry *getWriteProcResBegin(\n    const MCSchedClassDesc *SC) const {\n    return &WriteProcResTable[SC->WriteProcResIdx];\n  }\n  const MCWriteProcResEntry *getWriteProcResEnd(\n    const MCSchedClassDesc *SC) const {\n    return getWriteProcResBegin(SC) + SC->NumWriteProcResEntries;\n  }\n\n  const MCWriteLatencyEntry *getWriteLatencyEntry(const MCSchedClassDesc *SC,\n                                                  unsigned DefIdx) const {\n    assert(DefIdx < SC->NumWriteLatencyEntries &&\n           \"MachineModel does not specify a WriteResource for DefIdx\");\n\n    return &WriteLatencyTable[SC->WriteLatencyIdx + DefIdx];\n  }\n\n  int getReadAdvanceCycles(const MCSchedClassDesc *SC, unsigned UseIdx,\n                           unsigned WriteResID) const {\n    // TODO: The number of read advance entries in a class can be significant\n    // (~50). Consider compressing the WriteID into a dense ID of those that are\n    // used by ReadAdvance and representing them as a bitset.\n    for (const MCReadAdvanceEntry *I = &ReadAdvanceTable[SC->ReadAdvanceIdx],\n           *E = I + SC->NumReadAdvanceEntries; I != E; ++I) {\n      if (I->UseIdx < UseIdx)\n        continue;\n      if (I->UseIdx > UseIdx)\n        break;\n      // Find the first WriteResIdx match, which has the highest cycle count.\n      if (!I->WriteResourceID || I->WriteResourceID == WriteResID) {\n        return I->Cycles;\n      }\n    }\n    return 0;\n  }\n\n  /// Return the set of ReadAdvance entries declared by the scheduling class\n  /// descriptor in input.\n  ArrayRef<MCReadAdvanceEntry>\n  getReadAdvanceEntries(const MCSchedClassDesc &SC) const {\n    if (!SC.NumReadAdvanceEntries)\n      return ArrayRef<MCReadAdvanceEntry>();\n    return ArrayRef<MCReadAdvanceEntry>(&ReadAdvanceTable[SC.ReadAdvanceIdx],\n                                        SC.NumReadAdvanceEntries);\n  }\n\n  /// Get scheduling itinerary of a CPU.\n  InstrItineraryData getInstrItineraryForCPU(StringRef CPU) const;\n\n  /// Initialize an InstrItineraryData instance.\n  void initInstrItins(InstrItineraryData &InstrItins) const;\n\n  /// Resolve a variant scheduling class for the given MCInst and CPU.\n  virtual unsigned resolveVariantSchedClass(unsigned SchedClass,\n                                            const MCInst *MI,\n                                            const MCInstrInfo *MCII,\n                                            unsigned CPUID) const {\n    return 0;\n  }\n\n  /// Check whether the CPU string is valid.\n  bool isCPUStringValid(StringRef CPU) const {\n    auto Found = llvm::lower_bound(ProcDesc, CPU);\n    return Found != ProcDesc.end() && StringRef(Found->Key) == CPU;\n  }\n\n  virtual unsigned getHwMode() const { return 0; }\n\n  /// Return the cache size in bytes for the given level of cache.\n  /// Level is zero-based, so a value of zero means the first level of\n  /// cache.\n  ///\n  virtual Optional<unsigned> getCacheSize(unsigned Level) const;\n\n  /// Return the cache associatvity for the given level of cache.\n  /// Level is zero-based, so a value of zero means the first level of\n  /// cache.\n  ///\n  virtual Optional<unsigned> getCacheAssociativity(unsigned Level) const;\n\n  /// Return the target cache line size in bytes at a given level.\n  ///\n  virtual Optional<unsigned> getCacheLineSize(unsigned Level) const;\n\n  /// Return the target cache line size in bytes.  By default, return\n  /// the line size for the bottom-most level of cache.  This provides\n  /// a more convenient interface for the common case where all cache\n  /// levels have the same line size.  Return zero if there is no\n  /// cache model.\n  ///\n  virtual unsigned getCacheLineSize() const {\n    Optional<unsigned> Size = getCacheLineSize(0);\n    if (Size)\n      return *Size;\n\n    return 0;\n  }\n\n  /// Return the preferred prefetch distance in terms of instructions.\n  ///\n  virtual unsigned getPrefetchDistance() const;\n\n  /// Return the maximum prefetch distance in terms of loop\n  /// iterations.\n  ///\n  virtual unsigned getMaxPrefetchIterationsAhead() const;\n\n  /// \\return True if prefetching should also be done for writes.\n  ///\n  virtual bool enableWritePrefetching() const;\n\n  /// Return the minimum stride necessary to trigger software\n  /// prefetching.\n  ///\n  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,\n                                        unsigned NumStridedMemAccesses,\n                                        unsigned NumPrefetches,\n                                        bool HasCall) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCSUBTARGETINFO_H\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/PassAnalysisSupport.h", "content": "//===- llvm/PassAnalysisSupport.h - Analysis Pass Support code --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines stuff that is used to define and \"use\" Analysis Passes.\n// This file is automatically #included by Pass.h, so:\n//\n//           NO .CPP FILES SHOULD INCLUDE THIS FILE DIRECTLY\n//\n// Instead, #include Pass.h\n//\n//===----------------------------------------------------------------------===//\n\n#if !defined(LLVM_PASS_H) || defined(LLVM_PASSANALYSISSUPPORT_H)\n#error \"Do not include <PassAnalysisSupport.h>; include <Pass.h> instead\"\n#endif\n\n#ifndef LLVM_PASSANALYSISSUPPORT_H\n#define LLVM_PASSANALYSISSUPPORT_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass Function;\nclass Pass;\nclass PMDataManager;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// Represent the analysis usage information of a pass.  This tracks analyses\n/// that the pass REQUIRES (must be available when the pass runs), REQUIRES\n/// TRANSITIVE (must be available throughout the lifetime of the pass), and\n/// analyses that the pass PRESERVES (the pass does not invalidate the results\n/// of these analyses).  This information is provided by a pass to the Pass\n/// infrastructure through the getAnalysisUsage virtual function.\n///\nclass AnalysisUsage {\npublic:\n  using VectorType = SmallVectorImpl<AnalysisID>;\n\nprivate:\n  /// Sets of analyses required and preserved by a pass\n  // TODO: It's not clear that SmallVector is an appropriate data structure for\n  // this usecase.  The sizes were picked to minimize wasted space, but are\n  // otherwise fairly meaningless.\n  SmallVector<AnalysisID, 8> Required;\n  SmallVector<AnalysisID, 2> RequiredTransitive;\n  SmallVector<AnalysisID, 2> Preserved;\n  SmallVector<AnalysisID, 0> Used;\n  bool PreservesAll = false;\n\n  void pushUnique(VectorType &Set, AnalysisID ID) {\n    if (!llvm::is_contained(Set, ID))\n      Set.push_back(ID);\n  }\n\npublic:\n  AnalysisUsage() = default;\n\n  ///@{\n  /// Add the specified ID to the required set of the usage info for a pass.\n  AnalysisUsage &addRequiredID(const void *ID);\n  AnalysisUsage &addRequiredID(char &ID);\n  template<class PassClass>\n  AnalysisUsage &addRequired() {\n    return addRequiredID(PassClass::ID);\n  }\n\n  AnalysisUsage &addRequiredTransitiveID(char &ID);\n  template<class PassClass>\n  AnalysisUsage &addRequiredTransitive() {\n    return addRequiredTransitiveID(PassClass::ID);\n  }\n  ///@}\n\n  ///@{\n  /// Add the specified ID to the set of analyses preserved by this pass.\n  AnalysisUsage &addPreservedID(const void *ID) {\n    pushUnique(Preserved, ID);\n    return *this;\n  }\n  AnalysisUsage &addPreservedID(char &ID) {\n    pushUnique(Preserved, &ID);\n    return *this;\n  }\n  /// Add the specified Pass class to the set of analyses preserved by this pass.\n  template<class PassClass>\n  AnalysisUsage &addPreserved() {\n    pushUnique(Preserved, &PassClass::ID);\n    return *this;\n  }\n  ///@}\n\n  ///@{\n  /// Add the specified ID to the set of analyses used by this pass if they are\n  /// available..\n  AnalysisUsage &addUsedIfAvailableID(const void *ID) {\n    pushUnique(Used, ID);\n    return *this;\n  }\n  AnalysisUsage &addUsedIfAvailableID(char &ID) {\n    pushUnique(Used, &ID);\n    return *this;\n  }\n  /// Add the specified Pass class to the set of analyses used by this pass.\n  template<class PassClass>\n  AnalysisUsage &addUsedIfAvailable() {\n    pushUnique(Used, &PassClass::ID);\n    return *this;\n  }\n  ///@}\n\n  /// Add the Pass with the specified argument string to the set of analyses\n  /// preserved by this pass. If no such Pass exists, do nothing. This can be\n  /// useful when a pass is trivially preserved, but may not be linked in. Be\n  /// careful about spelling!\n  AnalysisUsage &addPreserved(StringRef Arg);\n\n  /// Set by analyses that do not transform their input at all\n  void setPreservesAll() { PreservesAll = true; }\n\n  /// Determine whether a pass said it does not transform its input at all\n  bool getPreservesAll() const { return PreservesAll; }\n\n  /// This function should be called by the pass, iff they do not:\n  ///\n  ///  1. Add or remove basic blocks from the function\n  ///  2. Modify terminator instructions in any way.\n  ///\n  /// This function annotates the AnalysisUsage info object to say that analyses\n  /// that only depend on the CFG are preserved by this pass.\n  void setPreservesCFG();\n\n  const VectorType &getRequiredSet() const { return Required; }\n  const VectorType &getRequiredTransitiveSet() const {\n    return RequiredTransitive;\n  }\n  const VectorType &getPreservedSet() const { return Preserved; }\n  const VectorType &getUsedSet() const { return Used; }\n};\n\n//===----------------------------------------------------------------------===//\n/// AnalysisResolver - Simple interface used by Pass objects to pull all\n/// analysis information out of pass manager that is responsible to manage\n/// the pass.\n///\nclass AnalysisResolver {\npublic:\n  AnalysisResolver() = delete;\n  explicit AnalysisResolver(PMDataManager &P) : PM(P) {}\n\n  PMDataManager &getPMDataManager() { return PM; }\n\n  /// Find pass that is implementing PI.\n  Pass *findImplPass(AnalysisID PI) {\n    Pass *ResultPass = nullptr;\n    for (const auto &AnalysisImpl : AnalysisImpls) {\n      if (AnalysisImpl.first == PI) {\n        ResultPass = AnalysisImpl.second;\n        break;\n      }\n    }\n    return ResultPass;\n  }\n\n  /// Find pass that is implementing PI. Initialize pass for Function F.\n  std::tuple<Pass *, bool> findImplPass(Pass *P, AnalysisID PI, Function &F);\n\n  void addAnalysisImplsPair(AnalysisID PI, Pass *P) {\n    if (findImplPass(PI) == P)\n      return;\n    std::pair<AnalysisID, Pass*> pir = std::make_pair(PI,P);\n    AnalysisImpls.push_back(pir);\n  }\n\n  /// Clear cache that is used to connect a pass to the analysis (PassInfo).\n  void clearAnalysisImpls() {\n    AnalysisImpls.clear();\n  }\n\n  /// Return analysis result or null if it doesn't exist.\n  Pass *getAnalysisIfAvailable(AnalysisID ID) const;\n\nprivate:\n  /// This keeps track of which passes implements the interfaces that are\n  /// required by the current pass (to implement getAnalysis()).\n  std::vector<std::pair<AnalysisID, Pass *>> AnalysisImpls;\n\n  /// PassManager that is used to resolve analysis info\n  PMDataManager &PM;\n};\n\n/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to\n/// get analysis information that might be around, for example to update it.\n/// This is different than getAnalysis in that it can fail (if the analysis\n/// results haven't been computed), so should only be used if you can handle\n/// the case when the analysis is not available.  This method is often used by\n/// transformation APIs to update analysis results for a pass automatically as\n/// the transform is performed.\ntemplate<typename AnalysisType>\nAnalysisType *Pass::getAnalysisIfAvailable() const {\n  assert(Resolver && \"Pass not resident in a PassManager object!\");\n\n  const void *PI = &AnalysisType::ID;\n\n  Pass *ResultPass = Resolver->getAnalysisIfAvailable(PI);\n  if (!ResultPass) return nullptr;\n\n  // Because the AnalysisType may not be a subclass of pass (for\n  // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially\n  // adjust the return pointer (because the class may multiply inherit, once\n  // from pass, once from AnalysisType).\n  return (AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);\n}\n\n/// getAnalysis<AnalysisType>() - This function is used by subclasses to get\n/// to the analysis information that they claim to use by overriding the\n/// getAnalysisUsage function.\ntemplate<typename AnalysisType>\nAnalysisType &Pass::getAnalysis() const {\n  assert(Resolver && \"Pass has not been inserted into a PassManager object!\");\n  return getAnalysisID<AnalysisType>(&AnalysisType::ID);\n}\n\ntemplate<typename AnalysisType>\nAnalysisType &Pass::getAnalysisID(AnalysisID PI) const {\n  assert(PI && \"getAnalysis for unregistered pass!\");\n  assert(Resolver&&\"Pass has not been inserted into a PassManager object!\");\n  // PI *must* appear in AnalysisImpls.  Because the number of passes used\n  // should be a small number, we just do a linear search over a (dense)\n  // vector.\n  Pass *ResultPass = Resolver->findImplPass(PI);\n  assert(ResultPass &&\n         \"getAnalysis*() called on an analysis that was not \"\n         \"'required' by pass!\");\n\n  // Because the AnalysisType may not be a subclass of pass (for\n  // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially\n  // adjust the return pointer (because the class may multiply inherit, once\n  // from pass, once from AnalysisType).\n  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);\n}\n\n/// getAnalysis<AnalysisType>() - This function is used by subclasses to get\n/// to the analysis information that they claim to use by overriding the\n/// getAnalysisUsage function. If as part of the dependencies, an IR\n/// transformation is triggered (e.g. because the analysis requires\n/// BreakCriticalEdges), and Changed is non null, *Changed is updated.\ntemplate <typename AnalysisType>\nAnalysisType &Pass::getAnalysis(Function &F, bool *Changed) {\n  assert(Resolver &&\"Pass has not been inserted into a PassManager object!\");\n\n  return getAnalysisID<AnalysisType>(&AnalysisType::ID, F, Changed);\n}\n\ntemplate <typename AnalysisType>\nAnalysisType &Pass::getAnalysisID(AnalysisID PI, Function &F, bool *Changed) {\n  assert(PI && \"getAnalysis for unregistered pass!\");\n  assert(Resolver && \"Pass has not been inserted into a PassManager object!\");\n  // PI *must* appear in AnalysisImpls.  Because the number of passes used\n  // should be a small number, we just do a linear search over a (dense)\n  // vector.\n  Pass *ResultPass;\n  bool LocalChanged;\n  std::tie(ResultPass, LocalChanged) = Resolver->findImplPass(this, PI, F);\n\n  assert(ResultPass && \"Unable to find requested analysis info\");\n  if (Changed)\n    *Changed |= LocalChanged;\n  else\n    assert(!LocalChanged &&\n           \"A pass trigged a code update but the update status is lost\");\n\n  // Because the AnalysisType may not be a subclass of pass (for\n  // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially\n  // adjust the return pointer (because the class may multiply inherit, once\n  // from pass, once from AnalysisType).\n  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_PASSANALYSISSUPPORT_H\n"}, "72": {"id": 72, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h", "content": "//==- llvm/Support/ArrayRecycler.h - Recycling of Arrays ---------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ArrayRecycler class template which can recycle small\n// arrays allocated from one of the allocators in Allocator.h\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ARRAYRECYCLER_H\n#define LLVM_SUPPORT_ARRAYRECYCLER_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/MathExtras.h\"\n\nnamespace llvm {\n\n/// Recycle small arrays allocated from a BumpPtrAllocator.\n///\n/// Arrays are allocated in a small number of fixed sizes. For each supported\n/// array size, the ArrayRecycler keeps a free list of available arrays.\n///\ntemplate <class T, size_t Align = alignof(T)> class ArrayRecycler {\n  // The free list for a given array size is a simple singly linked list.\n  // We can't use iplist or Recycler here since those classes can't be copied.\n  struct FreeList {\n    FreeList *Next;\n  };\n\n  static_assert(Align >= alignof(FreeList), \"Object underaligned\");\n  static_assert(sizeof(T) >= sizeof(FreeList), \"Objects are too small\");\n\n  // Keep a free list for each array size.\n  SmallVector<FreeList*, 8> Bucket;\n\n  // Remove an entry from the free list in Bucket[Idx] and return it.\n  // Return NULL if no entries are available.\n  T *pop(unsigned Idx) {\n    if (Idx >= Bucket.size())\n      return nullptr;\n    FreeList *Entry = Bucket[Idx];\n    if (!Entry)\n      return nullptr;\n    __asan_unpoison_memory_region(Entry, Capacity::get(Idx).getSize());\n    Bucket[Idx] = Entry->Next;\n    __msan_allocated_memory(Entry, Capacity::get(Idx).getSize());\n    return reinterpret_cast<T*>(Entry);\n  }\n\n  // Add an entry to the free list at Bucket[Idx].\n  void push(unsigned Idx, T *Ptr) {\n    assert(Ptr && \"Cannot recycle NULL pointer\");\n    FreeList *Entry = reinterpret_cast<FreeList*>(Ptr);\n    if (Idx >= Bucket.size())\n      Bucket.resize(size_t(Idx) + 1);\n    Entry->Next = Bucket[Idx];\n    Bucket[Idx] = Entry;\n    __asan_poison_memory_region(Ptr, Capacity::get(Idx).getSize());\n  }\n\npublic:\n  /// The size of an allocated array is represented by a Capacity instance.\n  ///\n  /// This class is much smaller than a size_t, and it provides methods to work\n  /// with the set of legal array capacities.\n  class Capacity {\n    uint8_t Index;\n    explicit Capacity(uint8_t idx) : Index(idx) {}\n\n  public:\n    Capacity() : Index(0) {}\n\n    /// Get the capacity of an array that can hold at least N elements.\n    static Capacity get(size_t N) {\n      return Capacity(N ? Log2_64_Ceil(N) : 0);\n    }\n\n    /// Get the number of elements in an array with this capacity.\n    size_t getSize() const { return size_t(1u) << Index; }\n\n    /// Get the bucket number for this capacity.\n    unsigned getBucket() const { return Index; }\n\n    /// Get the next larger capacity. Large capacities grow exponentially, so\n    /// this function can be used to reallocate incrementally growing vectors\n    /// in amortized linear time.\n    Capacity getNext() const { return Capacity(Index + 1); }\n  };\n\n  ~ArrayRecycler() {\n    // The client should always call clear() so recycled arrays can be returned\n    // to the allocator.\n    assert(Bucket.empty() && \"Non-empty ArrayRecycler deleted!\");\n  }\n\n  /// Release all the tracked allocations to the allocator. The recycler must\n  /// be free of any tracked allocations before being deleted.\n  template<class AllocatorType>\n  void clear(AllocatorType &Allocator) {\n    for (; !Bucket.empty(); Bucket.pop_back())\n      while (T *Ptr = pop(Bucket.size() - 1))\n        Allocator.Deallocate(Ptr);\n  }\n\n  /// Special case for BumpPtrAllocator which has an empty Deallocate()\n  /// function.\n  ///\n  /// There is no need to traverse the free lists, pulling all the objects into\n  /// cache.\n  void clear(BumpPtrAllocator&) {\n    Bucket.clear();\n  }\n\n  /// Allocate an array of at least the requested capacity.\n  ///\n  /// Return an existing recycled array, or allocate one from Allocator if\n  /// none are available for recycling.\n  ///\n  template<class AllocatorType>\n  T *allocate(Capacity Cap, AllocatorType &Allocator) {\n    // Try to recycle an existing array.\n    if (T *Ptr = pop(Cap.getBucket()))\n      return Ptr;\n    // Nope, get more memory.\n    return static_cast<T*>(Allocator.Allocate(sizeof(T)*Cap.getSize(), Align));\n  }\n\n  /// Deallocate an array with the specified Capacity.\n  ///\n  /// Cap must be the same capacity that was given to allocate().\n  ///\n  void deallocate(Capacity Cap, T *Ptr) {\n    push(Cap.getBucket(), Ptr);\n  }\n};\n\n} // end llvm namespace\n\n#endif\n"}, "73": {"id": 73, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "content": "//===- BranchProbability.h - Branch Probability Wrapper ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Definition of BranchProbability shared by IR and Machine Instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BRANCHPROBABILITY_H\n#define LLVM_SUPPORT_BRANCHPROBABILITY_H\n\n#include \"llvm/Support/DataTypes.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <numeric>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n// This class represents Branch Probability as a non-negative fraction that is\n// no greater than 1. It uses a fixed-point-like implementation, in which the\n// denominator is always a constant value (here we use 1<<31 for maximum\n// precision).\nclass BranchProbability {\n  // Numerator\n  uint32_t N;\n\n  // Denominator, which is a constant value.\n  static constexpr uint32_t D = 1u << 31;\n  static constexpr uint32_t UnknownN = UINT32_MAX;\n\n  // Construct a BranchProbability with only numerator assuming the denominator\n  // is 1<<31. For internal use only.\n  explicit BranchProbability(uint32_t n) : N(n) {}\n\npublic:\n  BranchProbability() : N(UnknownN) {}\n  BranchProbability(uint32_t Numerator, uint32_t Denominator);\n\n  bool isZero() const { return N == 0; }\n  bool isUnknown() const { return N == UnknownN; }\n\n  static BranchProbability getZero() { return BranchProbability(0); }\n  static BranchProbability getOne() { return BranchProbability(D); }\n  static BranchProbability getUnknown() { return BranchProbability(UnknownN); }\n  // Create a BranchProbability object with the given numerator and 1<<31\n  // as denominator.\n  static BranchProbability getRaw(uint32_t N) { return BranchProbability(N); }\n  // Create a BranchProbability object from 64-bit integers.\n  static BranchProbability getBranchProbability(uint64_t Numerator,\n                                                uint64_t Denominator);\n\n  // Normalize given probabilties so that the sum of them becomes approximate\n  // one.\n  template <class ProbabilityIter>\n  static void normalizeProbabilities(ProbabilityIter Begin,\n                                     ProbabilityIter End);\n\n  uint32_t getNumerator() const { return N; }\n  static uint32_t getDenominator() { return D; }\n\n  // Return (1 - Probability).\n  BranchProbability getCompl() const { return BranchProbability(D - N); }\n\n  raw_ostream &print(raw_ostream &OS) const;\n\n  void dump() const;\n\n  /// Scale a large integer.\n  ///\n  /// Scales \\c Num.  Guarantees full precision.  Returns the floor of the\n  /// result.\n  ///\n  /// \\return \\c Num times \\c this.\n  uint64_t scale(uint64_t Num) const;\n\n  /// Scale a large integer by the inverse.\n  ///\n  /// Scales \\c Num by the inverse of \\c this.  Guarantees full precision.\n  /// Returns the floor of the result.\n  ///\n  /// \\return \\c Num divided by \\c this.\n  uint64_t scaleByInverse(uint64_t Num) const;\n\n  BranchProbability &operator+=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    // Saturate the result in case of overflow.\n    N = (uint64_t(N) + RHS.N > D) ? D : N + RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator-=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    // Saturate the result in case of underflow.\n    N = N < RHS.N ? 0 : N - RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator*=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (static_cast<uint64_t>(N) * RHS.N + D / 2) / D;\n    return *this;\n  }\n\n  BranchProbability &operator*=(uint32_t RHS) {\n    assert(N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (uint64_t(N) * RHS > D) ? D : N * RHS;\n    return *this;\n  }\n\n  BranchProbability &operator/=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (static_cast<uint64_t>(N) * D + RHS.N / 2) / RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator/=(uint32_t RHS) {\n    assert(N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    assert(RHS > 0 && \"The divider cannot be zero.\");\n    N /= RHS;\n    return *this;\n  }\n\n  BranchProbability operator+(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob += RHS;\n    return Prob;\n  }\n\n  BranchProbability operator-(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob -= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator*(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob *= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator*(uint32_t RHS) const {\n    BranchProbability Prob(*this);\n    Prob *= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator/(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob /= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator/(uint32_t RHS) const {\n    BranchProbability Prob(*this);\n    Prob /= RHS;\n    return Prob;\n  }\n\n  bool operator==(BranchProbability RHS) const { return N == RHS.N; }\n  bool operator!=(BranchProbability RHS) const { return !(*this == RHS); }\n\n  bool operator<(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return N < RHS.N;\n  }\n\n  bool operator>(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return RHS < *this;\n  }\n\n  bool operator<=(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return !(RHS < *this);\n  }\n\n  bool operator>=(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return !(*this < RHS);\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, BranchProbability Prob) {\n  return Prob.print(OS);\n}\n\ntemplate <class ProbabilityIter>\nvoid BranchProbability::normalizeProbabilities(ProbabilityIter Begin,\n                                               ProbabilityIter End) {\n  if (Begin == End)\n    return;\n\n  unsigned UnknownProbCount = 0;\n  uint64_t Sum = std::accumulate(Begin, End, uint64_t(0),\n                                 [&](uint64_t S, const BranchProbability &BP) {\n                                   if (!BP.isUnknown())\n                                     return S + BP.N;\n                                   UnknownProbCount++;\n                                   return S;\n                                 });\n\n  if (UnknownProbCount > 0) {\n    BranchProbability ProbForUnknown = BranchProbability::getZero();\n    // If the sum of all known probabilities is less than one, evenly distribute\n    // the complement of sum to unknown probabilities. Otherwise, set unknown\n    // probabilities to zeros and continue to normalize known probabilities.\n    if (Sum < BranchProbability::getDenominator())\n      ProbForUnknown = BranchProbability::getRaw(\n          (BranchProbability::getDenominator() - Sum) / UnknownProbCount);\n\n    std::replace_if(Begin, End,\n                    [](const BranchProbability &BP) { return BP.isUnknown(); },\n                    ProbForUnknown);\n\n    if (Sum <= BranchProbability::getDenominator())\n      return;\n  }\n\n  if (Sum == 0) {\n    BranchProbability BP(1, std::distance(Begin, End));\n    std::fill(Begin, End, BP);\n    return;\n  }\n\n  for (auto I = Begin; I != End; ++I)\n    I->N = (I->N * uint64_t(D) + Sum / 2) / Sum;\n}\n\n}\n\n#endif\n"}, "80": {"id": 80, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "content": "//== llvm/Support/LowLevelTypeImpl.h --------------------------- -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// Implement a low-level type suitable for MachineInstr level instruction\n/// selection.\n///\n/// For a type attached to a MachineInstr, we only care about 2 details: total\n/// size and the number of vector lanes (if any). Accordingly, there are 4\n/// possible valid type-kinds:\n///\n///    * `sN` for scalars and aggregates\n///    * `<N x sM>` for vectors, which must have at least 2 elements.\n///    * `pN` for pointers\n///\n/// Other information required for correct selection is expected to be carried\n/// by the opcode, or non-type flags. For example the distinction between G_ADD\n/// and G_FADD for int/float or fast-math flags.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n#define LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include <cassert>\n\nnamespace llvm {\n\nclass DataLayout;\nclass Type;\nclass raw_ostream;\n\nclass LLT {\npublic:\n  /// Get a low-level scalar or aggregate \"bag of bits\".\n  static LLT scalar(unsigned SizeInBits) {\n    assert(SizeInBits > 0 && \"invalid scalar size\");\n    return LLT{/*isPointer=*/false, /*isVector=*/false, /*NumElements=*/0,\n               SizeInBits, /*AddressSpace=*/0};\n  }\n\n  /// Get a low-level pointer in the given address space.\n  static LLT pointer(unsigned AddressSpace, unsigned SizeInBits) {\n    assert(SizeInBits > 0 && \"invalid pointer size\");\n    return LLT{/*isPointer=*/true, /*isVector=*/false, /*NumElements=*/0,\n               SizeInBits, AddressSpace};\n  }\n\n  /// Get a low-level vector of some number of elements and element width.\n  /// \\p NumElements must be at least 2.\n  static LLT vector(uint16_t NumElements, unsigned ScalarSizeInBits) {\n    assert(NumElements > 1 && \"invalid number of vector elements\");\n    assert(ScalarSizeInBits > 0 && \"invalid vector element size\");\n    return LLT{/*isPointer=*/false, /*isVector=*/true, NumElements,\n               ScalarSizeInBits, /*AddressSpace=*/0};\n  }\n\n  /// Get a low-level vector of some number of elements and element type.\n  static LLT vector(uint16_t NumElements, LLT ScalarTy) {\n    assert(NumElements > 1 && \"invalid number of vector elements\");\n    assert(!ScalarTy.isVector() && \"invalid vector element type\");\n    return LLT{ScalarTy.isPointer(), /*isVector=*/true, NumElements,\n               ScalarTy.getSizeInBits(),\n               ScalarTy.isPointer() ? ScalarTy.getAddressSpace() : 0};\n  }\n\n  static LLT scalarOrVector(uint16_t NumElements, LLT ScalarTy) {\n    return NumElements == 1 ? ScalarTy : LLT::vector(NumElements, ScalarTy);\n  }\n\n  static LLT scalarOrVector(uint16_t NumElements, unsigned ScalarSize) {\n    return scalarOrVector(NumElements, LLT::scalar(ScalarSize));\n  }\n\n  explicit LLT(bool isPointer, bool isVector, uint16_t NumElements,\n               unsigned SizeInBits, unsigned AddressSpace) {\n    init(isPointer, isVector, NumElements, SizeInBits, AddressSpace);\n  }\n  explicit LLT() : IsPointer(false), IsVector(false), RawData(0) {}\n\n  explicit LLT(MVT VT);\n\n  bool isValid() const { return RawData != 0; }\n\n  bool isScalar() const { return isValid() && !IsPointer && !IsVector; }\n\n  bool isPointer() const { return isValid() && IsPointer && !IsVector; }\n\n  bool isVector() const { return isValid() && IsVector; }\n\n  /// Returns the number of elements in a vector LLT. Must only be called on\n  /// vector types.\n  uint16_t getNumElements() const {\n    assert(IsVector && \"cannot get number of elements on scalar/aggregate\");\n    if (!IsPointer)\n      return getFieldValue(VectorElementsFieldInfo);\n    else\n      return getFieldValue(PointerVectorElementsFieldInfo);\n  }\n\n  /// Returns the total size of the type. Must only be called on sized types.\n  unsigned getSizeInBits() const {\n    if (isPointer() || isScalar())\n      return getScalarSizeInBits();\n    return getScalarSizeInBits() * getNumElements();\n  }\n\n  /// Returns the total size of the type in bytes, i.e. number of whole bytes\n  /// needed to represent the size in bits. Must only be called on sized types.\n  unsigned getSizeInBytes() const {\n    return (getSizeInBits() + 7) / 8;\n  }\n\n  LLT getScalarType() const {\n    return isVector() ? getElementType() : *this;\n  }\n\n  /// If this type is a vector, return a vector with the same number of elements\n  /// but the new element type. Otherwise, return the new element type.\n  LLT changeElementType(LLT NewEltTy) const {\n    return isVector() ? LLT::vector(getNumElements(), NewEltTy) : NewEltTy;\n  }\n\n  /// If this type is a vector, return a vector with the same number of elements\n  /// but the new element size. Otherwise, return the new element type. Invalid\n  /// for pointer types. For pointer types, use changeElementType.\n  LLT changeElementSize(unsigned NewEltSize) const {\n    assert(!getScalarType().isPointer() &&\n           \"invalid to directly change element size for pointers\");\n    return isVector() ? LLT::vector(getNumElements(), NewEltSize)\n                      : LLT::scalar(NewEltSize);\n  }\n\n  /// Return a vector or scalar with the same element type and the new number of\n  /// elements.\n  LLT changeNumElements(unsigned NewNumElts) const {\n    return LLT::scalarOrVector(NewNumElts, getScalarType());\n  }\n\n  /// Return a type that is \\p Factor times smaller. Reduces the number of\n  /// elements if this is a vector, or the bitwidth for scalar/pointers. Does\n  /// not attempt to handle cases that aren't evenly divisible.\n  LLT divide(int Factor) const {\n    assert(Factor != 1);\n    if (isVector()) {\n      assert(getNumElements() % Factor == 0);\n      return scalarOrVector(getNumElements() / Factor, getElementType());\n    }\n\n    assert(getSizeInBits() % Factor == 0);\n    return scalar(getSizeInBits() / Factor);\n  }\n\n  bool isByteSized() const { return (getSizeInBits() & 7) == 0; }\n\n  unsigned getScalarSizeInBits() const {\n    assert(RawData != 0 && \"Invalid Type\");\n    if (!IsVector) {\n      if (!IsPointer)\n        return getFieldValue(ScalarSizeFieldInfo);\n      else\n        return getFieldValue(PointerSizeFieldInfo);\n    } else {\n      if (!IsPointer)\n        return getFieldValue(VectorSizeFieldInfo);\n      else\n        return getFieldValue(PointerVectorSizeFieldInfo);\n    }\n  }\n\n  unsigned getAddressSpace() const {\n    assert(RawData != 0 && \"Invalid Type\");\n    assert(IsPointer && \"cannot get address space of non-pointer type\");\n    if (!IsVector)\n      return getFieldValue(PointerAddressSpaceFieldInfo);\n    else\n      return getFieldValue(PointerVectorAddressSpaceFieldInfo);\n  }\n\n  /// Returns the vector's element type. Only valid for vector types.\n  LLT getElementType() const {\n    assert(isVector() && \"cannot get element type of scalar/aggregate\");\n    if (IsPointer)\n      return pointer(getAddressSpace(), getScalarSizeInBits());\n    else\n      return scalar(getScalarSizeInBits());\n  }\n\n  void print(raw_ostream &OS) const;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    print(dbgs());\n    dbgs() << '\\n';\n  }\n#endif\n\n  bool operator==(const LLT &RHS) const {\n    return IsPointer == RHS.IsPointer && IsVector == RHS.IsVector &&\n           RHS.RawData == RawData;\n  }\n\n  bool operator!=(const LLT &RHS) const { return !(*this == RHS); }\n\n  friend struct DenseMapInfo<LLT>;\n  friend class GISelInstProfileBuilder;\n\nprivate:\n  /// LLT is packed into 64 bits as follows:\n  /// isPointer : 1\n  /// isVector  : 1\n  /// with 62 bits remaining for Kind-specific data, packed in bitfields\n  /// as described below. As there isn't a simple portable way to pack bits\n  /// into bitfields, here the different fields in the packed structure is\n  /// described in static const *Field variables. Each of these variables\n  /// is a 2-element array, with the first element describing the bitfield size\n  /// and the second element describing the bitfield offset.\n  typedef int BitFieldInfo[2];\n  ///\n  /// This is how the bitfields are packed per Kind:\n  /// * Invalid:\n  ///   gets encoded as RawData == 0, as that is an invalid encoding, since for\n  ///   valid encodings, SizeInBits/SizeOfElement must be larger than 0.\n  /// * Non-pointer scalar (isPointer == 0 && isVector == 0):\n  ///   SizeInBits: 32;\n  static const constexpr BitFieldInfo ScalarSizeFieldInfo{32, 0};\n  /// * Pointer (isPointer == 1 && isVector == 0):\n  ///   SizeInBits: 16;\n  ///   AddressSpace: 24;\n  static const constexpr BitFieldInfo PointerSizeFieldInfo{16, 0};\n  static const constexpr BitFieldInfo PointerAddressSpaceFieldInfo{\n      24, PointerSizeFieldInfo[0] + PointerSizeFieldInfo[1]};\n  /// * Vector-of-non-pointer (isPointer == 0 && isVector == 1):\n  ///   NumElements: 16;\n  ///   SizeOfElement: 32;\n  static const constexpr BitFieldInfo VectorElementsFieldInfo{16, 0};\n  static const constexpr BitFieldInfo VectorSizeFieldInfo{\n      32, VectorElementsFieldInfo[0] + VectorElementsFieldInfo[1]};\n  /// * Vector-of-pointer (isPointer == 1 && isVector == 1):\n  ///   NumElements: 16;\n  ///   SizeOfElement: 16;\n  ///   AddressSpace: 24;\n  static const constexpr BitFieldInfo PointerVectorElementsFieldInfo{16, 0};\n  static const constexpr BitFieldInfo PointerVectorSizeFieldInfo{\n      16,\n      PointerVectorElementsFieldInfo[1] + PointerVectorElementsFieldInfo[0]};\n  static const constexpr BitFieldInfo PointerVectorAddressSpaceFieldInfo{\n      24, PointerVectorSizeFieldInfo[1] + PointerVectorSizeFieldInfo[0]};\n\n  uint64_t IsPointer : 1;\n  uint64_t IsVector : 1;\n  uint64_t RawData : 62;\n\n  static uint64_t getMask(const BitFieldInfo FieldInfo) {\n    const int FieldSizeInBits = FieldInfo[0];\n    return (((uint64_t)1) << FieldSizeInBits) - 1;\n  }\n  static uint64_t maskAndShift(uint64_t Val, uint64_t Mask, uint8_t Shift) {\n    assert(Val <= Mask && \"Value too large for field\");\n    return (Val & Mask) << Shift;\n  }\n  static uint64_t maskAndShift(uint64_t Val, const BitFieldInfo FieldInfo) {\n    return maskAndShift(Val, getMask(FieldInfo), FieldInfo[1]);\n  }\n  uint64_t getFieldValue(const BitFieldInfo FieldInfo) const {\n    return getMask(FieldInfo) & (RawData >> FieldInfo[1]);\n  }\n\n  void init(bool IsPointer, bool IsVector, uint16_t NumElements,\n            unsigned SizeInBits, unsigned AddressSpace) {\n    this->IsPointer = IsPointer;\n    this->IsVector = IsVector;\n    if (!IsVector) {\n      if (!IsPointer)\n        RawData = maskAndShift(SizeInBits, ScalarSizeFieldInfo);\n      else\n        RawData = maskAndShift(SizeInBits, PointerSizeFieldInfo) |\n                  maskAndShift(AddressSpace, PointerAddressSpaceFieldInfo);\n    } else {\n      assert(NumElements > 1 && \"invalid number of vector elements\");\n      if (!IsPointer)\n        RawData = maskAndShift(NumElements, VectorElementsFieldInfo) |\n                  maskAndShift(SizeInBits, VectorSizeFieldInfo);\n      else\n        RawData =\n            maskAndShift(NumElements, PointerVectorElementsFieldInfo) |\n            maskAndShift(SizeInBits, PointerVectorSizeFieldInfo) |\n            maskAndShift(AddressSpace, PointerVectorAddressSpaceFieldInfo);\n    }\n  }\n\n  uint64_t getUniqueRAWLLTData() const {\n    return ((uint64_t)RawData) << 2 | ((uint64_t)IsPointer) << 1 |\n           ((uint64_t)IsVector);\n  }\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const LLT &Ty) {\n  Ty.print(OS);\n  return OS;\n}\n\ntemplate<> struct DenseMapInfo<LLT> {\n  static inline LLT getEmptyKey() {\n    LLT Invalid;\n    Invalid.IsPointer = true;\n    return Invalid;\n  }\n  static inline LLT getTombstoneKey() {\n    LLT Invalid;\n    Invalid.IsVector = true;\n    return Invalid;\n  }\n  static inline unsigned getHashValue(const LLT &Ty) {\n    uint64_t Val = Ty.getUniqueRAWLLTData();\n    return DenseMapInfo<uint64_t>::getHashValue(Val);\n  }\n  static bool isEqual(const LLT &LHS, const LLT &RHS) {\n    return LHS == RHS;\n  }\n};\n\n}\n\n#endif // LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n"}, "82": {"id": 82, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Recycler.h", "content": "//==- llvm/Support/Recycler.h - Recycling Allocator --------------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the Recycler class template.  See the doxygen comment for\n// Recycler for more details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_RECYCLER_H\n#define LLVM_SUPPORT_RECYCLER_H\n\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// PrintRecyclingAllocatorStats - Helper for RecyclingAllocator for\n/// printing statistics.\n///\nvoid PrintRecyclerStats(size_t Size, size_t Align, size_t FreeListSize);\n\n/// Recycler - This class manages a linked-list of deallocated nodes\n/// and facilitates reusing deallocated memory in place of allocating\n/// new memory.\n///\ntemplate <class T, size_t Size = sizeof(T), size_t Align = alignof(T)>\nclass Recycler {\n  struct FreeNode {\n    FreeNode *Next;\n  };\n\n  /// List of nodes that have deleted contents and are not in active use.\n  FreeNode *FreeList = nullptr;\n\n  FreeNode *pop_val() {\n    auto *Val = FreeList;\n    __asan_unpoison_memory_region(Val, Size);\n    FreeList = FreeList->Next;\n    __msan_allocated_memory(Val, Size);\n    return Val;\n  }\n\n  void push(FreeNode *N) {\n    N->Next = FreeList;\n    FreeList = N;\n    __asan_poison_memory_region(N, Size);\n  }\n\npublic:\n  ~Recycler() {\n    // If this fails, either the callee has lost track of some allocation,\n    // or the callee isn't tracking allocations and should just call\n    // clear() before deleting the Recycler.\n    assert(!FreeList && \"Non-empty recycler deleted!\");\n  }\n\n  /// clear - Release all the tracked allocations to the allocator. The\n  /// recycler must be free of any tracked allocations before being\n  /// deleted; calling clear is one way to ensure this.\n  template<class AllocatorType>\n  void clear(AllocatorType &Allocator) {\n    while (FreeList) {\n      T *t = reinterpret_cast<T *>(pop_val());\n      Allocator.Deallocate(t);\n    }\n  }\n\n  /// Special case for BumpPtrAllocator which has an empty Deallocate()\n  /// function.\n  ///\n  /// There is no need to traverse the free list, pulling all the objects into\n  /// cache.\n  void clear(BumpPtrAllocator &) { FreeList = nullptr; }\n\n  template<class SubClass, class AllocatorType>\n  SubClass *Allocate(AllocatorType &Allocator) {\n    static_assert(alignof(SubClass) <= Align,\n                  \"Recycler allocation alignment is less than object align!\");\n    static_assert(sizeof(SubClass) <= Size,\n                  \"Recycler allocation size is less than object size!\");\n    return FreeList ? reinterpret_cast<SubClass *>(pop_val())\n                    : static_cast<SubClass *>(Allocator.Allocate(Size, Align));\n  }\n\n  template<class AllocatorType>\n  T *Allocate(AllocatorType &Allocator) {\n    return Allocate<T>(Allocator);\n  }\n\n  template<class SubClass, class AllocatorType>\n  void Deallocate(AllocatorType & /*Allocator*/, SubClass* Element) {\n    push(reinterpret_cast<FreeNode *>(Element));\n  }\n\n  void PrintStats();\n};\n\ntemplate <class T, size_t Size, size_t Align>\nvoid Recycler<T, Size, Align>::PrintStats() {\n  size_t S = 0;\n  for (auto *I = FreeList; I; I = I->Next)\n    ++S;\n  PrintRecyclerStats(Size, Align, S);\n}\n\n}\n\n#endif\n"}, "84": {"id": 84, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TimeProfiler.h", "content": "//===- llvm/Support/TimeProfiler.h - Hierarchical Time Profiler -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TIMEPROFILER_H\n#define LLVM_SUPPORT_TIMEPROFILER_H\n\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nstruct TimeTraceProfiler;\nTimeTraceProfiler *getTimeTraceProfilerInstance();\n\n/// Initialize the time trace profiler.\n/// This sets up the global \\p TimeTraceProfilerInstance\n/// variable to be the profiler instance.\nvoid timeTraceProfilerInitialize(unsigned TimeTraceGranularity,\n                                 StringRef ProcName);\n\n/// Cleanup the time trace profiler, if it was initialized.\nvoid timeTraceProfilerCleanup();\n\n/// Finish a time trace profiler running on a worker thread.\nvoid timeTraceProfilerFinishThread();\n\n/// Is the time trace profiler enabled, i.e. initialized?\ninline bool timeTraceProfilerEnabled() {\n  return getTimeTraceProfilerInstance() != nullptr;\n}\n\n/// Write profiling data to output stream.\n/// Data produced is JSON, in Chrome \"Trace Event\" format, see\n/// https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview\nvoid timeTraceProfilerWrite(raw_pwrite_stream &OS);\n\n/// Write profiling data to a file.\n/// The function will write to \\p PreferredFileName if provided, if not\n/// then will write to \\p FallbackFileName appending .time-trace.\n/// Returns a StringError indicating a failure if the function is\n/// unable to open the file for writing.\nError timeTraceProfilerWrite(StringRef PreferredFileName,\n                             StringRef FallbackFileName);\n\n/// Manually begin a time section, with the given \\p Name and \\p Detail.\n/// Profiler copies the string data, so the pointers can be given into\n/// temporaries. Time sections can be hierarchical; every Begin must have a\n/// matching End pair but they can nest.\nvoid timeTraceProfilerBegin(StringRef Name, StringRef Detail);\nvoid timeTraceProfilerBegin(StringRef Name,\n                            llvm::function_ref<std::string()> Detail);\n\n/// Manually end the last time section.\nvoid timeTraceProfilerEnd();\n\n/// The TimeTraceScope is a helper class to call the begin and end functions\n/// of the time trace profiler.  When the object is constructed, it begins\n/// the section; and when it is destroyed, it stops it. If the time profiler\n/// is not initialized, the overhead is a single branch.\nstruct TimeTraceScope {\n\n  TimeTraceScope() = delete;\n  TimeTraceScope(const TimeTraceScope &) = delete;\n  TimeTraceScope &operator=(const TimeTraceScope &) = delete;\n  TimeTraceScope(TimeTraceScope &&) = delete;\n  TimeTraceScope &operator=(TimeTraceScope &&) = delete;\n\n  TimeTraceScope(StringRef Name) {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerBegin(Name, StringRef(\"\"));\n  }\n  TimeTraceScope(StringRef Name, StringRef Detail) {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerBegin(Name, Detail);\n  }\n  TimeTraceScope(StringRef Name, llvm::function_ref<std::string()> Detail) {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerBegin(Name, Detail);\n  }\n  ~TimeTraceScope() {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerEnd();\n  }\n};\n\n} // end namespace llvm\n\n#endif\n"}, "92": {"id": 92, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h", "content": "//===-- llvm/CodeGen/DIEHash.h - Dwarf Hashing Framework -------*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for DWARF4 hashing of DIEs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DIEHASH_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DIEHASH_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/Support/MD5.h\"\n\nnamespace llvm {\n\nclass AsmPrinter;\n\n/// An object containing the capability of hashing and adding hash\n/// attributes onto a DIE.\nclass DIEHash {\n  // Collection of all attributes used in hashing a particular DIE.\n  struct DIEAttrs {\n#define HANDLE_DIE_HASH_ATTR(NAME) DIEValue NAME;\n#include \"DIEHashAttributes.def\"\n  };\n\npublic:\n  DIEHash(AsmPrinter *A = nullptr, DwarfCompileUnit *CU = nullptr)\n      : AP(A), CU(CU) {}\n\n  /// Computes the CU signature.\n  uint64_t computeCUSignature(StringRef DWOName, const DIE &Die);\n\n  /// Computes the type signature.\n  uint64_t computeTypeSignature(const DIE &Die);\n\n  // Helper routines to process parts of a DIE.\nprivate:\n  /// Adds the parent context of \\param Parent to the hash.\n  void addParentContext(const DIE &Parent);\n\n  /// Adds the attributes of \\param Die to the hash.\n  void addAttributes(const DIE &Die);\n\n  /// Computes the full DWARF4 7.27 hash of the DIE.\n  void computeHash(const DIE &Die);\n\n  // Routines that add DIEValues to the hash.\npublic:\n  /// Adds \\param Value to the hash.\n  void update(uint8_t Value) { Hash.update(Value); }\n\n  /// Encodes and adds \\param Value to the hash as a ULEB128.\n  void addULEB128(uint64_t Value);\n\n  /// Encodes and adds \\param Value to the hash as a SLEB128.\n  void addSLEB128(int64_t Value);\n\nprivate:\n  /// Adds \\param Str to the hash and includes a NULL byte.\n  void addString(StringRef Str);\n\n  /// Collects the attributes of DIE \\param Die into the \\param Attrs\n  /// structure.\n  void collectAttributes(const DIE &Die, DIEAttrs &Attrs);\n\n  /// Hashes the attributes in \\param Attrs in order.\n  void hashAttributes(const DIEAttrs &Attrs, dwarf::Tag Tag);\n\n  /// Hashes the data in a block like DIEValue, e.g. DW_FORM_block or\n  /// DW_FORM_exprloc.\n  void hashBlockData(const DIE::const_value_range &Values);\n\n  /// Hashes the contents pointed to in the .debug_loc section.\n  void hashLocList(const DIELocList &LocList);\n\n  /// Hashes an individual attribute.\n  void hashAttribute(const DIEValue &Value, dwarf::Tag Tag);\n\n  /// Hashes an attribute that refers to another DIE.\n  void hashDIEEntry(dwarf::Attribute Attribute, dwarf::Tag Tag,\n                    const DIE &Entry);\n\n  /// Hashes a reference to a named type in such a way that is\n  /// independent of whether that type is described by a declaration or a\n  /// definition.\n  void hashShallowTypeReference(dwarf::Attribute Attribute, const DIE &Entry,\n                                StringRef Name);\n\n  /// Hashes a reference to a previously referenced type DIE.\n  void hashRepeatedTypeReference(dwarf::Attribute Attribute,\n                                 unsigned DieNumber);\n\n  void hashNestedType(const DIE &Die, StringRef Name);\n\nprivate:\n  MD5 Hash;\n  AsmPrinter *AP;\n  DwarfCompileUnit *CU;\n  DenseMap<const DIE *, unsigned> Numbering;\n};\n}\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 12, "file": 5, "line": 907}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 5, "line": 907}, "message": "default constructor 'SmallDenseMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "9e11f14536cec5aff6a770c5e0a8ac85", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 5, "line": 916}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 5, "line": 916}, "message": "move constructor 'SmallDenseMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "cbf4c281f20005b5d5d6adb91429d19d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 7, "line": 530}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 7, "line": 530}, "message": "default constructor 'FoldingSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "6b0c6bc1a952715188d53b3c4ccf132c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 14, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 14, "line": 86}, "message": "default constructor 'StorageT' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "02d6a575caf32934d2228290445138ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 14, "line": 96}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 14, "line": 96}, "message": "default constructor 'PointerSumType<TagT, MemberTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "3296ad3a4b5fdcff4fa1652ce529a85e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 17, "line": 55}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 17, "line": 55}, "message": "default constructor 'SetVector<T, Vector, Set>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "e1f1b39645c029108d8d9baef413d452", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 271}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 17, "line": 271}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "60212b9c0440f2710987f3837be6f3b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 17, "line": 310}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 17, "line": 310}, "message": "default constructor 'SmallSetVector<T, N>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "122d9a47975a6265763e34541a2539c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 17, "line": 326}, "message": "mark 'noexcept'"}, {"location": {"col": 1, "file": 17, "line": 326}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "70d1dfe1043d085dbb013ab8de87f68f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 17, "line": 333}, "message": "mark 'noexcept'"}, {"location": {"col": 1, "file": 17, "line": 333}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "50ac2ff4efc4cf6595f01354daa01b15", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 57}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 57}, "message": "destructor '~SmallSetIterator<T, N, C>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "18d0a2b91dfb207f347ada9eca3e9731", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 73}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 73}, "message": "move constructor 'SmallSetIterator<T, N, C>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "98fbd27661f6313bc2b3962d52e1584c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 19, "line": 96}, "message": "mark 'noexcept'"}, {"location": {"col": 21, "file": 19, "line": 96}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "3c7de47cd6d459d11821210fdbc83cf8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 153}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 153}, "message": "default constructor 'SmallSet<T, N, C>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "ff5301d5f5d696f21bd564dd3a0038b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 20, "line": 28}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 20, "line": 28}, "message": "default constructor 'SmallString<N>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallString.h", "reportHash": "b5ca7cfe65ef7418ba5943032c26efc3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 56}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 56}, "message": "default constructor 'SparseBitVectorElement<ElementSize>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "6aa968d26219179c9933e14c30a601aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 22, "line": 394}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 22, "line": 394}, "message": "default constructor 'SparseBitVectorIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "1d6ae2cc9a1d3c679fc4b0abb52d1f8f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 443}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 443}, "message": "default constructor 'SparseBitVector<ElementSize>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "47454d4a61f3cd4f892c2a450d16b940", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 447}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 447}, "message": "move constructor 'SparseBitVector<ElementSize>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "757e5d7f675075b30049e92616e6d597", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 22, "line": 464}, "message": "mark 'noexcept'"}, {"location": {"col": 20, "file": 22, "line": 464}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "561839c8fc3fbe09f99c063993da6a36", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 195}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 195}, "message": "default constructor 'iplist_impl<IntrusiveListT, TraitsT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "ee967b8d2fefe848a7ecb0408c177fe8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 200}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 200}, "message": "move constructor 'iplist_impl<IntrusiveListT, TraitsT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "274637311d05bcfd1d2647d245d1d29f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 29, "line": 203}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 29, "line": 203}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "766db5f9aa84a071a8aeffa7313d8703", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 210}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 210}, "message": "destructor '~iplist_impl<IntrusiveListT, TraitsT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "a224cb37cc7f1c517a7afd457f2a2d96", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 223}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 29, "line": 223}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "7007871331ad9f41c0d7722ae3778724", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 395}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 395}, "message": "default constructor 'iplist<T, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "f49c6309a94b68fcc50543900045c9aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 400}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 400}, "message": "move constructor 'iplist<T, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "866afae75e9a8d74a59b3ce62bc323d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 29, "line": 401}, "message": "mark 'noexcept'"}, {"location": {"col": 11, "file": 29, "line": 401}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "d4d8ae4d24e9718e7738e60a693ee496", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 415}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 29, "line": 415}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "ef2e9b5a3b98ccd3dd158e7499ce6365", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 30, "line": 86}, "message": "default constructor 'ilist_iterator<OptionsT, IsReverse, IsConst>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h", "reportHash": "6d2cdc458064631aac7b372f968d9117", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 102}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 102}, "message": "default constructor 'simple_ilist<T, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "reportHash": "e4ef897286097b289f8ef598a0717967", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 103}, "message": "destructor '~simple_ilist<T, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "reportHash": "648682fea4b45d6ceb1522958fba8ad3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 110}, "message": "move constructor 'simple_ilist<T, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "reportHash": "d8e785274cd8b8fc02bd97ec9ac04dbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 33, "line": 111}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 33, "line": 111}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "reportHash": "04ad57aff23eff23da059512c25ac17e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 156}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 33, "line": 156}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "reportHash": "cdcd33be4bd313c091d3837bc3e0ccf0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 34, "line": 198}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 34, "line": 198}, "message": "default constructor 'AccelTable<DataT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "73f1ba59388445851c72f68e1317984e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 318}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 318}, "message": "default constructor 'DIEEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "dd0340e6aa0ab7b9962b33e3cedf098c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 518}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 518}, "message": "default constructor 'IntrusiveBackListNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "eae0d07c82911c943b0f7ef573efdf09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 35, "line": 598}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 35, "line": 598}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "cd63aa409a4482153b5de9509890d921", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 35, "line": 618}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 35, "line": 618}, "message": "default constructor 'const_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "73c6cc4325dada0f646d1ef35ad4e9cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 763}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 763}, "message": "default constructor 'DIE' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "dd735c50a20e6d0d49decdef9a97635f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 765}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 765}, "message": "move constructor 'DIE' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "700d80b00ec1ae7555c9e908abe51135", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 767}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 35, "line": 767}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "b496603eca5889534b60503a4f22d001", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 889}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 889}, "message": "move constructor 'DIEUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "0725b92deec3c2ff8c6307aa12245a93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 891}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 35, "line": 891}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "e7dea0ac616b08aed893340f77d8b41f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 111}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 36, "line": 111}, "message": "default constructor 'MachineFunctionProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "reportHash": "cb1463bf5325e3c1932ed3e0bb88f1cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 111}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 36, "line": 111}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "reportHash": "40480ec783073d24aca61d0ed132a37f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 111}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 36, "line": 111}, "message": "move constructor 'MachineFunctionProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "reportHash": "24761af505df694eeed8c850ae5f0911", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 37, "line": 159}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 37, "line": 159}, "message": "default constructor 'MachineInstrBundleIterator<Ty, IsReverse>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "a94d7a9f0940d763fe6d84c4cea85449", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 38, "line": 62}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 38, "line": 62}, "message": "default constructor 'MachinePointerInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "reportHash": "aa1b33c700e7bfb898842966850e670a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 39, "line": 166}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 39, "line": 166}, "message": "default constructor 'ContentsUnion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h", "reportHash": "c41429e72b1eb15468f82f2f083ec4ff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 40, "line": 36}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 40, "line": 36}, "message": "default constructor 'MachinePassRegistryListener<PassCtorTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h", "reportHash": "3fa3ebae8604ec8ffdf829d1deed06a9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 40, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 11, "file": 40, "line": 37}, "message": "destructor '~MachinePassRegistryListener<PassCtorTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h", "reportHash": "094241c86b35fbfd77c5283d6253890b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 40, "line": 142}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 40, "line": 142}, "message": "destructor '~RegisterPassParser<RegistryClass>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h", "reportHash": "8acba6c5b3d9530dce614a83f86e9ea1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 41, "line": 23}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 41, "line": 23}, "message": "default constructor 'Register' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "10d67b4e1f872d61f7e0dfddd1d580bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 42, "line": 75}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 42, "line": 75}, "message": "default constructor 'TargetSubtargetInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h", "reportHash": "4dfcbaa6f2e6b3f7654ecbb1b49ae9b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 43, "line": 327}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 43, "line": 327}, "message": "default constructor 'phi_iterator_impl<PHINodeT, BBIteratorT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "reportHash": "6ba60e2eddf50fd86d8f5931e5ba71e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 42}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 42}, "message": "move constructor 'Comdat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Comdat.h", "reportHash": "ef8526ac6dc8b5acffa22fe2bf66801b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 53}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 53}, "message": "default constructor 'Comdat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Comdat.h", "reportHash": "dc6cef08fe664fcd80e87e8d3512ad47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 45, "line": 551}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 45, "line": 551}, "message": "destructor '~ChecksumInfo<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "769726652dbfbfed1f7767a6b300ce55", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 26}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 26}, "message": "default constructor 'DiagnosticHandler' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h", "reportHash": "29510dd99165909cefd9f604f787c8a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 47, "line": 289}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 47, "line": 289}, "message": "default constructor 'ProfileCount' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Function.h", "reportHash": "194a211a5b1319b8baace9ab149b48b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 48, "line": 49}, "message": "'llvm/IR/IntrinsicEnums.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "reportHash": "66fd43c8c64831667bf194039dfffe87", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 3, "file": 49, "line": 71}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 49, "line": 71}, "message": "default constructor 'LLVMContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/LLVMContext.h", "reportHash": "5178f6d708e08b01d99bae32045e195f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 612}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 612}, "message": "default constructor 'MDString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "5f3644a6b8387192f9ec04c1120fea12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 50, "line": 616}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 50, "line": 616}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "7731fd984b4025f731421e084f98be6c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 745}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 745}, "message": "move constructor 'MDOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "2856e32b43d2a92fd4cae08e989a2c15", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 50, "line": 747}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 50, "line": 747}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "400d5db39b131124db586aa6e35b2c58", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 809}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 809}, "message": "default constructor 'ContextAndReplaceableUses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "8e321aa6876590bd395b754927dbc1ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 810}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 810}, "message": "move constructor 'ContextAndReplaceableUses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "8261c4b6dd05045ebc5ac1331d91556f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 50, "line": 812}, "message": "mark 'noexcept'"}, {"location": {"col": 30, "file": 50, "line": 812}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "26c6bfc287068c7d3f9be640c00fd273", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 1253}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 1253}, "message": "default constructor 'TypedMDOperandIterator<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "cfdb1e0d0518d2bbd19c555bf059c112", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 1281}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 1281}, "message": "default constructor 'MDTupleTypedArrayWrapper<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "884de96c345f5e53877601dd51ffdd19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 1345}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 1345}, "message": "default constructor 'DistinctMDOperandPlaceholder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "45053a89cef434c514bd8d8e8df58f3c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 1346}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 1346}, "message": "move constructor 'DistinctMDOperandPlaceholder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "69884273c5972891c21d3633e8c126fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 50, "line": 1402}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 50, "line": 1402}, "message": "default constructor 'op_iterator_impl<T1, T2>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "8b7b079723a7bde1dad82fd9bcef037b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 51, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 51, "line": 86}, "message": "default constructor 'PassInstrumentationCallbacks' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h", "reportHash": "75e2c4e34464baee9f5025bfec54d980", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 51, "line": 189}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 51, "line": 189}, "message": "default constructor 'PassInstrumentation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h", "reportHash": "a45bea8ede0d666ef1e3ed92ed76f176", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 52, "line": 472}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 52, "line": 472}, "message": "default constructor 'PassManager<IRUnitT, AnalysisManagerT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "73ea754e5f84168bae53c2a1de9e1ebf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 52, "line": 478}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 52, "line": 478}, "message": "move constructor 'PassManager<IRUnitT, AnalysisManagerT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "99ee9abb8e34df13cb665eb604e9640b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 52, "line": 482}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 52, "line": 482}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "61fa8f6eb7e44255edd71db74e600aea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 52, "line": 613}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 52, "line": 613}, "message": "default constructor 'PassInstrumentationAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "30443d2f41c09d62fbf25de760306e08", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 52, "line": 751}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 52, "line": 751}, "message": "default constructor 'AnalysisManager<IRUnitT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "b0919408684821540e0f5333e48c5c98", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 52, "line": 752}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 52, "line": 752}, "message": "move constructor 'AnalysisManager<IRUnitT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "6795b2400417f5cc90c378623b39b070", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 52, "line": 753}, "message": "mark 'noexcept'"}, {"location": {"col": 20, "file": 52, "line": 753}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "a913c896f3b0e7d56daae10942aa4ea6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 52, "line": 977}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 52, "line": 977}, "message": "move constructor 'Result' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "8fb6b06cbdece4abb0798127854411a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 52, "line": 984}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 52, "line": 984}, "message": "destructor '~Result' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "cfb993d79f39e9867c8da423d673b743", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 52, "line": 994}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 52, "line": 994}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "d24ef1f99ae80305099e81d52dbec50e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 53, "line": 39}, "message": "mark 'noexcept'"}, {"location": {"col": 11, "file": 53, "line": 39}, "message": "destructor '~PassConcept<IRUnitT, AnalysisManagerT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "57ae577bb123a2bbbf892d18fdf28432", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 71}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 71}, "message": "move constructor 'PassModel<IRUnitT, PassT, PreservedAnalysesT, AnalysisManagerT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "d2c88c3f0a2fc802854f39444fdd5f43", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 53, "line": 73}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 53, "line": 73}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "fad781af29e9ff2fc620578e2455ffc1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 53, "line": 115}, "message": "mark 'noexcept'"}, {"location": {"col": 11, "file": 53, "line": 115}, "message": "destructor '~AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "dd4b1bd8ee13b41b4f1015a23f8f3536", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 195}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 195}, "message": "move constructor 'AnalysisResultModel<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, false>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "9b8d314d1c60b7d06f66137673389dc0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 53, "line": 198}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 53, "line": 198}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "63949c2089b1a15efb37913ac11de802", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 234}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 234}, "message": "move constructor 'AnalysisResultModel<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, true>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "634d80f4b89158bd92cd7c9e91aaf20f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 53, "line": 237}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 53, "line": 237}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "63949c2089b1a15efb37913ac11de802", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 53, "line": 263}, "message": "mark 'noexcept'"}, {"location": {"col": 11, "file": 53, "line": 263}, "message": "destructor '~AnalysisPassConcept<IRUnitT, PreservedAnalysesT, InvalidatorT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "f144a3d074dbb2dd53f142b8abcb2f28", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 290}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 290}, "message": "move constructor 'AnalysisPassModel<IRUnitT, PassT, PreservedAnalysesT, InvalidatorT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "d721a4c7aff7337826d2c253e736423f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 53, "line": 292}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 53, "line": 292}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "a66b8ae0ef8b9d895ba164aedebe6234", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 73}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 73}, "message": "default constructor 'SymbolTableListTraits<ValueSubClass>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/SymbolTableListTraits.h", "reportHash": "badbb87cbf585156f2d82c2f3c99f4f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 32}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 32}, "message": "move constructor 'TrackingMDRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "7bb1061956fb2357947c4af715415821", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 55, "line": 35}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 55, "line": 35}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "fd35f8f68d57ca5838b891323efa05f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 110}, "message": "default constructor 'TypedTrackingMDRef<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "1c6464566cf8632619f536c2b69e6196", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 113}, "message": "move constructor 'TypedTrackingMDRef<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "435a05a717e689e1b014b71e0eed1c68", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 55, "line": 116}, "message": "mark 'noexcept'"}, {"location": {"col": 23, "file": 55, "line": 116}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "a00c286f3754a920666af344900ee697", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 56, "line": 50}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 56, "line": 50}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Use.h", "reportHash": "d09bc3d6831a66732505015d33ffdc5f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 57, "line": 254}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 57, "line": 254}, "message": "default constructor 'value_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "reportHash": "56a01c31d2b87d25523e055cf70f3c34", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 57, "line": 274}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 57, "line": 274}, "message": "default constructor 'const_value_op_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/User.h", "reportHash": "eb3340873dad638a4d702e24f6f13981", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 58, "line": 135}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 58, "line": 135}, "message": "default constructor 'use_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "8da3a5efe91c74716fd772a4ceeec161", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 58, "line": 135}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 58, "line": 135}, "message": "default constructor 'use_iterator_impl<UseT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "1b49d41516b0baac54dee844255ccf69", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 58, "line": 172}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 58, "line": 172}, "message": "default constructor 'user_iterator_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "f5405359dd0117f3db471f8675ef2080", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 58, "line": 172}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 58, "line": 172}, "message": "default constructor 'user_iterator_impl<UserTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "a8e1e26d34f8d2569271579810736618", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 146}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 146}, "message": "default constructor 'WeakVH' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "reportHash": "07050234f7b3c28b6345e15e32979d24", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 206}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 206}, "message": "default constructor 'WeakTrackingVH' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "reportHash": "d922290a71894cc6742fd82d53d8f196", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 288}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 288}, "message": "default constructor 'AssertingVH<ValueTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "reportHash": "f6c3c6ec979ccda79523bf64185368e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 360}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 360}, "message": "default constructor 'TrackingVH<ValueTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "reportHash": "e6a0d80137ed563f6224d79c99ea68c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 395}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 395}, "message": "default constructor 'CallbackVH' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "reportHash": "7c25701389982172bf7483f680f099ff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 497}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 497}, "message": "default constructor 'PoisoningVH<ValueTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueHandle.h", "reportHash": "d78bbd708f4fbec41c67b44b719c512b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 60, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 60, "line": 103}, "message": "default constructor 'ValueMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "adbf8ed92a87976bf566d617d7697737", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 60, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 60, "line": 103}, "message": "default constructor 'ValueMap<KeyT, ValueT, Config>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "15272a3ebe1c3e66ca382fa2f4d1737d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 60, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 60, "line": 110}, "message": "move constructor 'ValueMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "2df2d069291c6273a6ab8a847e93e90a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 60, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 60, "line": 110}, "message": "move constructor 'ValueMap<KeyT, ValueT, Config>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "41c273be9633a3f3d6dba9a1b58fa97a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 60, "line": 112}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 60, "line": 112}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "bdff69e840c2ef51fe0513fdfe0dd7e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 60, "line": 337}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 60, "line": 337}, "message": "default constructor 'ValueMapIterator<DenseMapT, KeyT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "46af1760355099e876fd349234831449", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 60, "line": 389}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 60, "line": 389}, "message": "default constructor 'ValueMapConstIterator<DenseMapT, KeyT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "4183c790fec64fe81603664c5c0c31b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 64, "line": 27}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 64, "line": 27}, "message": "default constructor 'MCRegister' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "be79cf69d69dddcfbf92e1db2c0f8766", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 65, "line": 253}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 65, "line": 253}, "message": "default constructor 'mc_difflist_iterator<SubT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "c4d5ba99d0a5bedc0a8ab52a76f6acb2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 66, "line": 101}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 66, "line": 101}, "message": "default constructor 'MCSubtargetInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "reportHash": "7920ec06582951a2c6a693eb45e86850", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 66, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 20, "file": 66, "line": 103}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "reportHash": "fd4ef3dd1fa97e3af631e9beb2fba411", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 69, "line": 159}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 69, "line": 159}, "message": "default constructor 'AnalysisResolver' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/PassAnalysisSupport.h", "reportHash": "0a45aaab3329056c572f98a825010256", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 72, "line": 76}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 72, "line": 76}, "message": "default constructor 'Capacity' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h", "reportHash": "b8861da236dce977bf0267755ff83d01", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 72, "line": 95}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 72, "line": 95}, "message": "destructor '~ArrayRecycler<T, Align>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h", "reportHash": "bec0a0758c3236fe73ddc194b4ab3c2a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 73, "line": 43}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 73, "line": 43}, "message": "default constructor 'BranchProbability' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "b6507f7e55250cdb485a4018a8c0f021", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 80, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 80, "line": 86}, "message": "default constructor 'LLT' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "reportHash": "374d7047369dd150ef53a3d841ca8455", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 82, "line": 57}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 82, "line": 57}, "message": "destructor '~Recycler<T, Size, Align>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Recycler.h", "reportHash": "88fdccfa2a9668b5b4096c5e4ee043dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 84, "line": 67}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 84, "line": 67}, "message": "default constructor 'TimeTraceScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TimeProfiler.h", "reportHash": "fe1c560fe8f89567d0a0d8ea00382f91", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 84, "line": 70}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 84, "line": 70}, "message": "move constructor 'TimeTraceScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TimeProfiler.h", "reportHash": "4ecf1124de6aa74c1b93c2fe2725683b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 84, "line": 71}, "message": "mark 'noexcept'"}, {"location": {"col": 19, "file": 84, "line": 71}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TimeProfiler.h", "reportHash": "c903e615073d715ebda4e1b136d7cb78", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 92, "line": 34}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 92, "line": 34}, "message": "default constructor 'DIEHash' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h", "reportHash": "553f19367c4a926f18f5340d1649f485", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
