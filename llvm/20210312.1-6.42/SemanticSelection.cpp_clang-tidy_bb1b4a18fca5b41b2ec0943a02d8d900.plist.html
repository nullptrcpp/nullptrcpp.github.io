<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ParsedAST.h", "content": "//===--- ParsedAST.h - Building translation units ----------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file exposes building a file as if it were open in clangd, and defines\n// the ParsedAST structure that holds the results.\n//\n// This is similar to a clang -fsyntax-only run that produces a clang AST, but\n// we have several customizations:\n//  - preamble handling\n//  - capturing diagnostics for later access\n//  - running clang-tidy checks checks\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PARSEDAST_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PARSEDAST_H\n\n#include \"CollectMacros.h\"\n#include \"Compiler.h\"\n#include \"Diagnostics.h\"\n#include \"Headers.h\"\n#include \"HeuristicResolver.h\"\n#include \"Preamble.h\"\n#include \"index/CanonicalIncludes.h\"\n#include \"support/Path.h\"\n#include \"clang/Frontend/FrontendAction.h\"\n#include \"clang/Frontend/PrecompiledPreamble.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\nclass SymbolIndex;\n\n/// Stores and provides access to parsed AST.\nclass ParsedAST {\npublic:\n  /// Attempts to run Clang and store the parsed AST.\n  /// If \\p Preamble is non-null it is reused during parsing.\n  /// This function does not check if preamble is valid to reuse.\n  static llvm::Optional<ParsedAST>\n  build(llvm::StringRef Filename, const ParseInputs &Inputs,\n        std::unique_ptr<clang::CompilerInvocation> CI,\n        llvm::ArrayRef<Diag> CompilerInvocationDiags,\n        std::shared_ptr<const PreambleData> Preamble);\n\n  ParsedAST(ParsedAST &&Other);\n  ParsedAST &operator=(ParsedAST &&Other);\n\n  ~ParsedAST();\n\n  /// Note that the returned ast will not contain decls from the preamble that\n  /// were not deserialized during parsing. Clients should expect only decls\n  /// from the main file to be in the AST.\n  ASTContext &getASTContext();\n  const ASTContext &getASTContext() const;\n\n  Preprocessor &getPreprocessor();\n  std::shared_ptr<Preprocessor> getPreprocessorPtr();\n  const Preprocessor &getPreprocessor() const;\n\n  SourceManager &getSourceManager() {\n    return getASTContext().getSourceManager();\n  }\n  const SourceManager &getSourceManager() const {\n    return getASTContext().getSourceManager();\n  }\n\n  const LangOptions &getLangOpts() const {\n    return getASTContext().getLangOpts();\n  }\n\n  /// This function returns top-level decls present in the main file of the AST.\n  /// The result does not include the decls that come from the preamble.\n  /// (These should be const, but RecursiveASTVisitor requires Decl*).\n  ArrayRef<Decl *> getLocalTopLevelDecls();\n\n  const std::vector<Diag> &getDiagnostics() const;\n\n  /// Returns the estimated size of the AST and the accessory structures, in\n  /// bytes. Does not include the size of the preamble.\n  std::size_t getUsedBytes() const;\n  const IncludeStructure &getIncludeStructure() const;\n  const CanonicalIncludes &getCanonicalIncludes() const;\n\n  /// Gets all macro references (definition, expansions) present in the main\n  /// file, including those in the preamble region.\n  const MainFileMacros &getMacros() const;\n  /// Tokens recorded while parsing the main file.\n  /// (!) does not have tokens from the preamble.\n  const syntax::TokenBuffer &getTokens() const { return Tokens; }\n\n  /// Returns the version of the ParseInputs this AST was built from.\n  llvm::StringRef version() const { return Version; }\n\n  /// Returns the version of the ParseInputs used to build Preamble part of this\n  /// AST. Might be None if no Preamble is used.\n  llvm::Optional<llvm::StringRef> preambleVersion() const;\n\n  const HeuristicResolver *getHeuristicResolver() const {\n    return Resolver.get();\n  }\n\nprivate:\n  ParsedAST(llvm::StringRef Version,\n            std::shared_ptr<const PreambleData> Preamble,\n            std::unique_ptr<CompilerInstance> Clang,\n            std::unique_ptr<FrontendAction> Action, syntax::TokenBuffer Tokens,\n            MainFileMacros Macros, std::vector<Decl *> LocalTopLevelDecls,\n            std::vector<Diag> Diags, IncludeStructure Includes,\n            CanonicalIncludes CanonIncludes);\n\n  std::string Version;\n  // In-memory preambles must outlive the AST, it is important that this member\n  // goes before Clang and Action.\n  std::shared_ptr<const PreambleData> Preamble;\n  // We store an \"incomplete\" FrontendAction (i.e. no EndSourceFile was called\n  // on it) and CompilerInstance used to run it. That way we don't have to do\n  // complex memory management of all Clang structures on our own. (They are\n  // stored in CompilerInstance and cleaned up by\n  // FrontendAction.EndSourceFile).\n  std::unique_ptr<CompilerInstance> Clang;\n  std::unique_ptr<FrontendAction> Action;\n  /// Tokens recorded after the preamble finished.\n  ///   - Includes all spelled tokens for the main file.\n  ///   - Includes expanded tokens produced **after** preamble.\n  ///   - Does not have spelled or expanded tokens for files from preamble.\n  syntax::TokenBuffer Tokens;\n\n  /// All macro definitions and expansions in the main file.\n  MainFileMacros Macros;\n  // Data, stored after parsing.\n  std::vector<Diag> Diags;\n  // Top-level decls inside the current file. Not that this does not include\n  // top-level decls from the preamble.\n  std::vector<Decl *> LocalTopLevelDecls;\n  IncludeStructure Includes;\n  CanonicalIncludes CanonIncludes;\n  std::unique_ptr<HeuristicResolver> Resolver;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PARSEDAST_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "content": "//===--- Index.h -------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n\n#include \"Ref.h\"\n#include \"Relation.h\"\n#include \"Symbol.h\"\n#include \"SymbolID.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Support/JSON.h\"\n#include <mutex>\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nstruct FuzzyFindRequest {\n  /// A query string for the fuzzy find. This is matched against symbols'\n  /// un-qualified identifiers and should not contain qualifiers like \"::\".\n  std::string Query;\n  /// If this is non-empty, symbols must be in at least one of the scopes\n  /// (e.g. namespaces) excluding nested scopes. For example, if a scope \"xyz::\"\n  /// is provided, the matched symbols must be defined in namespace xyz but not\n  /// namespace xyz::abc.\n  ///\n  /// The global scope is \"\", a top level scope is \"foo::\", etc.\n  std::vector<std::string> Scopes;\n  /// If set to true, allow symbols from any scope. Scopes explicitly listed\n  /// above will be ranked higher.\n  bool AnyScope = false;\n  /// The number of top candidates to return. The index may choose to\n  /// return more than this, e.g. if it doesn't know which candidates are best.\n  llvm::Optional<uint32_t> Limit;\n  /// If set to true, only symbols for completion support will be considered.\n  bool RestrictForCodeCompletion = false;\n  /// Contextually relevant files (e.g. the file we're code-completing in).\n  /// Paths should be absolute.\n  std::vector<std::string> ProximityPaths;\n  /// Preferred types of symbols. These are raw representation of `OpaqueType`.\n  std::vector<std::string> PreferredTypes;\n\n  bool operator==(const FuzzyFindRequest &Req) const {\n    return std::tie(Query, Scopes, Limit, RestrictForCodeCompletion,\n                    ProximityPaths, PreferredTypes) ==\n           std::tie(Req.Query, Req.Scopes, Req.Limit,\n                    Req.RestrictForCodeCompletion, Req.ProximityPaths,\n                    Req.PreferredTypes);\n  }\n  bool operator!=(const FuzzyFindRequest &Req) const { return !(*this == Req); }\n};\nbool fromJSON(const llvm::json::Value &Value, FuzzyFindRequest &Request,\n              llvm::json::Path);\nllvm::json::Value toJSON(const FuzzyFindRequest &Request);\n\nstruct LookupRequest {\n  llvm::DenseSet<SymbolID> IDs;\n};\n\nstruct RefsRequest {\n  llvm::DenseSet<SymbolID> IDs;\n  RefKind Filter = RefKind::All;\n  /// If set, limit the number of refers returned from the index. The index may\n  /// choose to return less than this, e.g. it tries to avoid returning stale\n  /// results.\n  llvm::Optional<uint32_t> Limit;\n};\n\nstruct RelationsRequest {\n  llvm::DenseSet<SymbolID> Subjects;\n  RelationKind Predicate;\n  /// If set, limit the number of relations returned from the index.\n  llvm::Optional<uint32_t> Limit;\n};\n\n/// Describes what data is covered by an index.\n///\n/// Indexes may contain symbols but not references from a file, etc.\n/// This affects merging: if a staler index contains a reference but a fresher\n/// one does not, we want to trust the fresher index *only* if it actually\n/// includes references in general.\nenum class IndexContents : uint8_t {\n  None = 0,\n  Symbols = 1 << 1,\n  References = 1 << 2,\n  Relations = 1 << 3,\n  All = Symbols | References | Relations\n};\n\ninline constexpr IndexContents operator&(IndexContents L, IndexContents R) {\n  return static_cast<IndexContents>(static_cast<uint8_t>(L) &\n                                    static_cast<uint8_t>(R));\n}\n\ninline constexpr IndexContents operator|(IndexContents L, IndexContents R) {\n  return static_cast<IndexContents>(static_cast<uint8_t>(L) |\n                                    static_cast<uint8_t>(R));\n}\n\n/// Interface for symbol indexes that can be used for searching or\n/// matching symbols among a set of symbols based on names or unique IDs.\nclass SymbolIndex {\npublic:\n  virtual ~SymbolIndex() = default;\n\n  /// Matches symbols in the index fuzzily and applies \\p Callback on\n  /// each matched symbol before returning.\n  /// If returned Symbols are used outside Callback, they must be deep-copied!\n  ///\n  /// Returns true if there may be more results (limited by Req.Limit).\n  virtual bool\n  fuzzyFind(const FuzzyFindRequest &Req,\n            llvm::function_ref<void(const Symbol &)> Callback) const = 0;\n\n  /// Looks up symbols with any of the given symbol IDs and applies \\p Callback\n  /// on each matched symbol.\n  /// The returned symbol must be deep-copied if it's used outside Callback.\n  virtual void\n  lookup(const LookupRequest &Req,\n         llvm::function_ref<void(const Symbol &)> Callback) const = 0;\n\n  /// Finds all occurrences (e.g. references, declarations, definitions) of\n  /// symbols and applies \\p Callback on each result.\n  ///\n  /// Results should be returned in arbitrary order.\n  /// The returned result must be deep-copied if it's used outside Callback.\n  /// FIXME: there's no indication which result references which symbol.\n  ///\n  /// Returns true if there will be more results (limited by Req.Limit);\n  virtual bool refs(const RefsRequest &Req,\n                    llvm::function_ref<void(const Ref &)> Callback) const = 0;\n\n  /// Finds all relations (S, P, O) stored in the index such that S is among\n  /// Req.Subjects and P is Req.Predicate, and invokes \\p Callback for (S, O) in\n  /// each.\n  virtual void relations(\n      const RelationsRequest &Req,\n      llvm::function_ref<void(const SymbolID &Subject, const Symbol &Object)>\n          Callback) const = 0;\n\n  /// Returns function which checks if the specified file was used to build this\n  /// index or not. The function must only be called while the index is alive.\n  virtual llvm::unique_function<IndexContents(llvm::StringRef) const>\n  indexedFiles() const = 0;\n\n  /// Returns estimated size of index (in bytes).\n  virtual size_t estimateMemoryUsage() const = 0;\n};\n\n// Delegating implementation of SymbolIndex whose delegate can be swapped out.\nclass SwapIndex : public SymbolIndex {\npublic:\n  // If an index is not provided, reset() must be called.\n  SwapIndex(std::unique_ptr<SymbolIndex> Index = nullptr)\n      : Index(std::move(Index)) {}\n  void reset(std::unique_ptr<SymbolIndex>);\n\n  // SymbolIndex methods delegate to the current index, which is kept alive\n  // until the call returns (even if reset() is called).\n  bool fuzzyFind(const FuzzyFindRequest &,\n                 llvm::function_ref<void(const Symbol &)>) const override;\n  void lookup(const LookupRequest &,\n              llvm::function_ref<void(const Symbol &)>) const override;\n  bool refs(const RefsRequest &,\n            llvm::function_ref<void(const Ref &)>) const override;\n  void relations(const RelationsRequest &,\n                 llvm::function_ref<void(const SymbolID &, const Symbol &)>)\n      const override;\n\n  llvm::unique_function<IndexContents(llvm::StringRef) const>\n  indexedFiles() const override;\n\n  size_t estimateMemoryUsage() const override;\n\nprivate:\n  std::shared_ptr<SymbolIndex> snapshot() const;\n  mutable std::mutex Mutex;\n  std::shared_ptr<SymbolIndex> Index;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "content": "//===--- Ref.h ---------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <set>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\n/// Describes the kind of a cross-reference.\n///\n/// This is a bitfield which can be combined from different kinds.\nenum class RefKind : uint8_t {\n  Unknown = 0,\n  // Points to symbol declaration. Example:\n  //\n  // class Foo;\n  //       ^ Foo declaration\n  // Foo foo;\n  // ^ this does not reference Foo declaration\n  Declaration = 1 << 0,\n  // Points to symbol definition. Example:\n  //\n  // int foo();\n  //     ^ references foo declaration, but not foo definition\n  // int foo() { return 42; }\n  //     ^ references foo definition, but not declaration\n  // bool bar() { return true; }\n  //      ^ references both definition and declaration\n  Definition = 1 << 1,\n  // Points to symbol reference. Example:\n  //\n  // int Foo = 42;\n  // int Bar = Foo + 1;\n  //           ^ this is a reference to Foo\n  Reference = 1 << 2,\n  // The reference explicitly spells out declaration's name. Such references can\n  // not come from macro expansions or implicit AST nodes.\n  //\n  // class Foo { public: Foo() {} };\n  //       ^ references declaration, definition and explicitly spells out name\n  // #define MACRO Foo\n  //     v there is an implicit constructor call here which is not a spelled ref\n  // Foo foo;\n  // ^ this reference explicitly spells out Foo's name\n  // struct Bar {\n  //   MACRO Internal;\n  //   ^ this references Foo, but does not explicitly spell out its name\n  // };\n  Spelled = 1 << 3,\n  All = Declaration | Definition | Reference | Spelled,\n};\n\ninline RefKind operator|(RefKind L, RefKind R) {\n  return static_cast<RefKind>(static_cast<uint8_t>(L) |\n                              static_cast<uint8_t>(R));\n}\ninline RefKind &operator|=(RefKind &L, RefKind R) { return L = L | R; }\ninline RefKind operator&(RefKind A, RefKind B) {\n  return static_cast<RefKind>(static_cast<uint8_t>(A) &\n                              static_cast<uint8_t>(B));\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, RefKind);\n\n/// Represents a symbol occurrence in the source file.\n/// Despite the name, it could be a declaration/definition/reference.\n///\n/// WARNING: Location does not own the underlying data - Copies are shallow.\nstruct Ref {\n  /// The source location where the symbol is named.\n  SymbolLocation Location;\n  RefKind Kind = RefKind::Unknown;\n  /// The ID of the symbol whose definition contains this reference.\n  /// For example, for a reference inside a function body, this would\n  /// be that function. For top-level definitions this isNull().\n  SymbolID Container;\n};\n\ninline bool operator<(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) <\n         std::tie(R.Location, R.Kind, R.Container);\n}\ninline bool operator==(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) ==\n         std::tie(R.Location, R.Kind, R.Container);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Ref &);\n\n/// An efficient structure of storing large set of symbol references in memory.\n/// Filenames are deduplicated.\nclass RefSlab {\npublic:\n  // Refs are stored in order.\n  using value_type = std::pair<SymbolID, llvm::ArrayRef<Ref>>;\n  using const_iterator = std::vector<value_type>::const_iterator;\n  using iterator = const_iterator;\n\n  RefSlab() = default;\n  RefSlab(RefSlab &&Slab) = default;\n  RefSlab &operator=(RefSlab &&RHS) = default;\n\n  const_iterator begin() const { return Refs.begin(); }\n  const_iterator end() const { return Refs.end(); }\n  /// Gets the number of symbols.\n  size_t size() const { return Refs.size(); }\n  size_t numRefs() const { return NumRefs; }\n  bool empty() const { return Refs.empty(); }\n\n  size_t bytes() const {\n    return sizeof(*this) + Arena.getTotalMemory() +\n           sizeof(value_type) * Refs.capacity();\n  }\n\n  /// RefSlab::Builder is a mutable container that can 'freeze' to RefSlab.\n  class Builder {\n  public:\n    Builder() : UniqueStrings(Arena) {}\n    /// Adds a ref to the slab. Deep copy: Strings will be owned by the slab.\n    void insert(const SymbolID &ID, const Ref &S);\n    /// Consumes the builder to finalize the slab.\n    RefSlab build() &&;\n\n  private:\n    // A ref we're storing with its symbol to consume with build().\n    // All strings are interned, so DenseMapInfo can use pointer comparisons.\n    struct Entry {\n      SymbolID Symbol;\n      Ref Reference;\n    };\n    friend struct llvm::DenseMapInfo<Entry>;\n\n    llvm::BumpPtrAllocator Arena;\n    llvm::UniqueStringSaver UniqueStrings; // Contents on the arena.\n    llvm::DenseSet<Entry> Entries;\n  };\n\nprivate:\n  RefSlab(std::vector<value_type> Refs, llvm::BumpPtrAllocator Arena,\n          size_t NumRefs)\n      : Arena(std::move(Arena)), Refs(std::move(Refs)), NumRefs(NumRefs) {}\n\n  llvm::BumpPtrAllocator Arena;\n  std::vector<value_type> Refs;\n  /// Number of all references.\n  size_t NumRefs = 0;\n};\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct DenseMapInfo<clang::clangd::RefSlab::Builder::Entry> {\n  using Entry = clang::clangd::RefSlab::Builder::Entry;\n  static inline Entry getEmptyKey() {\n    static Entry E{clang::clangd::SymbolID(\"\"), {}};\n    return E;\n  }\n  static inline Entry getTombstoneKey() {\n    static Entry E{clang::clangd::SymbolID(\"TOMBSTONE\"), {}};\n    return E;\n  }\n  static unsigned getHashValue(const Entry &Val) {\n    return llvm::hash_combine(\n        Val.Symbol, reinterpret_cast<uintptr_t>(Val.Reference.Location.FileURI),\n        Val.Reference.Location.Start.rep(), Val.Reference.Location.End.rep());\n  }\n  static bool isEqual(const Entry &LHS, const Entry &RHS) {\n    return std::tie(LHS.Symbol, LHS.Reference.Location.FileURI,\n                    LHS.Reference.Kind) ==\n               std::tie(RHS.Symbol, RHS.Reference.Location.FileURI,\n                        RHS.Reference.Kind) &&\n           LHS.Reference.Location.Start == RHS.Reference.Location.Start &&\n           LHS.Reference.Location.End == RHS.Reference.Location.End;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Symbol.h", "content": "//===--- Symbol.h ------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"SymbolOrigin.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/StringSaver.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// The class presents a C++ symbol, e.g. class, function.\n///\n/// WARNING: Symbols do not own much of their underlying data - typically\n/// strings are owned by a SymbolSlab. They should be treated as non-owning\n/// references. Copies are shallow.\n///\n/// When adding new unowned data fields to Symbol, remember to update:\n///   - SymbolSlab::Builder in Index.cpp, to copy them to the slab's storage.\n///   - mergeSymbol in Merge.cpp, to properly combine two Symbols.\n///\n/// A fully documented symbol can be split as:\n/// size_type std::map<k, t>::count(const K& key) const\n/// | Return  |     Scope     |Name|    Signature     |\n/// We split up these components to allow display flexibility later.\nstruct Symbol {\n  /// The ID of the symbol.\n  SymbolID ID;\n  /// The symbol information, like symbol kind.\n  index::SymbolInfo SymInfo = index::SymbolInfo();\n  /// The unqualified name of the symbol, e.g. \"bar\" (for ns::bar).\n  llvm::StringRef Name;\n  /// The containing namespace. e.g. \"\" (global), \"ns::\" (top-level namespace).\n  llvm::StringRef Scope;\n  /// The location of the symbol's definition, if one was found.\n  /// This just covers the symbol name (e.g. without class/function body).\n  SymbolLocation Definition;\n  /// The location of the preferred declaration of the symbol.\n  /// This just covers the symbol name.\n  /// This may be the same as Definition.\n  ///\n  /// A C++ symbol may have multiple declarations, and we pick one to prefer.\n  ///   * For classes, the canonical declaration should be the definition.\n  ///   * For non-inline functions, the canonical declaration typically appears\n  ///     in the \".h\" file corresponding to the definition.\n  SymbolLocation CanonicalDeclaration;\n  /// The number of translation units that reference this symbol from their main\n  /// file. This number is only meaningful if aggregated in an index.\n  unsigned References = 0;\n  /// Where this symbol came from. Usually an index provides a constant value.\n  SymbolOrigin Origin = SymbolOrigin::Unknown;\n  /// A brief description of the symbol that can be appended in the completion\n  /// candidate list. For example, \"(X x, Y y) const\" is a function signature.\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef Signature;\n  /// Argument list in human-readable format, will be displayed to help\n  /// disambiguate between different specializations of a template. Empty for\n  /// non-specializations. Example: \"<int, bool, 3>\"\n  llvm::StringRef TemplateSpecializationArgs;\n  /// What to insert when completing this symbol, after the symbol name.\n  /// This is in LSP snippet syntax (e.g. \"({$0})\" for a no-args function).\n  /// (When snippets are disabled, the symbol name alone is used).\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef CompletionSnippetSuffix;\n  /// Documentation including comment for the symbol declaration.\n  llvm::StringRef Documentation;\n  /// Type when this symbol is used in an expression. (Short display form).\n  /// e.g. return type of a function, or type of a variable.\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef ReturnType;\n\n  /// Raw representation of the OpaqueType of the symbol, used for scoring\n  /// purposes.\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef Type;\n\n  struct IncludeHeaderWithReferences {\n    IncludeHeaderWithReferences() = default;\n\n    IncludeHeaderWithReferences(llvm::StringRef IncludeHeader,\n                                unsigned References)\n        : IncludeHeader(IncludeHeader), References(References) {}\n\n    /// This can be either a URI of the header to be #include'd\n    /// for this symbol, or a literal header quoted with <> or \"\" that is\n    /// suitable to be included directly. When it is a URI, the exact #include\n    /// path needs to be calculated according to the URI scheme.\n    ///\n    /// Note that the include header is a canonical include for the symbol and\n    /// can be different from FileURI in the CanonicalDeclaration.\n    llvm::StringRef IncludeHeader = \"\";\n    /// The number of translation units that reference this symbol and include\n    /// this header. This number is only meaningful if aggregated in an index.\n    unsigned References = 0;\n  };\n  /// One Symbol can potentially be included via different headers.\n  ///   - If we haven't seen a definition, this covers all declarations.\n  ///   - If we have seen a definition, this covers declarations visible from\n  ///   any definition.\n  /// Only set when the symbol is indexed for completion.\n  llvm::SmallVector<IncludeHeaderWithReferences, 1> IncludeHeaders;\n\n  enum SymbolFlag : uint8_t {\n    None = 0,\n    /// Whether or not this symbol is meant to be used for the code completion.\n    /// See also isIndexedForCodeCompletion().\n    /// Note that we don't store completion information (signature, snippet,\n    /// type, includes) if the symbol is not indexed for code completion.\n    IndexedForCodeCompletion = 1 << 0,\n    /// Indicates if the symbol is deprecated.\n    Deprecated = 1 << 1,\n    /// Symbol is an implementation detail.\n    ImplementationDetail = 1 << 2,\n    /// Symbol is visible to other files (not e.g. a static helper function).\n    VisibleOutsideFile = 1 << 3,\n  };\n\n  SymbolFlag Flags = SymbolFlag::None;\n  /// FIXME: also add deprecation message and fixit?\n};\n\ninline Symbol::SymbolFlag operator|(Symbol::SymbolFlag A,\n                                    Symbol::SymbolFlag B) {\n  return static_cast<Symbol::SymbolFlag>(static_cast<uint8_t>(A) |\n                                         static_cast<uint8_t>(B));\n}\ninline Symbol::SymbolFlag &operator|=(Symbol::SymbolFlag &A,\n                                      Symbol::SymbolFlag B) {\n  return A = A | B;\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Symbol &S);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, Symbol::SymbolFlag);\n\n/// Invokes Callback with each StringRef& contained in the Symbol.\n/// Useful for deduplicating backing strings.\ntemplate <typename Callback> void visitStrings(Symbol &S, const Callback &CB) {\n  CB(S.Name);\n  CB(S.Scope);\n  CB(S.TemplateSpecializationArgs);\n  CB(S.Signature);\n  CB(S.CompletionSnippetSuffix);\n  CB(S.Documentation);\n  CB(S.ReturnType);\n  CB(S.Type);\n  auto RawCharPointerCB = [&CB](const char *&P) {\n    llvm::StringRef S(P);\n    CB(S);\n    assert(!S.data()[S.size()] && \"Visited StringRef must be null-terminated\");\n    P = S.data();\n  };\n  RawCharPointerCB(S.CanonicalDeclaration.FileURI);\n  RawCharPointerCB(S.Definition.FileURI);\n\n  for (auto &Include : S.IncludeHeaders)\n    CB(Include.IncludeHeader);\n}\n\n/// Computes query-independent quality score for a Symbol.\n/// This currently falls in the range [1, ln(#indexed documents)].\n/// FIXME: this should probably be split into symbol -> signals\n///        and signals -> score, so it can be reused for Sema completions.\nfloat quality(const Symbol &S);\n\n/// An immutable symbol container that stores a set of symbols.\n/// The container will maintain the lifetime of the symbols.\nclass SymbolSlab {\npublic:\n  using const_iterator = std::vector<Symbol>::const_iterator;\n  using iterator = const_iterator;\n  using value_type = Symbol;\n\n  SymbolSlab() = default;\n\n  const_iterator begin() const { return Symbols.begin(); }\n  const_iterator end() const { return Symbols.end(); }\n  const_iterator find(const SymbolID &SymID) const;\n\n  using size_type = size_t;\n  size_type size() const { return Symbols.size(); }\n  bool empty() const { return Symbols.empty(); }\n  // Estimates the total memory usage.\n  size_t bytes() const {\n    return sizeof(*this) + Arena.getTotalMemory() +\n           Symbols.capacity() * sizeof(Symbol);\n  }\n\n  /// SymbolSlab::Builder is a mutable container that can 'freeze' to\n  /// SymbolSlab. The frozen SymbolSlab will use less memory.\n  class Builder {\n  public:\n    Builder() : UniqueStrings(Arena) {}\n\n    /// Adds a symbol, overwriting any existing one with the same ID.\n    /// This is a deep copy: underlying strings will be owned by the slab.\n    void insert(const Symbol &S);\n\n    /// Removes the symbol with an ID, if it exists.\n    void erase(const SymbolID &ID) { Symbols.erase(ID); }\n\n    /// Returns the symbol with an ID, if it exists. Valid until insert/remove.\n    const Symbol *find(const SymbolID &ID) {\n      auto I = Symbols.find(ID);\n      return I == Symbols.end() ? nullptr : &I->second;\n    }\n\n    /// Consumes the builder to finalize the slab.\n    SymbolSlab build() &&;\n\n  private:\n    llvm::BumpPtrAllocator Arena;\n    /// Intern table for strings. Contents are on the arena.\n    llvm::UniqueStringSaver UniqueStrings;\n    /// Values are indices into Symbols vector.\n    llvm::DenseMap<SymbolID, Symbol> Symbols;\n  };\n\nprivate:\n  SymbolSlab(llvm::BumpPtrAllocator Arena, std::vector<Symbol> Symbols)\n      : Arena(std::move(Arena)), Symbols(std::move(Symbols)) {}\n\n  llvm::BumpPtrAllocator Arena; // Owns Symbol data that the Symbols do not.\n  std::vector<Symbol> Symbols;  // Sorted by SymbolID to allow lookup.\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "content": "//===--- SymbolLocation.h ----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\nstruct SymbolLocation {\n  // Specify a position (Line, Column) of symbol. Using Line/Column allows us to\n  // build LSP responses without reading the file content.\n  //\n  // clangd uses the following definitions, which differ slightly from LSP:\n  //  - Line is the number of newline characters (\\n) before the point.\n  //  - Column is (by default) the number of UTF-16 code between the last \\n\n  //    (or start of file) and the point.\n  //    If the `offsetEncoding` protocol extension is used to negotiate UTF-8,\n  //    then it is instead the number of *bytes* since the last \\n.\n  //\n  // Position is encoded into 32 bits to save space.\n  // If Line/Column overflow, the value will be their maximum value.\n  struct Position {\n    Position() : LineColumnPacked(0) {}\n    void setLine(uint32_t Line);\n    uint32_t line() const { return LineColumnPacked >> ColumnBits; }\n    void setColumn(uint32_t Column);\n    uint32_t column() const { return LineColumnPacked & MaxColumn; }\n    uint32_t rep() const { return LineColumnPacked; }\n\n    bool hasOverflow() const {\n      return line() == MaxLine || column() == MaxColumn;\n    }\n\n    static constexpr unsigned ColumnBits = 12;\n    static constexpr uint32_t MaxLine = (1 << (32 - ColumnBits)) - 1;\n    static constexpr uint32_t MaxColumn = (1 << ColumnBits) - 1;\n\n  private:\n    uint32_t LineColumnPacked; // Top 20 bit line, bottom 12 bits column.\n  };\n\n  /// The symbol range, using half-open range [Start, End).\n  Position Start;\n  Position End;\n\n  explicit operator bool() const { return !llvm::StringRef(FileURI).empty(); }\n\n  // The URI of the source file where a symbol occurs.\n  // The string must be null-terminated.\n  //\n  // We avoid using llvm::StringRef here to save memory.\n  // WARNING: unless you know what you are doing, it is recommended to use it\n  // via llvm::StringRef.\n  const char *FileURI = \"\";\n};\n\ninline bool operator==(const SymbolLocation::Position &L,\n                       const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) ==\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator<(const SymbolLocation::Position &L,\n                      const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) <\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator==(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  return !std::strcmp(L.FileURI, R.FileURI) &&\n         std::tie(L.Start, L.End) == std::tie(R.Start, R.End);\n}\ninline bool operator<(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  int Cmp = std::strcmp(L.FileURI, R.FileURI);\n  if (Cmp != 0)\n    return Cmp < 0;\n  return std::tie(L.Start, L.End) < std::tie(R.Start, R.End);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolLocation &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "content": "//===--- Context.h - Mechanism for passing implicit data --------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Context for storing and retrieving implicit data. Useful for passing implicit\n// parameters on a per-request basis.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_CONTEXT_H_\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_CONTEXT_H_\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <memory>\n#include <type_traits>\n\nnamespace clang {\nnamespace clangd {\n\n/// Values in a Context are indexed by typed keys.\n/// Key<T> serves two purposes:\n///   - it provides a lookup key for the context (each Key is unique),\n///   - it makes lookup type-safe: a Key<T> can only map to a T (or nothing).\n///\n/// Example:\n///    Key<int> RequestID;\n///    Key<int> Version;\n///\n///    Context Ctx = Context::empty().derive(RequestID, 10).derive(Version, 3);\n///    assert(*Ctx.get(RequestID) == 10);\n///    assert(*Ctx.get(Version) == 3);\n///\n/// Keys are typically used across multiple functions, so most of the time you\n/// would want to make them static class members or global variables.\ntemplate <class Type> class Key {\npublic:\n  static_assert(!std::is_reference<Type>::value,\n                \"Reference arguments to Key<> are not allowed\");\n\n  constexpr Key() = default;\n\n  Key(Key const &) = delete;\n  Key &operator=(Key const &) = delete;\n  Key(Key &&) = delete;\n  Key &operator=(Key &&) = delete;\n};\n\n/// A context is an immutable container for per-request data that must be\n/// propagated through layers that don't care about it. An example is a request\n/// ID that we may want to use when logging.\n///\n/// Conceptually, a context is a heterogeneous map<Key<T>, T>. Each key has\n/// an associated value type, which allows the map to be typesafe.\n///\n/// There is an \"ambient\" context for each thread, Context::current().\n/// Most functions should read from this, and use WithContextValue or\n/// WithContext to extend or replace the context within a block scope.\n/// Only code dealing with threads and extension points should need to use\n/// other Context objects.\n///\n/// You can't add data to an existing context, instead you create a new\n/// immutable context derived from it with extra data added. When you retrieve\n/// data, the context will walk up the parent chain until the key is found.\nclass Context {\npublic:\n  /// Returns an empty root context that contains no data.\n  static Context empty();\n  /// Returns the context for the current thread, creating it if needed.\n  static const Context &current();\n  // Sets the current() context to Replacement, and returns the old context.\n  // Prefer to use WithContext or WithContextValue to do this safely.\n  static Context swapCurrent(Context Replacement);\n\nprivate:\n  struct Data;\n  Context(std::shared_ptr<const Data> DataPtr);\n\npublic:\n  /// Same as Context::empty(), please use Context::empty() instead.\n  Context() = default;\n\n  /// Copy operations for this class are deleted, use an explicit clone() method\n  /// when you need a copy of the context instead.\n  Context(Context const &) = delete;\n  Context &operator=(const Context &) = delete;\n\n  Context(Context &&) = default;\n  Context &operator=(Context &&) = default;\n\n  /// Get data stored for a typed \\p Key. If values are not found\n  /// \\returns Pointer to the data associated with \\p Key. If no data is\n  /// specified for \\p Key, return null.\n  template <class Type> const Type *get(const Key<Type> &Key) const {\n    for (const Data *DataPtr = this->DataPtr.get(); DataPtr != nullptr;\n         DataPtr = DataPtr->Parent.get()) {\n      if (DataPtr->KeyPtr == &Key)\n        return static_cast<const Type *>(DataPtr->Value->getValuePtr());\n    }\n    return nullptr;\n  }\n\n  /// A helper to get a reference to a \\p Key that must exist in the map.\n  /// Must not be called for keys that are not in the map.\n  template <class Type> const Type &getExisting(const Key<Type> &Key) const {\n    auto Val = get(Key);\n    assert(Val && \"Key does not exist\");\n    return *Val;\n  }\n\n  /// Derives a child context\n  /// It is safe to move or destroy a parent context after calling derive().\n  /// The child will keep its parent alive, and its data remains accessible.\n  template <class Type>\n  Context derive(const Key<Type> &Key,\n                 typename std::decay<Type>::type Value) const & {\n    return Context(std::make_shared<Data>(\n        Data{/*Parent=*/DataPtr, &Key,\n             std::make_unique<TypedAnyStorage<typename std::decay<Type>::type>>(\n                 std::move(Value))}));\n  }\n\n  template <class Type>\n  Context\n  derive(const Key<Type> &Key,\n         typename std::decay<Type>::type Value) && /* takes ownership */ {\n    return Context(std::make_shared<Data>(\n        Data{/*Parent=*/std::move(DataPtr), &Key,\n             std::make_unique<TypedAnyStorage<typename std::decay<Type>::type>>(\n                 std::move(Value))}));\n  }\n\n  /// Derives a child context, using an anonymous key.\n  /// Intended for objects stored only for their destructor's side-effect.\n  template <class Type> Context derive(Type &&Value) const & {\n    static Key<typename std::decay<Type>::type> Private;\n    return derive(Private, std::forward<Type>(Value));\n  }\n\n  template <class Type> Context derive(Type &&Value) && {\n    static Key<typename std::decay<Type>::type> Private;\n    return std::move(*this).derive(Private, std::forward<Type>(Value));\n  }\n\n  /// Clone this context object.\n  Context clone() const;\n\nprivate:\n  class AnyStorage {\n  public:\n    virtual ~AnyStorage() = default;\n    virtual void *getValuePtr() = 0;\n  };\n\n  template <class T> class TypedAnyStorage : public Context::AnyStorage {\n    static_assert(std::is_same<typename std::decay<T>::type, T>::value,\n                  \"Argument to TypedAnyStorage must be decayed\");\n\n  public:\n    TypedAnyStorage(T &&Value) : Value(std::move(Value)) {}\n\n    void *getValuePtr() override { return &Value; }\n\n  private:\n    T Value;\n  };\n\n  struct Data {\n    // We need to make sure Parent outlives the Value, so the order of members\n    // is important. We do that to allow classes stored in Context's child\n    // layers to store references to the data in the parent layers.\n    std::shared_ptr<const Data> Parent;\n    const void *KeyPtr;\n    std::unique_ptr<AnyStorage> Value;\n  };\n\n  std::shared_ptr<const Data> DataPtr;\n};\n\n/// WithContext replaces Context::current() with a provided scope.\n/// When the WithContext is destroyed, the original scope is restored.\n/// For extending the current context with new value, prefer WithContextValue.\nclass LLVM_NODISCARD WithContext {\npublic:\n  WithContext(Context C) : Restore(Context::swapCurrent(std::move(C))) {}\n  ~WithContext() { Context::swapCurrent(std::move(Restore)); }\n  WithContext(const WithContext &) = delete;\n  WithContext &operator=(const WithContext &) = delete;\n  WithContext(WithContext &&) = delete;\n  WithContext &operator=(WithContext &&) = delete;\n\nprivate:\n  Context Restore;\n};\n\n/// WithContextValue extends Context::current() with a single value.\n/// When the WithContextValue is destroyed, the original scope is restored.\nclass LLVM_NODISCARD WithContextValue {\npublic:\n  template <typename T>\n  WithContextValue(const Key<T> &K, typename std::decay<T>::type V)\n      : Restore(Context::current().derive(K, std::move(V))) {}\n\n  // Anonymous values can be used for the destructor side-effect.\n  template <typename T>\n  WithContextValue(T &&V)\n      : Restore(Context::current().derive(std::forward<T>(V))) {}\n\nprivate:\n  WithContext Restore;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "content": "//===--- Function.h - Utility callable wrappers  -----------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides utilities for callable objects.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_FUNCTION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_FUNCTION_H\n\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/Support/Error.h\"\n#include <mutex>\n#include <tuple>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\n/// A Callback<T> is a void function that accepts Expected<T>.\n/// This is accepted by ClangdServer functions that logically return T.\ntemplate <typename T>\nusing Callback = llvm::unique_function<void(llvm::Expected<T>)>;\n\n/// An Event<T> allows events of type T to be broadcast to listeners.\ntemplate <typename T> class Event {\npublic:\n  // A Listener is the callback through which events are delivered.\n  using Listener = std::function<void(const T &)>;\n\n  // A subscription defines the scope of when a listener should receive events.\n  // After destroying the subscription, no more events are received.\n  class LLVM_NODISCARD Subscription {\n    Event *Parent;\n    unsigned ListenerID;\n\n    Subscription(Event *Parent, unsigned ListenerID)\n        : Parent(Parent), ListenerID(ListenerID) {}\n    friend Event;\n\n  public:\n    Subscription() : Parent(nullptr) {}\n    Subscription(Subscription &&Other) : Parent(nullptr) {\n      *this = std::move(Other);\n    }\n    Subscription &operator=(Subscription &&Other) {\n      // If *this is active, unsubscribe.\n      if (Parent) {\n        std::lock_guard<std::recursive_mutex> Lock(Parent->ListenersMu);\n        llvm::erase_if(Parent->Listeners,\n                       [&](const std::pair<Listener, unsigned> &P) {\n                         return P.second == ListenerID;\n                       });\n      }\n      // Take over the other subscription, and mark it inactive.\n      std::tie(Parent, ListenerID) = std::tie(Other.Parent, Other.ListenerID);\n      Other.Parent = nullptr;\n      return *this;\n    }\n    // Destroying a subscription may block if an event is being broadcast.\n    ~Subscription() {\n      if (Parent)\n        *this = Subscription(); // Unsubscribe.\n    }\n  };\n\n  // Adds a listener that will observe all future events until the returned\n  // subscription is destroyed.\n  // May block if an event is currently being broadcast.\n  Subscription observe(Listener L) {\n    std::lock_guard<std::recursive_mutex> Lock(ListenersMu);\n    Listeners.push_back({std::move(L), ++ListenerCount});\n    return Subscription(this, ListenerCount);\n  }\n\n  // Synchronously sends an event to all registered listeners.\n  // Must not be called from a listener to this event.\n  void broadcast(const T &V) {\n    // FIXME: it would be nice to dynamically check non-reentrancy here.\n    std::lock_guard<std::recursive_mutex> Lock(ListenersMu);\n    for (const auto &L : Listeners)\n      L.first(V);\n  }\n\n  ~Event() {\n    std::lock_guard<std::recursive_mutex> Lock(ListenersMu);\n    assert(Listeners.empty());\n  }\n\nprivate:\n  static_assert(std::is_same<typename std::decay<T>::type, T>::value,\n                \"use a plain type: event values are always passed by const&\");\n\n  std::recursive_mutex ListenersMu;\n  bool IsBroadcasting = false;\n  std::vector<std::pair<Listener, unsigned>> Listeners;\n  unsigned ListenerCount = 0;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/MemoryTree.h", "content": "//===--- MemoryTree.h - A special tree for components and sizes -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_MEMORYTREE_H_\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_MEMORYTREE_H_\n\n#include \"Trace.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include <cstddef>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// A tree that can be used to represent memory usage of nested components while\n/// preserving the hierarchy.\n/// Edges have associated names. An edge that might not be interesting to all\n/// traversers or costly to copy (e.g. file names) can be marked as \"detail\".\n/// Tree construction allows chosing between a detailed and brief mode, in brief\n/// mode all \"detail\" edges are ignored and tree is constructed without any\n/// string copies.\nstruct MemoryTree {\npublic:\n  /// If Alloc is nullptr, tree is in brief mode and will ignore detail edges.\n  MemoryTree(llvm::BumpPtrAllocator *DetailAlloc = nullptr)\n      : DetailAlloc(DetailAlloc) {}\n\n  /// No copy of the \\p Name.\n  /// Note that returned pointers are invalidated with subsequent calls to\n  /// child/detail.\n  MemoryTree &child(llvm::StringLiteral Name) { return createChild(Name); }\n\n  MemoryTree(const MemoryTree &) = delete;\n  MemoryTree &operator=(const MemoryTree &) = delete;\n\n  MemoryTree(MemoryTree &&) = default;\n  MemoryTree &operator=(MemoryTree &&) = default;\n\n  /// Makes a copy of the \\p Name in detailed mode, returns current node\n  /// otherwise.\n  /// Note that returned pointers are invalidated with subsequent calls to\n  /// child/detail.\n  MemoryTree &detail(llvm::StringRef Name) {\n    return DetailAlloc ? createChild(Name.copy(*DetailAlloc)) : *this;\n  }\n\n  /// Increases size of current node by \\p Increment.\n  void addUsage(size_t Increment) { Size += Increment; }\n\n  /// Returns edges to direct children of this node.\n  const llvm::DenseMap<llvm::StringRef, MemoryTree> &children() const;\n\n  /// Returns total number of bytes used by this sub-tree. Performs a traversal.\n  size_t total() const;\n\n  /// Returns total number of bytes used by this node only.\n  size_t self() const { return Size; }\n\nprivate:\n  /// Adds a child with an edge labeled as \\p Name. Multiple calls to this\n  /// function returns the same node.\n  MemoryTree &createChild(llvm::StringRef Name);\n\n  /// Allocator to use for detailed edge names.\n  llvm::BumpPtrAllocator *DetailAlloc = nullptr;\n\n  /// Bytes owned by this component specifically.\n  size_t Size = 0;\n\n  /// Edges from current node to its children. Keys are the labels for edges.\n  llvm::DenseMap<llvm::StringRef, MemoryTree> Children;\n};\n\n/// Records total memory usage of each node under \\p Out. Labels are edges on\n/// the path joined with \".\", starting with \\p RootName.\nvoid record(const MemoryTree &MT, std::string RootName,\n            const trace::Metric &Out);\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "content": "//===--- Threading.h - Abstractions for multithreading -----------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n\n#include \"support/Context.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <cassert>\n#include <condition_variable>\n#include <future>\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// A threadsafe flag that is initially clear.\nclass Notification {\npublic:\n  // Sets the flag. No-op if already set.\n  void notify();\n  // Blocks until flag is set.\n  void wait() const;\n\nprivate:\n  bool Notified = false;\n  mutable std::condition_variable CV;\n  mutable std::mutex Mu;\n};\n\n/// Limits the number of threads that can acquire the lock at the same time.\nclass Semaphore {\npublic:\n  Semaphore(std::size_t MaxLocks);\n\n  bool try_lock();\n  void lock();\n  void unlock();\n\nprivate:\n  std::mutex Mutex;\n  std::condition_variable SlotsChanged;\n  std::size_t FreeSlots;\n};\n\n/// A point in time we can wait for.\n/// Can be zero (don't wait) or infinity (wait forever).\n/// (Not time_point::max(), because many std::chrono implementations overflow).\nclass Deadline {\npublic:\n  Deadline(std::chrono::steady_clock::time_point Time)\n      : Type(Finite), Time(Time) {}\n  static Deadline zero() { return Deadline(Zero); }\n  static Deadline infinity() { return Deadline(Infinite); }\n\n  std::chrono::steady_clock::time_point time() const {\n    assert(Type == Finite);\n    return Time;\n  }\n  bool expired() const {\n    return (Type == Zero) ||\n           (Type == Finite && Time < std::chrono::steady_clock::now());\n  }\n  bool operator==(const Deadline &Other) const {\n    return (Type == Other.Type) && (Type != Finite || Time == Other.Time);\n  }\n\nprivate:\n  enum Type { Zero, Infinite, Finite };\n\n  Deadline(enum Type Type) : Type(Type) {}\n  enum Type Type;\n  std::chrono::steady_clock::time_point Time;\n};\n\n/// Makes a deadline from a timeout in seconds. None means wait forever.\nDeadline timeoutSeconds(llvm::Optional<double> Seconds);\n/// Wait once on CV for the specified duration.\nvoid wait(std::unique_lock<std::mutex> &Lock, std::condition_variable &CV,\n          Deadline D);\n/// Waits on a condition variable until F() is true or D expires.\ntemplate <typename Func>\nLLVM_NODISCARD bool wait(std::unique_lock<std::mutex> &Lock,\n                         std::condition_variable &CV, Deadline D, Func F) {\n  while (!F()) {\n    if (D.expired())\n      return false;\n    wait(Lock, CV, D);\n  }\n  return true;\n}\n\n/// Runs tasks on separate (detached) threads and wait for all tasks to finish.\n/// Objects that need to spawn threads can own an AsyncTaskRunner to ensure they\n/// all complete on destruction.\nclass AsyncTaskRunner {\npublic:\n  /// Destructor waits for all pending tasks to finish.\n  ~AsyncTaskRunner();\n\n  void wait() const { (void)wait(Deadline::infinity()); }\n  LLVM_NODISCARD bool wait(Deadline D) const;\n  // The name is used for tracing and debugging (e.g. to name a spawned thread).\n  void runAsync(const llvm::Twine &Name, llvm::unique_function<void()> Action);\n\nprivate:\n  mutable std::mutex Mutex;\n  mutable std::condition_variable TasksReachedZero;\n  std::size_t InFlightTasks = 0;\n};\n\n/// Runs \\p Action asynchronously with a new std::thread. The context will be\n/// propagated.\ntemplate <typename T>\nstd::future<T> runAsync(llvm::unique_function<T()> Action) {\n  return std::async(\n      std::launch::async,\n      [](llvm::unique_function<T()> &&Action, Context Ctx) {\n        WithContext WithCtx(std::move(Ctx));\n        return Action();\n      },\n      std::move(Action), Context::current().clone());\n}\n\n/// Memoize is a cache to store and reuse computation results based on a key.\n///\n///   Memoize<DenseMap<int, bool>> PrimeCache;\n///   for (int I : RepetitiveNumbers)\n///     if (PrimeCache.get(I, [&] { return expensiveIsPrime(I); }))\n///       llvm::errs() << \"Prime: \" << I << \"\\n\";\n///\n/// The computation will only be run once for each key.\n/// This class is threadsafe. Concurrent calls for the same key may run the\n/// computation multiple times, but each call will return the same result.\ntemplate <typename Container> class Memoize {\n  mutable Container Cache;\n  std::unique_ptr<std::mutex> Mu;\n\npublic:\n  Memoize() : Mu(std::make_unique<std::mutex>()) {}\n\n  template <typename T, typename Func>\n  typename Container::mapped_type get(T &&Key, Func Compute) const {\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto It = Cache.find(Key);\n      if (It != Cache.end())\n        return It->second;\n    }\n    // Don't hold the mutex while computing.\n    auto V = Compute();\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto R = Cache.try_emplace(std::forward<T>(Key), V);\n      // Insert into cache may fail if we raced with another thread.\n      if (!R.second)\n        return R.first->second; // Canonical value, from other thread.\n    }\n    return V;\n  }\n};\n\n/// Used to guard an operation that should run at most every N seconds.\n///\n/// Usage:\n///   mutable PeriodicThrottler ShouldLog(std::chrono::seconds(1));\n///   void calledFrequently() {\n///     if (ShouldLog())\n///       log(\"this is not spammy\");\n///   }\n///\n/// This class is threadsafe. If multiple threads are involved, then the guarded\n/// operation still needs to be threadsafe!\nclass PeriodicThrottler {\n  using Stopwatch = std::chrono::steady_clock;\n  using Rep = Stopwatch::duration::rep;\n\n  Rep Period;\n  std::atomic<Rep> Next;\n\npublic:\n  /// If Period is zero, the throttler will return true every time.\n  PeriodicThrottler(Stopwatch::duration Period, Stopwatch::duration Delay = {})\n      : Period(Period.count()),\n        Next((Stopwatch::now() + Delay).time_since_epoch().count()) {}\n\n  /// Returns whether the operation should run at this time.\n  /// operator() is safe to call concurrently.\n  bool operator()();\n};\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTConsumer.h", "content": "//===--- ASTConsumer.h - Abstract interface for reading ASTs ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTConsumer class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTCONSUMER_H\n#define LLVM_CLANG_AST_ASTCONSUMER_H\n\nnamespace clang {\n  class ASTContext;\n  class CXXMethodDecl;\n  class CXXRecordDecl;\n  class Decl;\n  class DeclGroupRef;\n  class ASTMutationListener;\n  class ASTDeserializationListener; // layering violation because void* is ugly\n  class SemaConsumer; // layering violation required for safe SemaConsumer\n  class TagDecl;\n  class VarDecl;\n  class FunctionDecl;\n  class ImportDecl;\n\n/// ASTConsumer - This is an abstract interface that should be implemented by\n/// clients that read ASTs.  This abstraction layer allows the client to be\n/// independent of the AST producer (e.g. parser vs AST dump file reader, etc).\nclass ASTConsumer {\n  /// Whether this AST consumer also requires information about\n  /// semantic analysis.\n  bool SemaConsumer;\n\n  friend class SemaConsumer;\n\npublic:\n  ASTConsumer() : SemaConsumer(false) { }\n\n  virtual ~ASTConsumer() {}\n\n  /// Initialize - This is called to initialize the consumer, providing the\n  /// ASTContext.\n  virtual void Initialize(ASTContext &Context) {}\n\n  /// HandleTopLevelDecl - Handle the specified top-level declaration.  This is\n  /// called by the parser to process every top-level Decl*.\n  ///\n  /// \\returns true to continue parsing, or false to abort parsing.\n  virtual bool HandleTopLevelDecl(DeclGroupRef D);\n\n  /// This callback is invoked each time an inline (method or friend)\n  /// function definition in a class is completed.\n  virtual void HandleInlineFunctionDefinition(FunctionDecl *D) {}\n\n  /// HandleInterestingDecl - Handle the specified interesting declaration. This\n  /// is called by the AST reader when deserializing things that might interest\n  /// the consumer. The default implementation forwards to HandleTopLevelDecl.\n  virtual void HandleInterestingDecl(DeclGroupRef D);\n\n  /// HandleTranslationUnit - This method is called when the ASTs for entire\n  /// translation unit have been parsed.\n  virtual void HandleTranslationUnit(ASTContext &Ctx) {}\n\n  /// HandleTagDeclDefinition - This callback is invoked each time a TagDecl\n  /// (e.g. struct, union, enum, class) is completed.  This allows the client to\n  /// hack on the type, which can occur at any point in the file (because these\n  /// can be defined in declspecs).\n  virtual void HandleTagDeclDefinition(TagDecl *D) {}\n\n  /// This callback is invoked the first time each TagDecl is required to\n  /// be complete.\n  virtual void HandleTagDeclRequiredDefinition(const TagDecl *D) {}\n\n  /// Invoked when a function is implicitly instantiated.\n  /// Note that at this point point it does not have a body, its body is\n  /// instantiated at the end of the translation unit and passed to\n  /// HandleTopLevelDecl.\n  virtual void HandleCXXImplicitFunctionInstantiation(FunctionDecl *D) {}\n\n  /// Handle the specified top-level declaration that occurred inside\n  /// and ObjC container.\n  /// The default implementation ignored them.\n  virtual void HandleTopLevelDeclInObjCContainer(DeclGroupRef D);\n\n  /// Handle an ImportDecl that was implicitly created due to an\n  /// inclusion directive.\n  /// The default implementation passes it to HandleTopLevelDecl.\n  virtual void HandleImplicitImportDecl(ImportDecl *D);\n\n  /// CompleteTentativeDefinition - Callback invoked at the end of a translation\n  /// unit to notify the consumer that the given tentative definition should be\n  /// completed.\n  ///\n  /// The variable declaration itself will be a tentative\n  /// definition. If it had an incomplete array type, its type will\n  /// have already been changed to an array of size 1. However, the\n  /// declaration remains a tentative definition and has not been\n  /// modified by the introduction of an implicit zero initializer.\n  virtual void CompleteTentativeDefinition(VarDecl *D) {}\n\n  /// CompleteExternalDeclaration - Callback invoked at the end of a translation\n  /// unit to notify the consumer that the given external declaration should be\n  /// completed.\n  virtual void CompleteExternalDeclaration(VarDecl *D) {}\n\n  /// Callback invoked when an MSInheritanceAttr has been attached to a\n  /// CXXRecordDecl.\n  virtual void AssignInheritanceModel(CXXRecordDecl *RD) {}\n\n  /// HandleCXXStaticMemberVarInstantiation - Tell the consumer that this\n  // variable has been instantiated.\n  virtual void HandleCXXStaticMemberVarInstantiation(VarDecl *D) {}\n\n  /// Callback involved at the end of a translation unit to\n  /// notify the consumer that a vtable for the given C++ class is\n  /// required.\n  ///\n  /// \\param RD The class whose vtable was used.\n  virtual void HandleVTable(CXXRecordDecl *RD) {}\n\n  /// If the consumer is interested in entities getting modified after\n  /// their initial creation, it should return a pointer to\n  /// an ASTMutationListener here.\n  virtual ASTMutationListener *GetASTMutationListener() { return nullptr; }\n\n  /// If the consumer is interested in entities being deserialized from\n  /// AST files, it should return a pointer to a ASTDeserializationListener here\n  virtual ASTDeserializationListener *GetASTDeserializationListener() {\n    return nullptr;\n  }\n\n  /// PrintStats - If desired, print any statistics.\n  virtual void PrintStats() {}\n\n  /// This callback is called for each function if the Parser was\n  /// initialized with \\c SkipFunctionBodies set to \\c true.\n  ///\n  /// \\return \\c true if the function's body should be skipped. The function\n  /// body may be parsed anyway if it is needed (for instance, if it contains\n  /// the code completion point or is constexpr).\n  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }\n};\n\n} // end namespace clang.\n\n#endif\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "content": "//===--- ASTTypeTraits.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Provides a dynamic type identifier and a dynamically typed node container\n//  that can be used to store an AST base node at runtime in the same storage in\n//  a type safe way.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTTYPETRAITS_H\n#define LLVM_CLANG_AST_ASTTYPETRAITS_H\n\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\n\n}\n\nnamespace clang {\n\nstruct PrintingPolicy;\n\n/// Defines how we descend a level in the AST when we pass\n/// through expressions.\nenum TraversalKind {\n  /// Will traverse all child nodes.\n  TK_AsIs,\n\n  /// Ignore AST nodes not written in the source\n  TK_IgnoreUnlessSpelledInSource\n};\n\n/// Kind identifier.\n///\n/// It can be constructed from any node kind and allows for runtime type\n/// hierarchy checks.\n/// Use getFromNodeKind<T>() to construct them.\nclass ASTNodeKind {\npublic:\n  /// Empty identifier. It matches nothing.\n  ASTNodeKind() : KindId(NKI_None) {}\n\n  /// Construct an identifier for T.\n  template <class T>\n  static ASTNodeKind getFromNodeKind() {\n    return ASTNodeKind(KindToKindId<T>::Id);\n  }\n\n  /// \\{\n  /// Construct an identifier for the dynamic type of the node\n  static ASTNodeKind getFromNode(const Decl &D);\n  static ASTNodeKind getFromNode(const Stmt &S);\n  static ASTNodeKind getFromNode(const Type &T);\n  static ASTNodeKind getFromNode(const OMPClause &C);\n  /// \\}\n\n  /// Returns \\c true if \\c this and \\c Other represent the same kind.\n  bool isSame(ASTNodeKind Other) const {\n    return KindId != NKI_None && KindId == Other.KindId;\n  }\n\n  /// Returns \\c true only for the default \\c ASTNodeKind()\n  bool isNone() const { return KindId == NKI_None; }\n\n  /// Returns \\c true if \\c this is a base kind of (or same as) \\c Other.\n  /// \\param Distance If non-null, used to return the distance between \\c this\n  /// and \\c Other in the class hierarchy.\n  bool isBaseOf(ASTNodeKind Other, unsigned *Distance = nullptr) const;\n\n  /// String representation of the kind.\n  StringRef asStringRef() const;\n\n  /// Strict weak ordering for ASTNodeKind.\n  bool operator<(const ASTNodeKind &Other) const {\n    return KindId < Other.KindId;\n  }\n\n  /// Return the most derived type between \\p Kind1 and \\p Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedType(ASTNodeKind Kind1, ASTNodeKind Kind2);\n\n  /// Return the most derived common ancestor between Kind1 and Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedCommonAncestor(ASTNodeKind Kind1,\n                                                  ASTNodeKind Kind2);\n\n  ASTNodeKind getCladeKind() const;\n\n  /// Hooks for using ASTNodeKind as a key in a DenseMap.\n  struct DenseMapInfo {\n    // ASTNodeKind() is a good empty key because it is represented as a 0.\n    static inline ASTNodeKind getEmptyKey() { return ASTNodeKind(); }\n    // NKI_NumberOfKinds is not a valid value, so it is good for a\n    // tombstone key.\n    static inline ASTNodeKind getTombstoneKey() {\n      return ASTNodeKind(NKI_NumberOfKinds);\n    }\n    static unsigned getHashValue(const ASTNodeKind &Val) { return Val.KindId; }\n    static bool isEqual(const ASTNodeKind &LHS, const ASTNodeKind &RHS) {\n      return LHS.KindId == RHS.KindId;\n    }\n  };\n\n  /// Check if the given ASTNodeKind identifies a type that offers pointer\n  /// identity. This is useful for the fast path in DynTypedNode.\n  bool hasPointerIdentity() const {\n    return KindId > NKI_LastKindWithoutPointerIdentity;\n  }\n\nprivate:\n  /// Kind ids.\n  ///\n  /// Includes all possible base and derived kinds.\n  enum NodeKindId {\n    NKI_None,\n    NKI_TemplateArgument,\n    NKI_TemplateArgumentLoc,\n    NKI_TemplateName,\n    NKI_NestedNameSpecifierLoc,\n    NKI_QualType,\n    NKI_TypeLoc,\n    NKI_LastKindWithoutPointerIdentity = NKI_TypeLoc,\n    NKI_CXXBaseSpecifier,\n    NKI_CXXCtorInitializer,\n    NKI_NestedNameSpecifier,\n    NKI_Decl,\n#define DECL(DERIVED, BASE) NKI_##DERIVED##Decl,\n#include \"clang/AST/DeclNodes.inc\"\n    NKI_Stmt,\n#define STMT(DERIVED, BASE) NKI_##DERIVED,\n#include \"clang/AST/StmtNodes.inc\"\n    NKI_Type,\n#define TYPE(DERIVED, BASE) NKI_##DERIVED##Type,\n#include \"clang/AST/TypeNodes.inc\"\n    NKI_OMPClause,\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) NKI_##Class,\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n    NKI_NumberOfKinds\n  };\n\n  /// Use getFromNodeKind<T>() to construct the kind.\n  ASTNodeKind(NodeKindId KindId) : KindId(KindId) {}\n\n  /// Returns \\c true if \\c Base is a base kind of (or same as) \\c\n  ///   Derived.\n  /// \\param Distance If non-null, used to return the distance between \\c Base\n  /// and \\c Derived in the class hierarchy.\n  static bool isBaseOf(NodeKindId Base, NodeKindId Derived, unsigned *Distance);\n\n  /// Helper meta-function to convert a kind T to its enum value.\n  ///\n  /// This struct is specialized below for all known kinds.\n  template <class T> struct KindToKindId {\n    static const NodeKindId Id = NKI_None;\n  };\n  template <class T>\n  struct KindToKindId<const T> : KindToKindId<T> {};\n\n  /// Per kind info.\n  struct KindInfo {\n    /// The id of the parent kind, or None if it has no parent.\n    NodeKindId ParentId;\n    /// Name of the kind.\n    const char *Name;\n  };\n  static const KindInfo AllKindInfo[NKI_NumberOfKinds];\n\n  NodeKindId KindId;\n};\n\n#define KIND_TO_KIND_ID(Class)                                                 \\\n  template <> struct ASTNodeKind::KindToKindId<Class> {                        \\\n    static const NodeKindId Id = NKI_##Class;                                  \\\n  };\nKIND_TO_KIND_ID(CXXCtorInitializer)\nKIND_TO_KIND_ID(TemplateArgument)\nKIND_TO_KIND_ID(TemplateArgumentLoc)\nKIND_TO_KIND_ID(TemplateName)\nKIND_TO_KIND_ID(NestedNameSpecifier)\nKIND_TO_KIND_ID(NestedNameSpecifierLoc)\nKIND_TO_KIND_ID(QualType)\nKIND_TO_KIND_ID(TypeLoc)\nKIND_TO_KIND_ID(Decl)\nKIND_TO_KIND_ID(Stmt)\nKIND_TO_KIND_ID(Type)\nKIND_TO_KIND_ID(OMPClause)\nKIND_TO_KIND_ID(CXXBaseSpecifier)\n#define DECL(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Decl)\n#include \"clang/AST/DeclNodes.inc\"\n#define STMT(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED)\n#include \"clang/AST/StmtNodes.inc\"\n#define TYPE(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Type)\n#include \"clang/AST/TypeNodes.inc\"\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) KIND_TO_KIND_ID(Class)\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n#undef KIND_TO_KIND_ID\n\ninline raw_ostream &operator<<(raw_ostream &OS, ASTNodeKind K) {\n  OS << K.asStringRef();\n  return OS;\n}\n\n/// A dynamically typed AST node container.\n///\n/// Stores an AST node in a type safe way. This allows writing code that\n/// works with different kinds of AST nodes, despite the fact that they don't\n/// have a common base class.\n///\n/// Use \\c create(Node) to create a \\c DynTypedNode from an AST node,\n/// and \\c get<T>() to retrieve the node as type T if the types match.\n///\n/// See \\c ASTNodeKind for which node base types are currently supported;\n/// You can create DynTypedNodes for all nodes in the inheritance hierarchy of\n/// the supported base types.\nclass DynTypedNode {\npublic:\n  /// Creates a \\c DynTypedNode from \\c Node.\n  template <typename T>\n  static DynTypedNode create(const T &Node) {\n    return BaseConverter<T>::create(Node);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Returns NULL if the stored node does not have a type that is\n  /// convertible to \\c T.\n  ///\n  /// For types that have identity via their pointer in the AST\n  /// (like \\c Stmt, \\c Decl, \\c Type and \\c NestedNameSpecifier) the returned\n  /// pointer points to the referenced AST node.\n  /// For other types (like \\c QualType) the value is stored directly\n  /// in the \\c DynTypedNode, and the returned pointer points at\n  /// the storage inside DynTypedNode. For those nodes, do not\n  /// use the pointer outside the scope of the DynTypedNode.\n  template <typename T> const T *get() const {\n    return BaseConverter<T>::get(NodeKind, &Storage);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Similar to \\c get(), but asserts that the type is what we are expecting.\n  template <typename T>\n  const T &getUnchecked() const {\n    return BaseConverter<T>::getUnchecked(NodeKind, &Storage);\n  }\n\n  ASTNodeKind getNodeKind() const { return NodeKind; }\n\n  /// Returns a pointer that identifies the stored AST node.\n  ///\n  /// Note that this is not supported by all AST nodes. For AST nodes\n  /// that don't have a pointer-defined identity inside the AST, this\n  /// method returns NULL.\n  const void *getMemoizationData() const {\n    return NodeKind.hasPointerIdentity()\n               ? *reinterpret_cast<void *const *>(&Storage)\n               : nullptr;\n  }\n\n  /// Prints the node to the given output stream.\n  void print(llvm::raw_ostream &OS, const PrintingPolicy &PP) const;\n\n  /// Dumps the node to the given output stream.\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  /// For nodes which represent textual entities in the source code,\n  /// return their SourceRange.  For all other nodes, return SourceRange().\n  SourceRange getSourceRange() const;\n\n  /// @{\n  /// Imposes an order on \\c DynTypedNode.\n  ///\n  /// Supports comparison of nodes that support memoization.\n  /// FIXME: Implement comparison for other node types (currently\n  /// only Stmt, Decl, Type and NestedNameSpecifier return memoization data).\n  bool operator<(const DynTypedNode &Other) const {\n    if (!NodeKind.isSame(Other.NodeKind))\n      return NodeKind < Other.NodeKind;\n\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>().getAsOpaquePtr() <\n             Other.getUnchecked<QualType>().getAsOpaquePtr();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(NodeKind)) {\n      auto TLA = getUnchecked<TypeLoc>();\n      auto TLB = Other.getUnchecked<TypeLoc>();\n      return std::make_pair(TLA.getType().getAsOpaquePtr(),\n                            TLA.getOpaqueData()) <\n             std::make_pair(TLB.getType().getAsOpaquePtr(),\n                            TLB.getOpaqueData());\n    }\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n            NodeKind)) {\n      auto NNSLA = getUnchecked<NestedNameSpecifierLoc>();\n      auto NNSLB = Other.getUnchecked<NestedNameSpecifierLoc>();\n      return std::make_pair(NNSLA.getNestedNameSpecifier(),\n                            NNSLA.getOpaqueData()) <\n             std::make_pair(NNSLB.getNestedNameSpecifier(),\n                            NNSLB.getOpaqueData());\n    }\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() < Other.getMemoizationData();\n  }\n  bool operator==(const DynTypedNode &Other) const {\n    // DynTypedNode::create() stores the exact kind of the node in NodeKind.\n    // If they contain the same node, their NodeKind must be the same.\n    if (!NodeKind.isSame(Other.NodeKind))\n      return false;\n\n    // FIXME: Implement for other types.\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>() == Other.getUnchecked<QualType>();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(NodeKind))\n      return getUnchecked<TypeLoc>() == Other.getUnchecked<TypeLoc>();\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(NodeKind))\n      return getUnchecked<NestedNameSpecifierLoc>() ==\n             Other.getUnchecked<NestedNameSpecifierLoc>();\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() == Other.getMemoizationData();\n  }\n  bool operator!=(const DynTypedNode &Other) const {\n    return !operator==(Other);\n  }\n  /// @}\n\n  /// Hooks for using DynTypedNode as a key in a DenseMap.\n  struct DenseMapInfo {\n    static inline DynTypedNode getEmptyKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      return Node;\n    }\n    static inline DynTypedNode getTombstoneKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return Node;\n    }\n    static unsigned getHashValue(const DynTypedNode &Val) {\n      // FIXME: Add hashing support for the remaining types.\n      if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(Val.NodeKind)) {\n        auto TL = Val.getUnchecked<TypeLoc>();\n        return llvm::hash_combine(TL.getType().getAsOpaquePtr(),\n                                  TL.getOpaqueData());\n      }\n\n      if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n              Val.NodeKind)) {\n        auto NNSL = Val.getUnchecked<NestedNameSpecifierLoc>();\n        return llvm::hash_combine(NNSL.getNestedNameSpecifier(),\n                                  NNSL.getOpaqueData());\n      }\n\n      assert(Val.getMemoizationData());\n      return llvm::hash_value(Val.getMemoizationData());\n    }\n    static bool isEqual(const DynTypedNode &LHS, const DynTypedNode &RHS) {\n      auto Empty = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      auto TombStone = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, Empty) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, Empty)) ||\n             (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, TombStone) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, TombStone)) ||\n             LHS == RHS;\n    }\n  };\n\nprivate:\n  /// Takes care of converting from and to \\c T.\n  template <typename T, typename EnablerT = void> struct BaseConverter;\n\n  /// Converter that uses dyn_cast<T> from a stored BaseT*.\n  template <typename T, typename BaseT> struct DynCastPtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind));\n      return *cast<T>(static_cast<const BaseT *>(\n          *reinterpret_cast<const void *const *>(Storage)));\n    }\n    static DynTypedNode create(const BaseT &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNode(Node);\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T* (by pointer).\n  template <typename T> struct PtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *static_cast<const T *>(\n          *reinterpret_cast<const void *const *>(Storage));\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T (by value).\n  template <typename T> struct ValueConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return reinterpret_cast<const T *>(Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *reinterpret_cast<const T *>(Storage);\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) T(Node);\n      return Result;\n    }\n  };\n\n  ASTNodeKind NodeKind;\n\n  /// Stores the data of the node.\n  ///\n  /// Note that we can store \\c Decls, \\c Stmts, \\c Types,\n  /// \\c NestedNameSpecifiers and \\c CXXCtorInitializer by pointer as they are\n  /// guaranteed to be unique pointers pointing to dedicated storage in the AST.\n  /// \\c QualTypes, \\c NestedNameSpecifierLocs, \\c TypeLocs,\n  /// \\c TemplateArguments and \\c TemplateArgumentLocs on the other hand do not\n  /// have storage or unique pointers and thus need to be stored by value.\n  llvm::AlignedCharArrayUnion<const void *, TemplateArgument,\n                              TemplateArgumentLoc, NestedNameSpecifierLoc,\n                              QualType, TypeLoc>\n      Storage;\n};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Decl, T>::value>>\n    : public DynCastPtrConverter<T, Decl> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Stmt, T>::value>>\n    : public DynCastPtrConverter<T, Stmt> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Type, T>::value>>\n    : public DynCastPtrConverter<T, Type> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<OMPClause, T>::value>>\n    : public DynCastPtrConverter<T, OMPClause> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    NestedNameSpecifier, void> : public PtrConverter<NestedNameSpecifier> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    CXXCtorInitializer, void> : public PtrConverter<CXXCtorInitializer> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TemplateArgument, void> : public ValueConverter<TemplateArgument> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<TemplateArgumentLoc, void>\n    : public ValueConverter<TemplateArgumentLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TemplateName, void> : public ValueConverter<TemplateName> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    NestedNameSpecifierLoc,\n    void> : public ValueConverter<NestedNameSpecifierLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<QualType,\n                                   void> : public ValueConverter<QualType> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TypeLoc, void> : public ValueConverter<TypeLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<CXXBaseSpecifier, void>\n    : public PtrConverter<CXXBaseSpecifier> {};\n\n// The only operation we allow on unsupported types is \\c get.\n// This allows to conveniently use \\c DynTypedNode when having an arbitrary\n// AST node that is not supported, but prevents misuse - a user cannot create\n// a DynTypedNode from arbitrary types.\ntemplate <typename T, typename EnablerT> struct DynTypedNode::BaseConverter {\n  static const T *get(ASTNodeKind NodeKind, const char Storage[]) {\n    return NULL;\n  }\n};\n\n} // end namespace clang\n\nnamespace llvm {\n\ntemplate <>\nstruct DenseMapInfo<clang::ASTNodeKind> : clang::ASTNodeKind::DenseMapInfo {};\n\ntemplate <>\nstruct DenseMapInfo<clang::DynTypedNode> : clang::DynTypedNode::DenseMapInfo {};\n\n}  // end namespace llvm\n\n#endif\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "content": "//===- PathDiagnostic.h - Path-Specific Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PathDiagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <deque>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass BinaryOperator;\nclass CallEnter;\nclass CallExitEnd;\nclass CallExpr;\nclass ConditionalOperator;\nclass Decl;\nclass Expr;\nclass LocationContext;\nclass MemberExpr;\nclass ProgramPoint;\nclass SourceManager;\n\nnamespace ento {\n\n//===----------------------------------------------------------------------===//\n// High-level interface for handlers of path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnostic;\n\n/// These options tweak the behavior of path diangostic consumers.\n/// Most of these options are currently supported by very few consumers.\nstruct PathDiagnosticConsumerOptions {\n  /// Run-line of the tool that produced the diagnostic.\n  /// It can be included with the diagnostic for debugging purposes.\n  std::string ToolInvocation;\n\n  /// Whether to include additional information about macro expansions\n  /// with the diagnostics, because otherwise they can be hard to obtain\n  /// without re-compiling the program under analysis.\n  bool ShouldDisplayMacroExpansions = false;\n\n  /// Whether to include LLVM statistics of the process in the diagnostic.\n  /// Useful for profiling the tool on large real-world codebases.\n  bool ShouldSerializeStats = false;\n\n  /// If the consumer intends to produce multiple output files, should it\n  /// use randomly generated file names for these files (with the tiny risk of\n  /// having random collisions) or deterministic human-readable file names\n  /// (with a larger risk of deterministic collisions or invalid characters\n  /// in the file name). We should not really give this choice to the users\n  /// because deterministic mode is always superior when done right, but\n  /// for some consumers this mode is experimental and needs to be\n  /// off by default.\n  bool ShouldWriteStableReportFilename = false;\n\n  /// Whether the consumer should treat consumed diagnostics as hard errors.\n  /// Useful for breaking your build when issues are found.\n  bool ShouldDisplayWarningsAsErrors = false;\n\n  /// Whether the consumer should attempt to rewrite the source file\n  /// with fix-it hints attached to the diagnostics it consumes.\n  bool ShouldApplyFixIts = false;\n\n  /// Whether the consumer should present the name of the entity that emitted\n  /// the diagnostic (eg., a checker) so that the user knew how to disable it.\n  bool ShouldDisplayDiagnosticName = false;\n};\n\nclass PathDiagnosticConsumer {\npublic:\n  class PDFileEntry : public llvm::FoldingSetNode {\n  public:\n    PDFileEntry(llvm::FoldingSetNodeID &NodeID) : NodeID(NodeID) {}\n\n    using ConsumerFiles = std::vector<std::pair<StringRef, StringRef>>;\n\n    /// A vector of <consumer,file> pairs.\n    ConsumerFiles files;\n\n    /// A precomputed hash tag used for uniquing PDFileEntry objects.\n    const llvm::FoldingSetNodeID NodeID;\n\n    /// Used for profiling in the FoldingSet.\n    void Profile(llvm::FoldingSetNodeID &ID) { ID = NodeID; }\n  };\n\n  class FilesMade {\n    llvm::BumpPtrAllocator Alloc;\n    llvm::FoldingSet<PDFileEntry> Set;\n\n  public:\n    ~FilesMade();\n\n    bool empty() const { return Set.empty(); }\n\n    void addDiagnostic(const PathDiagnostic &PD,\n                       StringRef ConsumerName,\n                       StringRef fileName);\n\n    PDFileEntry::ConsumerFiles *getFiles(const PathDiagnostic &PD);\n  };\n\nprivate:\n  virtual void anchor();\n\npublic:\n  PathDiagnosticConsumer() = default;\n  virtual ~PathDiagnosticConsumer();\n\n  void FlushDiagnostics(FilesMade *FilesMade);\n\n  virtual void FlushDiagnosticsImpl(std::vector<const PathDiagnostic *> &Diags,\n                                    FilesMade *filesMade) = 0;\n\n  virtual StringRef getName() const = 0;\n\n  void HandlePathDiagnostic(std::unique_ptr<PathDiagnostic> D);\n\n  enum PathGenerationScheme {\n    /// Only runs visitors, no output generated.\n    None,\n\n    /// Used for HTML, SARIF, and text output.\n    Minimal,\n\n    /// Used for plist output, used for \"arrows\" generation.\n    Extensive,\n  };\n\n  virtual PathGenerationScheme getGenerationScheme() const { return Minimal; }\n\n  bool shouldGenerateDiagnostics() const {\n    return getGenerationScheme() != None;\n  }\n\n  bool shouldAddPathEdges() const { return getGenerationScheme() == Extensive; }\n\n  virtual bool supportsLogicalOpControlFlow() const { return false; }\n\n  /// Return true if the PathDiagnosticConsumer supports individual\n  /// PathDiagnostics that span multiple files.\n  virtual bool supportsCrossFileDiagnostics() const { return false; }\n\nprotected:\n  bool flushed = false;\n  llvm::FoldingSet<PathDiagnostic> Diags;\n};\n\n//===----------------------------------------------------------------------===//\n// Path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticRange : public SourceRange {\npublic:\n  bool isPoint = false;\n\n  PathDiagnosticRange(SourceRange R, bool isP = false)\n      : SourceRange(R), isPoint(isP) {}\n  PathDiagnosticRange() = default;\n};\n\nusing LocationOrAnalysisDeclContext =\n    llvm::PointerUnion<const LocationContext *, AnalysisDeclContext *>;\n\nclass PathDiagnosticLocation {\nprivate:\n  enum Kind { RangeK, SingleLocK, StmtK, DeclK } K = SingleLocK;\n\n  const Stmt *S = nullptr;\n  const Decl *D = nullptr;\n  const SourceManager *SM = nullptr;\n  FullSourceLoc Loc;\n  PathDiagnosticRange Range;\n\n  PathDiagnosticLocation(SourceLocation L, const SourceManager &sm, Kind kind)\n      : K(kind), SM(&sm), Loc(genLocation(L)), Range(genRange()) {}\n\n  FullSourceLoc genLocation(\n      SourceLocation L = SourceLocation(),\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\n  PathDiagnosticRange genRange(\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\npublic:\n  /// Create an invalid location.\n  PathDiagnosticLocation() = default;\n\n  /// Create a location corresponding to the given statement.\n  PathDiagnosticLocation(const Stmt *s, const SourceManager &sm,\n                         LocationOrAnalysisDeclContext lac)\n      : K(s->getBeginLoc().isValid() ? StmtK : SingleLocK),\n        S(K == StmtK ? s : nullptr), SM(&sm),\n        Loc(genLocation(SourceLocation(), lac)), Range(genRange(lac)) {\n    assert(K == SingleLocK || S);\n    assert(K == SingleLocK || Loc.isValid());\n    assert(K == SingleLocK || Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  PathDiagnosticLocation(const Decl *d, const SourceManager &sm)\n      : K(DeclK), D(d), SM(&sm), Loc(genLocation()), Range(genRange()) {\n    assert(D);\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location at an explicit offset in the source.\n  ///\n  /// This should only be used if there are no more appropriate constructors.\n  PathDiagnosticLocation(SourceLocation loc, const SourceManager &sm)\n      : SM(&sm), Loc(loc, sm), Range(genRange()) {\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  static PathDiagnosticLocation create(const Decl *D,\n                                       const SourceManager &SM) {\n    return PathDiagnosticLocation(D, SM);\n  }\n\n  /// Create a location for the beginning of the declaration.\n  static PathDiagnosticLocation createBegin(const Decl *D,\n                                            const SourceManager &SM);\n\n  /// Create a location for the beginning of the declaration.\n  /// The third argument is ignored, useful for generic treatment\n  /// of statements and declarations.\n  static PathDiagnosticLocation\n  createBegin(const Decl *D, const SourceManager &SM,\n              const LocationOrAnalysisDeclContext LAC) {\n    return createBegin(D, SM);\n  }\n\n  /// Create a location for the beginning of the statement.\n  static PathDiagnosticLocation createBegin(const Stmt *S,\n                                            const SourceManager &SM,\n                                            const LocationOrAnalysisDeclContext LAC);\n\n  /// Create a location for the end of the statement.\n  ///\n  /// If the statement is a CompoundStatement, the location will point to the\n  /// closing brace instead of following it.\n  static PathDiagnosticLocation createEnd(const Stmt *S,\n                                          const SourceManager &SM,\n                                       const LocationOrAnalysisDeclContext LAC);\n\n  /// Create the location for the operator of the binary expression.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createOperatorLoc(const BinaryOperator *BO,\n                                                  const SourceManager &SM);\n  static PathDiagnosticLocation createConditionalColonLoc(\n                                                  const ConditionalOperator *CO,\n                                                  const SourceManager &SM);\n\n  /// For member expressions, return the location of the '.' or '->'.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createMemberLoc(const MemberExpr *ME,\n                                                const SourceManager &SM);\n\n  /// Create a location for the beginning of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createBeginBrace(const CompoundStmt *CS,\n                                                 const SourceManager &SM);\n\n  /// Create a location for the end of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createEndBrace(const CompoundStmt *CS,\n                                               const SourceManager &SM);\n\n  /// Create a location for the beginning of the enclosing declaration body.\n  /// Defaults to the beginning of the first statement in the declaration body.\n  static PathDiagnosticLocation createDeclBegin(const LocationContext *LC,\n                                                const SourceManager &SM);\n\n  /// Constructs a location for the end of the enclosing declaration body.\n  /// Defaults to the end of brace.\n  static PathDiagnosticLocation createDeclEnd(const LocationContext *LC,\n                                                   const SourceManager &SM);\n\n  /// Create a location corresponding to the given valid ProgramPoint.\n  static PathDiagnosticLocation create(const ProgramPoint &P,\n                                       const SourceManager &SMng);\n\n  /// Convert the given location into a single kind location.\n  static PathDiagnosticLocation createSingleLocation(\n                                             const PathDiagnosticLocation &PDL);\n\n  /// Construct a source location that corresponds to either the beginning\n  /// or the end of the given statement, or a nearby valid source location\n  /// if the statement does not have a valid source location of its own.\n  static SourceLocation\n  getValidSourceLocation(const Stmt *S, LocationOrAnalysisDeclContext LAC,\n                         bool UseEndOfStatement = false);\n\n  bool operator==(const PathDiagnosticLocation &X) const {\n    return K == X.K && Loc == X.Loc && Range == X.Range;\n  }\n\n  bool operator!=(const PathDiagnosticLocation &X) const {\n    return !(*this == X);\n  }\n\n  bool isValid() const {\n    return SM != nullptr;\n  }\n\n  FullSourceLoc asLocation() const {\n    return Loc;\n  }\n\n  PathDiagnosticRange asRange() const {\n    return Range;\n  }\n\n  const Stmt *asStmt() const { assert(isValid()); return S; }\n  const Stmt *getStmtOrNull() const {\n    if (!isValid())\n      return nullptr;\n    return asStmt();\n  }\n\n  const Decl *asDecl() const { assert(isValid()); return D; }\n\n  bool hasRange() const { return K == StmtK || K == RangeK || K == DeclK; }\n\n  bool hasValidLocation() const { return asLocation().isValid(); }\n\n  void invalidate() {\n    *this = PathDiagnosticLocation();\n  }\n\n  void flatten();\n\n  const SourceManager& getManager() const { assert(isValid()); return *SM; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void dump() const;\n};\n\nclass PathDiagnosticLocationPair {\nprivate:\n  PathDiagnosticLocation Start, End;\n\npublic:\n  PathDiagnosticLocationPair(const PathDiagnosticLocation &start,\n                             const PathDiagnosticLocation &end)\n      : Start(start), End(end) {}\n\n  const PathDiagnosticLocation &getStart() const { return Start; }\n  const PathDiagnosticLocation &getEnd() const { return End; }\n\n  void setStart(const PathDiagnosticLocation &L) { Start = L; }\n  void setEnd(const PathDiagnosticLocation &L) { End = L; }\n\n  void flatten() {\n    Start.flatten();\n    End.flatten();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Start.Profile(ID);\n    End.Profile(ID);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Path \"pieces\" for path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticPiece: public llvm::FoldingSetNode {\npublic:\n  enum Kind { ControlFlow, Event, Macro, Call, Note, PopUp };\n  enum DisplayHint { Above, Below };\n\nprivate:\n  const std::string str;\n  const Kind kind;\n  const DisplayHint Hint;\n\n  /// In the containing bug report, this piece is the last piece from\n  /// the main source file.\n  bool LastInMainSourceFile = false;\n\n  /// A constant string that can be used to tag the PathDiagnosticPiece,\n  /// typically with the identification of the creator.  The actual pointer\n  /// value is meant to be an identifier; the string itself is useful for\n  /// debugging.\n  StringRef Tag;\n\n  std::vector<SourceRange> ranges;\n  std::vector<FixItHint> fixits;\n\nprotected:\n  PathDiagnosticPiece(StringRef s, Kind k, DisplayHint hint = Below);\n  PathDiagnosticPiece(Kind k, DisplayHint hint = Below);\n\npublic:\n  PathDiagnosticPiece() = delete;\n  PathDiagnosticPiece(const PathDiagnosticPiece &) = delete;\n  PathDiagnosticPiece &operator=(const PathDiagnosticPiece &) = delete;\n  virtual ~PathDiagnosticPiece();\n\n  StringRef getString() const { return str; }\n\n  /// Tag this PathDiagnosticPiece with the given C-string.\n  void setTag(const char *tag) { Tag = tag; }\n\n  /// Return the opaque tag (if any) on the PathDiagnosticPiece.\n  const void *getTag() const { return Tag.data(); }\n\n  /// Return the string representation of the tag.  This is useful\n  /// for debugging.\n  StringRef getTagStr() const { return Tag; }\n\n  /// getDisplayHint - Return a hint indicating where the diagnostic should\n  ///  be displayed by the PathDiagnosticConsumer.\n  DisplayHint getDisplayHint() const { return Hint; }\n\n  virtual PathDiagnosticLocation getLocation() const = 0;\n  virtual void flattenLocations() = 0;\n\n  Kind getKind() const { return kind; }\n\n  void addRange(SourceRange R) {\n    if (!R.isValid())\n      return;\n    ranges.push_back(R);\n  }\n\n  void addRange(SourceLocation B, SourceLocation E) {\n    if (!B.isValid() || !E.isValid())\n      return;\n    ranges.push_back(SourceRange(B,E));\n  }\n\n  void addFixit(FixItHint F) {\n    fixits.push_back(F);\n  }\n\n  /// Return the SourceRanges associated with this PathDiagnosticPiece.\n  ArrayRef<SourceRange> getRanges() const { return ranges; }\n\n  /// Return the fix-it hints associated with this PathDiagnosticPiece.\n  ArrayRef<FixItHint> getFixits() const { return fixits; }\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void setAsLastInMainSourceFile() {\n    LastInMainSourceFile = true;\n  }\n\n  bool isLastInMainSourceFile() const {\n    return LastInMainSourceFile;\n  }\n\n  virtual void dump() const = 0;\n};\n\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\nclass PathPieces : public std::list<PathDiagnosticPieceRef> {\n  void flattenTo(PathPieces &Primary, PathPieces &Current,\n                 bool ShouldFlattenMacros) const;\n\npublic:\n  PathPieces flatten(bool ShouldFlattenMacros) const {\n    PathPieces Result;\n    flattenTo(Result, Result, ShouldFlattenMacros);\n    return Result;\n  }\n\n  void dump() const;\n};\n\nclass PathDiagnosticSpotPiece : public PathDiagnosticPiece {\nprivate:\n  PathDiagnosticLocation Pos;\n\npublic:\n  PathDiagnosticSpotPiece(const PathDiagnosticLocation &pos,\n                          StringRef s,\n                          PathDiagnosticPiece::Kind k,\n                          bool addPosRange = true)\n      : PathDiagnosticPiece(s, k), Pos(pos) {\n    assert(Pos.isValid() && Pos.hasValidLocation() &&\n           \"PathDiagnosticSpotPiece's must have a valid location.\");\n    if (addPosRange && Pos.hasRange()) addRange(Pos.asRange());\n  }\n\n  PathDiagnosticLocation getLocation() const override { return Pos; }\n  void flattenLocations() override { Pos.flatten(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event || P->getKind() == Macro ||\n           P->getKind() == Note || P->getKind() == PopUp;\n  }\n};\n\nclass PathDiagnosticEventPiece : public PathDiagnosticSpotPiece {\n  Optional<bool> IsPrunable;\n\npublic:\n  PathDiagnosticEventPiece(const PathDiagnosticLocation &pos,\n                           StringRef s, bool addPosRange = true)\n      : PathDiagnosticSpotPiece(pos, s, Event, addPosRange) {}\n  ~PathDiagnosticEventPiece() override;\n\n  /// Mark the diagnostic piece as being potentially prunable.  This\n  /// flag may have been previously set, at which point it will not\n  /// be reset unless one specifies to do so.\n  void setPrunable(bool isPrunable, bool override = false) {\n    if (IsPrunable.hasValue() && !override)\n     return;\n    IsPrunable = isPrunable;\n  }\n\n  /// Return true if the diagnostic piece is prunable.\n  bool isPrunable() const {\n    return IsPrunable.hasValue() ? IsPrunable.getValue() : false;\n  }\n\n  void dump() const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event;\n  }\n};\n\nclass PathDiagnosticCallPiece : public PathDiagnosticPiece {\n  const Decl *Caller;\n  const Decl *Callee = nullptr;\n\n  // Flag signifying that this diagnostic has only call enter and no matching\n  // call exit.\n  bool NoExit;\n\n  // Flag signifying that the callee function is an Objective-C autosynthesized\n  // property getter or setter.\n  bool IsCalleeAnAutosynthesizedPropertyAccessor = false;\n\n  // The custom string, which should appear after the call Return Diagnostic.\n  // TODO: Should we allow multiple diagnostics?\n  std::string CallStackMessage;\n\n  PathDiagnosticCallPiece(const Decl *callerD,\n                          const PathDiagnosticLocation &callReturnPos)\n      : PathDiagnosticPiece(Call), Caller(callerD), NoExit(false),\n        callReturn(callReturnPos) {}\n  PathDiagnosticCallPiece(PathPieces &oldPath, const Decl *caller)\n      : PathDiagnosticPiece(Call), Caller(caller), NoExit(true),\n        path(oldPath) {}\n\npublic:\n  PathDiagnosticLocation callEnter;\n  PathDiagnosticLocation callEnterWithin;\n  PathDiagnosticLocation callReturn;\n  PathPieces path;\n\n  ~PathDiagnosticCallPiece() override;\n\n  const Decl *getCaller() const { return Caller; }\n\n  const Decl *getCallee() const { return Callee; }\n  void setCallee(const CallEnter &CE, const SourceManager &SM);\n\n  bool hasCallStackMessage() { return !CallStackMessage.empty(); }\n  void setCallStackMessage(StringRef st) { CallStackMessage = std::string(st); }\n\n  PathDiagnosticLocation getLocation() const override { return callEnter; }\n\n  std::shared_ptr<PathDiagnosticEventPiece> getCallEnterEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece>\n  getCallEnterWithinCallerEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece> getCallExitEvent() const;\n\n  void flattenLocations() override {\n    callEnter.flatten();\n    callReturn.flatten();\n    for (const auto &I : path)\n      I->flattenLocations();\n  }\n\n  static std::shared_ptr<PathDiagnosticCallPiece>\n  construct(const CallExitEnd &CE,\n            const SourceManager &SM);\n\n  static PathDiagnosticCallPiece *construct(PathPieces &pieces,\n                                            const Decl *caller);\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Call;\n  }\n};\n\nclass PathDiagnosticControlFlowPiece : public PathDiagnosticPiece {\n  std::vector<PathDiagnosticLocationPair> LPairs;\n\npublic:\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos,\n                                 StringRef s)\n      : PathDiagnosticPiece(s, ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos)\n      : PathDiagnosticPiece(ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  ~PathDiagnosticControlFlowPiece() override;\n\n  PathDiagnosticLocation getStartLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getStart();\n  }\n\n  PathDiagnosticLocation getEndLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getEnd();\n  }\n\n  void setStartLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setStart(L);\n  }\n\n  void setEndLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setEnd(L);\n  }\n\n  void push_back(const PathDiagnosticLocationPair &X) { LPairs.push_back(X); }\n\n  PathDiagnosticLocation getLocation() const override {\n    return getStartLocation();\n  }\n\n  using iterator = std::vector<PathDiagnosticLocationPair>::iterator;\n\n  iterator begin() { return LPairs.begin(); }\n  iterator end() { return LPairs.end(); }\n\n  void flattenLocations() override {\n    for (auto &I : *this)\n      I.flatten();\n  }\n\n  using const_iterator =\n      std::vector<PathDiagnosticLocationPair>::const_iterator;\n\n  const_iterator begin() const { return LPairs.begin(); }\n  const_iterator end() const { return LPairs.end(); }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == ControlFlow;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticMacroPiece : public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticMacroPiece(const PathDiagnosticLocation &pos)\n      : PathDiagnosticSpotPiece(pos, \"\", Macro) {}\n  ~PathDiagnosticMacroPiece() override;\n\n  PathPieces subPieces;\n\n  void flattenLocations() override {\n    PathDiagnosticSpotPiece::flattenLocations();\n    for (const auto &I : subPieces)\n      I->flattenLocations();\n  }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Macro;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticNotePiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticNotePiece(const PathDiagnosticLocation &Pos, StringRef S,\n                          bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, Note, AddPosRange) {}\n  ~PathDiagnosticNotePiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Note;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticPopUpPiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticPopUpPiece(const PathDiagnosticLocation &Pos, StringRef S,\n                           bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, PopUp, AddPosRange) {}\n  ~PathDiagnosticPopUpPiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == PopUp;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\n/// File IDs mapped to sets of line numbers.\nusing FilesToLineNumsMap = std::map<FileID, std::set<unsigned>>;\n\n/// PathDiagnostic - PathDiagnostic objects represent a single path-sensitive\n///  diagnostic.  It represents an ordered-collection of PathDiagnosticPieces,\n///  each which represent the pieces of the path.\nclass PathDiagnostic : public llvm::FoldingSetNode {\n  std::string CheckerName;\n  const Decl *DeclWithIssue;\n  std::string BugType;\n  std::string VerboseDesc;\n  std::string ShortDesc;\n  std::string Category;\n  std::deque<std::string> OtherDesc;\n\n  /// Loc The location of the path diagnostic report.\n  PathDiagnosticLocation Loc;\n\n  PathPieces pathImpl;\n  SmallVector<PathPieces *, 3> pathStack;\n\n  /// Important bug uniqueing location.\n  /// The location info is useful to differentiate between bugs.\n  PathDiagnosticLocation UniqueingLoc;\n  const Decl *UniqueingDecl;\n\n  /// Lines executed in the path.\n  std::unique_ptr<FilesToLineNumsMap> ExecutedLines;\n\npublic:\n  PathDiagnostic() = delete;\n  PathDiagnostic(StringRef CheckerName, const Decl *DeclWithIssue,\n                 StringRef bugtype, StringRef verboseDesc, StringRef shortDesc,\n                 StringRef category, PathDiagnosticLocation LocationToUnique,\n                 const Decl *DeclToUnique,\n                 std::unique_ptr<FilesToLineNumsMap> ExecutedLines);\n  ~PathDiagnostic();\n\n  const PathPieces &path;\n\n  /// Return the path currently used by builders for constructing the\n  /// PathDiagnostic.\n  PathPieces &getActivePath() {\n    if (pathStack.empty())\n      return pathImpl;\n    return *pathStack.back();\n  }\n\n  /// Return a mutable version of 'path'.\n  PathPieces &getMutablePieces() {\n    return pathImpl;\n  }\n\n  /// Return the unrolled size of the path.\n  unsigned full_size();\n\n  void pushActivePath(PathPieces *p) { pathStack.push_back(p); }\n  void popActivePath() { if (!pathStack.empty()) pathStack.pop_back(); }\n\n  bool isWithinCall() const { return !pathStack.empty(); }\n\n  void setEndOfPath(PathDiagnosticPieceRef EndPiece) {\n    assert(!Loc.isValid() && \"End location already set!\");\n    Loc = EndPiece->getLocation();\n    assert(Loc.isValid() && \"Invalid location for end-of-path piece\");\n    getActivePath().push_back(std::move(EndPiece));\n  }\n\n  void appendToDesc(StringRef S) {\n    if (!ShortDesc.empty())\n      ShortDesc += S;\n    VerboseDesc += S;\n  }\n\n  StringRef getVerboseDescription() const { return VerboseDesc; }\n\n  StringRef getShortDescription() const {\n    return ShortDesc.empty() ? VerboseDesc : ShortDesc;\n  }\n\n  StringRef getCheckerName() const { return CheckerName; }\n  StringRef getBugType() const { return BugType; }\n  StringRef getCategory() const { return Category; }\n\n  using meta_iterator = std::deque<std::string>::const_iterator;\n\n  meta_iterator meta_begin() const { return OtherDesc.begin(); }\n  meta_iterator meta_end() const { return OtherDesc.end(); }\n  void addMeta(StringRef s) { OtherDesc.push_back(std::string(s)); }\n\n  const FilesToLineNumsMap &getExecutedLines() const {\n    return *ExecutedLines;\n  }\n\n  FilesToLineNumsMap &getExecutedLines() {\n    return *ExecutedLines;\n  }\n\n  /// Return the semantic context where an issue occurred.  If the\n  /// issue occurs along a path, this represents the \"central\" area\n  /// where the bug manifests.\n  const Decl *getDeclWithIssue() const { return DeclWithIssue; }\n\n  void setDeclWithIssue(const Decl *D) {\n    DeclWithIssue = D;\n  }\n\n  PathDiagnosticLocation getLocation() const {\n    return Loc;\n  }\n\n  void setLocation(PathDiagnosticLocation NewLoc) {\n    Loc = NewLoc;\n  }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLoc() const {\n    return UniqueingLoc;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const {\n    return UniqueingDecl;\n  }\n\n  void flattenLocations() {\n    Loc.flatten();\n    for (const auto &I : pathImpl)\n      I->flattenLocations();\n  }\n\n  /// Profiles the diagnostic, independent of the path it references.\n  ///\n  /// This can be used to merge diagnostics that refer to the same issue\n  /// along different paths.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  /// Profiles the diagnostic, including its path.\n  ///\n  /// Two diagnostics with the same issue along different paths will generate\n  /// different profiles.\n  void FullProfile(llvm::FoldingSetNodeID &ID) const;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "content": "//===- clang/Basic/DirectoryEntry.h - Directory references ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines interfaces for clang::DirectoryEntry and clang::DirectoryEntryRef.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n#define LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n\nnamespace clang {\nnamespace FileMgr {\n\ntemplate <class RefTy> class MapEntryOptionalStorage;\n\n} // end namespace FileMgr\n\n/// Cached information about one directory (either on disk or in\n/// the virtual file system).\nclass DirectoryEntry {\n  friend class FileManager;\n\n  // FIXME: We should not be storing a directory entry name here.\n  StringRef Name; // Name of the directory.\n\npublic:\n  StringRef getName() const { return Name; }\n};\n\n/// A reference to a \\c DirectoryEntry  that includes the name of the directory\n/// as it was accessed by the FileManager's client.\nclass DirectoryEntryRef {\npublic:\n  const DirectoryEntry &getDirEntry() const { return *ME->getValue(); }\n\n  StringRef getName() const { return ME->getKey(); }\n\n  /// Hash code is based on the DirectoryEntry, not the specific named\n  /// reference.\n  friend llvm::hash_code hash_value(DirectoryEntryRef Ref) {\n    return llvm::hash_value(&Ref.getDirEntry());\n  }\n\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<DirectoryEntry &>>;\n\n  const MapEntry &getMapEntry() const { return *ME; }\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(DirectoryEntryRef RHS) const { return ME == RHS.ME; }\n\n  DirectoryEntryRef() = delete;\n  DirectoryEntryRef(const MapEntry &ME) : ME(&ME) {}\n\n  /// Allow DirectoryEntryRef to degrade into 'const DirectoryEntry*' to\n  /// facilitate incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getDirectoryEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once DirectoryEntryRef is \"everywhere\" and DirectoryEntry::getName\n  /// has been deleted, delete this implicit conversion.\n  operator const DirectoryEntry *() const { return &getDirEntry(); }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<DirectoryEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  DirectoryEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<DirectoryEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  DirectoryEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  DirectoryEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(DirectoryEntryRef(dense_map_empty_tag())) ||\n           isSameRef(DirectoryEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nnamespace FileMgr {\n\n/// Customized storage for refs derived from map entires in FileManager, using\n/// the private optional_none_tag to keep it to the size of a single pointer.\ntemplate <class RefTy> class MapEntryOptionalStorage {\n  using optional_none_tag = typename RefTy::optional_none_tag;\n  RefTy MaybeRef;\n\npublic:\n  MapEntryOptionalStorage() : MaybeRef(optional_none_tag()) {}\n\n  template <class... ArgTypes>\n  explicit MapEntryOptionalStorage(llvm::optional_detail::in_place_t,\n                                   ArgTypes &&...Args)\n      : MaybeRef(std::forward<ArgTypes>(Args)...) {}\n\n  void reset() { MaybeRef = optional_none_tag(); }\n\n  bool hasValue() const { return MaybeRef.hasOptionalValue(); }\n\n  RefTy &getValue() LLVM_LVALUE_FUNCTION {\n    assert(hasValue());\n    return MaybeRef;\n  }\n  RefTy const &getValue() const LLVM_LVALUE_FUNCTION {\n    assert(hasValue());\n    return MaybeRef;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  RefTy &&getValue() && {\n    assert(hasValue());\n    return std::move(MaybeRef);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&...args) {\n    MaybeRef = RefTy(std::forward<Args>(args)...);\n  }\n\n  MapEntryOptionalStorage &operator=(RefTy Ref) {\n    MaybeRef = Ref;\n    return *this;\n  }\n};\n\n} // end namespace FileMgr\n} // end namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Customize OptionalStorage<DirectoryEntryRef> to use DirectoryEntryRef and\n/// its optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::DirectoryEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(in_place_t, ArgTypes &&...Args)\n      : StorageImpl(in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::DirectoryEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(Optional<clang::DirectoryEntryRef>) ==\n                  sizeof(clang::DirectoryEntryRef),\n              \"Optional<DirectoryEntryRef> must avoid size overhead\");\n\nstatic_assert(\n    std::is_trivially_copyable<Optional<clang::DirectoryEntryRef>>::value,\n    \"Optional<DirectoryEntryRef> should be trivially copyable\");\n\n} // end namespace optional_detail\n\n/// Specialisation of DenseMapInfo for DirectoryEntryRef.\ntemplate <> struct DenseMapInfo<clang::DirectoryEntryRef> {\n  static inline clang::DirectoryEntryRef getEmptyKey() {\n    return clang::DirectoryEntryRef(\n        clang::DirectoryEntryRef::dense_map_empty_tag());\n  }\n\n  static inline clang::DirectoryEntryRef getTombstoneKey() {\n    return clang::DirectoryEntryRef(\n        clang::DirectoryEntryRef::dense_map_tombstone_tag());\n  }\n\n  static unsigned getHashValue(clang::DirectoryEntryRef Val) {\n    return hash_value(Val);\n  }\n\n  static bool isEqual(clang::DirectoryEntryRef LHS,\n                      clang::DirectoryEntryRef RHS) {\n    // Catch the easy cases: both empty, both tombstone, or the same ref.\n    if (LHS.isSameRef(RHS))\n      return true;\n\n    // Confirm LHS and RHS are valid.\n    if (LHS.isSpecialDenseMapKey() || RHS.isSpecialDenseMapKey())\n      return false;\n\n    // It's safe to use operator==.\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace clang {\n\n/// Wrapper around Optional<DirectoryEntryRef> that degrades to 'const\n/// DirectoryEntry*', facilitating incremental patches to propagate\n/// DirectoryEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an Optional<DirectoryEntryRef> to degrade to a 'const DirectoryEntry*'. The\n/// purpose is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// Optional<DirectoryEntryRef> MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getDirectoryEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once DirectoryEntryRef is \"everywhere\" and DirectoryEntry::LastRef\n/// and DirectoryEntry::getName have been deleted, delete this class and\n/// replace instances with Optional<DirectoryEntryRef>.\nclass OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr\n    : public Optional<DirectoryEntryRef> {\npublic:\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr() = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(\n      OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &&) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(\n      const OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &&) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(const OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &) = default;\n\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(llvm::NoneType) {}\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(DirectoryEntryRef Ref)\n      : Optional<DirectoryEntryRef>(Ref) {}\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(Optional<DirectoryEntryRef> MaybeRef)\n      : Optional<DirectoryEntryRef>(MaybeRef) {}\n\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &operator=(llvm::NoneType) {\n    Optional<DirectoryEntryRef>::operator=(None);\n    return *this;\n  }\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &operator=(DirectoryEntryRef Ref) {\n    Optional<DirectoryEntryRef>::operator=(Ref);\n    return *this;\n  }\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(Optional<DirectoryEntryRef> MaybeRef) {\n    Optional<DirectoryEntryRef>::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const DirectoryEntry *' to allow  DirectoryEntry::LastRef and\n  /// DirectoryEntry::getName have been deleted, delete this class and replace\n  /// instances with Optional<DirectoryEntryRef>\n  operator const DirectoryEntry *() const {\n    return hasValue() ? &getValue().getDirEntry() : nullptr;\n  }\n};\n\nstatic_assert(std::is_trivially_copyable<\n                  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr>::value,\n              \"OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr should be \"\n              \"trivially copyable\");\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "content": "//===- clang/Basic/FileEntry.h - File references ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines interfaces for clang::FileEntry and clang::FileEntryRef.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_FILEENTRY_H\n#define LLVM_CLANG_BASIC_FILEENTRY_H\n\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nnamespace vfs {\n\nclass File;\n\n} // namespace vfs\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntryRef;\n\n} // namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Forward declare a template specialization for OptionalStorage.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef, /*is_trivially_copyable*/ true>;\n\n} // namespace optional_detail\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntry;\n\n/// A reference to a \\c FileEntry that includes the name of the file as it was\n/// accessed by the FileManager's client.\nclass FileEntryRef {\npublic:\n  StringRef getName() const { return ME->first(); }\n  const FileEntry &getFileEntry() const {\n    return *ME->second->V.get<FileEntry *>();\n  }\n  DirectoryEntryRef getDir() const { return *ME->second->Dir; }\n\n  inline bool isValid() const;\n  inline off_t getSize() const;\n  inline unsigned getUID() const;\n  inline const llvm::sys::fs::UniqueID &getUniqueID() const;\n  inline time_t getModificationTime() const;\n  inline bool isNamedPipe() const;\n  inline void closeFile() const;\n\n  /// Check if the underlying FileEntry is the same, intentially ignoring\n  /// whether the file was referenced with the same spelling of the filename.\n  friend bool operator==(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return &LHS.getFileEntry() == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return LHS == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return &LHS.getFileEntry() == RHS;\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Hash code is based on the FileEntry, not the specific named reference,\n  /// just like operator==.\n  friend llvm::hash_code hash_value(FileEntryRef Ref) {\n    return llvm::hash_value(&Ref.getFileEntry());\n  }\n\n  struct MapValue;\n\n  /// Type used in the StringMap.\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<MapValue>>;\n\n  /// Type stored in the StringMap.\n  struct MapValue {\n    /// The pointer at another MapEntry is used when the FileManager should\n    /// silently forward from one name to another, which occurs in Redirecting\n    /// VFSs that use external names. In that case, the \\c FileEntryRef\n    /// returned by the \\c FileManager will have the external name, and not the\n    /// name that was used to lookup the file.\n    ///\n    /// The second type is really a `const MapEntry *`, but that confuses\n    /// gcc5.3.  Once that's no longer supported, change this back.\n    llvm::PointerUnion<FileEntry *, const void *> V;\n\n    /// Directory the file was found in. Set if and only if V is a FileEntry.\n    Optional<DirectoryEntryRef> Dir;\n\n    MapValue() = delete;\n    MapValue(FileEntry &FE, DirectoryEntryRef Dir) : V(&FE), Dir(Dir) {}\n    MapValue(MapEntry &ME) : V(&ME) {}\n  };\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(const FileEntryRef &RHS) const { return ME == RHS.ME; }\n\n  /// Allow FileEntryRef to degrade into 'const FileEntry*' to facilitate\n  /// incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getFileEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this implicit conversion.\n  operator const FileEntry *() const { return &getFileEntry(); }\n\n  FileEntryRef() = delete;\n  explicit FileEntryRef(const MapEntry &ME) : ME(&ME) {\n    assert(ME.second && \"Expected payload\");\n    assert(ME.second->V && \"Expected non-null\");\n    assert(ME.second->V.is<FileEntry *>() && \"Expected FileEntry\");\n  }\n\n  /// Expose the underlying MapEntry to simplify packing in a PointerIntPair or\n  /// PointerUnion and allow construction in Optional.\n  const clang::FileEntryRef::MapEntry &getMapEntry() const { return *ME; }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<FileEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  FileEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<FileEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  FileEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  FileEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(FileEntryRef(dense_map_empty_tag())) ||\n           isSameRef(FileEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nstatic_assert(sizeof(FileEntryRef) == sizeof(const FileEntry *),\n              \"FileEntryRef must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<FileEntryRef>::value,\n              \"FileEntryRef must be trivially copyable\");\n\n} // end namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Customize OptionalStorage<FileEntryRef> to use FileEntryRef and its\n/// optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(in_place_t, ArgTypes &&...Args)\n      : StorageImpl(in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::FileEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(Optional<clang::FileEntryRef>) ==\n                  sizeof(clang::FileEntryRef),\n              \"Optional<FileEntryRef> must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<Optional<clang::FileEntryRef>>::value,\n              \"Optional<FileEntryRef> should be trivially copyable\");\n\n} // end namespace optional_detail\n\n/// Specialisation of DenseMapInfo for FileEntryRef.\ntemplate <> struct DenseMapInfo<clang::FileEntryRef> {\n  static inline clang::FileEntryRef getEmptyKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_empty_tag());\n  }\n\n  static inline clang::FileEntryRef getTombstoneKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_tombstone_tag());\n  }\n\n  static unsigned getHashValue(clang::FileEntryRef Val) {\n    return hash_value(Val);\n  }\n\n  static bool isEqual(clang::FileEntryRef LHS, clang::FileEntryRef RHS) {\n    // Catch the easy cases: both empty, both tombstone, or the same ref.\n    if (LHS.isSameRef(RHS))\n      return true;\n\n    // Confirm LHS and RHS are valid.\n    if (LHS.isSpecialDenseMapKey() || RHS.isSpecialDenseMapKey())\n      return false;\n\n    // It's safe to use operator==.\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace clang {\n\n/// Wrapper around Optional<FileEntryRef> that degrades to 'const FileEntry*',\n/// facilitating incremental patches to propagate FileEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an Optional<FileEntryRef> to degrade to a 'const FileEntry*'. The purpose\n/// is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// Optional<FileEntryRef> MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getFileEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n/// FileEntry::getName have been deleted, delete this class and replace\n/// instances with Optional<FileEntryRef>.\nclass OptionalFileEntryRefDegradesToFileEntryPtr\n    : public Optional<FileEntryRef> {\npublic:\n  OptionalFileEntryRefDegradesToFileEntryPtr() = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n\n  OptionalFileEntryRefDegradesToFileEntryPtr(llvm::NoneType) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(FileEntryRef Ref)\n      : Optional<FileEntryRef>(Ref) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(Optional<FileEntryRef> MaybeRef)\n      : Optional<FileEntryRef>(MaybeRef) {}\n\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(llvm::NoneType) {\n    Optional<FileEntryRef>::operator=(None);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(FileEntryRef Ref) {\n    Optional<FileEntryRef>::operator=(Ref);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(Optional<FileEntryRef> MaybeRef) {\n    Optional<FileEntryRef>::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const FileEntry *' to allow  FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this class and replace\n  /// instances with Optional<FileEntryRef>\n  operator const FileEntry *() const {\n    return hasValue() ? &getValue().getFileEntry() : nullptr;\n  }\n};\n\nstatic_assert(\n    std::is_trivially_copyable<\n        OptionalFileEntryRefDegradesToFileEntryPtr>::value,\n    \"OptionalFileEntryRefDegradesToFileEntryPtr should be trivially copyable\");\n\n/// Cached information about one file (either on disk\n/// or in the virtual file system).\n///\n/// If the 'File' member is valid, then this FileEntry has an open file\n/// descriptor for the file.\nclass FileEntry {\n  friend class FileManager;\n\n  std::string RealPathName;   // Real path to the file; could be empty.\n  off_t Size = 0;             // File size in bytes.\n  time_t ModTime = 0;         // Modification time of file.\n  const DirectoryEntry *Dir = nullptr; // Directory file lives in.\n  llvm::sys::fs::UniqueID UniqueID;\n  unsigned UID = 0; // A unique (small) ID for the file.\n  bool IsNamedPipe = false;\n  bool IsValid = false; // Is this \\c FileEntry initialized and valid?\n\n  /// The open file, if it is owned by the \\p FileEntry.\n  mutable std::unique_ptr<llvm::vfs::File> File;\n\n  /// The file content, if it is owned by the \\p FileEntry.\n  std::unique_ptr<llvm::MemoryBuffer> Content;\n\n  // First access name for this FileEntry.\n  //\n  // This is Optional only to allow delayed construction (FileEntryRef has no\n  // default constructor). It should always have a value in practice.\n  //\n  // TODO: remove this once everyone that needs a name uses FileEntryRef.\n  Optional<FileEntryRef> LastRef;\n\npublic:\n  FileEntry();\n  ~FileEntry();\n\n  FileEntry(const FileEntry &) = delete;\n  FileEntry &operator=(const FileEntry &) = delete;\n\n  StringRef getName() const { return LastRef->getName(); }\n  FileEntryRef getLastRef() const { return *LastRef; }\n\n  StringRef tryGetRealPathName() const { return RealPathName; }\n  bool isValid() const { return IsValid; }\n  off_t getSize() const { return Size; }\n  unsigned getUID() const { return UID; }\n  const llvm::sys::fs::UniqueID &getUniqueID() const { return UniqueID; }\n  time_t getModificationTime() const { return ModTime; }\n\n  /// Return the directory the file lives in.\n  const DirectoryEntry *getDir() const { return Dir; }\n\n  bool operator<(const FileEntry &RHS) const { return UniqueID < RHS.UniqueID; }\n\n  /// Check whether the file is a named pipe (and thus can't be opened by\n  /// the native FileManager methods).\n  bool isNamedPipe() const { return IsNamedPipe; }\n\n  void closeFile() const;\n};\n\nbool FileEntryRef::isValid() const { return getFileEntry().isValid(); }\n\noff_t FileEntryRef::getSize() const { return getFileEntry().getSize(); }\n\nunsigned FileEntryRef::getUID() const { return getFileEntry().getUID(); }\n\nconst llvm::sys::fs::UniqueID &FileEntryRef::getUniqueID() const {\n  return getFileEntry().getUniqueID();\n}\n\ntime_t FileEntryRef::getModificationTime() const {\n  return getFileEntry().getModificationTime();\n}\n\nbool FileEntryRef::isNamedPipe() const { return getFileEntry().isNamedPipe(); }\n\nvoid FileEntryRef::closeFile() const { getFileEntry().closeFile(); }\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_FILEENTRY_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "content": "//===- Module.h - Describe a module -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Module class, which describes a module in the\n/// source code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_MODULE_H\n#define LLVM_CLANG_BASIC_MODULE_H\n\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/FileEntry.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <iterator>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass FileManager;\nclass LangOptions;\nclass TargetInfo;\n\n/// Describes the name of a module.\nusing ModuleId = SmallVector<std::pair<std::string, SourceLocation>, 2>;\n\n/// The signature of a module, which is a hash of the AST content.\nstruct ASTFileSignature : std::array<uint8_t, 20> {\n  using BaseT = std::array<uint8_t, 20>;\n\n  static constexpr size_t size = std::tuple_size<BaseT>::value;\n\n  ASTFileSignature(BaseT S = {{0}}) : BaseT(std::move(S)) {}\n\n  explicit operator bool() const { return *this != BaseT({{0}}); }\n\n  /// Returns the value truncated to the size of an uint64_t.\n  uint64_t truncatedValue() const {\n    uint64_t Value = 0;\n    static_assert(sizeof(*this) >= sizeof(uint64_t), \"No need to truncate.\");\n    for (unsigned I = 0; I < sizeof(uint64_t); ++I)\n      Value |= static_cast<uint64_t>((*this)[I]) << (I * 8);\n    return Value;\n  }\n\n  static ASTFileSignature create(StringRef Bytes) {\n    return create(Bytes.bytes_begin(), Bytes.bytes_end());\n  }\n\n  static ASTFileSignature createDISentinel() {\n    ASTFileSignature Sentinel;\n    Sentinel.fill(0xFF);\n    return Sentinel;\n  }\n\n  template <typename InputIt>\n  static ASTFileSignature create(InputIt First, InputIt Last) {\n    assert(std::distance(First, Last) == size &&\n           \"Wrong amount of bytes to create an ASTFileSignature\");\n\n    ASTFileSignature Signature;\n    std::copy(First, Last, Signature.begin());\n    return Signature;\n  }\n};\n\n/// Describes a module or submodule.\nclass Module {\npublic:\n  /// The name of this module.\n  std::string Name;\n\n  /// The location of the module definition.\n  SourceLocation DefinitionLoc;\n\n  enum ModuleKind {\n    /// This is a module that was defined by a module map and built out\n    /// of header files.\n    ModuleMapModule,\n\n    /// This is a C++ Modules TS module interface unit.\n    ModuleInterfaceUnit,\n\n    /// This is a fragment of the global module within some C++ module.\n    GlobalModuleFragment,\n\n    /// This is the private module fragment within some C++ module.\n    PrivateModuleFragment,\n  };\n\n  /// The kind of this module.\n  ModuleKind Kind = ModuleMapModule;\n\n  /// The parent of this module. This will be NULL for the top-level\n  /// module.\n  Module *Parent;\n\n  /// The build directory of this module. This is the directory in\n  /// which the module is notionally built, and relative to which its headers\n  /// are found.\n  const DirectoryEntry *Directory = nullptr;\n\n  /// The presumed file name for the module map defining this module.\n  /// Only non-empty when building from preprocessed source.\n  std::string PresumedModuleMapFile;\n\n  /// The umbrella header or directory.\n  llvm::PointerUnion<const FileEntry *, const DirectoryEntry *> Umbrella;\n\n  /// The module signature.\n  ASTFileSignature Signature;\n\n  /// The name of the umbrella entry, as written in the module map.\n  std::string UmbrellaAsWritten;\n\n  /// The module through which entities defined in this module will\n  /// eventually be exposed, for use in \"private\" modules.\n  std::string ExportAsModule;\n\n  /// Does this Module scope describe part of the purview of a named C++ module?\n  bool isModulePurview() const {\n    return Kind == ModuleInterfaceUnit || Kind == PrivateModuleFragment;\n  }\n\nprivate:\n  /// The submodules of this module, indexed by name.\n  std::vector<Module *> SubModules;\n\n  /// A mapping from the submodule name to the index into the\n  /// \\c SubModules vector at which that submodule resides.\n  llvm::StringMap<unsigned> SubModuleIndex;\n\n  /// The AST file if this is a top-level module which has a\n  /// corresponding serialized AST file, or null otherwise.\n  Optional<FileEntryRef> ASTFile;\n\n  /// The top-level headers associated with this module.\n  llvm::SmallSetVector<const FileEntry *, 2> TopHeaders;\n\n  /// top-level header filenames that aren't resolved to FileEntries yet.\n  std::vector<std::string> TopHeaderNames;\n\n  /// Cache of modules visible to lookup in this module.\n  mutable llvm::DenseSet<const Module*> VisibleModulesCache;\n\n  /// The ID used when referencing this module within a VisibleModuleSet.\n  unsigned VisibilityID;\n\npublic:\n  enum HeaderKind {\n    HK_Normal,\n    HK_Textual,\n    HK_Private,\n    HK_PrivateTextual,\n    HK_Excluded\n  };\n  static const int NumHeaderKinds = HK_Excluded + 1;\n\n  /// Information about a header directive as found in the module map\n  /// file.\n  struct Header {\n    std::string NameAsWritten;\n    const FileEntry *Entry;\n\n    explicit operator bool() { return Entry; }\n  };\n\n  /// Information about a directory name as found in the module map\n  /// file.\n  struct DirectoryName {\n    std::string NameAsWritten;\n    const DirectoryEntry *Entry;\n\n    explicit operator bool() { return Entry; }\n  };\n\n  /// The headers that are part of this module.\n  SmallVector<Header, 2> Headers[5];\n\n  /// Stored information about a header directive that was found in the\n  /// module map file but has not been resolved to a file.\n  struct UnresolvedHeaderDirective {\n    HeaderKind Kind = HK_Normal;\n    SourceLocation FileNameLoc;\n    std::string FileName;\n    bool IsUmbrella = false;\n    bool HasBuiltinHeader = false;\n    Optional<off_t> Size;\n    Optional<time_t> ModTime;\n  };\n\n  /// Headers that are mentioned in the module map file but that we have not\n  /// yet attempted to resolve to a file on the file system.\n  SmallVector<UnresolvedHeaderDirective, 1> UnresolvedHeaders;\n\n  /// Headers that are mentioned in the module map file but could not be\n  /// found on the file system.\n  SmallVector<UnresolvedHeaderDirective, 1> MissingHeaders;\n\n  /// An individual requirement: a feature name and a flag indicating\n  /// the required state of that feature.\n  using Requirement = std::pair<std::string, bool>;\n\n  /// The set of language features required to use this module.\n  ///\n  /// If any of these requirements are not available, the \\c IsAvailable bit\n  /// will be false to indicate that this (sub)module is not available.\n  SmallVector<Requirement, 2> Requirements;\n\n  /// A module with the same name that shadows this module.\n  Module *ShadowingModule = nullptr;\n\n  /// Whether this module has declared itself unimportable, either because\n  /// it's missing a requirement from \\p Requirements or because it's been\n  /// shadowed by another module.\n  unsigned IsUnimportable : 1;\n\n  /// Whether we tried and failed to load a module file for this module.\n  unsigned HasIncompatibleModuleFile : 1;\n\n  /// Whether this module is available in the current translation unit.\n  ///\n  /// If the module is missing headers or does not meet all requirements then\n  /// this bit will be 0.\n  unsigned IsAvailable : 1;\n\n  /// Whether this module was loaded from a module file.\n  unsigned IsFromModuleFile : 1;\n\n  /// Whether this is a framework module.\n  unsigned IsFramework : 1;\n\n  /// Whether this is an explicit submodule.\n  unsigned IsExplicit : 1;\n\n  /// Whether this is a \"system\" module (which assumes that all\n  /// headers in it are system headers).\n  unsigned IsSystem : 1;\n\n  /// Whether this is an 'extern \"C\"' module (which implicitly puts all\n  /// headers in it within an 'extern \"C\"' block, and allows the module to be\n  /// imported within such a block).\n  unsigned IsExternC : 1;\n\n  /// Whether this is an inferred submodule (module * { ... }).\n  unsigned IsInferred : 1;\n\n  /// Whether we should infer submodules for this module based on\n  /// the headers.\n  ///\n  /// Submodules can only be inferred for modules with an umbrella header.\n  unsigned InferSubmodules : 1;\n\n  /// Whether, when inferring submodules, the inferred submodules\n  /// should be explicit.\n  unsigned InferExplicitSubmodules : 1;\n\n  /// Whether, when inferring submodules, the inferr submodules should\n  /// export all modules they import (e.g., the equivalent of \"export *\").\n  unsigned InferExportWildcard : 1;\n\n  /// Whether the set of configuration macros is exhaustive.\n  ///\n  /// When the set of configuration macros is exhaustive, meaning\n  /// that no identifier not in this list should affect how the module is\n  /// built.\n  unsigned ConfigMacrosExhaustive : 1;\n\n  /// Whether files in this module can only include non-modular headers\n  /// and headers from used modules.\n  unsigned NoUndeclaredIncludes : 1;\n\n  /// Whether this module came from a \"private\" module map, found next\n  /// to a regular (public) module map.\n  unsigned ModuleMapIsPrivate : 1;\n\n  /// Describes the visibility of the various names within a\n  /// particular module.\n  enum NameVisibilityKind {\n    /// All of the names in this module are hidden.\n    Hidden,\n    /// All of the names in this module are visible.\n    AllVisible\n  };\n\n  /// The visibility of names within this particular module.\n  NameVisibilityKind NameVisibility;\n\n  /// The location of the inferred submodule.\n  SourceLocation InferredSubmoduleLoc;\n\n  /// The set of modules imported by this module, and on which this\n  /// module depends.\n  llvm::SmallSetVector<Module *, 2> Imports;\n\n  /// Describes an exported module.\n  ///\n  /// The pointer is the module being re-exported, while the bit will be true\n  /// to indicate that this is a wildcard export.\n  using ExportDecl = llvm::PointerIntPair<Module *, 1, bool>;\n\n  /// The set of export declarations.\n  SmallVector<ExportDecl, 2> Exports;\n\n  /// Describes an exported module that has not yet been resolved\n  /// (perhaps because the module it refers to has not yet been loaded).\n  struct UnresolvedExportDecl {\n    /// The location of the 'export' keyword in the module map file.\n    SourceLocation ExportLoc;\n\n    /// The name of the module.\n    ModuleId Id;\n\n    /// Whether this export declaration ends in a wildcard, indicating\n    /// that all of its submodules should be exported (rather than the named\n    /// module itself).\n    bool Wildcard;\n  };\n\n  /// The set of export declarations that have yet to be resolved.\n  SmallVector<UnresolvedExportDecl, 2> UnresolvedExports;\n\n  /// The directly used modules.\n  SmallVector<Module *, 2> DirectUses;\n\n  /// The set of use declarations that have yet to be resolved.\n  SmallVector<ModuleId, 2> UnresolvedDirectUses;\n\n  /// A library or framework to link against when an entity from this\n  /// module is used.\n  struct LinkLibrary {\n    LinkLibrary() = default;\n    LinkLibrary(const std::string &Library, bool IsFramework)\n        : Library(Library), IsFramework(IsFramework) {}\n\n    /// The library to link against.\n    ///\n    /// This will typically be a library or framework name, but can also\n    /// be an absolute path to the library or framework.\n    std::string Library;\n\n    /// Whether this is a framework rather than a library.\n    bool IsFramework = false;\n  };\n\n  /// The set of libraries or frameworks to link against when\n  /// an entity from this module is used.\n  llvm::SmallVector<LinkLibrary, 2> LinkLibraries;\n\n  /// Autolinking uses the framework name for linking purposes\n  /// when this is false and the export_as name otherwise.\n  bool UseExportAsModuleLinkName = false;\n\n  /// The set of \"configuration macros\", which are macros that\n  /// (intentionally) change how this module is built.\n  std::vector<std::string> ConfigMacros;\n\n  /// An unresolved conflict with another module.\n  struct UnresolvedConflict {\n    /// The (unresolved) module id.\n    ModuleId Id;\n\n    /// The message provided to the user when there is a conflict.\n    std::string Message;\n  };\n\n  /// The list of conflicts for which the module-id has not yet been\n  /// resolved.\n  std::vector<UnresolvedConflict> UnresolvedConflicts;\n\n  /// A conflict between two modules.\n  struct Conflict {\n    /// The module that this module conflicts with.\n    Module *Other;\n\n    /// The message provided to the user when there is a conflict.\n    std::string Message;\n  };\n\n  /// The list of conflicts.\n  std::vector<Conflict> Conflicts;\n\n  /// Construct a new module or submodule.\n  Module(StringRef Name, SourceLocation DefinitionLoc, Module *Parent,\n         bool IsFramework, bool IsExplicit, unsigned VisibilityID);\n\n  ~Module();\n\n  /// Determine whether this module has been declared unimportable.\n  bool isUnimportable() const { return IsUnimportable; }\n\n  /// Determine whether this module has been declared unimportable.\n  ///\n  /// \\param LangOpts The language options used for the current\n  /// translation unit.\n  ///\n  /// \\param Target The target options used for the current translation unit.\n  ///\n  /// \\param Req If this module is unimportable because of a missing\n  /// requirement, this parameter will be set to one of the requirements that\n  /// is not met for use of this module.\n  ///\n  /// \\param ShadowingModule If this module is unimportable because it is\n  /// shadowed, this parameter will be set to the shadowing module.\n  bool isUnimportable(const LangOptions &LangOpts, const TargetInfo &Target,\n                      Requirement &Req, Module *&ShadowingModule) const;\n\n  /// Determine whether this module is available for use within the\n  /// current translation unit.\n  bool isAvailable() const { return IsAvailable; }\n\n  /// Determine whether this module is available for use within the\n  /// current translation unit.\n  ///\n  /// \\param LangOpts The language options used for the current\n  /// translation unit.\n  ///\n  /// \\param Target The target options used for the current translation unit.\n  ///\n  /// \\param Req If this module is unavailable because of a missing requirement,\n  /// this parameter will be set to one of the requirements that is not met for\n  /// use of this module.\n  ///\n  /// \\param MissingHeader If this module is unavailable because of a missing\n  /// header, this parameter will be set to one of the missing headers.\n  ///\n  /// \\param ShadowingModule If this module is unavailable because it is\n  /// shadowed, this parameter will be set to the shadowing module.\n  bool isAvailable(const LangOptions &LangOpts,\n                   const TargetInfo &Target,\n                   Requirement &Req,\n                   UnresolvedHeaderDirective &MissingHeader,\n                   Module *&ShadowingModule) const;\n\n  /// Determine whether this module is a submodule.\n  bool isSubModule() const { return Parent != nullptr; }\n\n  /// Check if this module is a (possibly transitive) submodule of \\p Other.\n  ///\n  /// The 'A is a submodule of B' relation is a partial order based on the\n  /// the parent-child relationship between individual modules.\n  ///\n  /// Returns \\c false if \\p Other is \\c nullptr.\n  bool isSubModuleOf(const Module *Other) const;\n\n  /// Determine whether this module is a part of a framework,\n  /// either because it is a framework module or because it is a submodule\n  /// of a framework module.\n  bool isPartOfFramework() const {\n    for (const Module *Mod = this; Mod; Mod = Mod->Parent)\n      if (Mod->IsFramework)\n        return true;\n\n    return false;\n  }\n\n  /// Determine whether this module is a subframework of another\n  /// framework.\n  bool isSubFramework() const {\n    return IsFramework && Parent && Parent->isPartOfFramework();\n  }\n\n  /// Set the parent of this module. This should only be used if the parent\n  /// could not be set during module creation.\n  void setParent(Module *M) {\n    assert(!Parent);\n    Parent = M;\n    Parent->SubModuleIndex[Name] = Parent->SubModules.size();\n    Parent->SubModules.push_back(this);\n  }\n\n  /// Retrieve the full name of this module, including the path from\n  /// its top-level module.\n  /// \\param AllowStringLiterals If \\c true, components that might not be\n  ///        lexically valid as identifiers will be emitted as string literals.\n  std::string getFullModuleName(bool AllowStringLiterals = false) const;\n\n  /// Whether the full name of this module is equal to joining\n  /// \\p nameParts with \".\"s.\n  ///\n  /// This is more efficient than getFullModuleName().\n  bool fullModuleNameIs(ArrayRef<StringRef> nameParts) const;\n\n  /// Retrieve the top-level module for this (sub)module, which may\n  /// be this module.\n  Module *getTopLevelModule() {\n    return const_cast<Module *>(\n             const_cast<const Module *>(this)->getTopLevelModule());\n  }\n\n  /// Retrieve the top-level module for this (sub)module, which may\n  /// be this module.\n  const Module *getTopLevelModule() const;\n\n  /// Retrieve the name of the top-level module.\n  StringRef getTopLevelModuleName() const {\n    return getTopLevelModule()->Name;\n  }\n\n  /// The serialized AST file for this module, if one was created.\n  OptionalFileEntryRefDegradesToFileEntryPtr getASTFile() const {\n    return getTopLevelModule()->ASTFile;\n  }\n\n  /// Set the serialized AST file for the top-level module of this module.\n  void setASTFile(Optional<FileEntryRef> File) {\n    assert((!File || !getASTFile() || getASTFile() == File) &&\n           \"file path changed\");\n    getTopLevelModule()->ASTFile = File;\n  }\n\n  /// Retrieve the directory for which this module serves as the\n  /// umbrella.\n  DirectoryName getUmbrellaDir() const;\n\n  /// Retrieve the header that serves as the umbrella header for this\n  /// module.\n  Header getUmbrellaHeader() const {\n    if (auto *FE = Umbrella.dyn_cast<const FileEntry *>())\n      return Header{UmbrellaAsWritten, FE};\n    return Header{};\n  }\n\n  /// Determine whether this module has an umbrella directory that is\n  /// not based on an umbrella header.\n  bool hasUmbrellaDir() const {\n    return Umbrella && Umbrella.is<const DirectoryEntry *>();\n  }\n\n  /// Add a top-level header associated with this module.\n  void addTopHeader(const FileEntry *File);\n\n  /// Add a top-level header filename associated with this module.\n  void addTopHeaderFilename(StringRef Filename) {\n    TopHeaderNames.push_back(std::string(Filename));\n  }\n\n  /// The top-level headers associated with this module.\n  ArrayRef<const FileEntry *> getTopHeaders(FileManager &FileMgr);\n\n  /// Determine whether this module has declared its intention to\n  /// directly use another module.\n  bool directlyUses(const Module *Requested) const;\n\n  /// Add the given feature requirement to the list of features\n  /// required by this module.\n  ///\n  /// \\param Feature The feature that is required by this module (and\n  /// its submodules).\n  ///\n  /// \\param RequiredState The required state of this feature: \\c true\n  /// if it must be present, \\c false if it must be absent.\n  ///\n  /// \\param LangOpts The set of language options that will be used to\n  /// evaluate the availability of this feature.\n  ///\n  /// \\param Target The target options that will be used to evaluate the\n  /// availability of this feature.\n  void addRequirement(StringRef Feature, bool RequiredState,\n                      const LangOptions &LangOpts,\n                      const TargetInfo &Target);\n\n  /// Mark this module and all of its submodules as unavailable.\n  void markUnavailable(bool Unimportable);\n\n  /// Find the submodule with the given name.\n  ///\n  /// \\returns The submodule if found, or NULL otherwise.\n  Module *findSubmodule(StringRef Name) const;\n  Module *findOrInferSubmodule(StringRef Name);\n\n  /// Determine whether the specified module would be visible to\n  /// a lookup at the end of this module.\n  ///\n  /// FIXME: This may return incorrect results for (submodules of) the\n  /// module currently being built, if it's queried before we see all\n  /// of its imports.\n  bool isModuleVisible(const Module *M) const {\n    if (VisibleModulesCache.empty())\n      buildVisibleModulesCache();\n    return VisibleModulesCache.count(M);\n  }\n\n  unsigned getVisibilityID() const { return VisibilityID; }\n\n  using submodule_iterator = std::vector<Module *>::iterator;\n  using submodule_const_iterator = std::vector<Module *>::const_iterator;\n\n  submodule_iterator submodule_begin() { return SubModules.begin(); }\n  submodule_const_iterator submodule_begin() const {return SubModules.begin();}\n  submodule_iterator submodule_end()   { return SubModules.end(); }\n  submodule_const_iterator submodule_end() const { return SubModules.end(); }\n\n  llvm::iterator_range<submodule_iterator> submodules() {\n    return llvm::make_range(submodule_begin(), submodule_end());\n  }\n  llvm::iterator_range<submodule_const_iterator> submodules() const {\n    return llvm::make_range(submodule_begin(), submodule_end());\n  }\n\n  /// Appends this module's list of exported modules to \\p Exported.\n  ///\n  /// This provides a subset of immediately imported modules (the ones that are\n  /// directly exported), not the complete set of exported modules.\n  void getExportedModules(SmallVectorImpl<Module *> &Exported) const;\n\n  static StringRef getModuleInputBufferName() {\n    return \"<module-includes>\";\n  }\n\n  /// Print the module map for this module to the given stream.\n  void print(raw_ostream &OS, unsigned Indent = 0) const;\n\n  /// Dump the contents of this module to the given output stream.\n  void dump() const;\n\nprivate:\n  void buildVisibleModulesCache() const;\n};\n\n/// A set of visible modules.\nclass VisibleModuleSet {\npublic:\n  VisibleModuleSet() = default;\n  VisibleModuleSet(VisibleModuleSet &&O)\n      : ImportLocs(std::move(O.ImportLocs)), Generation(O.Generation ? 1 : 0) {\n    O.ImportLocs.clear();\n    ++O.Generation;\n  }\n\n  /// Move from another visible modules set. Guaranteed to leave the source\n  /// empty and bump the generation on both.\n  VisibleModuleSet &operator=(VisibleModuleSet &&O) {\n    ImportLocs = std::move(O.ImportLocs);\n    O.ImportLocs.clear();\n    ++O.Generation;\n    ++Generation;\n    return *this;\n  }\n\n  /// Get the current visibility generation. Incremented each time the\n  /// set of visible modules changes in any way.\n  unsigned getGeneration() const { return Generation; }\n\n  /// Determine whether a module is visible.\n  bool isVisible(const Module *M) const {\n    return getImportLoc(M).isValid();\n  }\n\n  /// Get the location at which the import of a module was triggered.\n  SourceLocation getImportLoc(const Module *M) const {\n    return M->getVisibilityID() < ImportLocs.size()\n               ? ImportLocs[M->getVisibilityID()]\n               : SourceLocation();\n  }\n\n  /// A callback to call when a module is made visible (directly or\n  /// indirectly) by a call to \\ref setVisible.\n  using VisibleCallback = llvm::function_ref<void(Module *M)>;\n\n  /// A callback to call when a module conflict is found. \\p Path\n  /// consists of a sequence of modules from the conflicting module to the one\n  /// made visible, where each was exported by the next.\n  using ConflictCallback =\n      llvm::function_ref<void(ArrayRef<Module *> Path, Module *Conflict,\n                         StringRef Message)>;\n\n  /// Make a specific module visible.\n  void setVisible(Module *M, SourceLocation Loc,\n                  VisibleCallback Vis = [](Module *) {},\n                  ConflictCallback Cb = [](ArrayRef<Module *>, Module *,\n                                           StringRef) {});\n\nprivate:\n  /// Import locations for each visible module. Indexed by the module's\n  /// VisibilityID.\n  std::vector<SourceLocation> ImportLocs;\n\n  /// Visibility generation, bumped every time the visibility state changes.\n  unsigned Generation = 0;\n};\n\n/// Abstracts clang modules and precompiled header files and holds\n/// everything needed to generate debug info for an imported module\n/// or PCH.\nclass ASTSourceDescriptor {\n  StringRef PCHModuleName;\n  StringRef Path;\n  StringRef ASTFile;\n  ASTFileSignature Signature;\n  Module *ClangModule = nullptr;\n\npublic:\n  ASTSourceDescriptor() = default;\n  ASTSourceDescriptor(StringRef Name, StringRef Path, StringRef ASTFile,\n                      ASTFileSignature Signature)\n      : PCHModuleName(std::move(Name)), Path(std::move(Path)),\n        ASTFile(std::move(ASTFile)), Signature(Signature) {}\n  ASTSourceDescriptor(Module &M);\n\n  std::string getModuleName() const;\n  StringRef getPath() const { return Path; }\n  StringRef getASTFile() const { return ASTFile; }\n  ASTFileSignature getSignature() const { return Signature; }\n  Module *getModuleOrNull() const { return ClangModule; }\n};\n\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_MODULE_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "content": "//===- SourceManager.h - Track and cache source files -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the SourceManager interface.\n///\n/// There are three different types of locations in a %file: a spelling\n/// location, an expansion location, and a presumed location.\n///\n/// Given an example of:\n/// \\code\n/// #define min(x, y) x < y ? x : y\n/// \\endcode\n///\n/// and then later on a use of min:\n/// \\code\n/// #line 17\n/// return min(a, b);\n/// \\endcode\n///\n/// The expansion location is the line in the source code where the macro\n/// was expanded (the return statement), the spelling location is the\n/// location in the source where the macro was originally defined,\n/// and the presumed location is where the line directive states that\n/// the line is 17, or any other line.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SOURCEMANAGER_H\n#define LLVM_CLANG_BASIC_SOURCEMANAGER_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileEntry.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstddef>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTReader;\nclass ASTWriter;\nclass FileManager;\nclass LineTableInfo;\nclass SourceManager;\n\n/// Public enums and private classes that are part of the\n/// SourceManager implementation.\nnamespace SrcMgr {\n\n/// Indicates whether a file or directory holds normal user code,\n/// system code, or system code which is implicitly 'extern \"C\"' in C++ mode.\n///\n/// Entire directories can be tagged with this (this is maintained by\n/// DirectoryLookup and friends) as can specific FileInfos when a \\#pragma\n/// system_header is seen or in various other cases.\n///\nenum CharacteristicKind {\n  C_User,\n  C_System,\n  C_ExternCSystem,\n  C_User_ModuleMap,\n  C_System_ModuleMap\n};\n\n/// Determine whether a file / directory characteristic is for system code.\ninline bool isSystem(CharacteristicKind CK) {\n  return CK != C_User && CK != C_User_ModuleMap;\n}\n\n/// Determine whether a file characteristic is for a module map.\ninline bool isModuleMap(CharacteristicKind CK) {\n  return CK == C_User_ModuleMap || CK == C_System_ModuleMap;\n}\n\n/// Mapping of line offsets into a source file. This does not own the storage\n/// for the line numbers.\nclass LineOffsetMapping {\npublic:\n  explicit operator bool() const { return Storage; }\n  unsigned size() const {\n    assert(Storage);\n    return Storage[0];\n  }\n  ArrayRef<unsigned> getLines() const {\n    assert(Storage);\n    return ArrayRef<unsigned>(Storage + 1, Storage + 1 + size());\n  }\n  const unsigned *begin() const { return getLines().begin(); }\n  const unsigned *end() const { return getLines().end(); }\n  const unsigned &operator[](int I) const { return getLines()[I]; }\n\n  static LineOffsetMapping get(llvm::MemoryBufferRef Buffer,\n                               llvm::BumpPtrAllocator &Alloc);\n\n  LineOffsetMapping() = default;\n  LineOffsetMapping(ArrayRef<unsigned> LineOffsets,\n                    llvm::BumpPtrAllocator &Alloc);\n\nprivate:\n  /// First element is the size, followed by elements at off-by-one indexes.\n  unsigned *Storage = nullptr;\n};\n\n/// One instance of this struct is kept for every file loaded or used.\n///\n/// This object owns the MemoryBuffer object.\nclass alignas(8) ContentCache {\n  /// The actual buffer containing the characters from the input\n  /// file.\n  mutable std::unique_ptr<llvm::MemoryBuffer> Buffer;\n\npublic:\n  /// Reference to the file entry representing this ContentCache.\n  ///\n  /// This reference does not own the FileEntry object.\n  ///\n  /// It is possible for this to be NULL if the ContentCache encapsulates\n  /// an imaginary text buffer.\n  ///\n  /// FIXME: Turn this into a FileEntryRef and remove Filename.\n  const FileEntry *OrigEntry;\n\n  /// References the file which the contents were actually loaded from.\n  ///\n  /// Can be different from 'Entry' if we overridden the contents of one file\n  /// with the contents of another file.\n  const FileEntry *ContentsEntry;\n\n  /// The filename that is used to access OrigEntry.\n  ///\n  /// FIXME: Remove this once OrigEntry is a FileEntryRef with a stable name.\n  StringRef Filename;\n\n  /// A bump pointer allocated array of offsets for each source line.\n  ///\n  /// This is lazily computed.  The lines are owned by the SourceManager\n  /// BumpPointerAllocator object.\n  mutable LineOffsetMapping SourceLineCache;\n\n  /// Indicates whether the buffer itself was provided to override\n  /// the actual file contents.\n  ///\n  /// When true, the original entry may be a virtual file that does not\n  /// exist.\n  unsigned BufferOverridden : 1;\n\n  /// True if this content cache was initially created for a source file\n  /// considered to be volatile (likely to change between stat and open).\n  unsigned IsFileVolatile : 1;\n\n  /// True if this file may be transient, that is, if it might not\n  /// exist at some later point in time when this content entry is used,\n  /// after serialization and deserialization.\n  unsigned IsTransient : 1;\n\n  mutable unsigned IsBufferInvalid : 1;\n\n  ContentCache(const FileEntry *Ent = nullptr) : ContentCache(Ent, Ent) {}\n\n  ContentCache(const FileEntry *Ent, const FileEntry *contentEnt)\n      : OrigEntry(Ent), ContentsEntry(contentEnt), BufferOverridden(false),\n        IsFileVolatile(false), IsTransient(false), IsBufferInvalid(false) {}\n\n  /// The copy ctor does not allow copies where source object has either\n  /// a non-NULL Buffer or SourceLineCache.  Ownership of allocated memory\n  /// is not transferred, so this is a logical error.\n  ContentCache(const ContentCache &RHS)\n      : BufferOverridden(false), IsFileVolatile(false), IsTransient(false),\n        IsBufferInvalid(false) {\n    OrigEntry = RHS.OrigEntry;\n    ContentsEntry = RHS.ContentsEntry;\n\n    assert(!RHS.Buffer && !RHS.SourceLineCache &&\n           \"Passed ContentCache object cannot own a buffer.\");\n  }\n\n  ContentCache &operator=(const ContentCache &RHS) = delete;\n\n  /// Returns the memory buffer for the associated content.\n  ///\n  /// \\param Diag Object through which diagnostics will be emitted if the\n  ///   buffer cannot be retrieved.\n  ///\n  /// \\param Loc If specified, is the location that invalid file diagnostics\n  ///   will be emitted at.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getBufferOrNone(DiagnosticsEngine &Diag, FileManager &FM,\n                  SourceLocation Loc = SourceLocation()) const;\n\n  /// Returns the size of the content encapsulated by this\n  /// ContentCache.\n  ///\n  /// This can be the size of the source file or the size of an\n  /// arbitrary scratch buffer.  If the ContentCache encapsulates a source\n  /// file this size is retrieved from the file's FileEntry.\n  unsigned getSize() const;\n\n  /// Returns the number of bytes actually mapped for this\n  /// ContentCache.\n  ///\n  /// This can be 0 if the MemBuffer was not actually expanded.\n  unsigned getSizeBytesMapped() const;\n\n  /// Returns the kind of memory used to back the memory buffer for\n  /// this content cache.  This is used for performance analysis.\n  llvm::MemoryBuffer::BufferKind getMemoryBufferKind() const;\n\n  /// Return the buffer, only if it has been loaded.\n  llvm::Optional<llvm::MemoryBufferRef> getBufferIfLoaded() const {\n    if (Buffer)\n      return Buffer->getMemBufferRef();\n    return None;\n  }\n\n  /// Return a StringRef to the source buffer data, only if it has already\n  /// been loaded.\n  llvm::Optional<StringRef> getBufferDataIfLoaded() const {\n    if (Buffer)\n      return Buffer->getBuffer();\n    return None;\n  }\n\n  /// Set the buffer.\n  void setBuffer(std::unique_ptr<llvm::MemoryBuffer> B) {\n    IsBufferInvalid = false;\n    Buffer = std::move(B);\n  }\n\n  /// Set the buffer to one that's not owned (or to nullptr).\n  ///\n  /// \\pre Buffer cannot already be set.\n  void setUnownedBuffer(llvm::Optional<llvm::MemoryBufferRef> B) {\n    assert(!Buffer && \"Expected to be called right after construction\");\n    if (B)\n      setBuffer(llvm::MemoryBuffer::getMemBuffer(*B));\n  }\n\n  // If BufStr has an invalid BOM, returns the BOM name; otherwise, returns\n  // nullptr\n  static const char *getInvalidBOM(StringRef BufStr);\n};\n\n// Assert that the \\c ContentCache objects will always be 8-byte aligned so\n// that we can pack 3 bits of integer into pointers to such objects.\nstatic_assert(alignof(ContentCache) >= 8,\n              \"ContentCache must be 8-byte aligned.\");\n\n/// Information about a FileID, basically just the logical file\n/// that it represents and include stack information.\n///\n/// Each FileInfo has include stack information, indicating where it came\n/// from. This information encodes the \\#include chain that a token was\n/// expanded from. The main include file has an invalid IncludeLoc.\n///\n/// FileInfo should not grow larger than ExpansionInfo. Doing so will\n/// cause memory to bloat in compilations with many unloaded macro\n/// expansions, since the two data structurs are stored in a union in\n/// SLocEntry. Extra fields should instead go in \"ContentCache *\", which\n/// stores file contents and other bits on the side.\n///\nclass FileInfo {\n  friend class clang::SourceManager;\n  friend class clang::ASTWriter;\n  friend class clang::ASTReader;\n\n  /// The location of the \\#include that brought in this file.\n  ///\n  /// This is an invalid SLOC for the main file (top of the \\#include chain).\n  SourceLocation IncludeLoc;\n\n  /// Number of FileIDs (files and macros) that were created during\n  /// preprocessing of this \\#include, including this SLocEntry.\n  ///\n  /// Zero means the preprocessor didn't provide such info for this SLocEntry.\n  unsigned NumCreatedFIDs : 31;\n\n  /// Whether this FileInfo has any \\#line directives.\n  unsigned HasLineDirectives : 1;\n\n  /// The content cache and the characteristic of the file.\n  llvm::PointerIntPair<const ContentCache *, 3, CharacteristicKind>\n      ContentAndKind;\n\npublic:\n  /// Return a FileInfo object.\n  static FileInfo get(SourceLocation IL, ContentCache &Con,\n                      CharacteristicKind FileCharacter, StringRef Filename) {\n    FileInfo X;\n    X.IncludeLoc = IL;\n    X.NumCreatedFIDs = 0;\n    X.HasLineDirectives = false;\n    X.ContentAndKind.setPointer(&Con);\n    X.ContentAndKind.setInt(FileCharacter);\n    Con.Filename = Filename;\n    return X;\n  }\n\n  SourceLocation getIncludeLoc() const {\n    return IncludeLoc;\n  }\n\n  const ContentCache &getContentCache() const {\n    return *ContentAndKind.getPointer();\n  }\n\n  /// Return whether this is a system header or not.\n  CharacteristicKind getFileCharacteristic() const {\n    return ContentAndKind.getInt();\n  }\n\n  /// Return true if this FileID has \\#line directives in it.\n  bool hasLineDirectives() const { return HasLineDirectives; }\n\n  /// Set the flag that indicates that this FileID has\n  /// line table entries associated with it.\n  void setHasLineDirectives() { HasLineDirectives = true; }\n\n  /// Returns the name of the file that was used when the file was loaded from\n  /// the underlying file system.\n  StringRef getName() const { return getContentCache().Filename; }\n};\n\n/// Each ExpansionInfo encodes the expansion location - where\n/// the token was ultimately expanded, and the SpellingLoc - where the actual\n/// character data for the token came from.\nclass ExpansionInfo {\n  // Really these are all SourceLocations.\n\n  /// Where the spelling for the token can be found.\n  SourceLocation SpellingLoc;\n\n  /// In a macro expansion, ExpansionLocStart and ExpansionLocEnd\n  /// indicate the start and end of the expansion. In object-like macros,\n  /// they will be the same. In a function-like macro expansion, the start\n  /// will be the identifier and the end will be the ')'. Finally, in\n  /// macro-argument instantiations, the end will be 'SourceLocation()', an\n  /// invalid location.\n  SourceLocation ExpansionLocStart, ExpansionLocEnd;\n\n  /// Whether the expansion range is a token range.\n  bool ExpansionIsTokenRange;\n\npublic:\n  SourceLocation getSpellingLoc() const {\n    return SpellingLoc.isInvalid() ? getExpansionLocStart() : SpellingLoc;\n  }\n\n  SourceLocation getExpansionLocStart() const {\n    return ExpansionLocStart;\n  }\n\n  SourceLocation getExpansionLocEnd() const {\n    return ExpansionLocEnd.isInvalid() ? getExpansionLocStart()\n                                       : ExpansionLocEnd;\n  }\n\n  bool isExpansionTokenRange() const { return ExpansionIsTokenRange; }\n\n  CharSourceRange getExpansionLocRange() const {\n    return CharSourceRange(\n        SourceRange(getExpansionLocStart(), getExpansionLocEnd()),\n        isExpansionTokenRange());\n  }\n\n  bool isMacroArgExpansion() const {\n    // Note that this needs to return false for default constructed objects.\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isInvalid();\n  }\n\n  bool isMacroBodyExpansion() const {\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isValid();\n  }\n\n  bool isFunctionMacroExpansion() const {\n    return getExpansionLocStart().isValid() &&\n           getExpansionLocStart() != getExpansionLocEnd();\n  }\n\n  /// Return a ExpansionInfo for an expansion.\n  ///\n  /// Start and End specify the expansion range (where the macro is\n  /// expanded), and SpellingLoc specifies the spelling location (where\n  /// the characters from the token come from). All three can refer to\n  /// normal File SLocs or expansion locations.\n  static ExpansionInfo create(SourceLocation SpellingLoc, SourceLocation Start,\n                              SourceLocation End,\n                              bool ExpansionIsTokenRange = true) {\n    ExpansionInfo X;\n    X.SpellingLoc = SpellingLoc;\n    X.ExpansionLocStart = Start;\n    X.ExpansionLocEnd = End;\n    X.ExpansionIsTokenRange = ExpansionIsTokenRange;\n    return X;\n  }\n\n  /// Return a special ExpansionInfo for the expansion of\n  /// a macro argument into a function-like macro's body.\n  ///\n  /// ExpansionLoc specifies the expansion location (where the macro is\n  /// expanded). This doesn't need to be a range because a macro is always\n  /// expanded at a macro parameter reference, and macro parameters are\n  /// always exactly one token. SpellingLoc specifies the spelling location\n  /// (where the characters from the token come from). ExpansionLoc and\n  /// SpellingLoc can both refer to normal File SLocs or expansion locations.\n  ///\n  /// Given the code:\n  /// \\code\n  ///   #define F(x) f(x)\n  ///   F(42);\n  /// \\endcode\n  ///\n  /// When expanding '\\c F(42)', the '\\c x' would call this with an\n  /// SpellingLoc pointing at '\\c 42' and an ExpansionLoc pointing at its\n  /// location in the definition of '\\c F'.\n  static ExpansionInfo createForMacroArg(SourceLocation SpellingLoc,\n                                         SourceLocation ExpansionLoc) {\n    // We store an intentionally invalid source location for the end of the\n    // expansion range to mark that this is a macro argument location rather\n    // than a normal one.\n    return create(SpellingLoc, ExpansionLoc, SourceLocation());\n  }\n\n  /// Return a special ExpansionInfo representing a token that ends\n  /// prematurely. This is used to model a '>>' token that has been split\n  /// into '>' tokens and similar cases. Unlike for the other forms of\n  /// expansion, the expansion range in this case is a character range, not\n  /// a token range.\n  static ExpansionInfo createForTokenSplit(SourceLocation SpellingLoc,\n                                           SourceLocation Start,\n                                           SourceLocation End) {\n    return create(SpellingLoc, Start, End, false);\n  }\n};\n\n// Assert that the \\c FileInfo objects are no bigger than \\c ExpansionInfo\n// objects. This controls the size of \\c SLocEntry, of which we have one for\n// each macro expansion. The number of (unloaded) macro expansions can be\n// very large. Any other fields needed in FileInfo should go in ContentCache.\nstatic_assert(sizeof(FileInfo) <= sizeof(ExpansionInfo),\n              \"FileInfo must be no larger than ExpansionInfo.\");\n\n/// This is a discriminated union of FileInfo and ExpansionInfo.\n///\n/// SourceManager keeps an array of these objects, and they are uniquely\n/// identified by the FileID datatype.\nclass SLocEntry {\n  unsigned Offset : 31;\n  unsigned IsExpansion : 1;\n  union {\n    FileInfo File;\n    ExpansionInfo Expansion;\n  };\n\npublic:\n  SLocEntry() : Offset(), IsExpansion(), File() {}\n\n  unsigned getOffset() const { return Offset; }\n\n  bool isExpansion() const { return IsExpansion; }\n  bool isFile() const { return !isExpansion(); }\n\n  const FileInfo &getFile() const {\n    assert(isFile() && \"Not a file SLocEntry!\");\n    return File;\n  }\n\n  const ExpansionInfo &getExpansion() const {\n    assert(isExpansion() && \"Not a macro expansion SLocEntry!\");\n    return Expansion;\n  }\n\n  static SLocEntry get(unsigned Offset, const FileInfo &FI) {\n    assert(!(Offset & (1u << 31)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = false;\n    E.File = FI;\n    return E;\n  }\n\n  static SLocEntry get(unsigned Offset, const ExpansionInfo &Expansion) {\n    assert(!(Offset & (1u << 31)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = true;\n    new (&E.Expansion) ExpansionInfo(Expansion);\n    return E;\n  }\n};\n\n} // namespace SrcMgr\n\n/// External source of source location entries.\nclass ExternalSLocEntrySource {\npublic:\n  virtual ~ExternalSLocEntrySource();\n\n  /// Read the source location entry with index ID, which will always be\n  /// less than -1.\n  ///\n  /// \\returns true if an error occurred that prevented the source-location\n  /// entry from being loaded.\n  virtual bool ReadSLocEntry(int ID) = 0;\n\n  /// Retrieve the module import location and name for the given ID, if\n  /// in fact it was loaded from a module (rather than, say, a precompiled\n  /// header).\n  virtual std::pair<SourceLocation, StringRef> getModuleImportLoc(int ID) = 0;\n};\n\n/// Holds the cache used by isBeforeInTranslationUnit.\n///\n/// The cache structure is complex enough to be worth breaking out of\n/// SourceManager.\nclass InBeforeInTUCacheEntry {\n  /// The FileID's of the cached query.\n  ///\n  /// If these match up with a subsequent query, the result can be reused.\n  FileID LQueryFID, RQueryFID;\n\n  /// True if LQueryFID was created before RQueryFID.\n  ///\n  /// This is used to compare macro expansion locations.\n  bool IsLQFIDBeforeRQFID;\n\n  /// The file found in common between the two \\#include traces, i.e.,\n  /// the nearest common ancestor of the \\#include tree.\n  FileID CommonFID;\n\n  /// The offset of the previous query in CommonFID.\n  ///\n  /// Usually, this represents the location of the \\#include for QueryFID, but\n  /// if LQueryFID is a parent of RQueryFID (or vice versa) then these can be a\n  /// random token in the parent.\n  unsigned LCommonOffset, RCommonOffset;\n\npublic:\n  /// Return true if the currently cached values match up with\n  /// the specified LHS/RHS query.\n  ///\n  /// If not, we can't use the cache.\n  bool isCacheValid(FileID LHS, FileID RHS) const {\n    return LQueryFID == LHS && RQueryFID == RHS;\n  }\n\n  /// If the cache is valid, compute the result given the\n  /// specified offsets in the LHS/RHS FileID's.\n  bool getCachedResult(unsigned LOffset, unsigned ROffset) const {\n    // If one of the query files is the common file, use the offset.  Otherwise,\n    // use the #include loc in the common file.\n    if (LQueryFID != CommonFID) LOffset = LCommonOffset;\n    if (RQueryFID != CommonFID) ROffset = RCommonOffset;\n\n    // It is common for multiple macro expansions to be \"included\" from the same\n    // location (expansion location), in which case use the order of the FileIDs\n    // to determine which came first. This will also take care the case where\n    // one of the locations points at the inclusion/expansion point of the other\n    // in which case its FileID will come before the other.\n    if (LOffset == ROffset)\n      return IsLQFIDBeforeRQFID;\n\n    return LOffset < ROffset;\n  }\n\n  /// Set up a new query.\n  void setQueryFIDs(FileID LHS, FileID RHS, bool isLFIDBeforeRFID) {\n    assert(LHS != RHS);\n    LQueryFID = LHS;\n    RQueryFID = RHS;\n    IsLQFIDBeforeRQFID = isLFIDBeforeRFID;\n  }\n\n  void clear() {\n    LQueryFID = RQueryFID = FileID();\n    IsLQFIDBeforeRQFID = false;\n  }\n\n  void setCommonLoc(FileID commonFID, unsigned lCommonOffset,\n                    unsigned rCommonOffset) {\n    CommonFID = commonFID;\n    LCommonOffset = lCommonOffset;\n    RCommonOffset = rCommonOffset;\n  }\n};\n\n/// The stack used when building modules on demand, which is used\n/// to provide a link between the source managers of the different compiler\n/// instances.\nusing ModuleBuildStack = ArrayRef<std::pair<std::string, FullSourceLoc>>;\n\n/// This class handles loading and caching of source files into memory.\n///\n/// This object owns the MemoryBuffer objects for all of the loaded\n/// files and assigns unique FileID's for each unique \\#include chain.\n///\n/// The SourceManager can be queried for information about SourceLocation\n/// objects, turning them into either spelling or expansion locations. Spelling\n/// locations represent where the bytes corresponding to a token came from and\n/// expansion locations represent where the location is in the user's view. In\n/// the case of a macro expansion, for example, the spelling location indicates\n/// where the expanded token came from and the expansion location specifies\n/// where it was expanded.\nclass SourceManager : public RefCountedBase<SourceManager> {\n  /// DiagnosticsEngine object.\n  DiagnosticsEngine &Diag;\n\n  FileManager &FileMgr;\n\n  mutable llvm::BumpPtrAllocator ContentCacheAlloc;\n\n  /// Memoized information about all of the files tracked by this\n  /// SourceManager.\n  ///\n  /// This map allows us to merge ContentCache entries based\n  /// on their FileEntry*.  All ContentCache objects will thus have unique,\n  /// non-null, FileEntry pointers.\n  llvm::DenseMap<const FileEntry*, SrcMgr::ContentCache*> FileInfos;\n\n  /// True if the ContentCache for files that are overridden by other\n  /// files, should report the original file name. Defaults to true.\n  bool OverridenFilesKeepOriginalName = true;\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them). Defaults to false.\n  bool UserFilesAreVolatile;\n\n  /// True if all files read during this compilation should be treated\n  /// as transient (may not be present in later compilations using a module\n  /// file created from this compilation). Defaults to false.\n  bool FilesAreTransient = false;\n\n  struct OverriddenFilesInfoTy {\n    /// Files that have been overridden with the contents from another\n    /// file.\n    llvm::DenseMap<const FileEntry *, const FileEntry *> OverriddenFiles;\n\n    /// Files that were overridden with a memory buffer.\n    llvm::DenseSet<const FileEntry *> OverriddenFilesWithBuffer;\n  };\n\n  /// Lazily create the object keeping overridden files info, since\n  /// it is uncommonly used.\n  std::unique_ptr<OverriddenFilesInfoTy> OverriddenFilesInfo;\n\n  OverriddenFilesInfoTy &getOverriddenFilesInfo() {\n    if (!OverriddenFilesInfo)\n      OverriddenFilesInfo.reset(new OverriddenFilesInfoTy);\n    return *OverriddenFilesInfo;\n  }\n\n  /// Information about various memory buffers that we have read in.\n  ///\n  /// All FileEntry* within the stored ContentCache objects are NULL,\n  /// as they do not refer to a file.\n  std::vector<SrcMgr::ContentCache*> MemBufferInfos;\n\n  /// The table of SLocEntries that are local to this module.\n  ///\n  /// Positive FileIDs are indexes into this table. Entry 0 indicates an invalid\n  /// expansion.\n  SmallVector<SrcMgr::SLocEntry, 0> LocalSLocEntryTable;\n\n  /// The table of SLocEntries that are loaded from other modules.\n  ///\n  /// Negative FileIDs are indexes into this table. To get from ID to an index,\n  /// use (-ID - 2).\n  SmallVector<SrcMgr::SLocEntry, 0> LoadedSLocEntryTable;\n\n  /// The starting offset of the next local SLocEntry.\n  ///\n  /// This is LocalSLocEntryTable.back().Offset + the size of that entry.\n  unsigned NextLocalOffset;\n\n  /// The starting offset of the latest batch of loaded SLocEntries.\n  ///\n  /// This is LoadedSLocEntryTable.back().Offset, except that that entry might\n  /// not have been loaded, so that value would be unknown.\n  unsigned CurrentLoadedOffset;\n\n  /// The highest possible offset is 2^31-1, so CurrentLoadedOffset\n  /// starts at 2^31.\n  static const unsigned MaxLoadedOffset = 1U << 31U;\n\n  /// A bitmap that indicates whether the entries of LoadedSLocEntryTable\n  /// have already been loaded from the external source.\n  ///\n  /// Same indexing as LoadedSLocEntryTable.\n  llvm::BitVector SLocEntryLoaded;\n\n  /// An external source for source location entries.\n  ExternalSLocEntrySource *ExternalSLocEntries = nullptr;\n\n  /// A one-entry cache to speed up getFileID.\n  ///\n  /// LastFileIDLookup records the last FileID looked up or created, because it\n  /// is very common to look up many tokens from the same file.\n  mutable FileID LastFileIDLookup;\n\n  /// Holds information for \\#line directives.\n  ///\n  /// This is referenced by indices from SLocEntryTable.\n  std::unique_ptr<LineTableInfo> LineTable;\n\n  /// These ivars serve as a cache used in the getLineNumber\n  /// method which is used to speedup getLineNumber calls to nearby locations.\n  mutable FileID LastLineNoFileIDQuery;\n  mutable const SrcMgr::ContentCache *LastLineNoContentCache;\n  mutable unsigned LastLineNoFilePos;\n  mutable unsigned LastLineNoResult;\n\n  /// The file ID for the main source file of the translation unit.\n  FileID MainFileID;\n\n  /// The file ID for the precompiled preamble there is one.\n  FileID PreambleFileID;\n\n  // Statistics for -print-stats.\n  mutable unsigned NumLinearScans = 0;\n  mutable unsigned NumBinaryProbes = 0;\n\n  /// Associates a FileID with its \"included/expanded in\" decomposed\n  /// location.\n  ///\n  /// Used to cache results from and speed-up \\c getDecomposedIncludedLoc\n  /// function.\n  mutable llvm::DenseMap<FileID, std::pair<FileID, unsigned>> IncludedLocMap;\n\n  /// The key value into the IsBeforeInTUCache table.\n  using IsBeforeInTUCacheKey = std::pair<FileID, FileID>;\n\n  /// The IsBeforeInTranslationUnitCache is a mapping from FileID pairs\n  /// to cache results.\n  using InBeforeInTUCache =\n      llvm::DenseMap<IsBeforeInTUCacheKey, InBeforeInTUCacheEntry>;\n\n  /// Cache results for the isBeforeInTranslationUnit method.\n  mutable InBeforeInTUCache IBTUCache;\n  mutable InBeforeInTUCacheEntry IBTUCacheOverflow;\n\n  /// Return the cache entry for comparing the given file IDs\n  /// for isBeforeInTranslationUnit.\n  InBeforeInTUCacheEntry &getInBeforeInTUCache(FileID LFID, FileID RFID) const;\n\n  // Cache for the \"fake\" buffer used for error-recovery purposes.\n  mutable std::unique_ptr<llvm::MemoryBuffer> FakeBufferForRecovery;\n\n  mutable std::unique_ptr<SrcMgr::ContentCache> FakeContentCacheForRecovery;\n\n  mutable std::unique_ptr<SrcMgr::SLocEntry> FakeSLocEntryForRecovery;\n\n  /// Lazily computed map of macro argument chunks to their expanded\n  /// source location.\n  using MacroArgsMap = std::map<unsigned, SourceLocation>;\n\n  mutable llvm::DenseMap<FileID, std::unique_ptr<MacroArgsMap>>\n      MacroArgsCacheMap;\n\n  /// The stack of modules being built, which is used to detect\n  /// cycles in the module dependency graph as modules are being built, as\n  /// well as to describe why we're rebuilding a particular module.\n  ///\n  /// There is no way to set this value from the command line. If we ever need\n  /// to do so (e.g., if on-demand module construction moves out-of-process),\n  /// we can add a cc1-level option to do so.\n  SmallVector<std::pair<std::string, FullSourceLoc>, 2> StoredModuleBuildStack;\n\npublic:\n  SourceManager(DiagnosticsEngine &Diag, FileManager &FileMgr,\n                bool UserFilesAreVolatile = false);\n  explicit SourceManager(const SourceManager &) = delete;\n  SourceManager &operator=(const SourceManager &) = delete;\n  ~SourceManager();\n\n  void clearIDTables();\n\n  /// Initialize this source manager suitably to replay the compilation\n  /// described by \\p Old. Requires that \\p Old outlive \\p *this.\n  void initializeForReplay(const SourceManager &Old);\n\n  DiagnosticsEngine &getDiagnostics() const { return Diag; }\n\n  FileManager &getFileManager() const { return FileMgr; }\n\n  /// Set true if the SourceManager should report the original file name\n  /// for contents of files that were overridden by other files. Defaults to\n  /// true.\n  void setOverridenFilesKeepOriginalName(bool value) {\n    OverridenFilesKeepOriginalName = value;\n  }\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them).\n  bool userFilesAreVolatile() const { return UserFilesAreVolatile; }\n\n  /// Retrieve the module build stack.\n  ModuleBuildStack getModuleBuildStack() const {\n    return StoredModuleBuildStack;\n  }\n\n  /// Set the module build stack.\n  void setModuleBuildStack(ModuleBuildStack stack) {\n    StoredModuleBuildStack.clear();\n    StoredModuleBuildStack.append(stack.begin(), stack.end());\n  }\n\n  /// Push an entry to the module build stack.\n  void pushModuleBuildStack(StringRef moduleName, FullSourceLoc importLoc) {\n    StoredModuleBuildStack.push_back(std::make_pair(moduleName.str(),importLoc));\n  }\n\n  //===--------------------------------------------------------------------===//\n  // MainFileID creation and querying methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns the FileID of the main source file.\n  FileID getMainFileID() const { return MainFileID; }\n\n  /// Set the file ID for the main source file.\n  void setMainFileID(FileID FID) {\n    MainFileID = FID;\n  }\n\n  /// Returns true when the given FileEntry corresponds to the main file.\n  ///\n  /// The main file should be set prior to calling this function.\n  bool isMainFile(const FileEntry &SourceFile);\n\n  /// Set the file ID for the precompiled preamble.\n  void setPreambleFileID(FileID Preamble) {\n    assert(PreambleFileID.isInvalid() && \"PreambleFileID already set!\");\n    PreambleFileID = Preamble;\n  }\n\n  /// Get the file ID for the precompiled preamble if there is one.\n  FileID getPreambleFileID() const { return PreambleFileID; }\n\n  //===--------------------------------------------------------------------===//\n  // Methods to create new FileID's and macro expansions.\n  //===--------------------------------------------------------------------===//\n\n  /// Create a new FileID that represents the specified file\n  /// being \\#included from the specified IncludePosition.\n  ///\n  /// This translates NULL into standard input.\n  FileID createFileID(const FileEntry *SourceFile, SourceLocation IncludePos,\n                      SrcMgr::CharacteristicKind FileCharacter,\n                      int LoadedID = 0, unsigned LoadedOffset = 0);\n\n  FileID createFileID(FileEntryRef SourceFile, SourceLocation IncludePos,\n                      SrcMgr::CharacteristicKind FileCharacter,\n                      int LoadedID = 0, unsigned LoadedOffset = 0);\n\n  /// Create a new FileID that represents the specified memory buffer.\n  ///\n  /// This does no caching of the buffer and takes ownership of the\n  /// MemoryBuffer, so only pass a MemoryBuffer to this once.\n  FileID createFileID(std::unique_ptr<llvm::MemoryBuffer> Buffer,\n                      SrcMgr::CharacteristicKind FileCharacter = SrcMgr::C_User,\n                      int LoadedID = 0, unsigned LoadedOffset = 0,\n                      SourceLocation IncludeLoc = SourceLocation());\n\n  /// Create a new FileID that represents the specified memory buffer.\n  ///\n  /// This does not take ownership of the MemoryBuffer. The memory buffer must\n  /// outlive the SourceManager.\n  FileID createFileID(const llvm::MemoryBufferRef &Buffer,\n                      SrcMgr::CharacteristicKind FileCharacter = SrcMgr::C_User,\n                      int LoadedID = 0, unsigned LoadedOffset = 0,\n                      SourceLocation IncludeLoc = SourceLocation());\n\n  /// Get the FileID for \\p SourceFile if it exists. Otherwise, create a\n  /// new FileID for the \\p SourceFile.\n  FileID getOrCreateFileID(const FileEntry *SourceFile,\n                           SrcMgr::CharacteristicKind FileCharacter);\n\n  /// Return a new SourceLocation that encodes the\n  /// fact that a token from SpellingLoc should actually be referenced from\n  /// ExpansionLoc, and that it represents the expansion of a macro argument\n  /// into the function-like macro body.\n  SourceLocation createMacroArgExpansionLoc(SourceLocation Loc,\n                                            SourceLocation ExpansionLoc,\n                                            unsigned TokLength);\n\n  /// Return a new SourceLocation that encodes the fact\n  /// that a token from SpellingLoc should actually be referenced from\n  /// ExpansionLoc.\n  SourceLocation createExpansionLoc(SourceLocation Loc,\n                                    SourceLocation ExpansionLocStart,\n                                    SourceLocation ExpansionLocEnd,\n                                    unsigned TokLength,\n                                    bool ExpansionIsTokenRange = true,\n                                    int LoadedID = 0,\n                                    unsigned LoadedOffset = 0);\n\n  /// Return a new SourceLocation that encodes that the token starting\n  /// at \\p TokenStart ends prematurely at \\p TokenEnd.\n  SourceLocation createTokenSplitLoc(SourceLocation SpellingLoc,\n                                     SourceLocation TokenStart,\n                                     SourceLocation TokenEnd);\n\n  /// Retrieve the memory buffer associated with the given file.\n  ///\n  /// Returns None if the buffer is not valid.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getMemoryBufferForFileOrNone(const FileEntry *File);\n\n  /// Retrieve the memory buffer associated with the given file.\n  ///\n  /// Returns a fake buffer if there isn't a real one.\n  llvm::MemoryBufferRef getMemoryBufferForFileOrFake(const FileEntry *File) {\n    if (auto B = getMemoryBufferForFileOrNone(File))\n      return *B;\n    return getFakeBufferForRecovery();\n  }\n\n  /// Override the contents of the given source file by providing an\n  /// already-allocated buffer.\n  ///\n  /// \\param SourceFile the source file whose contents will be overridden.\n  ///\n  /// \\param Buffer the memory buffer whose contents will be used as the\n  /// data in the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            const llvm::MemoryBufferRef &Buffer) {\n    overrideFileContents(SourceFile, llvm::MemoryBuffer::getMemBuffer(Buffer));\n  }\n\n  /// Override the contents of the given source file by providing an\n  /// already-allocated buffer.\n  ///\n  /// \\param SourceFile the source file whose contents will be overridden.\n  ///\n  /// \\param Buffer the memory buffer whose contents will be used as the\n  /// data in the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            std::unique_ptr<llvm::MemoryBuffer> Buffer);\n  void overrideFileContents(FileEntryRef SourceFile,\n                            std::unique_ptr<llvm::MemoryBuffer> Buffer) {\n    overrideFileContents(&SourceFile.getFileEntry(), std::move(Buffer));\n  }\n\n  /// Override the given source file with another one.\n  ///\n  /// \\param SourceFile the source file which will be overridden.\n  ///\n  /// \\param NewFile the file whose contents will be used as the\n  /// data instead of the contents of the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            const FileEntry *NewFile);\n\n  /// Returns true if the file contents have been overridden.\n  bool isFileOverridden(const FileEntry *File) const {\n    if (OverriddenFilesInfo) {\n      if (OverriddenFilesInfo->OverriddenFilesWithBuffer.count(File))\n        return true;\n      if (OverriddenFilesInfo->OverriddenFiles.find(File) !=\n          OverriddenFilesInfo->OverriddenFiles.end())\n        return true;\n    }\n    return false;\n  }\n\n  /// Bypass the overridden contents of a file.  This creates a new FileEntry\n  /// and initializes the content cache for it.  Returns None if there is no\n  /// such file in the filesystem.\n  ///\n  /// This should be called before parsing has begun.\n  Optional<FileEntryRef> bypassFileContentsOverride(FileEntryRef File);\n\n  /// Specify that a file is transient.\n  void setFileIsTransient(const FileEntry *SourceFile);\n\n  /// Specify that all files that are read during this compilation are\n  /// transient.\n  void setAllFilesAreTransient(bool Transient) {\n    FilesAreTransient = Transient;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // FileID manipulation methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the buffer for the specified FileID.\n  ///\n  /// If there is an error opening this buffer the first time, return None.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getBufferOrNone(FileID FID, SourceLocation Loc = SourceLocation()) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getContentCache().getBufferOrNone(\n          Diag, getFileManager(), Loc);\n    return None;\n  }\n\n  /// Return the buffer for the specified FileID.\n  ///\n  /// If there is an error opening this buffer the first time, this\n  /// manufactures a temporary buffer and returns it.\n  llvm::MemoryBufferRef\n  getBufferOrFake(FileID FID, SourceLocation Loc = SourceLocation()) const {\n    if (auto B = getBufferOrNone(FID, Loc))\n      return *B;\n    return getFakeBufferForRecovery();\n  }\n\n  /// Returns the FileEntry record for the provided FileID.\n  const FileEntry *getFileEntryForID(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getContentCache().OrigEntry;\n    return nullptr;\n  }\n\n  /// Returns the FileEntryRef for the provided FileID.\n  Optional<FileEntryRef> getFileEntryRefForID(FileID FID) const {\n    if (auto *Entry = getFileEntryForID(FID))\n      return Entry->getLastRef();\n    return None;\n  }\n\n  /// Returns the filename for the provided FileID, unless it's a built-in\n  /// buffer that's not represented by a filename.\n  ///\n  /// Returns None for non-files and built-in files.\n  Optional<StringRef> getNonBuiltinFilenameForID(FileID FID) const;\n\n  /// Returns the FileEntry record for the provided SLocEntry.\n  const FileEntry *getFileEntryForSLocEntry(const SrcMgr::SLocEntry &sloc) const\n  {\n    return sloc.getFile().getContentCache().OrigEntry;\n  }\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  /// \\param Invalid If non-NULL, will be set true if an error occurred.\n  StringRef getBufferData(FileID FID, bool *Invalid = nullptr) const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID, returning None if invalid.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  llvm::Optional<StringRef> getBufferDataOrNone(FileID FID) const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID, returning None if it's not yet loaded.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  llvm::Optional<StringRef> getBufferDataIfLoaded(FileID FID) const;\n\n  /// Get the number of FileIDs (files and macros) that were created\n  /// during preprocessing of \\p FID, including it.\n  unsigned getNumCreatedFIDsForFileID(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().NumCreatedFIDs;\n    return 0;\n  }\n\n  /// Set the number of FileIDs (files and macros) that were created\n  /// during preprocessing of \\p FID, including it.\n  void setNumCreatedFIDsForFileID(FileID FID, unsigned NumFIDs,\n                                  bool Force = false) const {\n    auto *Entry = getSLocEntryForFile(FID);\n    if (!Entry)\n      return;\n    assert((Force || Entry->getFile().NumCreatedFIDs == 0) && \"Already set!\");\n    const_cast<SrcMgr::FileInfo &>(Entry->getFile()).NumCreatedFIDs = NumFIDs;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // SourceLocation manipulation methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the FileID for a SourceLocation.\n  ///\n  /// This is a very hot method that is used for all SourceManager queries\n  /// that start with a SourceLocation object.  It is responsible for finding\n  /// the entry in SLocEntryTable which contains the specified location.\n  ///\n  FileID getFileID(SourceLocation SpellingLoc) const {\n    unsigned SLocOffset = SpellingLoc.getOffset();\n\n    // If our one-entry cache covers this offset, just return it.\n    if (isOffsetInFileID(LastFileIDLookup, SLocOffset))\n      return LastFileIDLookup;\n\n    return getFileIDSlow(SLocOffset);\n  }\n\n  /// Return the filename of the file containing a SourceLocation.\n  StringRef getFilename(SourceLocation SpellingLoc) const;\n\n  /// Return the source location corresponding to the first byte of\n  /// the specified file.\n  SourceLocation getLocForStartOfFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return SourceLocation::getFileLoc(Entry->getOffset());\n    return SourceLocation();\n  }\n\n  /// Return the source location corresponding to the last byte of the\n  /// specified file.\n  SourceLocation getLocForEndOfFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return SourceLocation::getFileLoc(Entry->getOffset() +\n                                        getFileIDSize(FID));\n    return SourceLocation();\n  }\n\n  /// Returns the include location if \\p FID is a \\#include'd file\n  /// otherwise it returns an invalid location.\n  SourceLocation getIncludeLoc(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getIncludeLoc();\n    return SourceLocation();\n  }\n\n  // Returns the import location if the given source location is\n  // located within a module, or an invalid location if the source location\n  // is within the current translation unit.\n  std::pair<SourceLocation, StringRef>\n  getModuleImportLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n\n    // Positive file IDs are in the current translation unit, and -1 is a\n    // placeholder.\n    if (FID.ID >= -1)\n      return std::make_pair(SourceLocation(), \"\");\n\n    return ExternalSLocEntries->getModuleImportLoc(FID.ID);\n  }\n\n  /// Given a SourceLocation object \\p Loc, return the expansion\n  /// location referenced by the ID.\n  SourceLocation getExpansionLoc(SourceLocation Loc) const {\n    // Handle the non-mapped case inline, defer to out of line code to handle\n    // expansions.\n    if (Loc.isFileID()) return Loc;\n    return getExpansionLocSlowCase(Loc);\n  }\n\n  /// Given \\p Loc, if it is a macro location return the expansion\n  /// location or the spelling location, depending on if it comes from a\n  /// macro argument or not.\n  SourceLocation getFileLoc(SourceLocation Loc) const {\n    if (Loc.isFileID()) return Loc;\n    return getFileLocSlowCase(Loc);\n  }\n\n  /// Return the start/end of the expansion information for an\n  /// expansion location.\n  ///\n  /// \\pre \\p Loc is required to be an expansion location.\n  CharSourceRange getImmediateExpansionRange(SourceLocation Loc) const;\n\n  /// Given a SourceLocation object, return the range of\n  /// tokens covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(SourceLocation Loc) const;\n\n  /// Given a SourceRange object, return the range of\n  /// tokens or characters covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(SourceRange Range) const {\n    SourceLocation Begin = getExpansionRange(Range.getBegin()).getBegin();\n    CharSourceRange End = getExpansionRange(Range.getEnd());\n    return CharSourceRange(SourceRange(Begin, End.getEnd()),\n                           End.isTokenRange());\n  }\n\n  /// Given a CharSourceRange object, return the range of\n  /// tokens or characters covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(CharSourceRange Range) const {\n    CharSourceRange Expansion = getExpansionRange(Range.getAsRange());\n    if (Expansion.getEnd() == Range.getEnd())\n      Expansion.setTokenRange(Range.isTokenRange());\n    return Expansion;\n  }\n\n  /// Given a SourceLocation object, return the spelling\n  /// location referenced by the ID.\n  ///\n  /// This is the place where the characters that make up the lexed token\n  /// can be found.\n  SourceLocation getSpellingLoc(SourceLocation Loc) const {\n    // Handle the non-mapped case inline, defer to out of line code to handle\n    // expansions.\n    if (Loc.isFileID()) return Loc;\n    return getSpellingLocSlowCase(Loc);\n  }\n\n  /// Given a SourceLocation object, return the spelling location\n  /// referenced by the ID.\n  ///\n  /// This is the first level down towards the place where the characters\n  /// that make up the lexed token can be found.  This should not generally\n  /// be used by clients.\n  SourceLocation getImmediateSpellingLoc(SourceLocation Loc) const;\n\n  /// Form a SourceLocation from a FileID and Offset pair.\n  SourceLocation getComposedLoc(FileID FID, unsigned Offset) const {\n    auto *Entry = getSLocEntryOrNull(FID);\n    if (!Entry)\n      return SourceLocation();\n\n    unsigned GlobalOffset = Entry->getOffset() + Offset;\n    return Entry->isFile() ? SourceLocation::getFileLoc(GlobalOffset)\n                           : SourceLocation::getMacroLoc(GlobalOffset);\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// The first element is the FileID, the second is the offset from the\n  /// start of the buffer of the location.\n  std::pair<FileID, unsigned> getDecomposedLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *Entry = getSLocEntryOrNull(FID);\n    if (!Entry)\n      return std::make_pair(FileID(), 0);\n    return std::make_pair(FID, Loc.getOffset() - Entry->getOffset());\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// If the location is an expansion record, walk through it until we find\n  /// the final location expanded.\n  std::pair<FileID, unsigned>\n  getDecomposedExpansionLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *E = getSLocEntryOrNull(FID);\n    if (!E)\n      return std::make_pair(FileID(), 0);\n\n    unsigned Offset = Loc.getOffset()-E->getOffset();\n    if (Loc.isFileID())\n      return std::make_pair(FID, Offset);\n\n    return getDecomposedExpansionLocSlowCase(E);\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// If the location is an expansion record, walk through it until we find\n  /// its spelling record.\n  std::pair<FileID, unsigned>\n  getDecomposedSpellingLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *E = getSLocEntryOrNull(FID);\n    if (!E)\n      return std::make_pair(FileID(), 0);\n\n    unsigned Offset = Loc.getOffset()-E->getOffset();\n    if (Loc.isFileID())\n      return std::make_pair(FID, Offset);\n    return getDecomposedSpellingLocSlowCase(E, Offset);\n  }\n\n  /// Returns the \"included/expanded in\" decomposed location of the given\n  /// FileID.\n  std::pair<FileID, unsigned> getDecomposedIncludedLoc(FileID FID) const;\n\n  /// Returns the offset from the start of the file that the\n  /// specified SourceLocation represents.\n  ///\n  /// This is not very meaningful for a macro ID.\n  unsigned getFileOffset(SourceLocation SpellingLoc) const {\n    return getDecomposedLoc(SpellingLoc).second;\n  }\n\n  /// Tests whether the given source location represents a macro\n  /// argument's expansion into the function-like macro definition.\n  ///\n  /// \\param StartLoc If non-null and function returns true, it is set to the\n  /// start location of the macro argument expansion.\n  ///\n  /// Such source locations only appear inside of the expansion\n  /// locations representing where a particular function-like macro was\n  /// expanded.\n  bool isMacroArgExpansion(SourceLocation Loc,\n                           SourceLocation *StartLoc = nullptr) const;\n\n  /// Tests whether the given source location represents the expansion of\n  /// a macro body.\n  ///\n  /// This is equivalent to testing whether the location is part of a macro\n  /// expansion but not the expansion of an argument to a function-like macro.\n  bool isMacroBodyExpansion(SourceLocation Loc) const;\n\n  /// Returns true if the given MacroID location points at the beginning\n  /// of the immediate macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to the\n  /// begin location of the immediate macro expansion.\n  bool isAtStartOfImmediateMacroExpansion(SourceLocation Loc,\n                                    SourceLocation *MacroBegin = nullptr) const;\n\n  /// Returns true if the given MacroID location points at the character\n  /// end of the immediate macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to the\n  /// character end location of the immediate macro expansion.\n  bool\n  isAtEndOfImmediateMacroExpansion(SourceLocation Loc,\n                                   SourceLocation *MacroEnd = nullptr) const;\n\n  /// Returns true if \\p Loc is inside the [\\p Start, +\\p Length)\n  /// chunk of the source location address space.\n  ///\n  /// If it's true and \\p RelativeOffset is non-null, it will be set to the\n  /// relative offset of \\p Loc inside the chunk.\n  bool isInSLocAddrSpace(SourceLocation Loc,\n                         SourceLocation Start, unsigned Length,\n                         unsigned *RelativeOffset = nullptr) const {\n    assert(((Start.getOffset() < NextLocalOffset &&\n               Start.getOffset()+Length <= NextLocalOffset) ||\n            (Start.getOffset() >= CurrentLoadedOffset &&\n                Start.getOffset()+Length < MaxLoadedOffset)) &&\n           \"Chunk is not valid SLoc address space\");\n    unsigned LocOffs = Loc.getOffset();\n    unsigned BeginOffs = Start.getOffset();\n    unsigned EndOffs = BeginOffs + Length;\n    if (LocOffs >= BeginOffs && LocOffs < EndOffs) {\n      if (RelativeOffset)\n        *RelativeOffset = LocOffs - BeginOffs;\n      return true;\n    }\n\n    return false;\n  }\n\n  /// Return true if both \\p LHS and \\p RHS are in the local source\n  /// location address space or the loaded one.\n  ///\n  /// If it's true and \\p RelativeOffset is non-null, it will be set to the\n  /// offset of \\p RHS relative to \\p LHS.\n  bool isInSameSLocAddrSpace(SourceLocation LHS, SourceLocation RHS,\n                             int *RelativeOffset) const {\n    unsigned LHSOffs = LHS.getOffset(), RHSOffs = RHS.getOffset();\n    bool LHSLoaded = LHSOffs >= CurrentLoadedOffset;\n    bool RHSLoaded = RHSOffs >= CurrentLoadedOffset;\n\n    if (LHSLoaded == RHSLoaded) {\n      if (RelativeOffset)\n        *RelativeOffset = RHSOffs - LHSOffs;\n      return true;\n    }\n\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Queries about the code at a SourceLocation.\n  //===--------------------------------------------------------------------===//\n\n  /// Return a pointer to the start of the specified location\n  /// in the appropriate spelling MemoryBuffer.\n  ///\n  /// \\param Invalid If non-NULL, will be set \\c true if an error occurs.\n  const char *getCharacterData(SourceLocation SL,\n                               bool *Invalid = nullptr) const;\n\n  /// Return the column # for the specified file position.\n  ///\n  /// This is significantly cheaper to compute than the line number.  This\n  /// returns zero if the column number isn't known.  This may only be called\n  /// on a file sloc, so you must choose a spelling or expansion location\n  /// before calling this method.\n  unsigned getColumnNumber(FileID FID, unsigned FilePos,\n                           bool *Invalid = nullptr) const;\n  unsigned getSpellingColumnNumber(SourceLocation Loc,\n                                   bool *Invalid = nullptr) const;\n  unsigned getExpansionColumnNumber(SourceLocation Loc,\n                                    bool *Invalid = nullptr) const;\n  unsigned getPresumedColumnNumber(SourceLocation Loc,\n                                   bool *Invalid = nullptr) const;\n\n  /// Given a SourceLocation, return the spelling line number\n  /// for the position indicated.\n  ///\n  /// This requires building and caching a table of line offsets for the\n  /// MemoryBuffer, so this is not cheap: use only when about to emit a\n  /// diagnostic.\n  unsigned getLineNumber(FileID FID, unsigned FilePos, bool *Invalid = nullptr) const;\n  unsigned getSpellingLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n  unsigned getExpansionLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n  unsigned getPresumedLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n\n  /// Return the filename or buffer identifier of the buffer the\n  /// location is in.\n  ///\n  /// Note that this name does not respect \\#line directives.  Use\n  /// getPresumedLoc for normal clients.\n  StringRef getBufferName(SourceLocation Loc, bool *Invalid = nullptr) const;\n\n  /// Return the file characteristic of the specified source\n  /// location, indicating whether this is a normal file, a system\n  /// header, or an \"implicit extern C\" system header.\n  ///\n  /// This state can be modified with flags on GNU linemarker directives like:\n  /// \\code\n  ///   # 4 \"foo.h\" 3\n  /// \\endcode\n  /// which changes all source locations in the current file after that to be\n  /// considered to be from a system header.\n  SrcMgr::CharacteristicKind getFileCharacteristic(SourceLocation Loc) const;\n\n  /// Returns the \"presumed\" location of a SourceLocation specifies.\n  ///\n  /// A \"presumed location\" can be modified by \\#line or GNU line marker\n  /// directives.  This provides a view on the data that a user should see\n  /// in diagnostics, for example.\n  ///\n  /// Note that a presumed location is always given as the expansion point of\n  /// an expansion location, not at the spelling location.\n  ///\n  /// \\returns The presumed location of the specified SourceLocation. If the\n  /// presumed location cannot be calculated (e.g., because \\p Loc is invalid\n  /// or the file containing \\p Loc has changed on disk), returns an invalid\n  /// presumed location.\n  PresumedLoc getPresumedLoc(SourceLocation Loc,\n                             bool UseLineDirectives = true) const;\n\n  /// Returns whether the PresumedLoc for a given SourceLocation is\n  /// in the main file.\n  ///\n  /// This computes the \"presumed\" location for a SourceLocation, then checks\n  /// whether it came from a file other than the main file. This is different\n  /// from isWrittenInMainFile() because it takes line marker directives into\n  /// account.\n  bool isInMainFile(SourceLocation Loc) const;\n\n  /// Returns true if the spelling locations for both SourceLocations\n  /// are part of the same file buffer.\n  ///\n  /// This check ignores line marker directives.\n  bool isWrittenInSameFile(SourceLocation Loc1, SourceLocation Loc2) const {\n    return getFileID(Loc1) == getFileID(Loc2);\n  }\n\n  /// Returns true if the spelling location for the given location\n  /// is in the main file buffer.\n  ///\n  /// This check ignores line marker directives.\n  bool isWrittenInMainFile(SourceLocation Loc) const {\n    return getFileID(Loc) == getMainFileID();\n  }\n\n  /// Returns whether \\p Loc is located in a <built-in> file.\n  bool isWrittenInBuiltinFile(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<built-in>\");\n  }\n\n  /// Returns whether \\p Loc is located in a <command line> file.\n  bool isWrittenInCommandLineFile(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<command line>\");\n  }\n\n  /// Returns whether \\p Loc is located in a <scratch space> file.\n  bool isWrittenInScratchSpace(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<scratch space>\");\n  }\n\n  /// Returns if a SourceLocation is in a system header.\n  bool isInSystemHeader(SourceLocation Loc) const {\n    return isSystem(getFileCharacteristic(Loc));\n  }\n\n  /// Returns if a SourceLocation is in an \"extern C\" system header.\n  bool isInExternCSystemHeader(SourceLocation Loc) const {\n    return getFileCharacteristic(Loc) == SrcMgr::C_ExternCSystem;\n  }\n\n  /// Returns whether \\p Loc is expanded from a macro in a system header.\n  bool isInSystemMacro(SourceLocation loc) const {\n    if (!loc.isMacroID())\n      return false;\n\n    // This happens when the macro is the result of a paste, in that case\n    // its spelling is the scratch memory, so we take the parent context.\n    // There can be several level of token pasting.\n    if (isWrittenInScratchSpace(getSpellingLoc(loc))) {\n      do {\n        loc = getImmediateMacroCallerLoc(loc);\n      } while (isWrittenInScratchSpace(getSpellingLoc(loc)));\n      return isInSystemMacro(loc);\n    }\n\n    return isInSystemHeader(getSpellingLoc(loc));\n  }\n\n  /// The size of the SLocEntry that \\p FID represents.\n  unsigned getFileIDSize(FileID FID) const;\n\n  /// Given a specific FileID, returns true if \\p Loc is inside that\n  /// FileID chunk and sets relative offset (offset of \\p Loc from beginning\n  /// of FileID) to \\p relativeOffset.\n  bool isInFileID(SourceLocation Loc, FileID FID,\n                  unsigned *RelativeOffset = nullptr) const {\n    unsigned Offs = Loc.getOffset();\n    if (isOffsetInFileID(FID, Offs)) {\n      if (RelativeOffset)\n        *RelativeOffset = Offs - getSLocEntry(FID).getOffset();\n      return true;\n    }\n\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Line Table Manipulation Routines\n  //===--------------------------------------------------------------------===//\n\n  /// Return the uniqued ID for the specified filename.\n  unsigned getLineTableFilenameID(StringRef Str);\n\n  /// Add a line note to the line table for the FileID and offset\n  /// specified by Loc.\n  ///\n  /// If FilenameID is -1, it is considered to be unspecified.\n  void AddLineNote(SourceLocation Loc, unsigned LineNo, int FilenameID,\n                   bool IsFileEntry, bool IsFileExit,\n                   SrcMgr::CharacteristicKind FileKind);\n\n  /// Determine if the source manager has a line table.\n  bool hasLineTable() const { return LineTable != nullptr; }\n\n  /// Retrieve the stored line table.\n  LineTableInfo &getLineTable();\n\n  //===--------------------------------------------------------------------===//\n  // Queries for performance analysis.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the total amount of physical memory allocated by the\n  /// ContentCache allocator.\n  size_t getContentCacheSize() const {\n    return ContentCacheAlloc.getTotalMemory();\n  }\n\n  struct MemoryBufferSizes {\n    const size_t malloc_bytes;\n    const size_t mmap_bytes;\n\n    MemoryBufferSizes(size_t malloc_bytes, size_t mmap_bytes)\n      : malloc_bytes(malloc_bytes), mmap_bytes(mmap_bytes) {}\n  };\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  MemoryBufferSizes getMemoryBufferSizes() const;\n\n  /// Return the amount of memory used for various side tables and\n  /// data structures in the SourceManager.\n  size_t getDataStructureSizes() const;\n\n  //===--------------------------------------------------------------------===//\n  // Other miscellaneous methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Get the source location for the given file:line:col triplet.\n  ///\n  /// If the source file is included multiple times, the source location will\n  /// be based upon the first inclusion.\n  SourceLocation translateFileLineCol(const FileEntry *SourceFile,\n                                      unsigned Line, unsigned Col) const;\n\n  /// Get the FileID for the given file.\n  ///\n  /// If the source file is included multiple times, the FileID will be the\n  /// first inclusion.\n  FileID translateFile(const FileEntry *SourceFile) const;\n  FileID translateFile(FileEntryRef SourceFile) const {\n    return translateFile(&SourceFile.getFileEntry());\n  }\n\n  /// Get the source location in \\p FID for the given line:col.\n  /// Returns null location if \\p FID is not a file SLocEntry.\n  SourceLocation translateLineCol(FileID FID,\n                                  unsigned Line, unsigned Col) const;\n\n  /// If \\p Loc points inside a function macro argument, the returned\n  /// location will be the macro location in which the argument was expanded.\n  /// If a macro argument is used multiple times, the expanded location will\n  /// be at the first expansion of the argument.\n  /// e.g.\n  ///   MY_MACRO(foo);\n  ///             ^\n  /// Passing a file location pointing at 'foo', will yield a macro location\n  /// where 'foo' was expanded into.\n  SourceLocation getMacroArgExpandedLocation(SourceLocation Loc) const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if LHS source location comes before RHS, false otherwise.\n  bool isBeforeInTranslationUnit(SourceLocation LHS, SourceLocation RHS) const;\n\n  /// Determines whether the two decomposed source location is in the\n  ///        same translation unit. As a byproduct, it also calculates the order\n  ///        of the source locations in case they are in the same TU.\n  ///\n  /// \\returns Pair of bools the first component is true if the two locations\n  ///          are in the same TU. The second bool is true if the first is true\n  ///          and \\p LOffs is before \\p ROffs.\n  std::pair<bool, bool>\n  isInTheSameTranslationUnit(std::pair<FileID, unsigned> &LOffs,\n                             std::pair<FileID, unsigned> &ROffs) const;\n\n  /// Determines the order of 2 source locations in the \"source location\n  /// address space\".\n  bool isBeforeInSLocAddrSpace(SourceLocation LHS, SourceLocation RHS) const {\n    return isBeforeInSLocAddrSpace(LHS, RHS.getOffset());\n  }\n\n  /// Determines the order of a source location and a source location\n  /// offset in the \"source location address space\".\n  ///\n  /// Note that we always consider source locations loaded from\n  bool isBeforeInSLocAddrSpace(SourceLocation LHS, unsigned RHS) const {\n    unsigned LHSOffset = LHS.getOffset();\n    bool LHSLoaded = LHSOffset >= CurrentLoadedOffset;\n    bool RHSLoaded = RHS >= CurrentLoadedOffset;\n    if (LHSLoaded == RHSLoaded)\n      return LHSOffset < RHS;\n\n    return LHSLoaded;\n  }\n\n  /// Return true if the Point is within Start and End.\n  bool isPointWithin(SourceLocation Location, SourceLocation Start,\n                     SourceLocation End) const {\n    return Location == Start || Location == End ||\n           (isBeforeInTranslationUnit(Start, Location) &&\n            isBeforeInTranslationUnit(Location, End));\n  }\n\n  // Iterators over FileInfos.\n  using fileinfo_iterator =\n      llvm::DenseMap<const FileEntry*, SrcMgr::ContentCache*>::const_iterator;\n\n  fileinfo_iterator fileinfo_begin() const { return FileInfos.begin(); }\n  fileinfo_iterator fileinfo_end() const { return FileInfos.end(); }\n  bool hasFileInfo(const FileEntry *File) const {\n    return FileInfos.find(File) != FileInfos.end();\n  }\n\n  /// Print statistics to stderr.\n  void PrintStats() const;\n\n  void dump() const;\n\n  /// Get the number of local SLocEntries we have.\n  unsigned local_sloc_entry_size() const { return LocalSLocEntryTable.size(); }\n\n  /// Get a local SLocEntry. This is exposed for indexing.\n  const SrcMgr::SLocEntry &getLocalSLocEntry(unsigned Index) const {\n    assert(Index < LocalSLocEntryTable.size() && \"Invalid index\");\n    return LocalSLocEntryTable[Index];\n  }\n\n  /// Get the number of loaded SLocEntries we have.\n  unsigned loaded_sloc_entry_size() const { return LoadedSLocEntryTable.size();}\n\n  /// Get a loaded SLocEntry. This is exposed for indexing.\n  const SrcMgr::SLocEntry &getLoadedSLocEntry(unsigned Index,\n                                              bool *Invalid = nullptr) const {\n    assert(Index < LoadedSLocEntryTable.size() && \"Invalid index\");\n    if (SLocEntryLoaded[Index])\n      return LoadedSLocEntryTable[Index];\n    return loadSLocEntry(Index, Invalid);\n  }\n\n  const SrcMgr::SLocEntry &getSLocEntry(FileID FID,\n                                        bool *Invalid = nullptr) const {\n    if (FID.ID == 0 || FID.ID == -1) {\n      if (Invalid) *Invalid = true;\n      return LocalSLocEntryTable[0];\n    }\n    return getSLocEntryByID(FID.ID, Invalid);\n  }\n\n  unsigned getNextLocalOffset() const { return NextLocalOffset; }\n\n  void setExternalSLocEntrySource(ExternalSLocEntrySource *Source) {\n    assert(LoadedSLocEntryTable.empty() &&\n           \"Invalidating existing loaded entries\");\n    ExternalSLocEntries = Source;\n  }\n\n  /// Allocate a number of loaded SLocEntries, which will be actually\n  /// loaded on demand from the external source.\n  ///\n  /// NumSLocEntries will be allocated, which occupy a total of TotalSize space\n  /// in the global source view. The lowest ID and the base offset of the\n  /// entries will be returned.\n  std::pair<int, unsigned>\n  AllocateLoadedSLocEntries(unsigned NumSLocEntries, unsigned TotalSize);\n\n  /// Returns true if \\p Loc came from a PCH/Module.\n  bool isLoadedSourceLocation(SourceLocation Loc) const {\n    return Loc.getOffset() >= CurrentLoadedOffset;\n  }\n\n  /// Returns true if \\p Loc did not come from a PCH/Module.\n  bool isLocalSourceLocation(SourceLocation Loc) const {\n    return Loc.getOffset() < NextLocalOffset;\n  }\n\n  /// Returns true if \\p FID came from a PCH/Module.\n  bool isLoadedFileID(FileID FID) const {\n    assert(FID.ID != -1 && \"Using FileID sentinel value\");\n    return FID.ID < 0;\n  }\n\n  /// Returns true if \\p FID did not come from a PCH/Module.\n  bool isLocalFileID(FileID FID) const {\n    return !isLoadedFileID(FID);\n  }\n\n  /// Gets the location of the immediate macro caller, one level up the stack\n  /// toward the initial macro typed into the source.\n  SourceLocation getImmediateMacroCallerLoc(SourceLocation Loc) const {\n    if (!Loc.isMacroID()) return Loc;\n\n    // When we have the location of (part of) an expanded parameter, its\n    // spelling location points to the argument as expanded in the macro call,\n    // and therefore is used to locate the macro caller.\n    if (isMacroArgExpansion(Loc))\n      return getImmediateSpellingLoc(Loc);\n\n    // Otherwise, the caller of the macro is located where this macro is\n    // expanded (while the spelling is part of the macro definition).\n    return getImmediateExpansionRange(Loc).getBegin();\n  }\n\n  /// \\return Location of the top-level macro caller.\n  SourceLocation getTopMacroCallerLoc(SourceLocation Loc) const;\n\nprivate:\n  friend class ASTReader;\n  friend class ASTWriter;\n\n  llvm::MemoryBufferRef getFakeBufferForRecovery() const;\n  SrcMgr::ContentCache &getFakeContentCacheForRecovery() const;\n\n  const SrcMgr::SLocEntry &loadSLocEntry(unsigned Index, bool *Invalid) const;\n\n  const SrcMgr::SLocEntry *getSLocEntryOrNull(FileID FID) const {\n    bool Invalid = false;\n    const SrcMgr::SLocEntry &Entry = getSLocEntry(FID, &Invalid);\n    return Invalid ? nullptr : &Entry;\n  }\n\n  const SrcMgr::SLocEntry *getSLocEntryForFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryOrNull(FID))\n      if (Entry->isFile())\n        return Entry;\n    return nullptr;\n  }\n\n  /// Get the entry with the given unwrapped FileID.\n  /// Invalid will not be modified for Local IDs.\n  const SrcMgr::SLocEntry &getSLocEntryByID(int ID,\n                                            bool *Invalid = nullptr) const {\n    assert(ID != -1 && \"Using FileID sentinel value\");\n    if (ID < 0)\n      return getLoadedSLocEntryByID(ID, Invalid);\n    return getLocalSLocEntry(static_cast<unsigned>(ID));\n  }\n\n  const SrcMgr::SLocEntry &\n  getLoadedSLocEntryByID(int ID, bool *Invalid = nullptr) const {\n    return getLoadedSLocEntry(static_cast<unsigned>(-ID - 2), Invalid);\n  }\n\n  /// Implements the common elements of storing an expansion info struct into\n  /// the SLocEntry table and producing a source location that refers to it.\n  SourceLocation createExpansionLocImpl(const SrcMgr::ExpansionInfo &Expansion,\n                                        unsigned TokLength,\n                                        int LoadedID = 0,\n                                        unsigned LoadedOffset = 0);\n\n  /// Return true if the specified FileID contains the\n  /// specified SourceLocation offset.  This is a very hot method.\n  inline bool isOffsetInFileID(FileID FID, unsigned SLocOffset) const {\n    const SrcMgr::SLocEntry &Entry = getSLocEntry(FID);\n    // If the entry is after the offset, it can't contain it.\n    if (SLocOffset < Entry.getOffset()) return false;\n\n    // If this is the very last entry then it does.\n    if (FID.ID == -2)\n      return true;\n\n    // If it is the last local entry, then it does if the location is local.\n    if (FID.ID+1 == static_cast<int>(LocalSLocEntryTable.size()))\n      return SLocOffset < NextLocalOffset;\n\n    // Otherwise, the entry after it has to not include it. This works for both\n    // local and loaded entries.\n    return SLocOffset < getSLocEntryByID(FID.ID+1).getOffset();\n  }\n\n  /// Returns the previous in-order FileID or an invalid FileID if there\n  /// is no previous one.\n  FileID getPreviousFileID(FileID FID) const;\n\n  /// Returns the next in-order FileID or an invalid FileID if there is\n  /// no next one.\n  FileID getNextFileID(FileID FID) const;\n\n  /// Create a new fileID for the specified ContentCache and\n  /// include position.\n  ///\n  /// This works regardless of whether the ContentCache corresponds to a\n  /// file or some other input source.\n  FileID createFileIDImpl(SrcMgr::ContentCache &File, StringRef Filename,\n                          SourceLocation IncludePos,\n                          SrcMgr::CharacteristicKind DirCharacter, int LoadedID,\n                          unsigned LoadedOffset);\n\n  SrcMgr::ContentCache &getOrCreateContentCache(FileEntryRef SourceFile,\n                                                bool isSystemFile = false);\n\n  /// Create a new ContentCache for the specified  memory buffer.\n  SrcMgr::ContentCache &\n  createMemBufferContentCache(std::unique_ptr<llvm::MemoryBuffer> Buf);\n\n  FileID getFileIDSlow(unsigned SLocOffset) const;\n  FileID getFileIDLocal(unsigned SLocOffset) const;\n  FileID getFileIDLoaded(unsigned SLocOffset) const;\n\n  SourceLocation getExpansionLocSlowCase(SourceLocation Loc) const;\n  SourceLocation getSpellingLocSlowCase(SourceLocation Loc) const;\n  SourceLocation getFileLocSlowCase(SourceLocation Loc) const;\n\n  std::pair<FileID, unsigned>\n  getDecomposedExpansionLocSlowCase(const SrcMgr::SLocEntry *E) const;\n  std::pair<FileID, unsigned>\n  getDecomposedSpellingLocSlowCase(const SrcMgr::SLocEntry *E,\n                                   unsigned Offset) const;\n  void computeMacroArgsCache(MacroArgsMap &MacroArgsCache, FileID FID) const;\n  void associateFileChunkWithMacroArgExp(MacroArgsMap &MacroArgsCache,\n                                         FileID FID,\n                                         SourceLocation SpellLoc,\n                                         SourceLocation ExpansionLoc,\n                                         unsigned ExpansionLength) const;\n};\n\n/// Comparison function object.\ntemplate<typename T>\nclass BeforeThanCompare;\n\n/// Compare two source locations.\ntemplate<>\nclass BeforeThanCompare<SourceLocation> {\n  SourceManager &SM;\n\npublic:\n  explicit BeforeThanCompare(SourceManager &SM) : SM(SM) {}\n\n  bool operator()(SourceLocation LHS, SourceLocation RHS) const {\n    return SM.isBeforeInTranslationUnit(LHS, RHS);\n  }\n};\n\n/// Compare two non-overlapping source ranges.\ntemplate<>\nclass BeforeThanCompare<SourceRange> {\n  SourceManager &SM;\n\npublic:\n  explicit BeforeThanCompare(SourceManager &SM) : SM(SM) {}\n\n  bool operator()(SourceRange LHS, SourceRange RHS) const {\n    return SM.isBeforeInTranslationUnit(LHS.getBegin(), RHS.getBegin());\n  }\n};\n\n/// SourceManager and necessary depdencies (e.g. VFS, FileManager) for a single\n/// in-memorty file.\nclass SourceManagerForFile {\npublic:\n  /// Creates SourceManager and necessary depdencies (e.g. VFS, FileManager).\n  /// The main file in the SourceManager will be \\p FileName with \\p Content.\n  SourceManagerForFile(StringRef FileName, StringRef Content);\n\n  SourceManager &get() {\n    assert(SourceMgr);\n    return *SourceMgr;\n  }\n\nprivate:\n  // The order of these fields are important - they should be in the same order\n  // as they are created in `createSourceManagerForFile` so that they can be\n  // deleted in the reverse order as they are created.\n  std::unique_ptr<FileManager> FileMgr;\n  std::unique_ptr<DiagnosticsEngine> Diagnostics;\n  std::unique_ptr<SourceManager> SourceMgr;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_SOURCEMANAGER_H\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/ASTUnit.h", "content": "//===- ASTUnit.h - ASTUnit utility ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// ASTUnit utility class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_ASTUNIT_H\n#define LLVM_CLANG_FRONTEND_ASTUNIT_H\n\n#include \"clang-c/Index.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetOptions.h\"\n#include \"clang/Lex/HeaderSearchOptions.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Sema/CodeCompleteConsumer.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Frontend/PrecompiledPreamble.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nnamespace vfs {\n\nclass FileSystem;\n\n} // namespace vfs\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTDeserializationListener;\nclass ASTMutationListener;\nclass ASTReader;\nclass CompilerInstance;\nclass CompilerInvocation;\nclass Decl;\nclass FileEntry;\nclass FileManager;\nclass FrontendAction;\nclass HeaderSearch;\nclass InputKind;\nclass InMemoryModuleCache;\nclass PCHContainerOperations;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nclass Sema;\nclass TargetInfo;\n\n/// \\brief Enumerates the available scopes for skipping function bodies.\nenum class SkipFunctionBodiesScope { None, Preamble, PreambleAndMainFile };\n\n/// \\brief Enumerates the available kinds for capturing diagnostics.\nenum class CaptureDiagsKind { None, All, AllWithoutNonErrorsFromIncludes };\n\n/// Utility class for loading a ASTContext from an AST file.\nclass ASTUnit {\npublic:\n  struct StandaloneFixIt {\n    std::pair<unsigned, unsigned> RemoveRange;\n    std::pair<unsigned, unsigned> InsertFromRange;\n    std::string CodeToInsert;\n    bool BeforePreviousInsertions;\n  };\n\n  struct StandaloneDiagnostic {\n    unsigned ID;\n    DiagnosticsEngine::Level Level;\n    std::string Message;\n    std::string Filename;\n    unsigned LocOffset;\n    std::vector<std::pair<unsigned, unsigned>> Ranges;\n    std::vector<StandaloneFixIt> FixIts;\n  };\n\nprivate:\n  std::shared_ptr<LangOptions>            LangOpts;\n  IntrusiveRefCntPtr<DiagnosticsEngine>   Diagnostics;\n  IntrusiveRefCntPtr<FileManager>         FileMgr;\n  IntrusiveRefCntPtr<SourceManager>       SourceMgr;\n  IntrusiveRefCntPtr<InMemoryModuleCache> ModuleCache;\n  std::unique_ptr<HeaderSearch>           HeaderInfo;\n  IntrusiveRefCntPtr<TargetInfo>          Target;\n  std::shared_ptr<Preprocessor>           PP;\n  IntrusiveRefCntPtr<ASTContext>          Ctx;\n  std::shared_ptr<TargetOptions>          TargetOpts;\n  std::shared_ptr<HeaderSearchOptions>    HSOpts;\n  std::shared_ptr<PreprocessorOptions>    PPOpts;\n  IntrusiveRefCntPtr<ASTReader> Reader;\n  bool HadModuleLoaderFatalFailure = false;\n\n  struct ASTWriterData;\n  std::unique_ptr<ASTWriterData> WriterData;\n\n  FileSystemOptions FileSystemOpts;\n\n  /// The AST consumer that received information about the translation\n  /// unit as it was parsed or loaded.\n  std::unique_ptr<ASTConsumer> Consumer;\n\n  /// The semantic analysis object used to type-check the translation\n  /// unit.\n  std::unique_ptr<Sema> TheSema;\n\n  /// Optional owned invocation, just used to make the invocation used in\n  /// LoadFromCommandLine available.\n  std::shared_ptr<CompilerInvocation> Invocation;\n\n  /// Fake module loader: the AST unit doesn't need to load any modules.\n  TrivialModuleLoader ModuleLoader;\n\n  // OnlyLocalDecls - when true, walking this AST should only visit declarations\n  // that come from the AST itself, not from included precompiled headers.\n  // FIXME: This is temporary; eventually, CIndex will always do this.\n  bool OnlyLocalDecls = false;\n\n  /// Whether to capture any diagnostics produced.\n  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None;\n\n  /// Track whether the main file was loaded from an AST or not.\n  bool MainFileIsAST;\n\n  /// What kind of translation unit this AST represents.\n  TranslationUnitKind TUKind = TU_Complete;\n\n  /// Whether we should time each operation.\n  bool WantTiming;\n\n  /// Whether the ASTUnit should delete the remapped buffers.\n  bool OwnsRemappedFileBuffers = true;\n\n  /// Track the top-level decls which appeared in an ASTUnit which was loaded\n  /// from a source file.\n  //\n  // FIXME: This is just an optimization hack to avoid deserializing large parts\n  // of a PCH file when using the Index library on an ASTUnit loaded from\n  // source. In the long term we should make the Index library use efficient and\n  // more scalable search mechanisms.\n  std::vector<Decl*> TopLevelDecls;\n\n  /// Sorted (by file offset) vector of pairs of file offset/Decl.\n  using LocDeclsTy = SmallVector<std::pair<unsigned, Decl *>, 64>;\n  using FileDeclsTy = llvm::DenseMap<FileID, std::unique_ptr<LocDeclsTy>>;\n\n  /// Map from FileID to the file-level declarations that it contains.\n  /// The files and decls are only local (and non-preamble) ones.\n  FileDeclsTy FileDecls;\n\n  /// The name of the original source file used to generate this ASTUnit.\n  std::string OriginalSourceFile;\n\n  /// The set of diagnostics produced when creating the preamble.\n  SmallVector<StandaloneDiagnostic, 4> PreambleDiagnostics;\n\n  /// The set of diagnostics produced when creating this\n  /// translation unit.\n  SmallVector<StoredDiagnostic, 4> StoredDiagnostics;\n\n  /// The set of diagnostics produced when failing to parse, e.g. due\n  /// to failure to load the PCH.\n  SmallVector<StoredDiagnostic, 4> FailedParseDiagnostics;\n\n  /// The number of stored diagnostics that come from the driver\n  /// itself.\n  ///\n  /// Diagnostics that come from the driver are retained from one parse to\n  /// the next.\n  unsigned NumStoredDiagnosticsFromDriver = 0;\n\n  /// Counter that determines when we want to try building a\n  /// precompiled preamble.\n  ///\n  /// If zero, we will never build a precompiled preamble. Otherwise,\n  /// it's treated as a counter that decrements each time we reparse\n  /// without the benefit of a precompiled preamble. When it hits 1,\n  /// we'll attempt to rebuild the precompiled header. This way, if\n  /// building the precompiled preamble fails, we won't try again for\n  /// some number of calls.\n  unsigned PreambleRebuildCountdown = 0;\n\n  /// Counter indicating how often the preamble was build in total.\n  unsigned PreambleCounter = 0;\n\n  /// Cache pairs \"filename - source location\"\n  ///\n  /// Cache contains only source locations from preamble so it is\n  /// guaranteed that they stay valid when the SourceManager is recreated.\n  /// This cache is used when loading preamble to increase performance\n  /// of that loading. It must be cleared when preamble is recreated.\n  llvm::StringMap<SourceLocation> PreambleSrcLocCache;\n\n  /// The contents of the preamble.\n  llvm::Optional<PrecompiledPreamble> Preamble;\n\n  /// When non-NULL, this is the buffer used to store the contents of\n  /// the main file when it has been padded for use with the precompiled\n  /// preamble.\n  std::unique_ptr<llvm::MemoryBuffer> SavedMainFileBuffer;\n\n  /// The number of warnings that occurred while parsing the preamble.\n  ///\n  /// This value will be used to restore the state of the \\c DiagnosticsEngine\n  /// object when re-using the precompiled preamble. Note that only the\n  /// number of warnings matters, since we will not save the preamble\n  /// when any errors are present.\n  unsigned NumWarningsInPreamble = 0;\n\n  /// A list of the serialization ID numbers for each of the top-level\n  /// declarations parsed within the precompiled preamble.\n  std::vector<serialization::DeclID> TopLevelDeclsInPreamble;\n\n  /// Whether we should be caching code-completion results.\n  bool ShouldCacheCodeCompletionResults : 1;\n\n  /// Whether to include brief documentation within the set of code\n  /// completions cached.\n  bool IncludeBriefCommentsInCodeCompletion : 1;\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them).\n  bool UserFilesAreVolatile : 1;\n\n  static void ConfigureDiags(IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n                             ASTUnit &AST, CaptureDiagsKind CaptureDiagnostics);\n\n  void TranslateStoredDiagnostics(FileManager &FileMgr,\n                                  SourceManager &SrcMan,\n                      const SmallVectorImpl<StandaloneDiagnostic> &Diags,\n                            SmallVectorImpl<StoredDiagnostic> &Out);\n\n  void clearFileLevelDecls();\n\npublic:\n  /// A cached code-completion result, which may be introduced in one of\n  /// many different contexts.\n  struct CachedCodeCompletionResult {\n    /// The code-completion string corresponding to this completion\n    /// result.\n    CodeCompletionString *Completion;\n\n    /// A bitmask that indicates which code-completion contexts should\n    /// contain this completion result.\n    ///\n    /// The bits in the bitmask correspond to the values of\n    /// CodeCompleteContext::Kind. To map from a completion context kind to a\n    /// bit, shift 1 by that number of bits. Many completions can occur in\n    /// several different contexts.\n    uint64_t ShowInContexts;\n\n    /// The priority given to this code-completion result.\n    unsigned Priority;\n\n    /// The libclang cursor kind corresponding to this code-completion\n    /// result.\n    CXCursorKind Kind;\n\n    /// The availability of this code-completion result.\n    CXAvailabilityKind Availability;\n\n    /// The simplified type class for a non-macro completion result.\n    SimplifiedTypeClass TypeClass;\n\n    /// The type of a non-macro completion result, stored as a unique\n    /// integer used by the string map of cached completion types.\n    ///\n    /// This value will be zero if the type is not known, or a unique value\n    /// determined by the formatted type string. Se \\c CachedCompletionTypes\n    /// for more information.\n    unsigned Type;\n  };\n\n  /// Retrieve the mapping from formatted type names to unique type\n  /// identifiers.\n  llvm::StringMap<unsigned> &getCachedCompletionTypes() {\n    return CachedCompletionTypes;\n  }\n\n  /// Retrieve the allocator used to cache global code completions.\n  std::shared_ptr<GlobalCodeCompletionAllocator>\n  getCachedCompletionAllocator() {\n    return CachedCompletionAllocator;\n  }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() {\n    if (!CCTUInfo)\n      CCTUInfo = std::make_unique<CodeCompletionTUInfo>(\n          std::make_shared<GlobalCodeCompletionAllocator>());\n    return *CCTUInfo;\n  }\n\nprivate:\n  /// Allocator used to store cached code completions.\n  std::shared_ptr<GlobalCodeCompletionAllocator> CachedCompletionAllocator;\n\n  std::unique_ptr<CodeCompletionTUInfo> CCTUInfo;\n\n  /// The set of cached code-completion results.\n  std::vector<CachedCodeCompletionResult> CachedCompletionResults;\n\n  /// A mapping from the formatted type name to a unique number for that\n  /// type, which is used for type equality comparisons.\n  llvm::StringMap<unsigned> CachedCompletionTypes;\n\n  /// A string hash of the top-level declaration and macro definition\n  /// names processed the last time that we reparsed the file.\n  ///\n  /// This hash value is used to determine when we need to refresh the\n  /// global code-completion cache.\n  unsigned CompletionCacheTopLevelHashValue = 0;\n\n  /// A string hash of the top-level declaration and macro definition\n  /// names processed the last time that we reparsed the precompiled preamble.\n  ///\n  /// This hash value is used to determine when we need to refresh the\n  /// global code-completion cache after a rebuild of the precompiled preamble.\n  unsigned PreambleTopLevelHashValue = 0;\n\n  /// The current hash value for the top-level declaration and macro\n  /// definition names\n  unsigned CurrentTopLevelHashValue = 0;\n\n  /// Bit used by CIndex to mark when a translation unit may be in an\n  /// inconsistent state, and is not safe to free.\n  unsigned UnsafeToFree : 1;\n\n  /// \\brief Enumerator specifying the scope for skipping function bodies.\n  SkipFunctionBodiesScope SkipFunctionBodies = SkipFunctionBodiesScope::None;\n\n  /// Cache any \"global\" code-completion results, so that we can avoid\n  /// recomputing them with each completion.\n  void CacheCodeCompletionResults();\n\n  /// Clear out and deallocate\n  void ClearCachedCompletionResults();\n\n  explicit ASTUnit(bool MainFileIsAST);\n\n  bool Parse(std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n             std::unique_ptr<llvm::MemoryBuffer> OverrideMainBuffer,\n             IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS);\n\n  std::unique_ptr<llvm::MemoryBuffer> getMainBufferWithPrecompiledPreamble(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      CompilerInvocation &PreambleInvocationIn,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS, bool AllowRebuild = true,\n      unsigned MaxLines = 0);\n  void RealizeTopLevelDeclsFromPreamble();\n\n  /// Transfers ownership of the objects (like SourceManager) from\n  /// \\param CI to this ASTUnit.\n  void transferASTDataFromCompilerInstance(CompilerInstance &CI);\n\n  /// Allows us to assert that ASTUnit is not being used concurrently,\n  /// which is not supported.\n  ///\n  /// Clients should create instances of the ConcurrencyCheck class whenever\n  /// using the ASTUnit in a way that isn't intended to be concurrent, which is\n  /// just about any usage.\n  /// Becomes a noop in release mode; only useful for debug mode checking.\n  class ConcurrencyState {\n    void *Mutex; // a std::recursive_mutex in debug;\n\n  public:\n    ConcurrencyState();\n    ~ConcurrencyState();\n\n    void start();\n    void finish();\n  };\n  ConcurrencyState ConcurrencyCheckValue;\n\npublic:\n  friend class ConcurrencyCheck;\n\n  class ConcurrencyCheck {\n    ASTUnit &Self;\n\n  public:\n    explicit ConcurrencyCheck(ASTUnit &Self) : Self(Self) {\n      Self.ConcurrencyCheckValue.start();\n    }\n\n    ~ConcurrencyCheck() {\n      Self.ConcurrencyCheckValue.finish();\n    }\n  };\n\n  ASTUnit(const ASTUnit &) = delete;\n  ASTUnit &operator=(const ASTUnit &) = delete;\n  ~ASTUnit();\n\n  bool isMainFileAST() const { return MainFileIsAST; }\n\n  bool isUnsafeToFree() const { return UnsafeToFree; }\n  void setUnsafeToFree(bool Value) { UnsafeToFree = Value; }\n\n  const DiagnosticsEngine &getDiagnostics() const { return *Diagnostics; }\n  DiagnosticsEngine &getDiagnostics() { return *Diagnostics; }\n\n  const SourceManager &getSourceManager() const { return *SourceMgr; }\n  SourceManager &getSourceManager() { return *SourceMgr; }\n\n  const Preprocessor &getPreprocessor() const { return *PP; }\n  Preprocessor &getPreprocessor() { return *PP; }\n  std::shared_ptr<Preprocessor> getPreprocessorPtr() const { return PP; }\n\n  const ASTContext &getASTContext() const { return *Ctx; }\n  ASTContext &getASTContext() { return *Ctx; }\n\n  void setASTContext(ASTContext *ctx) { Ctx = ctx; }\n  void setPreprocessor(std::shared_ptr<Preprocessor> pp);\n\n  /// Enable source-range based diagnostic messages.\n  ///\n  /// If diagnostic messages with source-range information are to be expected\n  /// and AST comes not from file (e.g. after LoadFromCompilerInvocation) this\n  /// function has to be called.\n  /// The function is to be called only once and the AST should be associated\n  /// with the same source file afterwards.\n  void enableSourceFileDiagnostics();\n\n  bool hasSema() const { return (bool)TheSema; }\n\n  Sema &getSema() const {\n    assert(TheSema && \"ASTUnit does not have a Sema object!\");\n    return *TheSema;\n  }\n\n  const LangOptions &getLangOpts() const {\n    assert(LangOpts && \"ASTUnit does not have language options\");\n    return *LangOpts;\n  }\n\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    assert(HSOpts && \"ASTUnit does not have header search options\");\n    return *HSOpts;\n  }\n\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    assert(PPOpts && \"ASTUnit does not have preprocessor options\");\n    return *PPOpts;\n  }\n\n  const FileManager &getFileManager() const { return *FileMgr; }\n  FileManager &getFileManager() { return *FileMgr; }\n\n  const FileSystemOptions &getFileSystemOpts() const { return FileSystemOpts; }\n\n  IntrusiveRefCntPtr<ASTReader> getASTReader() const;\n\n  StringRef getOriginalSourceFileName() const {\n    return OriginalSourceFile;\n  }\n\n  ASTMutationListener *getASTMutationListener();\n  ASTDeserializationListener *getDeserializationListener();\n\n  bool getOnlyLocalDecls() const { return OnlyLocalDecls; }\n\n  bool getOwnsRemappedFileBuffers() const { return OwnsRemappedFileBuffers; }\n  void setOwnsRemappedFileBuffers(bool val) { OwnsRemappedFileBuffers = val; }\n\n  StringRef getMainFileName() const;\n\n  /// If this ASTUnit came from an AST file, returns the filename for it.\n  StringRef getASTFileName() const;\n\n  using top_level_iterator = std::vector<Decl *>::iterator;\n\n  top_level_iterator top_level_begin() {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    if (!TopLevelDeclsInPreamble.empty())\n      RealizeTopLevelDeclsFromPreamble();\n    return TopLevelDecls.begin();\n  }\n\n  top_level_iterator top_level_end() {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    if (!TopLevelDeclsInPreamble.empty())\n      RealizeTopLevelDeclsFromPreamble();\n    return TopLevelDecls.end();\n  }\n\n  std::size_t top_level_size() const {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    return TopLevelDeclsInPreamble.size() + TopLevelDecls.size();\n  }\n\n  bool top_level_empty() const {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    return TopLevelDeclsInPreamble.empty() && TopLevelDecls.empty();\n  }\n\n  /// Add a new top-level declaration.\n  void addTopLevelDecl(Decl *D) {\n    TopLevelDecls.push_back(D);\n  }\n\n  /// Add a new local file-level declaration.\n  void addFileLevelDecl(Decl *D);\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  void findFileRegionDecls(FileID File, unsigned Offset, unsigned Length,\n                           SmallVectorImpl<Decl *> &Decls);\n\n  /// Retrieve a reference to the current top-level name hash value.\n  ///\n  /// Note: This is used internally by the top-level tracking action\n  unsigned &getCurrentTopLevelHashValue() { return CurrentTopLevelHashValue; }\n\n  /// Get the source location for the given file:line:col triplet.\n  ///\n  /// The difference with SourceManager::getLocation is that this method checks\n  /// whether the requested location points inside the precompiled preamble\n  /// in which case the returned source location will be a \"loaded\" one.\n  SourceLocation getLocation(const FileEntry *File,\n                             unsigned Line, unsigned Col) const;\n\n  /// Get the source location for the given file:offset pair.\n  SourceLocation getLocation(const FileEntry *File, unsigned Offset) const;\n\n  /// If \\p Loc is a loaded location from the preamble, returns\n  /// the corresponding local location of the main file, otherwise it returns\n  /// \\p Loc.\n  SourceLocation mapLocationFromPreamble(SourceLocation Loc) const;\n\n  /// If \\p Loc is a local location of the main file but inside the\n  /// preamble chunk, returns the corresponding loaded location from the\n  /// preamble, otherwise it returns \\p Loc.\n  SourceLocation mapLocationToPreamble(SourceLocation Loc) const;\n\n  bool isInPreambleFileID(SourceLocation Loc) const;\n  bool isInMainFileID(SourceLocation Loc) const;\n  SourceLocation getStartOfMainFileID() const;\n  SourceLocation getEndOfPreambleFileID() const;\n\n  /// \\see mapLocationFromPreamble.\n  SourceRange mapRangeFromPreamble(SourceRange R) const {\n    return SourceRange(mapLocationFromPreamble(R.getBegin()),\n                       mapLocationFromPreamble(R.getEnd()));\n  }\n\n  /// \\see mapLocationToPreamble.\n  SourceRange mapRangeToPreamble(SourceRange R) const {\n    return SourceRange(mapLocationToPreamble(R.getBegin()),\n                       mapLocationToPreamble(R.getEnd()));\n  }\n\n  unsigned getPreambleCounterForTests() const { return PreambleCounter; }\n\n  // Retrieve the diagnostics associated with this AST\n  using stored_diag_iterator = StoredDiagnostic *;\n  using stored_diag_const_iterator = const StoredDiagnostic *;\n\n  stored_diag_const_iterator stored_diag_begin() const {\n    return StoredDiagnostics.begin();\n  }\n\n  stored_diag_iterator stored_diag_begin() {\n    return StoredDiagnostics.begin();\n  }\n\n  stored_diag_const_iterator stored_diag_end() const {\n    return StoredDiagnostics.end();\n  }\n\n  stored_diag_iterator stored_diag_end() {\n    return StoredDiagnostics.end();\n  }\n\n  unsigned stored_diag_size() const { return StoredDiagnostics.size(); }\n\n  stored_diag_iterator stored_diag_afterDriver_begin() {\n    if (NumStoredDiagnosticsFromDriver > StoredDiagnostics.size())\n      NumStoredDiagnosticsFromDriver = 0;\n    return StoredDiagnostics.begin() + NumStoredDiagnosticsFromDriver;\n  }\n\n  using cached_completion_iterator =\n      std::vector<CachedCodeCompletionResult>::iterator;\n\n  cached_completion_iterator cached_completion_begin() {\n    return CachedCompletionResults.begin();\n  }\n\n  cached_completion_iterator cached_completion_end() {\n    return CachedCompletionResults.end();\n  }\n\n  unsigned cached_completion_size() const {\n    return CachedCompletionResults.size();\n  }\n\n  /// Returns an iterator range for the local preprocessing entities\n  /// of the local Preprocessor, if this is a parsed source file, or the loaded\n  /// preprocessing entities of the primary module if this is an AST file.\n  llvm::iterator_range<PreprocessingRecord::iterator>\n  getLocalPreprocessingEntities() const;\n\n  /// Type for a function iterating over a number of declarations.\n  /// \\returns true to continue iteration and false to abort.\n  using DeclVisitorFn = bool (*)(void *context, const Decl *D);\n\n  /// Iterate over local declarations (locally parsed if this is a parsed\n  /// source file or the loaded declarations of the primary module if this is an\n  /// AST file).\n  /// \\returns true if the iteration was complete or false if it was aborted.\n  bool visitLocalTopLevelDecls(void *context, DeclVisitorFn Fn);\n\n  /// Get the PCH file if one was included.\n  const FileEntry *getPCHFile();\n\n  /// Returns true if the ASTUnit was constructed from a serialized\n  /// module file.\n  bool isModuleFile() const;\n\n  std::unique_ptr<llvm::MemoryBuffer>\n  getBufferForFile(StringRef Filename, std::string *ErrorStr = nullptr);\n\n  /// Determine what kind of translation unit this AST represents.\n  TranslationUnitKind getTranslationUnitKind() const { return TUKind; }\n\n  /// Determine the input kind this AST unit represents.\n  InputKind getInputKind() const;\n\n  /// A mapping from a file name to the memory buffer that stores the\n  /// remapped contents of that file.\n  using RemappedFile = std::pair<std::string, llvm::MemoryBuffer *>;\n\n  /// Create a ASTUnit. Gets ownership of the passed CompilerInvocation.\n  static std::unique_ptr<ASTUnit>\n  create(std::shared_ptr<CompilerInvocation> CI,\n         IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n         CaptureDiagsKind CaptureDiagnostics, bool UserFilesAreVolatile);\n\n  enum WhatToLoad {\n    /// Load options and the preprocessor state.\n    LoadPreprocessorOnly,\n\n    /// Load the AST, but do not restore Sema state.\n    LoadASTOnly,\n\n    /// Load everything, including Sema.\n    LoadEverything\n  };\n\n  /// Create a ASTUnit from an AST file.\n  ///\n  /// \\param Filename - The AST file to load.\n  ///\n  /// \\param PCHContainerRdr - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\returns - The initialized ASTUnit or null if the AST failed to load.\n  static std::unique_ptr<ASTUnit>\n  LoadFromASTFile(const std::string &Filename,\n                  const PCHContainerReader &PCHContainerRdr, WhatToLoad ToLoad,\n                  IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n                  const FileSystemOptions &FileSystemOpts,\n                  bool UseDebugInfo = false, bool OnlyLocalDecls = false,\n                  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n                  bool AllowASTWithCompilerErrors = false,\n                  bool UserFilesAreVolatile = false);\n\nprivate:\n  /// Helper function for \\c LoadFromCompilerInvocation() and\n  /// \\c LoadFromCommandLine(), which loads an AST from a compiler invocation.\n  ///\n  /// \\param PrecompilePreambleAfterNParses After how many parses the preamble\n  /// of this translation unit should be precompiled, to improve the performance\n  /// of reparsing. Set to zero to disable preambles.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should have access to\n  /// it(i.e., be an overlay over RealFileSystem).\n  ///\n  /// \\returns \\c true if a catastrophic failure occurred (which means that the\n  /// \\c ASTUnit itself is invalid), or \\c false otherwise.\n  bool LoadFromCompilerInvocation(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      unsigned PrecompilePreambleAfterNParses,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS);\n\npublic:\n  /// Create an ASTUnit from a source file, via a CompilerInvocation\n  /// object, by invoking the optionally provided ASTFrontendAction.\n  ///\n  /// \\param CI - The compiler invocation to use; it must have exactly one input\n  /// source file. The ASTUnit takes ownership of the CompilerInvocation object.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\param Action - The ASTFrontendAction to invoke. Its ownership is not\n  /// transferred.\n  ///\n  /// \\param Unit - optionally an already created ASTUnit. Its ownership is not\n  /// transferred.\n  ///\n  /// \\param Persistent - if true the returned ASTUnit will be complete.\n  /// false means the caller is only interested in getting info through the\n  /// provided \\see Action.\n  ///\n  /// \\param ErrAST - If non-null and parsing failed without any AST to return\n  /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit\n  /// mainly to allow the caller to see the diagnostics.\n  /// This will only receive an ASTUnit if a new one was created. If an already\n  /// created ASTUnit was passed in \\p Unit then the caller can check that.\n  ///\n  static ASTUnit *LoadFromCompilerInvocationAction(\n      std::shared_ptr<CompilerInvocation> CI,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n      FrontendAction *Action = nullptr, ASTUnit *Unit = nullptr,\n      bool Persistent = true, StringRef ResourceFilesPath = StringRef(),\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      bool CacheCodeCompletionResults = false,\n      bool UserFilesAreVolatile = false,\n      std::unique_ptr<ASTUnit> *ErrAST = nullptr);\n\n  /// LoadFromCompilerInvocation - Create an ASTUnit from a source file, via a\n  /// CompilerInvocation object.\n  ///\n  /// \\param CI - The compiler invocation to use; it must have exactly one input\n  /// source file. The ASTUnit takes ownership of the CompilerInvocation object.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  //\n  // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we\n  // shouldn't need to specify them at construction time.\n  static std::unique_ptr<ASTUnit> LoadFromCompilerInvocation(\n      std::shared_ptr<CompilerInvocation> CI,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags, FileManager *FileMgr,\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      TranslationUnitKind TUKind = TU_Complete,\n      bool CacheCodeCompletionResults = false,\n      bool IncludeBriefCommentsInCodeCompletion = false,\n      bool UserFilesAreVolatile = false);\n\n  /// LoadFromCommandLine - Create an ASTUnit from a vector of command line\n  /// arguments, which must specify exactly one source file.\n  ///\n  /// \\param ArgBegin - The beginning of the argument vector.\n  ///\n  /// \\param ArgEnd - The end of the argument vector.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\param ResourceFilesPath - The path to the compiler resource files.\n  ///\n  /// \\param ModuleFormat - If provided, uses the specific module format.\n  ///\n  /// \\param ErrAST - If non-null and parsing failed without any AST to return\n  /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit\n  /// mainly to allow the caller to see the diagnostics.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should have access to\n  /// it(i.e., be an overlay over RealFileSystem). RealFileSystem will be used\n  /// if \\p VFS is nullptr.\n  ///\n  // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we\n  // shouldn't need to specify them at construction time.\n  static ASTUnit *LoadFromCommandLine(\n      const char **ArgBegin, const char **ArgEnd,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags, StringRef ResourceFilesPath,\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      ArrayRef<RemappedFile> RemappedFiles = None,\n      bool RemappedFilesKeepOriginalName = true,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      TranslationUnitKind TUKind = TU_Complete,\n      bool CacheCodeCompletionResults = false,\n      bool IncludeBriefCommentsInCodeCompletion = false,\n      bool AllowPCHWithCompilerErrors = false,\n      SkipFunctionBodiesScope SkipFunctionBodies =\n          SkipFunctionBodiesScope::None,\n      bool SingleFileParse = false, bool UserFilesAreVolatile = false,\n      bool ForSerialization = false,\n      bool RetainExcludedConditionalBlocks = false,\n      llvm::Optional<StringRef> ModuleFormat = llvm::None,\n      std::unique_ptr<ASTUnit> *ErrAST = nullptr,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Reparse the source files using the same command-line options that\n  /// were originally used to produce this translation unit.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should give an access to\n  /// this(i.e. be an overlay over RealFileSystem).\n  /// FileMgr->getVirtualFileSystem() will be used if \\p VFS is nullptr.\n  ///\n  /// \\returns True if a failure occurred that causes the ASTUnit not to\n  /// contain any translation-unit information, false otherwise.\n  bool Reparse(std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n               ArrayRef<RemappedFile> RemappedFiles = None,\n               IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Free data that will be re-generated on the next parse.\n  ///\n  /// Preamble-related data is not affected.\n  void ResetForParse();\n\n  /// Perform code completion at the given file, line, and\n  /// column within this translation unit.\n  ///\n  /// \\param File The file in which code completion will occur.\n  ///\n  /// \\param Line The line at which code completion will occur.\n  ///\n  /// \\param Column The column at which code completion will occur.\n  ///\n  /// \\param IncludeMacros Whether to include macros in the code-completion\n  /// results.\n  ///\n  /// \\param IncludeCodePatterns Whether to include code patterns (such as a\n  /// for loop) in the code-completion results.\n  ///\n  /// \\param IncludeBriefComments Whether to include brief documentation within\n  /// the set of code completions returned.\n  ///\n  /// FIXME: The Diag, LangOpts, SourceMgr, FileMgr, StoredDiagnostics, and\n  /// OwnedBuffers parameters are all disgusting hacks. They will go away.\n  void CodeComplete(StringRef File, unsigned Line, unsigned Column,\n                    ArrayRef<RemappedFile> RemappedFiles, bool IncludeMacros,\n                    bool IncludeCodePatterns, bool IncludeBriefComments,\n                    CodeCompleteConsumer &Consumer,\n                    std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n                    DiagnosticsEngine &Diag, LangOptions &LangOpts,\n                    SourceManager &SourceMgr, FileManager &FileMgr,\n                    SmallVectorImpl<StoredDiagnostic> &StoredDiagnostics,\n                    SmallVectorImpl<const llvm::MemoryBuffer *> &OwnedBuffers);\n\n  /// Save this translation unit to a file with the given name.\n  ///\n  /// \\returns true if there was a file error or false if the save was\n  /// successful.\n  bool Save(StringRef File);\n\n  /// Serialize this translation unit with the given output stream.\n  ///\n  /// \\returns True if an error occurred, false otherwise.\n  bool serialize(raw_ostream &OS);\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_ASTUNIT_H\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInstance.h", "content": "//===-- CompilerInstance.h - Clang Compiler Instance ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_COMPILERINSTANCE_H_\n#define LLVM_CLANG_FRONTEND_COMPILERINSTANCE_H_\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Frontend/CompilerInvocation.h\"\n#include \"clang/Frontend/PCHContainerOperations.h\"\n#include \"clang/Frontend/Utils.h\"\n#include \"clang/Lex/HeaderSearchOptions.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/BuryPointer.h\"\n#include <cassert>\n#include <list>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace llvm {\nclass raw_fd_ostream;\nclass Timer;\nclass TimerGroup;\n}\n\nnamespace clang {\nclass ASTContext;\nclass ASTReader;\nclass CodeCompleteConsumer;\nclass DiagnosticsEngine;\nclass DiagnosticConsumer;\nclass ExternalASTSource;\nclass FileEntry;\nclass FileManager;\nclass FrontendAction;\nclass InMemoryModuleCache;\nclass Module;\nclass Preprocessor;\nclass Sema;\nclass SourceManager;\nclass TargetInfo;\nenum class DisableValidationForModuleKind;\n\n/// CompilerInstance - Helper class for managing a single instance of the Clang\n/// compiler.\n///\n/// The CompilerInstance serves two purposes:\n///  (1) It manages the various objects which are necessary to run the compiler,\n///      for example the preprocessor, the target information, and the AST\n///      context.\n///  (2) It provides utility routines for constructing and manipulating the\n///      common Clang objects.\n///\n/// The compiler instance generally owns the instance of all the objects that it\n/// manages. However, clients can still share objects by manually setting the\n/// object and retaking ownership prior to destroying the CompilerInstance.\n///\n/// The compiler instance is intended to simplify clients, but not to lock them\n/// in to the compiler instance for everything. When possible, utility functions\n/// come in two forms; a short form that reuses the CompilerInstance objects,\n/// and a long form that takes explicit instances of any required objects.\nclass CompilerInstance : public ModuleLoader {\n  /// The options used in this compiler instance.\n  std::shared_ptr<CompilerInvocation> Invocation;\n\n  /// The diagnostics engine instance.\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diagnostics;\n\n  /// The target being compiled for.\n  IntrusiveRefCntPtr<TargetInfo> Target;\n\n  /// Auxiliary Target info.\n  IntrusiveRefCntPtr<TargetInfo> AuxTarget;\n\n  /// The file manager.\n  IntrusiveRefCntPtr<FileManager> FileMgr;\n\n  /// The source manager.\n  IntrusiveRefCntPtr<SourceManager> SourceMgr;\n\n  /// The cache of PCM files.\n  IntrusiveRefCntPtr<InMemoryModuleCache> ModuleCache;\n\n  /// The preprocessor.\n  std::shared_ptr<Preprocessor> PP;\n\n  /// The AST context.\n  IntrusiveRefCntPtr<ASTContext> Context;\n\n  /// An optional sema source that will be attached to sema.\n  IntrusiveRefCntPtr<ExternalSemaSource> ExternalSemaSrc;\n\n  /// The AST consumer.\n  std::unique_ptr<ASTConsumer> Consumer;\n\n  /// The code completion consumer.\n  std::unique_ptr<CodeCompleteConsumer> CompletionConsumer;\n\n  /// The semantic analysis object.\n  std::unique_ptr<Sema> TheSema;\n\n  /// The frontend timer group.\n  std::unique_ptr<llvm::TimerGroup> FrontendTimerGroup;\n\n  /// The frontend timer.\n  std::unique_ptr<llvm::Timer> FrontendTimer;\n\n  /// The ASTReader, if one exists.\n  IntrusiveRefCntPtr<ASTReader> TheASTReader;\n\n  /// The module dependency collector for crashdumps\n  std::shared_ptr<ModuleDependencyCollector> ModuleDepCollector;\n\n  /// The module provider.\n  std::shared_ptr<PCHContainerOperations> ThePCHContainerOperations;\n\n  std::vector<std::shared_ptr<DependencyCollector>> DependencyCollectors;\n\n  /// The set of top-level modules that has already been built on the\n  /// fly as part of this overall compilation action.\n  std::map<std::string, std::string, std::less<>> BuiltModules;\n\n  /// Should we delete the BuiltModules when we're done?\n  bool DeleteBuiltModules = true;\n\n  /// The location of the module-import keyword for the last module\n  /// import.\n  SourceLocation LastModuleImportLoc;\n\n  /// The result of the last module import.\n  ///\n  ModuleLoadResult LastModuleImportResult;\n\n  /// Whether we should (re)build the global module index once we\n  /// have finished with this translation unit.\n  bool BuildGlobalModuleIndex = false;\n\n  /// We have a full global module index, with all modules.\n  bool HaveFullGlobalModuleIndex = false;\n\n  /// One or more modules failed to build.\n  bool ModuleBuildFailed = false;\n\n  /// The stream for verbose output if owned, otherwise nullptr.\n  std::unique_ptr<raw_ostream> OwnedVerboseOutputStream;\n\n  /// The stream for verbose output.\n  raw_ostream *VerboseOutputStream = &llvm::errs();\n\n  /// Holds information about the output file.\n  ///\n  /// If TempFilename is not empty we must rename it to Filename at the end.\n  /// TempFilename may be empty and Filename non-empty if creating the temporary\n  /// failed.\n  struct OutputFile {\n    std::string Filename;\n    std::string TempFilename;\n\n    OutputFile(std::string filename, std::string tempFilename)\n        : Filename(std::move(filename)), TempFilename(std::move(tempFilename)) {\n    }\n  };\n\n  /// The list of active output files.\n  std::list<OutputFile> OutputFiles;\n\n  /// Force an output buffer.\n  std::unique_ptr<llvm::raw_pwrite_stream> OutputStream;\n\n  CompilerInstance(const CompilerInstance &) = delete;\n  void operator=(const CompilerInstance &) = delete;\npublic:\n  explicit CompilerInstance(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n          std::make_shared<PCHContainerOperations>(),\n      InMemoryModuleCache *SharedModuleCache = nullptr);\n  ~CompilerInstance() override;\n\n  /// @name High-Level Operations\n  /// {\n\n  /// ExecuteAction - Execute the provided action against the compiler's\n  /// CompilerInvocation object.\n  ///\n  /// This function makes the following assumptions:\n  ///\n  ///  - The invocation options should be initialized. This function does not\n  ///    handle the '-help' or '-version' options, clients should handle those\n  ///    directly.\n  ///\n  ///  - The diagnostics engine should have already been created by the client.\n  ///\n  ///  - No other CompilerInstance state should have been initialized (this is\n  ///    an unchecked error).\n  ///\n  ///  - Clients should have initialized any LLVM target features that may be\n  ///    required.\n  ///\n  ///  - Clients should eventually call llvm_shutdown() upon the completion of\n  ///    this routine to ensure that any managed objects are properly destroyed.\n  ///\n  /// Note that this routine may write output to 'stderr'.\n  ///\n  /// \\param Act - The action to execute.\n  /// \\return - True on success.\n  //\n  // FIXME: Eliminate the llvm_shutdown requirement, that should either be part\n  // of the context or else not CompilerInstance specific.\n  bool ExecuteAction(FrontendAction &Act);\n\n  /// }\n  /// @name Compiler Invocation and Options\n  /// {\n\n  bool hasInvocation() const { return Invocation != nullptr; }\n\n  CompilerInvocation &getInvocation() {\n    assert(Invocation && \"Compiler instance has no invocation!\");\n    return *Invocation;\n  }\n\n  /// setInvocation - Replace the current invocation.\n  void setInvocation(std::shared_ptr<CompilerInvocation> Value);\n\n  /// Indicates whether we should (re)build the global module index.\n  bool shouldBuildGlobalModuleIndex() const;\n\n  /// Set the flag indicating whether we should (re)build the global\n  /// module index.\n  void setBuildGlobalModuleIndex(bool Build) {\n    BuildGlobalModuleIndex = Build;\n  }\n\n  /// }\n  /// @name Forwarding Methods\n  /// {\n\n  AnalyzerOptionsRef getAnalyzerOpts() {\n    return Invocation->getAnalyzerOpts();\n  }\n\n  CodeGenOptions &getCodeGenOpts() {\n    return Invocation->getCodeGenOpts();\n  }\n  const CodeGenOptions &getCodeGenOpts() const {\n    return Invocation->getCodeGenOpts();\n  }\n\n  DependencyOutputOptions &getDependencyOutputOpts() {\n    return Invocation->getDependencyOutputOpts();\n  }\n  const DependencyOutputOptions &getDependencyOutputOpts() const {\n    return Invocation->getDependencyOutputOpts();\n  }\n\n  DiagnosticOptions &getDiagnosticOpts() {\n    return Invocation->getDiagnosticOpts();\n  }\n  const DiagnosticOptions &getDiagnosticOpts() const {\n    return Invocation->getDiagnosticOpts();\n  }\n\n  FileSystemOptions &getFileSystemOpts() {\n    return Invocation->getFileSystemOpts();\n  }\n  const FileSystemOptions &getFileSystemOpts() const {\n    return Invocation->getFileSystemOpts();\n  }\n\n  FrontendOptions &getFrontendOpts() {\n    return Invocation->getFrontendOpts();\n  }\n  const FrontendOptions &getFrontendOpts() const {\n    return Invocation->getFrontendOpts();\n  }\n\n  HeaderSearchOptions &getHeaderSearchOpts() {\n    return Invocation->getHeaderSearchOpts();\n  }\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    return Invocation->getHeaderSearchOpts();\n  }\n  std::shared_ptr<HeaderSearchOptions> getHeaderSearchOptsPtr() const {\n    return Invocation->getHeaderSearchOptsPtr();\n  }\n\n  LangOptions &getLangOpts() {\n    return *Invocation->getLangOpts();\n  }\n  const LangOptions &getLangOpts() const {\n    return *Invocation->getLangOpts();\n  }\n\n  PreprocessorOptions &getPreprocessorOpts() {\n    return Invocation->getPreprocessorOpts();\n  }\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    return Invocation->getPreprocessorOpts();\n  }\n\n  PreprocessorOutputOptions &getPreprocessorOutputOpts() {\n    return Invocation->getPreprocessorOutputOpts();\n  }\n  const PreprocessorOutputOptions &getPreprocessorOutputOpts() const {\n    return Invocation->getPreprocessorOutputOpts();\n  }\n\n  TargetOptions &getTargetOpts() {\n    return Invocation->getTargetOpts();\n  }\n  const TargetOptions &getTargetOpts() const {\n    return Invocation->getTargetOpts();\n  }\n\n  /// }\n  /// @name Diagnostics Engine\n  /// {\n\n  bool hasDiagnostics() const { return Diagnostics != nullptr; }\n\n  /// Get the current diagnostics engine.\n  DiagnosticsEngine &getDiagnostics() const {\n    assert(Diagnostics && \"Compiler instance has no diagnostics!\");\n    return *Diagnostics;\n  }\n\n  /// setDiagnostics - Replace the current diagnostics engine.\n  void setDiagnostics(DiagnosticsEngine *Value);\n\n  DiagnosticConsumer &getDiagnosticClient() const {\n    assert(Diagnostics && Diagnostics->getClient() &&\n           \"Compiler instance has no diagnostic client!\");\n    return *Diagnostics->getClient();\n  }\n\n  /// }\n  /// @name VerboseOutputStream\n  /// }\n\n  /// Replace the current stream for verbose output.\n  void setVerboseOutputStream(raw_ostream &Value);\n\n  /// Replace the current stream for verbose output.\n  void setVerboseOutputStream(std::unique_ptr<raw_ostream> Value);\n\n  /// Get the current stream for verbose output.\n  raw_ostream &getVerboseOutputStream() {\n    return *VerboseOutputStream;\n  }\n\n  /// }\n  /// @name Target Info\n  /// {\n\n  bool hasTarget() const { return Target != nullptr; }\n\n  TargetInfo &getTarget() const {\n    assert(Target && \"Compiler instance has no target!\");\n    return *Target;\n  }\n\n  /// Replace the current Target.\n  void setTarget(TargetInfo *Value);\n\n  /// }\n  /// @name AuxTarget Info\n  /// {\n\n  TargetInfo *getAuxTarget() const { return AuxTarget.get(); }\n\n  /// Replace the current AuxTarget.\n  void setAuxTarget(TargetInfo *Value);\n\n  // Create Target and AuxTarget based on current options\n  bool createTarget();\n\n  /// }\n  /// @name Virtual File System\n  /// {\n\n  llvm::vfs::FileSystem &getVirtualFileSystem() const;\n\n  /// }\n  /// @name File Manager\n  /// {\n\n  bool hasFileManager() const { return FileMgr != nullptr; }\n\n  /// Return the current file manager to the caller.\n  FileManager &getFileManager() const {\n    assert(FileMgr && \"Compiler instance has no file manager!\");\n    return *FileMgr;\n  }\n\n  void resetAndLeakFileManager() {\n    llvm::BuryPointer(FileMgr.get());\n    FileMgr.resetWithoutRelease();\n  }\n\n  /// Replace the current file manager and virtual file system.\n  void setFileManager(FileManager *Value);\n\n  /// }\n  /// @name Source Manager\n  /// {\n\n  bool hasSourceManager() const { return SourceMgr != nullptr; }\n\n  /// Return the current source manager.\n  SourceManager &getSourceManager() const {\n    assert(SourceMgr && \"Compiler instance has no source manager!\");\n    return *SourceMgr;\n  }\n\n  void resetAndLeakSourceManager() {\n    llvm::BuryPointer(SourceMgr.get());\n    SourceMgr.resetWithoutRelease();\n  }\n\n  /// setSourceManager - Replace the current source manager.\n  void setSourceManager(SourceManager *Value);\n\n  /// }\n  /// @name Preprocessor\n  /// {\n\n  bool hasPreprocessor() const { return PP != nullptr; }\n\n  /// Return the current preprocessor.\n  Preprocessor &getPreprocessor() const {\n    assert(PP && \"Compiler instance has no preprocessor!\");\n    return *PP;\n  }\n\n  std::shared_ptr<Preprocessor> getPreprocessorPtr() { return PP; }\n\n  void resetAndLeakPreprocessor() {\n    llvm::BuryPointer(new std::shared_ptr<Preprocessor>(PP));\n  }\n\n  /// Replace the current preprocessor.\n  void setPreprocessor(std::shared_ptr<Preprocessor> Value);\n\n  /// }\n  /// @name ASTContext\n  /// {\n\n  bool hasASTContext() const { return Context != nullptr; }\n\n  ASTContext &getASTContext() const {\n    assert(Context && \"Compiler instance has no AST context!\");\n    return *Context;\n  }\n\n  void resetAndLeakASTContext() {\n    llvm::BuryPointer(Context.get());\n    Context.resetWithoutRelease();\n  }\n\n  /// setASTContext - Replace the current AST context.\n  void setASTContext(ASTContext *Value);\n\n  /// Replace the current Sema; the compiler instance takes ownership\n  /// of S.\n  void setSema(Sema *S);\n\n  /// }\n  /// @name ASTConsumer\n  /// {\n\n  bool hasASTConsumer() const { return (bool)Consumer; }\n\n  ASTConsumer &getASTConsumer() const {\n    assert(Consumer && \"Compiler instance has no AST consumer!\");\n    return *Consumer;\n  }\n\n  /// takeASTConsumer - Remove the current AST consumer and give ownership to\n  /// the caller.\n  std::unique_ptr<ASTConsumer> takeASTConsumer() { return std::move(Consumer); }\n\n  /// setASTConsumer - Replace the current AST consumer; the compiler instance\n  /// takes ownership of \\p Value.\n  void setASTConsumer(std::unique_ptr<ASTConsumer> Value);\n\n  /// }\n  /// @name Semantic analysis\n  /// {\n  bool hasSema() const { return (bool)TheSema; }\n\n  Sema &getSema() const {\n    assert(TheSema && \"Compiler instance has no Sema object!\");\n    return *TheSema;\n  }\n\n  std::unique_ptr<Sema> takeSema();\n  void resetAndLeakSema();\n\n  /// }\n  /// @name Module Management\n  /// {\n\n  IntrusiveRefCntPtr<ASTReader> getASTReader() const;\n  void setASTReader(IntrusiveRefCntPtr<ASTReader> Reader);\n\n  std::shared_ptr<ModuleDependencyCollector> getModuleDepCollector() const;\n  void setModuleDepCollector(\n      std::shared_ptr<ModuleDependencyCollector> Collector);\n\n  std::shared_ptr<PCHContainerOperations> getPCHContainerOperations() const {\n    return ThePCHContainerOperations;\n  }\n\n  /// Return the appropriate PCHContainerWriter depending on the\n  /// current CodeGenOptions.\n  const PCHContainerWriter &getPCHContainerWriter() const {\n    assert(Invocation && \"cannot determine module format without invocation\");\n    StringRef Format = getHeaderSearchOpts().ModuleFormat;\n    auto *Writer = ThePCHContainerOperations->getWriterOrNull(Format);\n    if (!Writer) {\n      if (Diagnostics)\n        Diagnostics->Report(diag::err_module_format_unhandled) << Format;\n      llvm::report_fatal_error(\"unknown module format\");\n    }\n    return *Writer;\n  }\n\n  /// Return the appropriate PCHContainerReader depending on the\n  /// current CodeGenOptions.\n  const PCHContainerReader &getPCHContainerReader() const {\n    assert(Invocation && \"cannot determine module format without invocation\");\n    StringRef Format = getHeaderSearchOpts().ModuleFormat;\n    auto *Reader = ThePCHContainerOperations->getReaderOrNull(Format);\n    if (!Reader) {\n      if (Diagnostics)\n        Diagnostics->Report(diag::err_module_format_unhandled) << Format;\n      llvm::report_fatal_error(\"unknown module format\");\n    }\n    return *Reader;\n  }\n\n  /// }\n  /// @name Code Completion\n  /// {\n\n  bool hasCodeCompletionConsumer() const { return (bool)CompletionConsumer; }\n\n  CodeCompleteConsumer &getCodeCompletionConsumer() const {\n    assert(CompletionConsumer &&\n           \"Compiler instance has no code completion consumer!\");\n    return *CompletionConsumer;\n  }\n\n  /// setCodeCompletionConsumer - Replace the current code completion consumer;\n  /// the compiler instance takes ownership of \\p Value.\n  void setCodeCompletionConsumer(CodeCompleteConsumer *Value);\n\n  /// }\n  /// @name Frontend timer\n  /// {\n\n  bool hasFrontendTimer() const { return (bool)FrontendTimer; }\n\n  llvm::Timer &getFrontendTimer() const {\n    assert(FrontendTimer && \"Compiler instance has no frontend timer!\");\n    return *FrontendTimer;\n  }\n\n  /// }\n  /// @name Output Files\n  /// {\n\n  /// clearOutputFiles - Clear the output file list. The underlying output\n  /// streams must have been closed beforehand.\n  ///\n  /// \\param EraseFiles - If true, attempt to erase the files from disk.\n  void clearOutputFiles(bool EraseFiles);\n\n  /// }\n  /// @name Construction Utility Methods\n  /// {\n\n  /// Create the diagnostics engine using the invocation's diagnostic options\n  /// and replace any existing one with it.\n  ///\n  /// Note that this routine also replaces the diagnostic client,\n  /// allocating one if one is not provided.\n  ///\n  /// \\param Client If non-NULL, a diagnostic client that will be\n  /// attached to (and, then, owned by) the DiagnosticsEngine inside this AST\n  /// unit.\n  ///\n  /// \\param ShouldOwnClient If Client is non-NULL, specifies whether\n  /// the diagnostic object should take ownership of the client.\n  void createDiagnostics(DiagnosticConsumer *Client = nullptr,\n                         bool ShouldOwnClient = true);\n\n  /// Create a DiagnosticsEngine object with a the TextDiagnosticPrinter.\n  ///\n  /// If no diagnostic client is provided, this creates a\n  /// DiagnosticConsumer that is owned by the returned diagnostic\n  /// object, if using directly the caller is responsible for\n  /// releasing the returned DiagnosticsEngine's client eventually.\n  ///\n  /// \\param Opts - The diagnostic options; note that the created text\n  /// diagnostic object contains a reference to these options.\n  ///\n  /// \\param Client If non-NULL, a diagnostic client that will be\n  /// attached to (and, then, owned by) the returned DiagnosticsEngine\n  /// object.\n  ///\n  /// \\param CodeGenOpts If non-NULL, the code gen options in use, which may be\n  /// used by some diagnostics printers (for logging purposes only).\n  ///\n  /// \\return The new object on success, or null on failure.\n  static IntrusiveRefCntPtr<DiagnosticsEngine>\n  createDiagnostics(DiagnosticOptions *Opts,\n                    DiagnosticConsumer *Client = nullptr,\n                    bool ShouldOwnClient = true,\n                    const CodeGenOptions *CodeGenOpts = nullptr);\n\n  /// Create the file manager and replace any existing one with it.\n  ///\n  /// \\return The new file manager on success, or null on failure.\n  FileManager *\n  createFileManager(IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Create the source manager and replace any existing one with it.\n  void createSourceManager(FileManager &FileMgr);\n\n  /// Create the preprocessor, using the invocation, file, and source managers,\n  /// and replace any existing one with it.\n  void createPreprocessor(TranslationUnitKind TUKind);\n\n  std::string getSpecificModuleCachePath(StringRef ModuleHash);\n  std::string getSpecificModuleCachePath() {\n    return getSpecificModuleCachePath(getInvocation().getModuleHash());\n  }\n\n  /// Create the AST context.\n  void createASTContext();\n\n  /// Create an external AST source to read a PCH file and attach it to the AST\n  /// context.\n  void createPCHExternalASTSource(\n      StringRef Path, DisableValidationForModuleKind DisableValidation,\n      bool AllowPCHWithCompilerErrors, void *DeserializationListener,\n      bool OwnDeserializationListener);\n\n  /// Create an external AST source to read a PCH file.\n  ///\n  /// \\return - The new object on success, or null on failure.\n  static IntrusiveRefCntPtr<ASTReader> createPCHExternalASTSource(\n      StringRef Path, StringRef Sysroot,\n      DisableValidationForModuleKind DisableValidation,\n      bool AllowPCHWithCompilerErrors, Preprocessor &PP,\n      InMemoryModuleCache &ModuleCache, ASTContext &Context,\n      const PCHContainerReader &PCHContainerRdr,\n      ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n      ArrayRef<std::shared_ptr<DependencyCollector>> DependencyCollectors,\n      void *DeserializationListener, bool OwnDeserializationListener,\n      bool Preamble, bool UseGlobalModuleIndex);\n\n  /// Create a code completion consumer using the invocation; note that this\n  /// will cause the source manager to truncate the input source file at the\n  /// completion point.\n  void createCodeCompletionConsumer();\n\n  /// Create a code completion consumer to print code completion results, at\n  /// \\p Filename, \\p Line, and \\p Column, to the given output stream \\p OS.\n  static CodeCompleteConsumer *createCodeCompletionConsumer(\n      Preprocessor &PP, StringRef Filename, unsigned Line, unsigned Column,\n      const CodeCompleteOptions &Opts, raw_ostream &OS);\n\n  /// Create the Sema object to be used for parsing.\n  void createSema(TranslationUnitKind TUKind,\n                  CodeCompleteConsumer *CompletionConsumer);\n\n  /// Create the frontend timer and replace any existing one with it.\n  void createFrontendTimer();\n\n  /// Create the default output file (from the invocation's options) and add it\n  /// to the list of tracked output files.\n  ///\n  /// The files created by this are usually removed on signal, and, depending\n  /// on FrontendOptions, may also use a temporary file (that is, the data is\n  /// written to a temporary file which will atomically replace the target\n  /// output on success). If a client (like libclang) needs to disable\n  /// RemoveFileOnSignal, temporary files will be forced on.\n  ///\n  /// \\return - Null on error.\n  std::unique_ptr<raw_pwrite_stream>\n  createDefaultOutputFile(bool Binary = true, StringRef BaseInput = \"\",\n                          StringRef Extension = \"\",\n                          bool RemoveFileOnSignal = true,\n                          bool CreateMissingDirectories = false);\n\n  /// Create a new output file, optionally deriving the output path name, and\n  /// add it to the list of tracked output files.\n  ///\n  /// \\return - Null on error.\n  std::unique_ptr<raw_pwrite_stream>\n  createOutputFile(StringRef OutputPath, bool Binary, bool RemoveFileOnSignal,\n                   bool UseTemporary, bool CreateMissingDirectories = false);\n\nprivate:\n  /// Create a new output file and add it to the list of tracked output files.\n  ///\n  /// If \\p OutputPath is empty, then createOutputFile will derive an output\n  /// path location as \\p BaseInput, with any suffix removed, and \\p Extension\n  /// appended. If \\p OutputPath is not stdout and \\p UseTemporary\n  /// is true, createOutputFile will create a new temporary file that must be\n  /// renamed to \\p OutputPath in the end.\n  ///\n  /// \\param OutputPath - If given, the path to the output file.\n  /// \\param Binary - The mode to open the file in.\n  /// \\param RemoveFileOnSignal - Whether the file should be registered with\n  /// llvm::sys::RemoveFileOnSignal. Note that this is not safe for\n  /// multithreaded use, as the underlying signal mechanism is not reentrant\n  /// \\param UseTemporary - Create a new temporary file that must be renamed to\n  /// OutputPath in the end.\n  /// \\param CreateMissingDirectories - When \\p UseTemporary is true, create\n  /// missing directories in the output path.\n  Expected<std::unique_ptr<raw_pwrite_stream>>\n  createOutputFileImpl(StringRef OutputPath, bool Binary,\n                       bool RemoveFileOnSignal, bool UseTemporary,\n                       bool CreateMissingDirectories);\n\npublic:\n  std::unique_ptr<raw_pwrite_stream> createNullOutputFile();\n\n  /// }\n  /// @name Initialization Utility Methods\n  /// {\n\n  /// InitializeSourceManager - Initialize the source manager to set InputFile\n  /// as the main file.\n  ///\n  /// \\return True on success.\n  bool InitializeSourceManager(const FrontendInputFile &Input);\n\n  /// InitializeSourceManager - Initialize the source manager to set InputFile\n  /// as the main file.\n  ///\n  /// \\return True on success.\n  static bool InitializeSourceManager(const FrontendInputFile &Input,\n                                      DiagnosticsEngine &Diags,\n                                      FileManager &FileMgr,\n                                      SourceManager &SourceMgr);\n\n  /// }\n\n  void setOutputStream(std::unique_ptr<llvm::raw_pwrite_stream> OutStream) {\n    OutputStream = std::move(OutStream);\n  }\n\n  std::unique_ptr<llvm::raw_pwrite_stream> takeOutputStream() {\n    return std::move(OutputStream);\n  }\n\n  void createASTReader();\n\n  bool loadModuleFile(StringRef FileName);\n\nprivate:\n  /// Find a module, potentially compiling it, before reading its AST.  This is\n  /// the guts of loadModule.\n  ///\n  /// For prebuilt modules, the Module is not expected to exist in\n  /// HeaderSearch's ModuleMap.  If a ModuleFile by that name is in the\n  /// ModuleManager, then it will be loaded and looked up.\n  ///\n  /// For implicit modules, the Module is expected to already be in the\n  /// ModuleMap.  First attempt to load it from the given path on disk.  If that\n  /// fails, defer to compileModuleAndReadAST, which will first build and then\n  /// load it.\n  ModuleLoadResult findOrCompileModuleAndReadAST(StringRef ModuleName,\n                                                 SourceLocation ImportLoc,\n                                                 SourceLocation ModuleNameLoc,\n                                                 bool IsInclusionDirective);\n\npublic:\n  ModuleLoadResult loadModule(SourceLocation ImportLoc, ModuleIdPath Path,\n                              Module::NameVisibilityKind Visibility,\n                              bool IsInclusionDirective) override;\n\n  void createModuleFromSource(SourceLocation ImportLoc, StringRef ModuleName,\n                              StringRef Source) override;\n\n  void makeModuleVisible(Module *Mod, Module::NameVisibilityKind Visibility,\n                         SourceLocation ImportLoc) override;\n\n  bool hadModuleLoaderFatalFailure() const {\n    return ModuleLoader::HadFatalFailure;\n  }\n\n  GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc) override;\n\n  bool lookupMissingImports(StringRef Name, SourceLocation TriggerLoc) override;\n\n  void addDependencyCollector(std::shared_ptr<DependencyCollector> Listener) {\n    DependencyCollectors.push_back(std::move(Listener));\n  }\n\n  void setExternalSemaSource(IntrusiveRefCntPtr<ExternalSemaSource> ESS);\n\n  InMemoryModuleCache &getModuleCache() const { return *ModuleCache; }\n};\n\n} // end namespace clang\n\n#endif\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h", "content": "//===- CompilerInvocation.h - Compiler Invocation Helper Data ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H\n#define LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H\n\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Frontend/DependencyOutputOptions.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"clang/Frontend/MigratorOptions.h\"\n#include \"clang/Frontend/PreprocessorOutputOptions.h\"\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include <memory>\n#include <string>\n\nnamespace llvm {\n\nclass Triple;\n\nnamespace opt {\n\nclass ArgList;\n\n} // namespace opt\n\nnamespace vfs {\n\nclass FileSystem;\n\n} // namespace vfs\n\n} // namespace llvm\n\nnamespace clang {\n\nclass DiagnosticsEngine;\nclass HeaderSearchOptions;\nclass PreprocessorOptions;\nclass TargetOptions;\n\n/// Fill out Opts based on the options given in Args.\n///\n/// Args must have been created from the OptTable returned by\n/// createCC1OptTable().\n///\n/// When errors are encountered, return false and, if Diags is non-null,\n/// report the error(s).\nbool ParseDiagnosticArgs(DiagnosticOptions &Opts, llvm::opt::ArgList &Args,\n                         DiagnosticsEngine *Diags = nullptr,\n                         bool DefaultDiagColor = true);\n\nclass CompilerInvocationBase {\npublic:\n  /// Options controlling the language variant.\n  std::shared_ptr<LangOptions> LangOpts;\n\n  /// Options controlling the target.\n  std::shared_ptr<TargetOptions> TargetOpts;\n\n  /// Options controlling the diagnostic engine.\n  IntrusiveRefCntPtr<DiagnosticOptions> DiagnosticOpts;\n\n  /// Options controlling the \\#include directive.\n  std::shared_ptr<HeaderSearchOptions> HeaderSearchOpts;\n\n  /// Options controlling the preprocessor (aside from \\#include handling).\n  std::shared_ptr<PreprocessorOptions> PreprocessorOpts;\n\n  CompilerInvocationBase();\n  CompilerInvocationBase(const CompilerInvocationBase &X);\n  CompilerInvocationBase &operator=(const CompilerInvocationBase &) = delete;\n  ~CompilerInvocationBase();\n\n  LangOptions *getLangOpts() { return LangOpts.get(); }\n  const LangOptions *getLangOpts() const { return LangOpts.get(); }\n\n  TargetOptions &getTargetOpts() { return *TargetOpts.get(); }\n  const TargetOptions &getTargetOpts() const { return *TargetOpts.get(); }\n\n  DiagnosticOptions &getDiagnosticOpts() const { return *DiagnosticOpts; }\n\n  HeaderSearchOptions &getHeaderSearchOpts() { return *HeaderSearchOpts; }\n\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    return *HeaderSearchOpts;\n  }\n\n  std::shared_ptr<HeaderSearchOptions> getHeaderSearchOptsPtr() const {\n    return HeaderSearchOpts;\n  }\n\n  std::shared_ptr<PreprocessorOptions> getPreprocessorOptsPtr() {\n    return PreprocessorOpts;\n  }\n\n  PreprocessorOptions &getPreprocessorOpts() { return *PreprocessorOpts; }\n\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    return *PreprocessorOpts;\n  }\n};\n\n/// Helper class for holding the data necessary to invoke the compiler.\n///\n/// This class is designed to represent an abstract \"invocation\" of the\n/// compiler, including data such as the include paths, the code generation\n/// options, the warning flags, and so on.\nclass CompilerInvocation : public CompilerInvocationBase {\n  /// Options controlling the static analyzer.\n  AnalyzerOptionsRef AnalyzerOpts;\n\n  MigratorOptions MigratorOpts;\n\n  /// Options controlling IRgen and the backend.\n  CodeGenOptions CodeGenOpts;\n\n  /// Options controlling dependency output.\n  DependencyOutputOptions DependencyOutputOpts;\n\n  /// Options controlling file system operations.\n  FileSystemOptions FileSystemOpts;\n\n  /// Options controlling the frontend itself.\n  FrontendOptions FrontendOpts;\n\n  /// Options controlling preprocessed output.\n  PreprocessorOutputOptions PreprocessorOutputOpts;\n\npublic:\n  CompilerInvocation() : AnalyzerOpts(new AnalyzerOptions()) {}\n\n  /// @name Utility Methods\n  /// @{\n\n  /// Create a compiler invocation from a list of input options.\n  /// \\returns true on success.\n  ///\n  /// \\returns false if an error was encountered while parsing the arguments\n  /// and attempts to recover and continue parsing the rest of the arguments.\n  /// The recovery is best-effort and only guarantees that \\p Res will end up in\n  /// one of the vaild-to-access (albeit arbitrary) states.\n  ///\n  /// \\param [out] Res - The resulting invocation.\n  /// \\param [in] CommandLineArgs - Array of argument strings, this must not\n  /// contain \"-cc1\".\n  static bool CreateFromArgs(CompilerInvocation &Res,\n                             ArrayRef<const char *> CommandLineArgs,\n                             DiagnosticsEngine &Diags,\n                             const char *Argv0 = nullptr);\n\n  /// Get the directory where the compiler headers\n  /// reside, relative to the compiler binary (found by the passed in\n  /// arguments).\n  ///\n  /// \\param Argv0 - The program path (from argv[0]), for finding the builtin\n  /// compiler path.\n  /// \\param MainAddr - The address of main (or some other function in the main\n  /// executable), for finding the builtin compiler path.\n  static std::string GetResourcesPath(const char *Argv0, void *MainAddr);\n\n  /// Set language defaults for the given input language and\n  /// language standard in the given LangOptions object.\n  ///\n  /// \\param Opts - The LangOptions object to set up.\n  /// \\param IK - The input language.\n  /// \\param T - The target triple.\n  /// \\param Includes - The affected list of included files.\n  /// \\param LangStd - The input language standard.\n  static void\n  setLangDefaults(LangOptions &Opts, InputKind IK, const llvm::Triple &T,\n                  std::vector<std::string> &Includes,\n                  LangStandard::Kind LangStd = LangStandard::lang_unspecified);\n\n  /// Retrieve a module hash string that is suitable for uniquely\n  /// identifying the conditions under which the module was built.\n  std::string getModuleHash() const;\n\n  using StringAllocator = llvm::function_ref<const char *(const llvm::Twine &)>;\n  /// Generate a cc1-compatible command line arguments from this instance.\n  ///\n  /// \\param [out] Args - The generated arguments. Note that the caller is\n  /// responsible for inserting the path to the clang executable and \"-cc1\" if\n  /// desired.\n  /// \\param SA - A function that given a Twine can allocate storage for a given\n  /// command line argument and return a pointer to the newly allocated string.\n  /// The returned pointer is what gets appended to Args.\n  void generateCC1CommandLine(llvm::SmallVectorImpl<const char *> &Args,\n                              StringAllocator SA) const;\n\n  /// @}\n  /// @name Option Subgroups\n  /// @{\n\n  AnalyzerOptionsRef getAnalyzerOpts() const { return AnalyzerOpts; }\n\n  MigratorOptions &getMigratorOpts() { return MigratorOpts; }\n  const MigratorOptions &getMigratorOpts() const { return MigratorOpts; }\n\n  CodeGenOptions &getCodeGenOpts() { return CodeGenOpts; }\n  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }\n\n  DependencyOutputOptions &getDependencyOutputOpts() {\n    return DependencyOutputOpts;\n  }\n\n  const DependencyOutputOptions &getDependencyOutputOpts() const {\n    return DependencyOutputOpts;\n  }\n\n  FileSystemOptions &getFileSystemOpts() { return FileSystemOpts; }\n\n  const FileSystemOptions &getFileSystemOpts() const {\n    return FileSystemOpts;\n  }\n\n  FrontendOptions &getFrontendOpts() { return FrontendOpts; }\n  const FrontendOptions &getFrontendOpts() const { return FrontendOpts; }\n\n  PreprocessorOutputOptions &getPreprocessorOutputOpts() {\n    return PreprocessorOutputOpts;\n  }\n\n  const PreprocessorOutputOptions &getPreprocessorOutputOpts() const {\n    return PreprocessorOutputOpts;\n  }\n\n  /// @}\n\nprivate:\n  static bool CreateFromArgsImpl(CompilerInvocation &Res,\n                                 ArrayRef<const char *> CommandLineArgs,\n                                 DiagnosticsEngine &Diags, const char *Argv0);\n\n  /// Generate command line options from DiagnosticOptions.\n  static void GenerateDiagnosticArgs(const DiagnosticOptions &Opts,\n                                     SmallVectorImpl<const char *> &Args,\n                                     StringAllocator SA, bool DefaultDiagColor);\n\n  /// Parse command line options that map to LangOptions.\n  static bool ParseLangArgs(LangOptions &Opts, llvm::opt::ArgList &Args,\n                            InputKind IK, const llvm::Triple &T,\n                            std::vector<std::string> &Includes,\n                            DiagnosticsEngine &Diags);\n\n  /// Generate command line options from LangOptions.\n  static void GenerateLangArgs(const LangOptions &Opts,\n                               SmallVectorImpl<const char *> &Args,\n                               StringAllocator SA, const llvm::Triple &T);\n\n  /// Parse command line options that map to CodeGenOptions.\n  static bool ParseCodeGenArgs(CodeGenOptions &Opts, llvm::opt::ArgList &Args,\n                               InputKind IK, DiagnosticsEngine &Diags,\n                               const llvm::Triple &T,\n                               const std::string &OutputFile,\n                               const LangOptions &LangOptsRef);\n\n  // Generate command line options from CodeGenOptions.\n  static void GenerateCodeGenArgs(const CodeGenOptions &Opts,\n                                  SmallVectorImpl<const char *> &Args,\n                                  StringAllocator SA, const llvm::Triple &T,\n                                  const std::string &OutputFile,\n                                  const LangOptions *LangOpts);\n};\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem>\ncreateVFSFromCompilerInvocation(const CompilerInvocation &CI,\n                                DiagnosticsEngine &Diags);\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem> createVFSFromCompilerInvocation(\n    const CompilerInvocation &CI, DiagnosticsEngine &Diags,\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h", "content": "//===--- DependencyOutputOptions.h ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_DEPENDENCYOUTPUTOPTIONS_H\n#define LLVM_CLANG_FRONTEND_DEPENDENCYOUTPUTOPTIONS_H\n\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// ShowIncludesDestination - Destination for /showIncludes output.\nenum class ShowIncludesDestination { None, Stdout, Stderr };\n\n/// DependencyOutputFormat - Format for the compiler dependency file.\nenum class DependencyOutputFormat { Make, NMake };\n\n/// ExtraDepKind - The kind of extra dependency file.\nenum ExtraDepKind {\n  EDK_SanitizeBlacklist,\n  EDK_ProfileList,\n  EDK_ModuleFile,\n  EDK_DepFileEntry,\n};\n\n/// DependencyOutputOptions - Options for controlling the compiler dependency\n/// file generation.\nclass DependencyOutputOptions {\npublic:\n  unsigned IncludeSystemHeaders : 1; ///< Include system header dependencies.\n  unsigned ShowHeaderIncludes : 1;   ///< Show header inclusions (-H).\n  unsigned UsePhonyTargets : 1;      ///< Include phony targets for each\n                                     /// dependency, which can avoid some 'make'\n                                     /// problems.\n  unsigned AddMissingHeaderDeps : 1; ///< Add missing headers to dependency list\n  unsigned IncludeModuleFiles : 1; ///< Include module file dependencies.\n\n  /// Destination of cl.exe style /showIncludes info.\n  ShowIncludesDestination ShowIncludesDest = ShowIncludesDestination::None;\n\n  /// The format for the dependency file.\n  DependencyOutputFormat OutputFormat = DependencyOutputFormat::Make;\n\n  /// The file to write dependency output to.\n  std::string OutputFile;\n\n  /// The file to write header include output to. This is orthogonal to\n  /// ShowHeaderIncludes (-H) and will include headers mentioned in the\n  /// predefines buffer. If the output file is \"-\", output will be sent to\n  /// stderr.\n  std::string HeaderIncludeOutputFile;\n\n  /// A list of names to use as the targets in the dependency file; this list\n  /// must contain at least one entry.\n  std::vector<std::string> Targets;\n\n  /// A list of extra dependencies (filename and kind) to be used for every\n  /// target.\n  std::vector<std::pair<std::string, ExtraDepKind>> ExtraDeps;\n\n  /// In /showIncludes mode, pretend the main TU is a header with this name.\n  std::string ShowIncludesPretendHeader;\n\n  /// The file to write GraphViz-formatted header dependencies to.\n  std::string DOTOutputFile;\n\n  /// The directory to copy module dependencies to when collecting them.\n  std::string ModuleDependencyOutputDir;\n\npublic:\n  DependencyOutputOptions()\n      : IncludeSystemHeaders(0), ShowHeaderIncludes(0), UsePhonyTargets(0),\n        AddMissingHeaderDeps(0), IncludeModuleFiles(0) {}\n};\n\n}  // end namespace clang\n\n#endif\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "content": "//===-- FrontendAction.h - Generic Frontend Action Interface ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the clang::FrontendAction interface and various convenience\n/// abstract classes (clang::ASTFrontendAction, clang::PluginASTAction,\n/// clang::PreprocessorFrontendAction, and clang::WrapperFrontendAction)\n/// derived from it.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_FRONTENDACTION_H\n#define LLVM_CLANG_FRONTEND_FRONTENDACTION_H\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Frontend/ASTUnit.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nclass ASTMergeAction;\nclass CompilerInstance;\n\n/// Abstract base class for actions which can be performed by the frontend.\nclass FrontendAction {\n  FrontendInputFile CurrentInput;\n  std::unique_ptr<ASTUnit> CurrentASTUnit;\n  CompilerInstance *Instance;\n  friend class ASTMergeAction;\n  friend class WrapperFrontendAction;\n\nprivate:\n  std::unique_ptr<ASTConsumer> CreateWrappedASTConsumer(CompilerInstance &CI,\n                                                        StringRef InFile);\n\nprotected:\n  /// @name Implementation Action Interface\n  /// @{\n\n  /// Prepare to execute the action on the given CompilerInstance.\n  ///\n  /// This is called before executing the action on any inputs, and can modify\n  /// the configuration as needed (including adjusting the input list).\n  virtual bool PrepareToExecuteAction(CompilerInstance &CI) { return true; }\n\n  /// Create the AST consumer object for this action, if supported.\n  ///\n  /// This routine is called as part of BeginSourceFile(), which will\n  /// fail if the AST consumer cannot be created. This will not be called if the\n  /// action has indicated that it only uses the preprocessor.\n  ///\n  /// \\param CI - The current compiler instance, provided as a convenience, see\n  /// getCompilerInstance().\n  ///\n  /// \\param InFile - The current input file, provided as a convenience, see\n  /// getCurrentFile().\n  ///\n  /// \\return The new AST consumer, or null on failure.\n  virtual std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                         StringRef InFile) = 0;\n\n  /// Callback before starting processing a single input, giving the\n  /// opportunity to modify the CompilerInvocation or do some other action\n  /// before BeginSourceFileAction is called.\n  ///\n  /// \\return True on success; on failure BeginSourceFileAction(),\n  /// ExecuteAction() and EndSourceFileAction() will not be called.\n  virtual bool BeginInvocation(CompilerInstance &CI) { return true; }\n\n  /// Callback at the start of processing a single input.\n  ///\n  /// \\return True on success; on failure ExecutionAction() and\n  /// EndSourceFileAction() will not be called.\n  virtual bool BeginSourceFileAction(CompilerInstance &CI) {\n    return true;\n  }\n\n  /// Callback to run the program action, using the initialized\n  /// compiler instance.\n  ///\n  /// This is guaranteed to only be called between BeginSourceFileAction()\n  /// and EndSourceFileAction().\n  virtual void ExecuteAction() = 0;\n\n  /// Callback at the end of processing a single input.\n  ///\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual void EndSourceFileAction() {}\n\n  /// Callback at the end of processing a single input, to determine\n  /// if the output files should be erased or not.\n  ///\n  /// By default it returns true if a compiler error occurred.\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual bool shouldEraseOutputFiles();\n\n  /// @}\n\npublic:\n  FrontendAction();\n  virtual ~FrontendAction();\n\n  /// @name Compiler Instance Access\n  /// @{\n\n  CompilerInstance &getCompilerInstance() const {\n    assert(Instance && \"Compiler instance not registered!\");\n    return *Instance;\n  }\n\n  void setCompilerInstance(CompilerInstance *Value) { Instance = Value; }\n\n  /// @}\n  /// @name Current File Information\n  /// @{\n\n  bool isCurrentFileAST() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return (bool)CurrentASTUnit;\n  }\n\n  const FrontendInputFile &getCurrentInput() const {\n    return CurrentInput;\n  }\n\n  StringRef getCurrentFile() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getFile();\n  }\n\n  StringRef getCurrentFileOrBufferName() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.isFile()\n               ? CurrentInput.getFile()\n               : CurrentInput.getBuffer().getBufferIdentifier();\n  }\n\n  InputKind getCurrentFileKind() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getKind();\n  }\n\n  ASTUnit &getCurrentASTUnit() const {\n    assert(CurrentASTUnit && \"No current AST unit!\");\n    return *CurrentASTUnit;\n  }\n\n  Module *getCurrentModule() const;\n\n  std::unique_ptr<ASTUnit> takeCurrentASTUnit() {\n    return std::move(CurrentASTUnit);\n  }\n\n  void setCurrentInput(const FrontendInputFile &CurrentInput,\n                       std::unique_ptr<ASTUnit> AST = nullptr);\n\n  /// @}\n  /// @name Supported Modes\n  /// @{\n\n  /// Is this action invoked on a model file?\n  ///\n  /// Model files are incomplete translation units that relies on type\n  /// information from another translation unit. Check ParseModelFileAction for\n  /// details.\n  virtual bool isModelParsingAction() const { return false; }\n\n  /// Does this action only use the preprocessor?\n  ///\n  /// If so no AST context will be created and this action will be invalid\n  /// with AST file inputs.\n  virtual bool usesPreprocessorOnly() const = 0;\n\n  /// For AST-based actions, the kind of translation unit we're handling.\n  virtual TranslationUnitKind getTranslationUnitKind() { return TU_Complete; }\n\n  /// Does this action support use with PCH?\n  virtual bool hasPCHSupport() const { return true; }\n\n  /// Does this action support use with AST files?\n  virtual bool hasASTFileSupport() const { return true; }\n\n  /// Does this action support use with IR files?\n  virtual bool hasIRSupport() const { return false; }\n\n  /// Does this action support use with code completion?\n  virtual bool hasCodeCompletionSupport() const { return false; }\n\n  /// @}\n  /// @name Public Action Interface\n  /// @{\n\n  /// Prepare the action to execute on the given compiler instance.\n  bool PrepareToExecute(CompilerInstance &CI) {\n    return PrepareToExecuteAction(CI);\n  }\n\n  /// Prepare the action for processing the input file \\p Input.\n  ///\n  /// This is run after the options and frontend have been initialized,\n  /// but prior to executing any per-file processing.\n  ///\n  /// \\param CI - The compiler instance this action is being run from. The\n  /// action may store and use this object up until the matching EndSourceFile\n  /// action.\n  ///\n  /// \\param Input - The input filename and kind. Some input kinds are handled\n  /// specially, for example AST inputs, since the AST file itself contains\n  /// several objects which would normally be owned by the\n  /// CompilerInstance. When processing AST input files, these objects should\n  /// generally not be initialized in the CompilerInstance -- they will\n  /// automatically be shared with the AST file in between\n  /// BeginSourceFile() and EndSourceFile().\n  ///\n  /// \\return True on success; on failure the compilation of this file should\n  /// be aborted and neither Execute() nor EndSourceFile() should be called.\n  bool BeginSourceFile(CompilerInstance &CI, const FrontendInputFile &Input);\n\n  /// Set the source manager's main input file, and run the action.\n  llvm::Error Execute();\n\n  /// Perform any per-file post processing, deallocate per-file\n  /// objects, and run statistics and output file cleanup code.\n  void EndSourceFile();\n\n  /// @}\n};\n\n/// Abstract base class to use for AST consumer-based frontend actions.\nclass ASTFrontendAction : public FrontendAction {\nprotected:\n  /// Implement the ExecuteAction interface by running Sema on\n  /// the already-initialized AST consumer.\n  ///\n  /// This will also take care of instantiating a code completion consumer if\n  /// the user requested it and the action supports it.\n  void ExecuteAction() override;\n\npublic:\n  ASTFrontendAction() {}\n  bool usesPreprocessorOnly() const override { return false; }\n};\n\nclass PluginASTAction : public ASTFrontendAction {\n  virtual void anchor();\npublic:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override = 0;\n\n  /// Parse the given plugin command line arguments.\n  ///\n  /// \\param CI - The compiler instance, for use in reporting diagnostics.\n  /// \\return True if the parsing succeeded; otherwise the plugin will be\n  /// destroyed and no action run. The plugin is responsible for using the\n  /// CompilerInstance's Diagnostic object to report errors.\n  virtual bool ParseArgs(const CompilerInstance &CI,\n                         const std::vector<std::string> &arg) = 0;\n\n  enum ActionType {\n    Cmdline,             ///< Action is determined by the cc1 command-line\n    ReplaceAction,       ///< Replace the main action\n    AddBeforeMainAction, ///< Execute the action before the main action\n    AddAfterMainAction   ///< Execute the action after the main action\n  };\n  /// Get the action type for this plugin\n  ///\n  /// \\return The action type. If the type is Cmdline then by default the\n  /// plugin does nothing and what it does is determined by the cc1\n  /// command-line.\n  virtual ActionType getActionType() { return Cmdline; }\n};\n\n/// Abstract base class to use for preprocessor-based frontend actions.\nclass PreprocessorFrontendAction : public FrontendAction {\nprotected:\n  /// Provide a default implementation which returns aborts;\n  /// this method should never be called by FrontendAction clients.\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\npublic:\n  bool usesPreprocessorOnly() const override { return true; }\n};\n\n/// A frontend action which simply wraps some other runtime-specified\n/// frontend action.\n///\n/// Deriving from this class allows an action to inject custom logic around\n/// some existing action's behavior. It implements every virtual method in\n/// the FrontendAction interface by forwarding to the wrapped action.\nclass WrapperFrontendAction : public FrontendAction {\n  std::unique_ptr<FrontendAction> WrappedAction;\n\nprotected:\n  bool PrepareToExecuteAction(CompilerInstance &CI) override;\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n  bool BeginInvocation(CompilerInstance &CI) override;\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n  void ExecuteAction() override;\n  void EndSourceFileAction() override;\n  bool shouldEraseOutputFiles() override;\n\npublic:\n  /// Construct a WrapperFrontendAction from an existing action, taking\n  /// ownership of it.\n  WrapperFrontendAction(std::unique_ptr<FrontendAction> WrappedAction);\n\n  bool usesPreprocessorOnly() const override;\n  TranslationUnitKind getTranslationUnitKind() override;\n  bool hasPCHSupport() const override;\n  bool hasASTFileSupport() const override;\n  bool hasIRSupport() const override;\n  bool hasCodeCompletionSupport() const override;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "content": "//===- FrontendOptions.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n#define LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n\n#include \"clang/AST/ASTDumperUtils.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Frontend/CommandLineSourceLoc.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\n} // namespace llvm\n\nnamespace clang {\n\nnamespace frontend {\n\nenum ActionKind {\n  /// Parse ASTs and list Decl nodes.\n  ASTDeclList,\n\n  /// Parse ASTs and dump them.\n  ASTDump,\n\n  /// Parse ASTs and print them.\n  ASTPrint,\n\n  /// Parse ASTs and view them in Graphviz.\n  ASTView,\n\n  /// Dump the compiler configuration.\n  DumpCompilerOptions,\n\n  /// Dump out raw tokens.\n  DumpRawTokens,\n\n  /// Dump out preprocessed tokens.\n  DumpTokens,\n\n  /// Emit a .s file.\n  EmitAssembly,\n\n  /// Emit a .bc file.\n  EmitBC,\n\n  /// Translate input source into HTML.\n  EmitHTML,\n\n  /// Emit a .ll file.\n  EmitLLVM,\n\n  /// Generate LLVM IR, but do not emit anything.\n  EmitLLVMOnly,\n\n  /// Generate machine code, but don't emit anything.\n  EmitCodeGenOnly,\n\n  /// Emit a .o file.\n  EmitObj,\n\n  /// Parse and apply any fixits to the source.\n  FixIt,\n\n  /// Generate pre-compiled module from a module map.\n  GenerateModule,\n\n  /// Generate pre-compiled module from a C++ module interface file.\n  GenerateModuleInterface,\n\n  /// Generate pre-compiled module from a set of header files.\n  GenerateHeaderModule,\n\n  /// Generate pre-compiled header.\n  GeneratePCH,\n\n  /// Generate Interface Stub Files.\n  GenerateInterfaceStubs,\n\n  /// Only execute frontend initialization.\n  InitOnly,\n\n  /// Dump information about a module file.\n  ModuleFileInfo,\n\n  /// Load and verify that a PCH file is usable.\n  VerifyPCH,\n\n  /// Parse and perform semantic analysis.\n  ParseSyntaxOnly,\n\n  /// Run a plugin action, \\see ActionName.\n  PluginAction,\n\n  /// Print the \"preamble\" of the input file\n  PrintPreamble,\n\n  /// -E mode.\n  PrintPreprocessedInput,\n\n  /// Expand macros but not \\#includes.\n  RewriteMacros,\n\n  /// ObjC->C Rewriter.\n  RewriteObjC,\n\n  /// Rewriter playground\n  RewriteTest,\n\n  /// Run one or more source code analyses.\n  RunAnalysis,\n\n  /// Dump template instantiations\n  TemplightDump,\n\n  /// Run migrator.\n  MigrateSource,\n\n  /// Just lex, no output.\n  RunPreprocessorOnly,\n\n  /// Print the output of the dependency directives source minimizer.\n  PrintDependencyDirectivesSourceMinimizerOutput\n};\n\n} // namespace frontend\n\n/// The kind of a file that we've been handed as an input.\nclass InputKind {\nprivate:\n  Language Lang;\n  unsigned Fmt : 3;\n  unsigned Preprocessed : 1;\n\npublic:\n  /// The input file format.\n  enum Format {\n    Source,\n    ModuleMap,\n    Precompiled\n  };\n\n  constexpr InputKind(Language L = Language::Unknown, Format F = Source,\n                      bool PP = false)\n      : Lang(L), Fmt(F), Preprocessed(PP) {}\n\n  Language getLanguage() const { return static_cast<Language>(Lang); }\n  Format getFormat() const { return static_cast<Format>(Fmt); }\n  bool isPreprocessed() const { return Preprocessed; }\n\n  /// Is the input kind fully-unknown?\n  bool isUnknown() const { return Lang == Language::Unknown && Fmt == Source; }\n\n  /// Is the language of the input some dialect of Objective-C?\n  bool isObjectiveC() const {\n    return Lang == Language::ObjC || Lang == Language::ObjCXX;\n  }\n\n  InputKind getPreprocessed() const {\n    return InputKind(getLanguage(), getFormat(), true);\n  }\n\n  InputKind withFormat(Format F) const {\n    return InputKind(getLanguage(), F, isPreprocessed());\n  }\n};\n\n/// An input file for the front end.\nclass FrontendInputFile {\n  /// The file name, or \"-\" to read from standard input.\n  std::string File;\n\n  /// The input, if it comes from a buffer rather than a file. This object\n  /// does not own the buffer, and the caller is responsible for ensuring\n  /// that it outlives any users.\n  llvm::Optional<llvm::MemoryBufferRef> Buffer;\n\n  /// The kind of input, e.g., C source, AST file, LLVM IR.\n  InputKind Kind;\n\n  /// Whether we're dealing with a 'system' input (vs. a 'user' input).\n  bool IsSystem = false;\n\npublic:\n  FrontendInputFile() = default;\n  FrontendInputFile(StringRef File, InputKind Kind, bool IsSystem = false)\n      : File(File.str()), Kind(Kind), IsSystem(IsSystem) {}\n  FrontendInputFile(llvm::MemoryBufferRef Buffer, InputKind Kind,\n                    bool IsSystem = false)\n      : Buffer(Buffer), Kind(Kind), IsSystem(IsSystem) {}\n\n  InputKind getKind() const { return Kind; }\n  bool isSystem() const { return IsSystem; }\n\n  bool isEmpty() const { return File.empty() && Buffer == None; }\n  bool isFile() const { return !isBuffer(); }\n  bool isBuffer() const { return Buffer != None; }\n  bool isPreprocessed() const { return Kind.isPreprocessed(); }\n\n  StringRef getFile() const {\n    assert(isFile());\n    return File;\n  }\n\n  llvm::MemoryBufferRef getBuffer() const {\n    assert(isBuffer());\n    return *Buffer;\n  }\n};\n\n/// FrontendOptions - Options for controlling the behavior of the frontend.\nclass FrontendOptions {\npublic:\n  /// Disable memory freeing on exit.\n  unsigned DisableFree : 1;\n\n  /// When generating PCH files, instruct the AST writer to create relocatable\n  /// PCH files.\n  unsigned RelocatablePCH : 1;\n\n  /// Show the -help text.\n  unsigned ShowHelp : 1;\n\n  /// Show frontend performance metrics and statistics.\n  unsigned ShowStats : 1;\n\n  /// print the supported cpus for the current target\n  unsigned PrintSupportedCPUs : 1;\n\n  /// Output time trace profile.\n  unsigned TimeTrace : 1;\n\n  /// Show the -version text.\n  unsigned ShowVersion : 1;\n\n  /// Apply fixes even if there are unfixable errors.\n  unsigned FixWhatYouCan : 1;\n\n  /// Apply fixes only for warnings.\n  unsigned FixOnlyWarnings : 1;\n\n  /// Apply fixes and recompile.\n  unsigned FixAndRecompile : 1;\n\n  /// Apply fixes to temporary files.\n  unsigned FixToTemporaries : 1;\n\n  /// Emit ARC errors even if the migrator can fix them.\n  unsigned ARCMTMigrateEmitARCErrors : 1;\n\n  /// Skip over function bodies to speed up parsing in cases you do not need\n  /// them (e.g. with code completion).\n  unsigned SkipFunctionBodies : 1;\n\n  /// Whether we can use the global module index if available.\n  unsigned UseGlobalModuleIndex : 1;\n\n  /// Whether we can generate the global module index if needed.\n  unsigned GenerateGlobalModuleIndex : 1;\n\n  /// Whether we include declaration dumps in AST dumps.\n  unsigned ASTDumpDecls : 1;\n\n  /// Whether we deserialize all decls when forming AST dumps.\n  unsigned ASTDumpAll : 1;\n\n  /// Whether we include lookup table dumps in AST dumps.\n  unsigned ASTDumpLookups : 1;\n\n  /// Whether we include declaration type dumps in AST dumps.\n  unsigned ASTDumpDeclTypes : 1;\n\n  /// Whether we are performing an implicit module build.\n  unsigned BuildingImplicitModule : 1;\n\n  /// Whether we should embed all used files into the PCM file.\n  unsigned ModulesEmbedAllFiles : 1;\n\n  /// Whether timestamps should be written to the produced PCH file.\n  unsigned IncludeTimestamps : 1;\n\n  /// Should a temporary file be used during compilation.\n  unsigned UseTemporary : 1;\n\n  /// When using -emit-module, treat the modulemap as a system module.\n  unsigned IsSystemModule : 1;\n\n  /// Output (and read) PCM files regardless of compiler errors.\n  unsigned AllowPCMWithCompilerErrors : 1;\n\n  CodeCompleteOptions CodeCompleteOpts;\n\n  /// Specifies the output format of the AST.\n  ASTDumpOutputFormat ASTDumpFormat = ADOF_Default;\n\n  enum {\n    ARCMT_None,\n    ARCMT_Check,\n    ARCMT_Modify,\n    ARCMT_Migrate\n  } ARCMTAction = ARCMT_None;\n\n  enum {\n    ObjCMT_None = 0,\n\n    /// Enable migration to modern ObjC literals.\n    ObjCMT_Literals = 0x1,\n\n    /// Enable migration to modern ObjC subscripting.\n    ObjCMT_Subscripting = 0x2,\n\n    /// Enable migration to modern ObjC readonly property.\n    ObjCMT_ReadonlyProperty = 0x4,\n\n    /// Enable migration to modern ObjC readwrite property.\n    ObjCMT_ReadwriteProperty = 0x8,\n\n    /// Enable migration to modern ObjC property.\n    ObjCMT_Property = (ObjCMT_ReadonlyProperty | ObjCMT_ReadwriteProperty),\n\n    /// Enable annotation of ObjCMethods of all kinds.\n    ObjCMT_Annotation = 0x10,\n\n    /// Enable migration of ObjC methods to 'instancetype'.\n    ObjCMT_Instancetype = 0x20,\n\n    /// Enable migration to NS_ENUM/NS_OPTIONS macros.\n    ObjCMT_NsMacros = 0x40,\n\n    /// Enable migration to add conforming protocols.\n    ObjCMT_ProtocolConformance = 0x80,\n\n    /// prefer 'atomic' property over 'nonatomic'.\n    ObjCMT_AtomicProperty = 0x100,\n\n    /// annotate property with NS_RETURNS_INNER_POINTER\n    ObjCMT_ReturnsInnerPointerProperty = 0x200,\n\n    /// use NS_NONATOMIC_IOSONLY for property 'atomic' attribute\n    ObjCMT_NsAtomicIOSOnlyProperty = 0x400,\n\n    /// Enable inferring NS_DESIGNATED_INITIALIZER for ObjC methods.\n    ObjCMT_DesignatedInitializer = 0x800,\n\n    /// Enable converting setter/getter expressions to property-dot syntx.\n    ObjCMT_PropertyDotSyntax = 0x1000,\n\n    ObjCMT_MigrateDecls = (ObjCMT_ReadonlyProperty | ObjCMT_ReadwriteProperty |\n                           ObjCMT_Annotation | ObjCMT_Instancetype |\n                           ObjCMT_NsMacros | ObjCMT_ProtocolConformance |\n                           ObjCMT_NsAtomicIOSOnlyProperty |\n                           ObjCMT_DesignatedInitializer),\n    ObjCMT_MigrateAll = (ObjCMT_Literals | ObjCMT_Subscripting |\n                         ObjCMT_MigrateDecls | ObjCMT_PropertyDotSyntax)\n  };\n  unsigned ObjCMTAction = ObjCMT_None;\n  std::string ObjCMTWhiteListPath;\n\n  std::string MTMigrateDir;\n  std::string ARCMTMigrateReportOut;\n\n  /// The input kind, either specified via -x argument or deduced from the input\n  /// file name.\n  InputKind DashX;\n\n  /// The input files and their types.\n  SmallVector<FrontendInputFile, 0> Inputs;\n\n  /// When the input is a module map, the original module map file from which\n  /// that map was inferred, if any (for umbrella modules).\n  std::string OriginalModuleMap;\n\n  /// The output file, if any.\n  std::string OutputFile;\n\n  /// If given, the new suffix for fix-it rewritten files.\n  std::string FixItSuffix;\n\n  /// If given, filter dumped AST Decl nodes by this substring.\n  std::string ASTDumpFilter;\n\n  /// If given, enable code completion at the provided location.\n  ParsedSourceLocation CodeCompletionAt;\n\n  /// The frontend action to perform.\n  frontend::ActionKind ProgramAction = frontend::ParseSyntaxOnly;\n\n  /// The name of the action to run when using a plugin action.\n  std::string ActionName;\n\n  /// Args to pass to the plugins\n  std::unordered_map<std::string,std::vector<std::string>> PluginArgs;\n\n  /// The list of plugin actions to run in addition to the normal action.\n  std::vector<std::string> AddPluginActions;\n\n  /// The list of plugins to load.\n  std::vector<std::string> Plugins;\n\n  /// The list of module file extensions.\n  std::vector<std::shared_ptr<ModuleFileExtension>> ModuleFileExtensions;\n\n  /// The list of module map files to load before processing the input.\n  std::vector<std::string> ModuleMapFiles;\n\n  /// The list of additional prebuilt module files to load before\n  /// processing the input.\n  std::vector<std::string> ModuleFiles;\n\n  /// The list of files to embed into the compiled module file.\n  std::vector<std::string> ModulesEmbedFiles;\n\n  /// The list of AST files to merge.\n  std::vector<std::string> ASTMergeFiles;\n\n  /// A list of arguments to forward to LLVM's option processing; this\n  /// should only be used for debugging and experimental features.\n  std::vector<std::string> LLVMArgs;\n\n  /// File name of the file that will provide record layouts\n  /// (in the format produced by -fdump-record-layouts).\n  std::string OverrideRecordLayoutsFile;\n\n  /// Auxiliary triple for CUDA/HIP compilation.\n  std::string AuxTriple;\n\n  /// Auxiliary target CPU for CUDA/HIP compilation.\n  Optional<std::string> AuxTargetCPU;\n\n  /// Auxiliary target features for CUDA/HIP compilation.\n  Optional<std::vector<std::string>> AuxTargetFeatures;\n\n  /// Filename to write statistics to.\n  std::string StatsFile;\n\n  /// Minimum time granularity (in microseconds) traced by time profiler.\n  unsigned TimeTraceGranularity;\n\npublic:\n  FrontendOptions()\n      : DisableFree(false), RelocatablePCH(false), ShowHelp(false),\n        ShowStats(false), TimeTrace(false), ShowVersion(false),\n        FixWhatYouCan(false), FixOnlyWarnings(false), FixAndRecompile(false),\n        FixToTemporaries(false), ARCMTMigrateEmitARCErrors(false),\n        SkipFunctionBodies(false), UseGlobalModuleIndex(true),\n        GenerateGlobalModuleIndex(true), ASTDumpDecls(false),\n        ASTDumpLookups(false), BuildingImplicitModule(false),\n        ModulesEmbedAllFiles(false), IncludeTimestamps(true),\n        UseTemporary(true), AllowPCMWithCompilerErrors(false),\n        TimeTraceGranularity(500) {}\n\n  /// getInputKindForExtension - Return the appropriate input kind for a file\n  /// extension. For example, \"c\" would return Language::C.\n  ///\n  /// \\return The input kind for the extension, or Language::Unknown if the\n  /// extension is not recognized.\n  static InputKind getInputKindForExtension(StringRef Extension);\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/MigratorOptions.h", "content": "//===--- MigratorOptions.h - MigratorOptions Options ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This header contains the structures necessary for a front-end to specify\n// various migration analysis.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_MIGRATOROPTIONS_H\n#define LLVM_CLANG_FRONTEND_MIGRATOROPTIONS_H\n\nnamespace clang {\n\nclass MigratorOptions {\npublic:\n  unsigned NoNSAllocReallocError : 1;\n  unsigned NoFinalizeRemoval : 1;\n  MigratorOptions() {\n    NoNSAllocReallocError = 0;\n    NoFinalizeRemoval = 0;\n  }\n};\n\n}\n#endif\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "content": "//===--- PrecompiledPreamble.h - Build precompiled preambles ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Helper class to build precompiled preamble.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n#define LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cstddef>\n#include <memory>\n#include <system_error>\n#include <type_traits>\n\nnamespace llvm {\nclass MemoryBuffer;\nclass MemoryBufferRef;\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\nclass CompilerInstance;\nclass CompilerInvocation;\nclass Decl;\nclass DeclGroupRef;\nclass PCHContainerOperations;\n\n/// Runs lexer to compute suggested preamble bounds.\nPreambleBounds ComputePreambleBounds(const LangOptions &LangOpts,\n                                     const llvm::MemoryBufferRef &Buffer,\n                                     unsigned MaxLines);\n\nclass PreambleCallbacks;\n\n/// A class holding a PCH and all information to check whether it is valid to\n/// reuse the PCH for the subsequent runs. Use BuildPreamble to create PCH and\n/// CanReusePreamble + AddImplicitPreamble to make use of it.\nclass PrecompiledPreamble {\n  class PCHStorage;\n  struct PreambleFileHash;\n\npublic:\n  /// Try to build PrecompiledPreamble for \\p Invocation. See\n  /// BuildPreambleError for possible error codes.\n  ///\n  /// \\param Invocation Original CompilerInvocation with options to compile the\n  /// file.\n  ///\n  /// \\param MainFileBuffer Buffer with the contents of the main file.\n  ///\n  /// \\param Bounds Bounds of the preamble, result of calling\n  /// ComputePreambleBounds.\n  ///\n  /// \\param Diagnostics Diagnostics engine to be used while building the\n  /// preamble.\n  ///\n  /// \\param VFS An instance of vfs::FileSystem to be used for file\n  /// accesses.\n  ///\n  /// \\param PCHContainerOps An instance of PCHContainerOperations.\n  ///\n  /// \\param StoreInMemory Store PCH in memory. If false, PCH will be stored in\n  /// a temporary file.\n  ///\n  /// \\param Callbacks A set of callbacks to be executed when building\n  /// the preamble.\n  static llvm::ErrorOr<PrecompiledPreamble>\n  Build(const CompilerInvocation &Invocation,\n        const llvm::MemoryBuffer *MainFileBuffer, PreambleBounds Bounds,\n        DiagnosticsEngine &Diagnostics,\n        IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS,\n        std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n        bool StoreInMemory, PreambleCallbacks &Callbacks);\n\n  PrecompiledPreamble(PrecompiledPreamble &&) = default;\n  PrecompiledPreamble &operator=(PrecompiledPreamble &&) = default;\n\n  /// PreambleBounds used to build the preamble.\n  PreambleBounds getBounds() const;\n\n  /// Returns the size, in bytes, that preamble takes on disk or in memory.\n  /// For on-disk preambles returns 0 if filesystem operations fail. Intended to\n  /// be used for logging and debugging purposes only.\n  std::size_t getSize() const;\n\n  /// Returned string is not null-terminated.\n  llvm::StringRef getContents() const {\n    return {PreambleBytes.data(), PreambleBytes.size()};\n  }\n\n  /// Check whether PrecompiledPreamble can be reused for the new contents(\\p\n  /// MainFileBuffer) of the main file.\n  bool CanReuse(const CompilerInvocation &Invocation,\n                const llvm::MemoryBufferRef &MainFileBuffer,\n                PreambleBounds Bounds, llvm::vfs::FileSystem &VFS) const;\n\n  /// Changes options inside \\p CI to use PCH from this preamble. Also remaps\n  /// main file to \\p MainFileBuffer and updates \\p VFS to ensure the preamble\n  /// is accessible.\n  /// Requires that CanReuse() is true.\n  /// For in-memory preambles, PrecompiledPreamble instance continues to own the\n  /// MemoryBuffer with the Preamble after this method returns. The caller is\n  /// responsible for making sure the PrecompiledPreamble instance outlives the\n  /// compiler run and the AST that will be using the PCH.\n  void AddImplicitPreamble(CompilerInvocation &CI,\n                           IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                           llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Configure \\p CI to use this preamble.\n  /// Like AddImplicitPreamble, but doesn't assume CanReuse() is true.\n  /// If this preamble does not match the file, it may parse differently.\n  void OverridePreamble(CompilerInvocation &CI,\n                        IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                        llvm::MemoryBuffer *MainFileBuffer) const;\n\nprivate:\n  PrecompiledPreamble(PCHStorage Storage, std::vector<char> PreambleBytes,\n                      bool PreambleEndsAtStartOfLine,\n                      llvm::StringMap<PreambleFileHash> FilesInPreamble,\n                      llvm::StringSet<> MissingFiles);\n\n  /// A temp file that would be deleted on destructor call. If destructor is not\n  /// called for any reason, the file will be deleted at static objects'\n  /// destruction.\n  /// An assertion will fire if two TempPCHFiles are created with the same name,\n  /// so it's not intended to be used outside preamble-handling.\n  class TempPCHFile {\n  public:\n    // A main method used to construct TempPCHFile.\n    static llvm::ErrorOr<TempPCHFile> CreateNewPreamblePCHFile();\n\n  private:\n    TempPCHFile(std::string FilePath);\n\n  public:\n    TempPCHFile(TempPCHFile &&Other);\n    TempPCHFile &operator=(TempPCHFile &&Other);\n\n    TempPCHFile(const TempPCHFile &) = delete;\n    ~TempPCHFile();\n\n    /// A path where temporary file is stored.\n    llvm::StringRef getFilePath() const;\n\n  private:\n    void RemoveFileIfPresent();\n\n  private:\n    llvm::Optional<std::string> FilePath;\n  };\n\n  class InMemoryPreamble {\n  public:\n    std::string Data;\n  };\n\n  class PCHStorage {\n  public:\n    enum class Kind { Empty, InMemory, TempFile };\n\n    PCHStorage() = default;\n    PCHStorage(TempPCHFile File);\n    PCHStorage(InMemoryPreamble Memory);\n\n    PCHStorage(const PCHStorage &) = delete;\n    PCHStorage &operator=(const PCHStorage &) = delete;\n\n    PCHStorage(PCHStorage &&Other);\n    PCHStorage &operator=(PCHStorage &&Other);\n\n    ~PCHStorage();\n\n    Kind getKind() const;\n\n    TempPCHFile &asFile();\n    const TempPCHFile &asFile() const;\n\n    InMemoryPreamble &asMemory();\n    const InMemoryPreamble &asMemory() const;\n\n  private:\n    void destroy();\n    void setEmpty();\n\n  private:\n    Kind StorageKind = Kind::Empty;\n    llvm::AlignedCharArrayUnion<TempPCHFile, InMemoryPreamble> Storage = {};\n  };\n\n  /// Data used to determine if a file used in the preamble has been changed.\n  struct PreambleFileHash {\n    /// All files have size set.\n    off_t Size = 0;\n\n    /// Modification time is set for files that are on disk.  For memory\n    /// buffers it is zero.\n    time_t ModTime = 0;\n\n    /// Memory buffers have MD5 instead of modification time.  We don't\n    /// compute MD5 for on-disk files because we hope that modification time is\n    /// enough to tell if the file was changed.\n    llvm::MD5::MD5Result MD5 = {};\n\n    static PreambleFileHash createForFile(off_t Size, time_t ModTime);\n    static PreambleFileHash\n    createForMemoryBuffer(const llvm::MemoryBufferRef &Buffer);\n\n    friend bool operator==(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return LHS.Size == RHS.Size && LHS.ModTime == RHS.ModTime &&\n             LHS.MD5 == RHS.MD5;\n    }\n    friend bool operator!=(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return !(LHS == RHS);\n    }\n  };\n\n  /// Helper function to set up PCH for the preamble into \\p CI and \\p VFS to\n  /// with the specified \\p Bounds.\n  void configurePreamble(PreambleBounds Bounds, CompilerInvocation &CI,\n                         IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                         llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Sets up the PreprocessorOptions and changes VFS, so that PCH stored in \\p\n  /// Storage is accessible to clang. This method is an implementation detail of\n  /// AddImplicitPreamble.\n  static void\n  setupPreambleStorage(const PCHStorage &Storage,\n                       PreprocessorOptions &PreprocessorOpts,\n                       IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS);\n\n  /// Manages the memory buffer or temporary file that stores the PCH.\n  PCHStorage Storage;\n  /// Keeps track of the files that were used when computing the\n  /// preamble, with both their buffer size and their modification time.\n  ///\n  /// If any of the files have changed from one compile to the next,\n  /// the preamble must be thrown away.\n  llvm::StringMap<PreambleFileHash> FilesInPreamble;\n  /// Files that were not found during preamble building. If any of these now\n  /// exist then the preamble should not be reused.\n  ///\n  /// Storing *all* the missing files that could invalidate the preamble would\n  /// make it too expensive to revalidate (when the include path has many\n  /// entries, each #include will miss half of them on average).\n  /// Instead, we track only files that could have satisfied an #include that\n  /// was ultimately not found.\n  llvm::StringSet<> MissingFiles;\n  /// The contents of the file that was used to precompile the preamble. Only\n  /// contains first PreambleBounds::Size bytes. Used to compare if the relevant\n  /// part of the file has not changed, so that preamble can be reused.\n  std::vector<char> PreambleBytes;\n  /// See PreambleBounds::PreambleEndsAtStartOfLine\n  bool PreambleEndsAtStartOfLine;\n};\n\n/// A set of callbacks to gather useful information while building a preamble.\nclass PreambleCallbacks {\npublic:\n  virtual ~PreambleCallbacks() = default;\n\n  /// Called before FrontendAction::BeginSourceFile.\n  /// Can be used to store references to various CompilerInstance fields\n  /// (e.g. SourceManager) that may be interesting to the consumers of other\n  /// callbacks.\n  virtual void BeforeExecute(CompilerInstance &CI);\n  /// Called after FrontendAction::Execute(), but before\n  /// FrontendAction::EndSourceFile(). Can be used to transfer ownership of\n  /// various CompilerInstance fields before they are destroyed.\n  virtual void AfterExecute(CompilerInstance &CI);\n  /// Called after PCH has been emitted. \\p Writer may be used to retrieve\n  /// information about AST, serialized in PCH.\n  virtual void AfterPCHEmitted(ASTWriter &Writer);\n  /// Called for each TopLevelDecl.\n  /// NOTE: To allow more flexibility a custom ASTConsumer could probably be\n  /// used instead, but having only this method allows a simpler API.\n  virtual void HandleTopLevelDecl(DeclGroupRef DG);\n  /// Creates wrapper class for PPCallbacks so we can also process information\n  /// about includes that are inside of a preamble\n  virtual std::unique_ptr<PPCallbacks> createPPCallbacks();\n  /// The returned CommentHandler will be added to the preprocessor if not null.\n  virtual CommentHandler *getCommentHandler();\n  /// Determines which function bodies are parsed, by default skips everything.\n  /// Only used if FrontendOpts::SkipFunctionBodies is true.\n  /// See ASTConsumer::shouldSkipFunctionBody.\n  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }\n};\n\nenum class BuildPreambleError {\n  CouldntCreateTempFile = 1,\n  CouldntCreateTargetInfo,\n  BeginSourceFileFailed,\n  CouldntEmitPCH,\n  BadInputs\n};\n\nclass BuildPreambleErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int condition) const override;\n};\n\nstd::error_code make_error_code(BuildPreambleError Error);\n} // namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::BuildPreambleError> : std::true_type {};\n} // namespace std\n\n#endif\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PreprocessorOutputOptions.h", "content": "//===--- PreprocessorOutputOptions.h ----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_PREPROCESSOROUTPUTOPTIONS_H\n#define LLVM_CLANG_FRONTEND_PREPROCESSOROUTPUTOPTIONS_H\n\nnamespace clang {\n\n/// PreprocessorOutputOptions - Options for controlling the C preprocessor\n/// output (e.g., -E).\nclass PreprocessorOutputOptions {\npublic:\n  unsigned ShowCPP : 1;            ///< Print normal preprocessed output.\n  unsigned ShowComments : 1;       ///< Show comments.\n  unsigned ShowLineMarkers : 1;    ///< Show \\#line markers.\n  unsigned UseLineDirectives : 1;   ///< Use \\#line instead of GCC-style \\# N.\n  unsigned ShowMacroComments : 1;  ///< Show comments, even in macros.\n  unsigned ShowMacros : 1;         ///< Print macro definitions.\n  unsigned ShowIncludeDirectives : 1;  ///< Print includes, imports etc. within preprocessed output.\n  unsigned RewriteIncludes : 1;    ///< Preprocess include directives only.\n  unsigned RewriteImports  : 1;    ///< Include contents of transitively-imported modules.\n\npublic:\n  PreprocessorOutputOptions() {\n    ShowCPP = 0;\n    ShowComments = 0;\n    ShowLineMarkers = 1;\n    UseLineDirectives = 0;\n    ShowMacroComments = 0;\n    ShowMacros = 0;\n    ShowIncludeDirectives = 0;\n    RewriteIncludes = 0;\n    RewriteImports = 0;\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearch.h", "content": "//===- HeaderSearch.h - Resolve Header File Locations -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the HeaderSearch interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_HEADERSEARCH_H\n#define LLVM_CLANG_LEX_HEADERSEARCH_H\n\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Lex/DirectoryLookup.h\"\n#include \"clang/Lex/HeaderMap.h\"\n#include \"clang/Lex/ModuleMap.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass DiagnosticsEngine;\nclass DirectoryEntry;\nclass ExternalPreprocessorSource;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearchOptions;\nclass IdentifierInfo;\nclass LangOptions;\nclass Module;\nclass Preprocessor;\nclass TargetInfo;\n\n/// The preprocessor keeps track of this information for each\n/// file that is \\#included.\nstruct HeaderFileInfo {\n  /// True if this is a \\#import'd or \\#pragma once file.\n  unsigned isImport : 1;\n\n  /// True if this is a \\#pragma once file.\n  unsigned isPragmaOnce : 1;\n\n  /// Keep track of whether this is a system header, and if so,\n  /// whether it is C++ clean or not.  This can be set by the include paths or\n  /// by \\#pragma gcc system_header.  This is an instance of\n  /// SrcMgr::CharacteristicKind.\n  unsigned DirInfo : 3;\n\n  /// Whether this header file info was supplied by an external source,\n  /// and has not changed since.\n  unsigned External : 1;\n\n  /// Whether this header is part of a module.\n  unsigned isModuleHeader : 1;\n\n  /// Whether this header is part of the module that we are building.\n  unsigned isCompilingModuleHeader : 1;\n\n  /// Whether this structure is considered to already have been\n  /// \"resolved\", meaning that it was loaded from the external source.\n  unsigned Resolved : 1;\n\n  /// Whether this is a header inside a framework that is currently\n  /// being built.\n  ///\n  /// When a framework is being built, the headers have not yet been placed\n  /// into the appropriate framework subdirectories, and therefore are\n  /// provided via a header map. This bit indicates when this is one of\n  /// those framework headers.\n  unsigned IndexHeaderMapHeader : 1;\n\n  /// Whether this file has been looked up as a header.\n  unsigned IsValid : 1;\n\n  /// The number of times the file has been included already.\n  unsigned short NumIncludes = 0;\n\n  /// The ID number of the controlling macro.\n  ///\n  /// This ID number will be non-zero when there is a controlling\n  /// macro whose IdentifierInfo may not yet have been loaded from\n  /// external storage.\n  unsigned ControllingMacroID = 0;\n\n  /// If this file has a \\#ifndef XXX (or equivalent) guard that\n  /// protects the entire contents of the file, this is the identifier\n  /// for the macro that controls whether or not it has any effect.\n  ///\n  /// Note: Most clients should use getControllingMacro() to access\n  /// the controlling macro of this header, since\n  /// getControllingMacro() is able to load a controlling macro from\n  /// external storage.\n  const IdentifierInfo *ControllingMacro = nullptr;\n\n  /// If this header came from a framework include, this is the name\n  /// of the framework.\n  StringRef Framework;\n\n  HeaderFileInfo()\n      : isImport(false), isPragmaOnce(false), DirInfo(SrcMgr::C_User),\n        External(false), isModuleHeader(false), isCompilingModuleHeader(false),\n        Resolved(false), IndexHeaderMapHeader(false), IsValid(false)  {}\n\n  /// Retrieve the controlling macro for this header file, if\n  /// any.\n  const IdentifierInfo *\n  getControllingMacro(ExternalPreprocessorSource *External);\n\n  /// Determine whether this is a non-default header file info, e.g.,\n  /// it corresponds to an actual header we've included or tried to include.\n  bool isNonDefault() const {\n    return isImport || isPragmaOnce || NumIncludes || ControllingMacro ||\n      ControllingMacroID;\n  }\n};\n\n/// An external source of header file information, which may supply\n/// information about header files already included.\nclass ExternalHeaderFileInfoSource {\npublic:\n  virtual ~ExternalHeaderFileInfoSource();\n\n  /// Retrieve the header file information for the given file entry.\n  ///\n  /// \\returns Header file information for the given file entry, with the\n  /// \\c External bit set. If the file entry is not known, return a\n  /// default-constructed \\c HeaderFileInfo.\n  virtual HeaderFileInfo GetHeaderFileInfo(const FileEntry *FE) = 0;\n};\n\n/// This structure is used to record entries in our framework cache.\nstruct FrameworkCacheEntry {\n  /// The directory entry which should be used for the cached framework.\n  const DirectoryEntry *Directory;\n\n  /// Whether this framework has been \"user-specified\" to be treated as if it\n  /// were a system framework (even if it was found outside a system framework\n  /// directory).\n  bool IsUserSpecifiedSystemFramework;\n};\n\n/// Encapsulates the information needed to find the file referenced\n/// by a \\#include or \\#include_next, (sub-)framework lookup, etc.\nclass HeaderSearch {\n  friend class DirectoryLookup;\n\n  /// Header-search options used to initialize this header search.\n  std::shared_ptr<HeaderSearchOptions> HSOpts;\n\n  DiagnosticsEngine &Diags;\n  FileManager &FileMgr;\n\n  /// \\#include search path information.  Requests for \\#include \"x\" search the\n  /// directory of the \\#including file first, then each directory in SearchDirs\n  /// consecutively. Requests for <x> search the current dir first, then each\n  /// directory in SearchDirs, starting at AngledDirIdx, consecutively.  If\n  /// NoCurDirSearch is true, then the check for the file in the current\n  /// directory is suppressed.\n  std::vector<DirectoryLookup> SearchDirs;\n  unsigned AngledDirIdx = 0;\n  unsigned SystemDirIdx = 0;\n  bool NoCurDirSearch = false;\n\n  /// \\#include prefixes for which the 'system header' property is\n  /// overridden.\n  ///\n  /// For a \\#include \"x\" or \\#include \\<x> directive, the last string in this\n  /// list which is a prefix of 'x' determines whether the file is treated as\n  /// a system header.\n  std::vector<std::pair<std::string, bool>> SystemHeaderPrefixes;\n\n  /// The hash used for module cache paths.\n  std::string ModuleHash;\n\n  /// The path to the module cache.\n  std::string ModuleCachePath;\n\n  /// All of the preprocessor-specific data about files that are\n  /// included, indexed by the FileEntry's UID.\n  mutable std::vector<HeaderFileInfo> FileInfo;\n\n  /// Keeps track of each lookup performed by LookupFile.\n  struct LookupFileCacheInfo {\n    /// Starting index in SearchDirs that the cached search was performed from.\n    /// If there is a hit and this value doesn't match the current query, the\n    /// cache has to be ignored.\n    unsigned StartIdx = 0;\n\n    /// The entry in SearchDirs that satisfied the query.\n    unsigned HitIdx = 0;\n\n    /// This is non-null if the original filename was mapped to a framework\n    /// include via a headermap.\n    const char *MappedName = nullptr;\n\n    /// Default constructor -- Initialize all members with zero.\n    LookupFileCacheInfo() = default;\n\n    void reset(unsigned StartIdx) {\n      this->StartIdx = StartIdx;\n      this->MappedName = nullptr;\n    }\n  };\n  llvm::StringMap<LookupFileCacheInfo, llvm::BumpPtrAllocator> LookupFileCache;\n\n  /// Collection mapping a framework or subframework\n  /// name like \"Carbon\" to the Carbon.framework directory.\n  llvm::StringMap<FrameworkCacheEntry, llvm::BumpPtrAllocator> FrameworkMap;\n\n  /// Maps include file names (including the quotes or\n  /// angle brackets) to other include file names.  This is used to support the\n  /// include_alias pragma for Microsoft compatibility.\n  using IncludeAliasMap =\n      llvm::StringMap<std::string, llvm::BumpPtrAllocator>;\n  std::unique_ptr<IncludeAliasMap> IncludeAliases;\n\n  /// This is a mapping from FileEntry -> HeaderMap, uniquing headermaps.\n  std::vector<std::pair<const FileEntry *, std::unique_ptr<HeaderMap>>> HeaderMaps;\n\n  /// The mapping between modules and headers.\n  mutable ModuleMap ModMap;\n\n  /// Describes whether a given directory has a module map in it.\n  llvm::DenseMap<const DirectoryEntry *, bool> DirectoryHasModuleMap;\n\n  /// Set of module map files we've already loaded, and a flag indicating\n  /// whether they were valid or not.\n  llvm::DenseMap<const FileEntry *, bool> LoadedModuleMaps;\n\n  /// Uniqued set of framework names, which is used to track which\n  /// headers were included as framework headers.\n  llvm::StringSet<llvm::BumpPtrAllocator> FrameworkNames;\n\n  /// Entity used to resolve the identifier IDs of controlling\n  /// macros into IdentifierInfo pointers, and keep the identifire up to date,\n  /// as needed.\n  ExternalPreprocessorSource *ExternalLookup = nullptr;\n\n  /// Entity used to look up stored header file information.\n  ExternalHeaderFileInfoSource *ExternalSource = nullptr;\n\npublic:\n  HeaderSearch(std::shared_ptr<HeaderSearchOptions> HSOpts,\n               SourceManager &SourceMgr, DiagnosticsEngine &Diags,\n               const LangOptions &LangOpts, const TargetInfo *Target);\n  HeaderSearch(const HeaderSearch &) = delete;\n  HeaderSearch &operator=(const HeaderSearch &) = delete;\n\n  /// Retrieve the header-search options with which this header search\n  /// was initialized.\n  HeaderSearchOptions &getHeaderSearchOpts() const { return *HSOpts; }\n\n  FileManager &getFileMgr() const { return FileMgr; }\n\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  /// Interface for setting the file search paths.\n  void SetSearchPaths(const std::vector<DirectoryLookup> &dirs,\n                      unsigned angledDirIdx, unsigned systemDirIdx,\n                      bool noCurDirSearch) {\n    assert(angledDirIdx <= systemDirIdx && systemDirIdx <= dirs.size() &&\n        \"Directory indices are unordered\");\n    SearchDirs = dirs;\n    AngledDirIdx = angledDirIdx;\n    SystemDirIdx = systemDirIdx;\n    NoCurDirSearch = noCurDirSearch;\n    //LookupFileCache.clear();\n  }\n\n  /// Add an additional search path.\n  void AddSearchPath(const DirectoryLookup &dir, bool isAngled) {\n    unsigned idx = isAngled ? SystemDirIdx : AngledDirIdx;\n    SearchDirs.insert(SearchDirs.begin() + idx, dir);\n    if (!isAngled)\n      AngledDirIdx++;\n    SystemDirIdx++;\n  }\n\n  /// Set the list of system header prefixes.\n  void SetSystemHeaderPrefixes(ArrayRef<std::pair<std::string, bool>> P) {\n    SystemHeaderPrefixes.assign(P.begin(), P.end());\n  }\n\n  /// Checks whether the map exists or not.\n  bool HasIncludeAliasMap() const { return (bool)IncludeAliases; }\n\n  /// Map the source include name to the dest include name.\n  ///\n  /// The Source should include the angle brackets or quotes, the dest\n  /// should not.  This allows for distinction between <> and \"\" headers.\n  void AddIncludeAlias(StringRef Source, StringRef Dest) {\n    if (!IncludeAliases)\n      IncludeAliases.reset(new IncludeAliasMap);\n    (*IncludeAliases)[Source] = std::string(Dest);\n  }\n\n  /// Maps one header file name to a different header\n  /// file name, for use with the include_alias pragma.  Note that the source\n  /// file name should include the angle brackets or quotes.  Returns StringRef\n  /// as null if the header cannot be mapped.\n  StringRef MapHeaderToIncludeAlias(StringRef Source) {\n    assert(IncludeAliases && \"Trying to map headers when there's no map\");\n\n    // Do any filename replacements before anything else\n    IncludeAliasMap::const_iterator Iter = IncludeAliases->find(Source);\n    if (Iter != IncludeAliases->end())\n      return Iter->second;\n    return {};\n  }\n\n  /// Set the hash to use for module cache paths.\n  void setModuleHash(StringRef Hash) { ModuleHash = std::string(Hash); }\n\n  /// Set the path to the module cache.\n  void setModuleCachePath(StringRef CachePath) {\n    ModuleCachePath = std::string(CachePath);\n  }\n\n  /// Retrieve the module hash.\n  StringRef getModuleHash() const { return ModuleHash; }\n\n  /// Retrieve the path to the module cache.\n  StringRef getModuleCachePath() const { return ModuleCachePath; }\n\n  /// Consider modules when including files from this directory.\n  void setDirectoryHasModuleMap(const DirectoryEntry* Dir) {\n    DirectoryHasModuleMap[Dir] = true;\n  }\n\n  /// Forget everything we know about headers so far.\n  void ClearFileInfo() {\n    FileInfo.clear();\n  }\n\n  void SetExternalLookup(ExternalPreprocessorSource *EPS) {\n    ExternalLookup = EPS;\n  }\n\n  ExternalPreprocessorSource *getExternalLookup() const {\n    return ExternalLookup;\n  }\n\n  /// Set the external source of header information.\n  void SetExternalSource(ExternalHeaderFileInfoSource *ES) {\n    ExternalSource = ES;\n  }\n\n  /// Set the target information for the header search, if not\n  /// already known.\n  void setTarget(const TargetInfo &Target);\n\n  /// Given a \"foo\" or \\<foo> reference, look up the indicated file,\n  /// return null on failure.\n  ///\n  /// \\returns If successful, this returns 'UsedDir', the DirectoryLookup member\n  /// the file was found in, or null if not applicable.\n  ///\n  /// \\param IncludeLoc Used for diagnostics if valid.\n  ///\n  /// \\param isAngled indicates whether the file reference is a <> reference.\n  ///\n  /// \\param CurDir If non-null, the file was found in the specified directory\n  /// search location.  This is used to implement \\#include_next.\n  ///\n  /// \\param Includers Indicates where the \\#including file(s) are, in case\n  /// relative searches are needed. In reverse order of inclusion.\n  ///\n  /// \\param SearchPath If non-null, will be set to the search path relative\n  /// to which the file was found. If the include path is absolute, SearchPath\n  /// will be set to an empty string.\n  ///\n  /// \\param RelativePath If non-null, will be set to the path relative to\n  /// SearchPath at which the file was found. This only differs from the\n  /// Filename for framework includes.\n  ///\n  /// \\param SuggestedModule If non-null, and the file found is semantically\n  /// part of a known module, this will be set to the module that should\n  /// be imported instead of preprocessing/parsing the file found.\n  ///\n  /// \\param IsMapped If non-null, and the search involved header maps, set to\n  /// true.\n  ///\n  /// \\param IsFrameworkFound If non-null, will be set to true if a framework is\n  /// found in any of searched SearchDirs. Will be set to false if a framework\n  /// is found only through header maps. Doesn't guarantee the requested file is\n  /// found.\n  Optional<FileEntryRef> LookupFile(\n      StringRef Filename, SourceLocation IncludeLoc, bool isAngled,\n      const DirectoryLookup *FromDir, const DirectoryLookup *&CurDir,\n      ArrayRef<std::pair<const FileEntry *, const DirectoryEntry *>> Includers,\n      SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,\n      Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,\n      bool *IsMapped, bool *IsFrameworkFound, bool SkipCache = false,\n      bool BuildSystemModule = false);\n\n  /// Look up a subframework for the specified \\#include file.\n  ///\n  /// For example, if \\#include'ing <HIToolbox/HIToolbox.h> from\n  /// within \".../Carbon.framework/Headers/Carbon.h\", check to see if\n  /// HIToolbox is a subframework within Carbon.framework.  If so, return\n  /// the FileEntry for the designated file, otherwise return null.\n  Optional<FileEntryRef> LookupSubframeworkHeader(\n      StringRef Filename, const FileEntry *ContextFileEnt,\n      SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,\n      Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule);\n\n  /// Look up the specified framework name in our framework cache.\n  /// \\returns The DirectoryEntry it is in if we know, null otherwise.\n  FrameworkCacheEntry &LookupFrameworkCache(StringRef FWName) {\n    return FrameworkMap[FWName];\n  }\n\n  /// Mark the specified file as a target of a \\#include,\n  /// \\#include_next, or \\#import directive.\n  ///\n  /// \\return false if \\#including the file will have no effect or true\n  /// if we should include it.\n  bool ShouldEnterIncludeFile(Preprocessor &PP, const FileEntry *File,\n                              bool isImport, bool ModulesEnabled,\n                              Module *M);\n\n  /// Return whether the specified file is a normal header,\n  /// a system header, or a C++ friendly system header.\n  SrcMgr::CharacteristicKind getFileDirFlavor(const FileEntry *File) {\n    return (SrcMgr::CharacteristicKind)getFileInfo(File).DirInfo;\n  }\n\n  /// Mark the specified file as a \"once only\" file, e.g. due to\n  /// \\#pragma once.\n  void MarkFileIncludeOnce(const FileEntry *File) {\n    HeaderFileInfo &FI = getFileInfo(File);\n    FI.isImport = true;\n    FI.isPragmaOnce = true;\n  }\n\n  /// Mark the specified file as a system header, e.g. due to\n  /// \\#pragma GCC system_header.\n  void MarkFileSystemHeader(const FileEntry *File) {\n    getFileInfo(File).DirInfo = SrcMgr::C_System;\n  }\n\n  /// Mark the specified file as part of a module.\n  void MarkFileModuleHeader(const FileEntry *FE,\n                            ModuleMap::ModuleHeaderRole Role,\n                            bool isCompilingModuleHeader);\n\n  /// Increment the count for the number of times the specified\n  /// FileEntry has been entered.\n  void IncrementIncludeCount(const FileEntry *File) {\n    ++getFileInfo(File).NumIncludes;\n  }\n\n  /// Mark the specified file as having a controlling macro.\n  ///\n  /// This is used by the multiple-include optimization to eliminate\n  /// no-op \\#includes.\n  void SetFileControllingMacro(const FileEntry *File,\n                               const IdentifierInfo *ControllingMacro) {\n    getFileInfo(File).ControllingMacro = ControllingMacro;\n  }\n\n  /// Return true if this is the first time encountering this header.\n  bool FirstTimeLexingFile(const FileEntry *File) {\n    return getFileInfo(File).NumIncludes == 1;\n  }\n\n  /// Determine whether this file is intended to be safe from\n  /// multiple inclusions, e.g., it has \\#pragma once or a controlling\n  /// macro.\n  ///\n  /// This routine does not consider the effect of \\#import\n  bool isFileMultipleIncludeGuarded(const FileEntry *File);\n\n  /// Determine whether the given file is known to have ever been \\#imported\n  /// (or if it has been \\#included and we've encountered a \\#pragma once).\n  bool hasFileBeenImported(const FileEntry *File) {\n    const HeaderFileInfo *FI = getExistingFileInfo(File);\n    return FI && FI->isImport;\n  }\n\n  /// This method returns a HeaderMap for the specified\n  /// FileEntry, uniquing them through the 'HeaderMaps' datastructure.\n  const HeaderMap *CreateHeaderMap(const FileEntry *FE);\n\n  /// Get filenames for all registered header maps.\n  void getHeaderMapFileNames(SmallVectorImpl<std::string> &Names) const;\n\n  /// Retrieve the name of the cached module file that should be used\n  /// to load the given module.\n  ///\n  /// \\param Module The module whose module file name will be returned.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getCachedModuleFileName(Module *Module);\n\n  /// Retrieve the name of the prebuilt module file that should be used\n  /// to load a module with the given name.\n  ///\n  /// \\param ModuleName The module whose module file name will be returned.\n  ///\n  /// \\param FileMapOnly If true, then only look in the explicit module name\n  //  to file name map and skip the directory search.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getPrebuiltModuleFileName(StringRef ModuleName,\n                                        bool FileMapOnly = false);\n\n  /// Retrieve the name of the prebuilt module file that should be used\n  /// to load the given module.\n  ///\n  /// \\param Module The module whose module file name will be returned.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getPrebuiltImplicitModuleFileName(Module *Module);\n\n  /// Retrieve the name of the (to-be-)cached module file that should\n  /// be used to load a module with the given name.\n  ///\n  /// \\param ModuleName The module whose module file name will be returned.\n  ///\n  /// \\param ModuleMapPath A path that when combined with \\c ModuleName\n  /// uniquely identifies this module. See Module::ModuleMap.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getCachedModuleFileName(StringRef ModuleName,\n                                      StringRef ModuleMapPath);\n\n  /// Lookup a module Search for a module with the given name.\n  ///\n  /// \\param ModuleName The name of the module we're looking for.\n  ///\n  /// \\param AllowSearch Whether we are allowed to search in the various\n  /// search directories to produce a module definition. If not, this lookup\n  /// will only return an already-known module.\n  ///\n  /// \\param AllowExtraModuleMapSearch Whether we allow to search modulemaps\n  /// in subdirectories.\n  ///\n  /// \\returns The module with the given name.\n  Module *lookupModule(StringRef ModuleName, bool AllowSearch = true,\n                       bool AllowExtraModuleMapSearch = false);\n\n  /// Try to find a module map file in the given directory, returning\n  /// \\c nullptr if none is found.\n  const FileEntry *lookupModuleMapFile(const DirectoryEntry *Dir,\n                                       bool IsFramework);\n\n  /// Determine whether there is a module map that may map the header\n  /// with the given file name to a (sub)module.\n  /// Always returns false if modules are disabled.\n  ///\n  /// \\param Filename The name of the file.\n  ///\n  /// \\param Root The \"root\" directory, at which we should stop looking for\n  /// module maps.\n  ///\n  /// \\param IsSystem Whether the directories we're looking at are system\n  /// header directories.\n  bool hasModuleMap(StringRef Filename, const DirectoryEntry *Root,\n                    bool IsSystem);\n\n  /// Retrieve the module that corresponds to the given file, if any.\n  ///\n  /// \\param File The header that we wish to map to a module.\n  /// \\param AllowTextual Whether we want to find textual headers too.\n  ModuleMap::KnownHeader findModuleForHeader(const FileEntry *File,\n                                             bool AllowTextual = false) const;\n\n  /// Retrieve all the modules corresponding to the given file.\n  ///\n  /// \\ref findModuleForHeader should typically be used instead of this.\n  ArrayRef<ModuleMap::KnownHeader>\n  findAllModulesForHeader(const FileEntry *File) const;\n\n  /// Read the contents of the given module map file.\n  ///\n  /// \\param File The module map file.\n  /// \\param IsSystem Whether this file is in a system header directory.\n  /// \\param ID If the module map file is already mapped (perhaps as part of\n  ///        processing a preprocessed module), the ID of the file.\n  /// \\param Offset [inout] An offset within ID to start parsing. On exit,\n  ///        filled by the end of the parsed contents (either EOF or the\n  ///        location of an end-of-module-map pragma).\n  /// \\param OriginalModuleMapFile The original path to the module map file,\n  ///        used to resolve paths within the module (this is required when\n  ///        building the module from preprocessed source).\n  /// \\returns true if an error occurred, false otherwise.\n  bool loadModuleMapFile(const FileEntry *File, bool IsSystem,\n                         FileID ID = FileID(), unsigned *Offset = nullptr,\n                         StringRef OriginalModuleMapFile = StringRef());\n\n  /// Collect the set of all known, top-level modules.\n  ///\n  /// \\param Modules Will be filled with the set of known, top-level modules.\n  void collectAllModules(SmallVectorImpl<Module *> &Modules);\n\n  /// Load all known, top-level system modules.\n  void loadTopLevelSystemModules();\n\nprivate:\n  /// Lookup a module with the given module name and search-name.\n  ///\n  /// \\param ModuleName The name of the module we're looking for.\n  ///\n  /// \\param SearchName The \"search-name\" to derive filesystem paths from\n  /// when looking for the module map; this is usually equal to ModuleName,\n  /// but for compatibility with some buggy frameworks, additional attempts\n  /// may be made to find the module under a related-but-different search-name.\n  ///\n  /// \\param AllowExtraModuleMapSearch Whether we allow to search modulemaps\n  /// in subdirectories.\n  ///\n  /// \\returns The module named ModuleName.\n  Module *lookupModule(StringRef ModuleName, StringRef SearchName,\n                       bool AllowExtraModuleMapSearch = false);\n\n  /// Retrieve the name of the (to-be-)cached module file that should\n  /// be used to load a module with the given name.\n  ///\n  /// \\param ModuleName The module whose module file name will be returned.\n  ///\n  /// \\param ModuleMapPath A path that when combined with \\c ModuleName\n  /// uniquely identifies this module. See Module::ModuleMap.\n  ///\n  /// \\param CachePath A path to the module cache.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getCachedModuleFileNameImpl(StringRef ModuleName,\n                                          StringRef ModuleMapPath,\n                                          StringRef CachePath);\n\n  /// Retrieve a module with the given name, which may be part of the\n  /// given framework.\n  ///\n  /// \\param Name The name of the module to retrieve.\n  ///\n  /// \\param Dir The framework directory (e.g., ModuleName.framework).\n  ///\n  /// \\param IsSystem Whether the framework directory is part of the system\n  /// frameworks.\n  ///\n  /// \\returns The module, if found; otherwise, null.\n  Module *loadFrameworkModule(StringRef Name,\n                              const DirectoryEntry *Dir,\n                              bool IsSystem);\n\n  /// Load all of the module maps within the immediate subdirectories\n  /// of the given search directory.\n  void loadSubdirectoryModuleMaps(DirectoryLookup &SearchDir);\n\n  /// Find and suggest a usable module for the given file.\n  ///\n  /// \\return \\c true if the file can be used, \\c false if we are not permitted to\n  ///         find this file due to requirements from \\p RequestingModule.\n  bool findUsableModuleForHeader(const FileEntry *File,\n                                 const DirectoryEntry *Root,\n                                 Module *RequestingModule,\n                                 ModuleMap::KnownHeader *SuggestedModule,\n                                 bool IsSystemHeaderDir);\n\n  /// Find and suggest a usable module for the given file, which is part of\n  /// the specified framework.\n  ///\n  /// \\return \\c true if the file can be used, \\c false if we are not permitted to\n  ///         find this file due to requirements from \\p RequestingModule.\n  bool findUsableModuleForFrameworkHeader(\n      const FileEntry *File, StringRef FrameworkName, Module *RequestingModule,\n      ModuleMap::KnownHeader *SuggestedModule, bool IsSystemFramework);\n\n  /// Look up the file with the specified name and determine its owning\n  /// module.\n  Optional<FileEntryRef>\n  getFileAndSuggestModule(StringRef FileName, SourceLocation IncludeLoc,\n                          const DirectoryEntry *Dir, bool IsSystemHeaderDir,\n                          Module *RequestingModule,\n                          ModuleMap::KnownHeader *SuggestedModule);\n\npublic:\n  /// Retrieve the module map.\n  ModuleMap &getModuleMap() { return ModMap; }\n\n  /// Retrieve the module map.\n  const ModuleMap &getModuleMap() const { return ModMap; }\n\n  unsigned header_file_size() const { return FileInfo.size(); }\n\n  /// Return the HeaderFileInfo structure for the specified FileEntry,\n  /// in preparation for updating it in some way.\n  HeaderFileInfo &getFileInfo(const FileEntry *FE);\n\n  /// Return the HeaderFileInfo structure for the specified FileEntry,\n  /// if it has ever been filled in.\n  /// \\param WantExternal Whether the caller wants purely-external header file\n  ///        info (where \\p External is true).\n  const HeaderFileInfo *getExistingFileInfo(const FileEntry *FE,\n                                            bool WantExternal = true) const;\n\n  // Used by external tools\n  using search_dir_iterator = std::vector<DirectoryLookup>::const_iterator;\n\n  search_dir_iterator search_dir_begin() const { return SearchDirs.begin(); }\n  search_dir_iterator search_dir_end() const { return SearchDirs.end(); }\n  unsigned search_dir_size() const { return SearchDirs.size(); }\n\n  search_dir_iterator quoted_dir_begin() const {\n    return SearchDirs.begin();\n  }\n\n  search_dir_iterator quoted_dir_end() const {\n    return SearchDirs.begin() + AngledDirIdx;\n  }\n\n  search_dir_iterator angled_dir_begin() const {\n    return SearchDirs.begin() + AngledDirIdx;\n  }\n\n  search_dir_iterator angled_dir_end() const {\n    return SearchDirs.begin() + SystemDirIdx;\n  }\n\n  search_dir_iterator system_dir_begin() const {\n    return SearchDirs.begin() + SystemDirIdx;\n  }\n\n  search_dir_iterator system_dir_end() const { return SearchDirs.end(); }\n\n  /// Retrieve a uniqued framework name.\n  StringRef getUniqueFrameworkName(StringRef Framework);\n\n  /// Suggest a path by which the specified file could be found, for use in\n  /// diagnostics to suggest a #include. Returned path will only contain forward\n  /// slashes as separators. MainFile is the absolute path of the file that we\n  /// are generating the diagnostics for. It will try to shorten the path using\n  /// MainFile location, if none of the include search directories were prefix\n  /// of File.\n  ///\n  /// \\param IsSystem If non-null, filled in to indicate whether the suggested\n  ///        path is relative to a system header directory.\n  std::string suggestPathToFileForDiagnostics(const FileEntry *File,\n                                              llvm::StringRef MainFile,\n                                              bool *IsSystem = nullptr);\n\n  /// Suggest a path by which the specified file could be found, for use in\n  /// diagnostics to suggest a #include. Returned path will only contain forward\n  /// slashes as separators. MainFile is the absolute path of the file that we\n  /// are generating the diagnostics for. It will try to shorten the path using\n  /// MainFile location, if none of the include search directories were prefix\n  /// of File.\n  ///\n  /// \\param WorkingDir If non-empty, this will be prepended to search directory\n  /// paths that are relative.\n  std::string suggestPathToFileForDiagnostics(llvm::StringRef File,\n                                              llvm::StringRef WorkingDir,\n                                              llvm::StringRef MainFile,\n                                              bool *IsSystem = nullptr);\n\n  void PrintStats();\n\n  size_t getTotalMemory() const;\n\nprivate:\n  /// Describes what happened when we tried to load a module map file.\n  enum LoadModuleMapResult {\n    /// The module map file had already been loaded.\n    LMM_AlreadyLoaded,\n\n    /// The module map file was loaded by this invocation.\n    LMM_NewlyLoaded,\n\n    /// There is was directory with the given name.\n    LMM_NoDirectory,\n\n    /// There was either no module map file or the module map file was\n    /// invalid.\n    LMM_InvalidModuleMap\n  };\n\n  LoadModuleMapResult loadModuleMapFileImpl(const FileEntry *File,\n                                            bool IsSystem,\n                                            const DirectoryEntry *Dir,\n                                            FileID ID = FileID(),\n                                            unsigned *Offset = nullptr);\n\n  /// Try to load the module map file in the given directory.\n  ///\n  /// \\param DirName The name of the directory where we will look for a module\n  /// map file.\n  /// \\param IsSystem Whether this is a system header directory.\n  /// \\param IsFramework Whether this is a framework directory.\n  ///\n  /// \\returns The result of attempting to load the module map file from the\n  /// named directory.\n  LoadModuleMapResult loadModuleMapFile(StringRef DirName, bool IsSystem,\n                                        bool IsFramework);\n\n  /// Try to load the module map file in the given directory.\n  ///\n  /// \\param Dir The directory where we will look for a module map file.\n  /// \\param IsSystem Whether this is a system header directory.\n  /// \\param IsFramework Whether this is a framework directory.\n  ///\n  /// \\returns The result of attempting to load the module map file from the\n  /// named directory.\n  LoadModuleMapResult loadModuleMapFile(const DirectoryEntry *Dir,\n                                        bool IsSystem, bool IsFramework);\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_HEADERSEARCH_H\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h", "content": "//===- HeaderSearchOptions.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_HEADERSEARCHOPTIONS_H\n#define LLVM_CLANG_LEX_HEADERSEARCHOPTIONS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <map>\n\nnamespace clang {\n\nnamespace frontend {\n\n/// IncludeDirGroup - Identifies the group an include Entry belongs to,\n/// representing its relative positive in the search list.\n/// \\#include directives whose paths are enclosed by string quotes (\"\")\n/// start searching at the Quoted group (specified by '-iquote'),\n/// then search the Angled group, then the System group, etc.\nenum IncludeDirGroup {\n  /// '\\#include \"\"' paths, added by 'gcc -iquote'.\n  Quoted = 0,\n\n  /// Paths for '\\#include <>' added by '-I'.\n  Angled,\n\n  /// Like Angled, but marks header maps used when building frameworks.\n  IndexHeaderMap,\n\n  /// Like Angled, but marks system directories.\n  System,\n\n  /// Like System, but headers are implicitly wrapped in extern \"C\".\n  ExternCSystem,\n\n  /// Like System, but only used for C.\n  CSystem,\n\n  /// Like System, but only used for C++.\n  CXXSystem,\n\n  /// Like System, but only used for ObjC.\n  ObjCSystem,\n\n  /// Like System, but only used for ObjC++.\n  ObjCXXSystem,\n\n  /// Like System, but searched after the system directories.\n  After\n};\n\n} // namespace frontend\n\n/// HeaderSearchOptions - Helper class for storing options related to the\n/// initialization of the HeaderSearch object.\nclass HeaderSearchOptions {\npublic:\n  struct Entry {\n    std::string Path;\n    frontend::IncludeDirGroup Group;\n    unsigned IsFramework : 1;\n\n    /// IgnoreSysRoot - This is false if an absolute path should be treated\n    /// relative to the sysroot, or true if it should always be the absolute\n    /// path.\n    unsigned IgnoreSysRoot : 1;\n\n    Entry(StringRef path, frontend::IncludeDirGroup group, bool isFramework,\n          bool ignoreSysRoot)\n        : Path(path), Group(group), IsFramework(isFramework),\n          IgnoreSysRoot(ignoreSysRoot) {}\n  };\n\n  struct SystemHeaderPrefix {\n    /// A prefix to be matched against paths in \\#include directives.\n    std::string Prefix;\n\n    /// True if paths beginning with this prefix should be treated as system\n    /// headers.\n    bool IsSystemHeader;\n\n    SystemHeaderPrefix(StringRef Prefix, bool IsSystemHeader)\n        : Prefix(Prefix), IsSystemHeader(IsSystemHeader) {}\n  };\n\n  /// If non-empty, the directory to use as a \"virtual system root\" for include\n  /// paths.\n  std::string Sysroot;\n\n  /// User specified include entries.\n  std::vector<Entry> UserEntries;\n\n  /// User-specified system header prefixes.\n  std::vector<SystemHeaderPrefix> SystemHeaderPrefixes;\n\n  /// The directory which holds the compiler resource files (builtin includes,\n  /// etc.).\n  std::string ResourceDir;\n\n  /// The directory used for the module cache.\n  std::string ModuleCachePath;\n\n  /// The directory used for a user build.\n  std::string ModuleUserBuildPath;\n\n  /// The mapping of module names to prebuilt module files.\n  std::map<std::string, std::string, std::less<>> PrebuiltModuleFiles;\n\n  /// The directories used to load prebuilt module files.\n  std::vector<std::string> PrebuiltModulePaths;\n\n  /// The module/pch container format.\n  std::string ModuleFormat;\n\n  /// Whether we should disable the use of the hash string within the\n  /// module cache.\n  ///\n  /// Note: Only used for testing!\n  unsigned DisableModuleHash : 1;\n\n  /// Implicit module maps.  This option is enabld by default when\n  /// modules is enabled.\n  unsigned ImplicitModuleMaps : 1;\n\n  /// Set the 'home directory' of a module map file to the current\n  /// working directory (or the home directory of the module map file that\n  /// contained the 'extern module' directive importing this module map file\n  /// if any) rather than the directory containing the module map file.\n  //\n  /// The home directory is where we look for files named in the module map\n  /// file.\n  unsigned ModuleMapFileHomeIsCwd : 1;\n\n  /// Also search for prebuilt implicit modules in the prebuilt module cache\n  /// path.\n  unsigned EnablePrebuiltImplicitModules : 1;\n\n  /// The interval (in seconds) between pruning operations.\n  ///\n  /// This operation is expensive, because it requires Clang to walk through\n  /// the directory structure of the module cache, stat()'ing and removing\n  /// files.\n  ///\n  /// The default value is large, e.g., the operation runs once a week.\n  unsigned ModuleCachePruneInterval = 7 * 24 * 60 * 60;\n\n  /// The time (in seconds) after which an unused module file will be\n  /// considered unused and will, therefore, be pruned.\n  ///\n  /// When the module cache is pruned, any module file that has not been\n  /// accessed in this many seconds will be removed. The default value is\n  /// large, e.g., a month, to avoid forcing infrequently-used modules to be\n  /// regenerated often.\n  unsigned ModuleCachePruneAfter = 31 * 24 * 60 * 60;\n\n  /// The time in seconds when the build session started.\n  ///\n  /// This time is used by other optimizations in header search and module\n  /// loading.\n  uint64_t BuildSessionTimestamp = 0;\n\n  /// The set of macro names that should be ignored for the purposes\n  /// of computing the module hash.\n  llvm::SmallSetVector<llvm::CachedHashString, 16> ModulesIgnoreMacros;\n\n  /// The set of user-provided virtual filesystem overlay files.\n  std::vector<std::string> VFSOverlayFiles;\n\n  /// Include the compiler builtin includes.\n  unsigned UseBuiltinIncludes : 1;\n\n  /// Include the system standard include search directories.\n  unsigned UseStandardSystemIncludes : 1;\n\n  /// Include the system standard C++ library include search directories.\n  unsigned UseStandardCXXIncludes : 1;\n\n  /// Use libc++ instead of the default libstdc++.\n  unsigned UseLibcxx : 1;\n\n  /// Whether header search information should be output as for -v.\n  unsigned Verbose : 1;\n\n  /// If true, skip verifying input files used by modules if the\n  /// module was already verified during this build session (see\n  /// \\c BuildSessionTimestamp).\n  unsigned ModulesValidateOncePerBuildSession : 1;\n\n  /// Whether to validate system input files when a module is loaded.\n  unsigned ModulesValidateSystemHeaders : 1;\n\n  // Whether the content of input files should be hashed and used to\n  // validate consistency.\n  unsigned ValidateASTInputFilesContent : 1;\n\n  /// Whether the module includes debug information (-gmodules).\n  unsigned UseDebugInfo : 1;\n\n  unsigned ModulesValidateDiagnosticOptions : 1;\n\n  unsigned ModulesHashContent : 1;\n\n  /// Whether we should include all things that could impact the module in the\n  /// hash.\n  ///\n  /// This includes things like the full header search path, and enabled\n  /// diagnostics.\n  unsigned ModulesStrictContextHash : 1;\n\n  HeaderSearchOptions(StringRef _Sysroot = \"/\")\n      : Sysroot(_Sysroot), ModuleFormat(\"raw\"), DisableModuleHash(false),\n        ImplicitModuleMaps(false), ModuleMapFileHomeIsCwd(false),\n        EnablePrebuiltImplicitModules(false), UseBuiltinIncludes(true),\n        UseStandardSystemIncludes(true), UseStandardCXXIncludes(true),\n        UseLibcxx(false), Verbose(false),\n        ModulesValidateOncePerBuildSession(false),\n        ModulesValidateSystemHeaders(false),\n        ValidateASTInputFilesContent(false), UseDebugInfo(false),\n        ModulesValidateDiagnosticOptions(true), ModulesHashContent(false),\n        ModulesStrictContextHash(false) {}\n\n  /// AddPath - Add the \\p Path path to the specified \\p Group list.\n  void AddPath(StringRef Path, frontend::IncludeDirGroup Group,\n               bool IsFramework, bool IgnoreSysRoot) {\n    UserEntries.emplace_back(Path, Group, IsFramework, IgnoreSysRoot);\n  }\n\n  /// AddSystemHeaderPrefix - Override whether \\#include directives naming a\n  /// path starting with \\p Prefix should be considered as naming a system\n  /// header.\n  void AddSystemHeaderPrefix(StringRef Prefix, bool IsSystemHeader) {\n    SystemHeaderPrefixes.emplace_back(Prefix, IsSystemHeader);\n  }\n\n  void AddVFSOverlayFile(StringRef Name) {\n    VFSOverlayFiles.push_back(std::string(Name));\n  }\n\n  void AddPrebuiltModulePath(StringRef Name) {\n    PrebuiltModulePaths.push_back(std::string(Name));\n  }\n};\n\ninline llvm::hash_code hash_value(const HeaderSearchOptions::Entry &E) {\n  return llvm::hash_combine(E.Path, E.Group, E.IsFramework, E.IgnoreSysRoot);\n}\n\ninline llvm::hash_code\nhash_value(const HeaderSearchOptions::SystemHeaderPrefix &SHP) {\n  return llvm::hash_combine(SHP.Prefix, SHP.IsSystemHeader);\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_HEADERSEARCHOPTIONS_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleLoader.h", "content": "//===- ModuleLoader.h - Module Loader Interface -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ModuleLoader interface, which is responsible for\n//  loading named modules.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MODULELOADER_H\n#define LLVM_CLANG_LEX_MODULELOADER_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <utility>\n\nnamespace clang {\n\nclass GlobalModuleIndex;\nclass IdentifierInfo;\n\n/// A sequence of identifier/location pairs used to describe a particular\n/// module or submodule, e.g., std.vector.\nusing ModuleIdPath = ArrayRef<std::pair<IdentifierInfo *, SourceLocation>>;\n\n/// Describes the result of attempting to load a module.\nclass ModuleLoadResult {\npublic:\n  enum LoadResultKind {\n    // We either succeeded or failed to load the named module.\n    Normal,\n\n    // The module exists, but does not actually contain the named submodule.\n    // This should only happen if the named submodule was inferred from an\n    // umbrella directory, but not actually part of the umbrella header.\n    MissingExpected,\n\n    // The module exists but cannot be imported due to a configuration mismatch.\n    ConfigMismatch,\n\n    // We failed to load the module, but we shouldn't cache the failure.\n    OtherUncachedFailure,\n  };\n  llvm::PointerIntPair<Module *, 2, LoadResultKind> Storage;\n\n  ModuleLoadResult() = default;\n  ModuleLoadResult(Module *M) : Storage(M, Normal) {}\n  ModuleLoadResult(LoadResultKind Kind) : Storage(nullptr, Kind) {}\n\n  operator Module *() const { return Storage.getPointer(); }\n\n  /// Determines whether this is a normal return, whether or not loading the\n  /// module was successful.\n  bool isNormal() const { return Storage.getInt() == Normal; }\n\n  /// Determines whether the module, which failed to load, was\n  /// actually a submodule that we expected to see (based on implying the\n  /// submodule from header structure), but didn't materialize in the actual\n  /// module.\n  bool isMissingExpected() const { return Storage.getInt() == MissingExpected; }\n\n  /// Determines whether the module failed to load due to a configuration\n  /// mismatch with an explicitly-named .pcm file from the command line.\n  bool isConfigMismatch() const { return Storage.getInt() == ConfigMismatch; }\n};\n\n/// Abstract interface for a module loader.\n///\n/// This abstract interface describes a module loader, which is responsible\n/// for resolving a module name (e.g., \"std\") to an actual module file, and\n/// then loading that module.\nclass ModuleLoader {\n  // Building a module if true.\n  bool BuildingModule;\n\npublic:\n  explicit ModuleLoader(bool BuildingModule = false)\n      : BuildingModule(BuildingModule) {}\n\n  virtual ~ModuleLoader();\n\n  /// Returns true if this instance is building a module.\n  bool buildingModule() const {\n    return BuildingModule;\n  }\n\n  /// Flag indicating whether this instance is building a module.\n  void setBuildingModule(bool BuildingModuleFlag) {\n    BuildingModule = BuildingModuleFlag;\n  }\n\n  /// Attempt to load the given module.\n  ///\n  /// This routine attempts to load the module described by the given\n  /// parameters.  If there is a module cache, this may implicitly compile the\n  /// module before loading it.\n  ///\n  /// \\param ImportLoc The location of the 'import' keyword.\n  ///\n  /// \\param Path The identifiers (and their locations) of the module\n  /// \"path\", e.g., \"std.vector\" would be split into \"std\" and \"vector\".\n  ///\n  /// \\param Visibility The visibility provided for the names in the loaded\n  /// module.\n  ///\n  /// \\param IsInclusionDirective Indicates that this module is being loaded\n  /// implicitly, due to the presence of an inclusion directive. Otherwise,\n  /// it is being loaded due to an import declaration.\n  ///\n  /// \\returns If successful, returns the loaded module. Otherwise, returns\n  /// NULL to indicate that the module could not be loaded.\n  virtual ModuleLoadResult loadModule(SourceLocation ImportLoc,\n                                      ModuleIdPath Path,\n                                      Module::NameVisibilityKind Visibility,\n                                      bool IsInclusionDirective) = 0;\n\n  /// Attempt to create the given module from the specified source buffer.\n  /// Does not load the module or make any submodule visible; for that, use\n  /// loadModule and makeModuleVisible.\n  ///\n  /// \\param Loc The location at which to create the module.\n  /// \\param ModuleName The name of the module to create.\n  /// \\param Source The source of the module: a (preprocessed) module map.\n  virtual void createModuleFromSource(SourceLocation Loc, StringRef ModuleName,\n                                      StringRef Source) = 0;\n\n  /// Make the given module visible.\n  virtual void makeModuleVisible(Module *Mod,\n                                 Module::NameVisibilityKind Visibility,\n                                 SourceLocation ImportLoc) = 0;\n\n  /// Load, create, or return global module.\n  /// This function returns an existing global module index, if one\n  /// had already been loaded or created, or loads one if it\n  /// exists, or creates one if it doesn't exist.\n  /// Also, importantly, if the index doesn't cover all the modules\n  /// in the module map, it will be update to do so here, because\n  /// of its use in searching for needed module imports and\n  /// associated fixit messages.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns null if load failed.\n  virtual GlobalModuleIndex *loadGlobalModuleIndex(\n                                                SourceLocation TriggerLoc) = 0;\n\n  /// Check global module index for missing imports.\n  /// \\param Name The symbol name to look for.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns true if any modules with that symbol found.\n  virtual bool lookupMissingImports(StringRef Name,\n                                    SourceLocation TriggerLoc) = 0;\n\n  bool HadFatalFailure = false;\n};\n\n/// A module loader that doesn't know how to create or load modules.\nclass TrivialModuleLoader : public ModuleLoader {\npublic:\n  ModuleLoadResult loadModule(SourceLocation ImportLoc, ModuleIdPath Path,\n                              Module::NameVisibilityKind Visibility,\n                              bool IsInclusionDirective) override {\n    return {};\n  }\n\n  void createModuleFromSource(SourceLocation ImportLoc, StringRef ModuleName,\n                              StringRef Source) override {}\n\n  void makeModuleVisible(Module *Mod, Module::NameVisibilityKind Visibility,\n                         SourceLocation ImportLoc) override {}\n\n  GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc) override {\n    return nullptr;\n  }\n\n  bool lookupMissingImports(StringRef Name,\n                            SourceLocation TriggerLoc) override {\n    return false;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_MODULELOADER_H\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "content": "//===- ModuleMap.h - Describe the layout of modules -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ModuleMap interface, which describes the layout of a\n// module as it relates to headers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MODULEMAP_H\n#define LLVM_CLANG_LEX_MODULEMAP_H\n\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <ctime>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass DiagnosticsEngine;\nclass DirectoryEntry;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearch;\nclass SourceManager;\n\n/// A mechanism to observe the actions of the module map parser as it\n/// reads module map files.\nclass ModuleMapCallbacks {\n  virtual void anchor();\n\npublic:\n  virtual ~ModuleMapCallbacks() = default;\n\n  /// Called when a module map file has been read.\n  ///\n  /// \\param FileStart A SourceLocation referring to the start of the file's\n  /// contents.\n  /// \\param File The file itself.\n  /// \\param IsSystem Whether this is a module map from a system include path.\n  virtual void moduleMapFileRead(SourceLocation FileStart,\n                                 const FileEntry &File, bool IsSystem) {}\n\n  /// Called when a header is added during module map parsing.\n  ///\n  /// \\param Filename The header file itself.\n  virtual void moduleMapAddHeader(StringRef Filename) {}\n\n  /// Called when an umbrella header is added during module map parsing.\n  ///\n  /// \\param FileMgr FileManager instance\n  /// \\param Header The umbrella header to collect.\n  virtual void moduleMapAddUmbrellaHeader(FileManager *FileMgr,\n                                          const FileEntry *Header) {}\n};\n\nclass ModuleMap {\n  SourceManager &SourceMgr;\n  DiagnosticsEngine &Diags;\n  const LangOptions &LangOpts;\n  const TargetInfo *Target;\n  HeaderSearch &HeaderInfo;\n\n  llvm::SmallVector<std::unique_ptr<ModuleMapCallbacks>, 1> Callbacks;\n\n  /// The directory used for Clang-supplied, builtin include headers,\n  /// such as \"stdint.h\".\n  const DirectoryEntry *BuiltinIncludeDir = nullptr;\n\n  /// Language options used to parse the module map itself.\n  ///\n  /// These are always simple C language options.\n  LangOptions MMapLangOpts;\n\n  /// The module that the main source file is associated with (the module\n  /// named LangOpts::CurrentModule, if we've loaded it).\n  Module *SourceModule = nullptr;\n\n  /// Submodules of the current module that have not yet been attached to it.\n  /// (Ownership is transferred if/when we create an enclosing module.)\n  llvm::SmallVector<std::unique_ptr<Module>, 8> PendingSubmodules;\n\n  /// The top-level modules that are known.\n  llvm::StringMap<Module *> Modules;\n\n  /// Module loading cache that includes submodules, indexed by IdentifierInfo.\n  /// nullptr is stored for modules that are known to fail to load.\n  llvm::DenseMap<const IdentifierInfo *, Module *> CachedModuleLoads;\n\n  /// Shadow modules created while building this module map.\n  llvm::SmallVector<Module*, 2> ShadowModules;\n\n  /// The number of modules we have created in total.\n  unsigned NumCreatedModules = 0;\n\n  /// In case a module has a export_as entry, it might have a pending link\n  /// name to be determined if that module is imported.\n  llvm::StringMap<llvm::StringSet<>> PendingLinkAsModule;\n\npublic:\n  /// Use PendingLinkAsModule information to mark top level link names that\n  /// are going to be replaced by export_as aliases.\n  void resolveLinkAsDependencies(Module *Mod);\n\n  /// Make module to use export_as as the link dependency name if enough\n  /// information is available or add it to a pending list otherwise.\n  void addLinkAsDependency(Module *Mod);\n\n  /// Flags describing the role of a module header.\n  enum ModuleHeaderRole {\n    /// This header is normally included in the module.\n    NormalHeader  = 0x0,\n\n    /// This header is included but private.\n    PrivateHeader = 0x1,\n\n    /// This header is part of the module (for layering purposes) but\n    /// should be textually included.\n    TextualHeader = 0x2,\n\n    // Caution: Adding an enumerator needs other changes.\n    // Adjust the number of bits for KnownHeader::Storage.\n    // Adjust the bitfield HeaderFileInfo::HeaderRole size.\n    // Adjust the HeaderFileInfoTrait::ReadData streaming.\n    // Adjust the HeaderFileInfoTrait::EmitData streaming.\n    // Adjust ModuleMap::addHeader.\n  };\n\n  /// Convert a header kind to a role. Requires Kind to not be HK_Excluded.\n  static ModuleHeaderRole headerKindToRole(Module::HeaderKind Kind);\n\n  /// Convert a header role to a kind.\n  static Module::HeaderKind headerRoleToKind(ModuleHeaderRole Role);\n\n  /// A header that is known to reside within a given module,\n  /// whether it was included or excluded.\n  class KnownHeader {\n    llvm::PointerIntPair<Module *, 2, ModuleHeaderRole> Storage;\n\n  public:\n    KnownHeader() : Storage(nullptr, NormalHeader) {}\n    KnownHeader(Module *M, ModuleHeaderRole Role) : Storage(M, Role) {}\n\n    friend bool operator==(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage == B.Storage;\n    }\n    friend bool operator!=(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage != B.Storage;\n    }\n\n    /// Retrieve the module the header is stored in.\n    Module *getModule() const { return Storage.getPointer(); }\n\n    /// The role of this header within the module.\n    ModuleHeaderRole getRole() const { return Storage.getInt(); }\n\n    /// Whether this header is available in the module.\n    bool isAvailable() const {\n      return getModule()->isAvailable();\n    }\n\n    /// Whether this header is accessible from the specified module.\n    bool isAccessibleFrom(Module *M) const {\n      return !(getRole() & PrivateHeader) ||\n             (M && M->getTopLevelModule() == getModule()->getTopLevelModule());\n    }\n\n    // Whether this known header is valid (i.e., it has an\n    // associated module).\n    explicit operator bool() const {\n      return Storage.getPointer() != nullptr;\n    }\n  };\n\n  using AdditionalModMapsSet = llvm::SmallPtrSet<const FileEntry *, 1>;\n\nprivate:\n  friend class ModuleMapParser;\n\n  using HeadersMap =\n      llvm::DenseMap<const FileEntry *, SmallVector<KnownHeader, 1>>;\n\n  /// Mapping from each header to the module that owns the contents of\n  /// that header.\n  HeadersMap Headers;\n\n  /// Map from file sizes to modules with lazy header directives of that size.\n  mutable llvm::DenseMap<off_t, llvm::TinyPtrVector<Module*>> LazyHeadersBySize;\n\n  /// Map from mtimes to modules with lazy header directives with those mtimes.\n  mutable llvm::DenseMap<time_t, llvm::TinyPtrVector<Module*>>\n              LazyHeadersByModTime;\n\n  /// Mapping from directories with umbrella headers to the module\n  /// that is generated from the umbrella header.\n  ///\n  /// This mapping is used to map headers that haven't explicitly been named\n  /// in the module map over to the module that includes them via its umbrella\n  /// header.\n  llvm::DenseMap<const DirectoryEntry *, Module *> UmbrellaDirs;\n\n  /// A generation counter that is used to test whether modules of the\n  /// same name may shadow or are illegal redefinitions.\n  ///\n  /// Modules from earlier scopes may shadow modules from later ones.\n  /// Modules from the same scope may not have the same name.\n  unsigned CurrentModuleScopeID = 0;\n\n  llvm::DenseMap<Module *, unsigned> ModuleScopeIDs;\n\n  /// The set of attributes that can be attached to a module.\n  struct Attributes {\n    /// Whether this is a system module.\n    unsigned IsSystem : 1;\n\n    /// Whether this is an extern \"C\" module.\n    unsigned IsExternC : 1;\n\n    /// Whether this is an exhaustive set of configuration macros.\n    unsigned IsExhaustive : 1;\n\n    /// Whether files in this module can only include non-modular headers\n    /// and headers from used modules.\n    unsigned NoUndeclaredIncludes : 1;\n\n    Attributes()\n        : IsSystem(false), IsExternC(false), IsExhaustive(false),\n          NoUndeclaredIncludes(false) {}\n  };\n\n  /// A directory for which framework modules can be inferred.\n  struct InferredDirectory {\n    /// Whether to infer modules from this directory.\n    unsigned InferModules : 1;\n\n    /// The attributes to use for inferred modules.\n    Attributes Attrs;\n\n    /// If \\c InferModules is non-zero, the module map file that allowed\n    /// inferred modules.  Otherwise, nullptr.\n    const FileEntry *ModuleMapFile;\n\n    /// The names of modules that cannot be inferred within this\n    /// directory.\n    SmallVector<std::string, 2> ExcludedModules;\n\n    InferredDirectory() : InferModules(false) {}\n  };\n\n  /// A mapping from directories to information about inferring\n  /// framework modules from within those directories.\n  llvm::DenseMap<const DirectoryEntry *, InferredDirectory> InferredDirectories;\n\n  /// A mapping from an inferred module to the module map that allowed the\n  /// inference.\n  llvm::DenseMap<const Module *, const FileEntry *> InferredModuleAllowedBy;\n\n  llvm::DenseMap<const Module *, AdditionalModMapsSet> AdditionalModMaps;\n\n  /// Describes whether we haved parsed a particular file as a module\n  /// map.\n  llvm::DenseMap<const FileEntry *, bool> ParsedModuleMap;\n\n  /// Resolve the given export declaration into an actual export\n  /// declaration.\n  ///\n  /// \\param Mod The module in which we're resolving the export declaration.\n  ///\n  /// \\param Unresolved The export declaration to resolve.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// exports.\n  ///\n  /// \\returns The resolved export declaration, which will have a NULL pointer\n  /// if the export could not be resolved.\n  Module::ExportDecl\n  resolveExport(Module *Mod, const Module::UnresolvedExportDecl &Unresolved,\n                bool Complain) const;\n\n  /// Resolve the given module id to an actual module.\n  ///\n  /// \\param Id The module-id to resolve.\n  ///\n  /// \\param Mod The module in which we're resolving the module-id.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// module-ids.\n  ///\n  /// \\returns The resolved module, or null if the module-id could not be\n  /// resolved.\n  Module *resolveModuleId(const ModuleId &Id, Module *Mod, bool Complain) const;\n\n  /// Add an unresolved header to a module.\n  ///\n  /// \\param Mod The module in which we're adding the unresolved header\n  ///        directive.\n  /// \\param Header The unresolved header directive.\n  /// \\param NeedsFramework If Mod is not a framework but a missing header would\n  ///        be found in case Mod was, set it to true. False otherwise.\n  void addUnresolvedHeader(Module *Mod,\n                           Module::UnresolvedHeaderDirective Header,\n                           bool &NeedsFramework);\n\n  /// Look up the given header directive to find an actual header file.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param RelativePathName Filled in with the relative path name from the\n  ///        module to the resolved header.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  /// \\return The resolved file, if any.\n  Optional<FileEntryRef>\n  findHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n             SmallVectorImpl<char> &RelativePathName, bool &NeedsFramework);\n\n  /// Resolve the given header directive.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  void resolveHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n                     bool &NeedsFramework);\n\n  /// Attempt to resolve the specified header directive as naming a builtin\n  /// header.\n  /// \\return \\c true if a corresponding builtin header was found.\n  bool resolveAsBuiltinHeader(Module *M,\n                              const Module::UnresolvedHeaderDirective &Header);\n\n  /// Looks up the modules that \\p File corresponds to.\n  ///\n  /// If \\p File represents a builtin header within Clang's builtin include\n  /// directory, this also loads all of the module maps to see if it will get\n  /// associated with a specific module (e.g. in /usr/include).\n  HeadersMap::iterator findKnownHeader(const FileEntry *File);\n\n  /// Searches for a module whose umbrella directory contains \\p File.\n  ///\n  /// \\param File The header to search for.\n  ///\n  /// \\param IntermediateDirs On success, contains the set of directories\n  /// searched before finding \\p File.\n  KnownHeader findHeaderInUmbrellaDirs(const FileEntry *File,\n                    SmallVectorImpl<const DirectoryEntry *> &IntermediateDirs);\n\n  /// Given that \\p File is not in the Headers map, look it up within\n  /// umbrella directories and find or create a module for it.\n  KnownHeader findOrCreateModuleForHeaderInUmbrellaDir(const FileEntry *File);\n\n  /// A convenience method to determine if \\p File is (possibly nested)\n  /// in an umbrella directory.\n  bool isHeaderInUmbrellaDirs(const FileEntry *File) {\n    SmallVector<const DirectoryEntry *, 2> IntermediateDirs;\n    return static_cast<bool>(findHeaderInUmbrellaDirs(File, IntermediateDirs));\n  }\n\n  Module *inferFrameworkModule(const DirectoryEntry *FrameworkDir,\n                               Attributes Attrs, Module *Parent);\n\npublic:\n  /// Construct a new module map.\n  ///\n  /// \\param SourceMgr The source manager used to find module files and headers.\n  /// This source manager should be shared with the header-search mechanism,\n  /// since they will refer to the same headers.\n  ///\n  /// \\param Diags A diagnostic engine used for diagnostics.\n  ///\n  /// \\param LangOpts Language options for this translation unit.\n  ///\n  /// \\param Target The target for this translation unit.\n  ModuleMap(SourceManager &SourceMgr, DiagnosticsEngine &Diags,\n            const LangOptions &LangOpts, const TargetInfo *Target,\n            HeaderSearch &HeaderInfo);\n\n  /// Destroy the module map.\n  ~ModuleMap();\n\n  /// Set the target information.\n  void setTarget(const TargetInfo &Target);\n\n  /// Set the directory that contains Clang-supplied include\n  /// files, such as our stdarg.h or tgmath.h.\n  void setBuiltinIncludeDir(const DirectoryEntry *Dir) {\n    BuiltinIncludeDir = Dir;\n  }\n\n  /// Get the directory that contains Clang-supplied include files.\n  const DirectoryEntry *getBuiltinDir() const {\n    return BuiltinIncludeDir;\n  }\n\n  /// Is this a compiler builtin header?\n  static bool isBuiltinHeader(StringRef FileName);\n  bool isBuiltinHeader(const FileEntry *File);\n\n  /// Add a module map callback.\n  void addModuleMapCallbacks(std::unique_ptr<ModuleMapCallbacks> Callback) {\n    Callbacks.push_back(std::move(Callback));\n  }\n\n  /// Retrieve the module that owns the given header file, if any. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// \\param File The header file that is likely to be included.\n  ///\n  /// \\param AllowTextual If \\c true and \\p File is a textual header, return\n  /// its owning module. Otherwise, no KnownHeader will be returned if the\n  /// file is only known as a textual header.\n  ///\n  /// \\returns The module KnownHeader, which provides the module that owns the\n  /// given header file.  The KnownHeader is default constructed to indicate\n  /// that no module owns this header file.\n  KnownHeader findModuleForHeader(const FileEntry *File,\n                                  bool AllowTextual = false);\n\n  /// Retrieve all the modules that contain the given header file. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// Typically, \\ref findModuleForHeader should be used instead, as it picks\n  /// the preferred module for the header.\n  ArrayRef<KnownHeader> findAllModulesForHeader(const FileEntry *File);\n\n  /// Like \\ref findAllModulesForHeader, but do not attempt to infer module\n  /// ownership from umbrella headers if we've not already done so.\n  ArrayRef<KnownHeader>\n  findResolvedModulesForHeader(const FileEntry *File) const;\n\n  /// Resolve all lazy header directives for the specified file.\n  ///\n  /// This ensures that the HeaderFileInfo on HeaderSearch is up to date. This\n  /// is effectively internal, but is exposed so HeaderSearch can call it.\n  void resolveHeaderDirectives(const FileEntry *File) const;\n\n  /// Resolve all lazy header directives for the specified module.\n  void resolveHeaderDirectives(Module *Mod) const;\n\n  /// Reports errors if a module must not include a specific file.\n  ///\n  /// \\param RequestingModule The module including a file.\n  ///\n  /// \\param RequestingModuleIsModuleInterface \\c true if the inclusion is in\n  ///        the interface of RequestingModule, \\c false if it's in the\n  ///        implementation of RequestingModule. Value is ignored and\n  ///        meaningless if RequestingModule is nullptr.\n  ///\n  /// \\param FilenameLoc The location of the inclusion's filename.\n  ///\n  /// \\param Filename The included filename as written.\n  ///\n  /// \\param File The included file.\n  void diagnoseHeaderInclusion(Module *RequestingModule,\n                               bool RequestingModuleIsModuleInterface,\n                               SourceLocation FilenameLoc, StringRef Filename,\n                               const FileEntry *File);\n\n  /// Determine whether the given header is part of a module\n  /// marked 'unavailable'.\n  bool isHeaderInUnavailableModule(const FileEntry *Header) const;\n\n  /// Determine whether the given header is unavailable as part\n  /// of the specified module.\n  bool isHeaderUnavailableInModule(const FileEntry *Header,\n                                   const Module *RequestingModule) const;\n\n  /// Retrieve a module with the given name.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *findModule(StringRef Name) const;\n\n  /// Retrieve a module with the given name using lexical name lookup,\n  /// starting at the given context.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module context, from which we will perform lexical\n  /// name lookup.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *lookupModuleUnqualified(StringRef Name, Module *Context) const;\n\n  /// Retrieve a module with the given name within the given context,\n  /// using direct (qualified) name lookup.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module for which we will look for a submodule. If\n  /// null, we will look for a top-level module.\n  ///\n  /// \\returns The named submodule, if known; otherwose, returns null.\n  Module *lookupModuleQualified(StringRef Name, Module *Context) const;\n\n  /// Find a new module or submodule, or create it if it does not already\n  /// exist.\n  ///\n  /// \\param Name The name of the module to find or create.\n  ///\n  /// \\param Parent The module that will act as the parent of this submodule,\n  /// or nullptr to indicate that this is a top-level module.\n  ///\n  /// \\param IsFramework Whether this is a framework module.\n  ///\n  /// \\param IsExplicit Whether this is an explicit submodule.\n  ///\n  /// \\returns The found or newly-created module, along with a boolean value\n  /// that will be true if the module is newly-created.\n  std::pair<Module *, bool> findOrCreateModule(StringRef Name, Module *Parent,\n                                               bool IsFramework,\n                                               bool IsExplicit);\n\n  /// Create a global module fragment for a C++ module unit.\n  ///\n  /// We model the global module fragment as a submodule of the module\n  /// interface unit. Unfortunately, we can't create the module interface\n  /// unit's Module until later, because we don't know what it will be called.\n  Module *createGlobalModuleFragmentForModuleUnit(SourceLocation Loc);\n\n  /// Create a global module fragment for a C++ module interface unit.\n  Module *createPrivateModuleFragmentForInterfaceUnit(Module *Parent,\n                                                      SourceLocation Loc);\n\n  /// Create a new module for a C++ module interface unit.\n  /// The module must not already exist, and will be configured for the current\n  /// compilation.\n  ///\n  /// Note that this also sets the current module to the newly-created module.\n  ///\n  /// \\returns The newly-created module.\n  Module *createModuleForInterfaceUnit(SourceLocation Loc, StringRef Name,\n                                       Module *GlobalModule);\n\n  /// Create a header module from the specified list of headers.\n  Module *createHeaderModule(StringRef Name, ArrayRef<Module::Header> Headers);\n\n  /// Infer the contents of a framework module map from the given\n  /// framework directory.\n  Module *inferFrameworkModule(const DirectoryEntry *FrameworkDir,\n                               bool IsSystem, Module *Parent);\n\n  /// Create a new top-level module that is shadowed by\n  /// \\p ShadowingModule.\n  Module *createShadowedModule(StringRef Name, bool IsFramework,\n                               Module *ShadowingModule);\n\n  /// Creates a new declaration scope for module names, allowing\n  /// previously defined modules to shadow definitions from the new scope.\n  ///\n  /// \\note Module names from earlier scopes will shadow names from the new\n  /// scope, which is the opposite of how shadowing works for variables.\n  void finishModuleDeclarationScope() { CurrentModuleScopeID += 1; }\n\n  bool mayShadowNewModule(Module *ExistingModule) {\n    assert(!ExistingModule->Parent && \"expected top-level module\");\n    assert(ModuleScopeIDs.count(ExistingModule) && \"unknown module\");\n    return ModuleScopeIDs[ExistingModule] < CurrentModuleScopeID;\n  }\n\n  /// Retrieve the module map file containing the definition of the given\n  /// module.\n  ///\n  /// \\param Module The module whose module map file will be returned, if known.\n  ///\n  /// \\returns The file entry for the module map file containing the given\n  /// module, or nullptr if the module definition was inferred.\n  const FileEntry *getContainingModuleMapFile(const Module *Module) const;\n\n  /// Get the module map file that (along with the module name) uniquely\n  /// identifies this module.\n  ///\n  /// The particular module that \\c Name refers to may depend on how the module\n  /// was found in header search. However, the combination of \\c Name and\n  /// this module map will be globally unique for top-level modules. In the case\n  /// of inferred modules, returns the module map that allowed the inference\n  /// (e.g. contained 'module *'). Otherwise, returns\n  /// getContainingModuleMapFile().\n  const FileEntry *getModuleMapFileForUniquing(const Module *M) const;\n\n  void setInferredModuleAllowedBy(Module *M, const FileEntry *ModMap);\n\n  /// Get any module map files other than getModuleMapFileForUniquing(M)\n  /// that define submodules of a top-level module \\p M. This is cheaper than\n  /// getting the module map file for each submodule individually, since the\n  /// expected number of results is very small.\n  AdditionalModMapsSet *getAdditionalModuleMapFiles(const Module *M) {\n    auto I = AdditionalModMaps.find(M);\n    if (I == AdditionalModMaps.end())\n      return nullptr;\n    return &I->second;\n  }\n\n  void addAdditionalModuleMapFile(const Module *M, const FileEntry *ModuleMap);\n\n  /// Resolve all of the unresolved exports in the given module.\n  ///\n  /// \\param Mod The module whose exports should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving exports,\n  /// false otherwise.\n  bool resolveExports(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved uses in the given module.\n  ///\n  /// \\param Mod The module whose uses should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving uses,\n  /// false otherwise.\n  bool resolveUses(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved conflicts in the given module.\n  ///\n  /// \\param Mod The module whose conflicts should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving conflicts,\n  /// false otherwise.\n  bool resolveConflicts(Module *Mod, bool Complain);\n\n  /// Sets the umbrella header of the given module to the given\n  /// header.\n  void setUmbrellaHeader(Module *Mod, const FileEntry *UmbrellaHeader,\n                         Twine NameAsWritten);\n\n  /// Sets the umbrella directory of the given module to the given\n  /// directory.\n  void setUmbrellaDir(Module *Mod, const DirectoryEntry *UmbrellaDir,\n                      Twine NameAsWritten);\n\n  /// Adds this header to the given module.\n  /// \\param Role The role of the header wrt the module.\n  void addHeader(Module *Mod, Module::Header Header,\n                 ModuleHeaderRole Role, bool Imported = false);\n\n  /// Marks this header as being excluded from the given module.\n  void excludeHeader(Module *Mod, Module::Header Header);\n\n  /// Parse the given module map file, and record any modules we\n  /// encounter.\n  ///\n  /// \\param File The file to be parsed.\n  ///\n  /// \\param IsSystem Whether this module map file is in a system header\n  /// directory, and therefore should be considered a system module.\n  ///\n  /// \\param HomeDir The directory in which relative paths within this module\n  ///        map file will be resolved.\n  ///\n  /// \\param ID The FileID of the file to process, if we've already entered it.\n  ///\n  /// \\param Offset [inout] On input the offset at which to start parsing. On\n  ///        output, the offset at which the module map terminated.\n  ///\n  /// \\param ExternModuleLoc The location of the \"extern module\" declaration\n  ///        that caused us to load this module map file, if any.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool parseModuleMapFile(const FileEntry *File, bool IsSystem,\n                          const DirectoryEntry *HomeDir,\n                          FileID ID = FileID(), unsigned *Offset = nullptr,\n                          SourceLocation ExternModuleLoc = SourceLocation());\n\n  /// Dump the contents of the module map, for debugging purposes.\n  void dump();\n\n  using module_iterator = llvm::StringMap<Module *>::const_iterator;\n\n  module_iterator module_begin() const { return Modules.begin(); }\n  module_iterator module_end()   const { return Modules.end(); }\n\n  /// Cache a module load.  M might be nullptr.\n  void cacheModuleLoad(const IdentifierInfo &II, Module *M) {\n    CachedModuleLoads[&II] = M;\n  }\n\n  /// Return a cached module load.\n  llvm::Optional<Module *> getCachedModuleLoad(const IdentifierInfo &II) {\n    auto I = CachedModuleLoads.find(&II);\n    if (I == CachedModuleLoads.end())\n      return None;\n    return I->second;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_MODULEMAP_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h", "content": "//===--- MultipleIncludeOpt.h - Header Multiple-Include Optzn ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the MultipleIncludeOpt interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MULTIPLEINCLUDEOPT_H\n#define LLVM_CLANG_LEX_MULTIPLEINCLUDEOPT_H\n\n#include \"clang/Basic/SourceLocation.h\"\n\nnamespace clang {\nclass IdentifierInfo;\n\n/// Implements the simple state machine that the Lexer class uses to\n/// detect files subject to the 'multiple-include' optimization.\n///\n/// The public methods in this class are triggered by various\n/// events that occur when a file is lexed, and after the entire file is lexed,\n/// information about which macro (if any) controls the header is returned.\nclass MultipleIncludeOpt {\n  /// ReadAnyTokens - This is set to false when a file is first opened and true\n  /// any time a token is returned to the client or a (non-multiple-include)\n  /// directive is parsed.  When the final \\#endif is parsed this is reset back\n  /// to false, that way any tokens before the first \\#ifdef or after the last\n  /// \\#endif can be easily detected.\n  bool ReadAnyTokens;\n\n  /// ImmediatelyAfterTopLevelIfndef - This is true when the only tokens\n  /// processed in the file so far is an #ifndef and an identifier.  Used in\n  /// the detection of header guards in a file.\n  bool ImmediatelyAfterTopLevelIfndef;\n\n  /// ReadAnyTokens - This is set to false when a file is first opened and true\n  /// any time a token is returned to the client or a (non-multiple-include)\n  /// directive is parsed.  When the final #endif is parsed this is reset back\n  /// to false, that way any tokens before the first #ifdef or after the last\n  /// #endif can be easily detected.\n  bool DidMacroExpansion;\n\n  /// TheMacro - The controlling macro for a file, if valid.\n  ///\n  const IdentifierInfo *TheMacro;\n\n  /// DefinedMacro - The macro defined right after TheMacro, if any.\n  const IdentifierInfo *DefinedMacro;\n\n  SourceLocation MacroLoc;\n  SourceLocation DefinedLoc;\npublic:\n  MultipleIncludeOpt() {\n    ReadAnyTokens = false;\n    ImmediatelyAfterTopLevelIfndef = false;\n    DidMacroExpansion = false;\n    TheMacro = nullptr;\n    DefinedMacro = nullptr;\n  }\n\n  SourceLocation GetMacroLocation() const {\n    return MacroLoc;\n  }\n\n  SourceLocation GetDefinedLocation() const {\n    return DefinedLoc;\n  }\n\n  void resetImmediatelyAfterTopLevelIfndef() {\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  void SetDefinedMacro(IdentifierInfo *M, SourceLocation Loc) {\n    DefinedMacro = M;\n    DefinedLoc = Loc;\n  }\n\n  /// Invalidate - Permanently mark this file as not being suitable for the\n  /// include-file optimization.\n  void Invalidate() {\n    // If we have read tokens but have no controlling macro, the state-machine\n    // below can never \"accept\".\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = false;\n    DefinedMacro = nullptr;\n    TheMacro = nullptr;\n  }\n\n  /// getHasReadAnyTokensVal - This is used for the \\#ifndef handshake at the\n  /// top of the file when reading preprocessor directives.  Otherwise, reading\n  /// the \"ifndef x\" would count as reading tokens.\n  bool getHasReadAnyTokensVal() const { return ReadAnyTokens; }\n\n  /// getImmediatelyAfterTopLevelIfndef - returns true if the last directive\n  /// was an #ifndef at the beginning of the file.\n  bool getImmediatelyAfterTopLevelIfndef() const {\n    return ImmediatelyAfterTopLevelIfndef;\n  }\n\n  // If a token is read, remember that we have seen a side-effect in this file.\n  void ReadToken() {\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  /// ExpandedMacro - When a macro is expanded with this lexer as the current\n  /// buffer, this method is called to disable the MIOpt if needed.\n  void ExpandedMacro() { DidMacroExpansion = true; }\n\n  /// Called when entering a top-level \\#ifndef directive (or the\n  /// \"\\#if !defined\" equivalent) without any preceding tokens.\n  ///\n  /// Note, we don't care about the input value of 'ReadAnyTokens'.  The caller\n  /// ensures that this is only called if there are no tokens read before the\n  /// \\#ifndef.  The caller is required to do this, because reading the \\#if\n  /// line obviously reads in tokens.\n  void EnterTopLevelIfndef(const IdentifierInfo *M, SourceLocation Loc) {\n    // If the macro is already set, this is after the top-level #endif.\n    if (TheMacro)\n      return Invalidate();\n\n    // If we have already expanded a macro by the end of the #ifndef line, then\n    // there is a macro expansion *in* the #ifndef line.  This means that the\n    // condition could evaluate differently when subsequently #included.  Reject\n    // this.\n    if (DidMacroExpansion)\n      return Invalidate();\n\n    // Remember that we're in the #if and that we have the macro.\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = true;\n    TheMacro = M;\n    MacroLoc = Loc;\n  }\n\n  /// Invoked when a top level conditional (except \\#ifndef) is found.\n  void EnterTopLevelConditional() {\n    // If a conditional directive (except #ifndef) is found at the top level,\n    // there is a chunk of the file not guarded by the controlling macro.\n    Invalidate();\n  }\n\n  /// Called when the lexer exits the top-level conditional.\n  void ExitTopLevelConditional() {\n    // If we have a macro, that means the top of the file was ok.  Set our state\n    // back to \"not having read any tokens\" so we can detect anything after the\n    // #endif.\n    if (!TheMacro) return Invalidate();\n\n    // At this point, we haven't \"read any tokens\" but we do have a controlling\n    // macro.\n    ReadAnyTokens = false;\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  /// Once the entire file has been lexed, if there is a controlling\n  /// macro, return it.\n  const IdentifierInfo *GetControllingMacroAtEndOfFile() const {\n    // If we haven't read any tokens after the #endif, return the controlling\n    // macro if it's valid (if it isn't, it will be null).\n    if (!ReadAnyTokens)\n      return TheMacro;\n    return nullptr;\n  }\n\n  /// If the ControllingMacro is followed by a macro definition, return\n  /// the macro that was defined.\n  const IdentifierInfo *GetDefinedMacro() const {\n    return DefinedMacro;\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Pragma.h", "content": "//===- Pragma.h - Pragma registration and handling --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PragmaHandler and PragmaTable interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PRAGMA_H\n#define LLVM_CLANG_LEX_PRAGMA_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <string>\n\nnamespace clang {\n\nclass PragmaNamespace;\nclass Preprocessor;\nclass Token;\n\n  /**\n   * Describes how the pragma was introduced, e.g., with \\#pragma,\n   * _Pragma, or __pragma.\n   */\n  enum PragmaIntroducerKind {\n    /**\n     * The pragma was introduced via \\#pragma.\n     */\n    PIK_HashPragma,\n\n    /**\n     * The pragma was introduced via the C99 _Pragma(string-literal).\n     */\n    PIK__Pragma,\n\n    /**\n     * The pragma was introduced via the Microsoft\n     * __pragma(token-string).\n     */\n    PIK___pragma\n  };\n\n  /// Describes how and where the pragma was introduced.\n  struct PragmaIntroducer {\n    PragmaIntroducerKind Kind;\n    SourceLocation Loc;\n  };\n\n/// PragmaHandler - Instances of this interface defined to handle the various\n/// pragmas that the language front-end uses.  Each handler optionally has a\n/// name (e.g. \"pack\") and the HandlePragma method is invoked when a pragma with\n/// that identifier is found.  If a handler does not match any of the declared\n/// pragmas the handler with a null identifier is invoked, if it exists.\n///\n/// Note that the PragmaNamespace class can be used to subdivide pragmas, e.g.\n/// we treat \"\\#pragma STDC\" and \"\\#pragma GCC\" as namespaces that contain other\n/// pragmas.\nclass PragmaHandler {\n  std::string Name;\n\npublic:\n  PragmaHandler() = default;\n  explicit PragmaHandler(StringRef name) : Name(name) {}\n  virtual ~PragmaHandler();\n\n  StringRef getName() const { return Name; }\n  virtual void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                            Token &FirstToken) = 0;\n\n  /// getIfNamespace - If this is a namespace, return it.  This is equivalent to\n  /// using a dynamic_cast, but doesn't require RTTI.\n  virtual PragmaNamespace *getIfNamespace() { return nullptr; }\n};\n\n/// EmptyPragmaHandler - A pragma handler which takes no action, which can be\n/// used to ignore particular pragmas.\nclass EmptyPragmaHandler : public PragmaHandler {\npublic:\n  explicit EmptyPragmaHandler(StringRef Name = StringRef());\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &FirstToken) override;\n};\n\n/// PragmaNamespace - This PragmaHandler subdivides the namespace of pragmas,\n/// allowing hierarchical pragmas to be defined.  Common examples of namespaces\n/// are \"\\#pragma GCC\", \"\\#pragma STDC\", and \"\\#pragma omp\", but any namespaces\n/// may be (potentially recursively) defined.\nclass PragmaNamespace : public PragmaHandler {\n  /// Handlers - This is a map of the handlers in this namespace with their name\n  /// as key.\n  llvm::StringMap<std::unique_ptr<PragmaHandler>> Handlers;\n\npublic:\n  explicit PragmaNamespace(StringRef Name) : PragmaHandler(Name) {}\n\n  /// FindHandler - Check to see if there is already a handler for the\n  /// specified name.  If not, return the handler for the null name if it\n  /// exists, otherwise return null.  If IgnoreNull is true (the default) then\n  /// the null handler isn't returned on failure to match.\n  PragmaHandler *FindHandler(StringRef Name,\n                             bool IgnoreNull = true) const;\n\n  /// AddPragma - Add a pragma to this namespace.\n  void AddPragma(PragmaHandler *Handler);\n\n  /// RemovePragmaHandler - Remove the given handler from the\n  /// namespace.\n  void RemovePragmaHandler(PragmaHandler *Handler);\n\n  bool IsEmpty() const { return Handlers.empty(); }\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &Tok) override;\n\n  PragmaNamespace *getIfNamespace() override { return this; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PRAGMA_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "content": "//===- PreprocessingRecord.h - Record of Preprocessing ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PreprocessingRecord class, which maintains a record\n//  of what occurred during preprocessing.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n#define LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass PreprocessingRecord;\n\n} // namespace clang\n\n/// Allocates memory within a Clang preprocessing record.\nvoid *operator new(size_t bytes, clang::PreprocessingRecord &PR,\n                   unsigned alignment = 8) noexcept;\n\n/// Frees memory allocated in a Clang preprocessing record.\nvoid operator delete(void *ptr, clang::PreprocessingRecord &PR,\n                     unsigned) noexcept;\n\nnamespace clang {\n\nclass FileEntry;\nclass IdentifierInfo;\nclass MacroInfo;\nclass SourceManager;\nclass Token;\n\n  /// Base class that describes a preprocessed entity, which may be a\n  /// preprocessor directive or macro expansion.\n  class PreprocessedEntity {\n  public:\n    /// The kind of preprocessed entity an object describes.\n    enum EntityKind {\n      /// Indicates a problem trying to load the preprocessed entity.\n      InvalidKind,\n\n      /// A macro expansion.\n      MacroExpansionKind,\n\n      /// \\defgroup Preprocessing directives\n      /// @{\n\n      /// A macro definition.\n      MacroDefinitionKind,\n\n      /// An inclusion directive, such as \\c \\#include, \\c\n      /// \\#import, or \\c \\#include_next.\n      InclusionDirectiveKind,\n\n      /// @}\n\n      FirstPreprocessingDirective = MacroDefinitionKind,\n      LastPreprocessingDirective = InclusionDirectiveKind\n    };\n\n  private:\n    /// The kind of preprocessed entity that this object describes.\n    EntityKind Kind;\n\n    /// The source range that covers this preprocessed entity.\n    SourceRange Range;\n\n  protected:\n    friend class PreprocessingRecord;\n\n    PreprocessedEntity(EntityKind Kind, SourceRange Range)\n        : Kind(Kind), Range(Range) {}\n\n  public:\n    /// Retrieve the kind of preprocessed entity stored in this object.\n    EntityKind getKind() const { return Kind; }\n\n    /// Retrieve the source range that covers this entire preprocessed\n    /// entity.\n    SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n    /// Returns true if there was a problem loading the preprocessed\n    /// entity.\n    bool isInvalid() const { return Kind == InvalidKind; }\n\n    // Only allow allocation of preprocessed entities using the allocator\n    // in PreprocessingRecord or by doing a placement new.\n    void *operator new(size_t bytes, PreprocessingRecord &PR,\n                       unsigned alignment = 8) noexcept {\n      return ::operator new(bytes, PR, alignment);\n    }\n\n    void *operator new(size_t bytes, void *mem) noexcept { return mem; }\n\n    void operator delete(void *ptr, PreprocessingRecord &PR,\n                         unsigned alignment) noexcept {\n      return ::operator delete(ptr, PR, alignment);\n    }\n\n    void operator delete(void *, std::size_t) noexcept {}\n    void operator delete(void *, void *) noexcept {}\n\n  private:\n    // Make vanilla 'new' and 'delete' illegal for preprocessed entities.\n    void *operator new(size_t bytes) noexcept;\n    void operator delete(void *data) noexcept;\n  };\n\n  /// Records the presence of a preprocessor directive.\n  class PreprocessingDirective : public PreprocessedEntity {\n  public:\n    PreprocessingDirective(EntityKind Kind, SourceRange Range)\n        : PreprocessedEntity(Kind, Range) {}\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PD) {\n      return PD->getKind() >= FirstPreprocessingDirective &&\n             PD->getKind() <= LastPreprocessingDirective;\n    }\n  };\n\n  /// Record the location of a macro definition.\n  class MacroDefinitionRecord : public PreprocessingDirective {\n    /// The name of the macro being defined.\n    const IdentifierInfo *Name;\n\n  public:\n    explicit MacroDefinitionRecord(const IdentifierInfo *Name,\n                                   SourceRange Range)\n        : PreprocessingDirective(MacroDefinitionKind, Range), Name(Name) {}\n\n    /// Retrieve the name of the macro being defined.\n    const IdentifierInfo *getName() const { return Name; }\n\n    /// Retrieve the location of the macro name in the definition.\n    SourceLocation getLocation() const { return getSourceRange().getBegin(); }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == MacroDefinitionKind;\n    }\n  };\n\n  /// Records the location of a macro expansion.\n  class MacroExpansion : public PreprocessedEntity {\n    /// The definition of this macro or the name of the macro if it is\n    /// a builtin macro.\n    llvm::PointerUnion<IdentifierInfo *, MacroDefinitionRecord *> NameOrDef;\n\n  public:\n    MacroExpansion(IdentifierInfo *BuiltinName, SourceRange Range)\n        : PreprocessedEntity(MacroExpansionKind, Range),\n          NameOrDef(BuiltinName) {}\n\n    MacroExpansion(MacroDefinitionRecord *Definition, SourceRange Range)\n        : PreprocessedEntity(MacroExpansionKind, Range), NameOrDef(Definition) {\n    }\n\n    /// True if it is a builtin macro.\n    bool isBuiltinMacro() const { return NameOrDef.is<IdentifierInfo *>(); }\n\n    /// The name of the macro being expanded.\n    const IdentifierInfo *getName() const {\n      if (MacroDefinitionRecord *Def = getDefinition())\n        return Def->getName();\n      return NameOrDef.get<IdentifierInfo *>();\n    }\n\n    /// The definition of the macro being expanded. May return null if\n    /// this is a builtin macro.\n    MacroDefinitionRecord *getDefinition() const {\n      return NameOrDef.dyn_cast<MacroDefinitionRecord *>();\n    }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == MacroExpansionKind;\n    }\n  };\n\n  /// Record the location of an inclusion directive, such as an\n  /// \\c \\#include or \\c \\#import statement.\n  class InclusionDirective : public PreprocessingDirective {\n  public:\n    /// The kind of inclusion directives known to the\n    /// preprocessor.\n    enum InclusionKind {\n      /// An \\c \\#include directive.\n      Include,\n\n      /// An Objective-C \\c \\#import directive.\n      Import,\n\n      /// A GNU \\c \\#include_next directive.\n      IncludeNext,\n\n      /// A Clang \\c \\#__include_macros directive.\n      IncludeMacros\n    };\n\n  private:\n    /// The name of the file that was included, as written in\n    /// the source.\n    StringRef FileName;\n\n    /// Whether the file name was in quotation marks; otherwise, it was\n    /// in angle brackets.\n    unsigned InQuotes : 1;\n\n    /// The kind of inclusion directive we have.\n    ///\n    /// This is a value of type InclusionKind.\n    unsigned Kind : 2;\n\n    /// Whether the inclusion directive was automatically turned into\n    /// a module import.\n    unsigned ImportedModule : 1;\n\n    /// The file that was included.\n    const FileEntry *File;\n\n  public:\n    InclusionDirective(PreprocessingRecord &PPRec,\n                       InclusionKind Kind, StringRef FileName,\n                       bool InQuotes, bool ImportedModule,\n                       const FileEntry *File, SourceRange Range);\n\n    /// Determine what kind of inclusion directive this is.\n    InclusionKind getKind() const { return static_cast<InclusionKind>(Kind); }\n\n    /// Retrieve the included file name as it was written in the source.\n    StringRef getFileName() const { return FileName; }\n\n    /// Determine whether the included file name was written in quotes;\n    /// otherwise, it was written in angle brackets.\n    bool wasInQuotes() const { return InQuotes; }\n\n    /// Determine whether the inclusion directive was automatically\n    /// turned into a module import.\n    bool importedModule() const { return ImportedModule; }\n\n    /// Retrieve the file entry for the actual file that was included\n    /// by this directive.\n    const FileEntry *getFile() const { return File; }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == InclusionDirectiveKind;\n    }\n  };\n\n  /// An abstract class that should be subclassed by any external source\n  /// of preprocessing record entries.\n  class ExternalPreprocessingRecordSource {\n  public:\n    virtual ~ExternalPreprocessingRecordSource();\n\n    /// Read a preallocated preprocessed entity from the external source.\n    ///\n    /// \\returns null if an error occurred that prevented the preprocessed\n    /// entity from being loaded.\n    virtual PreprocessedEntity *ReadPreprocessedEntity(unsigned Index) = 0;\n\n    /// Returns a pair of [Begin, End) indices of preallocated\n    /// preprocessed entities that \\p Range encompasses.\n    virtual std::pair<unsigned, unsigned>\n        findPreprocessedEntitiesInRange(SourceRange Range) = 0;\n\n    /// Optionally returns true or false if the preallocated preprocessed\n    /// entity with index \\p Index came from file \\p FID.\n    virtual Optional<bool> isPreprocessedEntityInFileID(unsigned Index,\n                                                        FileID FID) {\n      return None;\n    }\n\n    /// Read a preallocated skipped range from the external source.\n    virtual SourceRange ReadSkippedRange(unsigned Index) = 0;\n  };\n\n  /// A record of the steps taken while preprocessing a source file,\n  /// including the various preprocessing directives processed, macros\n  /// expanded, etc.\n  class PreprocessingRecord : public PPCallbacks {\n    SourceManager &SourceMgr;\n\n    /// Allocator used to store preprocessing objects.\n    llvm::BumpPtrAllocator BumpAlloc;\n\n    /// The set of preprocessed entities in this record, in order they\n    /// were seen.\n    std::vector<PreprocessedEntity *> PreprocessedEntities;\n\n    /// The set of preprocessed entities in this record that have been\n    /// loaded from external sources.\n    ///\n    /// The entries in this vector are loaded lazily from the external source,\n    /// and are referenced by the iterator using negative indices.\n    std::vector<PreprocessedEntity *> LoadedPreprocessedEntities;\n\n    /// The set of ranges that were skipped by the preprocessor,\n    std::vector<SourceRange> SkippedRanges;\n\n    bool SkippedRangesAllLoaded = true;\n\n    /// Global (loaded or local) ID for a preprocessed entity.\n    /// Negative values are used to indicate preprocessed entities\n    /// loaded from the external source while non-negative values are used to\n    /// indicate preprocessed entities introduced by the current preprocessor.\n    /// Value -1 corresponds to element 0 in the loaded entities vector,\n    /// value -2 corresponds to element 1 in the loaded entities vector, etc.\n    /// Value 0 is an invalid value, the index to local entities is 1-based,\n    /// value 1 corresponds to element 0 in the local entities vector,\n    /// value 2 corresponds to element 1 in the local entities vector, etc.\n    class PPEntityID {\n      friend class PreprocessingRecord;\n\n      int ID = 0;\n\n      explicit PPEntityID(int ID) : ID(ID) {}\n\n    public:\n      PPEntityID() = default;\n    };\n\n    static PPEntityID getPPEntityID(unsigned Index, bool isLoaded) {\n      return isLoaded ? PPEntityID(-int(Index)-1) : PPEntityID(Index+1);\n    }\n\n    /// Mapping from MacroInfo structures to their definitions.\n    llvm::DenseMap<const MacroInfo *, MacroDefinitionRecord *> MacroDefinitions;\n\n    /// External source of preprocessed entities.\n    ExternalPreprocessingRecordSource *ExternalSource = nullptr;\n\n    /// Retrieve the preprocessed entity at the given ID.\n    PreprocessedEntity *getPreprocessedEntity(PPEntityID PPID);\n\n    /// Retrieve the loaded preprocessed entity at the given index.\n    PreprocessedEntity *getLoadedPreprocessedEntity(unsigned Index);\n\n    /// Determine the number of preprocessed entities that were\n    /// loaded (or can be loaded) from an external source.\n    unsigned getNumLoadedPreprocessedEntities() const {\n      return LoadedPreprocessedEntities.size();\n    }\n\n    /// Returns a pair of [Begin, End) indices of local preprocessed\n    /// entities that \\p Range encompasses.\n    std::pair<unsigned, unsigned>\n      findLocalPreprocessedEntitiesInRange(SourceRange Range) const;\n    unsigned findBeginLocalPreprocessedEntity(SourceLocation Loc) const;\n    unsigned findEndLocalPreprocessedEntity(SourceLocation Loc) const;\n\n    /// Allocate space for a new set of loaded preprocessed entities.\n    ///\n    /// \\returns The index into the set of loaded preprocessed entities, which\n    /// corresponds to the first newly-allocated entity.\n    unsigned allocateLoadedEntities(unsigned NumEntities);\n\n    /// Allocate space for a new set of loaded preprocessed skipped\n    /// ranges.\n    ///\n    /// \\returns The index into the set of loaded preprocessed ranges, which\n    /// corresponds to the first newly-allocated range.\n    unsigned allocateSkippedRanges(unsigned NumRanges);\n\n    /// Ensures that all external skipped ranges have been loaded.\n    void ensureSkippedRangesLoaded();\n\n    /// Register a new macro definition.\n    void RegisterMacroDefinition(MacroInfo *Macro, MacroDefinitionRecord *Def);\n\n  public:\n    /// Construct a new preprocessing record.\n    explicit PreprocessingRecord(SourceManager &SM);\n\n    /// Allocate memory in the preprocessing record.\n    void *Allocate(unsigned Size, unsigned Align = 8) {\n      return BumpAlloc.Allocate(Size, Align);\n    }\n\n    /// Deallocate memory in the preprocessing record.\n    void Deallocate(void *Ptr) {}\n\n    size_t getTotalMemory() const;\n\n    SourceManager &getSourceManager() const { return SourceMgr; }\n\n    /// Iteration over the preprocessed entities.\n    ///\n    /// In a complete iteration, the iterator walks the range [-M, N),\n    /// where negative values are used to indicate preprocessed entities\n    /// loaded from the external source while non-negative values are used to\n    /// indicate preprocessed entities introduced by the current preprocessor.\n    /// However, to provide iteration in source order (for, e.g., chained\n    /// precompiled headers), dereferencing the iterator flips the negative\n    /// values (corresponding to loaded entities), so that position -M\n    /// corresponds to element 0 in the loaded entities vector, position -M+1\n    /// corresponds to element 1 in the loaded entities vector, etc. This\n    /// gives us a reasonably efficient, source-order walk.\n    ///\n    /// We define this as a wrapping iterator around an int. The\n    /// iterator_adaptor_base class forwards the iterator methods to basic\n    /// integer arithmetic.\n    class iterator : public llvm::iterator_adaptor_base<\n                         iterator, int, std::random_access_iterator_tag,\n                         PreprocessedEntity *, int, PreprocessedEntity *,\n                         PreprocessedEntity *> {\n      friend class PreprocessingRecord;\n\n      PreprocessingRecord *Self;\n\n      iterator(PreprocessingRecord *Self, int Position)\n          : iterator::iterator_adaptor_base(Position), Self(Self) {}\n\n    public:\n      iterator() : iterator(nullptr, 0) {}\n\n      PreprocessedEntity *operator*() const {\n        bool isLoaded = this->I < 0;\n        unsigned Index = isLoaded ?\n            Self->LoadedPreprocessedEntities.size() + this->I : this->I;\n        PPEntityID ID = Self->getPPEntityID(Index, isLoaded);\n        return Self->getPreprocessedEntity(ID);\n      }\n      PreprocessedEntity *operator->() const { return **this; }\n    };\n\n    /// Begin iterator for all preprocessed entities.\n    iterator begin() {\n      return iterator(this, -(int)LoadedPreprocessedEntities.size());\n    }\n\n    /// End iterator for all preprocessed entities.\n    iterator end() {\n      return iterator(this, PreprocessedEntities.size());\n    }\n\n    /// Begin iterator for local, non-loaded, preprocessed entities.\n    iterator local_begin() {\n      return iterator(this, 0);\n    }\n\n    /// End iterator for local, non-loaded, preprocessed entities.\n    iterator local_end() {\n      return iterator(this, PreprocessedEntities.size());\n    }\n\n    /// iterator range for the given range of loaded\n    /// preprocessed entities.\n    llvm::iterator_range<iterator> getIteratorsForLoadedRange(unsigned start,\n                                                              unsigned count) {\n      unsigned end = start + count;\n      assert(end <= LoadedPreprocessedEntities.size());\n      return llvm::make_range(\n          iterator(this, int(start) - LoadedPreprocessedEntities.size()),\n          iterator(this, int(end) - LoadedPreprocessedEntities.size()));\n    }\n\n    /// Returns a range of preprocessed entities that source range \\p R\n    /// encompasses.\n    ///\n    /// \\param R the range to look for preprocessed entities.\n    llvm::iterator_range<iterator>\n    getPreprocessedEntitiesInRange(SourceRange R);\n\n    /// Returns true if the preprocessed entity that \\p PPEI iterator\n    /// points to is coming from the file \\p FID.\n    ///\n    /// Can be used to avoid implicit deserializations of preallocated\n    /// preprocessed entities if we only care about entities of a specific file\n    /// and not from files \\#included in the range given at\n    /// \\see getPreprocessedEntitiesInRange.\n    bool isEntityInFileID(iterator PPEI, FileID FID);\n\n    /// Add a new preprocessed entity to this record.\n    PPEntityID addPreprocessedEntity(PreprocessedEntity *Entity);\n\n    /// Set the external source for preprocessed entities.\n    void SetExternalSource(ExternalPreprocessingRecordSource &Source);\n\n    /// Retrieve the external source for preprocessed entities.\n    ExternalPreprocessingRecordSource *getExternalSource() const {\n      return ExternalSource;\n    }\n\n    /// Retrieve the macro definition that corresponds to the given\n    /// \\c MacroInfo.\n    MacroDefinitionRecord *findMacroDefinition(const MacroInfo *MI);\n\n    /// Retrieve all ranges that got skipped while preprocessing.\n    const std::vector<SourceRange> &getSkippedRanges() {\n      ensureSkippedRangesLoaded();\n      return SkippedRanges;\n    }\n\n  private:\n    friend class ASTReader;\n    friend class ASTWriter;\n\n    void MacroExpands(const Token &Id, const MacroDefinition &MD,\n                      SourceRange Range, const MacroArgs *Args) override;\n    void MacroDefined(const Token &Id, const MacroDirective *MD) override;\n    void MacroUndefined(const Token &Id, const MacroDefinition &MD,\n                        const MacroDirective *Undef) override;\n    void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,\n                            StringRef FileName, bool IsAngled,\n                            CharSourceRange FilenameRange,\n                            const FileEntry *File, StringRef SearchPath,\n                            StringRef RelativePath, const Module *Imported,\n                            SrcMgr::CharacteristicKind FileType) override;\n    void Ifdef(SourceLocation Loc, const Token &MacroNameTok,\n               const MacroDefinition &MD) override;\n    void Ifndef(SourceLocation Loc, const Token &MacroNameTok,\n                const MacroDefinition &MD) override;\n\n    /// Hook called whenever the 'defined' operator is seen.\n    void Defined(const Token &MacroNameTok, const MacroDefinition &MD,\n                 SourceRange Range) override;\n\n    void SourceRangeSkipped(SourceRange Range,\n                            SourceLocation EndifLoc) override;\n\n    void addMacroExpansion(const Token &Id, const MacroInfo *MI,\n                           SourceRange Range);\n\n    /// Cached result of the last \\see getPreprocessedEntitiesInRange\n    /// query.\n    struct {\n      SourceRange Range;\n      std::pair<int, int> Result;\n    } CachedRangeQuery;\n\n    std::pair<int, int> getPreprocessedEntitiesInRangeSlow(SourceRange R);\n  };\n\n} // namespace clang\n\ninline void *operator new(size_t bytes, clang::PreprocessingRecord &PR,\n                          unsigned alignment) noexcept {\n  return PR.Allocate(bytes, alignment);\n}\n\ninline void operator delete(void *ptr, clang::PreprocessingRecord &PR,\n                            unsigned) noexcept {\n  PR.Deallocate(ptr);\n}\n\n#endif // LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n"}, "67": {"id": 67, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "content": "//===- Preprocessor.h - C Language Family Preprocessor ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Preprocessor interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSOR_H\n#define LLVM_CLANG_LEX_PREPROCESSOR_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/ModuleMap.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Lex/TokenLexer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Registry.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate<unsigned InternalLen> class SmallString;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass CodeCompletionHandler;\nclass CommentHandler;\nclass DirectoryEntry;\nclass DirectoryLookup;\nclass EmptylineHandler;\nclass ExternalPreprocessorSource;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearch;\nclass MacroArgs;\nclass PragmaHandler;\nclass PragmaNamespace;\nclass PreprocessingRecord;\nclass PreprocessorLexer;\nclass PreprocessorOptions;\nclass ScratchBuffer;\nclass TargetInfo;\n\nnamespace Builtin {\nclass Context;\n}\n\n/// Stores token information for comparing actual tokens with\n/// predefined values.  Only handles simple tokens and identifiers.\nclass TokenValue {\n  tok::TokenKind Kind;\n  IdentifierInfo *II;\n\npublic:\n  TokenValue(tok::TokenKind Kind) : Kind(Kind), II(nullptr) {\n    assert(Kind != tok::raw_identifier && \"Raw identifiers are not supported.\");\n    assert(Kind != tok::identifier &&\n           \"Identifiers should be created by TokenValue(IdentifierInfo *)\");\n    assert(!tok::isLiteral(Kind) && \"Literals are not supported.\");\n    assert(!tok::isAnnotation(Kind) && \"Annotations are not supported.\");\n  }\n\n  TokenValue(IdentifierInfo *II) : Kind(tok::identifier), II(II) {}\n\n  bool operator==(const Token &Tok) const {\n    return Tok.getKind() == Kind &&\n        (!II || II == Tok.getIdentifierInfo());\n  }\n};\n\n/// Context in which macro name is used.\nenum MacroUse {\n  // other than #define or #undef\n  MU_Other  = 0,\n\n  // macro name specified in #define\n  MU_Define = 1,\n\n  // macro name specified in #undef\n  MU_Undef  = 2\n};\n\n/// Engages in a tight little dance with the lexer to efficiently\n/// preprocess tokens.\n///\n/// Lexers know only about tokens within a single source file, and don't\n/// know anything about preprocessor-level issues like the \\#include stack,\n/// token expansion, etc.\nclass Preprocessor {\n  friend class VAOptDefinitionContext;\n  friend class VariadicMacroScopeGuard;\n\n  llvm::unique_function<void(const clang::Token &)> OnToken;\n  std::shared_ptr<PreprocessorOptions> PPOpts;\n  DiagnosticsEngine        *Diags;\n  LangOptions       &LangOpts;\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  FileManager       &FileMgr;\n  SourceManager     &SourceMgr;\n  std::unique_ptr<ScratchBuffer> ScratchBuf;\n  HeaderSearch      &HeaderInfo;\n  ModuleLoader      &TheModuleLoader;\n\n  /// External source of macros.\n  ExternalPreprocessorSource *ExternalSource;\n\n  /// A BumpPtrAllocator object used to quickly allocate and release\n  /// objects internal to the Preprocessor.\n  llvm::BumpPtrAllocator BP;\n\n  /// Identifiers for builtin macros and other builtins.\n  IdentifierInfo *Ident__LINE__, *Ident__FILE__;   // __LINE__, __FILE__\n  IdentifierInfo *Ident__DATE__, *Ident__TIME__;   // __DATE__, __TIME__\n  IdentifierInfo *Ident__INCLUDE_LEVEL__;          // __INCLUDE_LEVEL__\n  IdentifierInfo *Ident__BASE_FILE__;              // __BASE_FILE__\n  IdentifierInfo *Ident__FILE_NAME__;              // __FILE_NAME__\n  IdentifierInfo *Ident__TIMESTAMP__;              // __TIMESTAMP__\n  IdentifierInfo *Ident__COUNTER__;                // __COUNTER__\n  IdentifierInfo *Ident_Pragma, *Ident__pragma;    // _Pragma, __pragma\n  IdentifierInfo *Ident__identifier;               // __identifier\n  IdentifierInfo *Ident__VA_ARGS__;                // __VA_ARGS__\n  IdentifierInfo *Ident__VA_OPT__;                 // __VA_OPT__\n  IdentifierInfo *Ident__has_feature;              // __has_feature\n  IdentifierInfo *Ident__has_extension;            // __has_extension\n  IdentifierInfo *Ident__has_builtin;              // __has_builtin\n  IdentifierInfo *Ident__has_attribute;            // __has_attribute\n  IdentifierInfo *Ident__has_include;              // __has_include\n  IdentifierInfo *Ident__has_include_next;         // __has_include_next\n  IdentifierInfo *Ident__has_warning;              // __has_warning\n  IdentifierInfo *Ident__is_identifier;            // __is_identifier\n  IdentifierInfo *Ident__building_module;          // __building_module\n  IdentifierInfo *Ident__MODULE__;                 // __MODULE__\n  IdentifierInfo *Ident__has_cpp_attribute;        // __has_cpp_attribute\n  IdentifierInfo *Ident__has_c_attribute;          // __has_c_attribute\n  IdentifierInfo *Ident__has_declspec;             // __has_declspec_attribute\n  IdentifierInfo *Ident__is_target_arch;           // __is_target_arch\n  IdentifierInfo *Ident__is_target_vendor;         // __is_target_vendor\n  IdentifierInfo *Ident__is_target_os;             // __is_target_os\n  IdentifierInfo *Ident__is_target_environment;    // __is_target_environment\n\n  // Weak, only valid (and set) while InMacroArgs is true.\n  Token* ArgMacro;\n\n  SourceLocation DATELoc, TIMELoc;\n\n  // Next __COUNTER__ value, starts at 0.\n  unsigned CounterValue = 0;\n\n  enum {\n    /// Maximum depth of \\#includes.\n    MaxAllowedIncludeStackDepth = 200\n  };\n\n  // State that is set before the preprocessor begins.\n  bool KeepComments : 1;\n  bool KeepMacroComments : 1;\n  bool SuppressIncludeNotFoundError : 1;\n\n  // State that changes while the preprocessor runs:\n  bool InMacroArgs : 1;            // True if parsing fn macro invocation args.\n\n  /// Whether the preprocessor owns the header search object.\n  bool OwnsHeaderSearch : 1;\n\n  /// True if macro expansion is disabled.\n  bool DisableMacroExpansion : 1;\n\n  /// Temporarily disables DisableMacroExpansion (i.e. enables expansion)\n  /// when parsing preprocessor directives.\n  bool MacroExpansionInDirectivesOverride : 1;\n\n  class ResetMacroExpansionHelper;\n\n  /// Whether we have already loaded macros from the external source.\n  mutable bool ReadMacrosFromExternalSource : 1;\n\n  /// True if pragmas are enabled.\n  bool PragmasEnabled : 1;\n\n  /// True if the current build action is a preprocessing action.\n  bool PreprocessedOutput : 1;\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool ParsingIfOrElifDirective;\n\n  /// True if we are pre-expanding macro arguments.\n  bool InMacroArgPreExpansion;\n\n  /// Mapping/lookup information for all identifiers in\n  /// the program, including program keywords.\n  mutable IdentifierTable Identifiers;\n\n  /// This table contains all the selectors in the program.\n  ///\n  /// Unlike IdentifierTable above, this table *isn't* populated by the\n  /// preprocessor. It is declared/expanded here because its role/lifetime is\n  /// conceptually similar to the IdentifierTable. In addition, the current\n  /// control flow (in clang::ParseAST()), make it convenient to put here.\n  ///\n  /// FIXME: Make sure the lifetime of Identifiers/Selectors *isn't* tied to\n  /// the lifetime of the preprocessor.\n  SelectorTable Selectors;\n\n  /// Information about builtins.\n  std::unique_ptr<Builtin::Context> BuiltinInfo;\n\n  /// Tracks all of the pragmas that the client registered\n  /// with this preprocessor.\n  std::unique_ptr<PragmaNamespace> PragmaHandlers;\n\n  /// Pragma handlers of the original source is stored here during the\n  /// parsing of a model file.\n  std::unique_ptr<PragmaNamespace> PragmaHandlersBackup;\n\n  /// Tracks all of the comment handlers that the client registered\n  /// with this preprocessor.\n  std::vector<CommentHandler *> CommentHandlers;\n\n  /// Empty line handler.\n  EmptylineHandler *Emptyline = nullptr;\n\n  /// True if we want to ignore EOF token and continue later on (thus\n  /// avoid tearing the Lexer and etc. down).\n  bool IncrementalProcessing = false;\n\n  /// The kind of translation unit we are processing.\n  TranslationUnitKind TUKind;\n\n  /// The code-completion handler.\n  CodeCompletionHandler *CodeComplete = nullptr;\n\n  /// The file that we're performing code-completion for, if any.\n  const FileEntry *CodeCompletionFile = nullptr;\n\n  /// The offset in file for the code-completion point.\n  unsigned CodeCompletionOffset = 0;\n\n  /// The location for the code-completion point. This gets instantiated\n  /// when the CodeCompletionFile gets \\#include'ed for preprocessing.\n  SourceLocation CodeCompletionLoc;\n\n  /// The start location for the file of the code-completion point.\n  ///\n  /// This gets instantiated when the CodeCompletionFile gets \\#include'ed\n  /// for preprocessing.\n  SourceLocation CodeCompletionFileLoc;\n\n  /// The source location of the \\c import contextual keyword we just\n  /// lexed, if any.\n  SourceLocation ModuleImportLoc;\n\n  /// The module import path that we're currently processing.\n  SmallVector<std::pair<IdentifierInfo *, SourceLocation>, 2> ModuleImportPath;\n\n  /// Whether the last token we lexed was an '@'.\n  bool LastTokenWasAt = false;\n\n  /// A position within a C++20 import-seq.\n  class ImportSeq {\n  public:\n    enum State : int {\n      // Positive values represent a number of unclosed brackets.\n      AtTopLevel = 0,\n      AfterTopLevelTokenSeq = -1,\n      AfterExport = -2,\n      AfterImportSeq = -3,\n    };\n\n    ImportSeq(State S) : S(S) {}\n\n    /// Saw any kind of open bracket.\n    void handleOpenBracket() {\n      S = static_cast<State>(std::max<int>(S, 0) + 1);\n    }\n    /// Saw any kind of close bracket other than '}'.\n    void handleCloseBracket() {\n      S = static_cast<State>(std::max<int>(S, 1) - 1);\n    }\n    /// Saw a close brace.\n    void handleCloseBrace() {\n      handleCloseBracket();\n      if (S == AtTopLevel && !AfterHeaderName)\n        S = AfterTopLevelTokenSeq;\n    }\n    /// Saw a semicolon.\n    void handleSemi() {\n      if (atTopLevel()) {\n        S = AfterTopLevelTokenSeq;\n        AfterHeaderName = false;\n      }\n    }\n\n    /// Saw an 'export' identifier.\n    void handleExport() {\n      if (S == AfterTopLevelTokenSeq)\n        S = AfterExport;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n    /// Saw an 'import' identifier.\n    void handleImport() {\n      if (S == AfterTopLevelTokenSeq || S == AfterExport)\n        S = AfterImportSeq;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    /// Saw a 'header-name' token; do not recognize any more 'import' tokens\n    /// until we reach a top-level semicolon.\n    void handleHeaderName() {\n      if (S == AfterImportSeq)\n        AfterHeaderName = true;\n      handleMisc();\n    }\n\n    /// Saw any other token.\n    void handleMisc() {\n      if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    bool atTopLevel() { return S <= 0; }\n    bool afterImportSeq() { return S == AfterImportSeq; }\n\n  private:\n    State S;\n    /// Whether we're in the pp-import-suffix following the header-name in a\n    /// pp-import. If so, a close-brace is not sufficient to end the\n    /// top-level-token-seq of an import-seq.\n    bool AfterHeaderName = false;\n  };\n\n  /// Our current position within a C++20 import-seq.\n  ImportSeq ImportSeqState = ImportSeq::AfterTopLevelTokenSeq;\n\n  /// Whether the module import expects an identifier next. Otherwise,\n  /// it expects a '.' or ';'.\n  bool ModuleImportExpectsIdentifier = false;\n\n  /// The identifier and source location of the currently-active\n  /// \\#pragma clang arc_cf_code_audited begin.\n  std::pair<IdentifierInfo *, SourceLocation> PragmaARCCFCodeAuditedInfo;\n\n  /// The source location of the currently-active\n  /// \\#pragma clang assume_nonnull begin.\n  SourceLocation PragmaAssumeNonNullLoc;\n\n  /// True if we hit the code-completion point.\n  bool CodeCompletionReached = false;\n\n  /// The code completion token containing the information\n  /// on the stem that is to be code completed.\n  IdentifierInfo *CodeCompletionII = nullptr;\n\n  /// Range for the code completion token.\n  SourceRange CodeCompletionTokenRange;\n\n  /// The directory that the main file should be considered to occupy,\n  /// if it does not correspond to a real file (as happens when building a\n  /// module).\n  const DirectoryEntry *MainFileDir = nullptr;\n\n  /// The number of bytes that we will initially skip when entering the\n  /// main file, along with a flag that indicates whether skipping this number\n  /// of bytes will place the lexer at the start of a line.\n  ///\n  /// This is used when loading a precompiled preamble.\n  std::pair<int, bool> SkipMainFilePreamble;\n\n  /// Whether we hit an error due to reaching max allowed include depth. Allows\n  /// to avoid hitting the same error over and over again.\n  bool HasReachedMaxIncludeDepth = false;\n\n  /// The number of currently-active calls to Lex.\n  ///\n  /// Lex is reentrant, and asking for an (end-of-phase-4) token can often\n  /// require asking for multiple additional tokens. This counter makes it\n  /// possible for Lex to detect whether it's producing a token for the end\n  /// of phase 4 of translation or for some other situation.\n  unsigned LexLevel = 0;\n\n  /// The number of (LexLevel 0) preprocessor tokens.\n  unsigned TokenCount = 0;\n\n  /// Preprocess every token regardless of LexLevel.\n  bool PreprocessToken = false;\n\n  /// The maximum number of (LexLevel 0) tokens before issuing a -Wmax-tokens\n  /// warning, or zero for unlimited.\n  unsigned MaxTokens = 0;\n  SourceLocation MaxTokensOverrideLoc;\n\npublic:\n  struct PreambleSkipInfo {\n    SourceLocation HashTokenLoc;\n    SourceLocation IfTokenLoc;\n    bool FoundNonSkipPortion;\n    bool FoundElse;\n    SourceLocation ElseLoc;\n\n    PreambleSkipInfo(SourceLocation HashTokenLoc, SourceLocation IfTokenLoc,\n                     bool FoundNonSkipPortion, bool FoundElse,\n                     SourceLocation ElseLoc)\n        : HashTokenLoc(HashTokenLoc), IfTokenLoc(IfTokenLoc),\n          FoundNonSkipPortion(FoundNonSkipPortion), FoundElse(FoundElse),\n          ElseLoc(ElseLoc) {}\n  };\n\nprivate:\n  friend class ASTReader;\n  friend class MacroArgs;\n\n  class PreambleConditionalStackStore {\n    enum State {\n      Off = 0,\n      Recording = 1,\n      Replaying = 2,\n    };\n\n  public:\n    PreambleConditionalStackStore() = default;\n\n    void startRecording() { ConditionalStackState = Recording; }\n    void startReplaying() { ConditionalStackState = Replaying; }\n    bool isRecording() const { return ConditionalStackState == Recording; }\n    bool isReplaying() const { return ConditionalStackState == Replaying; }\n\n    ArrayRef<PPConditionalInfo> getStack() const {\n      return ConditionalStack;\n    }\n\n    void doneReplaying() {\n      ConditionalStack.clear();\n      ConditionalStackState = Off;\n    }\n\n    void setStack(ArrayRef<PPConditionalInfo> s) {\n      if (!isRecording() && !isReplaying())\n        return;\n      ConditionalStack.clear();\n      ConditionalStack.append(s.begin(), s.end());\n    }\n\n    bool hasRecordedPreamble() const { return !ConditionalStack.empty(); }\n\n    bool reachedEOFWhileSkipping() const { return SkipInfo.hasValue(); }\n\n    void clearSkipInfo() { SkipInfo.reset(); }\n\n    llvm::Optional<PreambleSkipInfo> SkipInfo;\n\n  private:\n    SmallVector<PPConditionalInfo, 4> ConditionalStack;\n    State ConditionalStackState = Off;\n  } PreambleConditionalStack;\n\n  /// The current top of the stack that we're lexing from if\n  /// not expanding a macro and we are lexing directly from source code.\n  ///\n  /// Only one of CurLexer, or CurTokenLexer will be non-null.\n  std::unique_ptr<Lexer> CurLexer;\n\n  /// The current top of the stack what we're lexing from\n  /// if not expanding a macro.\n  ///\n  /// This is an alias for CurLexer.\n  PreprocessorLexer *CurPPLexer = nullptr;\n\n  /// Used to find the current FileEntry, if CurLexer is non-null\n  /// and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *CurDirLookup = nullptr;\n\n  /// The current macro we are expanding, if we are expanding a macro.\n  ///\n  /// One of CurLexer and CurTokenLexer must be null.\n  std::unique_ptr<TokenLexer> CurTokenLexer;\n\n  /// The kind of lexer we're currently working with.\n  enum CurLexerKind {\n    CLK_Lexer,\n    CLK_TokenLexer,\n    CLK_CachingLexer,\n    CLK_LexAfterModuleImport\n  } CurLexerKind = CLK_Lexer;\n\n  /// If the current lexer is for a submodule that is being built, this\n  /// is that submodule.\n  Module *CurLexerSubmodule = nullptr;\n\n  /// Keeps track of the stack of files currently\n  /// \\#included, and macros currently being expanded from, not counting\n  /// CurLexer/CurTokenLexer.\n  struct IncludeStackInfo {\n    enum CurLexerKind           CurLexerKind;\n    Module                     *TheSubmodule;\n    std::unique_ptr<Lexer>      TheLexer;\n    PreprocessorLexer          *ThePPLexer;\n    std::unique_ptr<TokenLexer> TheTokenLexer;\n    const DirectoryLookup      *TheDirLookup;\n\n    // The following constructors are completely useless copies of the default\n    // versions, only needed to pacify MSVC.\n    IncludeStackInfo(enum CurLexerKind CurLexerKind, Module *TheSubmodule,\n                     std::unique_ptr<Lexer> &&TheLexer,\n                     PreprocessorLexer *ThePPLexer,\n                     std::unique_ptr<TokenLexer> &&TheTokenLexer,\n                     const DirectoryLookup *TheDirLookup)\n        : CurLexerKind(std::move(CurLexerKind)),\n          TheSubmodule(std::move(TheSubmodule)), TheLexer(std::move(TheLexer)),\n          ThePPLexer(std::move(ThePPLexer)),\n          TheTokenLexer(std::move(TheTokenLexer)),\n          TheDirLookup(std::move(TheDirLookup)) {}\n  };\n  std::vector<IncludeStackInfo> IncludeMacroStack;\n\n  /// Actions invoked when some preprocessor activity is\n  /// encountered (e.g. a file is \\#included, etc).\n  std::unique_ptr<PPCallbacks> Callbacks;\n\n  struct MacroExpandsInfo {\n    Token Tok;\n    MacroDefinition MD;\n    SourceRange Range;\n\n    MacroExpandsInfo(Token Tok, MacroDefinition MD, SourceRange Range)\n        : Tok(Tok), MD(MD), Range(Range) {}\n  };\n  SmallVector<MacroExpandsInfo, 2> DelayedMacroExpandsCallbacks;\n\n  /// Information about a name that has been used to define a module macro.\n  struct ModuleMacroInfo {\n    /// The most recent macro directive for this identifier.\n    MacroDirective *MD;\n\n    /// The active module macros for this identifier.\n    llvm::TinyPtrVector<ModuleMacro *> ActiveModuleMacros;\n\n    /// The generation number at which we last updated ActiveModuleMacros.\n    /// \\see Preprocessor::VisibleModules.\n    unsigned ActiveModuleMacrosGeneration = 0;\n\n    /// Whether this macro name is ambiguous.\n    bool IsAmbiguous = false;\n\n    /// The module macros that are overridden by this macro.\n    llvm::TinyPtrVector<ModuleMacro *> OverriddenMacros;\n\n    ModuleMacroInfo(MacroDirective *MD) : MD(MD) {}\n  };\n\n  /// The state of a macro for an identifier.\n  class MacroState {\n    mutable llvm::PointerUnion<MacroDirective *, ModuleMacroInfo *> State;\n\n    ModuleMacroInfo *getModuleInfo(Preprocessor &PP,\n                                   const IdentifierInfo *II) const {\n      if (II->isOutOfDate())\n        PP.updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n      // FIXME: Find a spare bit on IdentifierInfo and store a\n      //        HasModuleMacros flag.\n      if (!II->hasMacroDefinition() ||\n          (!PP.getLangOpts().Modules &&\n           !PP.getLangOpts().ModulesLocalVisibility) ||\n          !PP.CurSubmoduleState->VisibleModules.getGeneration())\n        return nullptr;\n\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n\n      if (PP.CurSubmoduleState->VisibleModules.getGeneration() !=\n          Info->ActiveModuleMacrosGeneration)\n        PP.updateModuleMacroInfo(II, *Info);\n      return Info;\n    }\n\n  public:\n    MacroState() : MacroState(nullptr) {}\n    MacroState(MacroDirective *MD) : State(MD) {}\n\n    MacroState(MacroState &&O) noexcept : State(O.State) {\n      O.State = (MacroDirective *)nullptr;\n    }\n\n    MacroState &operator=(MacroState &&O) noexcept {\n      auto S = O.State;\n      O.State = (MacroDirective *)nullptr;\n      State = S;\n      return *this;\n    }\n\n    ~MacroState() {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->~ModuleMacroInfo();\n    }\n\n    MacroDirective *getLatest() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->MD;\n      return State.get<MacroDirective*>();\n    }\n\n    void setLatest(MacroDirective *MD) {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->MD = MD;\n      else\n        State = MD;\n    }\n\n    bool isAmbiguous(Preprocessor &PP, const IdentifierInfo *II) const {\n      auto *Info = getModuleInfo(PP, II);\n      return Info ? Info->IsAmbiguous : false;\n    }\n\n    ArrayRef<ModuleMacro *>\n    getActiveModuleMacros(Preprocessor &PP, const IdentifierInfo *II) const {\n      if (auto *Info = getModuleInfo(PP, II))\n        return Info->ActiveModuleMacros;\n      return None;\n    }\n\n    MacroDirective::DefInfo findDirectiveAtLoc(SourceLocation Loc,\n                                               SourceManager &SourceMgr) const {\n      // FIXME: Incorporate module macros into the result of this.\n      if (auto *Latest = getLatest())\n        return Latest->findDirectiveAtLoc(Loc, SourceMgr);\n      return {};\n    }\n\n    void overrideActiveModuleMacros(Preprocessor &PP, IdentifierInfo *II) {\n      if (auto *Info = getModuleInfo(PP, II)) {\n        Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                      Info->ActiveModuleMacros.begin(),\n                                      Info->ActiveModuleMacros.end());\n        Info->ActiveModuleMacros.clear();\n        Info->IsAmbiguous = false;\n      }\n    }\n\n    ArrayRef<ModuleMacro*> getOverriddenMacros() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->OverriddenMacros;\n      return None;\n    }\n\n    void setOverriddenMacros(Preprocessor &PP,\n                             ArrayRef<ModuleMacro *> Overrides) {\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        if (Overrides.empty())\n          return;\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n      Info->OverriddenMacros.clear();\n      Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                    Overrides.begin(), Overrides.end());\n      Info->ActiveModuleMacrosGeneration = 0;\n    }\n  };\n\n  /// For each IdentifierInfo that was associated with a macro, we\n  /// keep a mapping to the history of all macro definitions and #undefs in\n  /// the reverse order (the latest one is in the head of the list).\n  ///\n  /// This mapping lives within the \\p CurSubmoduleState.\n  using MacroMap = llvm::DenseMap<const IdentifierInfo *, MacroState>;\n\n  struct SubmoduleState;\n\n  /// Information about a submodule that we're currently building.\n  struct BuildingSubmoduleInfo {\n    /// The module that we are building.\n    Module *M;\n\n    /// The location at which the module was included.\n    SourceLocation ImportLoc;\n\n    /// Whether we entered this submodule via a pragma.\n    bool IsPragma;\n\n    /// The previous SubmoduleState.\n    SubmoduleState *OuterSubmoduleState;\n\n    /// The number of pending module macro names when we started building this.\n    unsigned OuterPendingModuleMacroNames;\n\n    BuildingSubmoduleInfo(Module *M, SourceLocation ImportLoc, bool IsPragma,\n                          SubmoduleState *OuterSubmoduleState,\n                          unsigned OuterPendingModuleMacroNames)\n        : M(M), ImportLoc(ImportLoc), IsPragma(IsPragma),\n          OuterSubmoduleState(OuterSubmoduleState),\n          OuterPendingModuleMacroNames(OuterPendingModuleMacroNames) {}\n  };\n  SmallVector<BuildingSubmoduleInfo, 8> BuildingSubmoduleStack;\n\n  /// Information about a submodule's preprocessor state.\n  struct SubmoduleState {\n    /// The macros for the submodule.\n    MacroMap Macros;\n\n    /// The set of modules that are visible within the submodule.\n    VisibleModuleSet VisibleModules;\n\n    // FIXME: CounterValue?\n    // FIXME: PragmaPushMacroInfo?\n  };\n  std::map<Module *, SubmoduleState> Submodules;\n\n  /// The preprocessor state for preprocessing outside of any submodule.\n  SubmoduleState NullSubmoduleState;\n\n  /// The current submodule state. Will be \\p NullSubmoduleState if we're not\n  /// in a submodule.\n  SubmoduleState *CurSubmoduleState;\n\n  /// The set of known macros exported from modules.\n  llvm::FoldingSet<ModuleMacro> ModuleMacros;\n\n  /// The names of potential module macros that we've not yet processed.\n  llvm::SmallVector<const IdentifierInfo *, 32> PendingModuleMacroNames;\n\n  /// The list of module macros, for each identifier, that are not overridden by\n  /// any other module macro.\n  llvm::DenseMap<const IdentifierInfo *, llvm::TinyPtrVector<ModuleMacro *>>\n      LeafModuleMacros;\n\n  /// Macros that we want to warn because they are not used at the end\n  /// of the translation unit.\n  ///\n  /// We store just their SourceLocations instead of\n  /// something like MacroInfo*. The benefit of this is that when we are\n  /// deserializing from PCH, we don't need to deserialize identifier & macros\n  /// just so that we can report that they are unused, we just warn using\n  /// the SourceLocations of this set (that will be filled by the ASTReader).\n  /// We are using SmallPtrSet instead of a vector for faster removal.\n  using WarnUnusedMacroLocsTy = llvm::SmallPtrSet<SourceLocation, 32>;\n  WarnUnusedMacroLocsTy WarnUnusedMacroLocs;\n\n  /// A \"freelist\" of MacroArg objects that can be\n  /// reused for quick allocation.\n  MacroArgs *MacroArgCache = nullptr;\n\n  /// For each IdentifierInfo used in a \\#pragma push_macro directive,\n  /// we keep a MacroInfo stack used to restore the previous macro value.\n  llvm::DenseMap<IdentifierInfo *, std::vector<MacroInfo *>>\n      PragmaPushMacroInfo;\n\n  // Various statistics we track for performance analysis.\n  unsigned NumDirectives = 0;\n  unsigned NumDefined = 0;\n  unsigned NumUndefined = 0;\n  unsigned NumPragma = 0;\n  unsigned NumIf = 0;\n  unsigned NumElse = 0;\n  unsigned NumEndif = 0;\n  unsigned NumEnteredSourceFiles = 0;\n  unsigned MaxIncludeStackDepth = 0;\n  unsigned NumMacroExpanded = 0;\n  unsigned NumFnMacroExpanded = 0;\n  unsigned NumBuiltinMacroExpanded = 0;\n  unsigned NumFastMacroExpanded = 0;\n  unsigned NumTokenPaste = 0;\n  unsigned NumFastTokenPaste = 0;\n  unsigned NumSkipped = 0;\n\n  /// The predefined macros that preprocessor should use from the\n  /// command line etc.\n  std::string Predefines;\n\n  /// The file ID for the preprocessor predefines.\n  FileID PredefinesFileID;\n\n  /// The file ID for the PCH through header.\n  FileID PCHThroughHeaderFileID;\n\n  /// Whether tokens are being skipped until a #pragma hdrstop is seen.\n  bool SkippingUntilPragmaHdrStop = false;\n\n  /// Whether tokens are being skipped until the through header is seen.\n  bool SkippingUntilPCHThroughHeader = false;\n\n  /// \\{\n  /// Cache of macro expanders to reduce malloc traffic.\n  enum { TokenLexerCacheSize = 8 };\n  unsigned NumCachedTokenLexers;\n  std::unique_ptr<TokenLexer> TokenLexerCache[TokenLexerCacheSize];\n  /// \\}\n\n  /// Keeps macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  SmallVector<Token, 16> MacroExpandedTokens;\n  std::vector<std::pair<TokenLexer *, size_t>> MacroExpandingLexersStack;\n\n  /// A record of the macro definitions and expansions that\n  /// occurred during preprocessing.\n  ///\n  /// This is an optional side structure that can be enabled with\n  /// \\c createPreprocessingRecord() prior to preprocessing.\n  PreprocessingRecord *Record = nullptr;\n\n  /// Cached tokens state.\n  using CachedTokensTy = SmallVector<Token, 1>;\n\n  /// Cached tokens are stored here when we do backtracking or\n  /// lookahead. They are \"lexed\" by the CachingLex() method.\n  CachedTokensTy CachedTokens;\n\n  /// The position of the cached token that CachingLex() should\n  /// \"lex\" next.\n  ///\n  /// If it points beyond the CachedTokens vector, it means that a normal\n  /// Lex() should be invoked.\n  CachedTokensTy::size_type CachedLexPos = 0;\n\n  /// Stack of backtrack positions, allowing nested backtracks.\n  ///\n  /// The EnableBacktrackAtThisPos() method pushes a position to\n  /// indicate where CachedLexPos should be set when the BackTrack() method is\n  /// invoked (at which point the last position is popped).\n  std::vector<CachedTokensTy::size_type> BacktrackPositions;\n\n  struct MacroInfoChain {\n    MacroInfo MI;\n    MacroInfoChain *Next;\n  };\n\n  /// MacroInfos are managed as a chain for easy disposal.  This is the head\n  /// of that list.\n  MacroInfoChain *MIChainHead = nullptr;\n\n  void updateOutOfDateIdentifier(IdentifierInfo &II) const;\n\npublic:\n  Preprocessor(std::shared_ptr<PreprocessorOptions> PPOpts,\n               DiagnosticsEngine &diags, LangOptions &opts, SourceManager &SM,\n               HeaderSearch &Headers, ModuleLoader &TheModuleLoader,\n               IdentifierInfoLookup *IILookup = nullptr,\n               bool OwnsHeaderSearch = false,\n               TranslationUnitKind TUKind = TU_Complete);\n\n  ~Preprocessor();\n\n  /// Initialize the preprocessor using information about the target.\n  ///\n  /// \\param Target is owned by the caller and must remain valid for the\n  /// lifetime of the preprocessor.\n  /// \\param AuxTarget is owned by the caller and must remain valid for\n  /// the lifetime of the preprocessor.\n  void Initialize(const TargetInfo &Target,\n                  const TargetInfo *AuxTarget = nullptr);\n\n  /// Initialize the preprocessor to parse a model file\n  ///\n  /// To parse model files the preprocessor of the original source is reused to\n  /// preserver the identifier table. However to avoid some duplicate\n  /// information in the preprocessor some cleanup is needed before it is used\n  /// to parse model files. This method does that cleanup.\n  void InitializeForModelFile();\n\n  /// Cleanup after model file parsing\n  void FinalizeForModelFile();\n\n  /// Retrieve the preprocessor options used to initialize this\n  /// preprocessor.\n  PreprocessorOptions &getPreprocessorOpts() const { return *PPOpts; }\n\n  DiagnosticsEngine &getDiagnostics() const { return *Diags; }\n  void setDiagnostics(DiagnosticsEngine &D) { Diags = &D; }\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n  FileManager &getFileManager() const { return FileMgr; }\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  HeaderSearch &getHeaderSearchInfo() const { return HeaderInfo; }\n\n  IdentifierTable &getIdentifierTable() { return Identifiers; }\n  const IdentifierTable &getIdentifierTable() const { return Identifiers; }\n  SelectorTable &getSelectorTable() { return Selectors; }\n  Builtin::Context &getBuiltinInfo() { return *BuiltinInfo; }\n  llvm::BumpPtrAllocator &getPreprocessorAllocator() { return BP; }\n\n  void setExternalSource(ExternalPreprocessorSource *Source) {\n    ExternalSource = Source;\n  }\n\n  ExternalPreprocessorSource *getExternalSource() const {\n    return ExternalSource;\n  }\n\n  /// Retrieve the module loader associated with this preprocessor.\n  ModuleLoader &getModuleLoader() const { return TheModuleLoader; }\n\n  bool hadModuleLoaderFatalFailure() const {\n    return TheModuleLoader.HadFatalFailure;\n  }\n\n  /// Retrieve the number of Directives that have been processed by the\n  /// Preprocessor.\n  unsigned getNumDirectives() const {\n    return NumDirectives;\n  }\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool isParsingIfOrElifDirective() const {\n    return ParsingIfOrElifDirective;\n  }\n\n  /// Control whether the preprocessor retains comments in output.\n  void SetCommentRetentionState(bool KeepComments, bool KeepMacroComments) {\n    this->KeepComments = KeepComments | KeepMacroComments;\n    this->KeepMacroComments = KeepMacroComments;\n  }\n\n  bool getCommentRetentionState() const { return KeepComments; }\n\n  void setPragmasEnabled(bool Enabled) { PragmasEnabled = Enabled; }\n  bool getPragmasEnabled() const { return PragmasEnabled; }\n\n  void SetSuppressIncludeNotFoundError(bool Suppress) {\n    SuppressIncludeNotFoundError = Suppress;\n  }\n\n  bool GetSuppressIncludeNotFoundError() {\n    return SuppressIncludeNotFoundError;\n  }\n\n  /// Sets whether the preprocessor is responsible for producing output or if\n  /// it is producing tokens to be consumed by Parse and Sema.\n  void setPreprocessedOutput(bool IsPreprocessedOutput) {\n    PreprocessedOutput = IsPreprocessedOutput;\n  }\n\n  /// Returns true if the preprocessor is responsible for generating output,\n  /// false if it is producing tokens to be consumed by Parse and Sema.\n  bool isPreprocessedOutput() const { return PreprocessedOutput; }\n\n  /// Return true if we are lexing directly from the specified lexer.\n  bool isCurrentLexer(const PreprocessorLexer *L) const {\n    return CurPPLexer == L;\n  }\n\n  /// Return the current lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentLexer() const { return CurPPLexer; }\n\n  /// Return the current file lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentFileLexer() const;\n\n  /// Return the submodule owning the file being lexed. This may not be\n  /// the current module if we have changed modules since entering the file.\n  Module *getCurrentLexerSubmodule() const { return CurLexerSubmodule; }\n\n  /// Returns the FileID for the preprocessor predefines.\n  FileID getPredefinesFileID() const { return PredefinesFileID; }\n\n  /// \\{\n  /// Accessors for preprocessor callbacks.\n  ///\n  /// Note that this class takes ownership of any PPCallbacks object given to\n  /// it.\n  PPCallbacks *getPPCallbacks() const { return Callbacks.get(); }\n  void addPPCallbacks(std::unique_ptr<PPCallbacks> C) {\n    if (Callbacks)\n      C = std::make_unique<PPChainedCallbacks>(std::move(C),\n                                                std::move(Callbacks));\n    Callbacks = std::move(C);\n  }\n  /// \\}\n\n  /// Get the number of tokens processed so far.\n  unsigned getTokenCount() const { return TokenCount; }\n\n  /// Get the max number of tokens before issuing a -Wmax-tokens warning.\n  unsigned getMaxTokens() const { return MaxTokens; }\n\n  void overrideMaxTokens(unsigned Value, SourceLocation Loc) {\n    MaxTokens = Value;\n    MaxTokensOverrideLoc = Loc;\n  };\n\n  SourceLocation getMaxTokensOverrideLoc() const { return MaxTokensOverrideLoc; }\n\n  /// Register a function that would be called on each token in the final\n  /// expanded token stream.\n  /// This also reports annotation tokens produced by the parser.\n  void setTokenWatcher(llvm::unique_function<void(const clang::Token &)> F) {\n    OnToken = std::move(F);\n  }\n\n  void setPreprocessToken(bool Preprocess) { PreprocessToken = Preprocess; }\n\n  bool isMacroDefined(StringRef Id) {\n    return isMacroDefined(&Identifiers.get(Id));\n  }\n  bool isMacroDefined(const IdentifierInfo *II) {\n    return II->hasMacroDefinition() &&\n           (!getLangOpts().Modules || (bool)getMacroDefinition(II));\n  }\n\n  /// Determine whether II is defined as a macro within the module M,\n  /// if that is a module that we've already preprocessed. Does not check for\n  /// macros imported into M.\n  bool isMacroDefinedInLocalModule(const IdentifierInfo *II, Module *M) {\n    if (!II->hasMacroDefinition())\n      return false;\n    auto I = Submodules.find(M);\n    if (I == Submodules.end())\n      return false;\n    auto J = I->second.Macros.find(II);\n    if (J == I->second.Macros.end())\n      return false;\n    auto *MD = J->second.getLatest();\n    return MD && MD->isDefined();\n  }\n\n  MacroDefinition getMacroDefinition(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    auto *MD = S.getLatest();\n    while (MD && isa<VisibilityMacroDirective>(MD))\n      MD = MD->getPrevious();\n    return MacroDefinition(dyn_cast_or_null<DefMacroDirective>(MD),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  MacroDefinition getMacroDefinitionAtLoc(const IdentifierInfo *II,\n                                          SourceLocation Loc) {\n    if (!II->hadMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    MacroDirective::DefInfo DI;\n    if (auto *MD = S.getLatest())\n      DI = MD->findDirectiveAtLoc(Loc, getSourceManager());\n    // FIXME: Compute the set of active module macros at the specified location.\n    return MacroDefinition(DI.getDirective(),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  /// Given an identifier, return its latest non-imported MacroDirective\n  /// if it is \\#define'd and not \\#undef'd, or null if it isn't \\#define'd.\n  MacroDirective *getLocalMacroDirective(const IdentifierInfo *II) const {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n\n    auto *MD = getLocalMacroDirectiveHistory(II);\n    if (!MD || MD->getDefinition().isUndefined())\n      return nullptr;\n\n    return MD;\n  }\n\n  const MacroInfo *getMacroInfo(const IdentifierInfo *II) const {\n    return const_cast<Preprocessor*>(this)->getMacroInfo(II);\n  }\n\n  MacroInfo *getMacroInfo(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n    if (auto MD = getMacroDefinition(II))\n      return MD.getMacroInfo();\n    return nullptr;\n  }\n\n  /// Given an identifier, return the latest non-imported macro\n  /// directive for that identifier.\n  ///\n  /// One can iterate over all previous macro directives from the most recent\n  /// one.\n  MacroDirective *getLocalMacroDirectiveHistory(const IdentifierInfo *II) const;\n\n  /// Add a directive to the macro directive history for this identifier.\n  void appendMacroDirective(IdentifierInfo *II, MacroDirective *MD);\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II, MacroInfo *MI,\n                                             SourceLocation Loc) {\n    DefMacroDirective *MD = AllocateDefMacroDirective(MI, Loc);\n    appendMacroDirective(II, MD);\n    return MD;\n  }\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II,\n                                             MacroInfo *MI) {\n    return appendDefMacroDirective(II, MI, MI->getDefinitionLoc());\n  }\n\n  /// Set a MacroDirective that was loaded from a PCH file.\n  void setLoadedMacroDirective(IdentifierInfo *II, MacroDirective *ED,\n                               MacroDirective *MD);\n\n  /// Register an exported macro for a module and identifier.\n  ModuleMacro *addModuleMacro(Module *Mod, IdentifierInfo *II, MacroInfo *Macro,\n                              ArrayRef<ModuleMacro *> Overrides, bool &IsNew);\n  ModuleMacro *getModuleMacro(Module *Mod, IdentifierInfo *II);\n\n  /// Get the list of leaf (non-overridden) module macros for a name.\n  ArrayRef<ModuleMacro*> getLeafModuleMacros(const IdentifierInfo *II) const {\n    if (II->isOutOfDate())\n      updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n    auto I = LeafModuleMacros.find(II);\n    if (I != LeafModuleMacros.end())\n      return I->second;\n    return None;\n  }\n\n  /// \\{\n  /// Iterators for the macro history table. Currently defined macros have\n  /// IdentifierInfo::hasMacroDefinition() set and an empty\n  /// MacroInfo::getUndefLoc() at the head of the list.\n  using macro_iterator = MacroMap::const_iterator;\n\n  macro_iterator macro_begin(bool IncludeExternalMacros = true) const;\n  macro_iterator macro_end(bool IncludeExternalMacros = true) const;\n\n  llvm::iterator_range<macro_iterator>\n  macros(bool IncludeExternalMacros = true) const {\n    macro_iterator begin = macro_begin(IncludeExternalMacros);\n    macro_iterator end = macro_end(IncludeExternalMacros);\n    return llvm::make_range(begin, end);\n  }\n\n  /// \\}\n\n  /// Return the name of the macro defined before \\p Loc that has\n  /// spelling \\p Tokens.  If there are multiple macros with same spelling,\n  /// return the last one defined.\n  StringRef getLastMacroWithSpelling(SourceLocation Loc,\n                                     ArrayRef<TokenValue> Tokens) const;\n\n  const std::string &getPredefines() const { return Predefines; }\n\n  /// Set the predefines for this Preprocessor.\n  ///\n  /// These predefines are automatically injected when parsing the main file.\n  void setPredefines(const char *P) { Predefines = P; }\n  void setPredefines(StringRef P) { Predefines = std::string(P); }\n\n  /// Return information about the specified preprocessor\n  /// identifier token.\n  IdentifierInfo *getIdentifierInfo(StringRef Name) const {\n    return &Identifiers.get(Name);\n  }\n\n  /// Add the specified pragma handler to this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it is a token required to exist on the\n  /// pragma line before the pragma string starts, e.g. \"STDC\" or \"GCC\".\n  void AddPragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void AddPragmaHandler(PragmaHandler *Handler) {\n    AddPragmaHandler(StringRef(), Handler);\n  }\n\n  /// Remove the specific pragma handler from this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it should be the namespace that\n  /// \\p Handler was added to. It is an error to remove a handler that\n  /// has not been registered.\n  void RemovePragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void RemovePragmaHandler(PragmaHandler *Handler) {\n    RemovePragmaHandler(StringRef(), Handler);\n  }\n\n  /// Install empty handlers for all pragmas (making them ignored).\n  void IgnorePragmas();\n\n  /// Set empty line handler.\n  void setEmptylineHandler(EmptylineHandler *Handler) { Emptyline = Handler; }\n\n  EmptylineHandler *getEmptylineHandler() const { return Emptyline; }\n\n  /// Add the specified comment handler to the preprocessor.\n  void addCommentHandler(CommentHandler *Handler);\n\n  /// Remove the specified comment handler.\n  ///\n  /// It is an error to remove a handler that has not been registered.\n  void removeCommentHandler(CommentHandler *Handler);\n\n  /// Set the code completion handler to the given object.\n  void setCodeCompletionHandler(CodeCompletionHandler &Handler) {\n    CodeComplete = &Handler;\n  }\n\n  /// Retrieve the current code-completion handler.\n  CodeCompletionHandler *getCodeCompletionHandler() const {\n    return CodeComplete;\n  }\n\n  /// Clear out the code completion handler.\n  void clearCodeCompletionHandler() {\n    CodeComplete = nullptr;\n  }\n\n  /// Hook used by the lexer to invoke the \"included file\" code\n  /// completion point.\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);\n\n  /// Hook used by the lexer to invoke the \"natural language\" code\n  /// completion point.\n  void CodeCompleteNaturalLanguage();\n\n  /// Set the code completion token for filtering purposes.\n  void setCodeCompletionIdentifierInfo(IdentifierInfo *Filter) {\n    CodeCompletionII = Filter;\n  }\n\n  /// Set the code completion token range for detecting replacement range later\n  /// on.\n  void setCodeCompletionTokenRange(const SourceLocation Start,\n                                   const SourceLocation End) {\n    CodeCompletionTokenRange = {Start, End};\n  }\n  SourceRange getCodeCompletionTokenRange() const {\n    return CodeCompletionTokenRange;\n  }\n\n  /// Get the code completion token for filtering purposes.\n  StringRef getCodeCompletionFilter() {\n    if (CodeCompletionII)\n      return CodeCompletionII->getName();\n    return {};\n  }\n\n  /// Retrieve the preprocessing record, or NULL if there is no\n  /// preprocessing record.\n  PreprocessingRecord *getPreprocessingRecord() const { return Record; }\n\n  /// Create a new preprocessing record, which will keep track of\n  /// all macro expansions, macro definitions, etc.\n  void createPreprocessingRecord();\n\n  /// Returns true if the FileEntry is the PCH through header.\n  bool isPCHThroughHeader(const FileEntry *FE);\n\n  /// True if creating a PCH with a through header.\n  bool creatingPCHWithThroughHeader();\n\n  /// True if using a PCH with a through header.\n  bool usingPCHWithThroughHeader();\n\n  /// True if creating a PCH with a #pragma hdrstop.\n  bool creatingPCHWithPragmaHdrStop();\n\n  /// True if using a PCH with a #pragma hdrstop.\n  bool usingPCHWithPragmaHdrStop();\n\n  /// Skip tokens until after the #include of the through header or\n  /// until after a #pragma hdrstop.\n  void SkipTokensWhileUsingPCH();\n\n  /// Process directives while skipping until the through header or\n  /// #pragma hdrstop is found.\n  void HandleSkippedDirectiveWhileUsingPCH(Token &Result,\n                                           SourceLocation HashLoc);\n\n  /// Enter the specified FileID as the main source file,\n  /// which implicitly adds the builtin defines etc.\n  void EnterMainSourceFile();\n\n  /// Inform the preprocessor callbacks that processing is complete.\n  void EndSourceFile();\n\n  /// Add a source file to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  ///\n  /// Emits a diagnostic, doesn't enter the file, and returns true on error.\n  bool EnterSourceFile(FileID FID, const DirectoryLookup *Dir,\n                       SourceLocation Loc);\n\n  /// Add a Macro to the top of the include stack and start lexing\n  /// tokens from it instead of the current buffer.\n  ///\n  /// \\param Args specifies the tokens input to a function-like macro.\n  /// \\param ILEnd specifies the location of the ')' for a function-like macro\n  /// or the identifier for an object-like macro.\n  void EnterMacro(Token &Tok, SourceLocation ILEnd, MacroInfo *Macro,\n                  MacroArgs *Args);\n\nprivate:\n  /// Add a \"macro\" context to the top of the include stack,\n  /// which will cause the lexer to start returning the specified tokens.\n  ///\n  /// If \\p DisableMacroExpansion is true, tokens lexed from the token stream\n  /// will not be subject to further macro expansion. Otherwise, these tokens\n  /// will be re-macro-expanded when/if expansion is enabled.\n  ///\n  /// If \\p OwnsTokens is false, this method assumes that the specified stream\n  /// of tokens has a permanent owner somewhere, so they do not need to be\n  /// copied. If it is true, it assumes the array of tokens is allocated with\n  /// \\c new[] and the Preprocessor will delete[] it.\n  ///\n  /// If \\p IsReinject the resulting tokens will have Token::IsReinjected flag\n  /// set, see the flag documentation for details.\n  void EnterTokenStream(const Token *Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool OwnsTokens,\n                        bool IsReinject);\n\npublic:\n  void EnterTokenStream(std::unique_ptr<Token[]> Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool IsReinject) {\n    EnterTokenStream(Toks.release(), NumToks, DisableMacroExpansion, true,\n                     IsReinject);\n  }\n\n  void EnterTokenStream(ArrayRef<Token> Toks, bool DisableMacroExpansion,\n                        bool IsReinject) {\n    EnterTokenStream(Toks.data(), Toks.size(), DisableMacroExpansion, false,\n                     IsReinject);\n  }\n\n  /// Pop the current lexer/macro exp off the top of the lexer stack.\n  ///\n  /// This should only be used in situations where the current state of the\n  /// top-of-stack lexer is known.\n  void RemoveTopOfLexerStack();\n\n  /// From the point that this method is called, and until\n  /// CommitBacktrackedTokens() or Backtrack() is called, the Preprocessor\n  /// keeps track of the lexed tokens so that a subsequent Backtrack() call will\n  /// make the Preprocessor re-lex the same tokens.\n  ///\n  /// Nested backtracks are allowed, meaning that EnableBacktrackAtThisPos can\n  /// be called multiple times and CommitBacktrackedTokens/Backtrack calls will\n  /// be combined with the EnableBacktrackAtThisPos calls in reverse order.\n  ///\n  /// NOTE: *DO NOT* forget to call either CommitBacktrackedTokens or Backtrack\n  /// at some point after EnableBacktrackAtThisPos. If you don't, caching of\n  /// tokens will continue indefinitely.\n  ///\n  void EnableBacktrackAtThisPos();\n\n  /// Disable the last EnableBacktrackAtThisPos call.\n  void CommitBacktrackedTokens();\n\n  /// Make Preprocessor re-lex the tokens that were lexed since\n  /// EnableBacktrackAtThisPos() was previously called.\n  void Backtrack();\n\n  /// True if EnableBacktrackAtThisPos() was called and\n  /// caching of tokens is on.\n  bool isBacktrackEnabled() const { return !BacktrackPositions.empty(); }\n\n  /// Lex the next token for this preprocessor.\n  void Lex(Token &Result);\n\n  /// Lex a token, forming a header-name token if possible.\n  bool LexHeaderName(Token &Result, bool AllowMacroExpansion = true);\n\n  bool LexAfterModuleImport(Token &Result);\n  void CollectPpImportSuffix(SmallVectorImpl<Token> &Toks);\n\n  void makeModuleVisible(Module *M, SourceLocation Loc);\n\n  SourceLocation getModuleImportLoc(Module *M) const {\n    return CurSubmoduleState->VisibleModules.getImportLoc(M);\n  }\n\n  /// Lex a string literal, which may be the concatenation of multiple\n  /// string literals and may even come from macro expansion.\n  /// \\returns true on success, false if a error diagnostic has been generated.\n  bool LexStringLiteral(Token &Result, std::string &String,\n                        const char *DiagnosticTag, bool AllowMacroExpansion) {\n    if (AllowMacroExpansion)\n      Lex(Result);\n    else\n      LexUnexpandedToken(Result);\n    return FinishLexStringLiteral(Result, String, DiagnosticTag,\n                                  AllowMacroExpansion);\n  }\n\n  /// Complete the lexing of a string literal where the first token has\n  /// already been lexed (see LexStringLiteral).\n  bool FinishLexStringLiteral(Token &Result, std::string &String,\n                              const char *DiagnosticTag,\n                              bool AllowMacroExpansion);\n\n  /// Lex a token.  If it's a comment, keep lexing until we get\n  /// something not a comment.\n  ///\n  /// This is useful in -E -C mode where comments would foul up preprocessor\n  /// directive handling.\n  void LexNonComment(Token &Result) {\n    do\n      Lex(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Just like Lex, but disables macro expansion of identifier tokens.\n  void LexUnexpandedToken(Token &Result) {\n    // Disable macro expansion.\n    bool OldVal = DisableMacroExpansion;\n    DisableMacroExpansion = true;\n    // Lex the token.\n    Lex(Result);\n\n    // Reenable it.\n    DisableMacroExpansion = OldVal;\n  }\n\n  /// Like LexNonComment, but this disables macro expansion of\n  /// identifier tokens.\n  void LexUnexpandedNonComment(Token &Result) {\n    do\n      LexUnexpandedToken(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Parses a simple integer literal to get its numeric value.  Floating\n  /// point literals and user defined literals are rejected.  Used primarily to\n  /// handle pragmas that accept integer arguments.\n  bool parseSimpleIntegerLiteral(Token &Tok, uint64_t &Value);\n\n  /// Disables macro expansion everywhere except for preprocessor directives.\n  void SetMacroExpansionOnlyInDirectives() {\n    DisableMacroExpansion = true;\n    MacroExpansionInDirectivesOverride = true;\n  }\n\n  /// Peeks ahead N tokens and returns that token without consuming any\n  /// tokens.\n  ///\n  /// LookAhead(0) returns the next token that would be returned by Lex(),\n  /// LookAhead(1) returns the token after it, etc.  This returns normal\n  /// tokens after phase 5.  As such, it is equivalent to using\n  /// 'Lex', not 'LexUnexpandedToken'.\n  const Token &LookAhead(unsigned N) {\n    assert(LexLevel == 0 && \"cannot use lookahead while lexing\");\n    if (CachedLexPos + N < CachedTokens.size())\n      return CachedTokens[CachedLexPos+N];\n    else\n      return PeekAhead(N+1);\n  }\n\n  /// When backtracking is enabled and tokens are cached,\n  /// this allows to revert a specific number of tokens.\n  ///\n  /// Note that the number of tokens being reverted should be up to the last\n  /// backtrack position, not more.\n  void RevertCachedTokens(unsigned N) {\n    assert(isBacktrackEnabled() &&\n           \"Should only be called when tokens are cached for backtracking\");\n    assert(signed(CachedLexPos) - signed(N) >= signed(BacktrackPositions.back())\n         && \"Should revert tokens up to the last backtrack position, not more\");\n    assert(signed(CachedLexPos) - signed(N) >= 0 &&\n           \"Corrupted backtrack positions ?\");\n    CachedLexPos -= N;\n  }\n\n  /// Enters a token in the token stream to be lexed next.\n  ///\n  /// If BackTrack() is called afterwards, the token will remain at the\n  /// insertion point.\n  /// If \\p IsReinject is true, resulting token will have Token::IsReinjected\n  /// flag set. See the flag documentation for details.\n  void EnterToken(const Token &Tok, bool IsReinject) {\n    if (LexLevel) {\n      // It's not correct in general to enter caching lex mode while in the\n      // middle of a nested lexing action.\n      auto TokCopy = std::make_unique<Token[]>(1);\n      TokCopy[0] = Tok;\n      EnterTokenStream(std::move(TokCopy), 1, true, IsReinject);\n    } else {\n      EnterCachingLexMode();\n      assert(IsReinject && \"new tokens in the middle of cached stream\");\n      CachedTokens.insert(CachedTokens.begin()+CachedLexPos, Tok);\n    }\n  }\n\n  /// We notify the Preprocessor that if it is caching tokens (because\n  /// backtrack is enabled) it should replace the most recent cached tokens\n  /// with the given annotation token. This function has no effect if\n  /// backtracking is not enabled.\n  ///\n  /// Note that the use of this function is just for optimization, so that the\n  /// cached tokens doesn't get re-parsed and re-resolved after a backtrack is\n  /// invoked.\n  void AnnotateCachedTokens(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      AnnotatePreviousCachedTokens(Tok);\n  }\n\n  /// Get the location of the last cached token, suitable for setting the end\n  /// location of an annotation token.\n  SourceLocation getLastCachedTokenLocation() const {\n    assert(CachedLexPos != 0);\n    return CachedTokens[CachedLexPos-1].getLastLoc();\n  }\n\n  /// Whether \\p Tok is the most recent token (`CachedLexPos - 1`) in\n  /// CachedTokens.\n  bool IsPreviousCachedToken(const Token &Tok) const;\n\n  /// Replace token in `CachedLexPos - 1` in CachedTokens by the tokens\n  /// in \\p NewToks.\n  ///\n  /// Useful when a token needs to be split in smaller ones and CachedTokens\n  /// most recent token must to be updated to reflect that.\n  void ReplacePreviousCachedToken(ArrayRef<Token> NewToks);\n\n  /// Replace the last token with an annotation token.\n  ///\n  /// Like AnnotateCachedTokens(), this routine replaces an\n  /// already-parsed (and resolved) token with an annotation\n  /// token. However, this routine only replaces the last token with\n  /// the annotation token; it does not affect any other cached\n  /// tokens. This function has no effect if backtracking is not\n  /// enabled.\n  void ReplaceLastTokenWithAnnotation(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Enter an annotation token into the token stream.\n  void EnterAnnotationToken(SourceRange Range, tok::TokenKind Kind,\n                            void *AnnotationVal);\n\n  /// Determine whether it's possible for a future call to Lex to produce an\n  /// annotation token created by a previous call to EnterAnnotationToken.\n  bool mightHavePendingAnnotationTokens() {\n    return CurLexerKind != CLK_Lexer;\n  }\n\n  /// Update the current token to represent the provided\n  /// identifier, in order to cache an action performed by typo correction.\n  void TypoCorrectToken(const Token &Tok) {\n    assert(Tok.getIdentifierInfo() && \"Expected identifier token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Recompute the current lexer kind based on the CurLexer/\n  /// CurTokenLexer pointers.\n  void recomputeCurLexerKind();\n\n  /// Returns true if incremental processing is enabled\n  bool isIncrementalProcessingEnabled() const { return IncrementalProcessing; }\n\n  /// Enables the incremental processing\n  void enableIncrementalProcessing(bool value = true) {\n    IncrementalProcessing = value;\n  }\n\n  /// Specify the point at which code-completion will be performed.\n  ///\n  /// \\param File the file in which code completion should occur. If\n  /// this file is included multiple times, code-completion will\n  /// perform completion the first time it is included. If NULL, this\n  /// function clears out the code-completion point.\n  ///\n  /// \\param Line the line at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\param Column the column at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool SetCodeCompletionPoint(const FileEntry *File,\n                              unsigned Line, unsigned Column);\n\n  /// Determine if we are performing code completion.\n  bool isCodeCompletionEnabled() const { return CodeCompletionFile != nullptr; }\n\n  /// Returns the location of the code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionLoc() const { return CodeCompletionLoc; }\n\n  /// Returns the start location of the file of code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionFileLoc() const {\n    return CodeCompletionFileLoc;\n  }\n\n  /// Returns true if code-completion is enabled and we have hit the\n  /// code-completion point.\n  bool isCodeCompletionReached() const { return CodeCompletionReached; }\n\n  /// Note that we hit the code-completion point.\n  void setCodeCompletionReached() {\n    assert(isCodeCompletionEnabled() && \"Code-completion not enabled!\");\n    CodeCompletionReached = true;\n    // Silence any diagnostics that occur after we hit the code-completion.\n    getDiagnostics().setSuppressAllDiagnostics(true);\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  std::pair<IdentifierInfo *, SourceLocation>\n  getPragmaARCCFCodeAuditedInfo() const {\n    return PragmaARCCFCodeAuditedInfo;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.  An invalid location ends the pragma.\n  void setPragmaARCCFCodeAuditedInfo(IdentifierInfo *Ident,\n                                     SourceLocation Loc) {\n    PragmaARCCFCodeAuditedInfo = {Ident, Loc};\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  SourceLocation getPragmaAssumeNonNullLoc() const {\n    return PragmaAssumeNonNullLoc;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.  An invalid location ends the pragma.\n  void setPragmaAssumeNonNullLoc(SourceLocation Loc) {\n    PragmaAssumeNonNullLoc = Loc;\n  }\n\n  /// Set the directory in which the main file should be considered\n  /// to have been found, if it is not a real file.\n  void setMainFileDir(const DirectoryEntry *Dir) {\n    MainFileDir = Dir;\n  }\n\n  /// Instruct the preprocessor to skip part of the main source file.\n  ///\n  /// \\param Bytes The number of bytes in the preamble to skip.\n  ///\n  /// \\param StartOfLine Whether skipping these bytes puts the lexer at the\n  /// start of a line.\n  void setSkipMainFilePreamble(unsigned Bytes, bool StartOfLine) {\n    SkipMainFilePreamble.first = Bytes;\n    SkipMainFilePreamble.second = StartOfLine;\n  }\n\n  /// Forwarding function for diagnostics.  This emits a diagnostic at\n  /// the specified Token's location, translating the token's start\n  /// position in the current buffer into a SourcePosition object for rendering.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const {\n    return Diags->Report(Loc, DiagID);\n  }\n\n  DiagnosticBuilder Diag(const Token &Tok, unsigned DiagID) const {\n    return Diags->Report(Tok.getLocation(), DiagID);\n  }\n\n  /// Return the 'spelling' of the token at the given\n  /// location; does not go up to the spelling location or down to the\n  /// expansion location.\n  ///\n  /// \\param buffer A buffer which will be used only if the token requires\n  ///   \"cleaning\", e.g. if it contains trigraphs or escaped newlines\n  /// \\param invalid If non-null, will be set \\c true if an error occurs.\n  StringRef getSpelling(SourceLocation loc,\n                        SmallVectorImpl<char> &buffer,\n                        bool *invalid = nullptr) const {\n    return Lexer::getSpelling(loc, buffer, SourceMgr, LangOpts, invalid);\n  }\n\n  /// Return the 'spelling' of the Tok token.\n  ///\n  /// The spelling of a token is the characters used to represent the token in\n  /// the source file after trigraph expansion and escaped-newline folding.  In\n  /// particular, this wants to get the true, uncanonicalized, spelling of\n  /// things like digraphs, UCNs, etc.\n  ///\n  /// \\param Invalid If non-null, will be set \\c true if an error occurs.\n  std::string getSpelling(const Token &Tok, bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a preallocated buffer, instead\n  /// of as an std::string.\n  ///\n  /// The caller is required to allocate enough space for the token, which is\n  /// guaranteed to be at least Tok.getLength() bytes long. The length of the\n  /// actual result is returned.\n  ///\n  /// Note that this method may do two possible things: it may either fill in\n  /// the buffer specified with characters, or it may *change the input pointer*\n  /// to point to a constant buffer with the data already in it (avoiding a\n  /// copy).  The caller is not allowed to modify the returned buffer pointer\n  /// if an internal buffer is returned.\n  unsigned getSpelling(const Token &Tok, const char *&Buffer,\n                       bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, Buffer, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a SmallVector.\n  ///\n  /// Note that the returned StringRef may not point to the\n  /// supplied buffer if a copy can be avoided.\n  StringRef getSpelling(const Token &Tok,\n                        SmallVectorImpl<char> &Buffer,\n                        bool *Invalid = nullptr) const;\n\n  /// Relex the token at the specified location.\n  /// \\returns true if there was a failure, false on success.\n  bool getRawToken(SourceLocation Loc, Token &Result,\n                   bool IgnoreWhiteSpace = false) {\n    return Lexer::getRawToken(Loc, Result, SourceMgr, LangOpts, IgnoreWhiteSpace);\n  }\n\n  /// Given a Token \\p Tok that is a numeric constant with length 1,\n  /// return the character.\n  char\n  getSpellingOfSingleCharacterNumericConstant(const Token &Tok,\n                                              bool *Invalid = nullptr) const {\n    assert(Tok.is(tok::numeric_constant) &&\n           Tok.getLength() == 1 && \"Called on unsupported token\");\n    assert(!Tok.needsCleaning() && \"Token can't need cleaning with length 1\");\n\n    // If the token is carrying a literal data pointer, just use it.\n    if (const char *D = Tok.getLiteralData())\n      return *D;\n\n    // Otherwise, fall back on getCharacterData, which is slower, but always\n    // works.\n    return *SourceMgr.getCharacterData(Tok.getLocation(), Invalid);\n  }\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the\n  /// macro responsible for its immediate expansion. It looks through any\n  /// intervening macro argument expansions to compute this. It returns a\n  /// StringRef that refers to the SourceManager-owned buffer of the source\n  /// where that macro name is spelled. Thus, the result shouldn't out-live\n  /// the SourceManager.\n  StringRef getImmediateMacroName(SourceLocation Loc) {\n    return Lexer::getImmediateMacroName(Loc, SourceMgr, getLangOpts());\n  }\n\n  /// Plop the specified string into a scratch buffer and set the\n  /// specified token's location and length to it.\n  ///\n  /// If specified, the source location provides a location of the expansion\n  /// point of the token.\n  void CreateString(StringRef Str, Token &Tok,\n                    SourceLocation ExpansionLocStart = SourceLocation(),\n                    SourceLocation ExpansionLocEnd = SourceLocation());\n\n  /// Split the first Length characters out of the token starting at TokLoc\n  /// and return a location pointing to the split token. Re-lexing from the\n  /// split token will return the split token rather than the original.\n  SourceLocation SplitToken(SourceLocation TokLoc, unsigned Length);\n\n  /// Computes the source location just past the end of the\n  /// token at this source location.\n  ///\n  /// This routine can be used to produce a source location that\n  /// points just past the end of the token referenced by \\p Loc, and\n  /// is generally used when a diagnostic needs to point just after a\n  /// token where it expected something different that it received. If\n  /// the returned source location would not be meaningful (e.g., if\n  /// it points into a macro), this routine returns an invalid\n  /// source location.\n  ///\n  /// \\param Offset an offset from the end of the token, where the source\n  /// location should refer to. The default offset (0) produces a source\n  /// location pointing just past the end of the token; an offset of 1 produces\n  /// a source location pointing to the last character in the token, etc.\n  SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset = 0) {\n    return Lexer::getLocForEndOfToken(Loc, Offset, SourceMgr, LangOpts);\n  }\n\n  /// Returns true if the given MacroID location points at the first\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to\n  /// begin location of the macro.\n  bool isAtStartOfMacroExpansion(SourceLocation loc,\n                                 SourceLocation *MacroBegin = nullptr) const {\n    return Lexer::isAtStartOfMacroExpansion(loc, SourceMgr, LangOpts,\n                                            MacroBegin);\n  }\n\n  /// Returns true if the given MacroID location points at the last\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to\n  /// end location of the macro.\n  bool isAtEndOfMacroExpansion(SourceLocation loc,\n                               SourceLocation *MacroEnd = nullptr) const {\n    return Lexer::isAtEndOfMacroExpansion(loc, SourceMgr, LangOpts, MacroEnd);\n  }\n\n  /// Print the token to stderr, used for debugging.\n  void DumpToken(const Token &Tok, bool DumpFlags = false) const;\n  void DumpLocation(SourceLocation Loc) const;\n  void DumpMacro(const MacroInfo &MI) const;\n  void dumpMacroInfo(const IdentifierInfo *II);\n\n  /// Given a location that specifies the start of a\n  /// token, return a new location that specifies a character within the token.\n  SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,\n                                         unsigned Char) const {\n    return Lexer::AdvanceToTokenCharacter(TokStart, Char, SourceMgr, LangOpts);\n  }\n\n  /// Increment the counters for the number of token paste operations\n  /// performed.\n  ///\n  /// If fast was specified, this is a 'fast paste' case we handled.\n  void IncrementPasteCounter(bool isFast) {\n    if (isFast)\n      ++NumFastTokenPaste;\n    else\n      ++NumTokenPaste;\n  }\n\n  void PrintStats();\n\n  size_t getTotalMemory() const;\n\n  /// When the macro expander pastes together a comment (/##/) in Microsoft\n  /// mode, this method handles updating the current state, returning the\n  /// token on the next source line.\n  void HandleMicrosoftCommentPaste(Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  // Preprocessor callback methods.  These are invoked by a lexer as various\n  // directives and events are found.\n\n  /// Given a tok::raw_identifier token, look up the\n  /// identifier information for the token and install it into the token,\n  /// updating the token kind accordingly.\n  IdentifierInfo *LookUpIdentifierInfo(Token &Identifier) const;\n\nprivate:\n  llvm::DenseMap<IdentifierInfo*,unsigned> PoisonReasons;\n\npublic:\n  /// Specifies the reason for poisoning an identifier.\n  ///\n  /// If that identifier is accessed while poisoned, then this reason will be\n  /// used instead of the default \"poisoned\" diagnostic.\n  void SetPoisonReason(IdentifierInfo *II, unsigned DiagID);\n\n  /// Display reason for poisoned identifier.\n  void HandlePoisonedIdentifier(Token & Identifier);\n\n  void MaybeHandlePoisonedIdentifier(Token & Identifier) {\n    if(IdentifierInfo * II = Identifier.getIdentifierInfo()) {\n      if(II->isPoisoned()) {\n        HandlePoisonedIdentifier(Identifier);\n      }\n    }\n  }\n\nprivate:\n  /// Identifiers used for SEH handling in Borland. These are only\n  /// allowed in particular circumstances\n  // __except block\n  IdentifierInfo *Ident__exception_code,\n                 *Ident___exception_code,\n                 *Ident_GetExceptionCode;\n  // __except filter expression\n  IdentifierInfo *Ident__exception_info,\n                 *Ident___exception_info,\n                 *Ident_GetExceptionInfo;\n  // __finally\n  IdentifierInfo *Ident__abnormal_termination,\n                 *Ident___abnormal_termination,\n                 *Ident_AbnormalTermination;\n\n  const char *getCurLexerEndPos();\n  void diagnoseMissingHeaderInUmbrellaDir(const Module &Mod);\n\npublic:\n  void PoisonSEHIdentifiers(bool Poison = true); // Borland\n\n  /// Callback invoked when the lexer reads an identifier and has\n  /// filled in the tokens IdentifierInfo member.\n  ///\n  /// This callback potentially macro expands it or turns it into a named\n  /// token (like 'for').\n  ///\n  /// \\returns true if we actually computed a token, false if we need to\n  /// lex again.\n  bool HandleIdentifier(Token &Identifier);\n\n  /// Callback invoked when the lexer hits the end of the current file.\n  ///\n  /// This either returns the EOF token and returns true, or\n  /// pops a level off the include stack and returns false, at which point the\n  /// client should call lex again.\n  bool HandleEndOfFile(Token &Result, bool isEndOfMacro = false);\n\n  /// Callback invoked when the current TokenLexer hits the end of its\n  /// token stream.\n  bool HandleEndOfTokenLexer(Token &Result);\n\n  /// Callback invoked when the lexer sees a # token at the start of a\n  /// line.\n  ///\n  /// This consumes the directive, modifies the lexer/preprocessor state, and\n  /// advances the lexer(s) so that the next token read is the correct one.\n  void HandleDirective(Token &Result);\n\n  /// Ensure that the next token is a tok::eod token.\n  ///\n  /// If not, emit a diagnostic and consume up until the eod.\n  /// If \\p EnableMacros is true, then we consider macros that expand to zero\n  /// tokens as being ok.\n  ///\n  /// \\return The location of the end of the directive (the terminating\n  /// newline).\n  SourceLocation CheckEndOfDirective(const char *DirType,\n                                     bool EnableMacros = false);\n\n  /// Read and discard all tokens remaining on the current line until\n  /// the tok::eod token is found. Returns the range of the skipped tokens.\n  SourceRange DiscardUntilEndOfDirective();\n\n  /// Returns true if the preprocessor has seen a use of\n  /// __DATE__ or __TIME__ in the file so far.\n  bool SawDateOrTime() const {\n    return DATELoc != SourceLocation() || TIMELoc != SourceLocation();\n  }\n  unsigned getCounterValue() const { return CounterValue; }\n  void setCounterValue(unsigned V) { CounterValue = V; }\n\n  /// Retrieves the module that we're currently building, if any.\n  Module *getCurrentModule();\n\n  /// Allocate a new MacroInfo object with the provided SourceLocation.\n  MacroInfo *AllocateMacroInfo(SourceLocation L);\n\n  /// Turn the specified lexer token into a fully checked and spelled\n  /// filename, e.g. as an operand of \\#include.\n  ///\n  /// The caller is expected to provide a buffer that is large enough to hold\n  /// the spelling of the filename, but is also expected to handle the case\n  /// when this method decides to use a different buffer.\n  ///\n  /// \\returns true if the input filename was in <>'s or false if it was\n  /// in \"\"'s.\n  bool GetIncludeFilenameSpelling(SourceLocation Loc,StringRef &Buffer);\n\n  /// Given a \"foo\" or \\<foo> reference, look up the indicated file.\n  ///\n  /// Returns None on failure.  \\p isAngled indicates whether the file\n  /// reference is for system \\#include's or not (i.e. using <> instead of \"\").\n  Optional<FileEntryRef>\n  LookupFile(SourceLocation FilenameLoc, StringRef Filename, bool isAngled,\n             const DirectoryLookup *FromDir, const FileEntry *FromFile,\n             const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,\n             SmallVectorImpl<char> *RelativePath,\n             ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,\n             bool *IsFrameworkFound, bool SkipCache = false);\n\n  /// Get the DirectoryLookup structure used to find the current\n  /// FileEntry, if CurLexer is non-null and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *GetCurDirLookup() { return CurDirLookup; }\n\n  /// Return true if we're in the top-level file, not in a \\#include.\n  bool isInPrimaryFile() const;\n\n  /// Lex an on-off-switch (C99 6.10.6p2) and verify that it is\n  /// followed by EOD.  Return true if the token is not a valid on-off-switch.\n  bool LexOnOffSwitch(tok::OnOffSwitch &Result);\n\n  bool CheckMacroName(Token &MacroNameTok, MacroUse isDefineUndef,\n                      bool *ShadowFlag = nullptr);\n\n  void EnterSubmodule(Module *M, SourceLocation ImportLoc, bool ForPragma);\n  Module *LeaveSubmodule(bool ForPragma);\n\nprivate:\n  friend void TokenLexer::ExpandFunctionArguments();\n\n  void PushIncludeMacroStack() {\n    assert(CurLexerKind != CLK_CachingLexer && \"cannot push a caching lexer\");\n    IncludeMacroStack.emplace_back(CurLexerKind, CurLexerSubmodule,\n                                   std::move(CurLexer), CurPPLexer,\n                                   std::move(CurTokenLexer), CurDirLookup);\n    CurPPLexer = nullptr;\n  }\n\n  void PopIncludeMacroStack() {\n    CurLexer = std::move(IncludeMacroStack.back().TheLexer);\n    CurPPLexer = IncludeMacroStack.back().ThePPLexer;\n    CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);\n    CurDirLookup  = IncludeMacroStack.back().TheDirLookup;\n    CurLexerSubmodule = IncludeMacroStack.back().TheSubmodule;\n    CurLexerKind = IncludeMacroStack.back().CurLexerKind;\n    IncludeMacroStack.pop_back();\n  }\n\n  void PropagateLineStartLeadingSpaceInfo(Token &Result);\n\n  /// Determine whether we need to create module macros for #defines in the\n  /// current context.\n  bool needModuleMacros() const;\n\n  /// Update the set of active module macros and ambiguity flag for a module\n  /// macro name.\n  void updateModuleMacroInfo(const IdentifierInfo *II, ModuleMacroInfo &Info);\n\n  DefMacroDirective *AllocateDefMacroDirective(MacroInfo *MI,\n                                               SourceLocation Loc);\n  UndefMacroDirective *AllocateUndefMacroDirective(SourceLocation UndefLoc);\n  VisibilityMacroDirective *AllocateVisibilityMacroDirective(SourceLocation Loc,\n                                                             bool isPublic);\n\n  /// Lex and validate a macro name, which occurs after a\n  /// \\#define or \\#undef.\n  ///\n  /// \\param MacroNameTok Token that represents the name defined or undefined.\n  /// \\param IsDefineUndef Kind if preprocessor directive.\n  /// \\param ShadowFlag Points to flag that is set if macro name shadows\n  ///                   a keyword.\n  ///\n  /// This emits a diagnostic, sets the token kind to eod,\n  /// and discards the rest of the macro line if the macro name is invalid.\n  void ReadMacroName(Token &MacroNameTok, MacroUse IsDefineUndef = MU_Other,\n                     bool *ShadowFlag = nullptr);\n\n  /// ReadOptionalMacroParameterListAndBody - This consumes all (i.e. the\n  /// entire line) of the macro's tokens and adds them to MacroInfo, and while\n  /// doing so performs certain validity checks including (but not limited to):\n  ///   - # (stringization) is followed by a macro parameter\n  /// \\param MacroNameTok - Token that represents the macro name\n  /// \\param ImmediatelyAfterHeaderGuard - Macro follows an #ifdef header guard\n  ///\n  ///  Either returns a pointer to a MacroInfo object OR emits a diagnostic and\n  ///  returns a nullptr if an invalid sequence of tokens is encountered.\n  MacroInfo *ReadOptionalMacroParameterListAndBody(\n      const Token &MacroNameTok, bool ImmediatelyAfterHeaderGuard);\n\n  /// The ( starting an argument list of a macro definition has just been read.\n  /// Lex the rest of the parameters and the closing ), updating \\p MI with\n  /// what we learn and saving in \\p LastTok the last token read.\n  /// Return true if an error occurs parsing the arg list.\n  bool ReadMacroParameterList(MacroInfo *MI, Token& LastTok);\n\n  /// We just read a \\#if or related directive and decided that the\n  /// subsequent tokens are in the \\#if'd out portion of the\n  /// file.  Lex the rest of the file, until we see an \\#endif.  If \\p\n  /// FoundNonSkipPortion is true, then we have already emitted code for part of\n  /// this \\#if directive, so \\#else/\\#elif blocks should never be entered. If\n  /// \\p FoundElse is false, then \\#else directives are ok, if not, then we have\n  /// already seen one so a \\#else directive is a duplicate.  When this returns,\n  /// the caller can lex the first valid token.\n  void SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,\n                                    SourceLocation IfTokenLoc,\n                                    bool FoundNonSkipPortion, bool FoundElse,\n                                    SourceLocation ElseLoc = SourceLocation());\n\n  /// Information about the result for evaluating an expression for a\n  /// preprocessor directive.\n  struct DirectiveEvalResult {\n    /// Whether the expression was evaluated as true or not.\n    bool Conditional;\n\n    /// True if the expression contained identifiers that were undefined.\n    bool IncludedUndefinedIds;\n\n    /// The source range for the expression.\n    SourceRange ExprRange;\n  };\n\n  /// Evaluate an integer constant expression that may occur after a\n  /// \\#if or \\#elif directive and return a \\p DirectiveEvalResult object.\n  ///\n  /// If the expression is equivalent to \"!defined(X)\" return X in IfNDefMacro.\n  DirectiveEvalResult EvaluateDirectiveExpression(IdentifierInfo *&IfNDefMacro);\n\n  /// Install the standard preprocessor pragmas:\n  /// \\#pragma GCC poison/system_header/dependency and \\#pragma once.\n  void RegisterBuiltinPragmas();\n\n  /// Register builtin macros such as __LINE__ with the identifier table.\n  void RegisterBuiltinMacros();\n\n  /// If an identifier token is read that is to be expanded as a macro, handle\n  /// it and return the next token as 'Tok'.  If we lexed a token, return true;\n  /// otherwise the caller should lex again.\n  bool HandleMacroExpandedIdentifier(Token &Identifier, const MacroDefinition &MD);\n\n  /// Cache macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  Token *cacheMacroExpandedTokens(TokenLexer *tokLexer,\n                                  ArrayRef<Token> tokens);\n\n  void removeCachedMacroExpandedTokensOfLastLexer();\n\n  /// Determine whether the next preprocessor token to be\n  /// lexed is a '('.  If so, consume the token and return true, if not, this\n  /// method should have no observable side-effect on the lexed tokens.\n  bool isNextPPTokenLParen();\n\n  /// After reading \"MACRO(\", this method is invoked to read all of the formal\n  /// arguments specified for the macro invocation.  Returns null on error.\n  MacroArgs *ReadMacroCallArgumentList(Token &MacroName, MacroInfo *MI,\n                                       SourceLocation &MacroEnd);\n\n  /// If an identifier token is read that is to be expanded\n  /// as a builtin macro, handle it and return the next token as 'Tok'.\n  void ExpandBuiltinMacro(Token &Tok);\n\n  /// Read a \\c _Pragma directive, slice it up, process it, then\n  /// return the first token after the directive.\n  /// This assumes that the \\c _Pragma token has just been read into \\p Tok.\n  void Handle_Pragma(Token &Tok);\n\n  /// Like Handle_Pragma except the pragma text is not enclosed within\n  /// a string literal.\n  void HandleMicrosoft__pragma(Token &Tok);\n\n  /// Add a lexer to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  void EnterSourceFileWithLexer(Lexer *TheLexer, const DirectoryLookup *Dir);\n\n  /// Set the FileID for the preprocessor predefines.\n  void setPredefinesFileID(FileID FID) {\n    assert(PredefinesFileID.isInvalid() && \"PredefinesFileID already set!\");\n    PredefinesFileID = FID;\n  }\n\n  /// Set the FileID for the PCH through header.\n  void setPCHThroughHeaderFileID(FileID FID);\n\n  /// Returns true if we are lexing from a file and not a\n  /// pragma or a macro.\n  static bool IsFileLexer(const Lexer* L, const PreprocessorLexer* P) {\n    return L ? !L->isPragmaLexer() : P != nullptr;\n  }\n\n  static bool IsFileLexer(const IncludeStackInfo& I) {\n    return IsFileLexer(I.TheLexer.get(), I.ThePPLexer);\n  }\n\n  bool IsFileLexer() const {\n    return IsFileLexer(CurLexer.get(), CurPPLexer);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Caching stuff.\n  void CachingLex(Token &Result);\n\n  bool InCachingLexMode() const {\n    // If the Lexer pointers are 0 and IncludeMacroStack is empty, it means\n    // that we are past EOF, not that we are in CachingLex mode.\n    return !CurPPLexer && !CurTokenLexer && !IncludeMacroStack.empty();\n  }\n\n  void EnterCachingLexMode();\n  void EnterCachingLexModeUnchecked();\n\n  void ExitCachingLexMode() {\n    if (InCachingLexMode())\n      RemoveTopOfLexerStack();\n  }\n\n  const Token &PeekAhead(unsigned N);\n  void AnnotatePreviousCachedTokens(const Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  /// Handle*Directive - implement the various preprocessor directives.  These\n  /// should side-effect the current preprocessor object so that the next call\n  /// to Lex() will return the appropriate token next.\n  void HandleLineDirective();\n  void HandleDigitDirective(Token &Tok);\n  void HandleUserDiagnosticDirective(Token &Tok, bool isWarning);\n  void HandleIdentSCCSDirective(Token &Tok);\n  void HandleMacroPublicDirective(Token &Tok);\n  void HandleMacroPrivateDirective();\n\n  /// An additional notification that can be produced by a header inclusion or\n  /// import to tell the parser what happened.\n  struct ImportAction {\n    enum ActionKind {\n      None,\n      ModuleBegin,\n      ModuleImport,\n      SkippedModuleImport,\n      Failure,\n    } Kind;\n    Module *ModuleForHeader = nullptr;\n\n    ImportAction(ActionKind AK, Module *Mod = nullptr)\n        : Kind(AK), ModuleForHeader(Mod) {\n      assert((AK == None || Mod || AK == Failure) &&\n             \"no module for module action\");\n    }\n  };\n\n  Optional<FileEntryRef> LookupHeaderIncludeOrImport(\n      const DirectoryLookup *&CurDir, StringRef &Filename,\n      SourceLocation FilenameLoc, CharSourceRange FilenameRange,\n      const Token &FilenameTok, bool &IsFrameworkFound, bool IsImportDecl,\n      bool &IsMapped, const DirectoryLookup *LookupFrom,\n      const FileEntry *LookupFromFile, StringRef &LookupFilename,\n      SmallVectorImpl<char> &RelativePath, SmallVectorImpl<char> &SearchPath,\n      ModuleMap::KnownHeader &SuggestedModule, bool isAngled);\n\n  // File inclusion.\n  void HandleIncludeDirective(SourceLocation HashLoc, Token &Tok,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  ImportAction\n  HandleHeaderIncludeOrImport(SourceLocation HashLoc, Token &IncludeTok,\n                              Token &FilenameTok, SourceLocation EndLoc,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  void HandleIncludeNextDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleIncludeMacrosDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleImportDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleMicrosoftImportDirective(Token &Tok);\n\npublic:\n  /// Check that the given module is available, producing a diagnostic if not.\n  /// \\return \\c true if the check failed (because the module is not available).\n  ///         \\c false if the module appears to be usable.\n  static bool checkModuleIsAvailable(const LangOptions &LangOpts,\n                                     const TargetInfo &TargetInfo,\n                                     DiagnosticsEngine &Diags, Module *M);\n\n  // Module inclusion testing.\n  /// Find the module that owns the source or header file that\n  /// \\p Loc points to. If the location is in a file that was included\n  /// into a module, or is outside any module, returns nullptr.\n  Module *getModuleForLocation(SourceLocation Loc);\n\n  /// We want to produce a diagnostic at location IncLoc concerning an\n  /// unreachable effect at location MLoc (eg, where a desired entity was\n  /// declared or defined). Determine whether the right way to make MLoc\n  /// reachable is by #include, and if so, what header should be included.\n  ///\n  /// This is not necessarily fast, and might load unexpected module maps, so\n  /// should only be called by code that intends to produce an error.\n  ///\n  /// \\param IncLoc The location at which the missing effect was detected.\n  /// \\param MLoc A location within an unimported module at which the desired\n  ///        effect occurred.\n  /// \\return A file that can be #included to provide the desired effect. Null\n  ///         if no such file could be determined or if a #include is not\n  ///         appropriate (eg, if a module should be imported instead).\n  const FileEntry *getHeaderToIncludeForDiagnostics(SourceLocation IncLoc,\n                                                    SourceLocation MLoc);\n\n  bool isRecordingPreamble() const {\n    return PreambleConditionalStack.isRecording();\n  }\n\n  bool hasRecordedPreamble() const {\n    return PreambleConditionalStack.hasRecordedPreamble();\n  }\n\n  ArrayRef<PPConditionalInfo> getPreambleConditionalStack() const {\n      return PreambleConditionalStack.getStack();\n  }\n\n  void setRecordedPreambleConditionalStack(ArrayRef<PPConditionalInfo> s) {\n    PreambleConditionalStack.setStack(s);\n  }\n\n  void setReplayablePreambleConditionalStack(ArrayRef<PPConditionalInfo> s,\n                                             llvm::Optional<PreambleSkipInfo> SkipInfo) {\n    PreambleConditionalStack.startReplaying();\n    PreambleConditionalStack.setStack(s);\n    PreambleConditionalStack.SkipInfo = SkipInfo;\n  }\n\n  llvm::Optional<PreambleSkipInfo> getPreambleSkipInfo() const {\n    return PreambleConditionalStack.SkipInfo;\n  }\n\nprivate:\n  /// After processing predefined file, initialize the conditional stack from\n  /// the preamble.\n  void replayPreambleConditionalStack();\n\n  // Macro handling.\n  void HandleDefineDirective(Token &Tok, bool ImmediatelyAfterHeaderGuard);\n  void HandleUndefDirective();\n\n  // Conditional Inclusion.\n  void HandleIfdefDirective(Token &Result, const Token &HashToken,\n                            bool isIfndef, bool ReadAnyTokensBeforeDirective);\n  void HandleIfDirective(Token &IfToken, const Token &HashToken,\n                         bool ReadAnyTokensBeforeDirective);\n  void HandleEndifDirective(Token &EndifToken);\n  void HandleElseDirective(Token &Result, const Token &HashToken);\n  void HandleElifDirective(Token &ElifToken, const Token &HashToken);\n\n  // Pragmas.\n  void HandlePragmaDirective(PragmaIntroducer Introducer);\n\npublic:\n  void HandlePragmaOnce(Token &OnceTok);\n  void HandlePragmaMark();\n  void HandlePragmaPoison();\n  void HandlePragmaSystemHeader(Token &SysHeaderTok);\n  void HandlePragmaDependency(Token &DependencyTok);\n  void HandlePragmaPushMacro(Token &Tok);\n  void HandlePragmaPopMacro(Token &Tok);\n  void HandlePragmaIncludeAlias(Token &Tok);\n  void HandlePragmaModuleBuild(Token &Tok);\n  void HandlePragmaHdrstop(Token &Tok);\n  IdentifierInfo *ParsePragmaPushOrPopMacro(Token &Tok);\n\n  // Return true and store the first token only if any CommentHandler\n  // has inserted some tokens and getCommentRetentionState() is false.\n  bool HandleComment(Token &result, SourceRange Comment);\n\n  /// A macro is used, update information about macros that need unused\n  /// warnings.\n  void markMacroAsUsed(MacroInfo *MI);\n\nprivate:\n  Optional<unsigned>\n  getSkippedRangeForExcludedConditionalBlock(SourceLocation HashLoc);\n\n  /// Contains the currently active skipped range mappings for skipping excluded\n  /// conditional directives.\n  ExcludedPreprocessorDirectiveSkipMapping\n      *ExcludedConditionalDirectiveSkipMappings;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for each of the comments encountered in the source file.\nclass CommentHandler {\npublic:\n  virtual ~CommentHandler();\n\n  // The handler shall return true if it has pushed any tokens\n  // to be read using e.g. EnterToken or EnterTokenStream.\n  virtual bool HandleComment(Preprocessor &PP, SourceRange Comment) = 0;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for empty lines encountered in the source file.\nclass EmptylineHandler {\npublic:\n  virtual ~EmptylineHandler();\n\n  // The handler handles empty lines.\n  virtual void HandleEmptyline(SourceRange Range) = 0;\n};\n\n/// Registry of pragma handlers added by plugins\nusing PragmaHandlerRegistry = llvm::Registry<PragmaHandler>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSOR_H\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h", "content": "//===- PreprocessorLexer.h - C Language Family Lexer ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the PreprocessorLexer interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSORLEXER_H\n#define LLVM_CLANG_LEX_PREPROCESSORLEXER_H\n\n#include \"clang/Lex/MultipleIncludeOpt.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n\nnamespace clang {\n\nclass FileEntry;\nclass Preprocessor;\n\nclass PreprocessorLexer {\n  virtual void anchor();\n\nprotected:\n  friend class Preprocessor;\n\n  // Preprocessor object controlling lexing.\n  Preprocessor *PP = nullptr;\n\n  /// The SourceManager FileID corresponding to the file being lexed.\n  const FileID FID;\n\n  /// Number of SLocEntries before lexing the file.\n  unsigned InitialNumSLocEntries = 0;\n\n  //===--------------------------------------------------------------------===//\n  // Context-specific lexing flags set by the preprocessor.\n  //===--------------------------------------------------------------------===//\n\n  /// True when parsing \\#XXX; turns '\\\\n' into a tok::eod token.\n  bool ParsingPreprocessorDirective = false;\n\n  /// True after \\#include; turns \\<xx> or \"xxx\" into a tok::header_name token.\n  bool ParsingFilename = false;\n\n  /// True if in raw mode.\n  ///\n  /// Raw mode disables interpretation of tokens and is a far faster mode to\n  /// lex in than non-raw-mode.  This flag:\n  ///  1. If EOF of the current lexer is found, the include stack isn't popped.\n  ///  2. Identifier information is not looked up for identifier tokens.  As an\n  ///     effect of this, implicit macro expansion is naturally disabled.\n  ///  3. \"#\" tokens at the start of a line are treated as normal tokens, not\n  ///     implicitly transformed by the lexer.\n  ///  4. All diagnostic messages are disabled.\n  ///  5. No callbacks are made into the preprocessor.\n  ///\n  /// Note that in raw mode that the PP pointer may be null.\n  bool LexingRawMode = false;\n\n  /// A state machine that detects the \\#ifndef-wrapping a file\n  /// idiom for the multiple-include optimization.\n  MultipleIncludeOpt MIOpt;\n\n  /// Information about the set of \\#if/\\#ifdef/\\#ifndef blocks\n  /// we are currently in.\n  SmallVector<PPConditionalInfo, 4> ConditionalStack;\n\n  PreprocessorLexer() : FID() {}\n  PreprocessorLexer(Preprocessor *pp, FileID fid);\n  virtual ~PreprocessorLexer() = default;\n\n  virtual void IndirectLex(Token& Result) = 0;\n\n  /// Return the source location for the next observable location.\n  virtual SourceLocation getSourceLocation() = 0;\n\n  //===--------------------------------------------------------------------===//\n  // #if directive handling.\n\n  /// pushConditionalLevel - When we enter a \\#if directive, this keeps track of\n  /// what we are currently in for diagnostic emission (e.g. \\#if with missing\n  /// \\#endif).\n  void pushConditionalLevel(SourceLocation DirectiveStart, bool WasSkipping,\n                            bool FoundNonSkip, bool FoundElse) {\n    PPConditionalInfo CI;\n    CI.IfLoc = DirectiveStart;\n    CI.WasSkipping = WasSkipping;\n    CI.FoundNonSkip = FoundNonSkip;\n    CI.FoundElse = FoundElse;\n    ConditionalStack.push_back(CI);\n  }\n  void pushConditionalLevel(const PPConditionalInfo &CI) {\n    ConditionalStack.push_back(CI);\n  }\n\n  /// popConditionalLevel - Remove an entry off the top of the conditional\n  /// stack, returning information about it.  If the conditional stack is empty,\n  /// this returns true and does not fill in the arguments.\n  bool popConditionalLevel(PPConditionalInfo &CI) {\n    if (ConditionalStack.empty())\n      return true;\n    CI = ConditionalStack.pop_back_val();\n    return false;\n  }\n\n  /// Return the top of the conditional stack.\n  /// \\pre This requires that there be a conditional active.\n  PPConditionalInfo &peekConditionalLevel() {\n    assert(!ConditionalStack.empty() && \"No conditionals active!\");\n    return ConditionalStack.back();\n  }\n\n  unsigned getConditionalStackDepth() const { return ConditionalStack.size(); }\n\npublic:\n  PreprocessorLexer(const PreprocessorLexer &) = delete;\n  PreprocessorLexer &operator=(const PreprocessorLexer &) = delete;\n\n  //===--------------------------------------------------------------------===//\n  // Misc. lexing methods.\n\n  /// Lex a token, producing a header-name token if possible.\n  void LexIncludeFilename(Token &FilenameTok);\n\n  /// Inform the lexer whether or not we are currently lexing a\n  /// preprocessor directive.\n  void setParsingPreprocessorDirective(bool f) {\n    ParsingPreprocessorDirective = f;\n  }\n\n  /// Return true if this lexer is in raw mode or not.\n  bool isLexingRawMode() const { return LexingRawMode; }\n\n  /// Return the preprocessor object for this lexer.\n  Preprocessor *getPP() const { return PP; }\n\n  FileID getFileID() const {\n    assert(PP &&\n      \"PreprocessorLexer::getFileID() should only be used with a Preprocessor\");\n    return FID;\n  }\n\n  /// Number of SLocEntries before lexing the file.\n  unsigned getInitialNumSLocEntries() const {\n    return InitialNumSLocEntries;\n  }\n\n  /// getFileEntry - Return the FileEntry corresponding to this FileID.  Like\n  /// getFileID(), this only works for lexers with attached preprocessors.\n  const FileEntry *getFileEntry() const;\n\n  /// Iterator that traverses the current stack of preprocessor\n  /// conditional directives (\\#if/\\#ifdef/\\#ifndef).\n  using conditional_iterator =\n      SmallVectorImpl<PPConditionalInfo>::const_iterator;\n\n  conditional_iterator conditional_begin() const {\n    return ConditionalStack.begin();\n  }\n\n  conditional_iterator conditional_end() const {\n    return ConditionalStack.end();\n  }\n\n  void setConditionalLevels(ArrayRef<PPConditionalInfo> CL) {\n    ConditionalStack.clear();\n    ConditionalStack.append(CL.begin(), CL.end());\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSORLEXER_H\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "content": "//===- CodeCompleteConsumer.h - Code Completion Interface -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CodeCompleteConsumer class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n#define LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n\n#include \"clang-c/Index.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass DeclContext;\nclass FunctionDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass LangOptions;\nclass NamedDecl;\nclass NestedNameSpecifier;\nclass Preprocessor;\nclass RawComment;\nclass Sema;\nclass UsingShadowDecl;\n\n/// Default priority values for code-completion results based\n/// on their kind.\nenum {\n  /// Priority for the next initialization in a constructor initializer\n  /// list.\n  CCP_NextInitializer = 7,\n\n  /// Priority for an enumeration constant inside a switch whose\n  /// condition is of the enumeration type.\n  CCP_EnumInCase = 7,\n\n  /// Priority for a send-to-super completion.\n  CCP_SuperCompletion = 20,\n\n  /// Priority for a declaration that is in the local scope.\n  CCP_LocalDeclaration = 34,\n\n  /// Priority for a member declaration found from the current\n  /// method or member function.\n  CCP_MemberDeclaration = 35,\n\n  /// Priority for a language keyword (that isn't any of the other\n  /// categories).\n  CCP_Keyword = 40,\n\n  /// Priority for a code pattern.\n  CCP_CodePattern = 40,\n\n  /// Priority for a non-type declaration.\n  CCP_Declaration = 50,\n\n  /// Priority for a type.\n  CCP_Type = CCP_Declaration,\n\n  /// Priority for a constant value (e.g., enumerator).\n  CCP_Constant = 65,\n\n  /// Priority for a preprocessor macro.\n  CCP_Macro = 70,\n\n  /// Priority for a nested-name-specifier.\n  CCP_NestedNameSpecifier = 75,\n\n  /// Priority for a result that isn't likely to be what the user wants,\n  /// but is included for completeness.\n  CCP_Unlikely = 80,\n\n  /// Priority for the Objective-C \"_cmd\" implicit parameter.\n  CCP_ObjC_cmd = CCP_Unlikely\n};\n\n/// Priority value deltas that are added to code-completion results\n/// based on the context of the result.\nenum {\n  /// The result is in a base class.\n  CCD_InBaseClass = 2,\n\n  /// The result is a C++ non-static member function whose qualifiers\n  /// exactly match the object type on which the member function can be called.\n  CCD_ObjectQualifierMatch = -1,\n\n  /// The selector of the given message exactly matches the selector\n  /// of the current method, which might imply that some kind of delegation\n  /// is occurring.\n  CCD_SelectorMatch = -3,\n\n  /// Adjustment to the \"bool\" type in Objective-C, where the typedef\n  /// \"BOOL\" is preferred.\n  CCD_bool_in_ObjC = 1,\n\n  /// Adjustment for KVC code pattern priorities when it doesn't look\n  /// like the\n  CCD_ProbablyNotObjCCollection = 15,\n\n  /// An Objective-C method being used as a property.\n  CCD_MethodAsProperty = 2,\n\n  /// An Objective-C block property completed as a setter with a\n  /// block placeholder.\n  CCD_BlockPropertySetter = 3\n};\n\n/// Priority value factors by which we will divide or multiply the\n/// priority of a code-completion result.\nenum {\n  /// Divide by this factor when a code-completion result's type exactly\n  /// matches the type we expect.\n  CCF_ExactTypeMatch = 4,\n\n  /// Divide by this factor when a code-completion result's type is\n  /// similar to the type we expect (e.g., both arithmetic types, both\n  /// Objective-C object pointer types).\n  CCF_SimilarTypeMatch = 2\n};\n\n/// A simplified classification of types used when determining\n/// \"similar\" types for code completion.\nenum SimplifiedTypeClass {\n  STC_Arithmetic,\n  STC_Array,\n  STC_Block,\n  STC_Function,\n  STC_ObjectiveC,\n  STC_Other,\n  STC_Pointer,\n  STC_Record,\n  STC_Void\n};\n\n/// Determine the simplified type class of the given canonical type.\nSimplifiedTypeClass getSimplifiedTypeClass(CanQualType T);\n\n/// Determine the type that this declaration will have if it is used\n/// as a type or in an expression.\nQualType getDeclUsageType(ASTContext &C, const NamedDecl *ND);\n\n/// Determine the priority to be given to a macro code completion result\n/// with the given name.\n///\n/// \\param MacroName The name of the macro.\n///\n/// \\param LangOpts Options describing the current language dialect.\n///\n/// \\param PreferredTypeIsPointer Whether the preferred type for the context\n/// of this macro is a pointer type.\nunsigned getMacroUsagePriority(StringRef MacroName,\n                               const LangOptions &LangOpts,\n                               bool PreferredTypeIsPointer = false);\n\n/// Determine the libclang cursor kind associated with the given\n/// declaration.\nCXCursorKind getCursorKindForDecl(const Decl *D);\n\n/// The context in which code completion occurred, so that the\n/// code-completion consumer can process the results accordingly.\nclass CodeCompletionContext {\npublic:\n  enum Kind {\n    /// An unspecified code-completion context.\n    CCC_Other,\n\n    /// An unspecified code-completion context where we should also add\n    /// macro completions.\n    CCC_OtherWithMacros,\n\n    /// Code completion occurred within a \"top-level\" completion context,\n    /// e.g., at namespace or global scope.\n    CCC_TopLevel,\n\n    /// Code completion occurred within an Objective-C interface,\n    /// protocol, or category interface.\n    CCC_ObjCInterface,\n\n    /// Code completion occurred within an Objective-C implementation\n    /// or category implementation.\n    CCC_ObjCImplementation,\n\n    /// Code completion occurred within the instance variable list of\n    /// an Objective-C interface, implementation, or category implementation.\n    CCC_ObjCIvarList,\n\n    /// Code completion occurred within a class, struct, or union.\n    CCC_ClassStructUnion,\n\n    /// Code completion occurred where a statement (or declaration) is\n    /// expected in a function, method, or block.\n    CCC_Statement,\n\n    /// Code completion occurred where an expression is expected.\n    CCC_Expression,\n\n    /// Code completion occurred where an Objective-C message receiver\n    /// is expected.\n    CCC_ObjCMessageReceiver,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the dot operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_DotMemberAccess,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the arrow operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ArrowMemberAccess,\n\n    /// Code completion occurred on the right-hand side of an Objective-C\n    /// property access expression.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ObjCPropertyAccess,\n\n    /// Code completion occurred after the \"enum\" keyword, to indicate\n    /// an enumeration name.\n    CCC_EnumTag,\n\n    /// Code completion occurred after the \"union\" keyword, to indicate\n    /// a union name.\n    CCC_UnionTag,\n\n    /// Code completion occurred after the \"struct\" or \"class\" keyword,\n    /// to indicate a struct or class name.\n    CCC_ClassOrStructTag,\n\n    /// Code completion occurred where a protocol name is expected.\n    CCC_ObjCProtocolName,\n\n    /// Code completion occurred where a namespace or namespace alias\n    /// is expected.\n    CCC_Namespace,\n\n    /// Code completion occurred where a type name is expected.\n    CCC_Type,\n\n    /// Code completion occurred where a new name is expected.\n    CCC_NewName,\n\n    /// Code completion occurred where both a new name and an existing symbol is\n    /// permissible.\n    CCC_SymbolOrNewName,\n\n    /// Code completion occurred where an existing name(such as type, function\n    /// or variable) is expected.\n    CCC_Symbol,\n\n    /// Code completion occurred where an macro is being defined.\n    CCC_MacroName,\n\n    /// Code completion occurred where a macro name is expected\n    /// (without any arguments, in the case of a function-like macro).\n    CCC_MacroNameUse,\n\n    /// Code completion occurred within a preprocessor expression.\n    CCC_PreprocessorExpression,\n\n    /// Code completion occurred where a preprocessor directive is\n    /// expected.\n    CCC_PreprocessorDirective,\n\n    /// Code completion occurred in a context where natural language is\n    /// expected, e.g., a comment or string literal.\n    ///\n    /// This context usually implies that no completions should be added,\n    /// unless they come from an appropriate natural-language dictionary.\n    CCC_NaturalLanguage,\n\n    /// Code completion for a selector, as in an \\@selector expression.\n    CCC_SelectorName,\n\n    /// Code completion within a type-qualifier list.\n    CCC_TypeQualifiers,\n\n    /// Code completion in a parenthesized expression, which means that\n    /// we may also have types here in C and Objective-C (as well as in C++).\n    CCC_ParenthesizedExpression,\n\n    /// Code completion where an Objective-C instance message is\n    /// expected.\n    CCC_ObjCInstanceMessage,\n\n    /// Code completion where an Objective-C class message is expected.\n    CCC_ObjCClassMessage,\n\n    /// Code completion where the name of an Objective-C class is\n    /// expected.\n    CCC_ObjCInterfaceName,\n\n    /// Code completion where an Objective-C category name is expected.\n    CCC_ObjCCategoryName,\n\n    /// Code completion inside the filename part of a #include directive.\n    CCC_IncludedFile,\n\n    /// An unknown context, in which we are recovering from a parsing\n    /// error and don't know which completions we should give.\n    CCC_Recovery\n  };\n\n  using VisitedContextSet = llvm::SmallPtrSet<DeclContext *, 8>;\n\nprivate:\n  Kind CCKind;\n\n  /// Indicates whether we are completing a name of a using declaration, e.g.\n  ///     using ^;\n  ///     using a::^;\n  bool IsUsingDeclaration;\n\n  /// The type that would prefer to see at this point (e.g., the type\n  /// of an initializer or function parameter).\n  QualType PreferredType;\n\n  /// The type of the base object in a member access expression.\n  QualType BaseType;\n\n  /// The identifiers for Objective-C selector parts.\n  ArrayRef<IdentifierInfo *> SelIdents;\n\n  /// The scope specifier that comes before the completion token e.g.\n  /// \"a::b::\"\n  llvm::Optional<CXXScopeSpec> ScopeSpecifier;\n\n  /// A set of declaration contexts visited by Sema when doing lookup for\n  /// code completion.\n  VisitedContextSet VisitedContexts;\n\npublic:\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(None) {}\n\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind, QualType T,\n                        ArrayRef<IdentifierInfo *> SelIdents = None)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(SelIdents) {\n    if (CCKind == CCC_DotMemberAccess || CCKind == CCC_ArrowMemberAccess ||\n        CCKind == CCC_ObjCPropertyAccess || CCKind == CCC_ObjCClassMessage ||\n        CCKind == CCC_ObjCInstanceMessage)\n      BaseType = T;\n    else\n      PreferredType = T;\n  }\n\n  bool isUsingDeclaration() const { return IsUsingDeclaration; }\n  void setIsUsingDeclaration(bool V) { IsUsingDeclaration = V; }\n\n  /// Retrieve the kind of code-completion context.\n  Kind getKind() const { return CCKind; }\n\n  /// Retrieve the type that this expression would prefer to have, e.g.,\n  /// if the expression is a variable initializer or a function argument, the\n  /// type of the corresponding variable or function parameter.\n  QualType getPreferredType() const { return PreferredType; }\n  void setPreferredType(QualType T) { PreferredType = T; }\n\n  /// Retrieve the type of the base object in a member-access\n  /// expression.\n  QualType getBaseType() const { return BaseType; }\n\n  /// Retrieve the Objective-C selector identifiers.\n  ArrayRef<IdentifierInfo *> getSelIdents() const { return SelIdents; }\n\n  /// Determines whether we want C++ constructors as results within this\n  /// context.\n  bool wantConstructorResults() const;\n\n  /// Sets the scope specifier that comes before the completion token.\n  /// This is expected to be set in code completions on qualfied specifiers\n  /// (e.g. \"a::b::\").\n  void setCXXScopeSpecifier(CXXScopeSpec SS) {\n    this->ScopeSpecifier = std::move(SS);\n  }\n\n  /// Adds a visited context.\n  void addVisitedContext(DeclContext *Ctx) {\n    VisitedContexts.insert(Ctx);\n  }\n\n  /// Retrieves all visited contexts.\n  const VisitedContextSet &getVisitedContexts() const {\n    return VisitedContexts;\n  }\n\n  llvm::Optional<const CXXScopeSpec *> getCXXScopeSpecifier() {\n    if (ScopeSpecifier)\n      return ScopeSpecifier.getPointer();\n    return llvm::None;\n  }\n};\n\n/// Get string representation of \\p Kind, useful for for debugging.\nllvm::StringRef getCompletionKindString(CodeCompletionContext::Kind Kind);\n\n/// A \"string\" used to describe how code completion can\n/// be performed for an entity.\n///\n/// A code completion string typically shows how a particular entity can be\n/// used. For example, the code completion string for a function would show\n/// the syntax to call it, including the parentheses, placeholders for the\n/// arguments, etc.\nclass CodeCompletionString {\npublic:\n  /// The different kinds of \"chunks\" that can occur within a code\n  /// completion string.\n  enum ChunkKind {\n    /// The piece of text that the user is expected to type to\n    /// match the code-completion string, typically a keyword or the name of a\n    /// declarator or macro.\n    CK_TypedText,\n\n    /// A piece of text that should be placed in the buffer, e.g.,\n    /// parentheses or a comma in a function call.\n    CK_Text,\n\n    /// A code completion string that is entirely optional. For example,\n    /// an optional code completion string that describes the default arguments\n    /// in a function call.\n    CK_Optional,\n\n    /// A string that acts as a placeholder for, e.g., a function\n    /// call argument.\n    CK_Placeholder,\n\n    /// A piece of text that describes something about the result but\n    /// should not be inserted into the buffer.\n    CK_Informative,\n    /// A piece of text that describes the type of an entity or, for\n    /// functions and methods, the return type.\n    CK_ResultType,\n\n    /// A piece of text that describes the parameter that corresponds\n    /// to the code-completion location within a function call, message send,\n    /// macro invocation, etc.\n    CK_CurrentParameter,\n\n    /// A left parenthesis ('(').\n    CK_LeftParen,\n\n    /// A right parenthesis (')').\n    CK_RightParen,\n\n    /// A left bracket ('[').\n    CK_LeftBracket,\n\n    /// A right bracket (']').\n    CK_RightBracket,\n\n    /// A left brace ('{').\n    CK_LeftBrace,\n\n    /// A right brace ('}').\n    CK_RightBrace,\n\n    /// A left angle bracket ('<').\n    CK_LeftAngle,\n\n    /// A right angle bracket ('>').\n    CK_RightAngle,\n\n    /// A comma separator (',').\n    CK_Comma,\n\n    /// A colon (':').\n    CK_Colon,\n\n    /// A semicolon (';').\n    CK_SemiColon,\n\n    /// An '=' sign.\n    CK_Equal,\n\n    /// Horizontal whitespace (' ').\n    CK_HorizontalSpace,\n\n    /// Vertical whitespace ('\\\\n' or '\\\\r\\\\n', depending on the\n    /// platform).\n    CK_VerticalSpace\n  };\n\n  /// One piece of the code completion string.\n  struct Chunk {\n    /// The kind of data stored in this piece of the code completion\n    /// string.\n    ChunkKind Kind = CK_Text;\n\n    union {\n      /// The text string associated with a CK_Text, CK_Placeholder,\n      /// CK_Informative, or CK_Comma chunk.\n      /// The string is owned by the chunk and will be deallocated\n      /// (with delete[]) when the chunk is destroyed.\n      const char *Text;\n\n      /// The code completion string associated with a CK_Optional chunk.\n      /// The optional code completion string is owned by the chunk, and will\n      /// be deallocated (with delete) when the chunk is destroyed.\n      CodeCompletionString *Optional;\n    };\n\n    Chunk() : Text(nullptr) {}\n\n    explicit Chunk(ChunkKind Kind, const char *Text = \"\");\n\n    /// Create a new text chunk.\n    static Chunk CreateText(const char *Text);\n\n    /// Create a new optional chunk.\n    static Chunk CreateOptional(CodeCompletionString *Optional);\n\n    /// Create a new placeholder chunk.\n    static Chunk CreatePlaceholder(const char *Placeholder);\n\n    /// Create a new informative chunk.\n    static Chunk CreateInformative(const char *Informative);\n\n    /// Create a new result type chunk.\n    static Chunk CreateResultType(const char *ResultType);\n\n    /// Create a new current-parameter chunk.\n    static Chunk CreateCurrentParameter(const char *CurrentParameter);\n  };\n\nprivate:\n  friend class CodeCompletionBuilder;\n  friend class CodeCompletionResult;\n\n  /// The number of chunks stored in this string.\n  unsigned NumChunks : 16;\n\n  /// The number of annotations for this code-completion result.\n  unsigned NumAnnotations : 16;\n\n  /// The priority of this code-completion string.\n  unsigned Priority : 16;\n\n  /// The availability of this code-completion result.\n  unsigned Availability : 2;\n\n  /// The name of the parent context.\n  StringRef ParentName;\n\n  /// A brief documentation comment attached to the declaration of\n  /// entity being completed by this result.\n  const char *BriefComment;\n\n  CodeCompletionString(const Chunk *Chunks, unsigned NumChunks,\n                       unsigned Priority, CXAvailabilityKind Availability,\n                       const char **Annotations, unsigned NumAnnotations,\n                       StringRef ParentName,\n                       const char *BriefComment);\n  ~CodeCompletionString() = default;\n\npublic:\n  CodeCompletionString(const CodeCompletionString &) = delete;\n  CodeCompletionString &operator=(const CodeCompletionString &) = delete;\n\n  using iterator = const Chunk *;\n\n  iterator begin() const { return reinterpret_cast<const Chunk *>(this + 1); }\n  iterator end() const { return begin() + NumChunks; }\n  bool empty() const { return NumChunks == 0; }\n  unsigned size() const { return NumChunks; }\n\n  const Chunk &operator[](unsigned I) const {\n    assert(I < size() && \"Chunk index out-of-range\");\n    return begin()[I];\n  }\n\n  /// Returns the text in the TypedText chunk.\n  const char *getTypedText() const;\n\n  /// Retrieve the priority of this code completion result.\n  unsigned getPriority() const { return Priority; }\n\n  /// Retrieve the availability of this code completion result.\n  unsigned getAvailability() const { return Availability; }\n\n  /// Retrieve the number of annotations for this code completion result.\n  unsigned getAnnotationCount() const;\n\n  /// Retrieve the annotation string specified by \\c AnnotationNr.\n  const char *getAnnotation(unsigned AnnotationNr) const;\n\n  /// Retrieve the name of the parent context.\n  StringRef getParentContextName() const {\n    return ParentName;\n  }\n\n  const char *getBriefComment() const {\n    return BriefComment;\n  }\n\n  /// Retrieve a string representation of the code completion string,\n  /// which is mainly useful for debugging.\n  std::string getAsString() const;\n};\n\n/// An allocator used specifically for the purpose of code completion.\nclass CodeCompletionAllocator : public llvm::BumpPtrAllocator {\npublic:\n  /// Copy the given string into this allocator.\n  const char *CopyString(const Twine &String);\n};\n\n/// Allocator for a cached set of global code completions.\nclass GlobalCodeCompletionAllocator : public CodeCompletionAllocator {};\n\nclass CodeCompletionTUInfo {\n  llvm::DenseMap<const DeclContext *, StringRef> ParentNames;\n  std::shared_ptr<GlobalCodeCompletionAllocator> AllocatorRef;\n\npublic:\n  explicit CodeCompletionTUInfo(\n      std::shared_ptr<GlobalCodeCompletionAllocator> Allocator)\n      : AllocatorRef(std::move(Allocator)) {}\n\n  std::shared_ptr<GlobalCodeCompletionAllocator> getAllocatorRef() const {\n    return AllocatorRef;\n  }\n\n  CodeCompletionAllocator &getAllocator() const {\n    assert(AllocatorRef);\n    return *AllocatorRef;\n  }\n\n  StringRef getParentName(const DeclContext *DC);\n};\n\n} // namespace clang\n\nnamespace clang {\n\n/// A builder class used to construct new code-completion strings.\nclass CodeCompletionBuilder {\npublic:\n  using Chunk = CodeCompletionString::Chunk;\n\nprivate:\n  CodeCompletionAllocator &Allocator;\n  CodeCompletionTUInfo &CCTUInfo;\n  unsigned Priority = 0;\n  CXAvailabilityKind Availability = CXAvailability_Available;\n  StringRef ParentName;\n  const char *BriefComment = nullptr;\n\n  /// The chunks stored in this string.\n  SmallVector<Chunk, 4> Chunks;\n\n  SmallVector<const char *, 2> Annotations;\n\npublic:\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo) {}\n\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo,\n                        unsigned Priority, CXAvailabilityKind Availability)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo), Priority(Priority),\n        Availability(Availability) {}\n\n  /// Retrieve the allocator into which the code completion\n  /// strings should be allocated.\n  CodeCompletionAllocator &getAllocator() const { return Allocator; }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() const { return CCTUInfo; }\n\n  /// Take the resulting completion string.\n  ///\n  /// This operation can only be performed once.\n  CodeCompletionString *TakeString();\n\n  /// Add a new typed-text chunk.\n  void AddTypedTextChunk(const char *Text);\n\n  /// Add a new text chunk.\n  void AddTextChunk(const char *Text);\n\n  /// Add a new optional chunk.\n  void AddOptionalChunk(CodeCompletionString *Optional);\n\n  /// Add a new placeholder chunk.\n  void AddPlaceholderChunk(const char *Placeholder);\n\n  /// Add a new informative chunk.\n  void AddInformativeChunk(const char *Text);\n\n  /// Add a new result-type chunk.\n  void AddResultTypeChunk(const char *ResultType);\n\n  /// Add a new current-parameter chunk.\n  void AddCurrentParameterChunk(const char *CurrentParameter);\n\n  /// Add a new chunk.\n  void AddChunk(CodeCompletionString::ChunkKind CK, const char *Text = \"\");\n\n  void AddAnnotation(const char *A) { Annotations.push_back(A); }\n\n  /// Add the parent context information to this code completion.\n  void addParentContext(const DeclContext *DC);\n\n  const char *getBriefComment() const { return BriefComment; }\n  void addBriefComment(StringRef Comment);\n\n  StringRef getParentName() const { return ParentName; }\n};\n\n/// Captures a result of code completion.\nclass CodeCompletionResult {\npublic:\n  /// Describes the kind of result generated.\n  enum ResultKind {\n    /// Refers to a declaration.\n    RK_Declaration = 0,\n\n    /// Refers to a keyword or symbol.\n    RK_Keyword,\n\n    /// Refers to a macro.\n    RK_Macro,\n\n    /// Refers to a precomputed pattern.\n    RK_Pattern\n  };\n\n  /// When Kind == RK_Declaration or RK_Pattern, the declaration we are\n  /// referring to. In the latter case, the declaration might be NULL.\n  const NamedDecl *Declaration = nullptr;\n\n  union {\n    /// When Kind == RK_Keyword, the string representing the keyword\n    /// or symbol's spelling.\n    const char *Keyword;\n\n    /// When Kind == RK_Pattern, the code-completion string that\n    /// describes the completion text to insert.\n    CodeCompletionString *Pattern;\n\n    /// When Kind == RK_Macro, the identifier that refers to a macro.\n    const IdentifierInfo *Macro;\n  };\n\n  /// The priority of this particular code-completion result.\n  unsigned Priority;\n\n  /// Specifies which parameter (of a function, Objective-C method,\n  /// macro, etc.) we should start with when formatting the result.\n  unsigned StartParameter = 0;\n\n  /// The kind of result stored here.\n  ResultKind Kind;\n\n  /// The cursor kind that describes this result.\n  CXCursorKind CursorKind;\n\n  /// The availability of this result.\n  CXAvailabilityKind Availability = CXAvailability_Available;\n\n  /// Fix-its that *must* be applied before inserting the text for the\n  /// corresponding completion.\n  ///\n  /// By default, CodeCompletionBuilder only returns completions with empty\n  /// fix-its. Extra completions with non-empty fix-its should be explicitly\n  /// requested by setting CompletionOptions::IncludeFixIts.\n  ///\n  /// For the clients to be able to compute position of the cursor after\n  /// applying fix-its, the following conditions are guaranteed to hold for\n  /// RemoveRange of the stored fix-its:\n  ///  - Ranges in the fix-its are guaranteed to never contain the completion\n  ///  point (or identifier under completion point, if any) inside them, except\n  ///  at the start or at the end of the range.\n  ///  - If a fix-it range starts or ends with completion point (or starts or\n  ///  ends after the identifier under completion point), it will contain at\n  ///  least one character. It allows to unambiguously recompute completion\n  ///  point after applying the fix-it.\n  ///\n  /// The intuition is that provided fix-its change code around the identifier\n  /// we complete, but are not allowed to touch the identifier itself or the\n  /// completion point. One example of completions with corrections are the ones\n  /// replacing '.' with '->' and vice versa:\n  ///\n  /// std::unique_ptr<std::vector<int>> vec_ptr;\n  /// In 'vec_ptr.^', one of the completions is 'push_back', it requires\n  /// replacing '.' with '->'.\n  /// In 'vec_ptr->^', one of the completions is 'release', it requires\n  /// replacing '->' with '.'.\n  std::vector<FixItHint> FixIts;\n\n  /// Whether this result is hidden by another name.\n  bool Hidden : 1;\n\n  /// Whether this is a class member from base class.\n  bool InBaseClass : 1;\n\n  /// Whether this result was found via lookup into a base class.\n  bool QualifierIsInformative : 1;\n\n  /// Whether this declaration is the beginning of a\n  /// nested-name-specifier and, therefore, should be followed by '::'.\n  bool StartsNestedNameSpecifier : 1;\n\n  /// Whether all parameters (of a function, Objective-C\n  /// method, etc.) should be considered \"informative\".\n  bool AllParametersAreInformative : 1;\n\n  /// Whether we're completing a declaration of the given entity,\n  /// rather than a use of that entity.\n  bool DeclaringEntity : 1;\n\n  /// If the result should have a nested-name-specifier, this is it.\n  /// When \\c QualifierIsInformative, the nested-name-specifier is\n  /// informative rather than required.\n  NestedNameSpecifier *Qualifier = nullptr;\n\n  /// If this Decl was unshadowed by using declaration, this can store a\n  /// pointer to the UsingShadowDecl which was used in the unshadowing process.\n  /// This information can be used to uprank CodeCompletionResults / which have\n  /// corresponding `using decl::qualified::name;` nearby.\n  const UsingShadowDecl *ShadowDecl = nullptr;\n\n  /// If the result is RK_Macro, this can store the information about the macro\n  /// definition. This should be set in most cases but can be missing when\n  /// the macro has been undefined.\n  const MacroInfo *MacroDefInfo = nullptr;\n\n  /// Build a result that refers to a declaration.\n  CodeCompletionResult(const NamedDecl *Declaration, unsigned Priority,\n                       NestedNameSpecifier *Qualifier = nullptr,\n                       bool QualifierIsInformative = false,\n                       bool Accessible = true,\n                       std::vector<FixItHint> FixIts = std::vector<FixItHint>())\n      : Declaration(Declaration), Priority(Priority), Kind(RK_Declaration),\n        FixIts(std::move(FixIts)), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(QualifierIsInformative),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false), Qualifier(Qualifier) {\n    // FIXME: Add assert to check FixIts range requirements.\n    computeCursorKindAndAvailability(Accessible);\n  }\n\n  /// Build a result that refers to a keyword or symbol.\n  CodeCompletionResult(const char *Keyword, unsigned Priority = CCP_Keyword)\n      : Keyword(Keyword), Priority(Priority), Kind(RK_Keyword),\n        CursorKind(CXCursor_NotImplemented), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false) {}\n\n  /// Build a result that refers to a macro.\n  CodeCompletionResult(const IdentifierInfo *Macro,\n                       const MacroInfo *MI = nullptr,\n                       unsigned Priority = CCP_Macro)\n      : Macro(Macro), Priority(Priority), Kind(RK_Macro),\n        CursorKind(CXCursor_MacroDefinition), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false),\n        MacroDefInfo(MI) {}\n\n  /// Build a result that refers to a pattern.\n  CodeCompletionResult(\n      CodeCompletionString *Pattern, unsigned Priority = CCP_CodePattern,\n      CXCursorKind CursorKind = CXCursor_NotImplemented,\n      CXAvailabilityKind Availability = CXAvailability_Available,\n      const NamedDecl *D = nullptr)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        CursorKind(CursorKind), Availability(Availability), Hidden(false),\n        InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {}\n\n  /// Build a result that refers to a pattern with an associated\n  /// declaration.\n  CodeCompletionResult(CodeCompletionString *Pattern, const NamedDecl *D,\n                       unsigned Priority)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        Hidden(false), InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {\n    computeCursorKindAndAvailability();\n  }\n\n  /// Retrieve the declaration stored in this result. This might be nullptr if\n  /// Kind is RK_Pattern.\n  const NamedDecl *getDeclaration() const {\n    assert(((Kind == RK_Declaration) || (Kind == RK_Pattern)) &&\n           \"Not a declaration or pattern result\");\n    return Declaration;\n  }\n\n  /// Retrieve the keyword stored in this result.\n  const char *getKeyword() const {\n    assert(Kind == RK_Keyword && \"Not a keyword result\");\n    return Keyword;\n  }\n\n  /// Create a new code-completion string that describes how to insert\n  /// this result into a program.\n  ///\n  /// \\param S The semantic analysis that created the result.\n  ///\n  /// \\param Allocator The allocator that will be used to allocate the\n  /// string itself.\n  CodeCompletionString *CreateCodeCompletionString(Sema &S,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  CodeCompletionString *CreateCodeCompletionString(ASTContext &Ctx,\n                                                   Preprocessor &PP,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  /// Creates a new code-completion string for the macro result. Similar to the\n  /// above overloads, except this only requires preprocessor information.\n  /// The result kind must be `RK_Macro`.\n  CodeCompletionString *\n  CreateCodeCompletionStringForMacro(Preprocessor &PP,\n                                     CodeCompletionAllocator &Allocator,\n                                     CodeCompletionTUInfo &CCTUInfo);\n\n  CodeCompletionString *createCodeCompletionStringForDecl(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  CodeCompletionString *createCodeCompletionStringForOverride(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  /// Retrieve the name that should be used to order a result.\n  ///\n  /// If the name needs to be constructed as a string, that string will be\n  /// saved into Saved and the returned StringRef will refer to it.\n  StringRef getOrderedName(std::string &Saved) const;\n\nprivate:\n  void computeCursorKindAndAvailability(bool Accessible = true);\n};\n\nbool operator<(const CodeCompletionResult &X, const CodeCompletionResult &Y);\n\ninline bool operator>(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return Y < X;\n}\n\ninline bool operator<=(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return !(Y < X);\n}\n\ninline bool operator>=(const CodeCompletionResult &X,\n                       const CodeCompletionResult &Y) {\n  return !(X < Y);\n}\n\n/// Abstract interface for a consumer of code-completion\n/// information.\nclass CodeCompleteConsumer {\nprotected:\n  const CodeCompleteOptions CodeCompleteOpts;\n\npublic:\n  class OverloadCandidate {\n  public:\n    /// Describes the type of overload candidate.\n    enum CandidateKind {\n      /// The candidate is a function declaration.\n      CK_Function,\n\n      /// The candidate is a function template.\n      CK_FunctionTemplate,\n\n      /// The \"candidate\" is actually a variable, expression, or block\n      /// for which we only have a function prototype.\n      CK_FunctionType\n    };\n\n  private:\n    /// The kind of overload candidate.\n    CandidateKind Kind;\n\n    union {\n      /// The function overload candidate, available when\n      /// Kind == CK_Function.\n      FunctionDecl *Function;\n\n      /// The function template overload candidate, available when\n      /// Kind == CK_FunctionTemplate.\n      FunctionTemplateDecl *FunctionTemplate;\n\n      /// The function type that describes the entity being called,\n      /// when Kind == CK_FunctionType.\n      const FunctionType *Type;\n    };\n\n  public:\n    OverloadCandidate(FunctionDecl *Function)\n        : Kind(CK_Function), Function(Function) {}\n\n    OverloadCandidate(FunctionTemplateDecl *FunctionTemplateDecl)\n        : Kind(CK_FunctionTemplate), FunctionTemplate(FunctionTemplateDecl) {}\n\n    OverloadCandidate(const FunctionType *Type)\n        : Kind(CK_FunctionType), Type(Type) {}\n\n    /// Determine the kind of overload candidate.\n    CandidateKind getKind() const { return Kind; }\n\n    /// Retrieve the function overload candidate or the templated\n    /// function declaration for a function template.\n    FunctionDecl *getFunction() const;\n\n    /// Retrieve the function template overload candidate.\n    FunctionTemplateDecl *getFunctionTemplate() const {\n      assert(getKind() == CK_FunctionTemplate && \"Not a function template\");\n      return FunctionTemplate;\n    }\n\n    /// Retrieve the function type of the entity, regardless of how the\n    /// function is stored.\n    const FunctionType *getFunctionType() const;\n\n    /// Create a new code-completion string that describes the function\n    /// signature of this overload candidate.\n    CodeCompletionString *CreateSignatureString(unsigned CurrentArg,\n                                                Sema &S,\n                                      CodeCompletionAllocator &Allocator,\n                                      CodeCompletionTUInfo &CCTUInfo,\n                                      bool IncludeBriefComments) const;\n  };\n\n  CodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts)\n      : CodeCompleteOpts(CodeCompleteOpts) {}\n\n  /// Whether the code-completion consumer wants to see macros.\n  bool includeMacros() const {\n    return CodeCompleteOpts.IncludeMacros;\n  }\n\n  /// Whether the code-completion consumer wants to see code patterns.\n  bool includeCodePatterns() const {\n    return CodeCompleteOpts.IncludeCodePatterns;\n  }\n\n  /// Whether to include global (top-level) declaration results.\n  bool includeGlobals() const { return CodeCompleteOpts.IncludeGlobals; }\n\n  /// Whether to include declarations in namespace contexts (including\n  /// the global namespace). If this is false, `includeGlobals()` will be\n  /// ignored.\n  bool includeNamespaceLevelDecls() const {\n    return CodeCompleteOpts.IncludeNamespaceLevelDecls;\n  }\n\n  /// Whether to include brief documentation comments within the set of\n  /// code completions returned.\n  bool includeBriefComments() const {\n    return CodeCompleteOpts.IncludeBriefComments;\n  }\n\n  /// Whether to include completion items with small fix-its, e.g. change\n  /// '.' to '->' on member access, etc.\n  bool includeFixIts() const { return CodeCompleteOpts.IncludeFixIts; }\n\n  /// Hint whether to load data from the external AST in order to provide\n  /// full results. If false, declarations from the preamble may be omitted.\n  bool loadExternal() const {\n    return CodeCompleteOpts.LoadExternal;\n  }\n\n  /// Deregisters and destroys this code-completion consumer.\n  virtual ~CodeCompleteConsumer();\n\n  /// \\name Code-completion filtering\n  /// Check if the result should be filtered out.\n  virtual bool isResultFilteredOut(StringRef Filter,\n                                   CodeCompletionResult Results) {\n    return false;\n  }\n\n  /// \\name Code-completion callbacks\n  //@{\n  /// Process the finalized code-completion results.\n  virtual void ProcessCodeCompleteResults(Sema &S,\n                                          CodeCompletionContext Context,\n                                          CodeCompletionResult *Results,\n                                          unsigned NumResults) {}\n\n  /// \\param S the semantic-analyzer object for which code-completion is being\n  /// done.\n  ///\n  /// \\param CurrentArg the index of the current argument.\n  ///\n  /// \\param Candidates an array of overload candidates.\n  ///\n  /// \\param NumCandidates the number of overload candidates\n  ///\n  /// \\param OpenParLoc location of the opening parenthesis of the argument\n  ///        list.\n  virtual void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                         OverloadCandidate *Candidates,\n                                         unsigned NumCandidates,\n                                         SourceLocation OpenParLoc) {}\n  //@}\n\n  /// Retrieve the allocator that will be used to allocate\n  /// code completion strings.\n  virtual CodeCompletionAllocator &getAllocator() = 0;\n\n  virtual CodeCompletionTUInfo &getCodeCompletionTUInfo() = 0;\n};\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Declaration.\nconst RawComment *getCompletionComment(const ASTContext &Ctx,\n                                       const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Pattern.\nconst RawComment *getPatternCompletionComment(const ASTContext &Ctx,\n                                              const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for OverloadCandidate.\nconst RawComment *\ngetParameterComment(const ASTContext &Ctx,\n                    const CodeCompleteConsumer::OverloadCandidate &Result,\n                    unsigned ArgIndex);\n\n/// A simple code-completion consumer that prints the results it\n/// receives in a simple format.\nclass PrintingCodeCompleteConsumer : public CodeCompleteConsumer {\n  /// The raw output stream.\n  raw_ostream &OS;\n\n  CodeCompletionTUInfo CCTUInfo;\n\npublic:\n  /// Create a new printing code-completion consumer that prints its\n  /// results to the given raw output stream.\n  PrintingCodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts,\n                               raw_ostream &OS)\n      : CodeCompleteConsumer(CodeCompleteOpts), OS(OS),\n        CCTUInfo(std::make_shared<GlobalCodeCompletionAllocator>()) {}\n\n  /// Prints the finalized code-completion results.\n  void ProcessCodeCompleteResults(Sema &S, CodeCompletionContext Context,\n                                  CodeCompletionResult *Results,\n                                  unsigned NumResults) override;\n\n  void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                 OverloadCandidate *Candidates,\n                                 unsigned NumCandidates,\n                                 SourceLocation OpenParLoc) override;\n\n  bool isResultFilteredOut(StringRef Filter, CodeCompletionResult Results) override;\n\n  CodeCompletionAllocator &getAllocator() override {\n    return CCTUInfo.getAllocator();\n  }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() override { return CCTUInfo; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n"}, "70": {"id": 70, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h", "content": "//===---- CodeCompleteOptions.h - Code Completion Options -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_CODECOMPLETEOPTIONS_H\n#define LLVM_CLANG_SEMA_CODECOMPLETEOPTIONS_H\n\nnamespace clang {\n\n/// Options controlling the behavior of code completion.\nclass CodeCompleteOptions {\npublic:\n  /// Show macros in code completion results.\n  unsigned IncludeMacros : 1;\n\n  /// Show code patterns in code completion results.\n  unsigned IncludeCodePatterns : 1;\n\n  /// Show top-level decls in code completion results.\n  unsigned IncludeGlobals : 1;\n\n  /// Show decls in namespace (including the global namespace) in code\n  /// completion results. If this is 0, `IncludeGlobals` will be ignored.\n  ///\n  /// Currently, this only works when completing qualified IDs (i.e.\n  /// `Sema::CodeCompleteQualifiedId`).\n  /// FIXME: consider supporting more completion cases with this option.\n  unsigned IncludeNamespaceLevelDecls : 1;\n\n  /// Show brief documentation comments in code completion results.\n  unsigned IncludeBriefComments : 1;\n\n  /// Hint whether to load data from the external AST to provide full results.\n  /// If false, namespace-level declarations and macros from the preamble may be\n  /// omitted.\n  unsigned LoadExternal : 1;\n\n  /// Include results after corrections (small fix-its), e.g. change '.' to '->'\n  /// on member access, etc.\n  unsigned IncludeFixIts : 1;\n\n  CodeCompleteOptions()\n      : IncludeMacros(0), IncludeCodePatterns(0), IncludeGlobals(1),\n        IncludeNamespaceLevelDecls(1), IncludeBriefComments(0),\n        LoadExternal(1), IncludeFixIts(0) {}\n};\n\n} // namespace clang\n\n#endif\n\n"}, "71": {"id": 71, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "content": "//===--- DeclSpec.h - Parsed declaration specifiers -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file defines the classes used to store parsed information about\n/// declaration-specifiers and declarators.\n///\n/// \\verbatim\n///   static const int volatile x, *y, *(*(*z)[10])(const void *x);\n///   ------------------------- -  --  ---------------------------\n///     declaration-specifiers  \\  |   /\n///                            declarators\n/// \\endverbatim\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_DECLSPEC_H\n#define LLVM_CLANG_SEMA_DECLSPEC_H\n\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/ParsedAttr.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n\nnamespace clang {\n  class ASTContext;\n  class CXXRecordDecl;\n  class TypeLoc;\n  class LangOptions;\n  class IdentifierInfo;\n  class NamespaceAliasDecl;\n  class NamespaceDecl;\n  class ObjCDeclSpec;\n  class Sema;\n  class Declarator;\n  struct TemplateIdAnnotation;\n\n/// Represents a C++ nested-name-specifier or a global scope specifier.\n///\n/// These can be in 3 states:\n///   1) Not present, identified by isEmpty()\n///   2) Present, identified by isNotEmpty()\n///      2.a) Valid, identified by isValid()\n///      2.b) Invalid, identified by isInvalid().\n///\n/// isSet() is deprecated because it mostly corresponded to \"valid\" but was\n/// often used as if it meant \"present\".\n///\n/// The actual scope is described by getScopeRep().\nclass CXXScopeSpec {\n  SourceRange Range;\n  NestedNameSpecifierLocBuilder Builder;\n\npublic:\n  SourceRange getRange() const { return Range; }\n  void setRange(SourceRange R) { Range = R; }\n  void setBeginLoc(SourceLocation Loc) { Range.setBegin(Loc); }\n  void setEndLoc(SourceLocation Loc) { Range.setEnd(Loc); }\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n\n  /// Retrieve the representation of the nested-name-specifier.\n  NestedNameSpecifier *getScopeRep() const {\n    return Builder.getRepresentation();\n  }\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'type::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param TemplateKWLoc The location of the 'template' keyword, if present.\n  ///\n  /// \\param TL The TypeLoc that describes the type preceding the '::'.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, SourceLocation TemplateKWLoc, TypeLoc TL,\n              SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'identifier::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Identifier The identifier.\n  ///\n  /// \\param IdentifierLoc The location of the identifier.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, IdentifierInfo *Identifier,\n              SourceLocation IdentifierLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Namespace The namespace.\n  ///\n  /// \\param NamespaceLoc The location of the namespace name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceDecl *Namespace,\n              SourceLocation NamespaceLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace-alias::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Alias The namespace alias.\n  ///\n  /// \\param AliasLoc The location of the namespace alias\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceAliasDecl *Alias,\n              SourceLocation AliasLoc, SourceLocation ColonColonLoc);\n\n  /// Turn this (empty) nested-name-specifier into the global\n  /// nested-name-specifier '::'.\n  void MakeGlobal(ASTContext &Context, SourceLocation ColonColonLoc);\n\n  /// Turns this (empty) nested-name-specifier into '__super'\n  /// nested-name-specifier.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param RD The declaration of the class in which nested-name-specifier\n  /// appeared.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void MakeSuper(ASTContext &Context, CXXRecordDecl *RD,\n                 SourceLocation SuperLoc, SourceLocation ColonColonLoc);\n\n  /// Make a new nested-name-specifier from incomplete source-location\n  /// information.\n  ///\n  /// FIXME: This routine should be used very, very rarely, in cases where we\n  /// need to synthesize a nested-name-specifier. Most code should instead use\n  /// \\c Adopt() with a proper \\c NestedNameSpecifierLoc.\n  void MakeTrivial(ASTContext &Context, NestedNameSpecifier *Qualifier,\n                   SourceRange R);\n\n  /// Adopt an existing nested-name-specifier (with source-range\n  /// information).\n  void Adopt(NestedNameSpecifierLoc Other);\n\n  /// Retrieve a nested-name-specifier with location information, copied\n  /// into the given AST context.\n  ///\n  /// \\param Context The context into which this nested-name-specifier will be\n  /// copied.\n  NestedNameSpecifierLoc getWithLocInContext(ASTContext &Context) const;\n\n  /// Retrieve the location of the name in the last qualifier\n  /// in this nested name specifier.\n  ///\n  /// For example, the location of \\c bar\n  /// in\n  /// \\verbatim\n  ///   \\::foo::bar<0>::\n  ///           ^~~\n  /// \\endverbatim\n  SourceLocation getLastQualifierNameLoc() const;\n\n  /// No scope specifier.\n  bool isEmpty() const { return Range.isInvalid() && getScopeRep() == nullptr; }\n  /// A scope specifier is present, but may be valid or invalid.\n  bool isNotEmpty() const { return !isEmpty(); }\n\n  /// An error occurred during parsing of the scope specifier.\n  bool isInvalid() const { return Range.isValid() && getScopeRep() == nullptr; }\n  /// A scope specifier is present, and it refers to a real scope.\n  bool isValid() const { return getScopeRep() != nullptr; }\n\n  /// Indicate that this nested-name-specifier is invalid.\n  void SetInvalid(SourceRange R) {\n    assert(R.isValid() && \"Must have a valid source range\");\n    if (Range.getBegin().isInvalid())\n      Range.setBegin(R.getBegin());\n    Range.setEnd(R.getEnd());\n    Builder.Clear();\n  }\n\n  /// Deprecated.  Some call sites intend isNotEmpty() while others intend\n  /// isValid().\n  bool isSet() const { return getScopeRep() != nullptr; }\n\n  void clear() {\n    Range = SourceRange();\n    Builder.Clear();\n  }\n\n  /// Retrieve the data associated with the source-location information.\n  char *location_data() const { return Builder.getBuffer().first; }\n\n  /// Retrieve the size of the data associated with source-location\n  /// information.\n  unsigned location_size() const { return Builder.getBuffer().second; }\n};\n\n/// Captures information about \"declaration specifiers\".\n///\n/// \"Declaration specifiers\" encompasses storage-class-specifiers,\n/// type-specifiers, type-qualifiers, and function-specifiers.\nclass DeclSpec {\npublic:\n  /// storage-class-specifier\n  /// \\note The order of these enumerators is important for diagnostics.\n  enum SCS {\n    SCS_unspecified = 0,\n    SCS_typedef,\n    SCS_extern,\n    SCS_static,\n    SCS_auto,\n    SCS_register,\n    SCS_private_extern,\n    SCS_mutable\n  };\n\n  // Import thread storage class specifier enumeration and constants.\n  // These can be combined with SCS_extern and SCS_static.\n  typedef ThreadStorageClassSpecifier TSCS;\n  static const TSCS TSCS_unspecified = clang::TSCS_unspecified;\n  static const TSCS TSCS___thread = clang::TSCS___thread;\n  static const TSCS TSCS_thread_local = clang::TSCS_thread_local;\n  static const TSCS TSCS__Thread_local = clang::TSCS__Thread_local;\n\n  enum TSC {\n    TSC_unspecified,\n    TSC_imaginary,\n    TSC_complex\n  };\n\n  // Import type specifier type enumeration and constants.\n  typedef TypeSpecifierType TST;\n  static const TST TST_unspecified = clang::TST_unspecified;\n  static const TST TST_void = clang::TST_void;\n  static const TST TST_char = clang::TST_char;\n  static const TST TST_wchar = clang::TST_wchar;\n  static const TST TST_char8 = clang::TST_char8;\n  static const TST TST_char16 = clang::TST_char16;\n  static const TST TST_char32 = clang::TST_char32;\n  static const TST TST_int = clang::TST_int;\n  static const TST TST_int128 = clang::TST_int128;\n  static const TST TST_extint = clang::TST_extint;\n  static const TST TST_half = clang::TST_half;\n  static const TST TST_BFloat16 = clang::TST_BFloat16;\n  static const TST TST_float = clang::TST_float;\n  static const TST TST_double = clang::TST_double;\n  static const TST TST_float16 = clang::TST_Float16;\n  static const TST TST_accum = clang::TST_Accum;\n  static const TST TST_fract = clang::TST_Fract;\n  static const TST TST_float128 = clang::TST_float128;\n  static const TST TST_bool = clang::TST_bool;\n  static const TST TST_decimal32 = clang::TST_decimal32;\n  static const TST TST_decimal64 = clang::TST_decimal64;\n  static const TST TST_decimal128 = clang::TST_decimal128;\n  static const TST TST_enum = clang::TST_enum;\n  static const TST TST_union = clang::TST_union;\n  static const TST TST_struct = clang::TST_struct;\n  static const TST TST_interface = clang::TST_interface;\n  static const TST TST_class = clang::TST_class;\n  static const TST TST_typename = clang::TST_typename;\n  static const TST TST_typeofType = clang::TST_typeofType;\n  static const TST TST_typeofExpr = clang::TST_typeofExpr;\n  static const TST TST_decltype = clang::TST_decltype;\n  static const TST TST_decltype_auto = clang::TST_decltype_auto;\n  static const TST TST_underlyingType = clang::TST_underlyingType;\n  static const TST TST_auto = clang::TST_auto;\n  static const TST TST_auto_type = clang::TST_auto_type;\n  static const TST TST_unknown_anytype = clang::TST_unknown_anytype;\n  static const TST TST_atomic = clang::TST_atomic;\n#define GENERIC_IMAGE_TYPE(ImgType, Id) \\\n  static const TST TST_##ImgType##_t = clang::TST_##ImgType##_t;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  static const TST TST_error = clang::TST_error;\n\n  // type-qualifiers\n  enum TQ {   // NOTE: These flags must be kept in sync with Qualifiers::TQ.\n    TQ_unspecified = 0,\n    TQ_const       = 1,\n    TQ_restrict    = 2,\n    TQ_volatile    = 4,\n    TQ_unaligned   = 8,\n    // This has no corresponding Qualifiers::TQ value, because it's not treated\n    // as a qualifier in our type system.\n    TQ_atomic      = 16\n  };\n\n  /// ParsedSpecifiers - Flags to query which specifiers were applied.  This is\n  /// returned by getParsedSpecifiers.\n  enum ParsedSpecifiers {\n    PQ_None                  = 0,\n    PQ_StorageClassSpecifier = 1,\n    PQ_TypeSpecifier         = 2,\n    PQ_TypeQualifier         = 4,\n    PQ_FunctionSpecifier     = 8\n    // FIXME: Attributes should be included here.\n  };\n\nprivate:\n  // storage-class-specifier\n  /*SCS*/unsigned StorageClassSpec : 3;\n  /*TSCS*/unsigned ThreadStorageClassSpec : 2;\n  unsigned SCS_extern_in_linkage_spec : 1;\n\n  // type-specifier\n  /*TypeSpecifierWidth*/ unsigned TypeSpecWidth : 2;\n  /*TSC*/unsigned TypeSpecComplex : 2;\n  /*TSS*/unsigned TypeSpecSign : 2;\n  /*TST*/unsigned TypeSpecType : 6;\n  unsigned TypeAltiVecVector : 1;\n  unsigned TypeAltiVecPixel : 1;\n  unsigned TypeAltiVecBool : 1;\n  unsigned TypeSpecOwned : 1;\n  unsigned TypeSpecPipe : 1;\n  unsigned TypeSpecSat : 1;\n  unsigned ConstrainedAuto : 1;\n\n  // type-qualifiers\n  unsigned TypeQualifiers : 5;  // Bitwise OR of TQ.\n\n  // function-specifier\n  unsigned FS_inline_specified : 1;\n  unsigned FS_forceinline_specified: 1;\n  unsigned FS_virtual_specified : 1;\n  unsigned FS_noreturn_specified : 1;\n\n  // friend-specifier\n  unsigned Friend_specified : 1;\n\n  // constexpr-specifier\n  unsigned ConstexprSpecifier : 2;\n\n  union {\n    UnionParsedType TypeRep;\n    Decl *DeclRep;\n    Expr *ExprRep;\n    TemplateIdAnnotation *TemplateIdRep;\n  };\n\n  /// ExplicitSpecifier - Store information about explicit spicifer.\n  ExplicitSpecifier FS_explicit_specifier;\n\n  // attributes.\n  ParsedAttributes Attrs;\n\n  // Scope specifier for the type spec, if applicable.\n  CXXScopeSpec TypeScope;\n\n  // SourceLocation info.  These are null if the item wasn't specified or if\n  // the setting was synthesized.\n  SourceRange Range;\n\n  SourceLocation StorageClassSpecLoc, ThreadStorageClassSpecLoc;\n  SourceRange TSWRange;\n  SourceLocation TSCLoc, TSSLoc, TSTLoc, AltiVecLoc, TSSatLoc;\n  /// TSTNameLoc - If TypeSpecType is any of class, enum, struct, union,\n  /// typename, then this is the location of the named type (if present);\n  /// otherwise, it is the same as TSTLoc. Hence, the pair TSTLoc and\n  /// TSTNameLoc provides source range info for tag types.\n  SourceLocation TSTNameLoc;\n  SourceRange TypeofParensRange;\n  SourceLocation TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc,\n      TQ_unalignedLoc;\n  SourceLocation FS_inlineLoc, FS_virtualLoc, FS_explicitLoc, FS_noreturnLoc;\n  SourceLocation FS_explicitCloseParenLoc;\n  SourceLocation FS_forceinlineLoc;\n  SourceLocation FriendLoc, ModulePrivateLoc, ConstexprLoc;\n  SourceLocation TQ_pipeLoc;\n\n  WrittenBuiltinSpecs writtenBS;\n  void SaveWrittenBuiltinSpecs();\n\n  ObjCDeclSpec *ObjCQualifiers;\n\n  static bool isTypeRep(TST T) {\n    return (T == TST_typename || T == TST_typeofType ||\n            T == TST_underlyingType || T == TST_atomic);\n  }\n  static bool isExprRep(TST T) {\n    return (T == TST_typeofExpr || T == TST_decltype || T == TST_extint);\n  }\n  static bool isTemplateIdRep(TST T) {\n    return (T == TST_auto || T == TST_decltype_auto);\n  }\n\n  DeclSpec(const DeclSpec &) = delete;\n  void operator=(const DeclSpec &) = delete;\npublic:\n  static bool isDeclRep(TST T) {\n    return (T == TST_enum || T == TST_struct ||\n            T == TST_interface || T == TST_union ||\n            T == TST_class);\n  }\n\n  DeclSpec(AttributeFactory &attrFactory)\n      : StorageClassSpec(SCS_unspecified),\n        ThreadStorageClassSpec(TSCS_unspecified),\n        SCS_extern_in_linkage_spec(false),\n        TypeSpecWidth(static_cast<unsigned>(TypeSpecifierWidth::Unspecified)),\n        TypeSpecComplex(TSC_unspecified),\n        TypeSpecSign(static_cast<unsigned>(TypeSpecifierSign::Unspecified)),\n        TypeSpecType(TST_unspecified), TypeAltiVecVector(false),\n        TypeAltiVecPixel(false), TypeAltiVecBool(false), TypeSpecOwned(false),\n        TypeSpecPipe(false), TypeSpecSat(false), ConstrainedAuto(false),\n        TypeQualifiers(TQ_unspecified), FS_inline_specified(false),\n        FS_forceinline_specified(false), FS_virtual_specified(false),\n        FS_noreturn_specified(false), Friend_specified(false),\n        ConstexprSpecifier(\n            static_cast<unsigned>(ConstexprSpecKind::Unspecified)),\n        FS_explicit_specifier(), Attrs(attrFactory), writtenBS(),\n        ObjCQualifiers(nullptr) {}\n\n  // storage-class-specifier\n  SCS getStorageClassSpec() const { return (SCS)StorageClassSpec; }\n  TSCS getThreadStorageClassSpec() const {\n    return (TSCS)ThreadStorageClassSpec;\n  }\n  bool isExternInLinkageSpec() const { return SCS_extern_in_linkage_spec; }\n  void setExternInLinkageSpec(bool Value) {\n    SCS_extern_in_linkage_spec = Value;\n  }\n\n  SourceLocation getStorageClassSpecLoc() const { return StorageClassSpecLoc; }\n  SourceLocation getThreadStorageClassSpecLoc() const {\n    return ThreadStorageClassSpecLoc;\n  }\n\n  void ClearStorageClassSpecs() {\n    StorageClassSpec           = DeclSpec::SCS_unspecified;\n    ThreadStorageClassSpec     = DeclSpec::TSCS_unspecified;\n    SCS_extern_in_linkage_spec = false;\n    StorageClassSpecLoc        = SourceLocation();\n    ThreadStorageClassSpecLoc  = SourceLocation();\n  }\n\n  void ClearTypeSpecType() {\n    TypeSpecType = DeclSpec::TST_unspecified;\n    TypeSpecOwned = false;\n    TSTLoc = SourceLocation();\n  }\n\n  // type-specifier\n  TypeSpecifierWidth getTypeSpecWidth() const {\n    return static_cast<TypeSpecifierWidth>(TypeSpecWidth);\n  }\n  TSC getTypeSpecComplex() const { return (TSC)TypeSpecComplex; }\n  TypeSpecifierSign getTypeSpecSign() const {\n    return static_cast<TypeSpecifierSign>(TypeSpecSign);\n  }\n  TST getTypeSpecType() const { return (TST)TypeSpecType; }\n  bool isTypeAltiVecVector() const { return TypeAltiVecVector; }\n  bool isTypeAltiVecPixel() const { return TypeAltiVecPixel; }\n  bool isTypeAltiVecBool() const { return TypeAltiVecBool; }\n  bool isTypeSpecOwned() const { return TypeSpecOwned; }\n  bool isTypeRep() const { return isTypeRep((TST) TypeSpecType); }\n  bool isTypeSpecPipe() const { return TypeSpecPipe; }\n  bool isTypeSpecSat() const { return TypeSpecSat; }\n  bool isConstrainedAuto() const { return ConstrainedAuto; }\n\n  ParsedType getRepAsType() const {\n    assert(isTypeRep((TST) TypeSpecType) && \"DeclSpec does not store a type\");\n    return TypeRep;\n  }\n  Decl *getRepAsDecl() const {\n    assert(isDeclRep((TST) TypeSpecType) && \"DeclSpec does not store a decl\");\n    return DeclRep;\n  }\n  Expr *getRepAsExpr() const {\n    assert(isExprRep((TST) TypeSpecType) && \"DeclSpec does not store an expr\");\n    return ExprRep;\n  }\n  TemplateIdAnnotation *getRepAsTemplateId() const {\n    assert(isTemplateIdRep((TST) TypeSpecType) &&\n           \"DeclSpec does not store a template id\");\n    return TemplateIdRep;\n  }\n  CXXScopeSpec &getTypeSpecScope() { return TypeScope; }\n  const CXXScopeSpec &getTypeSpecScope() const { return TypeScope; }\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceLocation getTypeSpecWidthLoc() const { return TSWRange.getBegin(); }\n  SourceRange getTypeSpecWidthRange() const { return TSWRange; }\n  SourceLocation getTypeSpecComplexLoc() const { return TSCLoc; }\n  SourceLocation getTypeSpecSignLoc() const { return TSSLoc; }\n  SourceLocation getTypeSpecTypeLoc() const { return TSTLoc; }\n  SourceLocation getAltiVecLoc() const { return AltiVecLoc; }\n  SourceLocation getTypeSpecSatLoc() const { return TSSatLoc; }\n\n  SourceLocation getTypeSpecTypeNameLoc() const {\n    assert(isDeclRep((TST) TypeSpecType) || TypeSpecType == TST_typename);\n    return TSTNameLoc;\n  }\n\n  SourceRange getTypeofParensRange() const { return TypeofParensRange; }\n  void setTypeofParensRange(SourceRange range) { TypeofParensRange = range; }\n\n  bool hasAutoTypeSpec() const {\n    return (TypeSpecType == TST_auto || TypeSpecType == TST_auto_type ||\n            TypeSpecType == TST_decltype_auto);\n  }\n\n  bool hasTagDefinition() const;\n\n  /// Turn a type-specifier-type into a string like \"_Bool\" or \"union\".\n  static const char *getSpecifierName(DeclSpec::TST T,\n                                      const PrintingPolicy &Policy);\n  static const char *getSpecifierName(DeclSpec::TQ Q);\n  static const char *getSpecifierName(TypeSpecifierSign S);\n  static const char *getSpecifierName(DeclSpec::TSC C);\n  static const char *getSpecifierName(TypeSpecifierWidth W);\n  static const char *getSpecifierName(DeclSpec::SCS S);\n  static const char *getSpecifierName(DeclSpec::TSCS S);\n  static const char *getSpecifierName(ConstexprSpecKind C);\n\n  // type-qualifiers\n\n  /// getTypeQualifiers - Return a set of TQs.\n  unsigned getTypeQualifiers() const { return TypeQualifiers; }\n  SourceLocation getConstSpecLoc() const { return TQ_constLoc; }\n  SourceLocation getRestrictSpecLoc() const { return TQ_restrictLoc; }\n  SourceLocation getVolatileSpecLoc() const { return TQ_volatileLoc; }\n  SourceLocation getAtomicSpecLoc() const { return TQ_atomicLoc; }\n  SourceLocation getUnalignedSpecLoc() const { return TQ_unalignedLoc; }\n  SourceLocation getPipeLoc() const { return TQ_pipeLoc; }\n\n  /// Clear out all of the type qualifiers.\n  void ClearTypeQualifiers() {\n    TypeQualifiers = 0;\n    TQ_constLoc = SourceLocation();\n    TQ_restrictLoc = SourceLocation();\n    TQ_volatileLoc = SourceLocation();\n    TQ_atomicLoc = SourceLocation();\n    TQ_unalignedLoc = SourceLocation();\n    TQ_pipeLoc = SourceLocation();\n  }\n\n  // function-specifier\n  bool isInlineSpecified() const {\n    return FS_inline_specified | FS_forceinline_specified;\n  }\n  SourceLocation getInlineSpecLoc() const {\n    return FS_inline_specified ? FS_inlineLoc : FS_forceinlineLoc;\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() const {\n    return FS_explicit_specifier;\n  }\n\n  bool isVirtualSpecified() const { return FS_virtual_specified; }\n  SourceLocation getVirtualSpecLoc() const { return FS_virtualLoc; }\n\n  bool hasExplicitSpecifier() const {\n    return FS_explicit_specifier.isSpecified();\n  }\n  SourceLocation getExplicitSpecLoc() const { return FS_explicitLoc; }\n  SourceRange getExplicitSpecRange() const {\n    return FS_explicit_specifier.getExpr()\n               ? SourceRange(FS_explicitLoc, FS_explicitCloseParenLoc)\n               : SourceRange(FS_explicitLoc);\n  }\n\n  bool isNoreturnSpecified() const { return FS_noreturn_specified; }\n  SourceLocation getNoreturnSpecLoc() const { return FS_noreturnLoc; }\n\n  void ClearFunctionSpecs() {\n    FS_inline_specified = false;\n    FS_inlineLoc = SourceLocation();\n    FS_forceinline_specified = false;\n    FS_forceinlineLoc = SourceLocation();\n    FS_virtual_specified = false;\n    FS_virtualLoc = SourceLocation();\n    FS_explicit_specifier = ExplicitSpecifier();\n    FS_explicitLoc = SourceLocation();\n    FS_explicitCloseParenLoc = SourceLocation();\n    FS_noreturn_specified = false;\n    FS_noreturnLoc = SourceLocation();\n  }\n\n  /// This method calls the passed in handler on each CVRU qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachCVRUQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// This method calls the passed in handler on each qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// Return true if any type-specifier has been found.\n  bool hasTypeSpecifier() const {\n    return getTypeSpecType() != DeclSpec::TST_unspecified ||\n           getTypeSpecWidth() != TypeSpecifierWidth::Unspecified ||\n           getTypeSpecComplex() != DeclSpec::TSC_unspecified ||\n           getTypeSpecSign() != TypeSpecifierSign::Unspecified;\n  }\n\n  /// Return a bitmask of which flavors of specifiers this\n  /// DeclSpec includes.\n  unsigned getParsedSpecifiers() const;\n\n  /// isEmpty - Return true if this declaration specifier is completely empty:\n  /// no tokens were parsed in the production of it.\n  bool isEmpty() const {\n    return getParsedSpecifiers() == DeclSpec::PQ_None;\n  }\n\n  void SetRangeStart(SourceLocation Loc) { Range.setBegin(Loc); }\n  void SetRangeEnd(SourceLocation Loc) { Range.setEnd(Loc); }\n\n  /// These methods set the specified attribute of the DeclSpec and\n  /// return false if there was no error.  If an error occurs (for\n  /// example, if we tried to set \"auto\" on a spec with \"extern\"\n  /// already set), they return true and set PrevSpec and DiagID\n  /// such that\n  ///   Diag(Loc, DiagID) << PrevSpec;\n  /// will yield a useful result.\n  ///\n  /// TODO: use a more general approach that still allows these\n  /// diagnostics to be ignored when desired.\n  bool SetStorageClassSpec(Sema &S, SCS SC, SourceLocation Loc,\n                           const char *&PrevSpec, unsigned &DiagID,\n                           const PrintingPolicy &Policy);\n  bool SetStorageClassSpecThread(TSCS TSC, SourceLocation Loc,\n                                 const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecWidth(TypeSpecifierWidth W, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID,\n                        const PrintingPolicy &Policy);\n  bool SetTypeSpecComplex(TSC C, SourceLocation Loc, const char *&PrevSpec,\n                          unsigned &DiagID);\n  bool SetTypeSpecSign(TypeSpecifierSign S, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TypeResult Rep,\n                       const PrintingPolicy &Policy) {\n    if (Rep.isInvalid())\n      return SetTypeSpecError();\n    return SetTypeSpecType(T, Loc, PrevSpec, DiagID, Rep.get(), Policy);\n  }\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TemplateIdAnnotation *Rep,\n                       const PrintingPolicy &Policy);\n\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Expr *Rep,\n                       const PrintingPolicy &policy);\n  bool SetTypeAltiVecVector(bool isAltiVecVector, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecPixel(bool isAltiVecPixel, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecBool(bool isAltiVecBool, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypePipe(bool isPipe, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetExtIntType(SourceLocation KWLoc, Expr *BitWidth,\n                     const char *&PrevSpec, unsigned &DiagID,\n                     const PrintingPolicy &Policy);\n  bool SetTypeSpecSat(SourceLocation Loc, const char *&PrevSpec,\n                      unsigned &DiagID);\n  bool SetTypeSpecError();\n  void UpdateDeclRep(Decl *Rep) {\n    assert(isDeclRep((TST) TypeSpecType));\n    DeclRep = Rep;\n  }\n  void UpdateTypeRep(ParsedType Rep) {\n    assert(isTypeRep((TST) TypeSpecType));\n    TypeRep = Rep;\n  }\n  void UpdateExprRep(Expr *Rep) {\n    assert(isExprRep((TST) TypeSpecType));\n    ExprRep = Rep;\n  }\n\n  bool SetTypeQual(TQ T, SourceLocation Loc);\n\n  bool SetTypeQual(TQ T, SourceLocation Loc, const char *&PrevSpec,\n                   unsigned &DiagID, const LangOptions &Lang);\n\n  bool setFunctionSpecInline(SourceLocation Loc, const char *&PrevSpec,\n                             unsigned &DiagID);\n  bool setFunctionSpecForceInline(SourceLocation Loc, const char *&PrevSpec,\n                                  unsigned &DiagID);\n  bool setFunctionSpecVirtual(SourceLocation Loc, const char *&PrevSpec,\n                              unsigned &DiagID);\n  bool setFunctionSpecExplicit(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID, ExplicitSpecifier ExplicitSpec,\n                               SourceLocation CloseParenLoc);\n  bool setFunctionSpecNoreturn(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID);\n\n  bool SetFriendSpec(SourceLocation Loc, const char *&PrevSpec,\n                     unsigned &DiagID);\n  bool setModulePrivateSpec(SourceLocation Loc, const char *&PrevSpec,\n                            unsigned &DiagID);\n  bool SetConstexprSpec(ConstexprSpecKind ConstexprKind, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID);\n\n  bool isFriendSpecified() const { return Friend_specified; }\n  SourceLocation getFriendSpecLoc() const { return FriendLoc; }\n\n  bool isModulePrivateSpecified() const { return ModulePrivateLoc.isValid(); }\n  SourceLocation getModulePrivateSpecLoc() const { return ModulePrivateLoc; }\n\n  ConstexprSpecKind getConstexprSpecifier() const {\n    return ConstexprSpecKind(ConstexprSpecifier);\n  }\n\n  SourceLocation getConstexprSpecLoc() const { return ConstexprLoc; }\n  bool hasConstexprSpecifier() const {\n    return getConstexprSpecifier() != ConstexprSpecKind::Unspecified;\n  }\n\n  void ClearConstexprSpec() {\n    ConstexprSpecifier = static_cast<unsigned>(ConstexprSpecKind::Unspecified);\n    ConstexprLoc = SourceLocation();\n  }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// Concatenates two attribute lists.\n  ///\n  /// The GCC attribute syntax allows for the following:\n  ///\n  /// \\code\n  /// short __attribute__(( unused, deprecated ))\n  /// int __attribute__(( may_alias, aligned(16) )) var;\n  /// \\endcode\n  ///\n  /// This declares 4 attributes using 2 lists. The following syntax is\n  /// also allowed and equivalent to the previous declaration.\n  ///\n  /// \\code\n  /// short __attribute__((unused)) __attribute__((deprecated))\n  /// int __attribute__((may_alias)) __attribute__((aligned(16))) var;\n  /// \\endcode\n  ///\n  void addAttributes(ParsedAttributesView &AL) {\n    Attrs.addAll(AL.begin(), AL.end());\n  }\n\n  bool hasAttributes() const { return !Attrs.empty(); }\n\n  ParsedAttributes &getAttributes() { return Attrs; }\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n\n  void takeAttributesFrom(ParsedAttributes &attrs) {\n    Attrs.takeAllFrom(attrs);\n  }\n\n  /// Finish - This does final analysis of the declspec, issuing diagnostics for\n  /// things like \"_Imaginary\" (lacking an FP type).  After calling this method,\n  /// DeclSpec is guaranteed self-consistent, even if an error occurred.\n  void Finish(Sema &S, const PrintingPolicy &Policy);\n\n  const WrittenBuiltinSpecs& getWrittenBuiltinSpecs() const {\n    return writtenBS;\n  }\n\n  ObjCDeclSpec *getObjCQualifiers() const { return ObjCQualifiers; }\n  void setObjCQualifiers(ObjCDeclSpec *quals) { ObjCQualifiers = quals; }\n\n  /// Checks if this DeclSpec can stand alone, without a Declarator.\n  ///\n  /// Only tag declspecs can stand alone.\n  bool isMissingDeclaratorOk();\n};\n\n/// Captures information about \"declaration specifiers\" specific to\n/// Objective-C.\nclass ObjCDeclSpec {\npublic:\n  /// ObjCDeclQualifier - Qualifier used on types in method\n  /// declarations.  Not all combinations are sensible.  Parameters\n  /// can be one of { in, out, inout } with one of { bycopy, byref }.\n  /// Returns can either be { oneway } or not.\n  ///\n  /// This should be kept in sync with Decl::ObjCDeclQualifier.\n  enum ObjCDeclQualifier {\n    DQ_None = 0x0,\n    DQ_In = 0x1,\n    DQ_Inout = 0x2,\n    DQ_Out = 0x4,\n    DQ_Bycopy = 0x8,\n    DQ_Byref = 0x10,\n    DQ_Oneway = 0x20,\n    DQ_CSNullability = 0x40\n  };\n\n  ObjCDeclSpec()\n      : objcDeclQualifier(DQ_None),\n        PropertyAttributes(ObjCPropertyAttribute::kind_noattr), Nullability(0),\n        GetterName(nullptr), SetterName(nullptr) {}\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    return (ObjCDeclQualifier)objcDeclQualifier;\n  }\n  void setObjCDeclQualifier(ObjCDeclQualifier DQVal) {\n    objcDeclQualifier = (ObjCDeclQualifier) (objcDeclQualifier | DQVal);\n  }\n  void clearObjCDeclQualifier(ObjCDeclQualifier DQVal) {\n    objcDeclQualifier = (ObjCDeclQualifier) (objcDeclQualifier & ~DQVal);\n  }\n\n  ObjCPropertyAttribute::Kind getPropertyAttributes() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributes);\n  }\n  void setPropertyAttributes(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributes =\n        (ObjCPropertyAttribute::Kind)(PropertyAttributes | PRVal);\n  }\n\n  NullabilityKind getNullability() const {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Objective-C declspec doesn't have nullability\");\n    return static_cast<NullabilityKind>(Nullability);\n  }\n\n  SourceLocation getNullabilityLoc() const {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Objective-C declspec doesn't have nullability\");\n    return NullabilityLoc;\n  }\n\n  void setNullability(SourceLocation loc, NullabilityKind kind) {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Set the nullability declspec or property attribute first\");\n    Nullability = static_cast<unsigned>(kind);\n    NullabilityLoc = loc;\n  }\n\n  const IdentifierInfo *getGetterName() const { return GetterName; }\n  IdentifierInfo *getGetterName() { return GetterName; }\n  SourceLocation getGetterNameLoc() const { return GetterNameLoc; }\n  void setGetterName(IdentifierInfo *name, SourceLocation loc) {\n    GetterName = name;\n    GetterNameLoc = loc;\n  }\n\n  const IdentifierInfo *getSetterName() const { return SetterName; }\n  IdentifierInfo *getSetterName() { return SetterName; }\n  SourceLocation getSetterNameLoc() const { return SetterNameLoc; }\n  void setSetterName(IdentifierInfo *name, SourceLocation loc) {\n    SetterName = name;\n    SetterNameLoc = loc;\n  }\n\nprivate:\n  // FIXME: These two are unrelated and mutually exclusive. So perhaps\n  // we can put them in a union to reflect their mutual exclusivity\n  // (space saving is negligible).\n  unsigned objcDeclQualifier : 7;\n\n  // NOTE: VC++ treats enums as signed, avoid using ObjCPropertyAttribute::Kind\n  unsigned PropertyAttributes : NumObjCPropertyAttrsBits;\n\n  unsigned Nullability : 2;\n\n  SourceLocation NullabilityLoc;\n\n  IdentifierInfo *GetterName;    // getter name or NULL if no getter\n  IdentifierInfo *SetterName;    // setter name or NULL if no setter\n  SourceLocation GetterNameLoc; // location of the getter attribute's value\n  SourceLocation SetterNameLoc; // location of the setter attribute's value\n\n};\n\n/// Describes the kind of unqualified-id parsed.\nenum class UnqualifiedIdKind {\n  /// An identifier.\n  IK_Identifier,\n  /// An overloaded operator name, e.g., operator+.\n  IK_OperatorFunctionId,\n  /// A conversion function name, e.g., operator int.\n  IK_ConversionFunctionId,\n  /// A user-defined literal name, e.g., operator \"\" _i.\n  IK_LiteralOperatorId,\n  /// A constructor name.\n  IK_ConstructorName,\n  /// A constructor named via a template-id.\n  IK_ConstructorTemplateId,\n  /// A destructor name.\n  IK_DestructorName,\n  /// A template-id, e.g., f<int>.\n  IK_TemplateId,\n  /// An implicit 'self' parameter\n  IK_ImplicitSelfParam,\n  /// A deduction-guide name (a template-name)\n  IK_DeductionGuideName\n};\n\n/// Represents a C++ unqualified-id that has been parsed.\nclass UnqualifiedId {\nprivate:\n  UnqualifiedId(const UnqualifiedId &Other) = delete;\n  const UnqualifiedId &operator=(const UnqualifiedId &) = delete;\n\npublic:\n  /// Describes the kind of unqualified-id parsed.\n  UnqualifiedIdKind Kind;\n\n  struct OFI {\n    /// The kind of overloaded operator.\n    OverloadedOperatorKind Operator;\n\n    /// The source locations of the individual tokens that name\n    /// the operator, e.g., the \"new\", \"[\", and \"]\" tokens in\n    /// operator new [].\n    ///\n    /// Different operators have different numbers of tokens in their name,\n    /// up to three. Any remaining source locations in this array will be\n    /// set to an invalid value for operators with fewer than three tokens.\n    SourceLocation SymbolLocations[3];\n  };\n\n  /// Anonymous union that holds extra data associated with the\n  /// parsed unqualified-id.\n  union {\n    /// When Kind == IK_Identifier, the parsed identifier, or when\n    /// Kind == IK_UserLiteralId, the identifier suffix.\n    IdentifierInfo *Identifier;\n\n    /// When Kind == IK_OperatorFunctionId, the overloaded operator\n    /// that we parsed.\n    struct OFI OperatorFunctionId;\n\n    /// When Kind == IK_ConversionFunctionId, the type that the\n    /// conversion function names.\n    UnionParsedType ConversionFunctionId;\n\n    /// When Kind == IK_ConstructorName, the class-name of the type\n    /// whose constructor is being referenced.\n    UnionParsedType ConstructorName;\n\n    /// When Kind == IK_DestructorName, the type referred to by the\n    /// class-name.\n    UnionParsedType DestructorName;\n\n    /// When Kind == IK_DeductionGuideName, the parsed template-name.\n    UnionParsedTemplateTy TemplateName;\n\n    /// When Kind == IK_TemplateId or IK_ConstructorTemplateId,\n    /// the template-id annotation that contains the template name and\n    /// template arguments.\n    TemplateIdAnnotation *TemplateId;\n  };\n\n  /// The location of the first token that describes this unqualified-id,\n  /// which will be the location of the identifier, \"operator\" keyword,\n  /// tilde (for a destructor), or the template name of a template-id.\n  SourceLocation StartLocation;\n\n  /// The location of the last token that describes this unqualified-id.\n  SourceLocation EndLocation;\n\n  UnqualifiedId()\n      : Kind(UnqualifiedIdKind::IK_Identifier), Identifier(nullptr) {}\n\n  /// Clear out this unqualified-id, setting it to default (invalid)\n  /// state.\n  void clear() {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = nullptr;\n    StartLocation = SourceLocation();\n    EndLocation = SourceLocation();\n  }\n\n  /// Determine whether this unqualified-id refers to a valid name.\n  bool isValid() const { return StartLocation.isValid(); }\n\n  /// Determine whether this unqualified-id refers to an invalid name.\n  bool isInvalid() const { return !isValid(); }\n\n  /// Determine what kind of name we have.\n  UnqualifiedIdKind getKind() const { return Kind; }\n\n  /// Specify that this unqualified-id was parsed as an identifier.\n  ///\n  /// \\param Id the parsed identifier.\n  /// \\param IdLoc the location of the parsed identifier.\n  void setIdentifier(const IdentifierInfo *Id, SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as an\n  /// operator-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Op the overloaded operator.\n  ///\n  /// \\param SymbolLocations the locations of the individual operator symbols\n  /// in the operator.\n  void setOperatorFunctionId(SourceLocation OperatorLoc,\n                             OverloadedOperatorKind Op,\n                             SourceLocation SymbolLocations[3]);\n\n  /// Specify that this unqualified-id was parsed as a\n  /// conversion-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Ty the type to which this conversion function is converting.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConversionFunctionId(SourceLocation OperatorLoc,\n                               ParsedType Ty,\n                               SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConversionFunctionId;\n    StartLocation = OperatorLoc;\n    EndLocation = EndLoc;\n    ConversionFunctionId = Ty;\n  }\n\n  /// Specific that this unqualified-id was parsed as a\n  /// literal-operator-id.\n  ///\n  /// \\param Id the parsed identifier.\n  ///\n  /// \\param OpLoc the location of the 'operator' keyword.\n  ///\n  /// \\param IdLoc the location of the identifier.\n  void setLiteralOperatorId(const IdentifierInfo *Id, SourceLocation OpLoc,\n                              SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_LiteralOperatorId;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = OpLoc;\n    EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as a constructor name.\n  ///\n  /// \\param ClassType the class type referred to by the constructor name.\n  ///\n  /// \\param ClassNameLoc the location of the class name.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConstructorName(ParsedType ClassType,\n                          SourceLocation ClassNameLoc,\n                          SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConstructorName;\n    StartLocation = ClassNameLoc;\n    EndLocation = EndLoc;\n    ConstructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a\n  /// template-id that names a constructor.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setConstructorTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a destructor name.\n  ///\n  /// \\param TildeLoc the location of the '~' that introduces the destructor\n  /// name.\n  ///\n  /// \\param ClassType the name of the class referred to by the destructor name.\n  void setDestructorName(SourceLocation TildeLoc,\n                         ParsedType ClassType,\n                         SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_DestructorName;\n    StartLocation = TildeLoc;\n    EndLocation = EndLoc;\n    DestructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a template-id.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a template-name for\n  /// a deduction-guide.\n  ///\n  /// \\param Template The parsed template-name.\n  /// \\param TemplateLoc The location of the parsed template-name.\n  void setDeductionGuideName(ParsedTemplateTy Template,\n                             SourceLocation TemplateLoc) {\n    Kind = UnqualifiedIdKind::IK_DeductionGuideName;\n    TemplateName = Template;\n    StartLocation = EndLocation = TemplateLoc;\n  }\n\n  /// Specify that this unqualified-id is an implicit 'self'\n  /// parameter.\n  ///\n  /// \\param Id the identifier.\n  void setImplicitSelfParam(const IdentifierInfo *Id) {\n    Kind = UnqualifiedIdKind::IK_ImplicitSelfParam;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = SourceLocation();\n  }\n\n  /// Return the source range that covers this unqualified-id.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(StartLocation, EndLocation);\n  }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return StartLocation; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return EndLocation; }\n};\n\n/// A set of tokens that has been cached for later parsing.\ntypedef SmallVector<Token, 4> CachedTokens;\n\n/// One instance of this struct is used for each type in a\n/// declarator that is parsed.\n///\n/// This is intended to be a small value object.\nstruct DeclaratorChunk {\n  DeclaratorChunk() {};\n\n  enum {\n    Pointer, Reference, Array, Function, BlockPointer, MemberPointer, Paren, Pipe\n  } Kind;\n\n  /// Loc - The place where this type was defined.\n  SourceLocation Loc;\n  /// EndLoc - If valid, the place where this chunck ends.\n  SourceLocation EndLoc;\n\n  SourceRange getSourceRange() const {\n    if (EndLoc.isInvalid())\n      return SourceRange(Loc, Loc);\n    return SourceRange(Loc, EndLoc);\n  }\n\n  ParsedAttributesView AttrList;\n\n  struct PointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/unaligned/atomic.\n    unsigned TypeQuals : 5;\n\n    /// The location of the const-qualifier, if any.\n    SourceLocation ConstQualLoc;\n\n    /// The location of the volatile-qualifier, if any.\n    SourceLocation VolatileQualLoc;\n\n    /// The location of the restrict-qualifier, if any.\n    SourceLocation RestrictQualLoc;\n\n    /// The location of the _Atomic-qualifier, if any.\n    SourceLocation AtomicQualLoc;\n\n    /// The location of the __unaligned-qualifier, if any.\n    SourceLocation UnalignedQualLoc;\n\n    void destroy() {\n    }\n  };\n\n  struct ReferenceTypeInfo {\n    /// The type qualifier: restrict. [GNU] C++ extension\n    bool HasRestrict : 1;\n    /// True if this is an lvalue reference, false if it's an rvalue reference.\n    bool LValueRef : 1;\n    void destroy() {\n    }\n  };\n\n  struct ArrayTypeInfo {\n    /// The type qualifiers for the array:\n    /// const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    /// True if this dimension included the 'static' keyword.\n    unsigned hasStatic : 1;\n\n    /// True if this dimension was [*].  In this case, NumElts is null.\n    unsigned isStar : 1;\n\n    /// This is the size of the array, or null if [] or [*] was specified.\n    /// Since the parser is multi-purpose, and we don't want to impose a root\n    /// expression class on all clients, NumElts is untyped.\n    Expr *NumElts;\n\n    void destroy() {}\n  };\n\n  /// ParamInfo - An array of paraminfo objects is allocated whenever a function\n  /// declarator is parsed.  There are two interesting styles of parameters\n  /// here:\n  /// K&R-style identifier lists and parameter type lists.  K&R-style identifier\n  /// lists will have information about the identifier, but no type information.\n  /// Parameter type lists will have type info (if the actions module provides\n  /// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.\n  struct ParamInfo {\n    IdentifierInfo *Ident;\n    SourceLocation IdentLoc;\n    Decl *Param;\n\n    /// DefaultArgTokens - When the parameter's default argument\n    /// cannot be parsed immediately (because it occurs within the\n    /// declaration of a member function), it will be stored here as a\n    /// sequence of tokens to be parsed once the class definition is\n    /// complete. Non-NULL indicates that there is a default argument.\n    std::unique_ptr<CachedTokens> DefaultArgTokens;\n\n    ParamInfo() = default;\n    ParamInfo(IdentifierInfo *ident, SourceLocation iloc,\n              Decl *param,\n              std::unique_ptr<CachedTokens> DefArgTokens = nullptr)\n      : Ident(ident), IdentLoc(iloc), Param(param),\n        DefaultArgTokens(std::move(DefArgTokens)) {}\n  };\n\n  struct TypeAndRange {\n    ParsedType Ty;\n    SourceRange Range;\n  };\n\n  struct FunctionTypeInfo {\n    /// hasPrototype - This is true if the function had at least one typed\n    /// parameter.  If the function is () or (a,b,c), then it has no prototype,\n    /// and is treated as a K&R-style function.\n    unsigned hasPrototype : 1;\n\n    /// isVariadic - If this function has a prototype, and if that\n    /// proto ends with ',...)', this is true. When true, EllipsisLoc\n    /// contains the location of the ellipsis.\n    unsigned isVariadic : 1;\n\n    /// Can this declaration be a constructor-style initializer?\n    unsigned isAmbiguous : 1;\n\n    /// Whether the ref-qualifier (if any) is an lvalue reference.\n    /// Otherwise, it's an rvalue reference.\n    unsigned RefQualifierIsLValueRef : 1;\n\n    /// ExceptionSpecType - An ExceptionSpecificationType value.\n    unsigned ExceptionSpecType : 4;\n\n    /// DeleteParams - If this is true, we need to delete[] Params.\n    unsigned DeleteParams : 1;\n\n    /// HasTrailingReturnType - If this is true, a trailing return type was\n    /// specified.\n    unsigned HasTrailingReturnType : 1;\n\n    /// The location of the left parenthesis in the source.\n    SourceLocation LParenLoc;\n\n    /// When isVariadic is true, the location of the ellipsis in the source.\n    SourceLocation EllipsisLoc;\n\n    /// The location of the right parenthesis in the source.\n    SourceLocation RParenLoc;\n\n    /// NumParams - This is the number of formal parameters specified by the\n    /// declarator.\n    unsigned NumParams;\n\n    /// NumExceptionsOrDecls - This is the number of types in the\n    /// dynamic-exception-decl, if the function has one. In C, this is the\n    /// number of declarations in the function prototype.\n    unsigned NumExceptionsOrDecls;\n\n    /// The location of the ref-qualifier, if any.\n    ///\n    /// If this is an invalid location, there is no ref-qualifier.\n    SourceLocation RefQualifierLoc;\n\n    /// The location of the 'mutable' qualifer in a lambda-declarator, if\n    /// any.\n    SourceLocation MutableLoc;\n\n    /// The beginning location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocBeg;\n\n    /// The end location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocEnd;\n\n    /// Params - This is a pointer to a new[]'d array of ParamInfo objects that\n    /// describe the parameters specified by this function declarator.  null if\n    /// there are no parameters specified.\n    ParamInfo *Params;\n\n    /// DeclSpec for the function with the qualifier related info.\n    DeclSpec *MethodQualifiers;\n\n    /// AtttibuteFactory for the MethodQualifiers.\n    AttributeFactory *QualAttrFactory;\n\n    union {\n      /// Pointer to a new[]'d array of TypeAndRange objects that\n      /// contain the types in the function's dynamic exception specification\n      /// and their locations, if there is one.\n      TypeAndRange *Exceptions;\n\n      /// Pointer to the expression in the noexcept-specifier of this\n      /// function, if it has one.\n      Expr *NoexceptExpr;\n\n      /// Pointer to the cached tokens for an exception-specification\n      /// that has not yet been parsed.\n      CachedTokens *ExceptionSpecTokens;\n\n      /// Pointer to a new[]'d array of declarations that need to be available\n      /// for lookup inside the function body, if one exists. Does not exist in\n      /// C++.\n      NamedDecl **DeclsInPrototype;\n    };\n\n    /// If HasTrailingReturnType is true, this is the trailing return\n    /// type specified.\n    UnionParsedType TrailingReturnType;\n\n    /// If HasTrailingReturnType is true, this is the location of the trailing\n    /// return type.\n    SourceLocation TrailingReturnTypeLoc;\n\n    /// Reset the parameter list to having zero parameters.\n    ///\n    /// This is used in various places for error recovery.\n    void freeParams() {\n      for (unsigned I = 0; I < NumParams; ++I)\n        Params[I].DefaultArgTokens.reset();\n      if (DeleteParams) {\n        delete[] Params;\n        DeleteParams = false;\n      }\n      NumParams = 0;\n    }\n\n    void destroy() {\n      freeParams();\n      delete QualAttrFactory;\n      delete MethodQualifiers;\n      switch (getExceptionSpecType()) {\n      default:\n        break;\n      case EST_Dynamic:\n        delete[] Exceptions;\n        break;\n      case EST_Unparsed:\n        delete ExceptionSpecTokens;\n        break;\n      case EST_None:\n        if (NumExceptionsOrDecls != 0)\n          delete[] DeclsInPrototype;\n        break;\n      }\n    }\n\n    DeclSpec &getOrCreateMethodQualifiers() {\n      if (!MethodQualifiers) {\n        QualAttrFactory = new AttributeFactory();\n        MethodQualifiers = new DeclSpec(*QualAttrFactory);\n      }\n      return *MethodQualifiers;\n    }\n\n    /// isKNRPrototype - Return true if this is a K&R style identifier list,\n    /// like \"void foo(a,b,c)\".  In a function definition, this will be followed\n    /// by the parameter type definitions.\n    bool isKNRPrototype() const { return !hasPrototype && NumParams != 0; }\n\n    SourceLocation getLParenLoc() const { return LParenLoc; }\n\n    SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n    SourceLocation getRParenLoc() const { return RParenLoc; }\n\n    SourceLocation getExceptionSpecLocBeg() const {\n      return ExceptionSpecLocBeg;\n    }\n\n    SourceLocation getExceptionSpecLocEnd() const {\n      return ExceptionSpecLocEnd;\n    }\n\n    SourceRange getExceptionSpecRange() const {\n      return SourceRange(getExceptionSpecLocBeg(), getExceptionSpecLocEnd());\n    }\n\n    /// Retrieve the location of the ref-qualifier, if any.\n    SourceLocation getRefQualifierLoc() const { return RefQualifierLoc; }\n\n    /// Retrieve the location of the 'const' qualifier.\n    SourceLocation getConstQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getConstSpecLoc();\n    }\n\n    /// Retrieve the location of the 'volatile' qualifier.\n    SourceLocation getVolatileQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getVolatileSpecLoc();\n    }\n\n    /// Retrieve the location of the 'restrict' qualifier.\n    SourceLocation getRestrictQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getRestrictSpecLoc();\n    }\n\n    /// Retrieve the location of the 'mutable' qualifier, if any.\n    SourceLocation getMutableLoc() const { return MutableLoc; }\n\n    /// Determine whether this function declaration contains a\n    /// ref-qualifier.\n    bool hasRefQualifier() const { return getRefQualifierLoc().isValid(); }\n\n    /// Determine whether this lambda-declarator contains a 'mutable'\n    /// qualifier.\n    bool hasMutableQualifier() const { return getMutableLoc().isValid(); }\n\n    /// Determine whether this method has qualifiers.\n    bool hasMethodTypeQualifiers() const {\n      return MethodQualifiers && (MethodQualifiers->getTypeQualifiers() ||\n                                  MethodQualifiers->getAttributes().size());\n    }\n\n    /// Get the type of exception specification this function has.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      return static_cast<ExceptionSpecificationType>(ExceptionSpecType);\n    }\n\n    /// Get the number of dynamic exception specifications.\n    unsigned getNumExceptions() const {\n      assert(ExceptionSpecType != EST_None);\n      return NumExceptionsOrDecls;\n    }\n\n    /// Get the non-parameter decls defined within this function\n    /// prototype. Typically these are tag declarations.\n    ArrayRef<NamedDecl *> getDeclsInPrototype() const {\n      assert(ExceptionSpecType == EST_None);\n      return llvm::makeArrayRef(DeclsInPrototype, NumExceptionsOrDecls);\n    }\n\n    /// Determine whether this function declarator had a\n    /// trailing-return-type.\n    bool hasTrailingReturnType() const { return HasTrailingReturnType; }\n\n    /// Get the trailing-return-type for this function declarator.\n    ParsedType getTrailingReturnType() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnType;\n    }\n\n    /// Get the trailing-return-type location for this function declarator.\n    SourceLocation getTrailingReturnTypeLoc() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnTypeLoc;\n    }\n  };\n\n  struct BlockPointerTypeInfo {\n    /// For now, sema will catch these as invalid.\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    void destroy() {\n    }\n  };\n\n  struct MemberPointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n    /// Location of the '*' token.\n    SourceLocation StarLoc;\n    // CXXScopeSpec has a constructor, so it can't be a direct member.\n    // So we need some pointer-aligned storage and a bit of trickery.\n    alignas(CXXScopeSpec) char ScopeMem[sizeof(CXXScopeSpec)];\n    CXXScopeSpec &Scope() {\n      return *reinterpret_cast<CXXScopeSpec *>(ScopeMem);\n    }\n    const CXXScopeSpec &Scope() const {\n      return *reinterpret_cast<const CXXScopeSpec *>(ScopeMem);\n    }\n    void destroy() {\n      Scope().~CXXScopeSpec();\n    }\n  };\n\n  struct PipeTypeInfo {\n    /// The access writes.\n    unsigned AccessWrites : 3;\n\n    void destroy() {}\n  };\n\n  union {\n    PointerTypeInfo       Ptr;\n    ReferenceTypeInfo     Ref;\n    ArrayTypeInfo         Arr;\n    FunctionTypeInfo      Fun;\n    BlockPointerTypeInfo  Cls;\n    MemberPointerTypeInfo Mem;\n    PipeTypeInfo          PipeInfo;\n  };\n\n  void destroy() {\n    switch (Kind) {\n    case DeclaratorChunk::Function:      return Fun.destroy();\n    case DeclaratorChunk::Pointer:       return Ptr.destroy();\n    case DeclaratorChunk::BlockPointer:  return Cls.destroy();\n    case DeclaratorChunk::Reference:     return Ref.destroy();\n    case DeclaratorChunk::Array:         return Arr.destroy();\n    case DeclaratorChunk::MemberPointer: return Mem.destroy();\n    case DeclaratorChunk::Paren:         return;\n    case DeclaratorChunk::Pipe:          return PipeInfo.destroy();\n    }\n  }\n\n  /// If there are attributes applied to this declaratorchunk, return\n  /// them.\n  const ParsedAttributesView &getAttrs() const { return AttrList; }\n  ParsedAttributesView &getAttrs() { return AttrList; }\n\n  /// Return a DeclaratorChunk for a pointer.\n  static DeclaratorChunk getPointer(unsigned TypeQuals, SourceLocation Loc,\n                                    SourceLocation ConstQualLoc,\n                                    SourceLocation VolatileQualLoc,\n                                    SourceLocation RestrictQualLoc,\n                                    SourceLocation AtomicQualLoc,\n                                    SourceLocation UnalignedQualLoc) {\n    DeclaratorChunk I;\n    I.Kind                = Pointer;\n    I.Loc                 = Loc;\n    new (&I.Ptr) PointerTypeInfo;\n    I.Ptr.TypeQuals       = TypeQuals;\n    I.Ptr.ConstQualLoc    = ConstQualLoc;\n    I.Ptr.VolatileQualLoc = VolatileQualLoc;\n    I.Ptr.RestrictQualLoc = RestrictQualLoc;\n    I.Ptr.AtomicQualLoc   = AtomicQualLoc;\n    I.Ptr.UnalignedQualLoc = UnalignedQualLoc;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a reference.\n  static DeclaratorChunk getReference(unsigned TypeQuals, SourceLocation Loc,\n                                      bool lvalue) {\n    DeclaratorChunk I;\n    I.Kind            = Reference;\n    I.Loc             = Loc;\n    I.Ref.HasRestrict = (TypeQuals & DeclSpec::TQ_restrict) != 0;\n    I.Ref.LValueRef   = lvalue;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for an array.\n  static DeclaratorChunk getArray(unsigned TypeQuals,\n                                  bool isStatic, bool isStar, Expr *NumElts,\n                                  SourceLocation LBLoc, SourceLocation RBLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Array;\n    I.Loc           = LBLoc;\n    I.EndLoc        = RBLoc;\n    I.Arr.TypeQuals = TypeQuals;\n    I.Arr.hasStatic = isStatic;\n    I.Arr.isStar    = isStar;\n    I.Arr.NumElts   = NumElts;\n    return I;\n  }\n\n  /// DeclaratorChunk::getFunction - Return a DeclaratorChunk for a function.\n  /// \"TheDeclarator\" is the declarator that this will be added to.\n  static DeclaratorChunk getFunction(bool HasProto,\n                                     bool IsAmbiguous,\n                                     SourceLocation LParenLoc,\n                                     ParamInfo *Params, unsigned NumParams,\n                                     SourceLocation EllipsisLoc,\n                                     SourceLocation RParenLoc,\n                                     bool RefQualifierIsLvalueRef,\n                                     SourceLocation RefQualifierLoc,\n                                     SourceLocation MutableLoc,\n                                     ExceptionSpecificationType ESpecType,\n                                     SourceRange ESpecRange,\n                                     ParsedType *Exceptions,\n                                     SourceRange *ExceptionRanges,\n                                     unsigned NumExceptions,\n                                     Expr *NoexceptExpr,\n                                     CachedTokens *ExceptionSpecTokens,\n                                     ArrayRef<NamedDecl *> DeclsInPrototype,\n                                     SourceLocation LocalRangeBegin,\n                                     SourceLocation LocalRangeEnd,\n                                     Declarator &TheDeclarator,\n                                     TypeResult TrailingReturnType =\n                                                    TypeResult(),\n                                     SourceLocation TrailingReturnTypeLoc =\n                                                    SourceLocation(),\n                                     DeclSpec *MethodQualifiers = nullptr);\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getBlockPointer(unsigned TypeQuals,\n                                         SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = BlockPointer;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getPipe(unsigned TypeQuals,\n                                 SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = Pipe;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  static DeclaratorChunk getMemberPointer(const CXXScopeSpec &SS,\n                                          unsigned TypeQuals,\n                                          SourceLocation StarLoc,\n                                          SourceLocation EndLoc) {\n    DeclaratorChunk I;\n    I.Kind          = MemberPointer;\n    I.Loc           = SS.getBeginLoc();\n    I.EndLoc = EndLoc;\n    new (&I.Mem) MemberPointerTypeInfo;\n    I.Mem.StarLoc = StarLoc;\n    I.Mem.TypeQuals = TypeQuals;\n    new (I.Mem.ScopeMem) CXXScopeSpec(SS);\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a paren.\n  static DeclaratorChunk getParen(SourceLocation LParenLoc,\n                                  SourceLocation RParenLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Paren;\n    I.Loc           = LParenLoc;\n    I.EndLoc        = RParenLoc;\n    return I;\n  }\n\n  bool isParen() const {\n    return Kind == Paren;\n  }\n};\n\n/// A parsed C++17 decomposition declarator of the form\n///   '[' identifier-list ']'\nclass DecompositionDeclarator {\npublic:\n  struct Binding {\n    IdentifierInfo *Name;\n    SourceLocation NameLoc;\n  };\n\nprivate:\n  /// The locations of the '[' and ']' tokens.\n  SourceLocation LSquareLoc, RSquareLoc;\n\n  /// The bindings.\n  Binding *Bindings;\n  unsigned NumBindings : 31;\n  unsigned DeleteBindings : 1;\n\n  friend class Declarator;\n\npublic:\n  DecompositionDeclarator()\n      : Bindings(nullptr), NumBindings(0), DeleteBindings(false) {}\n  DecompositionDeclarator(const DecompositionDeclarator &G) = delete;\n  DecompositionDeclarator &operator=(const DecompositionDeclarator &G) = delete;\n  ~DecompositionDeclarator() {\n    if (DeleteBindings)\n      delete[] Bindings;\n  }\n\n  void clear() {\n    LSquareLoc = RSquareLoc = SourceLocation();\n    if (DeleteBindings)\n      delete[] Bindings;\n    Bindings = nullptr;\n    NumBindings = 0;\n    DeleteBindings = false;\n  }\n\n  ArrayRef<Binding> bindings() const {\n    return llvm::makeArrayRef(Bindings, NumBindings);\n  }\n\n  bool isSet() const { return LSquareLoc.isValid(); }\n\n  SourceLocation getLSquareLoc() const { return LSquareLoc; }\n  SourceLocation getRSquareLoc() const { return RSquareLoc; }\n  SourceRange getSourceRange() const {\n    return SourceRange(LSquareLoc, RSquareLoc);\n  }\n};\n\n/// Described the kind of function definition (if any) provided for\n/// a function.\nenum class FunctionDefinitionKind {\n  Declaration,\n  Definition,\n  Defaulted,\n  Deleted\n};\n\nenum class DeclaratorContext {\n  File,                // File scope declaration.\n  Prototype,           // Within a function prototype.\n  ObjCResult,          // An ObjC method result type.\n  ObjCParameter,       // An ObjC method parameter type.\n  KNRTypeList,         // K&R type definition list for formals.\n  TypeName,            // Abstract declarator for types.\n  FunctionalCast,      // Type in a C++ functional cast expression.\n  Member,              // Struct/Union field.\n  Block,               // Declaration within a block in a function.\n  ForInit,             // Declaration within first part of a for loop.\n  SelectionInit,       // Declaration within optional init stmt of if/switch.\n  Condition,           // Condition declaration in a C++ if/switch/while/for.\n  TemplateParam,       // Within a template parameter list.\n  CXXNew,              // C++ new-expression.\n  CXXCatch,            // C++ catch exception-declaration\n  ObjCCatch,           // Objective-C catch exception-declaration\n  BlockLiteral,        // Block literal declarator.\n  LambdaExpr,          // Lambda-expression declarator.\n  LambdaExprParameter, // Lambda-expression parameter declarator.\n  ConversionId,        // C++ conversion-type-id.\n  TrailingReturn,      // C++11 trailing-type-specifier.\n  TrailingReturnVar,   // C++11 trailing-type-specifier for variable.\n  TemplateArg,         // Any template argument (in template argument list).\n  TemplateTypeArg,     // Template type argument (in default argument).\n  AliasDecl,           // C++11 alias-declaration.\n  AliasTemplate,       // C++11 alias-declaration template.\n  RequiresExpr         // C++2a requires-expression.\n};\n\n/// Information about one declarator, including the parsed type\n/// information and the identifier.\n///\n/// When the declarator is fully formed, this is turned into the appropriate\n/// Decl object.\n///\n/// Declarators come in two types: normal declarators and abstract declarators.\n/// Abstract declarators are used when parsing types, and don't have an\n/// identifier.  Normal declarators do have ID's.\n///\n/// Instances of this class should be a transient object that lives on the\n/// stack, not objects that are allocated in large quantities on the heap.\nclass Declarator {\n\nprivate:\n  const DeclSpec &DS;\n  CXXScopeSpec SS;\n  UnqualifiedId Name;\n  SourceRange Range;\n\n  /// Where we are parsing this declarator.\n  DeclaratorContext Context;\n\n  /// The C++17 structured binding, if any. This is an alternative to a Name.\n  DecompositionDeclarator BindingGroup;\n\n  /// DeclTypeInfo - This holds each type that the declarator includes as it is\n  /// parsed.  This is pushed from the identifier out, which means that element\n  /// #0 will be the most closely bound to the identifier, and\n  /// DeclTypeInfo.back() will be the least closely bound.\n  SmallVector<DeclaratorChunk, 8> DeclTypeInfo;\n\n  /// InvalidType - Set by Sema::GetTypeForDeclarator().\n  unsigned InvalidType : 1;\n\n  /// GroupingParens - Set by Parser::ParseParenDeclarator().\n  unsigned GroupingParens : 1;\n\n  /// FunctionDefinition - Is this Declarator for a function or member\n  /// definition and, if so, what kind?\n  ///\n  /// Actually a FunctionDefinitionKind.\n  unsigned FunctionDefinition : 2;\n\n  /// Is this Declarator a redeclaration?\n  unsigned Redeclaration : 1;\n\n  /// true if the declaration is preceded by \\c __extension__.\n  unsigned Extension : 1;\n\n  /// Indicates whether this is an Objective-C instance variable.\n  unsigned ObjCIvar : 1;\n\n  /// Indicates whether this is an Objective-C 'weak' property.\n  unsigned ObjCWeakProperty : 1;\n\n  /// Indicates whether the InlineParams / InlineBindings storage has been used.\n  unsigned InlineStorageUsed : 1;\n\n  /// Indicates whether this declarator has an initializer.\n  unsigned HasInitializer : 1;\n\n  /// Attrs - Attributes.\n  ParsedAttributes Attrs;\n\n  /// The asm label, if specified.\n  Expr *AsmLabel;\n\n  /// \\brief The constraint-expression specified by the trailing\n  /// requires-clause, or null if no such clause was specified.\n  Expr *TrailingRequiresClause;\n\n  /// If this declarator declares a template, its template parameter lists.\n  ArrayRef<TemplateParameterList *> TemplateParameterLists;\n\n  /// If the declarator declares an abbreviated function template, the innermost\n  /// template parameter list containing the invented and explicit template\n  /// parameters (if any).\n  TemplateParameterList *InventedTemplateParameterList;\n\n#ifndef _MSC_VER\n  union {\n#endif\n    /// InlineParams - This is a local array used for the first function decl\n    /// chunk to avoid going to the heap for the common case when we have one\n    /// function chunk in the declarator.\n    DeclaratorChunk::ParamInfo InlineParams[16];\n    DecompositionDeclarator::Binding InlineBindings[16];\n#ifndef _MSC_VER\n  };\n#endif\n\n  /// If this is the second or subsequent declarator in this declaration,\n  /// the location of the comma before this declarator.\n  SourceLocation CommaLoc;\n\n  /// If provided, the source location of the ellipsis used to describe\n  /// this declarator as a parameter pack.\n  SourceLocation EllipsisLoc;\n\n  friend struct DeclaratorChunk;\n\npublic:\n  Declarator(const DeclSpec &ds, DeclaratorContext C)\n      : DS(ds), Range(ds.getSourceRange()), Context(C),\n        InvalidType(DS.getTypeSpecType() == DeclSpec::TST_error),\n        GroupingParens(false), FunctionDefinition(static_cast<unsigned>(\n                                   FunctionDefinitionKind::Declaration)),\n        Redeclaration(false), Extension(false), ObjCIvar(false),\n        ObjCWeakProperty(false), InlineStorageUsed(false),\n        HasInitializer(false), Attrs(ds.getAttributePool().getFactory()),\n        AsmLabel(nullptr), TrailingRequiresClause(nullptr),\n        InventedTemplateParameterList(nullptr) {}\n\n  ~Declarator() {\n    clear();\n  }\n  /// getDeclSpec - Return the declaration-specifier that this declarator was\n  /// declared with.\n  const DeclSpec &getDeclSpec() const { return DS; }\n\n  /// getMutableDeclSpec - Return a non-const version of the DeclSpec.  This\n  /// should be used with extreme care: declspecs can often be shared between\n  /// multiple declarators, so mutating the DeclSpec affects all of the\n  /// Declarators.  This should only be done when the declspec is known to not\n  /// be shared or when in error recovery etc.\n  DeclSpec &getMutableDeclSpec() { return const_cast<DeclSpec &>(DS); }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// getCXXScopeSpec - Return the C++ scope specifier (global scope or\n  /// nested-name-specifier) that is part of the declarator-id.\n  const CXXScopeSpec &getCXXScopeSpec() const { return SS; }\n  CXXScopeSpec &getCXXScopeSpec() { return SS; }\n\n  /// Retrieve the name specified by this declarator.\n  UnqualifiedId &getName() { return Name; }\n\n  const DecompositionDeclarator &getDecompositionDeclarator() const {\n    return BindingGroup;\n  }\n\n  DeclaratorContext getContext() const { return Context; }\n\n  bool isPrototypeContext() const {\n    return (Context == DeclaratorContext::Prototype ||\n            Context == DeclaratorContext::ObjCParameter ||\n            Context == DeclaratorContext::ObjCResult ||\n            Context == DeclaratorContext::LambdaExprParameter);\n  }\n\n  /// Get the source range that spans this declarator.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  void SetSourceRange(SourceRange R) { Range = R; }\n  /// SetRangeBegin - Set the start of the source range to Loc, unless it's\n  /// invalid.\n  void SetRangeBegin(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setBegin(Loc);\n  }\n  /// SetRangeEnd - Set the end of the source range to Loc, unless it's invalid.\n  void SetRangeEnd(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setEnd(Loc);\n  }\n  /// ExtendWithDeclSpec - Extend the declarator source range to include the\n  /// given declspec, unless its location is invalid. Adopts the range start if\n  /// the current range start is invalid.\n  void ExtendWithDeclSpec(const DeclSpec &DS) {\n    SourceRange SR = DS.getSourceRange();\n    if (Range.getBegin().isInvalid())\n      Range.setBegin(SR.getBegin());\n    if (!SR.getEnd().isInvalid())\n      Range.setEnd(SR.getEnd());\n  }\n\n  /// Reset the contents of this Declarator.\n  void clear() {\n    SS.clear();\n    Name.clear();\n    Range = DS.getSourceRange();\n    BindingGroup.clear();\n\n    for (unsigned i = 0, e = DeclTypeInfo.size(); i != e; ++i)\n      DeclTypeInfo[i].destroy();\n    DeclTypeInfo.clear();\n    Attrs.clear();\n    AsmLabel = nullptr;\n    InlineStorageUsed = false;\n    HasInitializer = false;\n    ObjCIvar = false;\n    ObjCWeakProperty = false;\n    CommaLoc = SourceLocation();\n    EllipsisLoc = SourceLocation();\n  }\n\n  /// mayOmitIdentifier - Return true if the identifier is either optional or\n  /// not allowed.  This is true for typenames, prototypes, and template\n  /// parameter lists.\n  bool mayOmitIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return false;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n      return true;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayHaveIdentifier - Return true if the identifier is either optional or\n  /// required.  This is true for normal declarators and prototypes, but not\n  /// typenames.\n  bool mayHaveIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::RequiresExpr:\n      return true;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if the context permits a C++17 decomposition declarator.\n  bool mayHaveDecompositionDeclarator() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n      // FIXME: It's not clear that the proposal meant to allow file-scope\n      // structured bindings, but it does.\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return true;\n\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::RequiresExpr:\n      // Maybe one day...\n      return false;\n\n    // These contexts don't allow any kind of non-abstract declarator.\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayBeFollowedByCXXDirectInit - Return true if the declarator can be\n  /// followed by a C++ direct initializer, e.g. \"int x(1);\".\n  bool mayBeFollowedByCXXDirectInit() const {\n    if (hasGroupingParens()) return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_extern &&\n        Context != DeclaratorContext::File)\n      return false;\n\n    // Special names can't have direct initializers.\n    if (Name.getKind() != UnqualifiedIdKind::IK_Identifier)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::TrailingReturnVar:\n      return true;\n\n    case DeclaratorContext::Condition:\n      // This may not be followed by a direct initializer, but it can't be a\n      // function declaration either, and we'd prefer to perform a tentative\n      // parse in order to produce the right diagnostic.\n      return true;\n\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast: // FIXME\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// isPastIdentifier - Return true if we have parsed beyond the point where\n  /// the name would appear. (This may happen even if we haven't actually parsed\n  /// a name, perhaps because this context doesn't require one.)\n  bool isPastIdentifier() const { return Name.isValid(); }\n\n  /// hasName - Whether this declarator has a name, which might be an\n  /// identifier (accessible via getIdentifier()) or some kind of\n  /// special C++ name (constructor, destructor, etc.), or a structured\n  /// binding (which is not exactly a name, but occupies the same position).\n  bool hasName() const {\n    return Name.getKind() != UnqualifiedIdKind::IK_Identifier ||\n           Name.Identifier || isDecompositionDeclarator();\n  }\n\n  /// Return whether this declarator is a decomposition declarator.\n  bool isDecompositionDeclarator() const {\n    return BindingGroup.isSet();\n  }\n\n  IdentifierInfo *getIdentifier() const {\n    if (Name.getKind() == UnqualifiedIdKind::IK_Identifier)\n      return Name.Identifier;\n\n    return nullptr;\n  }\n  SourceLocation getIdentifierLoc() const { return Name.StartLocation; }\n\n  /// Set the name of this declarator to be the given identifier.\n  void SetIdentifier(IdentifierInfo *Id, SourceLocation IdLoc) {\n    Name.setIdentifier(Id, IdLoc);\n  }\n\n  /// Set the decomposition bindings for this declarator.\n  void\n  setDecompositionBindings(SourceLocation LSquareLoc,\n                           ArrayRef<DecompositionDeclarator::Binding> Bindings,\n                           SourceLocation RSquareLoc);\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  /// This function takes attrs by R-Value reference because it takes ownership\n  /// of those attributes from the parameter.\n  void AddTypeInfo(const DeclaratorChunk &TI, ParsedAttributes &&attrs,\n                   SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n    DeclTypeInfo.back().getAttrs().addAll(attrs.begin(), attrs.end());\n    getAttributePool().takeAllFrom(attrs.getPool());\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  void AddTypeInfo(const DeclaratorChunk &TI, SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// Add a new innermost chunk to this declarator.\n  void AddInnermostTypeInfo(const DeclaratorChunk &TI) {\n    DeclTypeInfo.insert(DeclTypeInfo.begin(), TI);\n  }\n\n  /// Return the number of types applied to this declarator.\n  unsigned getNumTypeObjects() const { return DeclTypeInfo.size(); }\n\n  /// Return the specified TypeInfo from this declarator.  TypeInfo #0 is\n  /// closest to the identifier.\n  const DeclaratorChunk &getTypeObject(unsigned i) const {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n  DeclaratorChunk &getTypeObject(unsigned i) {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n\n  typedef SmallVectorImpl<DeclaratorChunk>::const_iterator type_object_iterator;\n  typedef llvm::iterator_range<type_object_iterator> type_object_range;\n\n  /// Returns the range of type objects, from the identifier outwards.\n  type_object_range type_objects() const {\n    return type_object_range(DeclTypeInfo.begin(), DeclTypeInfo.end());\n  }\n\n  void DropFirstTypeObject() {\n    assert(!DeclTypeInfo.empty() && \"No type chunks to drop.\");\n    DeclTypeInfo.front().destroy();\n    DeclTypeInfo.erase(DeclTypeInfo.begin());\n  }\n\n  /// Return the innermost (closest to the declarator) chunk of this\n  /// declarator that is not a parens chunk, or null if there are no\n  /// non-parens chunks.\n  const DeclaratorChunk *getInnermostNonParenChunk() const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      if (!DeclTypeInfo[i].isParen())\n        return &DeclTypeInfo[i];\n    }\n    return nullptr;\n  }\n\n  /// Return the outermost (furthest from the declarator) chunk of\n  /// this declarator that is not a parens chunk, or null if there are\n  /// no non-parens chunks.\n  const DeclaratorChunk *getOutermostNonParenChunk() const {\n    for (unsigned i = DeclTypeInfo.size(), i_end = 0; i != i_end; --i) {\n      if (!DeclTypeInfo[i-1].isParen())\n        return &DeclTypeInfo[i-1];\n    }\n    return nullptr;\n  }\n\n  /// isArrayOfUnknownBound - This method returns true if the declarator\n  /// is a declarator for an array of unknown bound (looking through\n  /// parentheses).\n  bool isArrayOfUnknownBound() const {\n    const DeclaratorChunk *chunk = getInnermostNonParenChunk();\n    return (chunk && chunk->Kind == DeclaratorChunk::Array &&\n            !chunk->Arr.NumElts);\n  }\n\n  /// isFunctionDeclarator - This method returns true if the declarator\n  /// is a function declarator (looking through parentheses).\n  /// If true is returned, then the reference type parameter idx is\n  /// assigned with the index of the declaration chunk.\n  bool isFunctionDeclarator(unsigned& idx) const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      switch (DeclTypeInfo[i].Kind) {\n      case DeclaratorChunk::Function:\n        idx = i;\n        return true;\n      case DeclaratorChunk::Paren:\n        continue;\n      case DeclaratorChunk::Pointer:\n      case DeclaratorChunk::Reference:\n      case DeclaratorChunk::Array:\n      case DeclaratorChunk::BlockPointer:\n      case DeclaratorChunk::MemberPointer:\n      case DeclaratorChunk::Pipe:\n        return false;\n      }\n      llvm_unreachable(\"Invalid type chunk\");\n    }\n    return false;\n  }\n\n  /// isFunctionDeclarator - Once this declarator is fully parsed and formed,\n  /// this method returns true if the identifier is a function declarator\n  /// (looking through parentheses).\n  bool isFunctionDeclarator() const {\n    unsigned index;\n    return isFunctionDeclarator(index);\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() {\n    assert(isFunctionDeclarator() && \"Not a function declarator!\");\n    unsigned index = 0;\n    isFunctionDeclarator(index);\n    return DeclTypeInfo[index].Fun;\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  const DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() const {\n    return const_cast<Declarator*>(this)->getFunctionTypeInfo();\n  }\n\n  /// Determine whether the declaration that will be produced from\n  /// this declaration will be a function.\n  ///\n  /// A declaration can declare a function even if the declarator itself\n  /// isn't a function declarator, if the type specifier refers to a function\n  /// type. This routine checks for both cases.\n  bool isDeclarationOfFunction() const;\n\n  /// Return true if this declaration appears in a context where a\n  /// function declarator would be a function declaration.\n  bool isFunctionDeclarationContext() const {\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n      return true;\n\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Determine whether this declaration appears in a context where an\n  /// expression could appear.\n  bool isExpressionContext() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n\n    // FIXME: sizeof(...) permits an expression.\n    case DeclaratorContext::TypeName:\n\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::TemplateArg:\n      return true;\n    }\n\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if a function declarator at this position would be a\n  /// function declaration.\n  bool isFunctionDeclaratorAFunctionDeclaration() const {\n    if (!isFunctionDeclarationContext())\n      return false;\n\n    for (unsigned I = 0, N = getNumTypeObjects(); I != N; ++I)\n      if (getTypeObject(I).Kind != DeclaratorChunk::Paren)\n        return false;\n\n    return true;\n  }\n\n  /// Determine whether a trailing return type was written (at any\n  /// level) within this declarator.\n  bool hasTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return true;\n    return false;\n  }\n  /// Get the trailing return type appearing (at any level) within this\n  /// declarator.\n  ParsedType getTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return Chunk.Fun.getTrailingReturnType();\n    return ParsedType();\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  void setTrailingRequiresClause(Expr *TRC) {\n    TrailingRequiresClause = TRC;\n\n    SetRangeEnd(TRC->getEndLoc());\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  Expr *getTrailingRequiresClause() {\n    return TrailingRequiresClause;\n  }\n\n  /// \\brief Determine whether a trailing requires clause was written in this\n  /// declarator.\n  bool hasTrailingRequiresClause() const {\n    return TrailingRequiresClause != nullptr;\n  }\n\n  /// Sets the template parameter lists that preceded the declarator.\n  void setTemplateParameterLists(ArrayRef<TemplateParameterList *> TPLs) {\n    TemplateParameterLists = TPLs;\n  }\n\n  /// The template parameter lists that preceded the declarator.\n  ArrayRef<TemplateParameterList *> getTemplateParameterLists() const {\n    return TemplateParameterLists;\n  }\n\n  /// Sets the template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters.\n  void setInventedTemplateParameterList(TemplateParameterList *Invented) {\n    InventedTemplateParameterList = Invented;\n  }\n\n  /// The template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters, if there were any such parameters.\n  TemplateParameterList * getInventedTemplateParameterList() const {\n    return InventedTemplateParameterList;\n  }\n\n  /// takeAttributes - Takes attributes from the given parsed-attributes\n  /// set and add them to this declarator.\n  ///\n  /// These examples both add 3 attributes to \"var\":\n  ///  short int var __attribute__((aligned(16),common,deprecated));\n  ///  short int x, __attribute__((aligned(16)) var\n  ///                                 __attribute__((common,deprecated));\n  ///\n  /// Also extends the range of the declarator.\n  void takeAttributes(ParsedAttributes &attrs, SourceLocation lastLoc) {\n    Attrs.takeAllFrom(attrs);\n\n    if (!lastLoc.isInvalid())\n      SetRangeEnd(lastLoc);\n  }\n\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n  ParsedAttributes &getAttributes() { return Attrs; }\n\n  /// hasAttributes - do we contain any attributes?\n  bool hasAttributes() const {\n    if (!getAttributes().empty() || getDeclSpec().hasAttributes())\n      return true;\n    for (unsigned i = 0, e = getNumTypeObjects(); i != e; ++i)\n      if (!getTypeObject(i).getAttrs().empty())\n        return true;\n    return false;\n  }\n\n  /// Return a source range list of C++11 attributes associated\n  /// with the declarator.\n  void getCXX11AttributeRanges(SmallVectorImpl<SourceRange> &Ranges) {\n    for (const ParsedAttr &AL : Attrs)\n      if (AL.isCXX11Attribute())\n        Ranges.push_back(AL.getRange());\n  }\n\n  void setAsmLabel(Expr *E) { AsmLabel = E; }\n  Expr *getAsmLabel() const { return AsmLabel; }\n\n  void setExtension(bool Val = true) { Extension = Val; }\n  bool getExtension() const { return Extension; }\n\n  void setObjCIvar(bool Val = true) { ObjCIvar = Val; }\n  bool isObjCIvar() const { return ObjCIvar; }\n\n  void setObjCWeakProperty(bool Val = true) { ObjCWeakProperty = Val; }\n  bool isObjCWeakProperty() const { return ObjCWeakProperty; }\n\n  void setInvalidType(bool Val = true) { InvalidType = Val; }\n  bool isInvalidType() const {\n    return InvalidType || DS.getTypeSpecType() == DeclSpec::TST_error;\n  }\n\n  void setGroupingParens(bool flag) { GroupingParens = flag; }\n  bool hasGroupingParens() const { return GroupingParens; }\n\n  bool isFirstDeclarator() const { return !CommaLoc.isValid(); }\n  SourceLocation getCommaLoc() const { return CommaLoc; }\n  void setCommaLoc(SourceLocation CL) { CommaLoc = CL; }\n\n  bool hasEllipsis() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  void setEllipsisLoc(SourceLocation EL) { EllipsisLoc = EL; }\n\n  void setFunctionDefinitionKind(FunctionDefinitionKind Val) {\n    FunctionDefinition = static_cast<unsigned>(Val);\n  }\n\n  bool isFunctionDefinition() const {\n    return getFunctionDefinitionKind() != FunctionDefinitionKind::Declaration;\n  }\n\n  FunctionDefinitionKind getFunctionDefinitionKind() const {\n    return (FunctionDefinitionKind)FunctionDefinition;\n  }\n\n  void setHasInitializer(bool Val = true) { HasInitializer = Val; }\n  bool hasInitializer() const { return HasInitializer; }\n\n  /// Returns true if this declares a real member and not a friend.\n  bool isFirstDeclarationOfMember() {\n    return getContext() == DeclaratorContext::Member &&\n           !getDeclSpec().isFriendSpecified();\n  }\n\n  /// Returns true if this declares a static member.  This cannot be called on a\n  /// declarator outside of a MemberContext because we won't know until\n  /// redeclaration time if the decl is static.\n  bool isStaticMember();\n\n  /// Returns true if this declares a constructor or a destructor.\n  bool isCtorOrDtor();\n\n  void setRedeclaration(bool Val) { Redeclaration = Val; }\n  bool isRedeclaration() const { return Redeclaration; }\n};\n\n/// This little struct is used to capture information about\n/// structure field declarators, which is basically just a bitfield size.\nstruct FieldDeclarator {\n  Declarator D;\n  Expr *BitfieldSize;\n  explicit FieldDeclarator(const DeclSpec &DS)\n      : D(DS, DeclaratorContext::Member), BitfieldSize(nullptr) {}\n};\n\n/// Represents a C++11 virt-specifier-seq.\nclass VirtSpecifiers {\npublic:\n  enum Specifier {\n    VS_None = 0,\n    VS_Override = 1,\n    VS_Final = 2,\n    VS_Sealed = 4,\n    // Represents the __final keyword, which is legal for gcc in pre-C++11 mode.\n    VS_GNU_Final = 8\n  };\n\n  VirtSpecifiers() : Specifiers(0), LastSpecifier(VS_None) { }\n\n  bool SetSpecifier(Specifier VS, SourceLocation Loc,\n                    const char *&PrevSpec);\n\n  bool isUnset() const { return Specifiers == 0; }\n\n  bool isOverrideSpecified() const { return Specifiers & VS_Override; }\n  SourceLocation getOverrideLoc() const { return VS_overrideLoc; }\n\n  bool isFinalSpecified() const { return Specifiers & (VS_Final | VS_Sealed | VS_GNU_Final); }\n  bool isFinalSpelledSealed() const { return Specifiers & VS_Sealed; }\n  SourceLocation getFinalLoc() const { return VS_finalLoc; }\n\n  void clear() { Specifiers = 0; }\n\n  static const char *getSpecifierName(Specifier VS);\n\n  SourceLocation getFirstLocation() const { return FirstLocation; }\n  SourceLocation getLastLocation() const { return LastLocation; }\n  Specifier getLastSpecifier() const { return LastSpecifier; }\n\nprivate:\n  unsigned Specifiers;\n  Specifier LastSpecifier;\n\n  SourceLocation VS_overrideLoc, VS_finalLoc;\n  SourceLocation FirstLocation;\n  SourceLocation LastLocation;\n};\n\nenum class LambdaCaptureInitKind {\n  NoInit,     //!< [a]\n  CopyInit,   //!< [a = b], [a = {b}]\n  DirectInit, //!< [a(b)]\n  ListInit    //!< [a{b}]\n};\n\n/// Represents a complete lambda introducer.\nstruct LambdaIntroducer {\n  /// An individual capture in a lambda introducer.\n  struct LambdaCapture {\n    LambdaCaptureKind Kind;\n    SourceLocation Loc;\n    IdentifierInfo *Id;\n    SourceLocation EllipsisLoc;\n    LambdaCaptureInitKind InitKind;\n    ExprResult Init;\n    ParsedType InitCaptureType;\n    SourceRange ExplicitRange;\n\n    LambdaCapture(LambdaCaptureKind Kind, SourceLocation Loc,\n                  IdentifierInfo *Id, SourceLocation EllipsisLoc,\n                  LambdaCaptureInitKind InitKind, ExprResult Init,\n                  ParsedType InitCaptureType,\n                  SourceRange ExplicitRange)\n        : Kind(Kind), Loc(Loc), Id(Id), EllipsisLoc(EllipsisLoc),\n          InitKind(InitKind), Init(Init), InitCaptureType(InitCaptureType),\n          ExplicitRange(ExplicitRange) {}\n  };\n\n  SourceRange Range;\n  SourceLocation DefaultLoc;\n  LambdaCaptureDefault Default;\n  SmallVector<LambdaCapture, 4> Captures;\n\n  LambdaIntroducer()\n    : Default(LCD_None) {}\n\n  /// Append a capture in a lambda introducer.\n  void addCapture(LambdaCaptureKind Kind,\n                  SourceLocation Loc,\n                  IdentifierInfo* Id,\n                  SourceLocation EllipsisLoc,\n                  LambdaCaptureInitKind InitKind,\n                  ExprResult Init,\n                  ParsedType InitCaptureType,\n                  SourceRange ExplicitRange) {\n    Captures.push_back(LambdaCapture(Kind, Loc, Id, EllipsisLoc, InitKind, Init,\n                                     InitCaptureType, ExplicitRange));\n  }\n};\n\nstruct InventedTemplateParameterInfo {\n  /// The number of parameters in the template parameter list that were\n  /// explicitly specified by the user, as opposed to being invented by use\n  /// of an auto parameter.\n  unsigned NumExplicitTemplateParams = 0;\n\n  /// If this is a generic lambda or abbreviated function template, use this\n  /// as the depth of each 'auto' parameter, during initial AST construction.\n  unsigned AutoTemplateParameterDepth = 0;\n\n  /// Store the list of the template parameters for a generic lambda or an\n  /// abbreviated function template.\n  /// If this is a generic lambda or abbreviated function template, this holds\n  /// the explicit template parameters followed by the auto parameters\n  /// converted into TemplateTypeParmDecls.\n  /// It can be used to construct the generic lambda or abbreviated template's\n  /// template parameter list during initial AST construction.\n  SmallVector<NamedDecl*, 4> TemplateParams;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_SEMA_DECLSPEC_H\n"}, "72": {"id": 72, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Ownership.h", "content": "//===- Ownership.h - Parser ownership helpers -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file contains classes for managing ownership of Stmt and Expr nodes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_OWNERSHIP_H\n#define LLVM_CLANG_SEMA_OWNERSHIP_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\n//===----------------------------------------------------------------------===//\n// OpaquePtr\n//===----------------------------------------------------------------------===//\n\nnamespace clang {\n\nclass CXXBaseSpecifier;\nclass CXXCtorInitializer;\nclass Decl;\nclass Expr;\nclass ParsedTemplateArgument;\nclass QualType;\nclass Stmt;\nclass TemplateName;\nclass TemplateParameterList;\n\n  /// Wrapper for void* pointer.\n  /// \\tparam PtrTy Either a pointer type like 'T*' or a type that behaves like\n  ///               a pointer.\n  ///\n  /// This is a very simple POD type that wraps a pointer that the Parser\n  /// doesn't know about but that Sema or another client does.  The PtrTy\n  /// template argument is used to make sure that \"Decl\" pointers are not\n  /// compatible with \"Type\" pointers for example.\n  template <class PtrTy>\n  class OpaquePtr {\n    void *Ptr = nullptr;\n\n    explicit OpaquePtr(void *Ptr) : Ptr(Ptr) {}\n\n    using Traits = llvm::PointerLikeTypeTraits<PtrTy>;\n\n  public:\n    OpaquePtr(std::nullptr_t = nullptr) {}\n\n    static OpaquePtr make(PtrTy P) { OpaquePtr OP; OP.set(P); return OP; }\n\n    /// Returns plain pointer to the entity pointed by this wrapper.\n    /// \\tparam PointeeT Type of pointed entity.\n    ///\n    /// It is identical to getPtrAs<PointeeT*>.\n    template <typename PointeeT> PointeeT* getPtrTo() const {\n      return get();\n    }\n\n    /// Returns pointer converted to the specified type.\n    /// \\tparam PtrT Result pointer type.  There must be implicit conversion\n    ///              from PtrTy to PtrT.\n    ///\n    /// In contrast to getPtrTo, this method allows the return type to be\n    /// a smart pointer.\n    template <typename PtrT> PtrT getPtrAs() const {\n      return get();\n    }\n\n    PtrTy get() const {\n      return Traits::getFromVoidPointer(Ptr);\n    }\n\n    void set(PtrTy P) {\n      Ptr = Traits::getAsVoidPointer(P);\n    }\n\n    explicit operator bool() const { return Ptr != nullptr; }\n\n    void *getAsOpaquePtr() const { return Ptr; }\n    static OpaquePtr getFromOpaquePtr(void *P) { return OpaquePtr(P); }\n  };\n\n  /// UnionOpaquePtr - A version of OpaquePtr suitable for membership\n  /// in a union.\n  template <class T> struct UnionOpaquePtr {\n    void *Ptr;\n\n    static UnionOpaquePtr make(OpaquePtr<T> P) {\n      UnionOpaquePtr OP = { P.getAsOpaquePtr() };\n      return OP;\n    }\n\n    OpaquePtr<T> get() const { return OpaquePtr<T>::getFromOpaquePtr(Ptr); }\n    operator OpaquePtr<T>() const { return get(); }\n\n    UnionOpaquePtr &operator=(OpaquePtr<T> P) {\n      Ptr = P.getAsOpaquePtr();\n      return *this;\n    }\n  };\n\n} // namespace clang\n\nnamespace llvm {\n\n  template <class T>\n  struct PointerLikeTypeTraits<clang::OpaquePtr<T>> {\n    static constexpr int NumLowBitsAvailable = 0;\n\n    static inline void *getAsVoidPointer(clang::OpaquePtr<T> P) {\n      // FIXME: Doesn't work? return P.getAs< void >();\n      return P.getAsOpaquePtr();\n    }\n\n    static inline clang::OpaquePtr<T> getFromVoidPointer(void *P) {\n      return clang::OpaquePtr<T>::getFromOpaquePtr(P);\n    }\n  };\n\n} // namespace llvm\n\nnamespace clang {\n\n  // Basic\nclass StreamingDiagnostic;\n\n// Determines whether the low bit of the result pointer for the\n// given UID is always zero. If so, ActionResult will use that bit\n// for it's \"invalid\" flag.\ntemplate <class Ptr> struct IsResultPtrLowBitFree {\n  static const bool value = false;\n  };\n\n  /// ActionResult - This structure is used while parsing/acting on\n  /// expressions, stmts, etc.  It encapsulates both the object returned by\n  /// the action, plus a sense of whether or not it is valid.\n  /// When CompressInvalid is true, the \"invalid\" flag will be\n  /// stored in the low bit of the Val pointer.\n  template<class PtrTy,\n           bool CompressInvalid = IsResultPtrLowBitFree<PtrTy>::value>\n  class ActionResult {\n    PtrTy Val;\n    bool Invalid;\n\n  public:\n    ActionResult(bool Invalid = false) : Val(PtrTy()), Invalid(Invalid) {}\n    ActionResult(PtrTy val) : Val(val), Invalid(false) {}\n    ActionResult(const DiagnosticBuilder &) : Val(PtrTy()), Invalid(true) {}\n\n    // These two overloads prevent void* -> bool conversions.\n    ActionResult(const void *) = delete;\n    ActionResult(volatile void *) = delete;\n\n    bool isInvalid() const { return Invalid; }\n    bool isUsable() const { return !Invalid && Val; }\n    bool isUnset() const { return !Invalid && !Val; }\n\n    PtrTy get() const { return Val; }\n    template <typename T> T *getAs() { return static_cast<T*>(get()); }\n\n    void set(PtrTy V) { Val = V; }\n\n    const ActionResult &operator=(PtrTy RHS) {\n      Val = RHS;\n      Invalid = false;\n      return *this;\n    }\n  };\n\n  // This ActionResult partial specialization places the \"invalid\"\n  // flag into the low bit of the pointer.\n  template<typename PtrTy>\n  class ActionResult<PtrTy, true> {\n    // A pointer whose low bit is 1 if this result is invalid, 0\n    // otherwise.\n    uintptr_t PtrWithInvalid;\n\n    using PtrTraits = llvm::PointerLikeTypeTraits<PtrTy>;\n\n  public:\n    ActionResult(bool Invalid = false)\n        : PtrWithInvalid(static_cast<uintptr_t>(Invalid)) {}\n\n    ActionResult(PtrTy V) {\n      void *VP = PtrTraits::getAsVoidPointer(V);\n      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);\n      assert((PtrWithInvalid & 0x01) == 0 && \"Badly aligned pointer\");\n    }\n\n    ActionResult(const DiagnosticBuilder &) : PtrWithInvalid(0x01) {}\n\n    // These two overloads prevent void* -> bool conversions.\n    ActionResult(const void *) = delete;\n    ActionResult(volatile void *) = delete;\n\n    bool isInvalid() const { return PtrWithInvalid & 0x01; }\n    bool isUsable() const { return PtrWithInvalid > 0x01; }\n    bool isUnset() const { return PtrWithInvalid == 0; }\n\n    PtrTy get() const {\n      void *VP = reinterpret_cast<void *>(PtrWithInvalid & ~0x01);\n      return PtrTraits::getFromVoidPointer(VP);\n    }\n\n    template <typename T> T *getAs() { return static_cast<T*>(get()); }\n\n    void set(PtrTy V) {\n      void *VP = PtrTraits::getAsVoidPointer(V);\n      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);\n      assert((PtrWithInvalid & 0x01) == 0 && \"Badly aligned pointer\");\n    }\n\n    const ActionResult &operator=(PtrTy RHS) {\n      void *VP = PtrTraits::getAsVoidPointer(RHS);\n      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);\n      assert((PtrWithInvalid & 0x01) == 0 && \"Badly aligned pointer\");\n      return *this;\n    }\n\n    // For types where we can fit a flag in with the pointer, provide\n    // conversions to/from pointer type.\n    static ActionResult getFromOpaquePointer(void *P) {\n      ActionResult Result;\n      Result.PtrWithInvalid = (uintptr_t)P;\n      return Result;\n    }\n    void *getAsOpaquePointer() const { return (void*)PtrWithInvalid; }\n  };\n\n  /// An opaque type for threading parsed type information through the\n  /// parser.\n  using ParsedType = OpaquePtr<QualType>;\n  using UnionParsedType = UnionOpaquePtr<QualType>;\n\n  // We can re-use the low bit of expression, statement, base, and\n  // member-initializer pointers for the \"invalid\" flag of\n  // ActionResult.\n  template<> struct IsResultPtrLowBitFree<Expr*> {\n    static const bool value = true;\n  };\n  template<> struct IsResultPtrLowBitFree<Stmt*> {\n    static const bool value = true;\n  };\n  template<> struct IsResultPtrLowBitFree<CXXBaseSpecifier*> {\n    static const bool value = true;\n  };\n  template<> struct IsResultPtrLowBitFree<CXXCtorInitializer*> {\n    static const bool value = true;\n  };\n\n  using ExprResult = ActionResult<Expr *>;\n  using StmtResult = ActionResult<Stmt *>;\n  using TypeResult = ActionResult<ParsedType>;\n  using BaseResult = ActionResult<CXXBaseSpecifier *>;\n  using MemInitResult = ActionResult<CXXCtorInitializer *>;\n\n  using DeclResult = ActionResult<Decl *>;\n  using ParsedTemplateTy = OpaquePtr<TemplateName>;\n  using UnionParsedTemplateTy = UnionOpaquePtr<TemplateName>;\n\n  using MultiExprArg = MutableArrayRef<Expr *>;\n  using MultiStmtArg = MutableArrayRef<Stmt *>;\n  using ASTTemplateArgsPtr = MutableArrayRef<ParsedTemplateArgument>;\n  using MultiTypeArg = MutableArrayRef<ParsedType>;\n  using MultiTemplateParamsArg = MutableArrayRef<TemplateParameterList *>;\n\n  inline ExprResult ExprError() { return ExprResult(true); }\n  inline StmtResult StmtError() { return StmtResult(true); }\n  inline TypeResult TypeError() { return TypeResult(true); }\n\n  inline ExprResult ExprError(const StreamingDiagnostic &) {\n    return ExprError();\n  }\n  inline StmtResult StmtError(const StreamingDiagnostic &) {\n    return StmtError();\n  }\n\n  inline ExprResult ExprEmpty() { return ExprResult(false); }\n  inline StmtResult StmtEmpty() { return StmtResult(false); }\n\n  inline Expr *AssertSuccess(ExprResult R) {\n    assert(!R.isInvalid() && \"operation was asserted to never fail!\");\n    return R.get();\n  }\n\n  inline Stmt *AssertSuccess(StmtResult R) {\n    assert(!R.isInvalid() && \"operation was asserted to never fail!\");\n    return R.get();\n  }\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_OWNERSHIP_H\n"}, "73": {"id": 73, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "content": "//======- ParsedAttr.h - Parsed attribute sets ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ParsedAttr class, which is used to collect\n// parsed attributes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n#define LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n\n#include \"clang/Basic/AttrSubjectMatchRules.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Registry.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass Expr;\nclass IdentifierInfo;\nclass LangOptions;\nclass ParsedAttr;\nclass Sema;\nclass TargetInfo;\n\nstruct ParsedAttrInfo {\n  /// Corresponds to the Kind enum.\n  unsigned AttrKind : 16;\n  /// The number of required arguments of this attribute.\n  unsigned NumArgs : 4;\n  /// The number of optional arguments of this attributes.\n  unsigned OptArgs : 4;\n  /// True if the parsing does not match the semantic content.\n  unsigned HasCustomParsing : 1;\n  /// True if this attribute is only available for certain targets.\n  unsigned IsTargetSpecific : 1;\n  /// True if this attribute applies to types.\n  unsigned IsType : 1;\n  /// True if this attribute applies to statements.\n  unsigned IsStmt : 1;\n  /// True if this attribute has any spellings that are known to gcc.\n  unsigned IsKnownToGCC : 1;\n  /// True if this attribute is supported by #pragma clang attribute.\n  unsigned IsSupportedByPragmaAttribute : 1;\n  /// The syntaxes supported by this attribute and how they're spelled.\n  struct Spelling {\n    AttributeCommonInfo::Syntax Syntax;\n    const char *NormalizedFullName;\n  };\n  ArrayRef<Spelling> Spellings;\n\n  ParsedAttrInfo(AttributeCommonInfo::Kind AttrKind =\n                     AttributeCommonInfo::NoSemaHandlerAttribute)\n      : AttrKind(AttrKind), NumArgs(0), OptArgs(0), HasCustomParsing(0),\n        IsTargetSpecific(0), IsType(0), IsStmt(0), IsKnownToGCC(0),\n        IsSupportedByPragmaAttribute(0) {}\n\n  virtual ~ParsedAttrInfo() = default;\n\n  /// Check if this attribute appertains to D, and issue a diagnostic if not.\n  virtual bool diagAppertainsToDecl(Sema &S, const ParsedAttr &Attr,\n                                    const Decl *D) const {\n    return true;\n  }\n  /// Check if this attribute is allowed by the language we are compiling, and\n  /// issue a diagnostic if not.\n  virtual bool diagLangOpts(Sema &S, const ParsedAttr &Attr) const {\n    return true;\n  }\n  /// Check if this attribute is allowed when compiling for the given target.\n  virtual bool existsInTarget(const TargetInfo &Target) const {\n    return true;\n  }\n  /// Convert the spelling index of Attr to a semantic spelling enum value.\n  virtual unsigned\n  spellingIndexToSemanticSpelling(const ParsedAttr &Attr) const {\n    return UINT_MAX;\n  }\n  /// Populate Rules with the match rules of this attribute.\n  virtual void getPragmaAttributeMatchRules(\n      llvm::SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>> &Rules,\n      const LangOptions &LangOpts) const {\n  }\n  enum AttrHandling {\n    NotHandled,\n    AttributeApplied,\n    AttributeNotApplied\n  };\n  /// If this ParsedAttrInfo knows how to handle this ParsedAttr applied to this\n  /// Decl then do so and return either AttributeApplied if it was applied or\n  /// AttributeNotApplied if it wasn't. Otherwise return NotHandled.\n  virtual AttrHandling handleDeclAttribute(Sema &S, Decl *D,\n                                           const ParsedAttr &Attr) const {\n    return NotHandled;\n  }\n\n  static const ParsedAttrInfo &get(const AttributeCommonInfo &A);\n};\n\ntypedef llvm::Registry<ParsedAttrInfo> ParsedAttrInfoRegistry;\n\n/// Represents information about a change in availability for\n/// an entity, which is part of the encoding of the 'availability'\n/// attribute.\nstruct AvailabilityChange {\n  /// The location of the keyword indicating the kind of change.\n  SourceLocation KeywordLoc;\n\n  /// The version number at which the change occurred.\n  VersionTuple Version;\n\n  /// The source range covering the version number.\n  SourceRange VersionRange;\n\n  /// Determine whether this availability change is valid.\n  bool isValid() const { return !Version.empty(); }\n};\n\nnamespace detail {\nenum AvailabilitySlot {\n  IntroducedSlot, DeprecatedSlot, ObsoletedSlot, NumAvailabilitySlots\n};\n\n/// Describes the trailing object for Availability attribute in ParsedAttr.\nstruct AvailabilityData {\n  AvailabilityChange Changes[NumAvailabilitySlots];\n  SourceLocation StrictLoc;\n  const Expr *Replacement;\n\n  AvailabilityData(const AvailabilityChange &Introduced,\n                   const AvailabilityChange &Deprecated,\n                   const AvailabilityChange &Obsoleted,\n                   SourceLocation Strict, const Expr *ReplaceExpr)\n    : StrictLoc(Strict), Replacement(ReplaceExpr) {\n    Changes[IntroducedSlot] = Introduced;\n    Changes[DeprecatedSlot] = Deprecated;\n    Changes[ObsoletedSlot] = Obsoleted;\n  }\n};\n\nstruct TypeTagForDatatypeData {\n  ParsedType MatchingCType;\n  unsigned LayoutCompatible : 1;\n  unsigned MustBeNull : 1;\n};\nstruct PropertyData {\n  IdentifierInfo *GetterId, *SetterId;\n\n  PropertyData(IdentifierInfo *getterId, IdentifierInfo *setterId)\n      : GetterId(getterId), SetterId(setterId) {}\n};\n\n} // namespace\n\n/// Wraps an identifier and optional source location for the identifier.\nstruct IdentifierLoc {\n  SourceLocation Loc;\n  IdentifierInfo *Ident;\n\n  static IdentifierLoc *create(ASTContext &Ctx, SourceLocation Loc,\n                               IdentifierInfo *Ident);\n};\n\n/// A union of the various pointer types that can be passed to an\n/// ParsedAttr as an argument.\nusing ArgsUnion = llvm::PointerUnion<Expr *, IdentifierLoc *>;\nusing ArgsVector = llvm::SmallVector<ArgsUnion, 12U>;\n\n/// ParsedAttr - Represents a syntactic attribute.\n///\n/// For a GNU attribute, there are four forms of this construct:\n///\n/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.\n/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.\n/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.\n/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.\n///\nclass ParsedAttr final\n    : public AttributeCommonInfo,\n      private llvm::TrailingObjects<\n          ParsedAttr, ArgsUnion, detail::AvailabilityData,\n          detail::TypeTagForDatatypeData, ParsedType, detail::PropertyData> {\n  friend TrailingObjects;\n\n  size_t numTrailingObjects(OverloadToken<ArgsUnion>) const { return NumArgs; }\n  size_t numTrailingObjects(OverloadToken<detail::AvailabilityData>) const {\n    return IsAvailability;\n  }\n  size_t\n      numTrailingObjects(OverloadToken<detail::TypeTagForDatatypeData>) const {\n    return IsTypeTagForDatatype;\n  }\n  size_t numTrailingObjects(OverloadToken<ParsedType>) const {\n    return HasParsedType;\n  }\n  size_t numTrailingObjects(OverloadToken<detail::PropertyData>) const {\n    return IsProperty;\n  }\n\nprivate:\n  IdentifierInfo *MacroII = nullptr;\n  SourceLocation MacroExpansionLoc;\n  SourceLocation EllipsisLoc;\n\n  /// The number of expression arguments this attribute has.\n  /// The expressions themselves are stored after the object.\n  unsigned NumArgs : 16;\n\n  /// True if already diagnosed as invalid.\n  mutable unsigned Invalid : 1;\n\n  /// True if this attribute was used as a type attribute.\n  mutable unsigned UsedAsTypeAttr : 1;\n\n  /// True if this has the extra information associated with an\n  /// availability attribute.\n  unsigned IsAvailability : 1;\n\n  /// True if this has extra information associated with a\n  /// type_tag_for_datatype attribute.\n  unsigned IsTypeTagForDatatype : 1;\n\n  /// True if this has extra information associated with a\n  /// Microsoft __delcspec(property) attribute.\n  unsigned IsProperty : 1;\n\n  /// True if this has a ParsedType\n  unsigned HasParsedType : 1;\n\n  /// True if the processing cache is valid.\n  mutable unsigned HasProcessingCache : 1;\n\n  /// A cached value.\n  mutable unsigned ProcessingCache : 8;\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  mutable unsigned IsPragmaClangAttribute : 1;\n\n  /// The location of the 'unavailable' keyword in an\n  /// availability attribute.\n  SourceLocation UnavailableLoc;\n\n  const Expr *MessageExpr;\n\n  const ParsedAttrInfo &Info;\n\n  ArgsUnion *getArgsBuffer() { return getTrailingObjects<ArgsUnion>(); }\n  ArgsUnion const *getArgsBuffer() const {\n    return getTrailingObjects<ArgsUnion>();\n  }\n\n  detail::AvailabilityData *getAvailabilityData() {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n  const detail::AvailabilityData *getAvailabilityData() const {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n\nprivate:\n  friend class AttributeFactory;\n  friend class AttributePool;\n\n  /// Constructor for attributes with expression arguments.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ArgsUnion *args, unsigned numArgs, Syntax syntaxUsed,\n             SourceLocation ellipsisLoc)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        EllipsisLoc(ellipsisLoc), NumArgs(numArgs), Invalid(false),\n        UsedAsTypeAttr(false), IsAvailability(false),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        Info(ParsedAttrInfo::get(*this)) {\n    if (numArgs)\n      memcpy(getArgsBuffer(), args, numArgs * sizeof(ArgsUnion));\n  }\n\n  /// Constructor for availability attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm, const AvailabilityChange &introduced,\n             const AvailabilityChange &deprecated,\n             const AvailabilityChange &obsoleted, SourceLocation unavailable,\n             const Expr *messageExpr, Syntax syntaxUsed, SourceLocation strict,\n             const Expr *replacementExpr)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false), IsAvailability(true),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        UnavailableLoc(unavailable), MessageExpr(messageExpr),\n        Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(Parm);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    new (getAvailabilityData()) detail::AvailabilityData(\n        introduced, deprecated, obsoleted, strict, replacementExpr);\n  }\n\n  /// Constructor for objc_bridge_related attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm1, IdentifierLoc *Parm2, IdentifierLoc *Parm3,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(3), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion *Args = getArgsBuffer();\n    Args[0] = Parm1;\n    Args[1] = Parm2;\n    Args[2] = Parm3;\n  }\n\n  /// Constructor for type_tag_for_datatype attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *ArgKind, ParsedType matchingCType,\n             bool layoutCompatible, bool mustBeNull, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(true), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(ArgKind);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    detail::TypeTagForDatatypeData &ExtraData = getTypeTagForDatatypeDataSlot();\n    new (&ExtraData.MatchingCType) ParsedType(matchingCType);\n    ExtraData.LayoutCompatible = layoutCompatible;\n    ExtraData.MustBeNull = mustBeNull;\n  }\n\n  /// Constructor for attributes with a single type argument.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ParsedType typeArg, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(true), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getTypeBuffer()) ParsedType(typeArg);\n  }\n\n  /// Constructor for microsoft __declspec(property) attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierInfo *getterId, IdentifierInfo *setterId,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(true),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getPropertyDataBuffer()) detail::PropertyData(getterId, setterId);\n  }\n\n  /// Type tag information is stored immediately following the arguments, if\n  /// any, at the end of the object.  They are mutually exclusive with\n  /// availability slots.\n  detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n  const detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() const {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n\n  /// The type buffer immediately follows the object and are mutually exclusive\n  /// with arguments.\n  ParsedType &getTypeBuffer() { return *getTrailingObjects<ParsedType>(); }\n  const ParsedType &getTypeBuffer() const {\n    return *getTrailingObjects<ParsedType>();\n  }\n\n  /// The property data immediately follows the object is is mutually exclusive\n  /// with arguments.\n  detail::PropertyData &getPropertyDataBuffer() {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n  const detail::PropertyData &getPropertyDataBuffer() const {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n\n  size_t allocated_size() const;\n\npublic:\n  ParsedAttr(const ParsedAttr &) = delete;\n  ParsedAttr(ParsedAttr &&) = delete;\n  ParsedAttr &operator=(const ParsedAttr &) = delete;\n  ParsedAttr &operator=(ParsedAttr &&) = delete;\n  ~ParsedAttr() = delete;\n\n  void operator delete(void *) = delete;\n\n  bool hasParsedType() const { return HasParsedType; }\n\n  /// Is this the Microsoft __declspec(property) attribute?\n  bool isDeclspecPropertyAttribute() const  {\n    return IsProperty;\n  }\n\n  bool isInvalid() const { return Invalid; }\n  void setInvalid(bool b = true) const { Invalid = b; }\n\n  bool hasProcessingCache() const { return HasProcessingCache; }\n\n  unsigned getProcessingCache() const {\n    assert(hasProcessingCache());\n    return ProcessingCache;\n  }\n\n  void setProcessingCache(unsigned value) const {\n    ProcessingCache = value;\n    HasProcessingCache = true;\n  }\n\n  bool isUsedAsTypeAttr() const { return UsedAsTypeAttr; }\n  void setUsedAsTypeAttr(bool Used = true) { UsedAsTypeAttr = Used; }\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  bool isPragmaClangAttribute() const { return IsPragmaClangAttribute; }\n\n  void setIsPragmaClangAttribute() { IsPragmaClangAttribute = true; }\n\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// getNumArgs - Return the number of actual arguments to this attribute.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// getArg - Return the specified argument.\n  ArgsUnion getArg(unsigned Arg) const {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgsBuffer()[Arg];\n  }\n\n  bool isArgExpr(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<Expr*>();\n  }\n\n  Expr *getArgAsExpr(unsigned Arg) const {\n    return getArg(Arg).get<Expr*>();\n  }\n\n  bool isArgIdent(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<IdentifierLoc*>();\n  }\n\n  IdentifierLoc *getArgAsIdent(unsigned Arg) const {\n    return getArg(Arg).get<IdentifierLoc*>();\n  }\n\n  const AvailabilityChange &getAvailabilityIntroduced() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::IntroducedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityDeprecated() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::DeprecatedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityObsoleted() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::ObsoletedSlot];\n  }\n\n  SourceLocation getStrictLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->StrictLoc;\n  }\n\n  SourceLocation getUnavailableLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return UnavailableLoc;\n  }\n\n  const Expr * getMessageExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return MessageExpr;\n  }\n\n  const Expr *getReplacementExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Replacement;\n  }\n\n  const ParsedType &getMatchingCType() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MatchingCType;\n  }\n\n  bool getLayoutCompatible() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().LayoutCompatible;\n  }\n\n  bool getMustBeNull() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MustBeNull;\n  }\n\n  const ParsedType &getTypeArg() const {\n    assert(HasParsedType && \"Not a type attribute\");\n    return getTypeBuffer();\n  }\n\n  IdentifierInfo *getPropertyDataGetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().GetterId;\n  }\n\n  IdentifierInfo *getPropertyDataSetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().SetterId;\n  }\n\n  /// Set the macro identifier info object that this parsed attribute was\n  /// declared in if it was declared in a macro. Also set the expansion location\n  /// of the macro.\n  void setMacroIdentifier(IdentifierInfo *MacroName, SourceLocation Loc) {\n    MacroII = MacroName;\n    MacroExpansionLoc = Loc;\n  }\n\n  /// Returns true if this attribute was declared in a macro.\n  bool hasMacroIdentifier() const { return MacroII != nullptr; }\n\n  /// Return the macro identifier if this attribute was declared in a macro.\n  /// nullptr is returned if it was not declared in a macro.\n  IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n\n  SourceLocation getMacroExpansionLoc() const {\n    assert(hasMacroIdentifier() && \"Can only get the macro expansion location \"\n                                   \"if this attribute has a macro identifier.\");\n    return MacroExpansionLoc;\n  }\n\n  /// Check if the attribute has exactly as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkExactlyNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at least as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtLeastNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at most as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtMostNumArgs(class Sema &S, unsigned Num) const;\n\n  bool isTargetSpecificAttr() const;\n  bool isTypeAttr() const;\n  bool isStmtAttr() const;\n\n  bool hasCustomParsing() const;\n  unsigned getMinArgs() const;\n  unsigned getMaxArgs() const;\n  bool hasVariadicArg() const;\n  bool diagnoseAppertainsTo(class Sema &S, const Decl *D) const;\n  bool appliesToDecl(const Decl *D, attr::SubjectMatchRule MatchRule) const;\n  void getMatchRules(const LangOptions &LangOpts,\n                     SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>>\n                         &MatchRules) const;\n  bool diagnoseLangOpts(class Sema &S) const;\n  bool existsInTarget(const TargetInfo &Target) const;\n  bool isKnownToGCC() const;\n  bool isSupportedByPragmaAttribute() const;\n\n  /// If the parsed attribute has a semantic equivalent, and it would\n  /// have a semantic Spelling enumeration (due to having semantically-distinct\n  /// spelling variations), return the value of that semantic spelling. If the\n  /// parsed attribute does not have a semantic equivalent, or would not have\n  /// a Spelling enumeration, the value UINT_MAX is returned.\n  unsigned getSemanticSpelling() const;\n\n  /// If this is an OpenCL addr space attribute returns its representation\n  /// in LangAS, otherwise returns default addr space.\n  LangAS asOpenCLLangAS() const {\n    switch (getParsedKind()) {\n    case ParsedAttr::AT_OpenCLConstantAddressSpace:\n      return LangAS::opencl_constant;\n    case ParsedAttr::AT_OpenCLGlobalAddressSpace:\n      return LangAS::opencl_global;\n    case ParsedAttr::AT_OpenCLGlobalDeviceAddressSpace:\n      return LangAS::opencl_global_device;\n    case ParsedAttr::AT_OpenCLGlobalHostAddressSpace:\n      return LangAS::opencl_global_host;\n    case ParsedAttr::AT_OpenCLLocalAddressSpace:\n      return LangAS::opencl_local;\n    case ParsedAttr::AT_OpenCLPrivateAddressSpace:\n      return LangAS::opencl_private;\n    case ParsedAttr::AT_OpenCLGenericAddressSpace:\n      return LangAS::opencl_generic;\n    default:\n      return LangAS::Default;\n    }\n  }\n\n  AttributeCommonInfo::Kind getKind() const {\n    return AttributeCommonInfo::Kind(Info.AttrKind);\n  }\n  const ParsedAttrInfo &getInfo() const { return Info; }\n};\n\nclass AttributePool;\n/// A factory, from which one makes pools, from which one creates\n/// individual attributes which are deallocated with the pool.\n///\n/// Note that it's tolerably cheap to create and destroy one of\n/// these as long as you don't actually allocate anything in it.\nclass AttributeFactory {\npublic:\n  enum {\n    AvailabilityAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 1, 0, 0, 0),\n    TypeTagForDatatypeAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 0, 1, 0, 0),\n    PropertyAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 0, 1),\n  };\n\nprivate:\n  enum {\n    /// The number of free lists we want to be sure to support\n    /// inline.  This is just enough that availability attributes\n    /// don't surpass it.  It's actually very unlikely we'll see an\n    /// attribute that needs more than that; on x86-64 you'd need 10\n    /// expression arguments, and on i386 you'd need 19.\n    InlineFreeListsCapacity =\n        1 + (AvailabilityAllocSize - sizeof(ParsedAttr)) / sizeof(void *)\n  };\n\n  llvm::BumpPtrAllocator Alloc;\n\n  /// Free lists.  The index is determined by the following formula:\n  ///   (size - sizeof(ParsedAttr)) / sizeof(void*)\n  SmallVector<SmallVector<ParsedAttr *, 8>, InlineFreeListsCapacity> FreeLists;\n\n  // The following are the private interface used by AttributePool.\n  friend class AttributePool;\n\n  /// Allocate an attribute of the given size.\n  void *allocate(size_t size);\n\n  void deallocate(ParsedAttr *AL);\n\n  /// Reclaim all the attributes in the given pool chain, which is\n  /// non-empty.  Note that the current implementation is safe\n  /// against reclaiming things which were not actually allocated\n  /// with the allocator, although of course it's important to make\n  /// sure that their allocator lives at least as long as this one.\n  void reclaimPool(AttributePool &head);\n\npublic:\n  AttributeFactory();\n  ~AttributeFactory();\n};\n\nclass AttributePool {\n  friend class AttributeFactory;\n  friend class ParsedAttributes;\n  AttributeFactory &Factory;\n  llvm::TinyPtrVector<ParsedAttr *> Attrs;\n\n  void *allocate(size_t size) {\n    return Factory.allocate(size);\n  }\n\n  ParsedAttr *add(ParsedAttr *attr) {\n    Attrs.push_back(attr);\n    return attr;\n  }\n\n  void remove(ParsedAttr *attr) {\n    assert(llvm::is_contained(Attrs, attr) &&\n           \"Can't take attribute from a pool that doesn't own it!\");\n    Attrs.erase(llvm::find(Attrs, attr));\n  }\n\n  void takePool(AttributePool &pool);\n\npublic:\n  /// Create a new pool for a factory.\n  AttributePool(AttributeFactory &factory) : Factory(factory) {}\n\n  AttributePool(const AttributePool &) = delete;\n\n  ~AttributePool() { Factory.reclaimPool(*this); }\n\n  /// Move the given pool's allocations to this pool.\n  AttributePool(AttributePool &&pool) = default;\n\n  AttributeFactory &getFactory() const { return Factory; }\n\n  void clear() {\n    Factory.reclaimPool(*this);\n    Attrs.clear();\n  }\n\n  /// Take the given pool's allocations and add them to this pool.\n  void takeAllFrom(AttributePool &pool) {\n    takePool(pool);\n    pool.Attrs.clear();\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    size_t temp =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0, 0);\n    (void)temp;\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0,\n                                                           0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       args, numArgs, syntax, ellipsisLoc));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    void *memory = allocate(AttributeFactory::AvailabilityAllocSize);\n    return add(new (memory) ParsedAttr(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(3, 0, 0, 0, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       Param1, Param2, Param3, syntax));\n  }\n\n  ParsedAttr *\n  createTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(AttributeFactory::TypeTagForDatatypeAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       argumentKind, matchingCType,\n                                       layoutCompatible, mustBeNull, syntax));\n  }\n\n  ParsedAttr *createTypeAttribute(IdentifierInfo *attrName,\n                                  SourceRange attrRange,\n                                  IdentifierInfo *scopeName,\n                                  SourceLocation scopeLoc, ParsedType typeArg,\n                                  ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 1, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       typeArg, syntaxUsed));\n  }\n\n  ParsedAttr *\n  createPropertyAttribute(IdentifierInfo *attrName, SourceRange attrRange,\n                          IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                          IdentifierInfo *getterId, IdentifierInfo *setterId,\n                          ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(AttributeFactory::PropertyAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       getterId, setterId, syntaxUsed));\n  }\n};\n\nclass ParsedAttributesView {\n  using VecTy = llvm::TinyPtrVector<ParsedAttr *>;\n  using SizeType = decltype(std::declval<VecTy>().size());\n\npublic:\n  bool empty() const { return AttrList.empty(); }\n  SizeType size() const { return AttrList.size(); }\n  ParsedAttr &operator[](SizeType pos) { return *AttrList[pos]; }\n  const ParsedAttr &operator[](SizeType pos) const { return *AttrList[pos]; }\n\n  void addAtEnd(ParsedAttr *newAttr) {\n    assert(newAttr);\n    AttrList.push_back(newAttr);\n  }\n\n  void remove(ParsedAttr *ToBeRemoved) {\n    assert(is_contained(AttrList, ToBeRemoved) &&\n           \"Cannot remove attribute that isn't in the list\");\n    AttrList.erase(llvm::find(AttrList, ToBeRemoved));\n  }\n\n  void clearListOnly() { AttrList.clear(); }\n\n  struct iterator : llvm::iterator_adaptor_base<iterator, VecTy::iterator,\n                                                std::random_access_iterator_tag,\n                                                ParsedAttr> {\n    iterator() : iterator_adaptor_base(nullptr) {}\n    iterator(VecTy::iterator I) : iterator_adaptor_base(I) {}\n    reference operator*() { return **I; }\n    friend class ParsedAttributesView;\n  };\n  struct const_iterator\n      : llvm::iterator_adaptor_base<const_iterator, VecTy::const_iterator,\n                                    std::random_access_iterator_tag,\n                                    ParsedAttr> {\n    const_iterator() : iterator_adaptor_base(nullptr) {}\n    const_iterator(VecTy::const_iterator I) : iterator_adaptor_base(I) {}\n\n    reference operator*() const { return **I; }\n    friend class ParsedAttributesView;\n  };\n\n  void addAll(iterator B, iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAll(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAllAtEnd(iterator B, iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  void addAllAtEnd(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  iterator begin() { return iterator(AttrList.begin()); }\n  const_iterator begin() const { return const_iterator(AttrList.begin()); }\n  iterator end() { return iterator(AttrList.end()); }\n  const_iterator end() const { return const_iterator(AttrList.end()); }\n\n  ParsedAttr &front() {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  const ParsedAttr &front() const {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  ParsedAttr &back() {\n    assert(!empty());\n    return *AttrList.back();\n  }\n  const ParsedAttr &back() const {\n    assert(!empty());\n    return *AttrList.back();\n  }\n\n  bool hasAttribute(ParsedAttr::Kind K) const {\n    return llvm::any_of(AttrList, [K](const ParsedAttr *AL) {\n      return AL->getParsedKind() == K;\n    });\n  }\n\nprivate:\n  VecTy AttrList;\n};\n\n/// ParsedAttributes - A collection of parsed attributes.  Currently\n/// we don't differentiate between the various attribute syntaxes,\n/// which is basically silly.\n///\n/// Right now this is a very lightweight container, but the expectation\n/// is that this will become significantly more serious.\nclass ParsedAttributes : public ParsedAttributesView {\npublic:\n  ParsedAttributes(AttributeFactory &factory) : pool(factory) {}\n  ParsedAttributes(const ParsedAttributes &) = delete;\n\n  AttributePool &getPool() const { return pool; }\n\n  void takeAllFrom(ParsedAttributes &attrs) {\n    addAll(attrs.begin(), attrs.end());\n    attrs.clearListOnly();\n    pool.takeAllFrom(attrs.pool);\n  }\n\n  void takeOneFrom(ParsedAttributes &Attrs, ParsedAttr *PA) {\n    Attrs.getPool().remove(PA);\n    Attrs.remove(PA);\n    getPool().add(PA);\n    addAtEnd(PA);\n  }\n\n  void clear() {\n    clearListOnly();\n    pool.clear();\n  }\n\n  /// Add attribute with expression arguments.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   args, numArgs, syntax, ellipsisLoc);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add availability attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    ParsedAttr *attr = pool.create(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add objc_bridge_related attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   Param1, Param2, Param3, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add type_tag_for_datatype attribute.\n  ParsedAttr *\n  addNewTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.createTypeTagForDatatype(\n        attrName, attrRange, scopeName, scopeLoc, argumentKind, matchingCType,\n        layoutCompatible, mustBeNull, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add an attribute with a single type argument.\n  ParsedAttr *addNewTypeAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                             ParsedType typeArg,\n                             ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr = pool.createTypeAttribute(attrName, attrRange, scopeName,\n                                                scopeLoc, typeArg, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add microsoft __delspec(property) attribute.\n  ParsedAttr *\n  addNewPropertyAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierInfo *getterId, IdentifierInfo *setterId,\n                     ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr =\n        pool.createPropertyAttribute(attrName, attrRange, scopeName, scopeLoc,\n                                     getterId, setterId, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\nprivate:\n  mutable AttributePool pool;\n};\n\n/// These constants match the enumerated choices of\n/// err_attribute_argument_n_type and err_attribute_argument_type.\nenum AttributeArgumentNType {\n  AANT_ArgumentIntOrBool,\n  AANT_ArgumentIntegerConstant,\n  AANT_ArgumentString,\n  AANT_ArgumentIdentifier,\n  AANT_ArgumentConstantExpr,\n};\n\n/// These constants match the enumerated choices of\n/// warn_attribute_wrong_decl_type and err_attribute_wrong_decl_type.\nenum AttributeDeclKind {\n  ExpectedFunction,\n  ExpectedUnion,\n  ExpectedVariableOrFunction,\n  ExpectedFunctionOrMethod,\n  ExpectedFunctionMethodOrBlock,\n  ExpectedFunctionMethodOrParameter,\n  ExpectedVariable,\n  ExpectedVariableOrField,\n  ExpectedVariableFieldOrTag,\n  ExpectedTypeOrNamespace,\n  ExpectedFunctionVariableOrClass,\n  ExpectedKernelFunction,\n  ExpectedFunctionWithProtoType,\n};\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr &At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr *At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n/// AttributeCommonInfo has a non-explicit constructor which takes an\n/// SourceRange as its only argument, this constructor has many uses so making\n/// it explicit is hard. This constructor causes ambiguity with\n/// DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB, SourceRange R).\n/// We use SFINAE to disable any conversion and remove any ambiguity.\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI &CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI* CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n"}, "74": {"id": 74, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/PCHContainerOperations.h", "content": "//===--- Serialization/PCHContainerOperations.h - PCH Containers --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_PCHCONTAINEROPERATIONS_H\n#define LLVM_CLANG_SERIALIZATION_PCHCONTAINEROPERATIONS_H\n\n#include \"clang/Basic/Module.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <memory>\n\nnamespace llvm {\nclass raw_pwrite_stream;\n}\n\nnamespace clang {\n\nclass ASTConsumer;\nclass CodeGenOptions;\nclass DiagnosticsEngine;\nclass CompilerInstance;\n\nstruct PCHBuffer {\n  ASTFileSignature Signature;\n  llvm::SmallVector<char, 0> Data;\n  bool IsComplete;\n};\n\n/// This abstract interface provides operations for creating\n/// containers for serialized ASTs (precompiled headers and clang\n/// modules).\nclass PCHContainerWriter {\npublic:\n  virtual ~PCHContainerWriter() = 0;\n  virtual llvm::StringRef getFormat() const = 0;\n\n  /// Return an ASTConsumer that can be chained with a\n  /// PCHGenerator that produces a wrapper file format containing a\n  /// serialized AST bitstream.\n  virtual std::unique_ptr<ASTConsumer>\n  CreatePCHContainerGenerator(CompilerInstance &CI,\n                              const std::string &MainFileName,\n                              const std::string &OutputFileName,\n                              std::unique_ptr<llvm::raw_pwrite_stream> OS,\n                              std::shared_ptr<PCHBuffer> Buffer) const = 0;\n};\n\n/// This abstract interface provides operations for unwrapping\n/// containers for serialized ASTs (precompiled headers and clang\n/// modules).\nclass PCHContainerReader {\npublic:\n  virtual ~PCHContainerReader() = 0;\n  /// Equivalent to the format passed to -fmodule-format=\n  virtual llvm::StringRef getFormat() const = 0;\n\n  /// Returns the serialized AST inside the PCH container Buffer.\n  virtual llvm::StringRef ExtractPCH(llvm::MemoryBufferRef Buffer) const = 0;\n};\n\n/// Implements write operations for a raw pass-through PCH container.\nclass RawPCHContainerWriter : public PCHContainerWriter {\n  llvm::StringRef getFormat() const override { return \"raw\"; }\n\n  /// Return an ASTConsumer that can be chained with a\n  /// PCHGenerator that writes the module to a flat file.\n  std::unique_ptr<ASTConsumer>\n  CreatePCHContainerGenerator(CompilerInstance &CI,\n                              const std::string &MainFileName,\n                              const std::string &OutputFileName,\n                              std::unique_ptr<llvm::raw_pwrite_stream> OS,\n                              std::shared_ptr<PCHBuffer> Buffer) const override;\n};\n\n/// Implements read operations for a raw pass-through PCH container.\nclass RawPCHContainerReader : public PCHContainerReader {\n  llvm::StringRef getFormat() const override { return \"raw\"; }\n\n  /// Simply returns the buffer contained in Buffer.\n  llvm::StringRef ExtractPCH(llvm::MemoryBufferRef Buffer) const override;\n};\n\n/// A registry of PCHContainerWriter and -Reader objects for different formats.\nclass PCHContainerOperations {\n  llvm::StringMap<std::unique_ptr<PCHContainerWriter>> Writers;\n  llvm::StringMap<std::unique_ptr<PCHContainerReader>> Readers;\npublic:\n  /// Automatically registers a RawPCHContainerWriter and\n  /// RawPCHContainerReader.\n  PCHContainerOperations();\n  void registerWriter(std::unique_ptr<PCHContainerWriter> Writer) {\n    Writers[Writer->getFormat()] = std::move(Writer);\n  }\n  void registerReader(std::unique_ptr<PCHContainerReader> Reader) {\n    Readers[Reader->getFormat()] = std::move(Reader);\n  }\n  const PCHContainerWriter *getWriterOrNull(llvm::StringRef Format) {\n    return Writers[Format].get();\n  }\n  const PCHContainerReader *getReaderOrNull(llvm::StringRef Format) {\n    return Readers[Format].get();\n  }\n  const PCHContainerReader &getRawReader() {\n    return *getReaderOrNull(\"raw\");\n  }\n};\n\n}\n\n#endif\n"}, "75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h", "content": "//===- AnalyzerOptions.h - Analysis Engine Options --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This header defines various options for the static analyzer that are set\n// by the frontend and are consulted throughout the analyzer.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_ANALYZEROPTIONS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_ANALYZEROPTIONS_H\n\n#include \"clang/Analysis/PathDiagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nnamespace ento {\n\nclass CheckerBase;\n\n} // namespace ento\n\n/// Analysis - Set of available source code analyses.\nenum Analyses {\n#define ANALYSIS(NAME, CMDFLAG, DESC, SCOPE) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumAnalyses\n};\n\n/// AnalysisStores - Set of available analysis store models.\nenum AnalysisStores {\n#define ANALYSIS_STORE(NAME, CMDFLAG, DESC, CREATFN) NAME##Model,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumStores\n};\n\n/// AnalysisConstraints - Set of available constraint models.\nenum AnalysisConstraints {\n#define ANALYSIS_CONSTRAINTS(NAME, CMDFLAG, DESC, CREATFN) NAME##Model,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumConstraints\n};\n\n/// AnalysisDiagClients - Set of available diagnostic clients for rendering\n///  analysis results.\nenum AnalysisDiagClients {\n#define ANALYSIS_DIAGNOSTICS(NAME, CMDFLAG, DESC, CREATFN) PD_##NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nPD_NONE,\nNUM_ANALYSIS_DIAG_CLIENTS\n};\n\n/// AnalysisPurgeModes - Set of available strategies for dead symbol removal.\nenum AnalysisPurgeMode {\n#define ANALYSIS_PURGE(NAME, CMDFLAG, DESC) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumPurgeModes\n};\n\n/// AnalysisInlineFunctionSelection - Set of inlining function selection heuristics.\nenum AnalysisInliningMode {\n#define ANALYSIS_INLINING_MODE(NAME, CMDFLAG, DESC) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumInliningModes\n};\n\n/// Describes the different kinds of C++ member functions which can be\n/// considered for inlining by the analyzer.\n///\n/// These options are cumulative; enabling one kind of member function will\n/// enable all kinds with lower enum values.\nenum CXXInlineableMemberKind {\n  // Uninitialized = 0,\n\n  /// A dummy mode in which no C++ inlining is enabled.\n  CIMK_None,\n\n  /// Refers to regular member function and operator calls.\n  CIMK_MemberFunctions,\n\n  /// Refers to constructors (implicit or explicit).\n  ///\n  /// Note that a constructor will not be inlined if the corresponding\n  /// destructor is non-trivial.\n  CIMK_Constructors,\n\n  /// Refers to destructors (implicit or explicit).\n  CIMK_Destructors\n};\n\n/// Describes the different modes of inter-procedural analysis.\nenum IPAKind {\n  /// Perform only intra-procedural analysis.\n  IPAK_None = 1,\n\n  /// Inline C functions and blocks when their definitions are available.\n  IPAK_BasicInlining = 2,\n\n  /// Inline callees(C, C++, ObjC) when their definitions are available.\n  IPAK_Inlining = 3,\n\n  /// Enable inlining of dynamically dispatched methods.\n  IPAK_DynamicDispatch = 4,\n\n  /// Enable inlining of dynamically dispatched methods, bifurcate paths when\n  /// exact type info is unavailable.\n  IPAK_DynamicDispatchBifurcate = 5\n};\n\nenum class ExplorationStrategyKind {\n  DFS,\n  BFS,\n  UnexploredFirst,\n  UnexploredFirstQueue,\n  UnexploredFirstLocationQueue,\n  BFSBlockDFSContents,\n};\n\n/// Describes the kinds for high-level analyzer mode.\nenum UserModeKind {\n  /// Perform shallow but fast analyzes.\n  UMK_Shallow = 1,\n\n  /// Perform deep analyzes.\n  UMK_Deep = 2\n};\n\n/// Stores options for the analyzer from the command line.\n///\n/// Some options are frontend flags (e.g.: -analyzer-output), but some are\n/// analyzer configuration options, which are preceded by -analyzer-config\n/// (e.g.: -analyzer-config notes-as-events=true).\n///\n/// If you'd like to add a new frontend flag, add it to\n/// include/clang/Driver/CC1Options.td, add a new field to store the value of\n/// that flag in this class, and initialize it in\n/// lib/Frontend/CompilerInvocation.cpp.\n///\n/// If you'd like to add a new non-checker configuration, register it in\n/// include/clang/StaticAnalyzer/Core/AnalyzerOptions.def, and refer to the\n/// top of the file for documentation.\n///\n/// If you'd like to add a new checker option, call getChecker*Option()\n/// whenever.\n///\n/// Some of the options are controlled by raw frontend flags for no good reason,\n/// and should be eventually converted into -analyzer-config flags. New analyzer\n/// options should not be implemented as frontend flags. Frontend flags still\n/// make sense for things that do not affect the actual analysis.\nclass AnalyzerOptions : public RefCountedBase<AnalyzerOptions> {\npublic:\n  using ConfigTable = llvm::StringMap<std::string>;\n\n  /// Retrieves the list of checkers generated from Checkers.td. This doesn't\n  /// contain statically linked but non-generated checkers and plugin checkers!\n  static std::vector<StringRef>\n  getRegisteredCheckers(bool IncludeExperimental = false);\n\n  /// Retrieves the list of packages generated from Checkers.td. This doesn't\n  /// contain statically linked but non-generated packages and plugin packages!\n  static std::vector<StringRef>\n  getRegisteredPackages(bool IncludeExperimental = false);\n\n  /// Convenience function for printing options or checkers and their\n  /// description in a formatted manner. If \\p MinLineWidth is set to 0, no line\n  /// breaks are introduced for the description.\n  ///\n  /// Format, depending whether the option name's length is less than\n  /// \\p EntryWidth:\n  ///\n  ///   <padding>EntryName<padding>Description\n  ///   <---------padding--------->Description\n  ///   <---------padding--------->Description\n  ///\n  ///   <padding>VeryVeryLongEntryName\n  ///   <---------padding--------->Description\n  ///   <---------padding--------->Description\n  ///   ^~~~~~~~~InitialPad\n  ///            ^~~~~~~~~~~~~~~~~~EntryWidth\n  ///   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MinLineWidth\n  static void printFormattedEntry(llvm::raw_ostream &Out,\n                                  std::pair<StringRef, StringRef> EntryDescPair,\n                                  size_t InitialPad, size_t EntryWidth,\n                                  size_t MinLineWidth = 0);\n\n  /// Pairs of checker/package name and enable/disable.\n  std::vector<std::pair<std::string, bool>> CheckersAndPackages;\n\n  /// Vector of checker/package names which will not emit warnings.\n  std::vector<std::string> SilencedCheckersAndPackages;\n\n  /// A key-value table of use-specified configuration values.\n  // TODO: This shouldn't be public.\n  ConfigTable Config;\n  AnalysisStores AnalysisStoreOpt = RegionStoreModel;\n  AnalysisConstraints AnalysisConstraintsOpt = RangeConstraintsModel;\n  AnalysisDiagClients AnalysisDiagOpt = PD_HTML;\n  AnalysisPurgeMode AnalysisPurgeOpt = PurgeStmt;\n\n  std::string AnalyzeSpecificFunction;\n\n  /// File path to which the exploded graph should be dumped.\n  std::string DumpExplodedGraphTo;\n\n  /// Store full compiler invocation for reproducible instructions in the\n  /// generated report.\n  std::string FullCompilerInvocation;\n\n  /// The maximum number of times the analyzer visits a block.\n  unsigned maxBlockVisitOnPath;\n\n  /// Disable all analyzer checkers.\n  ///\n  /// This flag allows one to disable analyzer checkers on the code processed by\n  /// the given analysis consumer. Note, the code will get parsed and the\n  /// command-line options will get checked.\n  unsigned DisableAllCheckers : 1;\n\n  unsigned ShowCheckerHelp : 1;\n  unsigned ShowCheckerHelpAlpha : 1;\n  unsigned ShowCheckerHelpDeveloper : 1;\n\n  unsigned ShowCheckerOptionList : 1;\n  unsigned ShowCheckerOptionAlphaList : 1;\n  unsigned ShowCheckerOptionDeveloperList : 1;\n\n  unsigned ShowEnabledCheckerList : 1;\n  unsigned ShowConfigOptionsList : 1;\n  unsigned ShouldEmitErrorsOnInvalidConfigValue : 1;\n  unsigned AnalyzeAll : 1;\n  unsigned AnalyzerDisplayProgress : 1;\n  unsigned AnalyzeNestedBlocks : 1;\n\n  unsigned eagerlyAssumeBinOpBifurcation : 1;\n\n  unsigned TrimGraph : 1;\n  unsigned visualizeExplodedGraphWithGraphViz : 1;\n  unsigned UnoptimizedCFG : 1;\n  unsigned PrintStats : 1;\n\n  /// Do not re-analyze paths leading to exhausted nodes with a different\n  /// strategy. We get better code coverage when retry is enabled.\n  unsigned NoRetryExhausted : 1;\n\n  /// Emit analyzer warnings as errors.\n  bool AnalyzerWerror : 1;\n\n  /// The inlining stack depth limit.\n  unsigned InlineMaxStackDepth;\n\n  /// The mode of function selection used during inlining.\n  AnalysisInliningMode InliningMode = NoRedundancy;\n\n  // Create a field for each -analyzer-config option.\n#define ANALYZER_OPTION_DEPENDS_ON_USER_MODE(TYPE, NAME, CMDFLAG, DESC,        \\\n                                             SHALLOW_VAL, DEEP_VAL)            \\\n  ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, SHALLOW_VAL)\n\n#define ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, DEFAULT_VAL)                \\\n  TYPE NAME;\n\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.def\"\n#undef ANALYZER_OPTION\n#undef ANALYZER_OPTION_DEPENDS_ON_USER_MODE\n\n  // Create an array of all -analyzer-config command line options. Sort it in\n  // the constructor.\n  std::vector<llvm::StringLiteral> AnalyzerConfigCmdFlags = {\n#define ANALYZER_OPTION_DEPENDS_ON_USER_MODE(TYPE, NAME, CMDFLAG, DESC,        \\\n                                             SHALLOW_VAL, DEEP_VAL)            \\\n  ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, SHALLOW_VAL)\n\n#define ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, DEFAULT_VAL)                \\\n  llvm::StringLiteral(CMDFLAG),\n\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.def\"\n#undef ANALYZER_OPTION\n#undef ANALYZER_OPTION_DEPENDS_ON_USER_MODE\n  };\n\n  bool isUnknownAnalyzerConfig(StringRef Name) const {\n    assert(llvm::is_sorted(AnalyzerConfigCmdFlags));\n\n    return !std::binary_search(AnalyzerConfigCmdFlags.begin(),\n                               AnalyzerConfigCmdFlags.end(), Name);\n  }\n\n  AnalyzerOptions()\n      : DisableAllCheckers(false), ShowCheckerHelp(false),\n        ShowCheckerHelpAlpha(false), ShowCheckerHelpDeveloper(false),\n        ShowCheckerOptionList(false), ShowCheckerOptionAlphaList(false),\n        ShowCheckerOptionDeveloperList(false), ShowEnabledCheckerList(false),\n        ShowConfigOptionsList(false), AnalyzeAll(false),\n        AnalyzerDisplayProgress(false), AnalyzeNestedBlocks(false),\n        eagerlyAssumeBinOpBifurcation(false), TrimGraph(false),\n        visualizeExplodedGraphWithGraphViz(false), UnoptimizedCFG(false),\n        PrintStats(false), NoRetryExhausted(false), AnalyzerWerror(false) {\n    llvm::sort(AnalyzerConfigCmdFlags);\n  }\n\n  /// Interprets an option's string value as a boolean. The \"true\" string is\n  /// interpreted as true and the \"false\" string is interpreted as false.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  bool getCheckerBooleanOption(StringRef CheckerName, StringRef OptionName,\n                               bool SearchInParents = false) const;\n\n  bool getCheckerBooleanOption(const ento::CheckerBase *C, StringRef OptionName,\n                               bool SearchInParents = false) const;\n\n  /// Interprets an option's string value as an integer value.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  int getCheckerIntegerOption(StringRef CheckerName, StringRef OptionName,\n                              bool SearchInParents = false) const;\n\n  int getCheckerIntegerOption(const ento::CheckerBase *C, StringRef OptionName,\n                              bool SearchInParents = false) const;\n\n  /// Query an option's string value.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  StringRef getCheckerStringOption(StringRef CheckerName, StringRef OptionName,\n                                   bool SearchInParents = false) const;\n\n  StringRef getCheckerStringOption(const ento::CheckerBase *C,\n                                   StringRef OptionName,\n                                   bool SearchInParents = false) const;\n\n  /// Retrieves and sets the UserMode. This is a high-level option,\n  /// which is used to set other low-level options. It is not accessible\n  /// outside of AnalyzerOptions.\n  UserModeKind getUserMode() const;\n\n  ExplorationStrategyKind getExplorationStrategy() const;\n\n  /// Returns the inter-procedural analysis mode.\n  IPAKind getIPAMode() const;\n\n  /// Returns the option controlling which C++ member functions will be\n  /// considered for inlining.\n  ///\n  /// This is controlled by the 'c++-inlining' config option.\n  ///\n  /// \\sa CXXMemberInliningMode\n  bool mayInlineCXXMemberFunction(CXXInlineableMemberKind K) const;\n\n  ento::PathDiagnosticConsumerOptions getDiagOpts() const {\n    return {FullCompilerInvocation,\n            ShouldDisplayMacroExpansions,\n            ShouldSerializeStats,\n            ShouldWriteStableReportFilename,\n            AnalyzerWerror,\n            ShouldApplyFixIts,\n            ShouldDisplayCheckerNameForText};\n  }\n};\n\nusing AnalyzerOptionsRef = IntrusiveRefCntPtr<AnalyzerOptions>;\n\n//===----------------------------------------------------------------------===//\n// We'll use AnalyzerOptions in the frontend, but we can't link the frontend\n// with clangStaticAnalyzerCore, because clangStaticAnalyzerCore depends on\n// clangFrontend.\n//\n// For this reason, implement some methods in this header file.\n//===----------------------------------------------------------------------===//\n\ninline UserModeKind AnalyzerOptions::getUserMode() const {\n  auto K = llvm::StringSwitch<llvm::Optional<UserModeKind>>(UserMode)\n    .Case(\"shallow\", UMK_Shallow)\n    .Case(\"deep\", UMK_Deep)\n    .Default(None);\n  assert(K.hasValue() && \"User mode is invalid.\");\n  return K.getValue();\n}\n\ninline std::vector<StringRef>\nAnalyzerOptions::getRegisteredCheckers(bool IncludeExperimental) {\n  static constexpr llvm::StringLiteral StaticAnalyzerCheckerNames[] = {\n#define GET_CHECKERS\n#define CHECKER(FULLNAME, CLASS, HELPTEXT, DOC_URI, IS_HIDDEN)                 \\\n  llvm::StringLiteral(FULLNAME),\n#include \"clang/StaticAnalyzer/Checkers/Checkers.inc\"\n#undef CHECKER\n#undef GET_CHECKERS\n  };\n  std::vector<StringRef> Checkers;\n  for (StringRef CheckerName : StaticAnalyzerCheckerNames) {\n    if (!CheckerName.startswith(\"debug.\") &&\n        (IncludeExperimental || !CheckerName.startswith(\"alpha.\")))\n      Checkers.push_back(CheckerName);\n  }\n  return Checkers;\n}\n\ninline std::vector<StringRef>\nAnalyzerOptions::getRegisteredPackages(bool IncludeExperimental) {\n  static constexpr llvm::StringLiteral StaticAnalyzerPackageNames[] = {\n#define GET_PACKAGES\n#define PACKAGE(FULLNAME) llvm::StringLiteral(FULLNAME),\n#include \"clang/StaticAnalyzer/Checkers/Checkers.inc\"\n#undef PACKAGE\n#undef GET_PACKAGES\n  };\n  std::vector<StringRef> Packages;\n  for (StringRef PackageName : StaticAnalyzerPackageNames) {\n    if (PackageName != \"debug\" &&\n        (IncludeExperimental || PackageName != \"alpha\"))\n      Packages.push_back(PackageName);\n  }\n  return Packages;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_ANALYZEROPTIONS_H\n"}, "77": {"id": 77, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "content": "//===- Nodes.h - syntax nodes for C/C++ grammar constructs ----*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Syntax tree nodes for C, C++ and Objective-C grammar constructs.\n//\n// Nodes provide access to their syntactic components, e.g. IfStatement provides\n// a way to get its condition, then and else branches, tokens for 'if' and\n// 'else' keywords.\n// When using the accessors, please assume they can return null. This happens\n// because:\n//   - the corresponding subnode is optional in the C++ grammar, e.g. an else\n//     branch of an if statement,\n//   - syntactic errors occurred while parsing the corresponding subnode.\n// One notable exception is \"introducer\" keywords, e.g. the accessor for the\n// 'if' keyword of an if statement will never return null.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_NODES_H\n#define LLVM_CLANG_TOOLING_SYNTAX_NODES_H\n\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"clang/Tooling/Syntax/Tree.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\nnamespace clang {\nnamespace syntax {\n\n/// A kind of a syntax node, used for implementing casts. The ordering and\n/// blocks of enumerator constants must correspond to the inheritance hierarchy\n/// of syntax::Node.\nenum class NodeKind : uint16_t {\n#define CONCRETE_NODE(Kind, Base) Kind,\n#include \"clang/Tooling/Syntax/Nodes.inc\"\n};\n/// For debugging purposes.\nraw_ostream &operator<<(raw_ostream &OS, NodeKind K);\n\n/// A relation between a parent and child node, e.g. 'left-hand-side of\n/// a binary expression'. Used for implementing accessors.\n///\n/// In general `NodeRole`s should be named the same as their accessors.\n///\n/// Some roles describe parent/child relations that occur multiple times in\n/// language grammar. We define only one role to describe all instances of such\n/// recurring relations. For example, grammar for both \"if\" and \"while\"\n/// statements requires an opening paren and a closing paren. The opening\n/// paren token is assigned the OpenParen role regardless of whether it appears\n/// as a child of IfStatement or WhileStatement node. More generally, when\n/// grammar requires a certain fixed token (like a specific keyword, or an\n/// opening paren), we define a role for this token and use it across all\n/// grammar rules with the same requirement. Names of such reusable roles end\n/// with a ~Token or a ~Keyword suffix.\nenum class NodeRole : uint8_t {\n  // Roles common to multiple node kinds.\n  /// A node without a parent\n  Detached,\n  /// Children of an unknown semantic nature, e.g. skipped tokens, comments.\n  Unknown,\n  /// An opening parenthesis in argument lists and blocks, e.g. '{', '(', etc.\n  OpenParen,\n  /// A closing parenthesis in argument lists and blocks, e.g. '}', ')', etc.\n  CloseParen,\n  /// A keywords that introduces some grammar construct, e.g. 'if', 'try', etc.\n  IntroducerKeyword,\n  /// A token that represents a literal, e.g. 'nullptr', '1', 'true', etc.\n  LiteralToken,\n  /// Tokens or Keywords.\n  ArrowToken,\n  ExternKeyword,\n  TemplateKeyword,\n  /// An inner statement for those that have only a single child of kind\n  /// statement, e.g. loop body for while, for, etc; inner statement for case,\n  /// default, etc.\n  BodyStatement,\n  /// List API roles.\n  ListElement,\n  ListDelimiter,\n\n  // Roles specific to particular node kinds.\n  OperatorToken,\n  Operand,\n  LeftHandSide,\n  RightHandSide,\n  ReturnValue,\n  CaseValue,\n  ThenStatement,\n  ElseKeyword,\n  ElseStatement,\n  Expression,\n  Statement,\n  Condition,\n  Message,\n  Declarator,\n  Declaration,\n  Size,\n  Parameters,\n  TrailingReturn,\n  UnqualifiedId,\n  Qualifier,\n  SubExpression,\n  Object,\n  AccessToken,\n  Member,\n  Callee,\n  Arguments,\n  Declarators\n};\n/// For debugging purposes.\nraw_ostream &operator<<(raw_ostream &OS, NodeRole R);\n\n#include \"clang/Tooling/Syntax/NodeClasses.inc\"\n\n/// Models a `nested-name-specifier`. C++ [expr.prim.id.qual]\n/// e.g. the `std::vector<int>::` in `std::vector<int>::size`.\nclass NestedNameSpecifier final : public List {\npublic:\n  NestedNameSpecifier() : List(NodeKind::NestedNameSpecifier) {}\n  static bool classof(const Node *N);\n  std::vector<NameSpecifier *> getSpecifiers();\n  std::vector<List::ElementAndDelimiter<syntax::NameSpecifier>>\n  getSpecifiersAndDoubleColons();\n};\n\n/// Models an `unqualified-id`. C++ [expr.prim.id.unqual]\n/// e.g. the `size` in `std::vector<int>::size`.\nclass UnqualifiedId final : public Tree {\npublic:\n  UnqualifiedId() : Tree(NodeKind::UnqualifiedId) {}\n  static bool classof(const Node *N);\n};\n\n/// An expression of an unknown kind, i.e. one not currently handled by the\n/// syntax tree.\nclass UnknownExpression final : public Expression {\npublic:\n  UnknownExpression() : Expression(NodeKind::UnknownExpression) {}\n  static bool classof(const Node *N);\n};\n\n/// Models arguments of a function call.\n///   call-arguments:\n///     delimited_list(expression, ',')\n/// Note: This construct is a simplification of the grammar rule for\n/// `expression-list`, that is used in the definition of `call-expression`\nclass CallArguments final : public List {\npublic:\n  CallArguments() : List(NodeKind::CallArguments) {}\n  static bool classof(const Node *N);\n  std::vector<Expression *> getArguments();\n  std::vector<List::ElementAndDelimiter<Expression>> getArgumentsAndCommas();\n};\n\n/// An abstract class for prefix and postfix unary operators.\nclass UnaryOperatorExpression : public Expression {\npublic:\n  UnaryOperatorExpression(NodeKind K) : Expression(K) {}\n  static bool classof(const Node *N);\n  Leaf *getOperatorToken();\n  Expression *getOperand();\n};\n\n/// <operator> <operand>\n///\n/// For example:\n///   +a          -b\n///   !c          not c\n///   ~d          compl d\n///   *e          &f\n///   ++h         --h\n///   __real i    __imag i\nclass PrefixUnaryOperatorExpression final : public UnaryOperatorExpression {\npublic:\n  PrefixUnaryOperatorExpression()\n      : UnaryOperatorExpression(NodeKind::PrefixUnaryOperatorExpression) {}\n  static bool classof(const Node *N);\n};\n\n/// <operand> <operator>\n///\n/// For example:\n///   a++\n///   b--\nclass PostfixUnaryOperatorExpression final : public UnaryOperatorExpression {\npublic:\n  PostfixUnaryOperatorExpression()\n      : UnaryOperatorExpression(NodeKind::PostfixUnaryOperatorExpression) {}\n  static bool classof(const Node *N);\n};\n\n/// <lhs> <operator> <rhs>\n///\n/// For example:\n///   a + b\n///   a bitor 1\n///   a |= b\n///   a and_eq b\nclass BinaryOperatorExpression final : public Expression {\npublic:\n  BinaryOperatorExpression() : Expression(NodeKind::BinaryOperatorExpression) {}\n  static bool classof(const Node *N);\n  Expression *getLhs();\n  Leaf *getOperatorToken();\n  Expression *getRhs();\n};\n\n/// An abstract node for C++ statements, e.g. 'while', 'if', etc.\n/// FIXME: add accessors for semicolon of statements that have it.\nclass Statement : public Tree {\npublic:\n  Statement(NodeKind K) : Tree(K) {}\n  static bool classof(const Node *N);\n};\n\n/// A statement of an unknown kind, i.e. one not currently handled by the syntax\n/// tree.\nclass UnknownStatement final : public Statement {\npublic:\n  UnknownStatement() : Statement(NodeKind::UnknownStatement) {}\n  static bool classof(const Node *N);\n};\n\n/// E.g. 'int a, b = 10;'\nclass DeclarationStatement final : public Statement {\npublic:\n  DeclarationStatement() : Statement(NodeKind::DeclarationStatement) {}\n  static bool classof(const Node *N);\n};\n\n/// The no-op statement, i.e. ';'.\nclass EmptyStatement final : public Statement {\npublic:\n  EmptyStatement() : Statement(NodeKind::EmptyStatement) {}\n  static bool classof(const Node *N);\n};\n\n/// switch (<cond>) <body>\nclass SwitchStatement final : public Statement {\npublic:\n  SwitchStatement() : Statement(NodeKind::SwitchStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getSwitchKeyword();\n  Statement *getBody();\n};\n\n/// case <value>: <body>\nclass CaseStatement final : public Statement {\npublic:\n  CaseStatement() : Statement(NodeKind::CaseStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getCaseKeyword();\n  Expression *getCaseValue();\n  Statement *getBody();\n};\n\n/// default: <body>\nclass DefaultStatement final : public Statement {\npublic:\n  DefaultStatement() : Statement(NodeKind::DefaultStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getDefaultKeyword();\n  Statement *getBody();\n};\n\n/// if (cond) <then-statement> else <else-statement>\n/// FIXME: add condition that models 'expression  or variable declaration'\nclass IfStatement final : public Statement {\npublic:\n  IfStatement() : Statement(NodeKind::IfStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getIfKeyword();\n  Statement *getThenStatement();\n  Leaf *getElseKeyword();\n  Statement *getElseStatement();\n};\n\n/// for (<init>; <cond>; <increment>) <body>\nclass ForStatement final : public Statement {\npublic:\n  ForStatement() : Statement(NodeKind::ForStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getForKeyword();\n  Statement *getBody();\n};\n\n/// while (<cond>) <body>\nclass WhileStatement final : public Statement {\npublic:\n  WhileStatement() : Statement(NodeKind::WhileStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getWhileKeyword();\n  Statement *getBody();\n};\n\n/// continue;\nclass ContinueStatement final : public Statement {\npublic:\n  ContinueStatement() : Statement(NodeKind::ContinueStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getContinueKeyword();\n};\n\n/// break;\nclass BreakStatement final : public Statement {\npublic:\n  BreakStatement() : Statement(NodeKind::BreakStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getBreakKeyword();\n};\n\n/// return <expr>;\n/// return;\nclass ReturnStatement final : public Statement {\npublic:\n  ReturnStatement() : Statement(NodeKind::ReturnStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getReturnKeyword();\n  Expression *getReturnValue();\n};\n\n/// for (<decl> : <init>) <body>\nclass RangeBasedForStatement final : public Statement {\npublic:\n  RangeBasedForStatement() : Statement(NodeKind::RangeBasedForStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getForKeyword();\n  Statement *getBody();\n};\n\n/// Expression in a statement position, e.g. functions calls inside compound\n/// statements or inside a loop body.\nclass ExpressionStatement final : public Statement {\npublic:\n  ExpressionStatement() : Statement(NodeKind::ExpressionStatement) {}\n  static bool classof(const Node *N);\n  Expression *getExpression();\n};\n\n/// { statement1; statement2; \u2026 }\nclass CompoundStatement final : public Statement {\npublic:\n  CompoundStatement() : Statement(NodeKind::CompoundStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getLbrace();\n  /// FIXME: use custom iterator instead of 'vector'.\n  std::vector<Statement *> getStatements();\n  Leaf *getRbrace();\n};\n\n/// A declaration that can appear at the top-level. Note that this does *not*\n/// correspond 1-to-1 to clang::Decl. Syntax trees distinguish between top-level\n/// declarations (e.g. namespace definitions) and declarators (e.g. variables,\n/// typedefs, etc.). Declarators are stored inside SimpleDeclaration.\nclass Declaration : public Tree {\npublic:\n  Declaration(NodeKind K) : Tree(K) {}\n  static bool classof(const Node *N);\n};\n\n/// Declaration of an unknown kind, e.g. not yet supported in syntax trees.\nclass UnknownDeclaration final : public Declaration {\npublic:\n  UnknownDeclaration() : Declaration(NodeKind::UnknownDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// A semicolon in the top-level context. Does not declare anything.\nclass EmptyDeclaration final : public Declaration {\npublic:\n  EmptyDeclaration() : Declaration(NodeKind::EmptyDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// static_assert(<condition>, <message>)\n/// static_assert(<condition>)\nclass StaticAssertDeclaration final : public Declaration {\npublic:\n  StaticAssertDeclaration() : Declaration(NodeKind::StaticAssertDeclaration) {}\n  static bool classof(const Node *N);\n  Expression *getCondition();\n  Expression *getMessage();\n};\n\n/// extern <string-literal> declaration\n/// extern <string-literal> { <decls>  }\nclass LinkageSpecificationDeclaration final : public Declaration {\npublic:\n  LinkageSpecificationDeclaration()\n      : Declaration(NodeKind::LinkageSpecificationDeclaration) {}\n  static bool classof(const Node *N);\n};\n\nclass DeclaratorList final : public List {\npublic:\n  DeclaratorList() : List(NodeKind::DeclaratorList) {}\n  static bool classof(const Node *N);\n  std::vector<SimpleDeclarator *> getDeclarators();\n  std::vector<List::ElementAndDelimiter<syntax::SimpleDeclarator>>\n  getDeclaratorsAndCommas();\n};\n\n/// Groups multiple declarators (e.g. variables, typedefs, etc.) together. All\n/// grouped declarators share the same declaration specifiers (e.g. 'int' or\n/// 'typedef').\nclass SimpleDeclaration final : public Declaration {\npublic:\n  SimpleDeclaration() : Declaration(NodeKind::SimpleDeclaration) {}\n  static bool classof(const Node *N);\n  /// FIXME: use custom iterator instead of 'vector'.\n  std::vector<SimpleDeclarator *> getDeclarators();\n};\n\n/// template <template-parameters> <declaration>\nclass TemplateDeclaration final : public Declaration {\npublic:\n  TemplateDeclaration() : Declaration(NodeKind::TemplateDeclaration) {}\n  static bool classof(const Node *N);\n  Leaf *getTemplateKeyword();\n  Declaration *getDeclaration();\n};\n\n/// template <declaration>\n/// Examples:\n///     template struct X<int>\n///     template void foo<int>()\n///     template int var<double>\nclass ExplicitTemplateInstantiation final : public Declaration {\npublic:\n  ExplicitTemplateInstantiation()\n      : Declaration(NodeKind::ExplicitTemplateInstantiation) {}\n  static bool classof(const Node *N);\n  Leaf *getTemplateKeyword();\n  Leaf *getExternKeyword();\n  Declaration *getDeclaration();\n};\n\n/// namespace <name> { <decls> }\nclass NamespaceDefinition final : public Declaration {\npublic:\n  NamespaceDefinition() : Declaration(NodeKind::NamespaceDefinition) {}\n  static bool classof(const Node *N);\n};\n\n/// namespace <name> = <namespace-reference>\nclass NamespaceAliasDefinition final : public Declaration {\npublic:\n  NamespaceAliasDefinition()\n      : Declaration(NodeKind::NamespaceAliasDefinition) {}\n  static bool classof(const Node *N);\n};\n\n/// using namespace <name>\nclass UsingNamespaceDirective final : public Declaration {\npublic:\n  UsingNamespaceDirective() : Declaration(NodeKind::UsingNamespaceDirective) {}\n  static bool classof(const Node *N);\n};\n\n/// using <scope>::<name>\n/// using typename <scope>::<name>\nclass UsingDeclaration final : public Declaration {\npublic:\n  UsingDeclaration() : Declaration(NodeKind::UsingDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// using <name> = <type>\nclass TypeAliasDeclaration final : public Declaration {\npublic:\n  TypeAliasDeclaration() : Declaration(NodeKind::TypeAliasDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// Covers a name, an initializer and a part of the type outside declaration\n/// specifiers. Examples are:\n///     `*a` in `int *a`\n///     `a[10]` in `int a[10]`\n///     `*a = nullptr` in `int *a = nullptr`\n/// Declarators can be unnamed too:\n///     `**` in `new int**`\n///     `* = nullptr` in `void foo(int* = nullptr)`\n/// Most declarators you encounter are instances of SimpleDeclarator. They may\n/// contain an inner declarator inside parentheses, we represent it as\n/// ParenDeclarator. E.g.\n///     `(*a)` in `int (*a) = 10`\nclass Declarator : public Tree {\npublic:\n  Declarator(NodeKind K) : Tree(K) {}\n  static bool classof(const Node *N);\n};\n\n/// A top-level declarator without parentheses. See comment of Declarator for\n/// more details.\nclass SimpleDeclarator final : public Declarator {\npublic:\n  SimpleDeclarator() : Declarator(NodeKind::SimpleDeclarator) {}\n  static bool classof(const Node *N);\n};\n\n/// Declarator inside parentheses.\n/// E.g. `(***a)` from `int (***a) = nullptr;`\n/// See comment of Declarator for more details.\nclass ParenDeclarator final : public Declarator {\npublic:\n  ParenDeclarator() : Declarator(NodeKind::ParenDeclarator) {}\n  static bool classof(const Node *N);\n  Leaf *getLparen();\n  Leaf *getRparen();\n};\n\n/// Array size specified inside a declarator.\n/// E.g:\n///   `[10]` in `int a[10];`\n///   `[static 10]` in `void f(int xs[static 10]);`\nclass ArraySubscript final : public Tree {\npublic:\n  ArraySubscript() : Tree(NodeKind::ArraySubscript) {}\n  static bool classof(const Node *N);\n  // TODO: add an accessor for the \"static\" keyword.\n  Leaf *getLbracket();\n  Expression *getSize();\n  Leaf *getRbracket();\n};\n\n/// Trailing return type after the parameter list, including the arrow token.\n/// E.g. `-> int***`.\nclass TrailingReturnType final : public Tree {\npublic:\n  TrailingReturnType() : Tree(NodeKind::TrailingReturnType) {}\n  static bool classof(const Node *N);\n  // TODO: add accessors for specifiers.\n  Leaf *getArrowToken();\n  // FIXME: This should be a `type-id` following the grammar. Fix this once we\n  // have a representation of `type-id`s.\n  SimpleDeclarator *getDeclarator();\n};\n\n/// Models a `parameter-declaration-list` which appears within\n/// `parameters-and-qualifiers`. See C++ [dcl.fct]\nclass ParameterDeclarationList final : public List {\npublic:\n  ParameterDeclarationList() : List(NodeKind::ParameterDeclarationList) {}\n  static bool classof(const Node *N);\n  std::vector<SimpleDeclaration *> getParameterDeclarations();\n  std::vector<List::ElementAndDelimiter<syntax::SimpleDeclaration>>\n  getParametersAndCommas();\n};\n\n/// Parameter list for a function type and a trailing return type, if the\n/// function has one.\n/// E.g.:\n///  `(int a) volatile ` in `int foo(int a) volatile;`\n///  `(int a) &&` in `int foo(int a) &&;`\n///  `() -> int` in `auto foo() -> int;`\n///  `() const` in `int foo() const;`\n///  `() noexcept` in `int foo() noexcept;`\n///  `() throw()` in `int foo() throw();`\n///\n/// (!) override doesn't belong here.\nclass ParametersAndQualifiers final : public Tree {\npublic:\n  ParametersAndQualifiers() : Tree(NodeKind::ParametersAndQualifiers) {}\n  static bool classof(const Node *N);\n  Leaf *getLparen();\n  ParameterDeclarationList *getParameters();\n  Leaf *getRparen();\n  TrailingReturnType *getTrailingReturn();\n};\n\n/// Member pointer inside a declarator\n/// E.g. `X::*` in `int X::* a = 0;`\nclass MemberPointer final : public Tree {\npublic:\n  MemberPointer() : Tree(NodeKind::MemberPointer) {}\n  static bool classof(const Node *N);\n};\n\n#define CONCRETE_NODE(Kind, Base)                                              \\\n  inline bool Kind::classof(const Node *N) {                                   \\\n    return N->getKind() == NodeKind::Kind;                                     \\\n  }\n#define ABSTRACT_NODE(Kind, Base, First, Last)                                 \\\n  inline bool Kind::classof(const Node *N) {                                   \\\n    return N->getKind() >= NodeKind::First && N->getKind() <= NodeKind::Last;  \\\n  }\n#include \"clang/Tooling/Syntax/Nodes.inc\"\n\n} // namespace syntax\n} // namespace clang\n#endif\n"}, "78": {"id": 78, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "content": "//===- Tree.h - structure of the syntax tree ------------------*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Defines the basic structure of the syntax tree. There are two kinds of nodes:\n//   - leaf nodes correspond to a token in the expanded token stream,\n//   - tree nodes correspond to language grammar constructs.\n//\n// The tree is initially built from an AST. Each node of a newly built tree\n// covers a continous subrange of expanded tokens (i.e. tokens after\n// preprocessing), the specific tokens coverered are stored in the leaf nodes of\n// a tree. A post-order traversal of a tree will visit leaf nodes in an order\n// corresponding the original order of expanded tokens.\n//\n// This is still work in progress and highly experimental, we leave room for\n// ourselves to completely change the design and/or implementation.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n#define LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cstdint>\n#include <iterator>\n\nnamespace clang {\nnamespace syntax {\n\n/// A memory arena for syntax trees. Also tracks the underlying token buffers,\n/// source manager, etc.\nclass Arena {\npublic:\n  Arena(SourceManager &SourceMgr, const LangOptions &LangOpts,\n        const TokenBuffer &Tokens);\n\n  const SourceManager &getSourceManager() const { return SourceMgr; }\n  const LangOptions &getLangOptions() const { return LangOpts; }\n\n  const TokenBuffer &getTokenBuffer() const;\n  llvm::BumpPtrAllocator &getAllocator() { return Allocator; }\n\nprivate:\n  /// Add \\p Buffer to the underlying source manager, tokenize it and store the\n  /// resulting tokens. Used exclusively in `FactoryImpl` to materialize tokens\n  /// that were not written in user code.\n  std::pair<FileID, ArrayRef<Token>>\n  lexBuffer(std::unique_ptr<llvm::MemoryBuffer> Buffer);\n  friend class FactoryImpl;\n\nprivate:\n  SourceManager &SourceMgr;\n  const LangOptions &LangOpts;\n  const TokenBuffer &Tokens;\n  /// IDs and storage for additional tokenized files.\n  llvm::DenseMap<FileID, std::vector<Token>> ExtraTokens;\n  /// Keeps all the allocated nodes and their intermediate data structures.\n  llvm::BumpPtrAllocator Allocator;\n};\n\nclass Tree;\nclass TreeBuilder;\nclass FactoryImpl;\nclass MutationsImpl;\n\nenum class NodeKind : uint16_t;\nenum class NodeRole : uint8_t;\n\n/// A node in a syntax tree. Each node is either a Leaf (representing tokens) or\n/// a Tree (representing language constructrs).\nclass Node {\nprotected:\n  /// Newly created nodes are detached from a tree, parent and sibling links are\n  /// set when the node is added as a child to another one.\n  Node(NodeKind Kind);\n  /// Nodes are allocated on Arenas; the destructor is never called.\n  ~Node() = default;\n\npublic:\n  /// Nodes cannot simply be copied without violating tree invariants.\n  Node(const Node &) = delete;\n  Node &operator=(const Node &) = delete;\n  /// Idiomatically, nodes are allocated on an Arena and never moved.\n  Node(Node &&) = delete;\n  Node &operator=(Node &&) = delete;\n\n  NodeKind getKind() const { return static_cast<NodeKind>(Kind); }\n  NodeRole getRole() const { return static_cast<NodeRole>(Role); }\n\n  /// Whether the node is detached from a tree, i.e. does not have a parent.\n  bool isDetached() const;\n  /// Whether the node was created from the AST backed by the source code\n  /// rather than added later through mutation APIs or created with factory\n  /// functions.\n  /// When this flag is true, all subtrees are also original.\n  /// This flag is set to false on any modifications to the node or any of its\n  /// subtrees, even if this simply involves swapping existing subtrees.\n  bool isOriginal() const { return Original; }\n  /// If this function return false, the tree cannot be modified because there\n  /// is no reasonable way to produce the corresponding textual replacements.\n  /// This can happen when the node crosses macro expansion boundaries.\n  ///\n  /// Note that even if the node is not modifiable, its child nodes can be\n  /// modifiable.\n  bool canModify() const { return CanModify; }\n\n  const Tree *getParent() const { return Parent; }\n  Tree *getParent() { return Parent; }\n\n  const Node *getNextSibling() const { return NextSibling; }\n  Node *getNextSibling() { return NextSibling; }\n  const Node *getPreviousSibling() const { return PreviousSibling; }\n  Node *getPreviousSibling() { return PreviousSibling; }\n\n  /// Dumps the structure of a subtree. For debugging and testing purposes.\n  std::string dump(const SourceManager &SM) const;\n  /// Dumps the tokens forming this subtree.\n  std::string dumpTokens(const SourceManager &SM) const;\n\n  /// Asserts invariants on this node of the tree and its immediate children.\n  /// Will not recurse into the subtree. No-op if NDEBUG is set.\n  void assertInvariants() const;\n  /// Runs checkInvariants on all nodes in the subtree. No-op if NDEBUG is set.\n  void assertInvariantsRecursive() const;\n\nprivate:\n  // Tree is allowed to change the Parent link and Role.\n  friend class Tree;\n  // TreeBuilder is allowed to set the Original and CanModify flags.\n  friend class TreeBuilder;\n  // MutationsImpl sets roles and CanModify flag.\n  friend class MutationsImpl;\n  // FactoryImpl sets CanModify flag.\n  friend class FactoryImpl;\n\n  void setRole(NodeRole NR);\n\n  Tree *Parent;\n  Node *NextSibling;\n  Node *PreviousSibling;\n  unsigned Kind : 16;\n  unsigned Role : 8;\n  unsigned Original : 1;\n  unsigned CanModify : 1;\n};\n\n/// A leaf node points to a single token inside the expanded token stream.\nclass Leaf final : public Node {\npublic:\n  Leaf(const Token *T);\n  static bool classof(const Node *N);\n\n  const Token *getToken() const { return Tok; }\n\nprivate:\n  const Token *Tok;\n};\n\n/// A node that has children and represents a syntactic language construct.\nclass Tree : public Node {\n  /// Iterator over children (common base for const/non-const).\n  /// Not invalidated by tree mutations (holds a stable node pointer).\n  template <typename DerivedT, typename NodeT>\n  class ChildIteratorBase\n      : public llvm::iterator_facade_base<DerivedT, std::forward_iterator_tag,\n                                          NodeT> {\n  protected:\n    NodeT *N = nullptr;\n    using Base = ChildIteratorBase;\n\n  public:\n    ChildIteratorBase() = default;\n    explicit ChildIteratorBase(NodeT *N) : N(N) {}\n\n    bool operator==(const DerivedT &O) const { return O.N == N; }\n    NodeT &operator*() const { return *N; }\n    DerivedT &operator++() {\n      N = N->getNextSibling();\n      return *static_cast<DerivedT *>(this);\n    }\n\n    /// Truthy if valid (not past-the-end).\n    /// This allows: if (auto It = find_if(N.children(), ...) )\n    explicit operator bool() const { return N != nullptr; }\n    /// The element, or nullptr if past-the-end.\n    NodeT *asPointer() const { return N; }\n  };\n\npublic:\n  static bool classof(const Node *N);\n\n  Node *getFirstChild() { return FirstChild; }\n  const Node *getFirstChild() const { return FirstChild; }\n  Node *getLastChild() { return LastChild; }\n  const Node *getLastChild() const { return LastChild; }\n\n  const Leaf *findFirstLeaf() const;\n  Leaf *findFirstLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findFirstLeaf());\n  }\n\n  const Leaf *findLastLeaf() const;\n  Leaf *findLastLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findLastLeaf());\n  }\n\n  /// child_iterator is not invalidated by mutations.\n  struct ChildIterator : ChildIteratorBase<ChildIterator, Node> {\n    using Base::ChildIteratorBase;\n  };\n  struct ConstChildIterator\n      : ChildIteratorBase<ConstChildIterator, const Node> {\n    using Base::ChildIteratorBase;\n    ConstChildIterator() = default;\n    ConstChildIterator(const ChildIterator &I) : Base(I.asPointer()) {}\n  };\n\n  llvm::iterator_range<ChildIterator> getChildren() {\n    return {ChildIterator(getFirstChild()), ChildIterator()};\n  }\n  llvm::iterator_range<ConstChildIterator> getChildren() const {\n    return {ConstChildIterator(getFirstChild()), ConstChildIterator()};\n  }\n\n  /// Find the first node with a corresponding role.\n  const Node *findChild(NodeRole R) const;\n  Node *findChild(NodeRole R) {\n    return const_cast<Node *>(const_cast<const Tree *>(this)->findChild(R));\n  }\n\nprotected:\n  using Node::Node;\n\nprivate:\n  /// Append \\p Child to the list of children and sets the parent pointer.\n  /// A very low-level operation that does not check any invariants, only used\n  /// by TreeBuilder and FactoryImpl.\n  /// EXPECTS: Role != Detached.\n  void appendChildLowLevel(Node *Child, NodeRole Role);\n  /// Similar but prepends.\n  void prependChildLowLevel(Node *Child, NodeRole Role);\n\n  /// Like the previous overloads, but does not set role for \\p Child.\n  /// EXPECTS: Child->Role != Detached\n  void appendChildLowLevel(Node *Child);\n  void prependChildLowLevel(Node *Child);\n  friend class TreeBuilder;\n  friend class FactoryImpl;\n\n  /// Replace a range of children [Begin, End) with a list of\n  /// new nodes starting at \\p New.\n  /// Only used by MutationsImpl to implement higher-level mutation operations.\n  /// (!) \\p New can be null to model removal of the child range.\n  /// (!) \\p End can be null to model one past the end.\n  /// (!) \\p Begin can be null to model an append.\n  void replaceChildRangeLowLevel(Node *Begin, Node *End, Node *New);\n  friend class MutationsImpl;\n\n  Node *FirstChild = nullptr;\n  Node *LastChild = nullptr;\n};\n\n// Provide missing non_const == const overload.\n// iterator_facade_base requires == to be a member, but implicit conversions\n// don't work on the LHS of a member operator.\ninline bool operator==(const Tree::ConstChildIterator &A,\n                       const Tree::ConstChildIterator &B) {\n  return A.operator==(B);\n}\n\n/// A list of Elements separated or terminated by a fixed token.\n///\n/// This type models the following grammar construct:\n/// delimited-list(element, delimiter, termination, canBeEmpty)\nclass List : public Tree {\npublic:\n  template <typename Element> struct ElementAndDelimiter {\n    Element *element;\n    Leaf *delimiter;\n  };\n\n  enum class TerminationKind {\n    Terminated,\n    MaybeTerminated,\n    Separated,\n  };\n\n  using Tree::Tree;\n  static bool classof(const Node *N);\n  /// Returns the elements and corresponding delimiters. Missing elements\n  /// and delimiters are represented as null pointers.\n  ///\n  /// For example, in a separated list:\n  /// \"a, b, c\"  <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (\"c\" , null)]\n  /// \"a,  , c\"  <=> [(\"a\" , \",\"), (null, \",\" ), (\"c\" , null)]\n  /// \"a, b  c\"  <=> [(\"a\" , \",\"), (\"b\" , null), (\"c\" , null)]\n  /// \"a, b,\"    <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (null, null)]\n  ///\n  /// In a terminated or maybe-terminated list:\n  /// \"a; b; c;\" <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , \";\" )]\n  /// \"a;  ; c;\" <=> [(\"a\" , \";\"), (null, \";\" ), (\"c\" , \";\" )]\n  /// \"a; b  c;\" <=> [(\"a\" , \";\"), (\"b\" , null), (\"c\" , \";\" )]\n  /// \"a; b; c\"  <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , null)]\n  std::vector<ElementAndDelimiter<Node>> getElementsAsNodesAndDelimiters();\n\n  /// Returns the elements of the list. Missing elements are represented\n  /// as null pointers in the same way as in the return value of\n  /// `getElementsAsNodesAndDelimiters()`.\n  std::vector<Node *> getElementsAsNodes();\n\n  // These can't be implemented with the information we have!\n\n  /// Returns the appropriate delimiter for this list.\n  ///\n  /// Useful for discovering the correct delimiter to use when adding\n  /// elements to empty or one-element lists.\n  clang::tok::TokenKind getDelimiterTokenKind() const;\n\n  TerminationKind getTerminationKind() const;\n\n  /// Whether this list can be empty in syntactically and semantically correct\n  /// code.\n  ///\n  /// This list may be empty when the source code has errors even if\n  /// canBeEmpty() returns false.\n  bool canBeEmpty() const;\n};\n\n} // namespace syntax\n} // namespace clang\n\n#endif\n"}, "79": {"id": 79, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "content": "//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the fixed point number interface.\n/// This is a class for abstracting various operations performed on fixed point\n/// types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFIXEDPOINT_H\n#define LLVM_ADT_APFIXEDPOINT_H\n\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nclass APFloat;\nstruct fltSemantics;\n\n/// The fixed point semantics work similarly to fltSemantics. The width\n/// specifies the whole bit width of the underlying scaled integer (with padding\n/// if any). The scale represents the number of fractional bits in this type.\n/// When HasUnsignedPadding is true and this type is unsigned, the first bit\n/// in the value this represents is treated as padding.\nclass FixedPointSemantics {\npublic:\n  FixedPointSemantics(unsigned Width, unsigned Scale, bool IsSigned,\n                      bool IsSaturated, bool HasUnsignedPadding)\n      : Width(Width), Scale(Scale), IsSigned(IsSigned),\n        IsSaturated(IsSaturated), HasUnsignedPadding(HasUnsignedPadding) {\n    assert(Width >= Scale && \"Not enough room for the scale\");\n    assert(!(IsSigned && HasUnsignedPadding) &&\n           \"Cannot have unsigned padding on a signed type.\");\n  }\n\n  unsigned getWidth() const { return Width; }\n  unsigned getScale() const { return Scale; }\n  bool isSigned() const { return IsSigned; }\n  bool isSaturated() const { return IsSaturated; }\n  bool hasUnsignedPadding() const { return HasUnsignedPadding; }\n\n  void setSaturated(bool Saturated) { IsSaturated = Saturated; }\n\n  /// Return the number of integral bits represented by these semantics. These\n  /// are separate from the fractional bits and do not include the sign or\n  /// padding bit.\n  unsigned getIntegralBits() const {\n    if (IsSigned || (!IsSigned && HasUnsignedPadding))\n      return Width - Scale - 1;\n    else\n      return Width - Scale;\n  }\n\n  /// Return the FixedPointSemantics that allows for calculating the full\n  /// precision semantic that can precisely represent the precision and ranges\n  /// of both input values. This does not compute the resulting semantics for a\n  /// given binary operation.\n  FixedPointSemantics\n  getCommonSemantics(const FixedPointSemantics &Other) const;\n\n  /// Returns true if this fixed-point semantic with its value bits interpreted\n  /// as an integer can fit in the given floating point semantic without\n  /// overflowing to infinity.\n  /// For example, a signed 8-bit fixed-point semantic has a maximum and\n  /// minimum integer representation of 127 and -128, respectively. If both of\n  /// these values can be represented (possibly inexactly) in the floating\n  /// point semantic without overflowing, this returns true.\n  bool fitsInFloatSemantics(const fltSemantics &FloatSema) const;\n\n  /// Return the FixedPointSemantics for an integer type.\n  static FixedPointSemantics GetIntegerSemantics(unsigned Width,\n                                                 bool IsSigned) {\n    return FixedPointSemantics(Width, /*Scale=*/0, IsSigned,\n                               /*IsSaturated=*/false,\n                               /*HasUnsignedPadding=*/false);\n  }\n\nprivate:\n  unsigned Width          : 16;\n  unsigned Scale          : 13;\n  unsigned IsSigned       : 1;\n  unsigned IsSaturated    : 1;\n  unsigned HasUnsignedPadding : 1;\n};\n\n/// The APFixedPoint class works similarly to APInt/APSInt in that it is a\n/// functional replacement for a scaled integer. It is meant to replicate the\n/// fixed point types proposed in ISO/IEC JTC1 SC22 WG14 N1169. The class carries\n/// info about the fixed point type's width, sign, scale, and saturation, and\n/// provides different operations that would normally be performed on fixed point\n/// types.\nclass APFixedPoint {\npublic:\n  APFixedPoint(const APInt &Val, const FixedPointSemantics &Sema)\n      : Val(Val, !Sema.isSigned()), Sema(Sema) {\n    assert(Val.getBitWidth() == Sema.getWidth() &&\n           \"The value should have a bit width that matches the Sema width\");\n  }\n\n  APFixedPoint(uint64_t Val, const FixedPointSemantics &Sema)\n      : APFixedPoint(APInt(Sema.getWidth(), Val, Sema.isSigned()), Sema) {}\n\n  // Zero initialization.\n  APFixedPoint(const FixedPointSemantics &Sema) : APFixedPoint(0, Sema) {}\n\n  APSInt getValue() const { return APSInt(Val, !Sema.isSigned()); }\n  inline unsigned getWidth() const { return Sema.getWidth(); }\n  inline unsigned getScale() const { return Sema.getScale(); }\n  inline bool isSaturated() const { return Sema.isSaturated(); }\n  inline bool isSigned() const { return Sema.isSigned(); }\n  inline bool hasPadding() const { return Sema.hasUnsignedPadding(); }\n  FixedPointSemantics getSemantics() const { return Sema; }\n\n  bool getBoolValue() const { return Val.getBoolValue(); }\n\n  // Convert this number to match the semantics provided. If the overflow\n  // parameter is provided, set this value to true or false to indicate if this\n  // operation results in an overflow.\n  APFixedPoint convert(const FixedPointSemantics &DstSema,\n                       bool *Overflow = nullptr) const;\n\n  // Perform binary operations on a fixed point type. The resulting fixed point\n  // value will be in the common, full precision semantics that can represent\n  // the precision and ranges of both input values. See convert() for an\n  // explanation of the Overflow parameter.\n  APFixedPoint add(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint sub(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint mul(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint div(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n\n  // Perform shift operations on a fixed point type. Unlike the other binary\n  // operations, the resulting fixed point value will be in the original\n  // semantic.\n  APFixedPoint shl(unsigned Amt, bool *Overflow = nullptr) const;\n  APFixedPoint shr(unsigned Amt, bool *Overflow = nullptr) const {\n    // Right shift cannot overflow.\n    if (Overflow)\n      *Overflow = false;\n    return APFixedPoint(Val >> Amt, Sema);\n  }\n\n  /// Perform a unary negation (-X) on this fixed point type, taking into\n  /// account saturation if applicable.\n  APFixedPoint negate(bool *Overflow = nullptr) const;\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. (-2.5k -> -2)\n  APSInt getIntPart() const {\n    if (Val < 0 && Val != -Val) // Cover the case when we have the min val\n      return -(-Val >> getScale());\n    else\n      return Val >> getScale();\n  }\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. The value is stored into an APSInt with the provided width and sign.\n  /// If the overflow parameter is provided, and the integral value is not able\n  /// to be fully stored in the provided width and sign, the overflow parameter\n  /// is set to true.\n  APSInt convertToInt(unsigned DstWidth, bool DstSign,\n                      bool *Overflow = nullptr) const;\n\n  /// Convert this fixed point number to a floating point value with the\n  /// provided semantics.\n  APFloat convertToFloat(const fltSemantics &FloatSema) const;\n\n  void toString(SmallVectorImpl<char> &Str) const;\n  std::string toString() const {\n    SmallString<40> S;\n    toString(S);\n    return std::string(S.str());\n  }\n\n  // If LHS > RHS, return 1. If LHS == RHS, return 0. If LHS < RHS, return -1.\n  int compare(const APFixedPoint &Other) const;\n  bool operator==(const APFixedPoint &Other) const {\n    return compare(Other) == 0;\n  }\n  bool operator!=(const APFixedPoint &Other) const {\n    return compare(Other) != 0;\n  }\n  bool operator>(const APFixedPoint &Other) const { return compare(Other) > 0; }\n  bool operator<(const APFixedPoint &Other) const { return compare(Other) < 0; }\n  bool operator>=(const APFixedPoint &Other) const {\n    return compare(Other) >= 0;\n  }\n  bool operator<=(const APFixedPoint &Other) const {\n    return compare(Other) <= 0;\n  }\n\n  static APFixedPoint getMax(const FixedPointSemantics &Sema);\n  static APFixedPoint getMin(const FixedPointSemantics &Sema);\n\n  /// Given a floating point semantic, return the next floating point semantic\n  /// with a larger exponent and larger or equal mantissa.\n  static const fltSemantics *promoteFloatSemantics(const fltSemantics *S);\n\n  /// Create an APFixedPoint with a value equal to that of the provided integer,\n  /// and in the same semantics as the provided target semantics. If the value\n  /// is not able to fit in the specified fixed point semantics, and the\n  /// overflow parameter is provided, it is set to true.\n  static APFixedPoint getFromIntValue(const APSInt &Value,\n                                      const FixedPointSemantics &DstFXSema,\n                                      bool *Overflow = nullptr);\n\n  /// Create an APFixedPoint with a value equal to that of the provided\n  /// floating point value, in the provided target semantics. If the value is\n  /// not able to fit in the specified fixed point semantics and the overflow\n  /// parameter is specified, it is set to true.\n  /// For NaN, the Overflow flag is always set. For +inf and -inf, if the\n  /// semantic is saturating, the value saturates. Otherwise, the Overflow flag\n  /// is set.\n  static APFixedPoint getFromFloatValue(const APFloat &Value,\n                                        const FixedPointSemantics &DstFXSema,\n                                        bool *Overflow = nullptr);\n\nprivate:\n  APSInt Val;\n  FixedPointSemantics Sema;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APFixedPoint &FX) {\n  OS << FX.toString();\n  return OS;\n}\n\n} // namespace llvm\n\n#endif\n"}, "80": {"id": 80, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "content": "//===- llvm/ADT/APFloat.h - Arbitrary Precision Floating Point ---*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief\n/// This file declares a class to represent arbitrary precision floating point\n/// values and provide a variety of arithmetic operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFLOAT_H\n#define LLVM_ADT_APFLOAT_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <memory>\n\n#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \\\n  do {                                                                         \\\n    if (usesLayout<IEEEFloat>(getSemantics()))                                 \\\n      return U.IEEE.METHOD_CALL;                                               \\\n    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \\\n      return U.Double.METHOD_CALL;                                             \\\n    llvm_unreachable(\"Unexpected semantics\");                                  \\\n  } while (false)\n\nnamespace llvm {\n\nstruct fltSemantics;\nclass APSInt;\nclass StringRef;\nclass APFloat;\nclass raw_ostream;\n\ntemplate <typename T> class Expected;\ntemplate <typename T> class SmallVectorImpl;\n\n/// Enum that represents what fraction of the LSB truncated bits of an fp number\n/// represent.\n///\n/// This essentially combines the roles of guard and sticky bits.\nenum lostFraction { // Example of truncated bits:\n  lfExactlyZero,    // 000000\n  lfLessThanHalf,   // 0xxxxx  x's not all zero\n  lfExactlyHalf,    // 100000\n  lfMoreThanHalf    // 1xxxxx  x's not all zero\n};\n\n/// A self-contained host- and target-independent arbitrary-precision\n/// floating-point software implementation.\n///\n/// APFloat uses bignum integer arithmetic as provided by static functions in\n/// the APInt class.  The library will work with bignum integers whose parts are\n/// any unsigned type at least 16 bits wide, but 64 bits is recommended.\n///\n/// Written for clarity rather than speed, in particular with a view to use in\n/// the front-end of a cross compiler so that target arithmetic can be correctly\n/// performed on the host.  Performance should nonetheless be reasonable,\n/// particularly for its intended use.  It may be useful as a base\n/// implementation for a run-time library during development of a faster\n/// target-specific one.\n///\n/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n/// implemented operations.  Currently implemented operations are add, subtract,\n/// multiply, divide, fused-multiply-add, conversion-to-float,\n/// conversion-to-integer and conversion-from-integer.  New rounding modes\n/// (e.g. away from zero) can be added with three or four lines of code.\n///\n/// Four formats are built-in: IEEE single precision, double precision,\n/// quadruple precision, and x87 80-bit extended double (when operating with\n/// full extended precision).  Adding a new format that obeys IEEE semantics\n/// only requires adding two lines of code: a declaration and definition of the\n/// format.\n///\n/// All operations return the status of that operation as an exception bit-mask,\n/// so multiple operations can be done consecutively with their results or-ed\n/// together.  The returned status can be useful for compiler diagnostics; e.g.,\n/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n/// and compiler optimizers can determine what exceptions would be raised by\n/// folding operations and optimize, or perhaps not optimize, accordingly.\n///\n/// At present, underflow tininess is detected after rounding; it should be\n/// straight forward to add support for the before-rounding case too.\n///\n/// The library reads hexadecimal floating point numbers as per C99, and\n/// correctly rounds if necessary according to the specified rounding mode.\n/// Syntax is required to have been validated by the caller.  It also converts\n/// floating point numbers to hexadecimal text as per the C99 %a and %A\n/// conversions.  The output precision (or alternatively the natural minimal\n/// precision) can be specified; if the requested precision is less than the\n/// natural precision the output is correctly rounded for the specified rounding\n/// mode.\n///\n/// It also reads decimal floating point numbers and correctly rounds according\n/// to the specified rounding mode.\n///\n/// Conversion to decimal text is not currently implemented.\n///\n/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n/// signed exponent, and the significand as an array of integer parts.  After\n/// normalization of a number of precision P the exponent is within the range of\n/// the format, and if the number is not denormal the P-th bit of the\n/// significand is set as an explicit integer bit.  For denormals the most\n/// significant bit is shifted right so that the exponent is maintained at the\n/// format's minimum, so that the smallest denormal has just the least\n/// significant bit of the significand set.  The sign of zeroes and infinities\n/// is significant; the exponent and significand of such numbers is not stored,\n/// but has a known implicit (deterministic) value: 0 for the significands, 0\n/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and\n/// significand are deterministic, although not really meaningful, and preserved\n/// in non-conversion operations.  The exponent is implicitly all 1 bits.\n///\n/// APFloat does not provide any exception handling beyond default exception\n/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n/// by encoding Signaling NaNs with the first bit of its trailing significand as\n/// 0.\n///\n/// TODO\n/// ====\n///\n/// Some features that may or may not be worth adding:\n///\n/// Binary to decimal conversion (hard).\n///\n/// Optional ability to detect underflow tininess before rounding.\n///\n/// New formats: x87 in single and double precision mode (IEEE apart from\n/// extended exponent range) (hard).\n///\n/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.\n///\n\n// This is the common type definitions shared by APFloat and its internal\n// implementation classes. This struct should not define any non-static data\n// members.\nstruct APFloatBase {\n  typedef APInt::WordType integerPart;\n  static constexpr unsigned integerPartWidth = APInt::APINT_BITS_PER_WORD;\n\n  /// A signed type to represent a floating point numbers unbiased exponent.\n  typedef int32_t ExponentType;\n\n  /// \\name Floating Point Semantics.\n  /// @{\n  enum Semantics {\n    S_IEEEhalf,\n    S_BFloat,\n    S_IEEEsingle,\n    S_IEEEdouble,\n    S_x87DoubleExtended,\n    S_IEEEquad,\n    S_PPCDoubleDouble\n  };\n\n  static const llvm::fltSemantics &EnumToSemantics(Semantics S);\n  static Semantics SemanticsToEnum(const llvm::fltSemantics &Sem);\n\n  static const fltSemantics &IEEEhalf() LLVM_READNONE;\n  static const fltSemantics &BFloat() LLVM_READNONE;\n  static const fltSemantics &IEEEsingle() LLVM_READNONE;\n  static const fltSemantics &IEEEdouble() LLVM_READNONE;\n  static const fltSemantics &IEEEquad() LLVM_READNONE;\n  static const fltSemantics &PPCDoubleDouble() LLVM_READNONE;\n  static const fltSemantics &x87DoubleExtended() LLVM_READNONE;\n\n  /// A Pseudo fltsemantic used to construct APFloats that cannot conflict with\n  /// anything real.\n  static const fltSemantics &Bogus() LLVM_READNONE;\n\n  /// @}\n\n  /// IEEE-754R 5.11: Floating Point Comparison Relations.\n  enum cmpResult {\n    cmpLessThan,\n    cmpEqual,\n    cmpGreaterThan,\n    cmpUnordered\n  };\n\n  /// IEEE-754R 4.3: Rounding-direction attributes.\n  using roundingMode = llvm::RoundingMode;\n\n  static constexpr roundingMode rmNearestTiesToEven =\n                                                RoundingMode::NearestTiesToEven;\n  static constexpr roundingMode rmTowardPositive = RoundingMode::TowardPositive;\n  static constexpr roundingMode rmTowardNegative = RoundingMode::TowardNegative;\n  static constexpr roundingMode rmTowardZero     = RoundingMode::TowardZero;\n  static constexpr roundingMode rmNearestTiesToAway =\n                                                RoundingMode::NearestTiesToAway;\n\n  /// IEEE-754R 7: Default exception handling.\n  ///\n  /// opUnderflow or opOverflow are always returned or-ed with opInexact.\n  ///\n  /// APFloat models this behavior specified by IEEE-754:\n  ///   \"For operations producing results in floating-point format, the default\n  ///    result of an operation that signals the invalid operation exception\n  ///    shall be a quiet NaN.\"\n  enum opStatus {\n    opOK = 0x00,\n    opInvalidOp = 0x01,\n    opDivByZero = 0x02,\n    opOverflow = 0x04,\n    opUnderflow = 0x08,\n    opInexact = 0x10\n  };\n\n  /// Category of internally-represented number.\n  enum fltCategory {\n    fcInfinity,\n    fcNaN,\n    fcNormal,\n    fcZero\n  };\n\n  /// Convenience enum used to construct an uninitialized APFloat.\n  enum uninitializedTag {\n    uninitialized\n  };\n\n  /// Enumeration of \\c ilogb error results.\n  enum IlogbErrorKinds {\n    IEK_Zero = INT_MIN + 1,\n    IEK_NaN = INT_MIN,\n    IEK_Inf = INT_MAX\n  };\n\n  static unsigned int semanticsPrecision(const fltSemantics &);\n  static ExponentType semanticsMinExponent(const fltSemantics &);\n  static ExponentType semanticsMaxExponent(const fltSemantics &);\n  static unsigned int semanticsSizeInBits(const fltSemantics &);\n\n  /// Returns the size of the floating point number (in bits) in the given\n  /// semantics.\n  static unsigned getSizeInBits(const fltSemantics &Sem);\n};\n\nnamespace detail {\n\nclass IEEEFloat final : public APFloatBase {\npublic:\n  /// \\name Constructors\n  /// @{\n\n  IEEEFloat(const fltSemantics &); // Default construct to +0.0\n  IEEEFloat(const fltSemantics &, integerPart);\n  IEEEFloat(const fltSemantics &, uninitializedTag);\n  IEEEFloat(const fltSemantics &, const APInt &);\n  explicit IEEEFloat(double d);\n  explicit IEEEFloat(float f);\n  IEEEFloat(const IEEEFloat &);\n  IEEEFloat(IEEEFloat &&);\n  ~IEEEFloat();\n\n  /// @}\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return partCount() > 1; }\n\n  /// \\name Convenience \"constructors\"\n  /// @{\n\n  /// @}\n\n  /// \\name Arithmetic\n  /// @{\n\n  opStatus add(const IEEEFloat &, roundingMode);\n  opStatus subtract(const IEEEFloat &, roundingMode);\n  opStatus multiply(const IEEEFloat &, roundingMode);\n  opStatus divide(const IEEEFloat &, roundingMode);\n  /// IEEE remainder.\n  opStatus remainder(const IEEEFloat &);\n  /// C fmod, or llvm frem.\n  opStatus mod(const IEEEFloat &);\n  opStatus fusedMultiplyAdd(const IEEEFloat &, const IEEEFloat &, roundingMode);\n  opStatus roundToIntegral(roundingMode);\n  /// IEEE-754R 5.3.1: nextUp/nextDown.\n  opStatus next(bool nextDown);\n\n  /// @}\n\n  /// \\name Sign operations.\n  /// @{\n\n  void changeSign();\n\n  /// @}\n\n  /// \\name Conversions\n  /// @{\n\n  opStatus convert(const fltSemantics &, roundingMode, bool *);\n  opStatus convertToInteger(MutableArrayRef<integerPart>, unsigned int, bool,\n                            roundingMode, bool *) const;\n  opStatus convertFromAPInt(const APInt &, bool, roundingMode);\n  opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const;\n  double convertToDouble() const;\n  float convertToFloat() const;\n\n  /// @}\n\n  /// The definition of equality is not straightforward for floating point, so\n  /// we won't use operator==.  Use one of the following, or write whatever it\n  /// is you really mean.\n  bool operator==(const IEEEFloat &) const = delete;\n\n  /// IEEE comparison with another floating point number (NaNs compare\n  /// unordered, 0==-0).\n  cmpResult compare(const IEEEFloat &) const;\n\n  /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n  bool bitwiseIsEqual(const IEEEFloat &) const;\n\n  /// Write out a hexadecimal representation of the floating point value to DST,\n  /// which must be of sufficient size, in the C99 form [-]0xh.hhhhp[+-]d.\n  /// Return the number of characters written, excluding the terminating NUL.\n  unsigned int convertToHexString(char *dst, unsigned int hexDigits,\n                                  bool upperCase, roundingMode) const;\n\n  /// \\name IEEE-754R 5.7.2 General operations.\n  /// @{\n\n  /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n  /// negative.\n  ///\n  /// This applies to zeros and NaNs as well.\n  bool isNegative() const { return sign; }\n\n  /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n  ///\n  /// This implies that the current value of the float is not zero, subnormal,\n  /// infinite, or NaN following the definition of normality from IEEE-754R.\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n\n  /// Returns true if and only if the current value is zero, subnormal, or\n  /// normal.\n  ///\n  /// This means that the value is not infinite or NaN.\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  /// Returns true if and only if the float is plus or minus zero.\n  bool isZero() const { return category == fcZero; }\n\n  /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n  /// denormal.\n  bool isDenormal() const;\n\n  /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n  bool isInfinity() const { return category == fcInfinity; }\n\n  /// Returns true if and only if the float is a quiet or signaling NaN.\n  bool isNaN() const { return category == fcNaN; }\n\n  /// Returns true if and only if the float is a signaling NaN.\n  bool isSignaling() const;\n\n  /// @}\n\n  /// \\name Simple Queries\n  /// @{\n\n  fltCategory getCategory() const { return category; }\n  const fltSemantics &getSemantics() const { return *semantics; }\n  bool isNonZero() const { return category != fcZero; }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n\n  /// Returns true if and only if the number has the smallest possible non-zero\n  /// magnitude in the current semantics.\n  bool isSmallest() const;\n\n  /// Returns true if and only if the number has the largest possible finite\n  /// magnitude in the current semantics.\n  bool isLargest() const;\n\n  /// Returns true if and only if the number is an exact integer.\n  bool isInteger() const;\n\n  /// @}\n\n  IEEEFloat &operator=(const IEEEFloat &);\n  IEEEFloat &operator=(IEEEFloat &&);\n\n  /// Overload to compute a hash code for an APFloat value.\n  ///\n  /// Note that the use of hash codes for floating point values is in general\n  /// frought with peril. Equality is hard to define for these values. For\n  /// example, should negative and positive zero hash to different codes? Are\n  /// they equal or not? This hash value implementation specifically\n  /// emphasizes producing different codes for different inputs in order to\n  /// be used in canonicalization and memoization. As such, equality is\n  /// bitwiseIsEqual, and 0 != -0.\n  friend hash_code hash_value(const IEEEFloat &Arg);\n\n  /// Converts this value into a decimal string.\n  ///\n  /// \\param FormatPrecision The maximum number of digits of\n  ///   precision to output.  If there are fewer digits available,\n  ///   zero padding will not be used unless the value is\n  ///   integral and small enough to be expressed in\n  ///   FormatPrecision digits.  0 means to use the natural\n  ///   precision of the number.\n  /// \\param FormatMaxPadding The maximum number of zeros to\n  ///   consider inserting before falling back to scientific\n  ///   notation.  0 means to always use scientific notation.\n  ///\n  /// \\param TruncateZero Indicate whether to remove the trailing zero in\n  ///   fraction part or not. Also setting this parameter to false forcing\n  ///   producing of output more similar to default printf behavior.\n  ///   Specifically the lower e is used as exponent delimiter and exponent\n  ///   always contains no less than two digits.\n  ///\n  /// Number       Precision    MaxPadding      Result\n  /// ------       ---------    ----------      ------\n  /// 1.01E+4              5             2       10100\n  /// 1.01E+4              4             2       1.01E+4\n  /// 1.01E+4              5             1       1.01E+4\n  /// 1.01E-2              5             2       0.0101\n  /// 1.01E-2              4             2       0.0101\n  /// 1.01E-2              4             1       1.01E-2\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const;\n\n  /// If this value has an exact multiplicative inverse, store it in inv and\n  /// return true.\n  bool getExactInverse(APFloat *inv) const;\n\n  /// Returns the exponent of the internal representation of the APFloat.\n  ///\n  /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).\n  /// For special APFloat values, this returns special error codes:\n  ///\n  ///   NaN -> \\c IEK_NaN\n  ///   0   -> \\c IEK_Zero\n  ///   Inf -> \\c IEK_Inf\n  ///\n  friend int ilogb(const IEEEFloat &Arg);\n\n  /// Returns: X * 2^Exp for integral exponents.\n  friend IEEEFloat scalbn(IEEEFloat X, int Exp, roundingMode);\n\n  friend IEEEFloat frexp(const IEEEFloat &X, int &Exp, roundingMode);\n\n  /// \\name Special value setters.\n  /// @{\n\n  void makeLargest(bool Neg = false);\n  void makeSmallest(bool Neg = false);\n  void makeNaN(bool SNaN = false, bool Neg = false,\n               const APInt *fill = nullptr);\n  void makeInf(bool Neg = false);\n  void makeZero(bool Neg = false);\n  void makeQuiet();\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  void makeSmallestNormalized(bool Negative = false);\n\n  /// @}\n\n  cmpResult compareAbsoluteValue(const IEEEFloat &) const;\n\nprivate:\n  /// \\name Simple Queries\n  /// @{\n\n  integerPart *significandParts();\n  const integerPart *significandParts() const;\n  unsigned int partCount() const;\n\n  /// @}\n\n  /// \\name Significand operations.\n  /// @{\n\n  integerPart addSignificand(const IEEEFloat &);\n  integerPart subtractSignificand(const IEEEFloat &, integerPart);\n  lostFraction addOrSubtractSignificand(const IEEEFloat &, bool subtract);\n  lostFraction multiplySignificand(const IEEEFloat &, IEEEFloat);\n  lostFraction multiplySignificand(const IEEEFloat&);\n  lostFraction divideSignificand(const IEEEFloat &);\n  void incrementSignificand();\n  void initialize(const fltSemantics *);\n  void shiftSignificandLeft(unsigned int);\n  lostFraction shiftSignificandRight(unsigned int);\n  unsigned int significandLSB() const;\n  unsigned int significandMSB() const;\n  void zeroSignificand();\n  /// Return true if the significand excluding the integral bit is all ones.\n  bool isSignificandAllOnes() const;\n  /// Return true if the significand excluding the integral bit is all zeros.\n  bool isSignificandAllZeros() const;\n\n  /// @}\n\n  /// \\name Arithmetic on special values.\n  /// @{\n\n  opStatus addOrSubtractSpecials(const IEEEFloat &, bool subtract);\n  opStatus divideSpecials(const IEEEFloat &);\n  opStatus multiplySpecials(const IEEEFloat &);\n  opStatus modSpecials(const IEEEFloat &);\n  opStatus remainderSpecials(const IEEEFloat&);\n\n  /// @}\n\n  /// \\name Miscellany\n  /// @{\n\n  bool convertFromStringSpecials(StringRef str);\n  opStatus normalize(roundingMode, lostFraction);\n  opStatus addOrSubtract(const IEEEFloat &, roundingMode, bool subtract);\n  opStatus handleOverflow(roundingMode);\n  bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;\n  opStatus convertToSignExtendedInteger(MutableArrayRef<integerPart>,\n                                        unsigned int, bool, roundingMode,\n                                        bool *) const;\n  opStatus convertFromUnsignedParts(const integerPart *, unsigned int,\n                                    roundingMode);\n  Expected<opStatus> convertFromHexadecimalString(StringRef, roundingMode);\n  Expected<opStatus> convertFromDecimalString(StringRef, roundingMode);\n  char *convertNormalToHexString(char *, unsigned int, bool,\n                                 roundingMode) const;\n  opStatus roundSignificandWithExponent(const integerPart *, unsigned int, int,\n                                        roundingMode);\n  ExponentType exponentNaN() const;\n  ExponentType exponentInf() const;\n  ExponentType exponentZero() const;\n\n  /// @}\n\n  APInt convertHalfAPFloatToAPInt() const;\n  APInt convertBFloatAPFloatToAPInt() const;\n  APInt convertFloatAPFloatToAPInt() const;\n  APInt convertDoubleAPFloatToAPInt() const;\n  APInt convertQuadrupleAPFloatToAPInt() const;\n  APInt convertF80LongDoubleAPFloatToAPInt() const;\n  APInt convertPPCDoubleDoubleAPFloatToAPInt() const;\n  void initFromAPInt(const fltSemantics *Sem, const APInt &api);\n  void initFromHalfAPInt(const APInt &api);\n  void initFromBFloatAPInt(const APInt &api);\n  void initFromFloatAPInt(const APInt &api);\n  void initFromDoubleAPInt(const APInt &api);\n  void initFromQuadrupleAPInt(const APInt &api);\n  void initFromF80LongDoubleAPInt(const APInt &api);\n  void initFromPPCDoubleDoubleAPInt(const APInt &api);\n\n  void assign(const IEEEFloat &);\n  void copySignificand(const IEEEFloat &);\n  void freeSignificand();\n\n  /// Note: this must be the first data member.\n  /// The semantics that this value obeys.\n  const fltSemantics *semantics;\n\n  /// A binary fraction with an explicit integer bit.\n  ///\n  /// The significand must be at least one bit wider than the target precision.\n  union Significand {\n    integerPart part;\n    integerPart *parts;\n  } significand;\n\n  /// The signed unbiased exponent of the value.\n  ExponentType exponent;\n\n  /// What kind of floating point number this is.\n  ///\n  /// Only 2 bits are required, but VisualStudio incorrectly sign extends it.\n  /// Using the extra bit keeps it from failing under VisualStudio.\n  fltCategory category : 3;\n\n  /// Sign bit of the number.\n  unsigned int sign : 1;\n};\n\nhash_code hash_value(const IEEEFloat &Arg);\nint ilogb(const IEEEFloat &Arg);\nIEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode);\nIEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM);\n\n// This mode implements more precise float in terms of two APFloats.\n// The interface and layout is designed for arbitrary underlying semantics,\n// though currently only PPCDoubleDouble semantics are supported, whose\n// corresponding underlying semantics are IEEEdouble.\nclass DoubleAPFloat final : public APFloatBase {\n  // Note: this must be the first data member.\n  const fltSemantics *Semantics;\n  std::unique_ptr<APFloat[]> Floats;\n\n  opStatus addImpl(const APFloat &a, const APFloat &aa, const APFloat &c,\n                   const APFloat &cc, roundingMode RM);\n\n  opStatus addWithSpecial(const DoubleAPFloat &LHS, const DoubleAPFloat &RHS,\n                          DoubleAPFloat &Out, roundingMode RM);\n\npublic:\n  DoubleAPFloat(const fltSemantics &S);\n  DoubleAPFloat(const fltSemantics &S, uninitializedTag);\n  DoubleAPFloat(const fltSemantics &S, integerPart);\n  DoubleAPFloat(const fltSemantics &S, const APInt &I);\n  DoubleAPFloat(const fltSemantics &S, APFloat &&First, APFloat &&Second);\n  DoubleAPFloat(const DoubleAPFloat &RHS);\n  DoubleAPFloat(DoubleAPFloat &&RHS);\n\n  DoubleAPFloat &operator=(const DoubleAPFloat &RHS);\n\n  DoubleAPFloat &operator=(DoubleAPFloat &&RHS) {\n    if (this != &RHS) {\n      this->~DoubleAPFloat();\n      new (this) DoubleAPFloat(std::move(RHS));\n    }\n    return *this;\n  }\n\n  bool needsCleanup() const { return Floats != nullptr; }\n\n  APFloat &getFirst() { return Floats[0]; }\n  const APFloat &getFirst() const { return Floats[0]; }\n  APFloat &getSecond() { return Floats[1]; }\n  const APFloat &getSecond() const { return Floats[1]; }\n\n  opStatus add(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus subtract(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus multiply(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus divide(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus remainder(const DoubleAPFloat &RHS);\n  opStatus mod(const DoubleAPFloat &RHS);\n  opStatus fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,\n                            const DoubleAPFloat &Addend, roundingMode RM);\n  opStatus roundToIntegral(roundingMode RM);\n  void changeSign();\n  cmpResult compareAbsoluteValue(const DoubleAPFloat &RHS) const;\n\n  fltCategory getCategory() const;\n  bool isNegative() const;\n\n  void makeInf(bool Neg);\n  void makeZero(bool Neg);\n  void makeLargest(bool Neg);\n  void makeSmallest(bool Neg);\n  void makeSmallestNormalized(bool Neg);\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill);\n\n  cmpResult compare(const DoubleAPFloat &RHS) const;\n  bool bitwiseIsEqual(const DoubleAPFloat &RHS) const;\n  APInt bitcastToAPInt() const;\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  opStatus next(bool nextDown);\n\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned, roundingMode RM);\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const;\n\n  bool isDenormal() const;\n  bool isSmallest() const;\n  bool isLargest() const;\n  bool isInteger() const;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,\n                unsigned FormatMaxPadding, bool TruncateZero = true) const;\n\n  bool getExactInverse(APFloat *inv) const;\n\n  friend DoubleAPFloat scalbn(const DoubleAPFloat &X, int Exp, roundingMode);\n  friend DoubleAPFloat frexp(const DoubleAPFloat &X, int &Exp, roundingMode);\n  friend hash_code hash_value(const DoubleAPFloat &Arg);\n};\n\nhash_code hash_value(const DoubleAPFloat &Arg);\n\n} // End detail namespace\n\n// This is a interface class that is currently forwarding functionalities from\n// detail::IEEEFloat.\nclass APFloat : public APFloatBase {\n  typedef detail::IEEEFloat IEEEFloat;\n  typedef detail::DoubleAPFloat DoubleAPFloat;\n\n  static_assert(std::is_standard_layout<IEEEFloat>::value, \"\");\n\n  union Storage {\n    const fltSemantics *semantics;\n    IEEEFloat IEEE;\n    DoubleAPFloat Double;\n\n    explicit Storage(IEEEFloat F, const fltSemantics &S);\n    explicit Storage(DoubleAPFloat F, const fltSemantics &S)\n        : Double(std::move(F)) {\n      assert(&S == &PPCDoubleDouble());\n    }\n\n    template <typename... ArgTypes>\n    Storage(const fltSemantics &Semantics, ArgTypes &&... Args) {\n      if (usesLayout<IEEEFloat>(Semantics)) {\n        new (&IEEE) IEEEFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(Semantics)) {\n        new (&Double) DoubleAPFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    ~Storage() {\n      if (usesLayout<IEEEFloat>(*semantics)) {\n        IEEE.~IEEEFloat();\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*semantics)) {\n        Double.~DoubleAPFloat();\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(RHS.IEEE);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(RHS.Double);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(std::move(RHS.IEEE));\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(std::move(RHS.Double));\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage &operator=(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = RHS.IEEE;\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = RHS.Double;\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(RHS);\n      }\n      return *this;\n    }\n\n    Storage &operator=(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = std::move(RHS.IEEE);\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = std::move(RHS.Double);\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(std::move(RHS));\n      }\n      return *this;\n    }\n  } U;\n\n  template <typename T> static bool usesLayout(const fltSemantics &Semantics) {\n    static_assert(std::is_same<T, IEEEFloat>::value ||\n                  std::is_same<T, DoubleAPFloat>::value, \"\");\n    if (std::is_same<T, DoubleAPFloat>::value) {\n      return &Semantics == &PPCDoubleDouble();\n    }\n    return &Semantics != &PPCDoubleDouble();\n  }\n\n  IEEEFloat &getIEEE() {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  const IEEEFloat &getIEEE() const {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  void makeZero(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeZero(Neg)); }\n\n  void makeInf(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeInf(Neg)); }\n\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeNaN(SNaN, Neg, fill));\n  }\n\n  void makeLargest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeLargest(Neg));\n  }\n\n  void makeSmallest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallest(Neg));\n  }\n\n  void makeSmallestNormalized(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallestNormalized(Neg));\n  }\n\n  // FIXME: This is due to clang 3.3 (or older version) always checks for the\n  // default constructor in an array aggregate initialization, even if no\n  // elements in the array is default initialized.\n  APFloat() : U(IEEEdouble()) {\n    llvm_unreachable(\"This is a workaround for old clang.\");\n  }\n\n  explicit APFloat(IEEEFloat F, const fltSemantics &S) : U(std::move(F), S) {}\n  explicit APFloat(DoubleAPFloat F, const fltSemantics &S)\n      : U(std::move(F), S) {}\n\n  cmpResult compareAbsoluteValue(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compareAbsoluteValue(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compareAbsoluteValue(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\npublic:\n  APFloat(const fltSemantics &Semantics) : U(Semantics) {}\n  APFloat(const fltSemantics &Semantics, StringRef S);\n  APFloat(const fltSemantics &Semantics, integerPart I) : U(Semantics, I) {}\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>>\n  APFloat(const fltSemantics &Semantics, T V) = delete;\n  // TODO: Remove this constructor. This isn't faster than the first one.\n  APFloat(const fltSemantics &Semantics, uninitializedTag)\n      : U(Semantics, uninitialized) {}\n  APFloat(const fltSemantics &Semantics, const APInt &I) : U(Semantics, I) {}\n  explicit APFloat(double d) : U(IEEEFloat(d), IEEEdouble()) {}\n  explicit APFloat(float f) : U(IEEEFloat(f), IEEEsingle()) {}\n  APFloat(const APFloat &RHS) = default;\n  APFloat(APFloat &&RHS) = default;\n\n  ~APFloat() = default;\n\n  bool needsCleanup() const { APFLOAT_DISPATCH_ON_SEMANTICS(needsCleanup()); }\n\n  /// Factory for Positive and Negative Zero.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeZero(Negative);\n    return Val;\n  }\n\n  /// Factory for Positive and Negative Infinity.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeInf(Negative);\n    return Val;\n  }\n\n  /// Factory for NaN values.\n  ///\n  /// \\param Negative - True iff the NaN generated should be negative.\n  /// \\param payload - The unspecified fill bits for creating the NaN, 0 by\n  /// default.  The value is truncated as necessary.\n  static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,\n                        uint64_t payload = 0) {\n    if (payload) {\n      APInt intPayload(64, payload);\n      return getQNaN(Sem, Negative, &intPayload);\n    } else {\n      return getQNaN(Sem, Negative, nullptr);\n    }\n  }\n\n  /// Factory for QNaN values.\n  static APFloat getQNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(false, Negative, payload);\n    return Val;\n  }\n\n  /// Factory for SNaN values.\n  static APFloat getSNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(true, Negative, payload);\n    return Val;\n  }\n\n  /// Returns the largest finite number in the given semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getLargest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeLargest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) finite number in the given semantics.\n  /// Might be denormalized, which implies a relative loss of precision.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallestNormalized(const fltSemantics &Sem,\n                                       bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallestNormalized(Negative);\n    return Val;\n  }\n\n  /// Returns a float which is bitcasted from an all one value int.\n  ///\n  /// \\param Semantics - type float semantics\n  /// \\param BitWidth - Select float type\n  static APFloat getAllOnesValue(const fltSemantics &Semantics,\n                                 unsigned BitWidth);\n\n  /// Used to insert APFloat objects, or objects that contain APFloat objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID &NID) const;\n\n  opStatus add(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.add(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.add(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus subtract(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.subtract(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.subtract(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus multiply(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.multiply(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.multiply(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus divide(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.divide(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.divide(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus remainder(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.remainder(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.remainder(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus mod(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.mod(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.mod(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus fusedMultiplyAdd(const APFloat &Multiplicand, const APFloat &Addend,\n                            roundingMode RM) {\n    assert(&getSemantics() == &Multiplicand.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    assert(&getSemantics() == &Addend.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.fusedMultiplyAdd(Multiplicand.U.IEEE, Addend.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.fusedMultiplyAdd(Multiplicand.U.Double, Addend.U.Double,\n                                       RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus roundToIntegral(roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(roundToIntegral(RM));\n  }\n\n  // TODO: bool parameters are not readable and a source of bugs.\n  // Do something.\n  opStatus next(bool nextDown) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(next(nextDown));\n  }\n\n  /// Negate an APFloat.\n  APFloat operator-() const {\n    APFloat Result(*this);\n    Result.changeSign();\n    return Result;\n  }\n\n  /// Add two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator+(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.add(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Subtract two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator-(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.subtract(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Multiply two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator*(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.multiply(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Divide the first APFloat by the second, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator/(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.divide(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  void changeSign() { APFLOAT_DISPATCH_ON_SEMANTICS(changeSign()); }\n  void clearSign() {\n    if (isNegative())\n      changeSign();\n  }\n  void copySign(const APFloat &RHS) {\n    if (isNegative() != RHS.isNegative())\n      changeSign();\n  }\n\n  /// A static helper to produce a copy of an APFloat value with its sign\n  /// copied from some other APFloat.\n  static APFloat copySign(APFloat Value, const APFloat &Sign) {\n    Value.copySign(Sign);\n    return Value;\n  }\n\n  opStatus convert(const fltSemantics &ToSemantics, roundingMode RM,\n                   bool *losesInfo);\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToInteger(Input, Width, IsSigned, RM, IsExact));\n  }\n  opStatus convertToInteger(APSInt &Result, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned,\n                            roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(convertFromAPInt(Input, IsSigned, RM));\n  }\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(bitcastToAPInt());\n  }\n  double convertToDouble() const { return getIEEE().convertToDouble(); }\n  float convertToFloat() const { return getIEEE().convertToFloat(); }\n\n  bool operator==(const APFloat &RHS) const { return compare(RHS) == cmpEqual; }\n\n  bool operator!=(const APFloat &RHS) const { return compare(RHS) != cmpEqual; }\n\n  bool operator<(const APFloat &RHS) const {\n    return compare(RHS) == cmpLessThan;\n  }\n\n  bool operator>(const APFloat &RHS) const {\n    return compare(RHS) == cmpGreaterThan;\n  }\n\n  bool operator<=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpLessThan || Res == cmpEqual;\n  }\n\n  bool operator>=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpGreaterThan || Res == cmpEqual;\n  }\n\n  cmpResult compare(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compare(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compare(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  bool bitwiseIsEqual(const APFloat &RHS) const {\n    if (&getSemantics() != &RHS.getSemantics())\n      return false;\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.bitwiseIsEqual(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.bitwiseIsEqual(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n  ///\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat Tmp(V);\n    Tmp.convert(getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return bitwiseIsEqual(Tmp);\n  }\n\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToHexString(DST, HexDigits, UpperCase, RM));\n  }\n\n  bool isZero() const { return getCategory() == fcZero; }\n  bool isInfinity() const { return getCategory() == fcInfinity; }\n  bool isNaN() const { return getCategory() == fcNaN; }\n\n  bool isNegative() const { return getIEEE().isNegative(); }\n  bool isDenormal() const { APFLOAT_DISPATCH_ON_SEMANTICS(isDenormal()); }\n  bool isSignaling() const { return getIEEE().isSignaling(); }\n\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  fltCategory getCategory() const { return getIEEE().getCategory(); }\n  const fltSemantics &getSemantics() const { return *U.semantics; }\n  bool isNonZero() const { return !isZero(); }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n  bool isSmallest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isSmallest()); }\n  bool isLargest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isLargest()); }\n  bool isInteger() const { APFLOAT_DISPATCH_ON_SEMANTICS(isInteger()); }\n  bool isIEEE() const { return usesLayout<IEEEFloat>(getSemantics()); }\n\n  APFloat &operator=(const APFloat &RHS) = default;\n  APFloat &operator=(APFloat &&RHS) = default;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero));\n  }\n\n  void print(raw_ostream &) const;\n  void dump() const;\n\n  bool getExactInverse(APFloat *inv) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(getExactInverse(inv));\n  }\n\n  friend hash_code hash_value(const APFloat &Arg);\n  friend int ilogb(const APFloat &Arg) { return ilogb(Arg.getIEEE()); }\n  friend APFloat scalbn(APFloat X, int Exp, roundingMode RM);\n  friend APFloat frexp(const APFloat &X, int &Exp, roundingMode RM);\n  friend IEEEFloat;\n  friend DoubleAPFloat;\n};\n\n/// See friend declarations above.\n///\n/// These additional declarations are required in order to compile LLVM with IBM\n/// xlC compiler.\nhash_code hash_value(const APFloat &Arg);\ninline APFloat scalbn(APFloat X, int Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n\n/// Equivalent of C standard library function.\n///\n/// While the C standard says Exp is an unspecified value for infinity and nan,\n/// this returns INT_MAX for infinities, and INT_MIN for NaNs.\ninline APFloat frexp(const APFloat &X, int &Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n/// Returns the absolute value of the argument.\ninline APFloat abs(APFloat X) {\n  X.clearSign();\n  return X;\n}\n\n/// Returns the negated value of the argument.\ninline APFloat neg(APFloat X) {\n  X.changeSign();\n  return X;\n}\n\n/// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat minnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat maxnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return A < B ? B : A;\n}\n\n/// Implements IEEE 754-2018 minimum semantics. Returns the smaller of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat minimum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? A : B;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE 754-2018 maximum semantics. Returns the larger of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat maximum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? B : A;\n  return A < B ? B : A;\n}\n\n} // namespace llvm\n\n#undef APFLOAT_DISPATCH_ON_SEMANTICS\n#endif // LLVM_ADT_APFLOAT_H\n"}, "82": {"id": 82, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "content": "//===-- llvm/ADT/APSInt.h - Arbitrary Precision Signed Int -----*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the APSInt class, which is a simple class that\n// represents an arbitrary sized integer that knows its signedness.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APSINT_H\n#define LLVM_ADT_APSINT_H\n\n#include \"llvm/ADT/APInt.h\"\n\nnamespace llvm {\n\n/// An arbitrary precision integer that knows its signedness.\nclass LLVM_NODISCARD APSInt : public APInt {\n  bool IsUnsigned;\n\npublic:\n  /// Default constructor that creates an uninitialized APInt.\n  explicit APSInt() : IsUnsigned(false) {}\n\n  /// Create an APSInt with the specified width, default to unsigned.\n  explicit APSInt(uint32_t BitWidth, bool isUnsigned = true)\n   : APInt(BitWidth, 0), IsUnsigned(isUnsigned) {}\n\n  explicit APSInt(APInt I, bool isUnsigned = true)\n   : APInt(std::move(I)), IsUnsigned(isUnsigned) {}\n\n  /// Construct an APSInt from a string representation.\n  ///\n  /// This constructor interprets the string \\p Str using the radix of 10.\n  /// The interpretation stops at the end of the string. The bit width of the\n  /// constructed APSInt is determined automatically.\n  ///\n  /// \\param Str the string to be interpreted.\n  explicit APSInt(StringRef Str);\n\n  /// Determine sign of this APSInt.\n  ///\n  /// \\returns true if this APSInt is negative, false otherwise\n  bool isNegative() const { return isSigned() && APInt::isNegative(); }\n\n  /// Determine if this APSInt Value is non-negative (>= 0)\n  ///\n  /// \\returns true if this APSInt is non-negative, false otherwise\n  bool isNonNegative() const { return !isNegative(); }\n\n  /// Determine if this APSInt Value is positive.\n  ///\n  /// This tests if the value of this APSInt is positive (> 0). Note\n  /// that 0 is not a positive value.\n  ///\n  /// \\returns true if this APSInt is positive.\n  bool isStrictlyPositive() const { return isNonNegative() && !isNullValue(); }\n\n  APSInt &operator=(APInt RHS) {\n    // Retain our current sign.\n    APInt::operator=(std::move(RHS));\n    return *this;\n  }\n\n  APSInt &operator=(uint64_t RHS) {\n    // Retain our current sign.\n    APInt::operator=(RHS);\n    return *this;\n  }\n\n  // Query sign information.\n  bool isSigned() const { return !IsUnsigned; }\n  bool isUnsigned() const { return IsUnsigned; }\n  void setIsUnsigned(bool Val) { IsUnsigned = Val; }\n  void setIsSigned(bool Val) { IsUnsigned = !Val; }\n\n  /// Append this APSInt to the specified SmallString.\n  void toString(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    APInt::toString(Str, Radix, isSigned());\n  }\n  /// Converts an APInt to a std::string.  This is an inefficient\n  /// method; you should prefer passing in a SmallString instead.\n  std::string toString(unsigned Radix) const {\n    return APInt::toString(Radix, isSigned());\n  }\n  using APInt::toString;\n\n  /// Get the correctly-extended \\c int64_t value.\n  int64_t getExtValue() const {\n    assert(getMinSignedBits() <= 64 && \"Too many bits for int64_t\");\n    return isSigned() ? getSExtValue() : getZExtValue();\n  }\n\n  APSInt trunc(uint32_t width) const {\n    return APSInt(APInt::trunc(width), IsUnsigned);\n  }\n\n  APSInt extend(uint32_t width) const {\n    if (IsUnsigned)\n      return APSInt(zext(width), IsUnsigned);\n    else\n      return APSInt(sext(width), IsUnsigned);\n  }\n\n  APSInt extOrTrunc(uint32_t width) const {\n    if (IsUnsigned)\n      return APSInt(zextOrTrunc(width), IsUnsigned);\n    else\n      return APSInt(sextOrTrunc(width), IsUnsigned);\n  }\n\n  const APSInt &operator%=(const APSInt &RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    if (IsUnsigned)\n      *this = urem(RHS);\n    else\n      *this = srem(RHS);\n    return *this;\n  }\n  const APSInt &operator/=(const APSInt &RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    if (IsUnsigned)\n      *this = udiv(RHS);\n    else\n      *this = sdiv(RHS);\n    return *this;\n  }\n  APSInt operator%(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? APSInt(urem(RHS), true) : APSInt(srem(RHS), false);\n  }\n  APSInt operator/(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? APSInt(udiv(RHS), true) : APSInt(sdiv(RHS), false);\n  }\n\n  APSInt operator>>(unsigned Amt) const {\n    return IsUnsigned ? APSInt(lshr(Amt), true) : APSInt(ashr(Amt), false);\n  }\n  APSInt& operator>>=(unsigned Amt) {\n    if (IsUnsigned)\n      lshrInPlace(Amt);\n    else\n      ashrInPlace(Amt);\n    return *this;\n  }\n\n  inline bool operator<(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ult(RHS) : slt(RHS);\n  }\n  inline bool operator>(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ugt(RHS) : sgt(RHS);\n  }\n  inline bool operator<=(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ule(RHS) : sle(RHS);\n  }\n  inline bool operator>=(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? uge(RHS) : sge(RHS);\n  }\n  inline bool operator==(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return eq(RHS);\n  }\n  inline bool operator!=(const APSInt& RHS) const {\n    return !((*this) == RHS);\n  }\n\n  bool operator==(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) == 0;\n  }\n  bool operator!=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) != 0;\n  }\n  bool operator<=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) <= 0;\n  }\n  bool operator>=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) >= 0;\n  }\n  bool operator<(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) < 0;\n  }\n  bool operator>(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) > 0;\n  }\n\n  // The remaining operators just wrap the logic of APInt, but retain the\n  // signedness information.\n\n  APSInt operator<<(unsigned Bits) const {\n    return APSInt(static_cast<const APInt&>(*this) << Bits, IsUnsigned);\n  }\n  APSInt& operator<<=(unsigned Amt) {\n    static_cast<APInt&>(*this) <<= Amt;\n    return *this;\n  }\n\n  APSInt& operator++() {\n    ++(static_cast<APInt&>(*this));\n    return *this;\n  }\n  APSInt& operator--() {\n    --(static_cast<APInt&>(*this));\n    return *this;\n  }\n  APSInt operator++(int) {\n    return APSInt(++static_cast<APInt&>(*this), IsUnsigned);\n  }\n  APSInt operator--(int) {\n    return APSInt(--static_cast<APInt&>(*this), IsUnsigned);\n  }\n  APSInt operator-() const {\n    return APSInt(-static_cast<const APInt&>(*this), IsUnsigned);\n  }\n  APSInt& operator+=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) += RHS;\n    return *this;\n  }\n  APSInt& operator-=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) -= RHS;\n    return *this;\n  }\n  APSInt& operator*=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) *= RHS;\n    return *this;\n  }\n  APSInt& operator&=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) &= RHS;\n    return *this;\n  }\n  APSInt& operator|=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) |= RHS;\n    return *this;\n  }\n  APSInt& operator^=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) ^= RHS;\n    return *this;\n  }\n\n  APSInt operator&(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) & RHS, IsUnsigned);\n  }\n\n  APSInt operator|(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) | RHS, IsUnsigned);\n  }\n\n  APSInt operator^(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) ^ RHS, IsUnsigned);\n  }\n\n  APSInt operator*(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) * RHS, IsUnsigned);\n  }\n  APSInt operator+(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) + RHS, IsUnsigned);\n  }\n  APSInt operator-(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) - RHS, IsUnsigned);\n  }\n  APSInt operator~() const {\n    return APSInt(~static_cast<const APInt&>(*this), IsUnsigned);\n  }\n\n  /// Return the APSInt representing the maximum integer value with the given\n  /// bit width and signedness.\n  static APSInt getMaxValue(uint32_t numBits, bool Unsigned) {\n    return APSInt(Unsigned ? APInt::getMaxValue(numBits)\n                           : APInt::getSignedMaxValue(numBits), Unsigned);\n  }\n\n  /// Return the APSInt representing the minimum integer value with the given\n  /// bit width and signedness.\n  static APSInt getMinValue(uint32_t numBits, bool Unsigned) {\n    return APSInt(Unsigned ? APInt::getMinValue(numBits)\n                           : APInt::getSignedMinValue(numBits), Unsigned);\n  }\n\n  /// Determine if two APSInts have the same value, zero- or\n  /// sign-extending as needed.\n  static bool isSameValue(const APSInt &I1, const APSInt &I2) {\n    return !compareValues(I1, I2);\n  }\n\n  /// Compare underlying values of two numbers.\n  static int compareValues(const APSInt &I1, const APSInt &I2) {\n    if (I1.getBitWidth() == I2.getBitWidth() && I1.isSigned() == I2.isSigned())\n      return I1.IsUnsigned ? I1.compare(I2) : I1.compareSigned(I2);\n\n    // Check for a bit-width mismatch.\n    if (I1.getBitWidth() > I2.getBitWidth())\n      return compareValues(I1, I2.extend(I1.getBitWidth()));\n    if (I2.getBitWidth() > I1.getBitWidth())\n      return compareValues(I1.extend(I2.getBitWidth()), I2);\n\n    // We have a signedness mismatch. Check for negative values and do an\n    // unsigned compare if both are positive.\n    if (I1.isSigned()) {\n      assert(!I2.isSigned() && \"Expected signed mismatch\");\n      if (I1.isNegative())\n        return -1;\n    } else {\n      assert(I2.isSigned() && \"Expected signed mismatch\");\n      if (I2.isNegative())\n        return 1;\n    }\n\n    return I1.compare(I2);\n  }\n\n  static APSInt get(int64_t X) { return APSInt(APInt(64, X), false); }\n  static APSInt getUnsigned(uint64_t X) { return APSInt(APInt(64, X), true); }\n\n  /// Used to insert APSInt objects, or objects that contain APSInt objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID& ID) const;\n};\n\ninline bool operator==(int64_t V1, const APSInt &V2) { return V2 == V1; }\ninline bool operator!=(int64_t V1, const APSInt &V2) { return V2 != V1; }\ninline bool operator<=(int64_t V1, const APSInt &V2) { return V2 >= V1; }\ninline bool operator>=(int64_t V1, const APSInt &V2) { return V2 <= V1; }\ninline bool operator<(int64_t V1, const APSInt &V2) { return V2 > V1; }\ninline bool operator>(int64_t V1, const APSInt &V2) { return V2 < V1; }\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APSInt &I) {\n  I.print(OS, I.isSigned());\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif\n"}, "85": {"id": 85, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "content": "//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines CachedHashString and CachedHashStringRef.  These are owning\n// and not-owning string types that store their hash in addition to their string\n// data.\n//\n// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap\n// (because, unlike std::string, CachedHashString lets us have empty and\n// tombstone values).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_CACHEDHASHSTRING_H\n#define LLVM_ADT_CACHEDHASHSTRING_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\n/// A container which contains a StringRef plus a precomputed hash.\nclass CachedHashStringRef {\n  const char *P;\n  uint32_t Size;\n  uint32_t Hash;\n\npublic:\n  // Explicit because hashing a string isn't free.\n  explicit CachedHashStringRef(StringRef S)\n      : CachedHashStringRef(S, DenseMapInfo<StringRef>::getHashValue(S)) {}\n\n  CachedHashStringRef(StringRef S, uint32_t Hash)\n      : P(S.data()), Size(S.size()), Hash(Hash) {\n    assert(S.size() <= std::numeric_limits<uint32_t>::max());\n  }\n\n  StringRef val() const { return StringRef(P, Size); }\n  const char *data() const { return P; }\n  uint32_t size() const { return Size; }\n  uint32_t hash() const { return Hash; }\n};\n\ntemplate <> struct DenseMapInfo<CachedHashStringRef> {\n  static CachedHashStringRef getEmptyKey() {\n    return CachedHashStringRef(DenseMapInfo<StringRef>::getEmptyKey(), 0);\n  }\n  static CachedHashStringRef getTombstoneKey() {\n    return CachedHashStringRef(DenseMapInfo<StringRef>::getTombstoneKey(), 1);\n  }\n  static unsigned getHashValue(const CachedHashStringRef &S) {\n    assert(!isEqual(S, getEmptyKey()) && \"Cannot hash the empty key!\");\n    assert(!isEqual(S, getTombstoneKey()) && \"Cannot hash the tombstone key!\");\n    return S.hash();\n  }\n  static bool isEqual(const CachedHashStringRef &LHS,\n                      const CachedHashStringRef &RHS) {\n    return LHS.hash() == RHS.hash() &&\n           DenseMapInfo<StringRef>::isEqual(LHS.val(), RHS.val());\n  }\n};\n\n/// A container which contains a string, which it owns, plus a precomputed hash.\n///\n/// We do not null-terminate the string.\nclass CachedHashString {\n  friend struct DenseMapInfo<CachedHashString>;\n\n  char *P;\n  uint32_t Size;\n  uint32_t Hash;\n\n  static char *getEmptyKeyPtr() { return DenseMapInfo<char *>::getEmptyKey(); }\n  static char *getTombstoneKeyPtr() {\n    return DenseMapInfo<char *>::getTombstoneKey();\n  }\n\n  bool isEmptyOrTombstone() const {\n    return P == getEmptyKeyPtr() || P == getTombstoneKeyPtr();\n  }\n\n  struct ConstructEmptyOrTombstoneTy {};\n\n  CachedHashString(ConstructEmptyOrTombstoneTy, char *EmptyOrTombstonePtr)\n      : P(EmptyOrTombstonePtr), Size(0), Hash(0) {\n    assert(isEmptyOrTombstone());\n  }\n\n  // TODO: Use small-string optimization to avoid allocating.\n\npublic:\n  explicit CachedHashString(const char *S) : CachedHashString(StringRef(S)) {}\n\n  // Explicit because copying and hashing a string isn't free.\n  explicit CachedHashString(StringRef S)\n      : CachedHashString(S, DenseMapInfo<StringRef>::getHashValue(S)) {}\n\n  CachedHashString(StringRef S, uint32_t Hash)\n      : P(new char[S.size()]), Size(S.size()), Hash(Hash) {\n    memcpy(P, S.data(), S.size());\n  }\n\n  // Ideally this class would not be copyable.  But SetVector requires copyable\n  // keys, and we want this to be usable there.\n  CachedHashString(const CachedHashString &Other)\n      : Size(Other.Size), Hash(Other.Hash) {\n    if (Other.isEmptyOrTombstone()) {\n      P = Other.P;\n    } else {\n      P = new char[Size];\n      memcpy(P, Other.P, Size);\n    }\n  }\n\n  CachedHashString &operator=(CachedHashString Other) {\n    swap(*this, Other);\n    return *this;\n  }\n\n  CachedHashString(CachedHashString &&Other) noexcept\n      : P(Other.P), Size(Other.Size), Hash(Other.Hash) {\n    Other.P = getEmptyKeyPtr();\n  }\n\n  ~CachedHashString() {\n    if (!isEmptyOrTombstone())\n      delete[] P;\n  }\n\n  StringRef val() const { return StringRef(P, Size); }\n  uint32_t size() const { return Size; }\n  uint32_t hash() const { return Hash; }\n\n  operator StringRef() const { return val(); }\n  operator CachedHashStringRef() const {\n    return CachedHashStringRef(val(), Hash);\n  }\n\n  friend void swap(CachedHashString &LHS, CachedHashString &RHS) {\n    using std::swap;\n    swap(LHS.P, RHS.P);\n    swap(LHS.Size, RHS.Size);\n    swap(LHS.Hash, RHS.Hash);\n  }\n};\n\ntemplate <> struct DenseMapInfo<CachedHashString> {\n  static CachedHashString getEmptyKey() {\n    return CachedHashString(CachedHashString::ConstructEmptyOrTombstoneTy(),\n                            CachedHashString::getEmptyKeyPtr());\n  }\n  static CachedHashString getTombstoneKey() {\n    return CachedHashString(CachedHashString::ConstructEmptyOrTombstoneTy(),\n                            CachedHashString::getTombstoneKeyPtr());\n  }\n  static unsigned getHashValue(const CachedHashString &S) {\n    assert(!isEqual(S, getEmptyKey()) && \"Cannot hash the empty key!\");\n    assert(!isEqual(S, getTombstoneKey()) && \"Cannot hash the tombstone key!\");\n    return S.hash();\n  }\n  static bool isEqual(const CachedHashString &LHS,\n                      const CachedHashString &RHS) {\n    if (LHS.hash() != RHS.hash())\n      return false;\n    if (LHS.P == CachedHashString::getEmptyKeyPtr())\n      return RHS.P == CachedHashString::getEmptyKeyPtr();\n    if (LHS.P == CachedHashString::getTombstoneKeyPtr())\n      return RHS.P == CachedHashString::getTombstoneKeyPtr();\n\n    // This is safe because if RHS.P is the empty or tombstone key, it will have\n    // length 0, so we'll never dereference its pointer.\n    return LHS.val() == RHS.val();\n  }\n};\n\n} // namespace llvm\n\n#endif\n"}, "113": {"id": 113, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h", "content": "//===-- llvm/Support/DynamicLibrary.h - Portable Dynamic Library -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the sys::DynamicLibrary class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DYNAMICLIBRARY_H\n#define LLVM_SUPPORT_DYNAMICLIBRARY_H\n\n#include <string>\n\nnamespace llvm {\n\nclass StringRef;\n\nnamespace sys {\n\n  /// This class provides a portable interface to dynamic libraries which also\n  /// might be known as shared libraries, shared objects, dynamic shared\n  /// objects, or dynamic link libraries. Regardless of the terminology or the\n  /// operating system interface, this class provides a portable interface that\n  /// allows dynamic libraries to be loaded and searched for externally\n  /// defined symbols. This is typically used to provide \"plug-in\" support.\n  /// It also allows for symbols to be defined which don't live in any library,\n  /// but rather the main program itself, useful on Windows where the main\n  /// executable cannot be searched.\n  ///\n  /// Note: there is currently no interface for temporarily loading a library,\n  /// or for unloading libraries when the LLVM library is unloaded.\n  class DynamicLibrary {\n    // Placeholder whose address represents an invalid library.\n    // We use this instead of NULL or a pointer-int pair because the OS library\n    // might define 0 or 1 to be \"special\" handles, such as \"search all\".\n    static char Invalid;\n\n    // Opaque data used to interface with OS-specific dynamic library handling.\n    void *Data;\n\n  public:\n    explicit DynamicLibrary(void *data = &Invalid) : Data(data) {}\n\n    /// Returns true if the object refers to a valid library.\n    bool isValid() const { return Data != &Invalid; }\n\n    /// Searches through the library for the symbol \\p symbolName. If it is\n    /// found, the address of that symbol is returned. If not, NULL is returned.\n    /// Note that NULL will also be returned if the library failed to load.\n    /// Use isValid() to distinguish these cases if it is important.\n    /// Note that this will \\e not search symbols explicitly registered by\n    /// AddSymbol().\n    void *getAddressOfSymbol(const char *symbolName);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// The library will only be unloaded when llvm_shutdown() is called.\n    /// This returns a valid DynamicLibrary instance on success and an invalid\n    /// instance on failure (see isValid()). \\p *errMsg will only be modified\n    /// if the library fails to load.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    /// Open a dynamic library permanently.\n    static DynamicLibrary getPermanentLibrary(const char *filename,\n                                              std::string *errMsg = nullptr);\n\n    /// Registers an externally loaded library. The library will be unloaded\n    /// when the program terminates.\n    ///\n    /// It is safe to call this function multiple times for the same library,\n    /// though ownership is only taken if there was no error.\n    ///\n    /// \\returns An empty \\p DynamicLibrary if the library was already loaded.\n    static DynamicLibrary addPermanentLibrary(void *handle,\n                                              std::string *errMsg = nullptr);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// Use this instead of getPermanentLibrary() when you won't need to get\n    /// symbols from the library itself.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    static bool LoadLibraryPermanently(const char *Filename,\n                                       std::string *ErrMsg = nullptr) {\n      return !getPermanentLibrary(Filename, ErrMsg).isValid();\n    }\n\n    enum SearchOrdering {\n      /// SO_Linker - Search as a call to dlsym(dlopen(NULL)) would when\n      /// DynamicLibrary::getPermanentLibrary(NULL) has been called or\n      /// search the list of explcitly loaded symbols if not.\n      SO_Linker,\n      /// SO_LoadedFirst - Search all loaded libraries, then as SO_Linker would.\n      SO_LoadedFirst,\n      /// SO_LoadedLast - Search as SO_Linker would, then loaded libraries.\n      /// Only useful to search if libraries with RTLD_LOCAL have been added.\n      SO_LoadedLast,\n      /// SO_LoadOrder - Or this in to search libraries in the ordered loaded.\n      /// The default bahaviour is to search loaded libraries in reverse.\n      SO_LoadOrder = 4\n    };\n    static SearchOrdering SearchOrder; // = SO_Linker\n\n    /// This function will search through all previously loaded dynamic\n    /// libraries for the symbol \\p symbolName. If it is found, the address of\n    /// that symbol is returned. If not, null is returned. Note that this will\n    /// search permanently loaded libraries (getPermanentLibrary()) as well\n    /// as explicitly registered symbols (AddSymbol()).\n    /// @throws std::string on error.\n    /// Search through libraries for address of a symbol\n    static void *SearchForAddressOfSymbol(const char *symbolName);\n\n    /// Convenience function for C++ophiles.\n    static void *SearchForAddressOfSymbol(const std::string &symbolName) {\n      return SearchForAddressOfSymbol(symbolName.c_str());\n    }\n\n    /// This functions permanently adds the symbol \\p symbolName with the\n    /// value \\p symbolValue.  These symbols are searched before any\n    /// libraries.\n    /// Add searchable symbol/value pair.\n    static void AddSymbol(StringRef symbolName, void *symbolValue);\n\n    class HandleSet;\n  };\n\n} // End sys namespace\n} // End llvm namespace\n\n#endif\n"}, "125": {"id": 125, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Registry.h", "content": "//=== Registry.h - Linker-supported plugin registries -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Defines a registry template for discovering pluggable modules.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_REGISTRY_H\n#define LLVM_SUPPORT_REGISTRY_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/DynamicLibrary.h\"\n#include <memory>\n\nnamespace llvm {\n  /// A simple registry entry which provides only a name, description, and\n  /// no-argument constructor.\n  template <typename T>\n  class SimpleRegistryEntry {\n    StringRef Name, Desc;\n    std::unique_ptr<T> (*Ctor)();\n\n  public:\n    SimpleRegistryEntry(StringRef N, StringRef D, std::unique_ptr<T> (*C)())\n        : Name(N), Desc(D), Ctor(C) {}\n\n    StringRef getName() const { return Name; }\n    StringRef getDesc() const { return Desc; }\n    std::unique_ptr<T> instantiate() const { return Ctor(); }\n  };\n\n  /// A global registry used in conjunction with static constructors to make\n  /// pluggable components (like targets or garbage collectors) \"just work\" when\n  /// linked with an executable.\n  template <typename T>\n  class Registry {\n  public:\n    typedef T type;\n    typedef SimpleRegistryEntry<T> entry;\n\n    class node;\n    class iterator;\n\n  private:\n    Registry() = delete;\n\n    friend class node;\n    static node *Head, *Tail;\n\n  public:\n    /// Node in linked list of entries.\n    ///\n    class node {\n      friend class iterator;\n      friend Registry<T>;\n\n      node *Next;\n      const entry& Val;\n\n    public:\n      node(const entry &V) : Next(nullptr), Val(V) {}\n    };\n\n    /// Add a node to the Registry: this is the interface between the plugin and\n    /// the executable.\n    ///\n    /// This function is exported by the executable and called by the plugin to\n    /// add a node to the executable's registry. Therefore it's not defined here\n    /// to avoid it being instantiated in the plugin and is instead defined in\n    /// the executable (see LLVM_INSTANTIATE_REGISTRY below).\n    static void add_node(node *N);\n\n    /// Iterators for registry entries.\n    ///\n    class iterator\n        : public llvm::iterator_facade_base<iterator, std::forward_iterator_tag,\n                                            const entry> {\n      const node *Cur;\n\n    public:\n      explicit iterator(const node *N) : Cur(N) {}\n\n      bool operator==(const iterator &That) const { return Cur == That.Cur; }\n      iterator &operator++() { Cur = Cur->Next; return *this; }\n      const entry &operator*() const { return Cur->Val; }\n    };\n\n    // begin is not defined here in order to avoid usage of an undefined static\n    // data member, instead it's instantiated by LLVM_INSTANTIATE_REGISTRY.\n    static iterator begin();\n    static iterator end()   { return iterator(nullptr); }\n\n    static iterator_range<iterator> entries() {\n      return make_range(begin(), end());\n    }\n\n    /// A static registration template. Use like such:\n    ///\n    ///   Registry<Collector>::Add<FancyGC>\n    ///   X(\"fancy-gc\", \"Newfangled garbage collector.\");\n    ///\n    /// Use of this template requires that:\n    ///\n    ///  1. The registered subclass has a default constructor.\n    template <typename V>\n    class Add {\n      entry Entry;\n      node Node;\n\n      static std::unique_ptr<T> CtorFn() { return std::make_unique<V>(); }\n\n    public:\n      Add(StringRef Name, StringRef Desc)\n          : Entry(Name, Desc, CtorFn), Node(Entry) {\n        add_node(&Node);\n      }\n    };\n  };\n} // end namespace llvm\n\n/// Instantiate a registry class.\n///\n/// This provides template definitions of add_node, begin, and the Head and Tail\n/// pointers, then explicitly instantiates them. We could explicitly specialize\n/// them, instead of the two-step process of define then instantiate, but\n/// strictly speaking that's not allowed by the C++ standard (we would need to\n/// have explicit specialization declarations in all translation units where the\n/// specialization is used) so we don't.\n#define LLVM_INSTANTIATE_REGISTRY(REGISTRY_CLASS) \\\n  namespace llvm { \\\n  template<typename T> typename Registry<T>::node *Registry<T>::Head = nullptr;\\\n  template<typename T> typename Registry<T>::node *Registry<T>::Tail = nullptr;\\\n  template<typename T> \\\n  void Registry<T>::add_node(typename Registry<T>::node *N) { \\\n    if (Tail) \\\n      Tail->Next = N; \\\n    else \\\n      Head = N; \\\n    Tail = N; \\\n  } \\\n  template<typename T> typename Registry<T>::iterator Registry<T>::begin() { \\\n    return iterator(Head); \\\n  } \\\n  template REGISTRY_CLASS::node *Registry<REGISTRY_CLASS::type>::Head; \\\n  template REGISTRY_CLASS::node *Registry<REGISTRY_CLASS::type>::Tail; \\\n  template \\\n  void Registry<REGISTRY_CLASS::type>::add_node(REGISTRY_CLASS::node*); \\\n  template REGISTRY_CLASS::iterator Registry<REGISTRY_CLASS::type>::begin(); \\\n  }\n\n#endif // LLVM_SUPPORT_REGISTRY_H\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 1, "line": 60}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 1, "line": 60}, "message": "move constructor 'ParsedAST' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ParsedAST.h", "reportHash": "abdc22e061fdda3d5de8c3de174aae40", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 1, "line": 61}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 1, "line": 61}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ParsedAST.h", "reportHash": "82cd7ed8c5cde8680ce4bd37da2074a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 2, "line": 163}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 2, "line": 163}, "message": "default constructor 'SwapIndex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "reportHash": "063978df20a2789a4d76ea9af8af578e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 3, "line": 136}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 3, "line": 136}, "message": "default constructor 'Builder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "87887e98042f2bcb60218edf8503efb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 4, "line": 202}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 4, "line": 202}, "message": "default constructor 'Builder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Symbol.h", "reportHash": "94b0cca6fa94f3aaedaec9f696122d26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 5, "line": 33}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 5, "line": 33}, "message": "default constructor 'Position' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "870ef87494c588c9437aa6503ff8447a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 6, "line": 45}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 6, "line": 45}, "message": "default constructor 'Key<Type>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "ab6d30f41bf3cd16f0905086d42df38f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 6, "line": 49}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 6, "line": 49}, "message": "move constructor 'Key<Type>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "19fc1d4dbcda923308479760718e9b41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 50}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 6, "line": 50}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "9b881cd82c092e55cf002e1c478dac88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 6, "line": 193}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 6, "line": 193}, "message": "move constructor 'WithContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "adc25396be17f005261470afb94ac1ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 194}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 194}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "09deef981f6e7786a03c91e6dad1b0df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 7, "line": 47}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 7, "line": 47}, "message": "default constructor 'Subscription' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "reportHash": "03a32fbce2d563d579501affe8e0a896", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 7, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 7, "line": 48}, "message": "move constructor 'Subscription' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "reportHash": "9ca91bb07410557b124d4169ced99f41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 7, "line": 51}, "message": "mark 'noexcept'"}, {"location": {"col": 19, "file": 7, "line": 51}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "reportHash": "f4d1417934dc4f0e32f16dd26211cd86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 7, "line": 66}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 7, "line": 66}, "message": "destructor '~Subscription' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "reportHash": "07ad3fa013d7f02c1fed552251e2628c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 7, "line": 90}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 7, "line": 90}, "message": "destructor '~Event<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "reportHash": "e51c4dd9773e68986baa097633dd15b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 35}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 35}, "message": "default constructor 'MemoryTree' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/MemoryTree.h", "reportHash": "397c077300a5aceb19d6c9b1c7488ae3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 149}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 9, "line": 149}, "message": "default constructor 'Memoize<Container>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "dc20ce3d605c7d78c8c9a7489a33e162", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 12, "line": 41}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 12, "line": 41}, "message": "default constructor 'ASTConsumer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTConsumer.h", "reportHash": "740983470d7ac26b2dd02fbb609de090", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 14, "line": 55}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 14, "line": 55}, "message": "default constructor 'ASTNodeKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "1dcf6c2d8467e89f8ba5c4d642a363d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 36, "line": 432}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 36, "line": 432}, "message": "default constructor 'PathDiagnosticPiece' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "bc07a75574c3c20f6d3bb50f0cdf0ef7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 36, "line": 790}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 36, "line": 790}, "message": "default constructor 'PathDiagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "b3785b377427f5fe6236a43242a99ee7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 42, "line": 64}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 42, "line": 64}, "message": "default constructor 'DirectoryEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "877703ce1173961a1f7de49b4dd0f364", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 42, "line": 120}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 42, "line": 120}, "message": "default constructor 'MapEntryOptionalStorage<RefTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "756811c4f34f51a11f482408770ffd82", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 43, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 43, "line": 123}, "message": "default constructor 'MapValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "b82e584eae9a6ad290cf918a5157ee19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 43, "line": 150}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 43, "line": 150}, "message": "default constructor 'FileEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "e46e2f91ab444a7cb542d84eaff186e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 43, "line": 358}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 43, "line": 358}, "message": "default constructor 'FileEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "82a3a98bca54f1ac3b8e5fa8a2b24414", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 61}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 61}, "message": "default constructor 'ASTFileSignature' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "80b11031d10ab7a27a202514b0c13e50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 653}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 653}, "message": "move constructor 'VisibleModuleSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "9b44621e85af0d91522c7eaeec508083", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 46, "line": 661}, "message": "mark 'noexcept'"}, {"location": {"col": 21, "file": 46, "line": 661}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "d0b955f0b81f7fc38727552bd5bbf6b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 48, "line": 179}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 48, "line": 179}, "message": "default constructor 'ContentCache' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "97d3b3bda4b5d460ecdff25f2f5485f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 48, "line": 476}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 48, "line": 476}, "message": "default constructor 'SLocEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "3773968b8a1502884ed0e5ad09db23f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 51, "line": 396}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 51, "line": 396}, "message": "default constructor 'ConcurrencyState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/ASTUnit.h", "reportHash": "3b75f1061f4e0cb3e7243125065fb037", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 52, "line": 184}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 52, "line": 184}, "message": "default constructor 'CompilerInstance' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInstance.h", "reportHash": "d60634dfcc7dd25c11693963692a7d55", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 81}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 81}, "message": "default constructor 'CompilerInvocationBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h", "reportHash": "9d6b6dbbd7adfbe64fb8bd5d312d6d65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 142}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 142}, "message": "default constructor 'CompilerInvocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h", "reportHash": "c937c7520bad95e8626c0535e6070f39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 76}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 76}, "message": "default constructor 'DependencyOutputOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h", "reportHash": "27b0c3cfec22775c9f9efd921968a7ec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 113}, "message": "default constructor 'FrontendAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "reportHash": "f131e6537037f1302e3d9a30d1fe4ebc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 253}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 253}, "message": "default constructor 'ASTFrontendAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "reportHash": "7834f7921e313a0ef5fce7ec06bf515a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 56, "line": 158}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 56, "line": 158}, "message": "default constructor 'InputKind' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "reportHash": "44b304c0bb89eee122f6bf564eba64f2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 56, "line": 455}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 56, "line": 455}, "message": "default constructor 'FrontendOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "reportHash": "d0cf47bed35d4407ab412b8f139dbd0c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 57, "line": 23}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 57, "line": 23}, "message": "default constructor 'MigratorOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/MigratorOptions.h", "reportHash": "ad248d70a5b74f53aa48e448d4c2e080", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 58, "line": 150}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 58, "line": 150}, "message": "move constructor 'TempPCHFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "def50a1be5665b3051a14d3b2b29ec33", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 58, "line": 151}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 58, "line": 151}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "bcb8f2b8bd38e9d7c9b80c21c9b1652c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 58, "line": 182}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 58, "line": 182}, "message": "move constructor 'PCHStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "2bb1e88c0bc4e519607239afd522312e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 58, "line": 183}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 58, "line": 183}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "83994d04fe06eec1562481d7cbfb9eef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 59, "line": 29}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 59, "line": 29}, "message": "default constructor 'PreprocessorOutputOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PreprocessorOutputOptions.h", "reportHash": "b26e6a8680490d5ca4d3d975a03f6158", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 60, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 60, "line": 113}, "message": "default constructor 'HeaderFileInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearch.h", "reportHash": "a96aabbc7b90810974cfe6f389ed33bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 221}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 61, "line": 221}, "message": "default constructor 'HeaderSearchOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h", "reportHash": "08f17b447a4e0ee8e9276240d0ba727f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 62, "line": 85}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 62, "line": 85}, "message": "default constructor 'ModuleLoader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleLoader.h", "reportHash": "1f96ebc20bc92f30e01c2a0cdbd05349", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 63, "line": 159}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 63, "line": 159}, "message": "default constructor 'KnownHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "0bc9b8efb8286553e3c031f187f778af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 63, "line": 244}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 63, "line": 244}, "message": "default constructor 'Attributes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "ab956e37095b12d836188b359c4fe2d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 63, "line": 265}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 63, "line": 265}, "message": "default constructor 'InferredDirectory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "b2cffd25bd42512441ca06f8d632ca0d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 64, "line": 58}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 64, "line": 58}, "message": "default constructor 'MultipleIncludeOpt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h", "reportHash": "391abad3e7f5795440de8c4e346ac556", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 65, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 65, "line": 86}, "message": "default constructor 'EmptyPragmaHandler' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Pragma.h", "reportHash": "1a080002f8fadae5d8f0cd1b8dd092e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 442}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 66, "line": 442}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "14cf500c1eb49ff740df18e7433eada2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 67, "line": 625}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 67, "line": 625}, "message": "default constructor 'MacroState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "reportHash": "0986a5bbb7b7b1ae9541cbd40a218026", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 68, "line": 77}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 68, "line": 77}, "message": "default constructor 'PreprocessorLexer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h", "reportHash": "66e97b369d1eede638cee4e2f7d9faf3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 69, "line": 537}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 69, "line": 537}, "message": "default constructor 'Chunk' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "b86d33a4b3675ff22f9854fe0d50f036", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 70, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 70, "line": 46}, "message": "default constructor 'CodeCompleteOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h", "reportHash": "4a68233872b5f1a4a6270087976f66b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 71, "line": 841}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 71, "line": 841}, "message": "default constructor 'ObjCDeclSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "759de945c96672b1e4758f522f918715", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 71, "line": 1013}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 71, "line": 1013}, "message": "default constructor 'UnqualifiedId' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "792cf7535cabaaf0871e2d3075075fc7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 71, "line": 1174}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 71, "line": 1174}, "message": "default constructor 'DeclaratorChunk' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "bc4d9a0c78b16feb0e419752d7d968b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 71, "line": 1721}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 71, "line": 1721}, "message": "default constructor 'DecompositionDeclarator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "f84b6ae283f5f749535a9e7a3a5d7dbb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 71, "line": 2626}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 71, "line": 2626}, "message": "default constructor 'VirtSpecifiers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "47f31227015d4b27b9bab0b7699abd65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 71, "line": 2692}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 71, "line": 2692}, "message": "default constructor 'LambdaIntroducer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "a6ceb9d131f474987e6e0db7f09530d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 72, "line": 58}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 72, "line": 58}, "message": "default constructor 'OpaquePtr<PtrTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Ownership.h", "reportHash": "ae297d7addc9408d509dd041156f55d6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 72, "line": 157}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 72, "line": 157}, "message": "default constructor 'ActionResult<PtrTy, CompressInvalid>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Ownership.h", "reportHash": "88e8a57fc926b069268a54096e9e0db5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 72, "line": 192}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 72, "line": 192}, "message": "default constructor 'ActionResult<type-parameter-0-0, true>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Ownership.h", "reportHash": "9e4e61d200490dd0ed260417c8dd3d04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 73, "line": 70}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 73, "line": 70}, "message": "default constructor 'ParsedAttrInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "b7fc18de7db6888b22b63a0b8d6affdb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 73, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 73, "line": 123}, "message": "default constructor 'AvailabilityChange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "f21ba2d267fc77cc0bf7692334287d44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 73, "line": 413}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 73, "line": 413}, "message": "move constructor 'ParsedAttr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "1281ea3966c3d61a692c26736527da1b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 73, "line": 415}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 73, "line": 415}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "f5b25b430a74d4ba37b8f85f8dd7f434", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 73, "line": 696}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 73, "line": 696}, "message": "default constructor 'AttributeFactory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "56937f7598dd152e4ee7d91d16aa07a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 73, "line": 854}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 73, "line": 854}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "464e9e1833c6007db14a5007367a9eb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 73, "line": 863}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 73, "line": 863}, "message": "default constructor 'const_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "91591530f68a8c63ed44b0ce750d3f7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 74, "line": 96}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 74, "line": 96}, "message": "default constructor 'PCHContainerOperations' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/PCHContainerOperations.h", "reportHash": "600c8c360432caeba3ec061f62a1cb1f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 75, "line": 301}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 75, "line": 301}, "message": "default constructor 'AnalyzerOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h", "reportHash": "bcf34c31cdd2a1168b7ae45d2e4d32d6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 123}, "message": "default constructor 'NestedNameSpecifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "d47208b10c3aa6e0610fb5ce0ef52b34", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 134}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 134}, "message": "default constructor 'UnqualifiedId' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "9bbf757978a845a4eb9a689adb7d415d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 142}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 142}, "message": "default constructor 'UnknownExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "b4d8c4e830cd8452df2488036146d887", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 153}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 153}, "message": "default constructor 'CallArguments' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "8568d5d1a3ee11c1acca21fc3338bd05", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 179}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 179}, "message": "default constructor 'PrefixUnaryOperatorExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "b21e55c08128f60bc7dfcf1fcbd5b315", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 191}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 191}, "message": "default constructor 'PostfixUnaryOperatorExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "99f52e33ca9fd470544d3e632ade5a2b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 205}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 205}, "message": "default constructor 'BinaryOperatorExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "70063d8b20798dc3b4c6e07fc3f29927", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 224}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 224}, "message": "default constructor 'UnknownStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "0cc2c66778ebd12fae3e996f8a6dcb72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 231}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 231}, "message": "default constructor 'DeclarationStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "94880341f70dbca3a2dc0b9081177cc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 238}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 238}, "message": "default constructor 'EmptyStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "7211feda84ca81eb09a3a62c301cae76", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 245}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 245}, "message": "default constructor 'SwitchStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "68fb0ae3aeadfdb7d61e4bf258d51a7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 254}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 254}, "message": "default constructor 'CaseStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "d0d1d78828cd387b7d4ef8ff0d34fe30", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 264}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 264}, "message": "default constructor 'DefaultStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "5a190336e5bf8cbd1348acd9fde968cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 274}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 274}, "message": "default constructor 'IfStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "09a8bb7e5ed90d909ce2de59960644dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 285}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 285}, "message": "default constructor 'ForStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "b4de7c1435cdbcc69bf64ef047930087", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 294}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 294}, "message": "default constructor 'WhileStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "9085c19d673638401a7add296875ae0c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 303}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 303}, "message": "default constructor 'ContinueStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "9f22a40f0791559868e1bb8b557e6f1d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 311}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 311}, "message": "default constructor 'BreakStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "ad2eca3c1a27956662e65c0a8f74c2f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 320}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 320}, "message": "default constructor 'ReturnStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "556af8b145d301138f4a58f4849e2af0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 329}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 329}, "message": "default constructor 'RangeBasedForStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "686776a97c3bff7af86b6f2ef5a9d58c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 339}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 339}, "message": "default constructor 'ExpressionStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "217f9c8dd4fdec676191a2355fdce2f2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 347}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 347}, "message": "default constructor 'CompoundStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "2cd40aa6d813eef7b8254cb59654dc3e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 368}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 368}, "message": "default constructor 'UnknownDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "33e7fe9f6647902218f52dbf4b9be7d6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 375}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 375}, "message": "default constructor 'EmptyDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "618271df9f81cd7d64ddb29a8048912c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 383}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 383}, "message": "default constructor 'StaticAssertDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "baa7361033994c8399abcd7682b4f3d9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 393}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 393}, "message": "default constructor 'LinkageSpecificationDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "75ae6503deb7ae8cb551d8dfbc22c65c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 400}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 400}, "message": "default constructor 'DeclaratorList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "ae1c4df0c192d23beb0f860f6b260a36", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 412}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 412}, "message": "default constructor 'SimpleDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "7b088f688af8e58189867bf7f81903c6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 421}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 421}, "message": "default constructor 'TemplateDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "75bdadfc106854b831f3cbc7bd5a85d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 434}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 434}, "message": "default constructor 'ExplicitTemplateInstantiation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "6afa38dbffd8f9dbbbdcfecf62689239", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 445}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 445}, "message": "default constructor 'NamespaceDefinition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "a2233023fb4c4d5acb48bcd14b31aebc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 452}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 452}, "message": "default constructor 'NamespaceAliasDefinition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "a7b3a201bde8e421cea8e22c8af66d98", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 460}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 460}, "message": "default constructor 'UsingNamespaceDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "15e25a39e02265f93b558c67bdd312aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 468}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 468}, "message": "default constructor 'UsingDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "2e8e613820b0840801a94afcfb644659", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 475}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 475}, "message": "default constructor 'TypeAliasDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "99d9c828728e99bcd0ebccc55d550aa4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 501}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 501}, "message": "default constructor 'SimpleDeclarator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "4a780da9213fce38cdbe32f11c5b6f09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 510}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 510}, "message": "default constructor 'ParenDeclarator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "e64217cc9d61bdff42fd865504fac9a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 522}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 522}, "message": "default constructor 'ArraySubscript' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "1c22cc5ef8f0052f1220999095d6e800", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 534}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 534}, "message": "default constructor 'TrailingReturnType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "d03d5f086d895dd79d285d291181f132", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 547}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 547}, "message": "default constructor 'ParameterDeclarationList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "21b6fa756af727218f51a9fcbf887c92", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 567}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 567}, "message": "default constructor 'ParametersAndQualifiers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "8f3f8caa1f2f4eb94732943eb761b514", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 77, "line": 579}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 77, "line": 579}, "message": "default constructor 'MemberPointer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "dad7d9e57894f35eab0f0d5f31b95a4e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 78, "line": 93}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 78, "line": 93}, "message": "move constructor 'Node' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "bc50c79a0f8b467e5254947247068f43", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 78, "line": 94}, "message": "mark 'noexcept'"}, {"location": {"col": 9, "file": 78, "line": 94}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "556696b0786888970bc77e267e40ef2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 78, "line": 181}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 78, "line": 181}, "message": "default constructor 'ChildIteratorBase<DerivedT, NodeT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "871ffe64cb90d91b4575ff398cdcfbca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 79, "line": 100}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 79, "line": 100}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "0a9ed7e1ac2e1e3589611637a866e90a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 80, "line": 1224}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 80, "line": 1224}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "f0147f576318b69e5b308113c7d4e280", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 82, "line": 22}, "message": "mark 'noexcept'"}, {"location": {"col": 22, "file": 82, "line": 22}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "1b0a45265d8d9a3c782f6aa664e5b48f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 85, "line": 144}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 85, "line": 144}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/CachedHashString.h", "reportHash": "b9306b79ee72259656de79f23ff4b605", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 113, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 113, "line": 46}, "message": "default constructor 'DynamicLibrary' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h", "reportHash": "1baa2e16c8a67e0eba8e2452abc56318", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 125, "line": 53}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 125, "line": 53}, "message": "default constructor 'Registry<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Registry.h", "reportHash": "4d74f675a9f55a42a3faff5fad40174f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
