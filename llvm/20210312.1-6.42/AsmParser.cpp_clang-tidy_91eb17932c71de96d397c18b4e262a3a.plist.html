<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/MapVector.h", "content": "//===- llvm/ADT/MapVector.h - Map w/ deterministic value order --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a map that provides insertion order iteration. The\n// interface is purposefully minimal. The key is assumed to be cheap to copy\n// and 2 copies are kept, one for indexing in a DenseMap, one for iteration in\n// a std::vector.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_MAPVECTOR_H\n#define LLVM_ADT_MAPVECTOR_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n/// This class implements a map that also provides access to all stored values\n/// in a deterministic order. The values are kept in a std::vector and the\n/// mapping is done with DenseMap from Keys to indexes in that vector.\ntemplate<typename KeyT, typename ValueT,\n         typename MapType = DenseMap<KeyT, unsigned>,\n         typename VectorType = std::vector<std::pair<KeyT, ValueT>>>\nclass MapVector {\n  MapType Map;\n  VectorType Vector;\n\n  static_assert(\n      std::is_integral<typename MapType::mapped_type>::value,\n      \"The mapped_type of the specified Map must be an integral type\");\n\npublic:\n  using value_type = typename VectorType::value_type;\n  using size_type = typename VectorType::size_type;\n\n  using iterator = typename VectorType::iterator;\n  using const_iterator = typename VectorType::const_iterator;\n  using reverse_iterator = typename VectorType::reverse_iterator;\n  using const_reverse_iterator = typename VectorType::const_reverse_iterator;\n\n  /// Clear the MapVector and return the underlying vector.\n  VectorType takeVector() {\n    Map.clear();\n    return std::move(Vector);\n  }\n\n  size_type size() const { return Vector.size(); }\n\n  /// Grow the MapVector so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    Map.reserve(NumEntries);\n    Vector.reserve(NumEntries);\n  }\n\n  iterator begin() { return Vector.begin(); }\n  const_iterator begin() const { return Vector.begin(); }\n  iterator end() { return Vector.end(); }\n  const_iterator end() const { return Vector.end(); }\n\n  reverse_iterator rbegin() { return Vector.rbegin(); }\n  const_reverse_iterator rbegin() const { return Vector.rbegin(); }\n  reverse_iterator rend() { return Vector.rend(); }\n  const_reverse_iterator rend() const { return Vector.rend(); }\n\n  bool empty() const {\n    return Vector.empty();\n  }\n\n  std::pair<KeyT, ValueT>       &front()       { return Vector.front(); }\n  const std::pair<KeyT, ValueT> &front() const { return Vector.front(); }\n  std::pair<KeyT, ValueT>       &back()        { return Vector.back(); }\n  const std::pair<KeyT, ValueT> &back()  const { return Vector.back(); }\n\n  void clear() {\n    Map.clear();\n    Vector.clear();\n  }\n\n  void swap(MapVector &RHS) {\n    std::swap(Map, RHS.Map);\n    std::swap(Vector, RHS.Vector);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    std::pair<KeyT, typename MapType::mapped_type> Pair = std::make_pair(Key, 0);\n    std::pair<typename MapType::iterator, bool> Result = Map.insert(Pair);\n    auto &I = Result.first->second;\n    if (Result.second) {\n      Vector.push_back(std::make_pair(Key, ValueT()));\n      I = Vector.size() - 1;\n    }\n    return Vector[I].second;\n  }\n\n  // Returns a copy of the value.  Only allowed if ValueT is copyable.\n  ValueT lookup(const KeyT &Key) const {\n    static_assert(std::is_copy_constructible<ValueT>::value,\n                  \"Cannot call lookup() if ValueT is not copyable.\");\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? ValueT() : Vector[Pos->second].second;\n  }\n\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    std::pair<KeyT, typename MapType::mapped_type> Pair = std::make_pair(KV.first, 0);\n    std::pair<typename MapType::iterator, bool> Result = Map.insert(Pair);\n    auto &I = Result.first->second;\n    if (Result.second) {\n      Vector.push_back(std::make_pair(KV.first, KV.second));\n      I = Vector.size() - 1;\n      return std::make_pair(std::prev(end()), true);\n    }\n    return std::make_pair(begin() + I, false);\n  }\n\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    // Copy KV.first into the map, then move it into the vector.\n    std::pair<KeyT, typename MapType::mapped_type> Pair = std::make_pair(KV.first, 0);\n    std::pair<typename MapType::iterator, bool> Result = Map.insert(Pair);\n    auto &I = Result.first->second;\n    if (Result.second) {\n      Vector.push_back(std::move(KV));\n      I = Vector.size() - 1;\n      return std::make_pair(std::prev(end()), true);\n    }\n    return std::make_pair(begin() + I, false);\n  }\n\n  size_type count(const KeyT &Key) const {\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? 0 : 1;\n  }\n\n  iterator find(const KeyT &Key) {\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? Vector.end() :\n                            (Vector.begin() + Pos->second);\n  }\n\n  const_iterator find(const KeyT &Key) const {\n    typename MapType::const_iterator Pos = Map.find(Key);\n    return Pos == Map.end()? Vector.end() :\n                            (Vector.begin() + Pos->second);\n  }\n\n  /// Remove the last element from the vector.\n  void pop_back() {\n    typename MapType::iterator Pos = Map.find(Vector.back().first);\n    Map.erase(Pos);\n    Vector.pop_back();\n  }\n\n  /// Remove the element given by Iterator.\n  ///\n  /// Returns an iterator to the element following the one which was removed,\n  /// which may be end().\n  ///\n  /// \\note This is a deceivingly expensive operation (linear time).  It's\n  /// usually better to use \\a remove_if() if possible.\n  typename VectorType::iterator erase(typename VectorType::iterator Iterator) {\n    Map.erase(Iterator->first);\n    auto Next = Vector.erase(Iterator);\n    if (Next == Vector.end())\n      return Next;\n\n    // Update indices in the map.\n    size_t Index = Next - Vector.begin();\n    for (auto &I : Map) {\n      assert(I.second != Index && \"Index was already erased!\");\n      if (I.second > Index)\n        --I.second;\n    }\n    return Next;\n  }\n\n  /// Remove all elements with the key value Key.\n  ///\n  /// Returns the number of elements removed.\n  size_type erase(const KeyT &Key) {\n    auto Iterator = find(Key);\n    if (Iterator == end())\n      return 0;\n    erase(Iterator);\n    return 1;\n  }\n\n  /// Remove the elements that match the predicate.\n  ///\n  /// Erase all elements that match \\c Pred in a single pass.  Takes linear\n  /// time.\n  template <class Predicate> void remove_if(Predicate Pred);\n};\n\ntemplate <typename KeyT, typename ValueT, typename MapType, typename VectorType>\ntemplate <class Function>\nvoid MapVector<KeyT, ValueT, MapType, VectorType>::remove_if(Function Pred) {\n  auto O = Vector.begin();\n  for (auto I = O, E = Vector.end(); I != E; ++I) {\n    if (Pred(*I)) {\n      // Erase from the map.\n      Map.erase(I->first);\n      continue;\n    }\n\n    if (I != O) {\n      // Move the value and update the index in the map.\n      *O = std::move(*I);\n      Map[O->first] = O - Vector.begin();\n    }\n    ++O;\n  }\n  // Erase trailing entries in the vector.\n  Vector.erase(O, Vector.end());\n}\n\n/// A MapVector that performs no allocations if smaller than a certain\n/// size.\ntemplate <typename KeyT, typename ValueT, unsigned N>\nstruct SmallMapVector\n    : MapVector<KeyT, ValueT, SmallDenseMap<KeyT, unsigned, N>,\n                SmallVector<std::pair<KeyT, ValueT>, N>> {\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_MAPVECTOR_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "content": "//==-- llvm/ADT/ilist.h - Intrusive Linked List Template ---------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines classes to implement an intrusive doubly linked list class\n// (i.e. each node of the list must contain a next and previous field for the\n// list.\n//\n// The ilist class itself should be a plug in replacement for list.  This list\n// replacement does not provide a constant time size() method, so be careful to\n// use empty() when you really want to know if it's empty.\n//\n// The ilist class is implemented as a circular list.  The list itself contains\n// a sentinel node, whose Next points at begin() and whose Prev points at\n// rbegin().  The sentinel node itself serves as end() and rend().\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_H\n#define LLVM_ADT_ILIST_H\n\n#include \"llvm/ADT/simple_ilist.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace llvm {\n\n/// Use delete by default for iplist and ilist.\n///\n/// Specialize this to get different behaviour for ownership-related API.  (If\n/// you really want ownership semantics, consider using std::list or building\n/// something like \\a BumpPtrList.)\n///\n/// \\see ilist_noalloc_traits\ntemplate <typename NodeTy> struct ilist_alloc_traits {\n  static void deleteNode(NodeTy *V) { delete V; }\n};\n\n/// Custom traits to do nothing on deletion.\n///\n/// Specialize ilist_alloc_traits to inherit from this to disable the\n/// non-intrusive deletion in iplist (which implies ownership).\n///\n/// If you want purely intrusive semantics with no callbacks, consider using \\a\n/// simple_ilist instead.\n///\n/// \\code\n/// template <>\n/// struct ilist_alloc_traits<MyType> : ilist_noalloc_traits<MyType> {};\n/// \\endcode\ntemplate <typename NodeTy> struct ilist_noalloc_traits {\n  static void deleteNode(NodeTy *V) {}\n};\n\n/// Callbacks do nothing by default in iplist and ilist.\n///\n/// Specialize this for to use callbacks for when nodes change their list\n/// membership.\ntemplate <typename NodeTy> struct ilist_callback_traits {\n  void addNodeToList(NodeTy *) {}\n  void removeNodeFromList(NodeTy *) {}\n\n  /// Callback before transferring nodes to this list. The nodes may already be\n  /// in this same list.\n  template <class Iterator>\n  void transferNodesFromList(ilist_callback_traits &OldList, Iterator /*first*/,\n                             Iterator /*last*/) {\n    (void)OldList;\n  }\n};\n\n/// A fragment for template traits for intrusive list that provides default\n/// node related operations.\n///\n/// TODO: Remove this layer of indirection.  It's not necessary.\ntemplate <typename NodeTy>\nstruct ilist_node_traits : ilist_alloc_traits<NodeTy>,\n                           ilist_callback_traits<NodeTy> {};\n\n/// Template traits for intrusive list.\n///\n/// Customize callbacks and allocation semantics.\ntemplate <typename NodeTy>\nstruct ilist_traits : public ilist_node_traits<NodeTy> {};\n\n/// Const traits should never be instantiated.\ntemplate <typename Ty> struct ilist_traits<const Ty> {};\n\nnamespace ilist_detail {\n\ntemplate <class T> T &make();\n\n/// Type trait to check for a traits class that has a getNext member (as a\n/// canary for any of the ilist_nextprev_traits API).\ntemplate <class TraitsT, class NodeT> struct HasGetNext {\n  typedef char Yes[1];\n  typedef char No[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->getNext(&make<NodeT>())) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\n/// Type trait to check for a traits class that has a createSentinel member (as\n/// a canary for any of the ilist_sentinel_traits API).\ntemplate <class TraitsT> struct HasCreateSentinel {\n  typedef char Yes[1];\n  typedef char No[2];\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->createSentinel()) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\n/// Type trait to check for a traits class that has a createNode member.\n/// Allocation should be managed in a wrapper class, instead of in\n/// ilist_traits.\ntemplate <class TraitsT, class NodeT> struct HasCreateNode {\n  typedef char Yes[1];\n  typedef char No[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->createNode(make<NodeT>())) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\ntemplate <class TraitsT, class NodeT> struct HasObsoleteCustomization {\n  static const bool value = HasGetNext<TraitsT, NodeT>::value ||\n                            HasCreateSentinel<TraitsT>::value ||\n                            HasCreateNode<TraitsT, NodeT>::value;\n};\n\n} // end namespace ilist_detail\n\n//===----------------------------------------------------------------------===//\n//\n/// A wrapper around an intrusive list with callbacks and non-intrusive\n/// ownership.\n///\n/// This wraps a purely intrusive list (like simple_ilist) with a configurable\n/// traits class.  The traits can implement callbacks and customize the\n/// ownership semantics.\n///\n/// This is a subset of ilist functionality that can safely be used on nodes of\n/// polymorphic types, i.e. a heterogeneous list with a common base class that\n/// holds the next/prev pointers.  The only state of the list itself is an\n/// ilist_sentinel, which holds pointers to the first and last nodes in the\n/// list.\ntemplate <class IntrusiveListT, class TraitsT>\nclass iplist_impl : public TraitsT, IntrusiveListT {\n  typedef IntrusiveListT base_list_type;\n\npublic:\n  typedef typename base_list_type::pointer pointer;\n  typedef typename base_list_type::const_pointer const_pointer;\n  typedef typename base_list_type::reference reference;\n  typedef typename base_list_type::const_reference const_reference;\n  typedef typename base_list_type::value_type value_type;\n  typedef typename base_list_type::size_type size_type;\n  typedef typename base_list_type::difference_type difference_type;\n  typedef typename base_list_type::iterator iterator;\n  typedef typename base_list_type::const_iterator const_iterator;\n  typedef typename base_list_type::reverse_iterator reverse_iterator;\n  typedef\n      typename base_list_type::const_reverse_iterator const_reverse_iterator;\n\nprivate:\n  // TODO: Drop this assertion and the transitive type traits anytime after\n  // v4.0 is branched (i.e,. keep them for one release to help out-of-tree code\n  // update).\n  static_assert(\n      !ilist_detail::HasObsoleteCustomization<TraitsT, value_type>::value,\n      \"ilist customization points have changed!\");\n\n  static bool op_less(const_reference L, const_reference R) { return L < R; }\n  static bool op_equal(const_reference L, const_reference R) { return L == R; }\n\npublic:\n  iplist_impl() = default;\n\n  iplist_impl(const iplist_impl &) = delete;\n  iplist_impl &operator=(const iplist_impl &) = delete;\n\n  iplist_impl(iplist_impl &&X)\n      : TraitsT(std::move(static_cast<TraitsT &>(X))),\n        IntrusiveListT(std::move(static_cast<IntrusiveListT &>(X))) {}\n  iplist_impl &operator=(iplist_impl &&X) {\n    *static_cast<TraitsT *>(this) = std::move(static_cast<TraitsT &>(X));\n    *static_cast<IntrusiveListT *>(this) =\n        std::move(static_cast<IntrusiveListT &>(X));\n    return *this;\n  }\n\n  ~iplist_impl() { clear(); }\n\n  // Miscellaneous inspection routines.\n  size_type max_size() const { return size_type(-1); }\n\n  using base_list_type::begin;\n  using base_list_type::end;\n  using base_list_type::rbegin;\n  using base_list_type::rend;\n  using base_list_type::empty;\n  using base_list_type::front;\n  using base_list_type::back;\n\n  void swap(iplist_impl &RHS) {\n    assert(0 && \"Swap does not use list traits callback correctly yet!\");\n    base_list_type::swap(RHS);\n  }\n\n  iterator insert(iterator where, pointer New) {\n    this->addNodeToList(New); // Notify traits that we added a node...\n    return base_list_type::insert(where, *New);\n  }\n\n  iterator insert(iterator where, const_reference New) {\n    return this->insert(where, new value_type(New));\n  }\n\n  iterator insertAfter(iterator where, pointer New) {\n    if (empty())\n      return insert(begin(), New);\n    else\n      return insert(++where, New);\n  }\n\n  /// Clone another list.\n  template <class Cloner> void cloneFrom(const iplist_impl &L2, Cloner clone) {\n    clear();\n    for (const_reference V : L2)\n      push_back(clone(V));\n  }\n\n  pointer remove(iterator &IT) {\n    pointer Node = &*IT++;\n    this->removeNodeFromList(Node); // Notify traits that we removed a node...\n    base_list_type::remove(*Node);\n    return Node;\n  }\n\n  pointer remove(const iterator &IT) {\n    iterator MutIt = IT;\n    return remove(MutIt);\n  }\n\n  pointer remove(pointer IT) { return remove(iterator(IT)); }\n  pointer remove(reference IT) { return remove(iterator(IT)); }\n\n  // erase - remove a node from the controlled sequence... and delete it.\n  iterator erase(iterator where) {\n    this->deleteNode(remove(where));\n    return where;\n  }\n\n  iterator erase(pointer IT) { return erase(iterator(IT)); }\n  iterator erase(reference IT) { return erase(iterator(IT)); }\n\n  /// Remove all nodes from the list like clear(), but do not call\n  /// removeNodeFromList() or deleteNode().\n  ///\n  /// This should only be used immediately before freeing nodes in bulk to\n  /// avoid traversing the list and bringing all the nodes into cache.\n  void clearAndLeakNodesUnsafely() { base_list_type::clear(); }\n\nprivate:\n  // transfer - The heart of the splice function.  Move linked list nodes from\n  // [first, last) into position.\n  //\n  void transfer(iterator position, iplist_impl &L2, iterator first, iterator last) {\n    if (position == last)\n      return;\n\n    // Notify traits we moved the nodes...\n    this->transferNodesFromList(L2, first, last);\n\n    base_list_type::splice(position, L2, first, last);\n  }\n\npublic:\n  //===----------------------------------------------------------------------===\n  // Functionality derived from other functions defined above...\n  //\n\n  using base_list_type::size;\n\n  iterator erase(iterator first, iterator last) {\n    while (first != last)\n      first = erase(first);\n    return last;\n  }\n\n  void clear() { erase(begin(), end()); }\n\n  // Front and back inserters...\n  void push_front(pointer val) { insert(begin(), val); }\n  void push_back(pointer val) { insert(end(), val); }\n  void pop_front() {\n    assert(!empty() && \"pop_front() on empty list!\");\n    erase(begin());\n  }\n  void pop_back() {\n    assert(!empty() && \"pop_back() on empty list!\");\n    iterator t = end(); erase(--t);\n  }\n\n  // Special forms of insert...\n  template<class InIt> void insert(iterator where, InIt first, InIt last) {\n    for (; first != last; ++first) insert(where, *first);\n  }\n\n  // Splice members - defined in terms of transfer...\n  void splice(iterator where, iplist_impl &L2) {\n    if (!L2.empty())\n      transfer(where, L2, L2.begin(), L2.end());\n  }\n  void splice(iterator where, iplist_impl &L2, iterator first) {\n    iterator last = first; ++last;\n    if (where == first || where == last) return; // No change\n    transfer(where, L2, first, last);\n  }\n  void splice(iterator where, iplist_impl &L2, iterator first, iterator last) {\n    if (first != last) transfer(where, L2, first, last);\n  }\n  void splice(iterator where, iplist_impl &L2, reference N) {\n    splice(where, L2, iterator(N));\n  }\n  void splice(iterator where, iplist_impl &L2, pointer N) {\n    splice(where, L2, iterator(N));\n  }\n\n  template <class Compare>\n  void merge(iplist_impl &Right, Compare comp) {\n    if (this == &Right)\n      return;\n    this->transferNodesFromList(Right, Right.begin(), Right.end());\n    base_list_type::merge(Right, comp);\n  }\n  void merge(iplist_impl &Right) { return merge(Right, op_less); }\n\n  using base_list_type::sort;\n\n  /// Get the previous node, or \\c nullptr for the list head.\n  pointer getPrevNode(reference N) const {\n    auto I = N.getIterator();\n    if (I == begin())\n      return nullptr;\n    return &*std::prev(I);\n  }\n  /// Get the previous node, or \\c nullptr for the list head.\n  const_pointer getPrevNode(const_reference N) const {\n    return getPrevNode(const_cast<reference >(N));\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  pointer getNextNode(reference N) const {\n    auto Next = std::next(N.getIterator());\n    if (Next == end())\n      return nullptr;\n    return &*Next;\n  }\n  /// Get the next node, or \\c nullptr for the list tail.\n  const_pointer getNextNode(const_reference N) const {\n    return getNextNode(const_cast<reference >(N));\n  }\n};\n\n/// An intrusive list with ownership and callbacks specified/controlled by\n/// ilist_traits, only with API safe for polymorphic types.\n///\n/// The \\p Options parameters are the same as those for \\a simple_ilist.  See\n/// there for a description of what's available.\ntemplate <class T, class... Options>\nclass iplist\n    : public iplist_impl<simple_ilist<T, Options...>, ilist_traits<T>> {\n  using iplist_impl_type = typename iplist::iplist_impl;\n\npublic:\n  iplist() = default;\n\n  iplist(const iplist &X) = delete;\n  iplist &operator=(const iplist &X) = delete;\n\n  iplist(iplist &&X) : iplist_impl_type(std::move(X)) {}\n  iplist &operator=(iplist &&X) {\n    *static_cast<iplist_impl_type *>(this) = std::move(X);\n    return *this;\n  }\n};\n\ntemplate <class T, class... Options> using ilist = iplist<T, Options...>;\n\n} // end namespace llvm\n\nnamespace std {\n\n  // Ensure that swap uses the fast list swap...\n  template<class Ty>\n  void swap(llvm::iplist<Ty> &Left, llvm::iplist<Ty> &Right) {\n    Left.swap(Right);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_ILIST_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h", "content": "//===- MCAsmMacro.h - Assembly Macros ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCASMMACRO_H\n#define LLVM_MC_MCASMMACRO_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <vector>\n\nnamespace llvm {\n\n/// Target independent representation for an assembler token.\nclass AsmToken {\npublic:\n  enum TokenKind {\n    // Markers\n    Eof, Error,\n\n    // String values.\n    Identifier,\n    String,\n\n    // Integer values.\n    Integer,\n    BigNum, // larger than 64 bits\n\n    // Real values.\n    Real,\n\n    // Comments\n    Comment,\n    HashDirective,\n    // No-value.\n    EndOfStatement,\n    Colon,\n    Space,\n    Plus, Minus, Tilde,\n    Slash,     // '/'\n    BackSlash, // '\\'\n    LParen, RParen, LBrac, RBrac, LCurly, RCurly,\n    Star, Dot, Comma, Dollar, Equal, EqualEqual,\n\n    Pipe, PipePipe, Caret,\n    Amp, AmpAmp, Exclaim, ExclaimEqual, Percent, Hash,\n    Less, LessEqual, LessLess, LessGreater,\n    Greater, GreaterEqual, GreaterGreater, At, MinusGreater,\n\n    // MIPS unary expression operators such as %neg.\n    PercentCall16, PercentCall_Hi, PercentCall_Lo, PercentDtprel_Hi,\n    PercentDtprel_Lo, PercentGot, PercentGot_Disp, PercentGot_Hi, PercentGot_Lo,\n    PercentGot_Ofst, PercentGot_Page, PercentGottprel, PercentGp_Rel, PercentHi,\n    PercentHigher, PercentHighest, PercentLo, PercentNeg, PercentPcrel_Hi,\n    PercentPcrel_Lo, PercentTlsgd, PercentTlsldm, PercentTprel_Hi,\n    PercentTprel_Lo\n  };\n\nprivate:\n  TokenKind Kind;\n\n  /// A reference to the entire token contents; this is always a pointer into\n  /// a memory buffer owned by the source manager.\n  StringRef Str;\n\n  APInt IntVal;\n\npublic:\n  AsmToken() = default;\n  AsmToken(TokenKind Kind, StringRef Str, APInt IntVal)\n      : Kind(Kind), Str(Str), IntVal(std::move(IntVal)) {}\n  AsmToken(TokenKind Kind, StringRef Str, int64_t IntVal = 0)\n      : Kind(Kind), Str(Str), IntVal(64, IntVal, true) {}\n\n  TokenKind getKind() const { return Kind; }\n  bool is(TokenKind K) const { return Kind == K; }\n  bool isNot(TokenKind K) const { return Kind != K; }\n\n  SMLoc getLoc() const;\n  SMLoc getEndLoc() const;\n  SMRange getLocRange() const;\n\n  /// Get the contents of a string token (without quotes).\n  StringRef getStringContents() const {\n    assert(Kind == String && \"This token isn't a string!\");\n    return Str.slice(1, Str.size() - 1);\n  }\n\n  /// Get the identifier string for the current token, which should be an\n  /// identifier or a string. This gets the portion of the string which should\n  /// be used as the identifier, e.g., it does not include the quotes on\n  /// strings.\n  StringRef getIdentifier() const {\n    if (Kind == Identifier)\n      return getString();\n    return getStringContents();\n  }\n\n  /// Get the string for the current token, this includes all characters (for\n  /// example, the quotes on strings) in the token.\n  ///\n  /// The returned StringRef points into the source manager's memory buffer, and\n  /// is safe to store across calls to Lex().\n  StringRef getString() const { return Str; }\n\n  // FIXME: Don't compute this in advance, it makes every token larger, and is\n  // also not generally what we want (it is nicer for recovery etc. to lex 123br\n  // as a single token, then diagnose as an invalid number).\n  int64_t getIntVal() const {\n    assert(Kind == Integer && \"This token isn't an integer!\");\n    return IntVal.getZExtValue();\n  }\n\n  APInt getAPIntVal() const {\n    assert((Kind == Integer || Kind == BigNum) &&\n           \"This token isn't an integer!\");\n    return IntVal;\n  }\n\n  void dump(raw_ostream &OS) const;\n};\n\nstruct MCAsmMacroParameter {\n  StringRef Name;\n  std::vector<AsmToken> Value;\n  bool Required = false;\n  bool Vararg = false;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const { dump(dbgs()); }\n  LLVM_DUMP_METHOD void dump(raw_ostream &OS) const;\n#endif\n};\n\ntypedef std::vector<MCAsmMacroParameter> MCAsmMacroParameters;\nstruct MCAsmMacro {\n  StringRef Name;\n  StringRef Body;\n  MCAsmMacroParameters Parameters;\n  std::vector<std::string> Locals;\n  bool IsFunction = false;\n\npublic:\n  MCAsmMacro(StringRef N, StringRef B, MCAsmMacroParameters P)\n      : Name(N), Body(B), Parameters(std::move(P)) {}\n  MCAsmMacro(StringRef N, StringRef B, MCAsmMacroParameters P,\n             std::vector<std::string> L, bool F)\n      : Name(N), Body(B), Parameters(std::move(P)), Locals(std::move(L)),\n        IsFunction(F) {}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const { dump(dbgs()); }\n  LLVM_DUMP_METHOD void dump(raw_ostream &OS) const;\n#endif\n};\n} // namespace llvm\n\n#endif\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCCodeView.h", "content": "//===- MCCodeView.h - Machine Code CodeView support -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Holds state from .cv_file and .cv_loc directives for later emission.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCCODEVIEW_H\n#define LLVM_MC_MCCODEVIEW_H\n\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/MC/MCFragment.h\"\n#include \"llvm/MC/MCObjectStreamer.h\"\n#include <map>\n#include <vector>\n\nnamespace llvm {\nclass MCContext;\nclass MCObjectStreamer;\nclass MCStreamer;\nclass CodeViewContext;\n\n/// Instances of this class represent the information from a\n/// .cv_loc directive.\nclass MCCVLoc {\n  const MCSymbol *Label = nullptr;\n  uint32_t FunctionId;\n  uint32_t FileNum;\n  uint32_t Line;\n  uint16_t Column;\n  uint16_t PrologueEnd : 1;\n  uint16_t IsStmt : 1;\n\nprivate: // CodeViewContext manages these\n  friend class CodeViewContext;\n  MCCVLoc(const MCSymbol *Label, unsigned functionid, unsigned fileNum,\n          unsigned line, unsigned column, bool prologueend, bool isstmt)\n      : Label(Label), FunctionId(functionid), FileNum(fileNum), Line(line),\n        Column(column), PrologueEnd(prologueend), IsStmt(isstmt) {}\n\n  // Allow the default copy constructor and assignment operator to be used\n  // for an MCCVLoc object.\n\npublic:\n  const MCSymbol *getLabel() const { return Label; }\n\n  unsigned getFunctionId() const { return FunctionId; }\n\n  /// Get the FileNum of this MCCVLoc.\n  unsigned getFileNum() const { return FileNum; }\n\n  /// Get the Line of this MCCVLoc.\n  unsigned getLine() const { return Line; }\n\n  /// Get the Column of this MCCVLoc.\n  unsigned getColumn() const { return Column; }\n\n  bool isPrologueEnd() const { return PrologueEnd; }\n  bool isStmt() const { return IsStmt; }\n\n  void setLabel(const MCSymbol *L) { Label = L; }\n\n  void setFunctionId(unsigned FID) { FunctionId = FID; }\n\n  /// Set the FileNum of this MCCVLoc.\n  void setFileNum(unsigned fileNum) { FileNum = fileNum; }\n\n  /// Set the Line of this MCCVLoc.\n  void setLine(unsigned line) { Line = line; }\n\n  /// Set the Column of this MCCVLoc.\n  void setColumn(unsigned column) {\n    assert(column <= UINT16_MAX);\n    Column = column;\n  }\n\n  void setPrologueEnd(bool PE) { PrologueEnd = PE; }\n  void setIsStmt(bool IS) { IsStmt = IS; }\n};\n\n/// Information describing a function or inlined call site introduced by\n/// .cv_func_id or .cv_inline_site_id. Accumulates information from .cv_loc\n/// directives used with this function's id or the id of an inlined call site\n/// within this function or inlined call site.\nstruct MCCVFunctionInfo {\n  /// If this represents an inlined call site, then ParentFuncIdPlusOne will be\n  /// the parent function id plus one. If this represents a normal function,\n  /// then there is no parent, and ParentFuncIdPlusOne will be FunctionSentinel.\n  /// If this struct is an unallocated slot in the function info vector, then\n  /// ParentFuncIdPlusOne will be zero.\n  unsigned ParentFuncIdPlusOne = 0;\n\n  enum : unsigned { FunctionSentinel = ~0U };\n\n  struct LineInfo {\n    unsigned File;\n    unsigned Line;\n    unsigned Col;\n  };\n\n  LineInfo InlinedAt;\n\n  /// The section of the first .cv_loc directive used for this function, or null\n  /// if none has been seen yet.\n  MCSection *Section = nullptr;\n\n  /// Map from inlined call site id to the inlined at location to use for that\n  /// call site. Call chains are collapsed, so for the call chain 'f -> g -> h',\n  /// the InlinedAtMap of 'f' will contain entries for 'g' and 'h' that both\n  /// list the line info for the 'g' call site.\n  DenseMap<unsigned, LineInfo> InlinedAtMap;\n\n  /// Returns true if this is function info has not yet been used in a\n  /// .cv_func_id or .cv_inline_site_id directive.\n  bool isUnallocatedFunctionInfo() const { return ParentFuncIdPlusOne == 0; }\n\n  /// Returns true if this represents an inlined call site, meaning\n  /// ParentFuncIdPlusOne is neither zero nor ~0U.\n  bool isInlinedCallSite() const {\n    return !isUnallocatedFunctionInfo() &&\n           ParentFuncIdPlusOne != FunctionSentinel;\n  }\n\n  unsigned getParentFuncId() const {\n    assert(isInlinedCallSite());\n    return ParentFuncIdPlusOne - 1;\n  }\n};\n\n/// Holds state from .cv_file and .cv_loc directives for later emission.\nclass CodeViewContext {\npublic:\n  CodeViewContext();\n  ~CodeViewContext();\n\n  bool isValidFileNumber(unsigned FileNumber) const;\n  bool addFile(MCStreamer &OS, unsigned FileNumber, StringRef Filename,\n               ArrayRef<uint8_t> ChecksumBytes, uint8_t ChecksumKind);\n\n  /// Records the function id of a normal function. Returns false if the\n  /// function id has already been used, and true otherwise.\n  bool recordFunctionId(unsigned FuncId);\n\n  /// Records the function id of an inlined call site. Records the \"inlined at\"\n  /// location info of the call site, including what function or inlined call\n  /// site it was inlined into. Returns false if the function id has already\n  /// been used, and true otherwise.\n  bool recordInlinedCallSiteId(unsigned FuncId, unsigned IAFunc,\n                               unsigned IAFile, unsigned IALine,\n                               unsigned IACol);\n\n  /// Retreive the function info if this is a valid function id, or nullptr.\n  MCCVFunctionInfo *getCVFunctionInfo(unsigned FuncId);\n\n  /// Saves the information from the currently parsed .cv_loc directive\n  /// and sets CVLocSeen.  When the next instruction is assembled an entry\n  /// in the line number table with this information and the address of the\n  /// instruction will be created.\n  void recordCVLoc(MCContext &Ctx, const MCSymbol *Label, unsigned FunctionId,\n                   unsigned FileNo, unsigned Line, unsigned Column,\n                   bool PrologueEnd, bool IsStmt);\n\n  /// Add a line entry.\n  void addLineEntry(const MCCVLoc &LineEntry);\n\n  std::vector<MCCVLoc> getFunctionLineEntries(unsigned FuncId);\n\n  std::pair<size_t, size_t> getLineExtent(unsigned FuncId);\n\n  ArrayRef<MCCVLoc> getLinesForExtent(size_t L, size_t R);\n\n  /// Emits a line table substream.\n  void emitLineTableForFunction(MCObjectStreamer &OS, unsigned FuncId,\n                                const MCSymbol *FuncBegin,\n                                const MCSymbol *FuncEnd);\n\n  void emitInlineLineTableForFunction(MCObjectStreamer &OS,\n                                      unsigned PrimaryFunctionId,\n                                      unsigned SourceFileId,\n                                      unsigned SourceLineNum,\n                                      const MCSymbol *FnStartSym,\n                                      const MCSymbol *FnEndSym);\n\n  /// Encodes the binary annotations once we have a layout.\n  void encodeInlineLineTable(MCAsmLayout &Layout,\n                             MCCVInlineLineTableFragment &F);\n\n  MCFragment *\n  emitDefRange(MCObjectStreamer &OS,\n               ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,\n               StringRef FixedSizePortion);\n\n  void encodeDefRange(MCAsmLayout &Layout, MCCVDefRangeFragment &F);\n\n  /// Emits the string table substream.\n  void emitStringTable(MCObjectStreamer &OS);\n\n  /// Emits the file checksum substream.\n  void emitFileChecksums(MCObjectStreamer &OS);\n\n  /// Emits the offset into the checksum table of the given file number.\n  void emitFileChecksumOffset(MCObjectStreamer &OS, unsigned FileNo);\n\n  /// Add something to the string table.  Returns the final string as well as\n  /// offset into the string table.\n  std::pair<StringRef, unsigned> addToStringTable(StringRef S);\n\nprivate:\n  /// Map from string to string table offset.\n  StringMap<unsigned> StringTable;\n\n  /// The fragment that ultimately holds our strings.\n  MCDataFragment *StrTabFragment = nullptr;\n  bool InsertedStrTabFragment = false;\n\n  MCDataFragment *getStringTableFragment();\n\n  /// Get a string table offset.\n  unsigned getStringTableOffset(StringRef S);\n\n  struct FileInfo {\n    unsigned StringTableOffset;\n\n    // Indicates if this FileInfo corresponds to an actual file, or hasn't been\n    // set yet.\n    bool Assigned = false;\n\n    uint8_t ChecksumKind;\n\n    ArrayRef<uint8_t> Checksum;\n\n    // Checksum offset stored as a symbol because it might be requested\n    // before it has been calculated, so a fixup may be needed.\n    MCSymbol *ChecksumTableOffset;\n  };\n\n  /// Array storing added file information.\n  SmallVector<FileInfo, 4> Files;\n\n  /// The offset of the first and last .cv_loc directive for a given function\n  /// id.\n  std::map<unsigned, std::pair<size_t, size_t>> MCCVLineStartStop;\n\n  /// A collection of MCCVLoc for each section.\n  std::vector<MCCVLoc> MCCVLines;\n\n  /// All known functions and inlined call sites, indexed by function id.\n  std::vector<MCCVFunctionInfo> Functions;\n\n  /// Indicate whether we have already laid out the checksum table addresses or\n  /// not.\n  bool ChecksumOffsetsAssigned = false;\n};\n\n} // end namespace llvm\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "content": "//===- MCDwarf.h - Machine Code Dwarf support -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MCDwarfFile to support the dwarf\n// .file directive and the .loc directive.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCDWARF_H\n#define LLVM_MC_MCDWARF_H\n\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/MC/MCSection.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\nclass MCAsmBackend;\nclass MCContext;\nclass MCDwarfLineStr;\nclass MCObjectStreamer;\nclass MCStreamer;\nclass MCSymbol;\nclass raw_ostream;\nclass SMLoc;\nclass SourceMgr;\n\nnamespace mcdwarf {\n// Emit the common part of the DWARF 5 range/locations list tables header.\nMCSymbol *emitListsTableHeaderStart(MCStreamer &S);\n} // namespace mcdwarf\n\n/// Instances of this class represent the name of the dwarf .file directive and\n/// its associated dwarf file number in the MC file. MCDwarfFile's are created\n/// and uniqued by the MCContext class. In Dwarf 4 file numbers start from 1;\n/// i.e. the entry with file number 1 is the first element in the vector of\n/// DwarfFiles and there is no MCDwarfFile with file number 0. In Dwarf 5 file\n/// numbers start from 0, with the MCDwarfFile with file number 0 being the\n/// primary source file, and file numbers correspond to their index in the\n/// vector.\nstruct MCDwarfFile {\n  // The base name of the file without its directory path.\n  std::string Name;\n\n  // The index into the list of directory names for this file name.\n  unsigned DirIndex = 0;\n\n  /// The MD5 checksum, if there is one. Non-owning pointer to data allocated\n  /// in MCContext.\n  Optional<MD5::MD5Result> Checksum;\n\n  /// The source code of the file. Non-owning reference to data allocated in\n  /// MCContext.\n  Optional<StringRef> Source;\n};\n\n/// Instances of this class represent the information from a\n/// dwarf .loc directive.\nclass MCDwarfLoc {\n  uint32_t FileNum;\n  uint32_t Line;\n  uint16_t Column;\n  // Flags (see #define's below)\n  uint8_t Flags;\n  uint8_t Isa;\n  uint32_t Discriminator;\n\n// Flag that indicates the initial value of the is_stmt_start flag.\n#define DWARF2_LINE_DEFAULT_IS_STMT 1\n\n#define DWARF2_FLAG_IS_STMT (1 << 0)\n#define DWARF2_FLAG_BASIC_BLOCK (1 << 1)\n#define DWARF2_FLAG_PROLOGUE_END (1 << 2)\n#define DWARF2_FLAG_EPILOGUE_BEGIN (1 << 3)\n\nprivate: // MCContext manages these\n  friend class MCContext;\n  friend class MCDwarfLineEntry;\n\n  MCDwarfLoc(unsigned fileNum, unsigned line, unsigned column, unsigned flags,\n             unsigned isa, unsigned discriminator)\n      : FileNum(fileNum), Line(line), Column(column), Flags(flags), Isa(isa),\n        Discriminator(discriminator) {}\n\n  // Allow the default copy constructor and assignment operator to be used\n  // for an MCDwarfLoc object.\n\npublic:\n  /// Get the FileNum of this MCDwarfLoc.\n  unsigned getFileNum() const { return FileNum; }\n\n  /// Get the Line of this MCDwarfLoc.\n  unsigned getLine() const { return Line; }\n\n  /// Get the Column of this MCDwarfLoc.\n  unsigned getColumn() const { return Column; }\n\n  /// Get the Flags of this MCDwarfLoc.\n  unsigned getFlags() const { return Flags; }\n\n  /// Get the Isa of this MCDwarfLoc.\n  unsigned getIsa() const { return Isa; }\n\n  /// Get the Discriminator of this MCDwarfLoc.\n  unsigned getDiscriminator() const { return Discriminator; }\n\n  /// Set the FileNum of this MCDwarfLoc.\n  void setFileNum(unsigned fileNum) { FileNum = fileNum; }\n\n  /// Set the Line of this MCDwarfLoc.\n  void setLine(unsigned line) { Line = line; }\n\n  /// Set the Column of this MCDwarfLoc.\n  void setColumn(unsigned column) {\n    assert(column <= UINT16_MAX);\n    Column = column;\n  }\n\n  /// Set the Flags of this MCDwarfLoc.\n  void setFlags(unsigned flags) {\n    assert(flags <= UINT8_MAX);\n    Flags = flags;\n  }\n\n  /// Set the Isa of this MCDwarfLoc.\n  void setIsa(unsigned isa) {\n    assert(isa <= UINT8_MAX);\n    Isa = isa;\n  }\n\n  /// Set the Discriminator of this MCDwarfLoc.\n  void setDiscriminator(unsigned discriminator) {\n    Discriminator = discriminator;\n  }\n};\n\n/// Instances of this class represent the line information for\n/// the dwarf line table entries.  Which is created after a machine\n/// instruction is assembled and uses an address from a temporary label\n/// created at the current address in the current section and the info from\n/// the last .loc directive seen as stored in the context.\nclass MCDwarfLineEntry : public MCDwarfLoc {\n  MCSymbol *Label;\n\nprivate:\n  // Allow the default copy constructor and assignment operator to be used\n  // for an MCDwarfLineEntry object.\n\npublic:\n  // Constructor to create an MCDwarfLineEntry given a symbol and the dwarf loc.\n  MCDwarfLineEntry(MCSymbol *label, const MCDwarfLoc loc)\n      : MCDwarfLoc(loc), Label(label) {}\n\n  MCSymbol *getLabel() const { return Label; }\n\n  // This is called when an instruction is assembled into the specified\n  // section and if there is information from the last .loc directive that\n  // has yet to have a line entry made for it is made.\n  static void make(MCStreamer *MCOS, MCSection *Section);\n};\n\n/// Instances of this class represent the line information for a compile\n/// unit where machine instructions have been assembled after seeing .loc\n/// directives.  This is the information used to build the dwarf line\n/// table for a section.\nclass MCLineSection {\npublic:\n  // Add an entry to this MCLineSection's line entries.\n  void addLineEntry(const MCDwarfLineEntry &LineEntry, MCSection *Sec) {\n    MCLineDivisions[Sec].push_back(LineEntry);\n  }\n\n  using MCDwarfLineEntryCollection = std::vector<MCDwarfLineEntry>;\n  using iterator = MCDwarfLineEntryCollection::iterator;\n  using const_iterator = MCDwarfLineEntryCollection::const_iterator;\n  using MCLineDivisionMap = MapVector<MCSection *, MCDwarfLineEntryCollection>;\n\nprivate:\n  // A collection of MCDwarfLineEntry for each section.\n  MCLineDivisionMap MCLineDivisions;\n\npublic:\n  // Returns the collection of MCDwarfLineEntry for a given Compile Unit ID.\n  const MCLineDivisionMap &getMCLineEntries() const {\n    return MCLineDivisions;\n  }\n};\n\nstruct MCDwarfLineTableParams {\n  /// First special line opcode - leave room for the standard opcodes.\n  /// Note: If you want to change this, you'll have to update the\n  /// \"StandardOpcodeLengths\" table that is emitted in\n  /// \\c Emit().\n  uint8_t DWARF2LineOpcodeBase = 13;\n  /// Minimum line offset in a special line info. opcode.  The value\n  /// -5 was chosen to give a reasonable range of values.\n  int8_t DWARF2LineBase = -5;\n  /// Range of line offsets in a special line info. opcode.\n  uint8_t DWARF2LineRange = 14;\n};\n\nstruct MCDwarfLineTableHeader {\n  MCSymbol *Label = nullptr;\n  SmallVector<std::string, 3> MCDwarfDirs;\n  SmallVector<MCDwarfFile, 3> MCDwarfFiles;\n  StringMap<unsigned> SourceIdMap;\n  std::string CompilationDir;\n  MCDwarfFile RootFile;\n  bool HasSource = false;\nprivate:\n  bool HasAllMD5 = true;\n  bool HasAnyMD5 = false;\n\npublic:\n  MCDwarfLineTableHeader() = default;\n\n  Expected<unsigned> tryGetFile(StringRef &Directory, StringRef &FileName,\n                                Optional<MD5::MD5Result> Checksum,\n                                Optional<StringRef> Source,\n                                uint16_t DwarfVersion,\n                                unsigned FileNumber = 0);\n  std::pair<MCSymbol *, MCSymbol *>\n  Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n       Optional<MCDwarfLineStr> &LineStr) const;\n  std::pair<MCSymbol *, MCSymbol *>\n  Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n       ArrayRef<char> SpecialOpcodeLengths,\n       Optional<MCDwarfLineStr> &LineStr) const;\n  void resetMD5Usage() {\n    HasAllMD5 = true;\n    HasAnyMD5 = false;\n  }\n  void trackMD5Usage(bool MD5Used) {\n    HasAllMD5 &= MD5Used;\n    HasAnyMD5 |= MD5Used;\n  }\n  bool isMD5UsageConsistent() const {\n    return MCDwarfFiles.empty() || (HasAllMD5 == HasAnyMD5);\n  }\n\n  void setRootFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum,\n                   Optional<StringRef> Source) {\n    CompilationDir = std::string(Directory);\n    RootFile.Name = std::string(FileName);\n    RootFile.DirIndex = 0;\n    RootFile.Checksum = Checksum;\n    RootFile.Source = Source;\n    trackMD5Usage(Checksum.hasValue());\n    HasSource = Source.hasValue();\n  }\n\n  void resetFileTable() {\n    MCDwarfDirs.clear();\n    MCDwarfFiles.clear();\n    RootFile.Name.clear();\n    resetMD5Usage();\n    HasSource = false;\n  }\n\nprivate:\n  void emitV2FileDirTables(MCStreamer *MCOS) const;\n  void emitV5FileDirTables(MCStreamer *MCOS, Optional<MCDwarfLineStr> &LineStr) const;\n};\n\nclass MCDwarfDwoLineTable {\n  MCDwarfLineTableHeader Header;\n  bool HasSplitLineTable = false;\n\npublic:\n  void maybeSetRootFile(StringRef Directory, StringRef FileName,\n                        Optional<MD5::MD5Result> Checksum,\n                        Optional<StringRef> Source) {\n    if (!Header.RootFile.Name.empty())\n      return;\n    Header.setRootFile(Directory, FileName, Checksum, Source);\n  }\n\n  unsigned getFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum, uint16_t DwarfVersion,\n                   Optional<StringRef> Source) {\n    HasSplitLineTable = true;\n    return cantFail(Header.tryGetFile(Directory, FileName, Checksum, Source,\n                                      DwarfVersion));\n  }\n\n  void Emit(MCStreamer &MCOS, MCDwarfLineTableParams Params,\n            MCSection *Section) const;\n};\n\nclass MCDwarfLineTable {\n  MCDwarfLineTableHeader Header;\n  MCLineSection MCLineSections;\n\npublic:\n  // This emits the Dwarf file and the line tables for all Compile Units.\n  static void emit(MCStreamer *MCOS, MCDwarfLineTableParams Params);\n\n  // This emits the Dwarf file and the line tables for a given Compile Unit.\n  void emitCU(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n              Optional<MCDwarfLineStr> &LineStr) const;\n\n  Expected<unsigned> tryGetFile(StringRef &Directory, StringRef &FileName,\n                                Optional<MD5::MD5Result> Checksum,\n                                Optional<StringRef> Source,\n                                uint16_t DwarfVersion,\n                                unsigned FileNumber = 0);\n  unsigned getFile(StringRef &Directory, StringRef &FileName,\n                   Optional<MD5::MD5Result> Checksum, Optional<StringRef> Source,\n                   uint16_t DwarfVersion, unsigned FileNumber = 0) {\n    return cantFail(tryGetFile(Directory, FileName, Checksum, Source,\n                               DwarfVersion, FileNumber));\n  }\n\n  void setRootFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum, Optional<StringRef> Source) {\n    Header.CompilationDir = std::string(Directory);\n    Header.RootFile.Name = std::string(FileName);\n    Header.RootFile.DirIndex = 0;\n    Header.RootFile.Checksum = Checksum;\n    Header.RootFile.Source = Source;\n    Header.trackMD5Usage(Checksum.hasValue());\n    Header.HasSource = Source.hasValue();\n  }\n\n  void resetFileTable() { Header.resetFileTable(); }\n\n  bool hasRootFile() const { return !Header.RootFile.Name.empty(); }\n\n  const MCDwarfFile &getRootFile() const { return Header.RootFile; }\n\n  // Report whether MD5 usage has been consistent (all-or-none).\n  bool isMD5UsageConsistent() const { return Header.isMD5UsageConsistent(); }\n\n  MCSymbol *getLabel() const {\n    return Header.Label;\n  }\n\n  void setLabel(MCSymbol *Label) {\n    Header.Label = Label;\n  }\n\n  const SmallVectorImpl<std::string> &getMCDwarfDirs() const {\n    return Header.MCDwarfDirs;\n  }\n\n  SmallVectorImpl<std::string> &getMCDwarfDirs() {\n    return Header.MCDwarfDirs;\n  }\n\n  const SmallVectorImpl<MCDwarfFile> &getMCDwarfFiles() const {\n    return Header.MCDwarfFiles;\n  }\n\n  SmallVectorImpl<MCDwarfFile> &getMCDwarfFiles() {\n    return Header.MCDwarfFiles;\n  }\n\n  const MCLineSection &getMCLineSections() const {\n    return MCLineSections;\n  }\n  MCLineSection &getMCLineSections() {\n    return MCLineSections;\n  }\n};\n\nclass MCDwarfLineAddr {\npublic:\n  /// Utility function to encode a Dwarf pair of LineDelta and AddrDeltas.\n  static void Encode(MCContext &Context, MCDwarfLineTableParams Params,\n                     int64_t LineDelta, uint64_t AddrDelta, raw_ostream &OS);\n\n  /// Utility function to encode a Dwarf pair of LineDelta and AddrDeltas using\n  /// fixed length operands. Returns (Offset, Size, SetDelta).\n  static std::tuple<uint32_t, uint32_t, bool> fixedEncode(MCContext &Context,\n                                                          int64_t LineDelta,\n                                                          uint64_t AddrDelta,\n                                                          raw_ostream &OS);\n\n  /// Utility function to emit the encoding to a streamer.\n  static void Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n                   int64_t LineDelta, uint64_t AddrDelta);\n};\n\nclass MCGenDwarfInfo {\npublic:\n  //\n  // When generating dwarf for assembly source files this emits the Dwarf\n  // sections.\n  //\n  static void Emit(MCStreamer *MCOS);\n};\n\n// When generating dwarf for assembly source files this is the info that is\n// needed to be gathered for each symbol that will have a dwarf label.\nclass MCGenDwarfLabelEntry {\nprivate:\n  // Name of the symbol without a leading underbar, if any.\n  StringRef Name;\n  // The dwarf file number this symbol is in.\n  unsigned FileNumber;\n  // The line number this symbol is at.\n  unsigned LineNumber;\n  // The low_pc for the dwarf label is taken from this symbol.\n  MCSymbol *Label;\n\npublic:\n  MCGenDwarfLabelEntry(StringRef name, unsigned fileNumber, unsigned lineNumber,\n                       MCSymbol *label)\n      : Name(name), FileNumber(fileNumber), LineNumber(lineNumber),\n        Label(label) {}\n\n  StringRef getName() const { return Name; }\n  unsigned getFileNumber() const { return FileNumber; }\n  unsigned getLineNumber() const { return LineNumber; }\n  MCSymbol *getLabel() const { return Label; }\n\n  // This is called when label is created when we are generating dwarf for\n  // assembly source files.\n  static void Make(MCSymbol *Symbol, MCStreamer *MCOS, SourceMgr &SrcMgr,\n                   SMLoc &Loc);\n};\n\nclass MCCFIInstruction {\npublic:\n  enum OpType {\n    OpSameValue,\n    OpRememberState,\n    OpRestoreState,\n    OpOffset,\n    OpDefCfaRegister,\n    OpDefCfaOffset,\n    OpDefCfa,\n    OpRelOffset,\n    OpAdjustCfaOffset,\n    OpEscape,\n    OpRestore,\n    OpUndefined,\n    OpRegister,\n    OpWindowSave,\n    OpNegateRAState,\n    OpGnuArgsSize\n  };\n\nprivate:\n  OpType Operation;\n  MCSymbol *Label;\n  unsigned Register;\n  union {\n    int Offset;\n    unsigned Register2;\n  };\n  std::vector<char> Values;\n  std::string Comment;\n\n  MCCFIInstruction(OpType Op, MCSymbol *L, unsigned R, int O, StringRef V,\n                   StringRef Comment = \"\")\n      : Operation(Op), Label(L), Register(R), Offset(O),\n        Values(V.begin(), V.end()), Comment(Comment) {\n    assert(Op != OpRegister);\n  }\n\n  MCCFIInstruction(OpType Op, MCSymbol *L, unsigned R1, unsigned R2)\n      : Operation(Op), Label(L), Register(R1), Register2(R2) {\n    assert(Op == OpRegister);\n  }\n\npublic:\n  /// .cfi_def_cfa defines a rule for computing CFA as: take address from\n  /// Register and add Offset to it.\n  static MCCFIInstruction cfiDefCfa(MCSymbol *L, unsigned Register,\n                                    int Offset) {\n    return MCCFIInstruction(OpDefCfa, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_def_cfa_register modifies a rule for computing CFA. From now\n  /// on Register will be used instead of the old one. Offset remains the same.\n  static MCCFIInstruction createDefCfaRegister(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpDefCfaRegister, L, Register, 0, \"\");\n  }\n\n  /// .cfi_def_cfa_offset modifies a rule for computing CFA. Register\n  /// remains the same, but offset is new. Note that it is the absolute offset\n  /// that will be added to a defined register to the compute CFA address.\n  static MCCFIInstruction cfiDefCfaOffset(MCSymbol *L, int Offset) {\n    return MCCFIInstruction(OpDefCfaOffset, L, 0, Offset, \"\");\n  }\n\n  /// .cfi_adjust_cfa_offset Same as .cfi_def_cfa_offset, but\n  /// Offset is a relative value that is added/subtracted from the previous\n  /// offset.\n  static MCCFIInstruction createAdjustCfaOffset(MCSymbol *L, int Adjustment) {\n    return MCCFIInstruction(OpAdjustCfaOffset, L, 0, Adjustment, \"\");\n  }\n\n  /// .cfi_offset Previous value of Register is saved at offset Offset\n  /// from CFA.\n  static MCCFIInstruction createOffset(MCSymbol *L, unsigned Register,\n                                       int Offset) {\n    return MCCFIInstruction(OpOffset, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_rel_offset Previous value of Register is saved at offset\n  /// Offset from the current CFA register. This is transformed to .cfi_offset\n  /// using the known displacement of the CFA register from the CFA.\n  static MCCFIInstruction createRelOffset(MCSymbol *L, unsigned Register,\n                                          int Offset) {\n    return MCCFIInstruction(OpRelOffset, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_register Previous value of Register1 is saved in\n  /// register Register2.\n  static MCCFIInstruction createRegister(MCSymbol *L, unsigned Register1,\n                                         unsigned Register2) {\n    return MCCFIInstruction(OpRegister, L, Register1, Register2);\n  }\n\n  /// .cfi_window_save SPARC register window is saved.\n  static MCCFIInstruction createWindowSave(MCSymbol *L) {\n    return MCCFIInstruction(OpWindowSave, L, 0, 0, \"\");\n  }\n\n  /// .cfi_negate_ra_state AArch64 negate RA state.\n  static MCCFIInstruction createNegateRAState(MCSymbol *L) {\n    return MCCFIInstruction(OpNegateRAState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_restore says that the rule for Register is now the same as it\n  /// was at the beginning of the function, after all initial instructions added\n  /// by .cfi_startproc were executed.\n  static MCCFIInstruction createRestore(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpRestore, L, Register, 0, \"\");\n  }\n\n  /// .cfi_undefined From now on the previous value of Register can't be\n  /// restored anymore.\n  static MCCFIInstruction createUndefined(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpUndefined, L, Register, 0, \"\");\n  }\n\n  /// .cfi_same_value Current value of Register is the same as in the\n  /// previous frame. I.e., no restoration is needed.\n  static MCCFIInstruction createSameValue(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpSameValue, L, Register, 0, \"\");\n  }\n\n  /// .cfi_remember_state Save all current rules for all registers.\n  static MCCFIInstruction createRememberState(MCSymbol *L) {\n    return MCCFIInstruction(OpRememberState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_restore_state Restore the previously saved state.\n  static MCCFIInstruction createRestoreState(MCSymbol *L) {\n    return MCCFIInstruction(OpRestoreState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_escape Allows the user to add arbitrary bytes to the unwind\n  /// info.\n  static MCCFIInstruction createEscape(MCSymbol *L, StringRef Vals,\n                                       StringRef Comment = \"\") {\n    return MCCFIInstruction(OpEscape, L, 0, 0, Vals, Comment);\n  }\n\n  /// A special wrapper for .cfi_escape that indicates GNU_ARGS_SIZE\n  static MCCFIInstruction createGnuArgsSize(MCSymbol *L, int Size) {\n    return MCCFIInstruction(OpGnuArgsSize, L, 0, Size, \"\");\n  }\n\n  OpType getOperation() const { return Operation; }\n  MCSymbol *getLabel() const { return Label; }\n\n  unsigned getRegister() const {\n    assert(Operation == OpDefCfa || Operation == OpOffset ||\n           Operation == OpRestore || Operation == OpUndefined ||\n           Operation == OpSameValue || Operation == OpDefCfaRegister ||\n           Operation == OpRelOffset || Operation == OpRegister);\n    return Register;\n  }\n\n  unsigned getRegister2() const {\n    assert(Operation == OpRegister);\n    return Register2;\n  }\n\n  int getOffset() const {\n    assert(Operation == OpDefCfa || Operation == OpOffset ||\n           Operation == OpRelOffset || Operation == OpDefCfaOffset ||\n           Operation == OpAdjustCfaOffset || Operation == OpGnuArgsSize);\n    return Offset;\n  }\n\n  StringRef getValues() const {\n    assert(Operation == OpEscape);\n    return StringRef(&Values[0], Values.size());\n  }\n\n  StringRef getComment() const {\n    return Comment;\n  }\n};\n\nstruct MCDwarfFrameInfo {\n  MCDwarfFrameInfo() = default;\n\n  MCSymbol *Begin = nullptr;\n  MCSymbol *End = nullptr;\n  const MCSymbol *Personality = nullptr;\n  const MCSymbol *Lsda = nullptr;\n  std::vector<MCCFIInstruction> Instructions;\n  unsigned CurrentCfaRegister = 0;\n  unsigned PersonalityEncoding = 0;\n  unsigned LsdaEncoding = 0;\n  uint32_t CompactUnwindEncoding = 0;\n  bool IsSignalFrame = false;\n  bool IsSimple = false;\n  unsigned RAReg = static_cast<unsigned>(INT_MAX);\n  bool IsBKeyFrame = false;\n};\n\nclass MCDwarfFrameEmitter {\npublic:\n  //\n  // This emits the frame info section.\n  //\n  static void Emit(MCObjectStreamer &streamer, MCAsmBackend *MAB, bool isEH);\n  static void EmitAdvanceLoc(MCObjectStreamer &Streamer, uint64_t AddrDelta);\n  static void EncodeAdvanceLoc(MCContext &Context, uint64_t AddrDelta,\n                               raw_ostream &OS, uint32_t *Offset = nullptr,\n                               uint32_t *Size = nullptr);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCDWARF_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h", "content": "//===- MCLinkerOptimizationHint.h - LOH interface ---------------*- C++ -*-===//\n//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares some helpers classes to handle Linker Optimization Hint\n// (LOH).\n//\n// FIXME: LOH interface supports only MachO format at the moment.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCLINKEROPTIMIZATIONHINT_H\n#define LLVM_MC_MCLINKEROPTIMIZATIONHINT_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\n\nclass MachObjectWriter;\nclass MCAsmLayout;\nclass MCSymbol;\n\n/// Linker Optimization Hint Type.\nenum MCLOHType {\n  MCLOH_AdrpAdrp = 0x1u,      ///< Adrp xY, _v1@PAGE -> Adrp xY, _v2@PAGE.\n  MCLOH_AdrpLdr = 0x2u,       ///< Adrp _v@PAGE -> Ldr _v@PAGEOFF.\n  MCLOH_AdrpAddLdr = 0x3u,    ///< Adrp _v@PAGE -> Add _v@PAGEOFF -> Ldr.\n  MCLOH_AdrpLdrGotLdr = 0x4u, ///< Adrp _v@GOTPAGE -> Ldr _v@GOTPAGEOFF -> Ldr.\n  MCLOH_AdrpAddStr = 0x5u,    ///< Adrp _v@PAGE -> Add _v@PAGEOFF -> Str.\n  MCLOH_AdrpLdrGotStr = 0x6u, ///< Adrp _v@GOTPAGE -> Ldr _v@GOTPAGEOFF -> Str.\n  MCLOH_AdrpAdd = 0x7u,       ///< Adrp _v@PAGE -> Add _v@PAGEOFF.\n  MCLOH_AdrpLdrGot = 0x8u     ///< Adrp _v@GOTPAGE -> Ldr _v@GOTPAGEOFF.\n};\n\nstatic inline StringRef MCLOHDirectiveName() {\n  return StringRef(\".loh\");\n}\n\nstatic inline bool isValidMCLOHType(unsigned Kind) {\n  return Kind >= MCLOH_AdrpAdrp && Kind <= MCLOH_AdrpLdrGot;\n}\n\nstatic inline int MCLOHNameToId(StringRef Name) {\n#define MCLOHCaseNameToId(Name)     .Case(#Name, MCLOH_ ## Name)\n  return StringSwitch<int>(Name)\n    MCLOHCaseNameToId(AdrpAdrp)\n    MCLOHCaseNameToId(AdrpLdr)\n    MCLOHCaseNameToId(AdrpAddLdr)\n    MCLOHCaseNameToId(AdrpLdrGotLdr)\n    MCLOHCaseNameToId(AdrpAddStr)\n    MCLOHCaseNameToId(AdrpLdrGotStr)\n    MCLOHCaseNameToId(AdrpAdd)\n    MCLOHCaseNameToId(AdrpLdrGot)\n    .Default(-1);\n#undef MCLOHCaseNameToId\n}\n\nstatic inline StringRef MCLOHIdToName(MCLOHType Kind) {\n#define MCLOHCaseIdToName(Name)      case MCLOH_ ## Name: return StringRef(#Name);\n  switch (Kind) {\n    MCLOHCaseIdToName(AdrpAdrp);\n    MCLOHCaseIdToName(AdrpLdr);\n    MCLOHCaseIdToName(AdrpAddLdr);\n    MCLOHCaseIdToName(AdrpLdrGotLdr);\n    MCLOHCaseIdToName(AdrpAddStr);\n    MCLOHCaseIdToName(AdrpLdrGotStr);\n    MCLOHCaseIdToName(AdrpAdd);\n    MCLOHCaseIdToName(AdrpLdrGot);\n  }\n  return StringRef();\n#undef MCLOHCaseIdToName\n}\n\nstatic inline int MCLOHIdToNbArgs(MCLOHType Kind) {\n  switch (Kind) {\n    // LOH with two arguments\n  case MCLOH_AdrpAdrp:\n  case MCLOH_AdrpLdr:\n  case MCLOH_AdrpAdd:\n  case MCLOH_AdrpLdrGot:\n    return 2;\n    // LOH with three arguments\n  case MCLOH_AdrpAddLdr:\n  case MCLOH_AdrpLdrGotLdr:\n  case MCLOH_AdrpAddStr:\n  case MCLOH_AdrpLdrGotStr:\n    return 3;\n  }\n  return -1;\n}\n\n/// Store Linker Optimization Hint information (LOH).\nclass MCLOHDirective {\n  MCLOHType Kind;\n\n  /// Arguments of this directive. Order matters.\n  SmallVector<MCSymbol *, 3> Args;\n\n  /// Emit this directive in \\p OutStream using the information available\n  /// in the given \\p ObjWriter and \\p Layout to get the address of the\n  /// arguments within the object file.\n  void emit_impl(raw_ostream &OutStream, const MachObjectWriter &ObjWriter,\n                 const MCAsmLayout &Layout) const;\n\npublic:\n  using LOHArgs = SmallVectorImpl<MCSymbol *>;\n\n  MCLOHDirective(MCLOHType Kind, const LOHArgs &Args)\n      : Kind(Kind), Args(Args.begin(), Args.end()) {\n    assert(isValidMCLOHType(Kind) && \"Invalid LOH directive type!\");\n  }\n\n  MCLOHType getKind() const { return Kind; }\n\n  const LOHArgs &getArgs() const { return Args; }\n\n  /// Emit this directive as:\n  /// <kind, numArgs, addr1, ..., addrN>\n  void emit(MachObjectWriter &ObjWriter, const MCAsmLayout &Layout) const;\n\n  /// Get the size in bytes of this directive if emitted in \\p ObjWriter with\n  /// the given \\p Layout.\n  uint64_t getEmitSize(const MachObjectWriter &ObjWriter,\n                       const MCAsmLayout &Layout) const;\n};\n\nclass MCLOHContainer {\n  /// Keep track of the emit size of all the LOHs.\n  mutable uint64_t EmitSize = 0;\n\n  /// Keep track of all LOH directives.\n  SmallVector<MCLOHDirective, 32> Directives;\n\npublic:\n  using LOHDirectives = SmallVectorImpl<MCLOHDirective>;\n\n  MCLOHContainer() = default;\n\n  /// Const accessor to the directives.\n  const LOHDirectives &getDirectives() const {\n    return Directives;\n  }\n\n  /// Add the directive of the given kind \\p Kind with the given arguments\n  /// \\p Args to the container.\n  void addDirective(MCLOHType Kind, const MCLOHDirective::LOHArgs &Args) {\n    Directives.push_back(MCLOHDirective(Kind, Args));\n  }\n\n  /// Get the size of the directives if emitted.\n  uint64_t getEmitSize(const MachObjectWriter &ObjWriter,\n                       const MCAsmLayout &Layout) const {\n    if (!EmitSize) {\n      for (const MCLOHDirective &D : Directives)\n        EmitSize += D.getEmitSize(ObjWriter, Layout);\n    }\n    return EmitSize;\n  }\n\n  /// Emit all Linker Optimization Hint in one big table.\n  /// Each line of the table is emitted by LOHDirective::emit.\n  void emit(MachObjectWriter &ObjWriter, const MCAsmLayout &Layout) const {\n    for (const MCLOHDirective &D : Directives)\n      D.emit(ObjWriter, Layout);\n  }\n\n  void reset() {\n    Directives.clear();\n    EmitSize = 0;\n  }\n};\n\n// Add types for specialized template using MCSymbol.\nusing MCLOHArgs = MCLOHDirective::LOHArgs;\nusing MCLOHDirectives = MCLOHContainer::LOHDirectives;\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCLINKEROPTIMIZATIONHINT_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp", "content": "//===- AsmParser.cpp - Parser for Assembly Files --------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class implements a parser for assembly files similar to gas syntax.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/CodeView/SymbolRecord.h\"\n#include \"llvm/MC/MCAsmInfo.h\"\n#include \"llvm/MC/MCCodeView.h\"\n#include \"llvm/MC/MCContext.h\"\n#include \"llvm/MC/MCDirectives.h\"\n#include \"llvm/MC/MCDwarf.h\"\n#include \"llvm/MC/MCExpr.h\"\n#include \"llvm/MC/MCInstPrinter.h\"\n#include \"llvm/MC/MCInstrDesc.h\"\n#include \"llvm/MC/MCInstrInfo.h\"\n#include \"llvm/MC/MCObjectFileInfo.h\"\n#include \"llvm/MC/MCParser/AsmCond.h\"\n#include \"llvm/MC/MCParser/AsmLexer.h\"\n#include \"llvm/MC/MCParser/MCAsmLexer.h\"\n#include \"llvm/MC/MCParser/MCAsmParser.h\"\n#include \"llvm/MC/MCParser/MCAsmParserExtension.h\"\n#include \"llvm/MC/MCParser/MCAsmParserUtils.h\"\n#include \"llvm/MC/MCParser/MCParsedAsmOperand.h\"\n#include \"llvm/MC/MCParser/MCTargetAsmParser.h\"\n#include \"llvm/MC/MCRegisterInfo.h\"\n#include \"llvm/MC/MCSection.h\"\n#include \"llvm/MC/MCStreamer.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n#include \"llvm/MC/MCValue.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MD5.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <deque>\n#include <memory>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\nMCAsmParserSemaCallback::~MCAsmParserSemaCallback() = default;\n\nextern cl::opt<unsigned> AsmMacroMaxNestingDepth;\n\nnamespace {\n\n/// Helper types for tracking macro definitions.\ntypedef std::vector<AsmToken> MCAsmMacroArgument;\ntypedef std::vector<MCAsmMacroArgument> MCAsmMacroArguments;\n\n/// Helper class for storing information about an active macro\n/// instantiation.\nstruct MacroInstantiation {\n  /// The location of the instantiation.\n  SMLoc InstantiationLoc;\n\n  /// The buffer where parsing should resume upon instantiation completion.\n  unsigned ExitBuffer;\n\n  /// The location where parsing should resume upon instantiation completion.\n  SMLoc ExitLoc;\n\n  /// The depth of TheCondStack at the start of the instantiation.\n  size_t CondStackDepth;\n};\n\nstruct ParseStatementInfo {\n  /// The parsed operands from the last parsed statement.\n  SmallVector<std::unique_ptr<MCParsedAsmOperand>, 8> ParsedOperands;\n\n  /// The opcode from the last parsed instruction.\n  unsigned Opcode = ~0U;\n\n  /// Was there an error parsing the inline assembly?\n  bool ParseError = false;\n\n  SmallVectorImpl<AsmRewrite> *AsmRewrites = nullptr;\n\n  ParseStatementInfo() = delete;\n  ParseStatementInfo(SmallVectorImpl<AsmRewrite> *rewrites)\n    : AsmRewrites(rewrites) {}\n};\n\n/// The concrete assembly parser instance.\nclass AsmParser : public MCAsmParser {\nprivate:\n  AsmLexer Lexer;\n  MCContext &Ctx;\n  MCStreamer &Out;\n  const MCAsmInfo &MAI;\n  SourceMgr &SrcMgr;\n  SourceMgr::DiagHandlerTy SavedDiagHandler;\n  void *SavedDiagContext;\n  std::unique_ptr<MCAsmParserExtension> PlatformParser;\n  SMLoc StartTokLoc;\n\n  /// This is the current buffer index we're lexing from as managed by the\n  /// SourceMgr object.\n  unsigned CurBuffer;\n\n  AsmCond TheCondState;\n  std::vector<AsmCond> TheCondStack;\n\n  /// maps directive names to handler methods in parser\n  /// extensions. Extensions register themselves in this map by calling\n  /// addDirectiveHandler.\n  StringMap<ExtensionDirectiveHandler> ExtensionDirectiveMap;\n\n  /// Stack of active macro instantiations.\n  std::vector<MacroInstantiation*> ActiveMacros;\n\n  /// List of bodies of anonymous macros.\n  std::deque<MCAsmMacro> MacroLikeBodies;\n\n  /// Boolean tracking whether macro substitution is enabled.\n  unsigned MacrosEnabledFlag : 1;\n\n  /// Keeps track of how many .macro's have been instantiated.\n  unsigned NumOfMacroInstantiations;\n\n  /// The values from the last parsed cpp hash file line comment if any.\n  struct CppHashInfoTy {\n    StringRef Filename;\n    int64_t LineNumber;\n    SMLoc Loc;\n    unsigned Buf;\n    CppHashInfoTy() : Filename(), LineNumber(0), Loc(), Buf(0) {}\n  };\n  CppHashInfoTy CppHashInfo;\n\n  /// The filename from the first cpp hash file line comment, if any.\n  StringRef FirstCppHashFilename;\n\n  /// List of forward directional labels for diagnosis at the end.\n  SmallVector<std::tuple<SMLoc, CppHashInfoTy, MCSymbol *>, 4> DirLabels;\n\n  /// AssemblerDialect. ~OU means unset value and use value provided by MAI.\n  unsigned AssemblerDialect = ~0U;\n\n  /// is Darwin compatibility enabled?\n  bool IsDarwin = false;\n\n  /// Are we parsing ms-style inline assembly?\n  bool ParsingMSInlineAsm = false;\n\n  /// Did we already inform the user about inconsistent MD5 usage?\n  bool ReportedInconsistentMD5 = false;\n\n  // Is alt macro mode enabled.\n  bool AltMacroMode = false;\n\npublic:\n  AsmParser(SourceMgr &SM, MCContext &Ctx, MCStreamer &Out,\n            const MCAsmInfo &MAI, unsigned CB);\n  AsmParser(const AsmParser &) = delete;\n  AsmParser &operator=(const AsmParser &) = delete;\n  ~AsmParser() override;\n\n  bool Run(bool NoInitialTextSection, bool NoFinalize = false) override;\n\n  void addDirectiveHandler(StringRef Directive,\n                           ExtensionDirectiveHandler Handler) override {\n    ExtensionDirectiveMap[Directive] = Handler;\n  }\n\n  void addAliasForDirective(StringRef Directive, StringRef Alias) override {\n    DirectiveKindMap[Directive.lower()] = DirectiveKindMap[Alias.lower()];\n  }\n\n  /// @name MCAsmParser Interface\n  /// {\n\n  SourceMgr &getSourceManager() override { return SrcMgr; }\n  MCAsmLexer &getLexer() override { return Lexer; }\n  MCContext &getContext() override { return Ctx; }\n  MCStreamer &getStreamer() override { return Out; }\n\n  CodeViewContext &getCVContext() { return Ctx.getCVContext(); }\n\n  unsigned getAssemblerDialect() override {\n    if (AssemblerDialect == ~0U)\n      return MAI.getAssemblerDialect();\n    else\n      return AssemblerDialect;\n  }\n  void setAssemblerDialect(unsigned i) override {\n    AssemblerDialect = i;\n  }\n\n  void Note(SMLoc L, const Twine &Msg, SMRange Range = None) override;\n  bool Warning(SMLoc L, const Twine &Msg, SMRange Range = None) override;\n  bool printError(SMLoc L, const Twine &Msg, SMRange Range = None) override;\n\n  const AsmToken &Lex() override;\n\n  void setParsingMSInlineAsm(bool V) override {\n    ParsingMSInlineAsm = V;\n    // When parsing MS inline asm, we must lex 0b1101 and 0ABCH as binary and\n    // hex integer literals.\n    Lexer.setLexMasmIntegers(V);\n  }\n  bool isParsingMSInlineAsm() override { return ParsingMSInlineAsm; }\n\n  bool parseMSInlineAsm(void *AsmLoc, std::string &AsmString,\n                        unsigned &NumOutputs, unsigned &NumInputs,\n                        SmallVectorImpl<std::pair<void *,bool>> &OpDecls,\n                        SmallVectorImpl<std::string> &Constraints,\n                        SmallVectorImpl<std::string> &Clobbers,\n                        const MCInstrInfo *MII, const MCInstPrinter *IP,\n                        MCAsmParserSemaCallback &SI) override;\n\n  bool parseExpression(const MCExpr *&Res);\n  bool parseExpression(const MCExpr *&Res, SMLoc &EndLoc) override;\n  bool parsePrimaryExpr(const MCExpr *&Res, SMLoc &EndLoc,\n                        AsmTypeInfo *TypeInfo) override;\n  bool parseParenExpression(const MCExpr *&Res, SMLoc &EndLoc) override;\n  bool parseParenExprOfDepth(unsigned ParenDepth, const MCExpr *&Res,\n                             SMLoc &EndLoc) override;\n  bool parseAbsoluteExpression(int64_t &Res) override;\n\n  /// Parse a floating point expression using the float \\p Semantics\n  /// and set \\p Res to the value.\n  bool parseRealValue(const fltSemantics &Semantics, APInt &Res);\n\n  /// Parse an identifier or string (as a quoted identifier)\n  /// and set \\p Res to the identifier contents.\n  bool parseIdentifier(StringRef &Res) override;\n  void eatToEndOfStatement() override;\n\n  bool checkForValidSection() override;\n\n  /// }\n\nprivate:\n  bool parseStatement(ParseStatementInfo &Info,\n                      MCAsmParserSemaCallback *SI);\n  bool parseCurlyBlockScope(SmallVectorImpl<AsmRewrite>& AsmStrRewrites);\n  bool parseCppHashLineFilenameComment(SMLoc L, bool SaveLocInfo = true);\n\n  void checkForBadMacro(SMLoc DirectiveLoc, StringRef Name, StringRef Body,\n                        ArrayRef<MCAsmMacroParameter> Parameters);\n  bool expandMacro(raw_svector_ostream &OS, StringRef Body,\n                   ArrayRef<MCAsmMacroParameter> Parameters,\n                   ArrayRef<MCAsmMacroArgument> A, bool EnableAtPseudoVariable,\n                   SMLoc L);\n\n  /// Are macros enabled in the parser?\n  bool areMacrosEnabled() {return MacrosEnabledFlag;}\n\n  /// Control a flag in the parser that enables or disables macros.\n  void setMacrosEnabled(bool Flag) {MacrosEnabledFlag = Flag;}\n\n  /// Are we inside a macro instantiation?\n  bool isInsideMacroInstantiation() {return !ActiveMacros.empty();}\n\n  /// Handle entry to macro instantiation.\n  ///\n  /// \\param M The macro.\n  /// \\param NameLoc Instantiation location.\n  bool handleMacroEntry(const MCAsmMacro *M, SMLoc NameLoc);\n\n  /// Handle exit from macro instantiation.\n  void handleMacroExit();\n\n  /// Extract AsmTokens for a macro argument.\n  bool parseMacroArgument(MCAsmMacroArgument &MA, bool Vararg);\n\n  /// Parse all macro arguments for a given macro.\n  bool parseMacroArguments(const MCAsmMacro *M, MCAsmMacroArguments &A);\n\n  void printMacroInstantiations();\n  void printMessage(SMLoc Loc, SourceMgr::DiagKind Kind, const Twine &Msg,\n                    SMRange Range = None) const {\n    ArrayRef<SMRange> Ranges(Range);\n    SrcMgr.PrintMessage(Loc, Kind, Msg, Ranges);\n  }\n  static void DiagHandler(const SMDiagnostic &Diag, void *Context);\n\n  /// Should we emit DWARF describing this assembler source?  (Returns false if\n  /// the source has .file directives, which means we don't want to generate\n  /// info describing the assembler source itself.)\n  bool enabledGenDwarfForAssembly();\n\n  /// Enter the specified file. This returns true on failure.\n  bool enterIncludeFile(const std::string &Filename);\n\n  /// Process the specified file for the .incbin directive.\n  /// This returns true on failure.\n  bool processIncbinFile(const std::string &Filename, int64_t Skip = 0,\n                         const MCExpr *Count = nullptr, SMLoc Loc = SMLoc());\n\n  /// Reset the current lexer position to that given by \\p Loc. The\n  /// current token is not set; clients should ensure Lex() is called\n  /// subsequently.\n  ///\n  /// \\param InBuffer If not 0, should be the known buffer id that contains the\n  /// location.\n  void jumpToLoc(SMLoc Loc, unsigned InBuffer = 0);\n\n  /// Parse up to the end of statement and a return the contents from the\n  /// current token until the end of the statement; the current token on exit\n  /// will be either the EndOfStatement or EOF.\n  StringRef parseStringToEndOfStatement() override;\n\n  /// Parse until the end of a statement or a comma is encountered,\n  /// return the contents from the current token up to the end or comma.\n  StringRef parseStringToComma();\n\n  bool parseAssignment(StringRef Name, bool allow_redef,\n                       bool NoDeadStrip = false);\n\n  unsigned getBinOpPrecedence(AsmToken::TokenKind K,\n                              MCBinaryExpr::Opcode &Kind);\n\n  bool parseBinOpRHS(unsigned Precedence, const MCExpr *&Res, SMLoc &EndLoc);\n  bool parseParenExpr(const MCExpr *&Res, SMLoc &EndLoc);\n  bool parseBracketExpr(const MCExpr *&Res, SMLoc &EndLoc);\n\n  bool parseRegisterOrRegisterNumber(int64_t &Register, SMLoc DirectiveLoc);\n\n  bool parseCVFunctionId(int64_t &FunctionId, StringRef DirectiveName);\n  bool parseCVFileId(int64_t &FileId, StringRef DirectiveName);\n\n  // Generic (target and platform independent) directive parsing.\n  enum DirectiveKind {\n    DK_NO_DIRECTIVE, // Placeholder\n    DK_SET,\n    DK_EQU,\n    DK_EQUIV,\n    DK_ASCII,\n    DK_ASCIZ,\n    DK_STRING,\n    DK_BYTE,\n    DK_SHORT,\n    DK_RELOC,\n    DK_VALUE,\n    DK_2BYTE,\n    DK_LONG,\n    DK_INT,\n    DK_4BYTE,\n    DK_QUAD,\n    DK_8BYTE,\n    DK_OCTA,\n    DK_DC,\n    DK_DC_A,\n    DK_DC_B,\n    DK_DC_D,\n    DK_DC_L,\n    DK_DC_S,\n    DK_DC_W,\n    DK_DC_X,\n    DK_DCB,\n    DK_DCB_B,\n    DK_DCB_D,\n    DK_DCB_L,\n    DK_DCB_S,\n    DK_DCB_W,\n    DK_DCB_X,\n    DK_DS,\n    DK_DS_B,\n    DK_DS_D,\n    DK_DS_L,\n    DK_DS_P,\n    DK_DS_S,\n    DK_DS_W,\n    DK_DS_X,\n    DK_SINGLE,\n    DK_FLOAT,\n    DK_DOUBLE,\n    DK_ALIGN,\n    DK_ALIGN32,\n    DK_BALIGN,\n    DK_BALIGNW,\n    DK_BALIGNL,\n    DK_P2ALIGN,\n    DK_P2ALIGNW,\n    DK_P2ALIGNL,\n    DK_ORG,\n    DK_FILL,\n    DK_ENDR,\n    DK_BUNDLE_ALIGN_MODE,\n    DK_BUNDLE_LOCK,\n    DK_BUNDLE_UNLOCK,\n    DK_ZERO,\n    DK_EXTERN,\n    DK_GLOBL,\n    DK_GLOBAL,\n    DK_LAZY_REFERENCE,\n    DK_NO_DEAD_STRIP,\n    DK_SYMBOL_RESOLVER,\n    DK_PRIVATE_EXTERN,\n    DK_REFERENCE,\n    DK_WEAK_DEFINITION,\n    DK_WEAK_REFERENCE,\n    DK_WEAK_DEF_CAN_BE_HIDDEN,\n    DK_COLD,\n    DK_COMM,\n    DK_COMMON,\n    DK_LCOMM,\n    DK_ABORT,\n    DK_INCLUDE,\n    DK_INCBIN,\n    DK_CODE16,\n    DK_CODE16GCC,\n    DK_REPT,\n    DK_IRP,\n    DK_IRPC,\n    DK_IF,\n    DK_IFEQ,\n    DK_IFGE,\n    DK_IFGT,\n    DK_IFLE,\n    DK_IFLT,\n    DK_IFNE,\n    DK_IFB,\n    DK_IFNB,\n    DK_IFC,\n    DK_IFEQS,\n    DK_IFNC,\n    DK_IFNES,\n    DK_IFDEF,\n    DK_IFNDEF,\n    DK_IFNOTDEF,\n    DK_ELSEIF,\n    DK_ELSE,\n    DK_ENDIF,\n    DK_SPACE,\n    DK_SKIP,\n    DK_FILE,\n    DK_LINE,\n    DK_LOC,\n    DK_STABS,\n    DK_CV_FILE,\n    DK_CV_FUNC_ID,\n    DK_CV_INLINE_SITE_ID,\n    DK_CV_LOC,\n    DK_CV_LINETABLE,\n    DK_CV_INLINE_LINETABLE,\n    DK_CV_DEF_RANGE,\n    DK_CV_STRINGTABLE,\n    DK_CV_STRING,\n    DK_CV_FILECHECKSUMS,\n    DK_CV_FILECHECKSUM_OFFSET,\n    DK_CV_FPO_DATA,\n    DK_CFI_SECTIONS,\n    DK_CFI_STARTPROC,\n    DK_CFI_ENDPROC,\n    DK_CFI_DEF_CFA,\n    DK_CFI_DEF_CFA_OFFSET,\n    DK_CFI_ADJUST_CFA_OFFSET,\n    DK_CFI_DEF_CFA_REGISTER,\n    DK_CFI_OFFSET,\n    DK_CFI_REL_OFFSET,\n    DK_CFI_PERSONALITY,\n    DK_CFI_LSDA,\n    DK_CFI_REMEMBER_STATE,\n    DK_CFI_RESTORE_STATE,\n    DK_CFI_SAME_VALUE,\n    DK_CFI_RESTORE,\n    DK_CFI_ESCAPE,\n    DK_CFI_RETURN_COLUMN,\n    DK_CFI_SIGNAL_FRAME,\n    DK_CFI_UNDEFINED,\n    DK_CFI_REGISTER,\n    DK_CFI_WINDOW_SAVE,\n    DK_CFI_B_KEY_FRAME,\n    DK_MACROS_ON,\n    DK_MACROS_OFF,\n    DK_ALTMACRO,\n    DK_NOALTMACRO,\n    DK_MACRO,\n    DK_EXITM,\n    DK_ENDM,\n    DK_ENDMACRO,\n    DK_PURGEM,\n    DK_SLEB128,\n    DK_ULEB128,\n    DK_ERR,\n    DK_ERROR,\n    DK_WARNING,\n    DK_PRINT,\n    DK_ADDRSIG,\n    DK_ADDRSIG_SYM,\n    DK_PSEUDO_PROBE,\n    DK_END\n  };\n\n  /// Maps directive name --> DirectiveKind enum, for\n  /// directives parsed by this class.\n  StringMap<DirectiveKind> DirectiveKindMap;\n\n  // Codeview def_range type parsing.\n  enum CVDefRangeType {\n    CVDR_DEFRANGE = 0, // Placeholder\n    CVDR_DEFRANGE_REGISTER,\n    CVDR_DEFRANGE_FRAMEPOINTER_REL,\n    CVDR_DEFRANGE_SUBFIELD_REGISTER,\n    CVDR_DEFRANGE_REGISTER_REL\n  };\n\n  /// Maps Codeview def_range types --> CVDefRangeType enum, for\n  /// Codeview def_range types parsed by this class.\n  StringMap<CVDefRangeType> CVDefRangeTypeMap;\n\n  // \".ascii\", \".asciz\", \".string\"\n  bool parseDirectiveAscii(StringRef IDVal, bool ZeroTerminated);\n  bool parseDirectiveReloc(SMLoc DirectiveLoc); // \".reloc\"\n  bool parseDirectiveValue(StringRef IDVal,\n                           unsigned Size);       // \".byte\", \".long\", ...\n  bool parseDirectiveOctaValue(StringRef IDVal); // \".octa\", ...\n  bool parseDirectiveRealValue(StringRef IDVal,\n                               const fltSemantics &); // \".single\", ...\n  bool parseDirectiveFill(); // \".fill\"\n  bool parseDirectiveZero(); // \".zero\"\n  // \".set\", \".equ\", \".equiv\"\n  bool parseDirectiveSet(StringRef IDVal, bool allow_redef);\n  bool parseDirectiveOrg(); // \".org\"\n  // \".align{,32}\", \".p2align{,w,l}\"\n  bool parseDirectiveAlign(bool IsPow2, unsigned ValueSize);\n\n  // \".file\", \".line\", \".loc\", \".stabs\"\n  bool parseDirectiveFile(SMLoc DirectiveLoc);\n  bool parseDirectiveLine();\n  bool parseDirectiveLoc();\n  bool parseDirectiveStabs();\n\n  // \".cv_file\", \".cv_func_id\", \".cv_inline_site_id\", \".cv_loc\", \".cv_linetable\",\n  // \".cv_inline_linetable\", \".cv_def_range\", \".cv_string\"\n  bool parseDirectiveCVFile();\n  bool parseDirectiveCVFuncId();\n  bool parseDirectiveCVInlineSiteId();\n  bool parseDirectiveCVLoc();\n  bool parseDirectiveCVLinetable();\n  bool parseDirectiveCVInlineLinetable();\n  bool parseDirectiveCVDefRange();\n  bool parseDirectiveCVString();\n  bool parseDirectiveCVStringTable();\n  bool parseDirectiveCVFileChecksums();\n  bool parseDirectiveCVFileChecksumOffset();\n  bool parseDirectiveCVFPOData();\n\n  // .cfi directives\n  bool parseDirectiveCFIRegister(SMLoc DirectiveLoc);\n  bool parseDirectiveCFIWindowSave();\n  bool parseDirectiveCFISections();\n  bool parseDirectiveCFIStartProc();\n  bool parseDirectiveCFIEndProc();\n  bool parseDirectiveCFIDefCfaOffset();\n  bool parseDirectiveCFIDefCfa(SMLoc DirectiveLoc);\n  bool parseDirectiveCFIAdjustCfaOffset();\n  bool parseDirectiveCFIDefCfaRegister(SMLoc DirectiveLoc);\n  bool parseDirectiveCFIOffset(SMLoc DirectiveLoc);\n  bool parseDirectiveCFIRelOffset(SMLoc DirectiveLoc);\n  bool parseDirectiveCFIPersonalityOrLsda(bool IsPersonality);\n  bool parseDirectiveCFIRememberState();\n  bool parseDirectiveCFIRestoreState();\n  bool parseDirectiveCFISameValue(SMLoc DirectiveLoc);\n  bool parseDirectiveCFIRestore(SMLoc DirectiveLoc);\n  bool parseDirectiveCFIEscape();\n  bool parseDirectiveCFIReturnColumn(SMLoc DirectiveLoc);\n  bool parseDirectiveCFISignalFrame();\n  bool parseDirectiveCFIUndefined(SMLoc DirectiveLoc);\n\n  // macro directives\n  bool parseDirectivePurgeMacro(SMLoc DirectiveLoc);\n  bool parseDirectiveExitMacro(StringRef Directive);\n  bool parseDirectiveEndMacro(StringRef Directive);\n  bool parseDirectiveMacro(SMLoc DirectiveLoc);\n  bool parseDirectiveMacrosOnOff(StringRef Directive);\n  // alternate macro mode directives\n  bool parseDirectiveAltmacro(StringRef Directive);\n  // \".bundle_align_mode\"\n  bool parseDirectiveBundleAlignMode();\n  // \".bundle_lock\"\n  bool parseDirectiveBundleLock();\n  // \".bundle_unlock\"\n  bool parseDirectiveBundleUnlock();\n\n  // \".space\", \".skip\"\n  bool parseDirectiveSpace(StringRef IDVal);\n\n  // \".dcb\"\n  bool parseDirectiveDCB(StringRef IDVal, unsigned Size);\n  bool parseDirectiveRealDCB(StringRef IDVal, const fltSemantics &);\n  // \".ds\"\n  bool parseDirectiveDS(StringRef IDVal, unsigned Size);\n\n  // .sleb128 (Signed=true) and .uleb128 (Signed=false)\n  bool parseDirectiveLEB128(bool Signed);\n\n  /// Parse a directive like \".globl\" which\n  /// accepts a single symbol (which should be a label or an external).\n  bool parseDirectiveSymbolAttribute(MCSymbolAttr Attr);\n\n  bool parseDirectiveComm(bool IsLocal); // \".comm\" and \".lcomm\"\n\n  bool parseDirectiveAbort(); // \".abort\"\n  bool parseDirectiveInclude(); // \".include\"\n  bool parseDirectiveIncbin(); // \".incbin\"\n\n  // \".if\", \".ifeq\", \".ifge\", \".ifgt\" , \".ifle\", \".iflt\" or \".ifne\"\n  bool parseDirectiveIf(SMLoc DirectiveLoc, DirectiveKind DirKind);\n  // \".ifb\" or \".ifnb\", depending on ExpectBlank.\n  bool parseDirectiveIfb(SMLoc DirectiveLoc, bool ExpectBlank);\n  // \".ifc\" or \".ifnc\", depending on ExpectEqual.\n  bool parseDirectiveIfc(SMLoc DirectiveLoc, bool ExpectEqual);\n  // \".ifeqs\" or \".ifnes\", depending on ExpectEqual.\n  bool parseDirectiveIfeqs(SMLoc DirectiveLoc, bool ExpectEqual);\n  // \".ifdef\" or \".ifndef\", depending on expect_defined\n  bool parseDirectiveIfdef(SMLoc DirectiveLoc, bool expect_defined);\n  bool parseDirectiveElseIf(SMLoc DirectiveLoc); // \".elseif\"\n  bool parseDirectiveElse(SMLoc DirectiveLoc); // \".else\"\n  bool parseDirectiveEndIf(SMLoc DirectiveLoc); // .endif\n  bool parseEscapedString(std::string &Data) override;\n  bool parseAngleBracketString(std::string &Data) override;\n\n  const MCExpr *applyModifierToExpr(const MCExpr *E,\n                                    MCSymbolRefExpr::VariantKind Variant);\n\n  // Macro-like directives\n  MCAsmMacro *parseMacroLikeBody(SMLoc DirectiveLoc);\n  void instantiateMacroLikeBody(MCAsmMacro *M, SMLoc DirectiveLoc,\n                                raw_svector_ostream &OS);\n  bool parseDirectiveRept(SMLoc DirectiveLoc, StringRef Directive);\n  bool parseDirectiveIrp(SMLoc DirectiveLoc);  // \".irp\"\n  bool parseDirectiveIrpc(SMLoc DirectiveLoc); // \".irpc\"\n  bool parseDirectiveEndr(SMLoc DirectiveLoc); // \".endr\"\n\n  // \"_emit\" or \"__emit\"\n  bool parseDirectiveMSEmit(SMLoc DirectiveLoc, ParseStatementInfo &Info,\n                            size_t Len);\n\n  // \"align\"\n  bool parseDirectiveMSAlign(SMLoc DirectiveLoc, ParseStatementInfo &Info);\n\n  // \"end\"\n  bool parseDirectiveEnd(SMLoc DirectiveLoc);\n\n  // \".err\" or \".error\"\n  bool parseDirectiveError(SMLoc DirectiveLoc, bool WithMessage);\n\n  // \".warning\"\n  bool parseDirectiveWarning(SMLoc DirectiveLoc);\n\n  // .print <double-quotes-string>\n  bool parseDirectivePrint(SMLoc DirectiveLoc);\n\n  // .pseudoprobe\n  bool parseDirectivePseudoProbe();\n\n  // Directives to support address-significance tables.\n  bool parseDirectiveAddrsig();\n  bool parseDirectiveAddrsigSym();\n\n  void initializeDirectiveKindMap();\n  void initializeCVDefRangeTypeMap();\n};\n\n} // end anonymous namespace\n\nnamespace llvm {\n\nextern MCAsmParserExtension *createDarwinAsmParser();\nextern MCAsmParserExtension *createELFAsmParser();\nextern MCAsmParserExtension *createCOFFAsmParser();\nextern MCAsmParserExtension *createWasmAsmParser();\n\n} // end namespace llvm\n\nenum { DEFAULT_ADDRSPACE = 0 };\n\nAsmParser::AsmParser(SourceMgr &SM, MCContext &Ctx, MCStreamer &Out,\n                     const MCAsmInfo &MAI, unsigned CB = 0)\n    : Lexer(MAI), Ctx(Ctx), Out(Out), MAI(MAI), SrcMgr(SM),\n      CurBuffer(CB ? CB : SM.getMainFileID()), MacrosEnabledFlag(true) {\n  HadError = false;\n  // Save the old handler.\n  SavedDiagHandler = SrcMgr.getDiagHandler();\n  SavedDiagContext = SrcMgr.getDiagContext();\n  // Set our own handler which calls the saved handler.\n  SrcMgr.setDiagHandler(DiagHandler, this);\n  Lexer.setBuffer(SrcMgr.getMemoryBuffer(CurBuffer)->getBuffer());\n  // Make MCStreamer aware of the StartTokLoc for locations in diagnostics.\n  Out.setStartTokLocPtr(&StartTokLoc);\n\n  // Initialize the platform / file format parser.\n  switch (Ctx.getObjectFileInfo()->getObjectFileType()) {\n  case MCObjectFileInfo::IsCOFF:\n    PlatformParser.reset(createCOFFAsmParser());\n    break;\n  case MCObjectFileInfo::IsMachO:\n    PlatformParser.reset(createDarwinAsmParser());\n    IsDarwin = true;\n    break;\n  case MCObjectFileInfo::IsELF:\n    PlatformParser.reset(createELFAsmParser());\n    break;\n  case MCObjectFileInfo::IsWasm:\n    PlatformParser.reset(createWasmAsmParser());\n    break;\n  case MCObjectFileInfo::IsXCOFF:\n    report_fatal_error(\n        \"Need to implement createXCOFFAsmParser for XCOFF format.\");\n    break;\n  }\n\n  PlatformParser->Initialize(*this);\n  initializeDirectiveKindMap();\n  initializeCVDefRangeTypeMap();\n\n  NumOfMacroInstantiations = 0;\n}\n\nAsmParser::~AsmParser() {\n  assert((HadError || ActiveMacros.empty()) &&\n         \"Unexpected active macro instantiation!\");\n\n  // Remove MCStreamer's reference to the parser SMLoc.\n  Out.setStartTokLocPtr(nullptr);\n  // Restore the saved diagnostics handler and context for use during\n  // finalization.\n  SrcMgr.setDiagHandler(SavedDiagHandler, SavedDiagContext);\n}\n\nvoid AsmParser::printMacroInstantiations() {\n  // Print the active macro instantiation stack.\n  for (std::vector<MacroInstantiation *>::const_reverse_iterator\n           it = ActiveMacros.rbegin(),\n           ie = ActiveMacros.rend();\n       it != ie; ++it)\n    printMessage((*it)->InstantiationLoc, SourceMgr::DK_Note,\n                 \"while in macro instantiation\");\n}\n\nvoid AsmParser::Note(SMLoc L, const Twine &Msg, SMRange Range) {\n  printPendingErrors();\n  printMessage(L, SourceMgr::DK_Note, Msg, Range);\n  printMacroInstantiations();\n}\n\nbool AsmParser::Warning(SMLoc L, const Twine &Msg, SMRange Range) {\n  if(getTargetParser().getTargetOptions().MCNoWarn)\n    return false;\n  if (getTargetParser().getTargetOptions().MCFatalWarnings)\n    return Error(L, Msg, Range);\n  printMessage(L, SourceMgr::DK_Warning, Msg, Range);\n  printMacroInstantiations();\n  return false;\n}\n\nbool AsmParser::printError(SMLoc L, const Twine &Msg, SMRange Range) {\n  HadError = true;\n  printMessage(L, SourceMgr::DK_Error, Msg, Range);\n  printMacroInstantiations();\n  return true;\n}\n\nbool AsmParser::enterIncludeFile(const std::string &Filename) {\n  std::string IncludedFile;\n  unsigned NewBuf =\n      SrcMgr.AddIncludeFile(Filename, Lexer.getLoc(), IncludedFile);\n  if (!NewBuf)\n    return true;\n\n  CurBuffer = NewBuf;\n  Lexer.setBuffer(SrcMgr.getMemoryBuffer(CurBuffer)->getBuffer());\n  return false;\n}\n\n/// Process the specified .incbin file by searching for it in the include paths\n/// then just emitting the byte contents of the file to the streamer. This\n/// returns true on failure.\nbool AsmParser::processIncbinFile(const std::string &Filename, int64_t Skip,\n                                  const MCExpr *Count, SMLoc Loc) {\n  std::string IncludedFile;\n  unsigned NewBuf =\n      SrcMgr.AddIncludeFile(Filename, Lexer.getLoc(), IncludedFile);\n  if (!NewBuf)\n    return true;\n\n  // Pick up the bytes from the file and emit them.\n  StringRef Bytes = SrcMgr.getMemoryBuffer(NewBuf)->getBuffer();\n  Bytes = Bytes.drop_front(Skip);\n  if (Count) {\n    int64_t Res;\n    if (!Count->evaluateAsAbsolute(Res, getStreamer().getAssemblerPtr()))\n      return Error(Loc, \"expected absolute expression\");\n    if (Res < 0)\n      return Warning(Loc, \"negative count has no effect\");\n    Bytes = Bytes.take_front(Res);\n  }\n  getStreamer().emitBytes(Bytes);\n  return false;\n}\n\nvoid AsmParser::jumpToLoc(SMLoc Loc, unsigned InBuffer) {\n  CurBuffer = InBuffer ? InBuffer : SrcMgr.FindBufferContainingLoc(Loc);\n  Lexer.setBuffer(SrcMgr.getMemoryBuffer(CurBuffer)->getBuffer(),\n                  Loc.getPointer());\n}\n\nconst AsmToken &AsmParser::Lex() {\n  if (Lexer.getTok().is(AsmToken::Error))\n    Error(Lexer.getErrLoc(), Lexer.getErr());\n\n  // if it's a end of statement with a comment in it\n  if (getTok().is(AsmToken::EndOfStatement)) {\n    // if this is a line comment output it.\n    if (!getTok().getString().empty() && getTok().getString().front() != '\\n' &&\n        getTok().getString().front() != '\\r' && MAI.preserveAsmComments())\n      Out.addExplicitComment(Twine(getTok().getString()));\n  }\n\n  const AsmToken *tok = &Lexer.Lex();\n\n  // Parse comments here to be deferred until end of next statement.\n  while (tok->is(AsmToken::Comment)) {\n    if (MAI.preserveAsmComments())\n      Out.addExplicitComment(Twine(tok->getString()));\n    tok = &Lexer.Lex();\n  }\n\n  if (tok->is(AsmToken::Eof)) {\n    // If this is the end of an included file, pop the parent file off the\n    // include stack.\n    SMLoc ParentIncludeLoc = SrcMgr.getParentIncludeLoc(CurBuffer);\n    if (ParentIncludeLoc != SMLoc()) {\n      jumpToLoc(ParentIncludeLoc);\n      return Lex();\n    }\n  }\n\n  return *tok;\n}\n\nbool AsmParser::enabledGenDwarfForAssembly() {\n  // Check whether the user specified -g.\n  if (!getContext().getGenDwarfForAssembly())\n    return false;\n  // If we haven't encountered any .file directives (which would imply that\n  // the assembler source was produced with debug info already) then emit one\n  // describing the assembler source file itself.\n  if (getContext().getGenDwarfFileNumber() == 0) {\n    // Use the first #line directive for this, if any. It's preprocessed, so\n    // there is no checksum, and of course no source directive.\n    if (!FirstCppHashFilename.empty())\n      getContext().setMCLineTableRootFile(/*CUID=*/0,\n                                          getContext().getCompilationDir(),\n                                          FirstCppHashFilename,\n                                          /*Cksum=*/None, /*Source=*/None);\n    const MCDwarfFile &RootFile =\n        getContext().getMCDwarfLineTable(/*CUID=*/0).getRootFile();\n    getContext().setGenDwarfFileNumber(getStreamer().emitDwarfFileDirective(\n        /*CUID=*/0, getContext().getCompilationDir(), RootFile.Name,\n        RootFile.Checksum, RootFile.Source));\n  }\n  return true;\n}\n\nbool AsmParser::Run(bool NoInitialTextSection, bool NoFinalize) {\n  // Create the initial section, if requested.\n  if (!NoInitialTextSection)\n    Out.InitSections(false);\n\n  // Prime the lexer.\n  Lex();\n\n  HadError = false;\n  AsmCond StartingCondState = TheCondState;\n  SmallVector<AsmRewrite, 4> AsmStrRewrites;\n\n  // If we are generating dwarf for assembly source files save the initial text\n  // section.  (Don't use enabledGenDwarfForAssembly() here, as we aren't\n  // emitting any actual debug info yet and haven't had a chance to parse any\n  // embedded .file directives.)\n  if (getContext().getGenDwarfForAssembly()) {\n    MCSection *Sec = getStreamer().getCurrentSectionOnly();\n    if (!Sec->getBeginSymbol()) {\n      MCSymbol *SectionStartSym = getContext().createTempSymbol();\n      getStreamer().emitLabel(SectionStartSym);\n      Sec->setBeginSymbol(SectionStartSym);\n    }\n    bool InsertResult = getContext().addGenDwarfSection(Sec);\n    assert(InsertResult && \".text section should not have debug info yet\");\n    (void)InsertResult;\n  }\n\n  // While we have input, parse each statement.\n  while (Lexer.isNot(AsmToken::Eof)) {\n    ParseStatementInfo Info(&AsmStrRewrites);\n    bool Parsed = parseStatement(Info, nullptr);\n\n    // If we have a Lexer Error we are on an Error Token. Load in Lexer Error\n    // for printing ErrMsg via Lex() only if no (presumably better) parser error\n    // exists.\n    if (Parsed && !hasPendingError() && Lexer.getTok().is(AsmToken::Error)) {\n      Lex();\n    }\n\n    // parseStatement returned true so may need to emit an error.\n    printPendingErrors();\n\n    // Skipping to the next line if needed.\n    if (Parsed && !getLexer().isAtStartOfStatement())\n      eatToEndOfStatement();\n  }\n\n  getTargetParser().onEndOfFile();\n  printPendingErrors();\n\n  // All errors should have been emitted.\n  assert(!hasPendingError() && \"unexpected error from parseStatement\");\n\n  getTargetParser().flushPendingInstructions(getStreamer());\n\n  if (TheCondState.TheCond != StartingCondState.TheCond ||\n      TheCondState.Ignore != StartingCondState.Ignore)\n    printError(getTok().getLoc(), \"unmatched .ifs or .elses\");\n  // Check to see there are no empty DwarfFile slots.\n  const auto &LineTables = getContext().getMCDwarfLineTables();\n  if (!LineTables.empty()) {\n    unsigned Index = 0;\n    for (const auto &File : LineTables.begin()->second.getMCDwarfFiles()) {\n      if (File.Name.empty() && Index != 0)\n        printError(getTok().getLoc(), \"unassigned file number: \" +\n                                          Twine(Index) +\n                                          \" for .file directives\");\n      ++Index;\n    }\n  }\n\n  // Check to see that all assembler local symbols were actually defined.\n  // Targets that don't do subsections via symbols may not want this, though,\n  // so conservatively exclude them. Only do this if we're finalizing, though,\n  // as otherwise we won't necessarilly have seen everything yet.\n  if (!NoFinalize) {\n    if (MAI.hasSubsectionsViaSymbols()) {\n      for (const auto &TableEntry : getContext().getSymbols()) {\n        MCSymbol *Sym = TableEntry.getValue();\n        // Variable symbols may not be marked as defined, so check those\n        // explicitly. If we know it's a variable, we have a definition for\n        // the purposes of this check.\n        if (Sym->isTemporary() && !Sym->isVariable() && !Sym->isDefined())\n          // FIXME: We would really like to refer back to where the symbol was\n          // first referenced for a source location. We need to add something\n          // to track that. Currently, we just point to the end of the file.\n          printError(getTok().getLoc(), \"assembler local symbol '\" +\n                                            Sym->getName() + \"' not defined\");\n      }\n    }\n\n    // Temporary symbols like the ones for directional jumps don't go in the\n    // symbol table. They also need to be diagnosed in all (final) cases.\n    for (std::tuple<SMLoc, CppHashInfoTy, MCSymbol *> &LocSym : DirLabels) {\n      if (std::get<2>(LocSym)->isUndefined()) {\n        // Reset the state of any \"# line file\" directives we've seen to the\n        // context as it was at the diagnostic site.\n        CppHashInfo = std::get<1>(LocSym);\n        printError(std::get<0>(LocSym), \"directional label undefined\");\n      }\n    }\n  }\n\n  // Finalize the output stream if there are no errors and if the client wants\n  // us to.\n  if (!HadError && !NoFinalize)\n    Out.Finish(Lexer.getLoc());\n\n  return HadError || getContext().hadError();\n}\n\nbool AsmParser::checkForValidSection() {\n  if (!ParsingMSInlineAsm && !getStreamer().getCurrentSectionOnly()) {\n    Out.InitSections(false);\n    return Error(getTok().getLoc(),\n                 \"expected section directive before assembly directive\");\n  }\n  return false;\n}\n\n/// Throw away the rest of the line for testing purposes.\nvoid AsmParser::eatToEndOfStatement() {\n  while (Lexer.isNot(AsmToken::EndOfStatement) && Lexer.isNot(AsmToken::Eof))\n    Lexer.Lex();\n\n  // Eat EOL.\n  if (Lexer.is(AsmToken::EndOfStatement))\n    Lexer.Lex();\n}\n\nStringRef AsmParser::parseStringToEndOfStatement() {\n  const char *Start = getTok().getLoc().getPointer();\n\n  while (Lexer.isNot(AsmToken::EndOfStatement) && Lexer.isNot(AsmToken::Eof))\n    Lexer.Lex();\n\n  const char *End = getTok().getLoc().getPointer();\n  return StringRef(Start, End - Start);\n}\n\nStringRef AsmParser::parseStringToComma() {\n  const char *Start = getTok().getLoc().getPointer();\n\n  while (Lexer.isNot(AsmToken::EndOfStatement) &&\n         Lexer.isNot(AsmToken::Comma) && Lexer.isNot(AsmToken::Eof))\n    Lexer.Lex();\n\n  const char *End = getTok().getLoc().getPointer();\n  return StringRef(Start, End - Start);\n}\n\n/// Parse a paren expression and return it.\n/// NOTE: This assumes the leading '(' has already been consumed.\n///\n/// parenexpr ::= expr)\n///\nbool AsmParser::parseParenExpr(const MCExpr *&Res, SMLoc &EndLoc) {\n  if (parseExpression(Res))\n    return true;\n  if (Lexer.isNot(AsmToken::RParen))\n    return TokError(\"expected ')' in parentheses expression\");\n  EndLoc = Lexer.getTok().getEndLoc();\n  Lex();\n  return false;\n}\n\n/// Parse a bracket expression and return it.\n/// NOTE: This assumes the leading '[' has already been consumed.\n///\n/// bracketexpr ::= expr]\n///\nbool AsmParser::parseBracketExpr(const MCExpr *&Res, SMLoc &EndLoc) {\n  if (parseExpression(Res))\n    return true;\n  EndLoc = getTok().getEndLoc();\n  if (parseToken(AsmToken::RBrac, \"expected ']' in brackets expression\"))\n    return true;\n  return false;\n}\n\n/// Parse a primary expression and return it.\n///  primaryexpr ::= (parenexpr\n///  primaryexpr ::= symbol\n///  primaryexpr ::= number\n///  primaryexpr ::= '.'\n///  primaryexpr ::= ~,+,- primaryexpr\nbool AsmParser::parsePrimaryExpr(const MCExpr *&Res, SMLoc &EndLoc,\n                                 AsmTypeInfo *TypeInfo) {\n  SMLoc FirstTokenLoc = getLexer().getLoc();\n  AsmToken::TokenKind FirstTokenKind = Lexer.getKind();\n  switch (FirstTokenKind) {\n  default:\n    return TokError(\"unknown token in expression\");\n  // If we have an error assume that we've already handled it.\n  case AsmToken::Error:\n    return true;\n  case AsmToken::Exclaim:\n    Lex(); // Eat the operator.\n    if (parsePrimaryExpr(Res, EndLoc, TypeInfo))\n      return true;\n    Res = MCUnaryExpr::createLNot(Res, getContext(), FirstTokenLoc);\n    return false;\n  case AsmToken::Dollar:\n  case AsmToken::At:\n  case AsmToken::String:\n  case AsmToken::Identifier: {\n    StringRef Identifier;\n    if (parseIdentifier(Identifier)) {\n      // We may have failed but $ may be a valid token.\n      if (getTok().is(AsmToken::Dollar)) {\n        if (Lexer.getMAI().getDollarIsPC()) {\n          Lex();\n          // This is a '$' reference, which references the current PC.  Emit a\n          // temporary label to the streamer and refer to it.\n          MCSymbol *Sym = Ctx.createTempSymbol();\n          Out.emitLabel(Sym);\n          Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None,\n                                        getContext());\n          EndLoc = FirstTokenLoc;\n          return false;\n        }\n        return Error(FirstTokenLoc, \"invalid token in expression\");\n      }\n    }\n    // Parse symbol variant\n    std::pair<StringRef, StringRef> Split;\n    if (!MAI.useParensForSymbolVariant()) {\n      if (FirstTokenKind == AsmToken::String) {\n        if (Lexer.is(AsmToken::At)) {\n          Lex(); // eat @\n          SMLoc AtLoc = getLexer().getLoc();\n          StringRef VName;\n          if (parseIdentifier(VName))\n            return Error(AtLoc, \"expected symbol variant after '@'\");\n\n          Split = std::make_pair(Identifier, VName);\n        }\n      } else {\n        Split = Identifier.split('@');\n      }\n    } else if (Lexer.is(AsmToken::LParen)) {\n      Lex(); // eat '('.\n      StringRef VName;\n      parseIdentifier(VName);\n      // eat ')'.\n      if (parseToken(AsmToken::RParen,\n                     \"unexpected token in variant, expected ')'\"))\n        return true;\n      Split = std::make_pair(Identifier, VName);\n    }\n\n    EndLoc = SMLoc::getFromPointer(Identifier.end());\n\n    // This is a symbol reference.\n    StringRef SymbolName = Identifier;\n    if (SymbolName.empty())\n      return Error(getLexer().getLoc(), \"expected a symbol reference\");\n\n    MCSymbolRefExpr::VariantKind Variant = MCSymbolRefExpr::VK_None;\n\n    // Lookup the symbol variant if used.\n    if (!Split.second.empty()) {\n      Variant = MCSymbolRefExpr::getVariantKindForName(Split.second);\n      if (Variant != MCSymbolRefExpr::VK_Invalid) {\n        SymbolName = Split.first;\n      } else if (MAI.doesAllowAtInName() && !MAI.useParensForSymbolVariant()) {\n        Variant = MCSymbolRefExpr::VK_None;\n      } else {\n        return Error(SMLoc::getFromPointer(Split.second.begin()),\n                     \"invalid variant '\" + Split.second + \"'\");\n      }\n    }\n\n    MCSymbol *Sym = getContext().getInlineAsmLabel(SymbolName);\n    if (!Sym)\n      Sym = getContext().getOrCreateSymbol(SymbolName);\n\n    // If this is an absolute variable reference, substitute it now to preserve\n    // semantics in the face of reassignment.\n    if (Sym->isVariable()) {\n      auto V = Sym->getVariableValue(/*SetUsed*/ false);\n      bool DoInline = isa<MCConstantExpr>(V) && !Variant;\n      if (auto TV = dyn_cast<MCTargetExpr>(V))\n        DoInline = TV->inlineAssignedExpr();\n      if (DoInline) {\n        if (Variant)\n          return Error(EndLoc, \"unexpected modifier on variable reference\");\n        Res = Sym->getVariableValue(/*SetUsed*/ false);\n        return false;\n      }\n    }\n\n    // Otherwise create a symbol ref.\n    Res = MCSymbolRefExpr::create(Sym, Variant, getContext(), FirstTokenLoc);\n    return false;\n  }\n  case AsmToken::BigNum:\n    return TokError(\"literal value out of range for directive\");\n  case AsmToken::Integer: {\n    SMLoc Loc = getTok().getLoc();\n    int64_t IntVal = getTok().getIntVal();\n    Res = MCConstantExpr::create(IntVal, getContext());\n    EndLoc = Lexer.getTok().getEndLoc();\n    Lex(); // Eat token.\n    // Look for 'b' or 'f' following an Integer as a directional label\n    if (Lexer.getKind() == AsmToken::Identifier) {\n      StringRef IDVal = getTok().getString();\n      // Lookup the symbol variant if used.\n      std::pair<StringRef, StringRef> Split = IDVal.split('@');\n      MCSymbolRefExpr::VariantKind Variant = MCSymbolRefExpr::VK_None;\n      if (Split.first.size() != IDVal.size()) {\n        Variant = MCSymbolRefExpr::getVariantKindForName(Split.second);\n        if (Variant == MCSymbolRefExpr::VK_Invalid)\n          return TokError(\"invalid variant '\" + Split.second + \"'\");\n        IDVal = Split.first;\n      }\n      if (IDVal == \"f\" || IDVal == \"b\") {\n        MCSymbol *Sym =\n            Ctx.getDirectionalLocalSymbol(IntVal, IDVal == \"b\");\n        Res = MCSymbolRefExpr::create(Sym, Variant, getContext());\n        if (IDVal == \"b\" && Sym->isUndefined())\n          return Error(Loc, \"directional label undefined\");\n        DirLabels.push_back(std::make_tuple(Loc, CppHashInfo, Sym));\n        EndLoc = Lexer.getTok().getEndLoc();\n        Lex(); // Eat identifier.\n      }\n    }\n    return false;\n  }\n  case AsmToken::Real: {\n    APFloat RealVal(APFloat::IEEEdouble(), getTok().getString());\n    uint64_t IntVal = RealVal.bitcastToAPInt().getZExtValue();\n    Res = MCConstantExpr::create(IntVal, getContext());\n    EndLoc = Lexer.getTok().getEndLoc();\n    Lex(); // Eat token.\n    return false;\n  }\n  case AsmToken::Dot: {\n    // This is a '.' reference, which references the current PC.  Emit a\n    // temporary label to the streamer and refer to it.\n    MCSymbol *Sym = Ctx.createTempSymbol();\n    Out.emitLabel(Sym);\n    Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());\n    EndLoc = Lexer.getTok().getEndLoc();\n    Lex(); // Eat identifier.\n    return false;\n  }\n  case AsmToken::LParen:\n    Lex(); // Eat the '('.\n    return parseParenExpr(Res, EndLoc);\n  case AsmToken::LBrac:\n    if (!PlatformParser->HasBracketExpressions())\n      return TokError(\"brackets expression not supported on this target\");\n    Lex(); // Eat the '['.\n    return parseBracketExpr(Res, EndLoc);\n  case AsmToken::Minus:\n    Lex(); // Eat the operator.\n    if (parsePrimaryExpr(Res, EndLoc, TypeInfo))\n      return true;\n    Res = MCUnaryExpr::createMinus(Res, getContext(), FirstTokenLoc);\n    return false;\n  case AsmToken::Plus:\n    Lex(); // Eat the operator.\n    if (parsePrimaryExpr(Res, EndLoc, TypeInfo))\n      return true;\n    Res = MCUnaryExpr::createPlus(Res, getContext(), FirstTokenLoc);\n    return false;\n  case AsmToken::Tilde:\n    Lex(); // Eat the operator.\n    if (parsePrimaryExpr(Res, EndLoc, TypeInfo))\n      return true;\n    Res = MCUnaryExpr::createNot(Res, getContext(), FirstTokenLoc);\n    return false;\n  // MIPS unary expression operators. The lexer won't generate these tokens if\n  // MCAsmInfo::HasMipsExpressions is false for the target.\n  case AsmToken::PercentCall16:\n  case AsmToken::PercentCall_Hi:\n  case AsmToken::PercentCall_Lo:\n  case AsmToken::PercentDtprel_Hi:\n  case AsmToken::PercentDtprel_Lo:\n  case AsmToken::PercentGot:\n  case AsmToken::PercentGot_Disp:\n  case AsmToken::PercentGot_Hi:\n  case AsmToken::PercentGot_Lo:\n  case AsmToken::PercentGot_Ofst:\n  case AsmToken::PercentGot_Page:\n  case AsmToken::PercentGottprel:\n  case AsmToken::PercentGp_Rel:\n  case AsmToken::PercentHi:\n  case AsmToken::PercentHigher:\n  case AsmToken::PercentHighest:\n  case AsmToken::PercentLo:\n  case AsmToken::PercentNeg:\n  case AsmToken::PercentPcrel_Hi:\n  case AsmToken::PercentPcrel_Lo:\n  case AsmToken::PercentTlsgd:\n  case AsmToken::PercentTlsldm:\n  case AsmToken::PercentTprel_Hi:\n  case AsmToken::PercentTprel_Lo:\n    Lex(); // Eat the operator.\n    if (Lexer.isNot(AsmToken::LParen))\n      return TokError(\"expected '(' after operator\");\n    Lex(); // Eat the operator.\n    if (parseExpression(Res, EndLoc))\n      return true;\n    if (Lexer.isNot(AsmToken::RParen))\n      return TokError(\"expected ')'\");\n    Lex(); // Eat the operator.\n    Res = getTargetParser().createTargetUnaryExpr(Res, FirstTokenKind, Ctx);\n    return !Res;\n  }\n}\n\nbool AsmParser::parseExpression(const MCExpr *&Res) {\n  SMLoc EndLoc;\n  return parseExpression(Res, EndLoc);\n}\n\nconst MCExpr *\nAsmParser::applyModifierToExpr(const MCExpr *E,\n                               MCSymbolRefExpr::VariantKind Variant) {\n  // Ask the target implementation about this expression first.\n  const MCExpr *NewE = getTargetParser().applyModifierToExpr(E, Variant, Ctx);\n  if (NewE)\n    return NewE;\n  // Recurse over the given expression, rebuilding it to apply the given variant\n  // if there is exactly one symbol.\n  switch (E->getKind()) {\n  case MCExpr::Target:\n  case MCExpr::Constant:\n    return nullptr;\n\n  case MCExpr::SymbolRef: {\n    const MCSymbolRefExpr *SRE = cast<MCSymbolRefExpr>(E);\n\n    if (SRE->getKind() != MCSymbolRefExpr::VK_None) {\n      TokError(\"invalid variant on expression '\" + getTok().getIdentifier() +\n               \"' (already modified)\");\n      return E;\n    }\n\n    return MCSymbolRefExpr::create(&SRE->getSymbol(), Variant, getContext());\n  }\n\n  case MCExpr::Unary: {\n    const MCUnaryExpr *UE = cast<MCUnaryExpr>(E);\n    const MCExpr *Sub = applyModifierToExpr(UE->getSubExpr(), Variant);\n    if (!Sub)\n      return nullptr;\n    return MCUnaryExpr::create(UE->getOpcode(), Sub, getContext());\n  }\n\n  case MCExpr::Binary: {\n    const MCBinaryExpr *BE = cast<MCBinaryExpr>(E);\n    const MCExpr *LHS = applyModifierToExpr(BE->getLHS(), Variant);\n    const MCExpr *RHS = applyModifierToExpr(BE->getRHS(), Variant);\n\n    if (!LHS && !RHS)\n      return nullptr;\n\n    if (!LHS)\n      LHS = BE->getLHS();\n    if (!RHS)\n      RHS = BE->getRHS();\n\n    return MCBinaryExpr::create(BE->getOpcode(), LHS, RHS, getContext());\n  }\n  }\n\n  llvm_unreachable(\"Invalid expression kind!\");\n}\n\n/// This function checks if the next token is <string> type or arithmetic.\n/// string that begin with character '<' must end with character '>'.\n/// otherwise it is arithmetics.\n/// If the function returns a 'true' value,\n/// the End argument will be filled with the last location pointed to the '>'\n/// character.\n\n/// There is a gap between the AltMacro's documentation and the single quote\n/// implementation. GCC does not fully support this feature and so we will not\n/// support it.\n/// TODO: Adding single quote as a string.\nstatic bool isAngleBracketString(SMLoc &StrLoc, SMLoc &EndLoc) {\n  assert((StrLoc.getPointer() != nullptr) &&\n         \"Argument to the function cannot be a NULL value\");\n  const char *CharPtr = StrLoc.getPointer();\n  while ((*CharPtr != '>') && (*CharPtr != '\\n') && (*CharPtr != '\\r') &&\n         (*CharPtr != '\\0')) {\n    if (*CharPtr == '!')\n      CharPtr++;\n    CharPtr++;\n  }\n  if (*CharPtr == '>') {\n    EndLoc = StrLoc.getFromPointer(CharPtr + 1);\n    return true;\n  }\n  return false;\n}\n\n/// creating a string without the escape characters '!'.\nstatic std::string angleBracketString(StringRef AltMacroStr) {\n  std::string Res;\n  for (size_t Pos = 0; Pos < AltMacroStr.size(); Pos++) {\n    if (AltMacroStr[Pos] == '!')\n      Pos++;\n    Res += AltMacroStr[Pos];\n  }\n  return Res;\n}\n\n/// Parse an expression and return it.\n///\n///  expr ::= expr &&,|| expr               -> lowest.\n///  expr ::= expr |,^,&,! expr\n///  expr ::= expr ==,!=,<>,<,<=,>,>= expr\n///  expr ::= expr <<,>> expr\n///  expr ::= expr +,- expr\n///  expr ::= expr *,/,% expr               -> highest.\n///  expr ::= primaryexpr\n///\nbool AsmParser::parseExpression(const MCExpr *&Res, SMLoc &EndLoc) {\n  // Parse the expression.\n  Res = nullptr;\n  if (getTargetParser().parsePrimaryExpr(Res, EndLoc) ||\n      parseBinOpRHS(1, Res, EndLoc))\n    return true;\n\n  // As a special case, we support 'a op b @ modifier' by rewriting the\n  // expression to include the modifier. This is inefficient, but in general we\n  // expect users to use 'a@modifier op b'.\n  if (Lexer.getKind() == AsmToken::At) {\n    Lex();\n\n    if (Lexer.isNot(AsmToken::Identifier))\n      return TokError(\"unexpected symbol modifier following '@'\");\n\n    MCSymbolRefExpr::VariantKind Variant =\n        MCSymbolRefExpr::getVariantKindForName(getTok().getIdentifier());\n    if (Variant == MCSymbolRefExpr::VK_Invalid)\n      return TokError(\"invalid variant '\" + getTok().getIdentifier() + \"'\");\n\n    const MCExpr *ModifiedRes = applyModifierToExpr(Res, Variant);\n    if (!ModifiedRes) {\n      return TokError(\"invalid modifier '\" + getTok().getIdentifier() +\n                      \"' (no symbols present)\");\n    }\n\n    Res = ModifiedRes;\n    Lex();\n  }\n\n  // Try to constant fold it up front, if possible. Do not exploit\n  // assembler here.\n  int64_t Value;\n  if (Res->evaluateAsAbsolute(Value))\n    Res = MCConstantExpr::create(Value, getContext());\n\n  return false;\n}\n\nbool AsmParser::parseParenExpression(const MCExpr *&Res, SMLoc &EndLoc) {\n  Res = nullptr;\n  return parseParenExpr(Res, EndLoc) || parseBinOpRHS(1, Res, EndLoc);\n}\n\nbool AsmParser::parseParenExprOfDepth(unsigned ParenDepth, const MCExpr *&Res,\n                                      SMLoc &EndLoc) {\n  if (parseParenExpr(Res, EndLoc))\n    return true;\n\n  for (; ParenDepth > 0; --ParenDepth) {\n    if (parseBinOpRHS(1, Res, EndLoc))\n      return true;\n\n    // We don't Lex() the last RParen.\n    // This is the same behavior as parseParenExpression().\n    if (ParenDepth - 1 > 0) {\n      EndLoc = getTok().getEndLoc();\n      if (parseToken(AsmToken::RParen,\n                     \"expected ')' in parentheses expression\"))\n        return true;\n    }\n  }\n  return false;\n}\n\nbool AsmParser::parseAbsoluteExpression(int64_t &Res) {\n  const MCExpr *Expr;\n\n  SMLoc StartLoc = Lexer.getLoc();\n  if (parseExpression(Expr))\n    return true;\n\n  if (!Expr->evaluateAsAbsolute(Res, getStreamer().getAssemblerPtr()))\n    return Error(StartLoc, \"expected absolute expression\");\n\n  return false;\n}\n\nstatic unsigned getDarwinBinOpPrecedence(AsmToken::TokenKind K,\n                                         MCBinaryExpr::Opcode &Kind,\n                                         bool ShouldUseLogicalShr) {\n  switch (K) {\n  default:\n    return 0; // not a binop.\n\n  // Lowest Precedence: &&, ||\n  case AsmToken::AmpAmp:\n    Kind = MCBinaryExpr::LAnd;\n    return 1;\n  case AsmToken::PipePipe:\n    Kind = MCBinaryExpr::LOr;\n    return 1;\n\n  // Low Precedence: |, &, ^\n  case AsmToken::Pipe:\n    Kind = MCBinaryExpr::Or;\n    return 2;\n  case AsmToken::Caret:\n    Kind = MCBinaryExpr::Xor;\n    return 2;\n  case AsmToken::Amp:\n    Kind = MCBinaryExpr::And;\n    return 2;\n\n  // Low Intermediate Precedence: ==, !=, <>, <, <=, >, >=\n  case AsmToken::EqualEqual:\n    Kind = MCBinaryExpr::EQ;\n    return 3;\n  case AsmToken::ExclaimEqual:\n  case AsmToken::LessGreater:\n    Kind = MCBinaryExpr::NE;\n    return 3;\n  case AsmToken::Less:\n    Kind = MCBinaryExpr::LT;\n    return 3;\n  case AsmToken::LessEqual:\n    Kind = MCBinaryExpr::LTE;\n    return 3;\n  case AsmToken::Greater:\n    Kind = MCBinaryExpr::GT;\n    return 3;\n  case AsmToken::GreaterEqual:\n    Kind = MCBinaryExpr::GTE;\n    return 3;\n\n  // Intermediate Precedence: <<, >>\n  case AsmToken::LessLess:\n    Kind = MCBinaryExpr::Shl;\n    return 4;\n  case AsmToken::GreaterGreater:\n    Kind = ShouldUseLogicalShr ? MCBinaryExpr::LShr : MCBinaryExpr::AShr;\n    return 4;\n\n  // High Intermediate Precedence: +, -\n  case AsmToken::Plus:\n    Kind = MCBinaryExpr::Add;\n    return 5;\n  case AsmToken::Minus:\n    Kind = MCBinaryExpr::Sub;\n    return 5;\n\n  // Highest Precedence: *, /, %\n  case AsmToken::Star:\n    Kind = MCBinaryExpr::Mul;\n    return 6;\n  case AsmToken::Slash:\n    Kind = MCBinaryExpr::Div;\n    return 6;\n  case AsmToken::Percent:\n    Kind = MCBinaryExpr::Mod;\n    return 6;\n  }\n}\n\nstatic unsigned getGNUBinOpPrecedence(const MCAsmInfo &MAI,\n                                      AsmToken::TokenKind K,\n                                      MCBinaryExpr::Opcode &Kind,\n                                      bool ShouldUseLogicalShr) {\n  switch (K) {\n  default:\n    return 0; // not a binop.\n\n  // Lowest Precedence: &&, ||\n  case AsmToken::AmpAmp:\n    Kind = MCBinaryExpr::LAnd;\n    return 2;\n  case AsmToken::PipePipe:\n    Kind = MCBinaryExpr::LOr;\n    return 1;\n\n  // Low Precedence: ==, !=, <>, <, <=, >, >=\n  case AsmToken::EqualEqual:\n    Kind = MCBinaryExpr::EQ;\n    return 3;\n  case AsmToken::ExclaimEqual:\n  case AsmToken::LessGreater:\n    Kind = MCBinaryExpr::NE;\n    return 3;\n  case AsmToken::Less:\n    Kind = MCBinaryExpr::LT;\n    return 3;\n  case AsmToken::LessEqual:\n    Kind = MCBinaryExpr::LTE;\n    return 3;\n  case AsmToken::Greater:\n    Kind = MCBinaryExpr::GT;\n    return 3;\n  case AsmToken::GreaterEqual:\n    Kind = MCBinaryExpr::GTE;\n    return 3;\n\n  // Low Intermediate Precedence: +, -\n  case AsmToken::Plus:\n    Kind = MCBinaryExpr::Add;\n    return 4;\n  case AsmToken::Minus:\n    Kind = MCBinaryExpr::Sub;\n    return 4;\n\n  // High Intermediate Precedence: |, !, &, ^\n  //\n  case AsmToken::Pipe:\n    Kind = MCBinaryExpr::Or;\n    return 5;\n  case AsmToken::Exclaim:\n    // Hack to support ARM compatible aliases (implied 'sp' operand in 'srs*'\n    // instructions like 'srsda #31!') and not parse ! as an infix operator.\n    if (MAI.getCommentString() == \"@\")\n      return 0;\n    Kind = MCBinaryExpr::OrNot;\n    return 5;\n  case AsmToken::Caret:\n    Kind = MCBinaryExpr::Xor;\n    return 5;\n  case AsmToken::Amp:\n    Kind = MCBinaryExpr::And;\n    return 5;\n\n  // Highest Precedence: *, /, %, <<, >>\n  case AsmToken::Star:\n    Kind = MCBinaryExpr::Mul;\n    return 6;\n  case AsmToken::Slash:\n    Kind = MCBinaryExpr::Div;\n    return 6;\n  case AsmToken::Percent:\n    Kind = MCBinaryExpr::Mod;\n    return 6;\n  case AsmToken::LessLess:\n    Kind = MCBinaryExpr::Shl;\n    return 6;\n  case AsmToken::GreaterGreater:\n    Kind = ShouldUseLogicalShr ? MCBinaryExpr::LShr : MCBinaryExpr::AShr;\n    return 6;\n  }\n}\n\nunsigned AsmParser::getBinOpPrecedence(AsmToken::TokenKind K,\n                                       MCBinaryExpr::Opcode &Kind) {\n  bool ShouldUseLogicalShr = MAI.shouldUseLogicalShr();\n  return IsDarwin ? getDarwinBinOpPrecedence(K, Kind, ShouldUseLogicalShr)\n                  : getGNUBinOpPrecedence(MAI, K, Kind, ShouldUseLogicalShr);\n}\n\n/// Parse all binary operators with precedence >= 'Precedence'.\n/// Res contains the LHS of the expression on input.\nbool AsmParser::parseBinOpRHS(unsigned Precedence, const MCExpr *&Res,\n                              SMLoc &EndLoc) {\n  SMLoc StartLoc = Lexer.getLoc();\n  while (true) {\n    MCBinaryExpr::Opcode Kind = MCBinaryExpr::Add;\n    unsigned TokPrec = getBinOpPrecedence(Lexer.getKind(), Kind);\n\n    // If the next token is lower precedence than we are allowed to eat, return\n    // successfully with what we ate already.\n    if (TokPrec < Precedence)\n      return false;\n\n    Lex();\n\n    // Eat the next primary expression.\n    const MCExpr *RHS;\n    if (getTargetParser().parsePrimaryExpr(RHS, EndLoc))\n      return true;\n\n    // If BinOp binds less tightly with RHS than the operator after RHS, let\n    // the pending operator take RHS as its LHS.\n    MCBinaryExpr::Opcode Dummy;\n    unsigned NextTokPrec = getBinOpPrecedence(Lexer.getKind(), Dummy);\n    if (TokPrec < NextTokPrec && parseBinOpRHS(TokPrec + 1, RHS, EndLoc))\n      return true;\n\n    // Merge LHS and RHS according to operator.\n    Res = MCBinaryExpr::create(Kind, Res, RHS, getContext(), StartLoc);\n  }\n}\n\n/// ParseStatement:\n///   ::= EndOfStatement\n///   ::= Label* Directive ...Operands... EndOfStatement\n///   ::= Label* Identifier OperandList* EndOfStatement\nbool AsmParser::parseStatement(ParseStatementInfo &Info,\n                               MCAsmParserSemaCallback *SI) {\n  assert(!hasPendingError() && \"parseStatement started with pending error\");\n  // Eat initial spaces and comments\n  while (Lexer.is(AsmToken::Space))\n    Lex();\n  if (Lexer.is(AsmToken::EndOfStatement)) {\n    // if this is a line comment we can drop it safely\n    if (getTok().getString().empty() || getTok().getString().front() == '\\r' ||\n        getTok().getString().front() == '\\n')\n      Out.AddBlankLine();\n    Lex();\n    return false;\n  }\n  // Statements always start with an identifier.\n  AsmToken ID = getTok();\n  SMLoc IDLoc = ID.getLoc();\n  StringRef IDVal;\n  int64_t LocalLabelVal = -1;\n  StartTokLoc = ID.getLoc();\n  if (Lexer.is(AsmToken::HashDirective))\n    return parseCppHashLineFilenameComment(IDLoc,\n                                           !isInsideMacroInstantiation());\n\n  // Allow an integer followed by a ':' as a directional local label.\n  if (Lexer.is(AsmToken::Integer)) {\n    LocalLabelVal = getTok().getIntVal();\n    if (LocalLabelVal < 0) {\n      if (!TheCondState.Ignore) {\n        Lex(); // always eat a token\n        return Error(IDLoc, \"unexpected token at start of statement\");\n      }\n      IDVal = \"\";\n    } else {\n      IDVal = getTok().getString();\n      Lex(); // Consume the integer token to be used as an identifier token.\n      if (Lexer.getKind() != AsmToken::Colon) {\n        if (!TheCondState.Ignore) {\n          Lex(); // always eat a token\n          return Error(IDLoc, \"unexpected token at start of statement\");\n        }\n      }\n    }\n  } else if (Lexer.is(AsmToken::Dot)) {\n    // Treat '.' as a valid identifier in this context.\n    Lex();\n    IDVal = \".\";\n  } else if (Lexer.is(AsmToken::LCurly)) {\n    // Treat '{' as a valid identifier in this context.\n    Lex();\n    IDVal = \"{\";\n\n  } else if (Lexer.is(AsmToken::RCurly)) {\n    // Treat '}' as a valid identifier in this context.\n    Lex();\n    IDVal = \"}\";\n  } else if (Lexer.is(AsmToken::Star) &&\n             getTargetParser().starIsStartOfStatement()) {\n    // Accept '*' as a valid start of statement.\n    Lex();\n    IDVal = \"*\";\n  } else if (parseIdentifier(IDVal)) {\n    if (!TheCondState.Ignore) {\n      Lex(); // always eat a token\n      return Error(IDLoc, \"unexpected token at start of statement\");\n    }\n    IDVal = \"\";\n  }\n\n  // Handle conditional assembly here before checking for skipping.  We\n  // have to do this so that .endif isn't skipped in a \".if 0\" block for\n  // example.\n  StringMap<DirectiveKind>::const_iterator DirKindIt =\n      DirectiveKindMap.find(IDVal.lower());\n  DirectiveKind DirKind = (DirKindIt == DirectiveKindMap.end())\n\n                              ? DK_NO_DIRECTIVE\n                              : DirKindIt->getValue();\n  switch (DirKind) {\n  default:\n    break;\n  case DK_IF:\n  case DK_IFEQ:\n  case DK_IFGE:\n  case DK_IFGT:\n  case DK_IFLE:\n  case DK_IFLT:\n  case DK_IFNE:\n    return parseDirectiveIf(IDLoc, DirKind);\n  case DK_IFB:\n    return parseDirectiveIfb(IDLoc, true);\n  case DK_IFNB:\n    return parseDirectiveIfb(IDLoc, false);\n  case DK_IFC:\n    return parseDirectiveIfc(IDLoc, true);\n  case DK_IFEQS:\n    return parseDirectiveIfeqs(IDLoc, true);\n  case DK_IFNC:\n    return parseDirectiveIfc(IDLoc, false);\n  case DK_IFNES:\n    return parseDirectiveIfeqs(IDLoc, false);\n  case DK_IFDEF:\n    return parseDirectiveIfdef(IDLoc, true);\n  case DK_IFNDEF:\n  case DK_IFNOTDEF:\n    return parseDirectiveIfdef(IDLoc, false);\n  case DK_ELSEIF:\n    return parseDirectiveElseIf(IDLoc);\n  case DK_ELSE:\n    return parseDirectiveElse(IDLoc);\n  case DK_ENDIF:\n    return parseDirectiveEndIf(IDLoc);\n  }\n\n  // Ignore the statement if in the middle of inactive conditional\n  // (e.g. \".if 0\").\n  if (TheCondState.Ignore) {\n    eatToEndOfStatement();\n    return false;\n  }\n\n  // FIXME: Recurse on local labels?\n\n  // See what kind of statement we have.\n  switch (Lexer.getKind()) {\n  case AsmToken::Colon: {\n    if (!getTargetParser().isLabel(ID))\n      break;\n    if (checkForValidSection())\n      return true;\n\n    // identifier ':'   -> Label.\n    Lex();\n\n    // Diagnose attempt to use '.' as a label.\n    if (IDVal == \".\")\n      return Error(IDLoc, \"invalid use of pseudo-symbol '.' as a label\");\n\n    // Diagnose attempt to use a variable as a label.\n    //\n    // FIXME: Diagnostics. Note the location of the definition as a label.\n    // FIXME: This doesn't diagnose assignment to a symbol which has been\n    // implicitly marked as external.\n    MCSymbol *Sym;\n    if (LocalLabelVal == -1) {\n      if (ParsingMSInlineAsm && SI) {\n        StringRef RewrittenLabel =\n            SI->LookupInlineAsmLabel(IDVal, getSourceManager(), IDLoc, true);\n        assert(!RewrittenLabel.empty() &&\n               \"We should have an internal name here.\");\n        Info.AsmRewrites->emplace_back(AOK_Label, IDLoc, IDVal.size(),\n                                       RewrittenLabel);\n        IDVal = RewrittenLabel;\n      }\n      Sym = getContext().getOrCreateSymbol(IDVal);\n    } else\n      Sym = Ctx.createDirectionalLocalSymbol(LocalLabelVal);\n    // End of Labels should be treated as end of line for lexing\n    // purposes but that information is not available to the Lexer who\n    // does not understand Labels. This may cause us to see a Hash\n    // here instead of a preprocessor line comment.\n    if (getTok().is(AsmToken::Hash)) {\n      StringRef CommentStr = parseStringToEndOfStatement();\n      Lexer.Lex();\n      Lexer.UnLex(AsmToken(AsmToken::EndOfStatement, CommentStr));\n    }\n\n    // Consume any end of statement token, if present, to avoid spurious\n    // AddBlankLine calls().\n    if (getTok().is(AsmToken::EndOfStatement)) {\n      Lex();\n    }\n\n    getTargetParser().doBeforeLabelEmit(Sym);\n\n    // Emit the label.\n    if (!getTargetParser().isParsingMSInlineAsm())\n      Out.emitLabel(Sym, IDLoc);\n\n    // If we are generating dwarf for assembly source files then gather the\n    // info to make a dwarf label entry for this label if needed.\n    if (enabledGenDwarfForAssembly())\n      MCGenDwarfLabelEntry::Make(Sym, &getStreamer(), getSourceManager(),\n                                 IDLoc);\n\n    getTargetParser().onLabelParsed(Sym);\n\n    return false;\n  }\n\n  case AsmToken::Equal:\n    if (!getTargetParser().equalIsAsmAssignment())\n      break;\n    // identifier '=' ... -> assignment statement\n    Lex();\n\n    return parseAssignment(IDVal, true);\n\n  default: // Normal instruction or directive.\n    break;\n  }\n\n  // If macros are enabled, check to see if this is a macro instantiation.\n  if (areMacrosEnabled())\n    if (const MCAsmMacro *M = getContext().lookupMacro(IDVal)) {\n      return handleMacroEntry(M, IDLoc);\n    }\n\n  // Otherwise, we have a normal instruction or directive.\n\n  // Directives start with \".\"\n  if (IDVal.startswith(\".\") && IDVal != \".\") {\n    // There are several entities interested in parsing directives:\n    //\n    // 1. The target-specific assembly parser. Some directives are target\n    //    specific or may potentially behave differently on certain targets.\n    // 2. Asm parser extensions. For example, platform-specific parsers\n    //    (like the ELF parser) register themselves as extensions.\n    // 3. The generic directive parser implemented by this class. These are\n    //    all the directives that behave in a target and platform independent\n    //    manner, or at least have a default behavior that's shared between\n    //    all targets and platforms.\n\n    getTargetParser().flushPendingInstructions(getStreamer());\n\n    SMLoc StartTokLoc = getTok().getLoc();\n    bool TPDirectiveReturn = getTargetParser().ParseDirective(ID);\n\n    if (hasPendingError())\n      return true;\n    // Currently the return value should be true if we are\n    // uninterested but as this is at odds with the standard parsing\n    // convention (return true = error) we have instances of a parsed\n    // directive that fails returning true as an error. Catch these\n    // cases as best as possible errors here.\n    if (TPDirectiveReturn && StartTokLoc != getTok().getLoc())\n      return true;\n    // Return if we did some parsing or believe we succeeded.\n    if (!TPDirectiveReturn || StartTokLoc != getTok().getLoc())\n      return false;\n\n    // Next, check the extension directive map to see if any extension has\n    // registered itself to parse this directive.\n    std::pair<MCAsmParserExtension *, DirectiveHandler> Handler =\n        ExtensionDirectiveMap.lookup(IDVal);\n    if (Handler.first)\n      return (*Handler.second)(Handler.first, IDVal, IDLoc);\n\n    // Finally, if no one else is interested in this directive, it must be\n    // generic and familiar to this class.\n    switch (DirKind) {\n    default:\n      break;\n    case DK_SET:\n    case DK_EQU:\n      return parseDirectiveSet(IDVal, true);\n    case DK_EQUIV:\n      return parseDirectiveSet(IDVal, false);\n    case DK_ASCII:\n      return parseDirectiveAscii(IDVal, false);\n    case DK_ASCIZ:\n    case DK_STRING:\n      return parseDirectiveAscii(IDVal, true);\n    case DK_BYTE:\n    case DK_DC_B:\n      return parseDirectiveValue(IDVal, 1);\n    case DK_DC:\n    case DK_DC_W:\n    case DK_SHORT:\n    case DK_VALUE:\n    case DK_2BYTE:\n      return parseDirectiveValue(IDVal, 2);\n    case DK_LONG:\n    case DK_INT:\n    case DK_4BYTE:\n    case DK_DC_L:\n      return parseDirectiveValue(IDVal, 4);\n    case DK_QUAD:\n    case DK_8BYTE:\n      return parseDirectiveValue(IDVal, 8);\n    case DK_DC_A:\n      return parseDirectiveValue(\n          IDVal, getContext().getAsmInfo()->getCodePointerSize());\n    case DK_OCTA:\n      return parseDirectiveOctaValue(IDVal);\n    case DK_SINGLE:\n    case DK_FLOAT:\n    case DK_DC_S:\n      return parseDirectiveRealValue(IDVal, APFloat::IEEEsingle());\n    case DK_DOUBLE:\n    case DK_DC_D:\n      return parseDirectiveRealValue(IDVal, APFloat::IEEEdouble());\n    case DK_ALIGN: {\n      bool IsPow2 = !getContext().getAsmInfo()->getAlignmentIsInBytes();\n      return parseDirectiveAlign(IsPow2, /*ExprSize=*/1);\n    }\n    case DK_ALIGN32: {\n      bool IsPow2 = !getContext().getAsmInfo()->getAlignmentIsInBytes();\n      return parseDirectiveAlign(IsPow2, /*ExprSize=*/4);\n    }\n    case DK_BALIGN:\n      return parseDirectiveAlign(/*IsPow2=*/false, /*ExprSize=*/1);\n    case DK_BALIGNW:\n      return parseDirectiveAlign(/*IsPow2=*/false, /*ExprSize=*/2);\n    case DK_BALIGNL:\n      return parseDirectiveAlign(/*IsPow2=*/false, /*ExprSize=*/4);\n    case DK_P2ALIGN:\n      return parseDirectiveAlign(/*IsPow2=*/true, /*ExprSize=*/1);\n    case DK_P2ALIGNW:\n      return parseDirectiveAlign(/*IsPow2=*/true, /*ExprSize=*/2);\n    case DK_P2ALIGNL:\n      return parseDirectiveAlign(/*IsPow2=*/true, /*ExprSize=*/4);\n    case DK_ORG:\n      return parseDirectiveOrg();\n    case DK_FILL:\n      return parseDirectiveFill();\n    case DK_ZERO:\n      return parseDirectiveZero();\n    case DK_EXTERN:\n      eatToEndOfStatement(); // .extern is the default, ignore it.\n      return false;\n    case DK_GLOBL:\n    case DK_GLOBAL:\n      return parseDirectiveSymbolAttribute(MCSA_Global);\n    case DK_LAZY_REFERENCE:\n      return parseDirectiveSymbolAttribute(MCSA_LazyReference);\n    case DK_NO_DEAD_STRIP:\n      return parseDirectiveSymbolAttribute(MCSA_NoDeadStrip);\n    case DK_SYMBOL_RESOLVER:\n      return parseDirectiveSymbolAttribute(MCSA_SymbolResolver);\n    case DK_PRIVATE_EXTERN:\n      return parseDirectiveSymbolAttribute(MCSA_PrivateExtern);\n    case DK_REFERENCE:\n      return parseDirectiveSymbolAttribute(MCSA_Reference);\n    case DK_WEAK_DEFINITION:\n      return parseDirectiveSymbolAttribute(MCSA_WeakDefinition);\n    case DK_WEAK_REFERENCE:\n      return parseDirectiveSymbolAttribute(MCSA_WeakReference);\n    case DK_WEAK_DEF_CAN_BE_HIDDEN:\n      return parseDirectiveSymbolAttribute(MCSA_WeakDefAutoPrivate);\n    case DK_COLD:\n      return parseDirectiveSymbolAttribute(MCSA_Cold);\n    case DK_COMM:\n    case DK_COMMON:\n      return parseDirectiveComm(/*IsLocal=*/false);\n    case DK_LCOMM:\n      return parseDirectiveComm(/*IsLocal=*/true);\n    case DK_ABORT:\n      return parseDirectiveAbort();\n    case DK_INCLUDE:\n      return parseDirectiveInclude();\n    case DK_INCBIN:\n      return parseDirectiveIncbin();\n    case DK_CODE16:\n    case DK_CODE16GCC:\n      return TokError(Twine(IDVal) +\n                      \" not currently supported for this target\");\n    case DK_REPT:\n      return parseDirectiveRept(IDLoc, IDVal);\n    case DK_IRP:\n      return parseDirectiveIrp(IDLoc);\n    case DK_IRPC:\n      return parseDirectiveIrpc(IDLoc);\n    case DK_ENDR:\n      return parseDirectiveEndr(IDLoc);\n    case DK_BUNDLE_ALIGN_MODE:\n      return parseDirectiveBundleAlignMode();\n    case DK_BUNDLE_LOCK:\n      return parseDirectiveBundleLock();\n    case DK_BUNDLE_UNLOCK:\n      return parseDirectiveBundleUnlock();\n    case DK_SLEB128:\n      return parseDirectiveLEB128(true);\n    case DK_ULEB128:\n      return parseDirectiveLEB128(false);\n    case DK_SPACE:\n    case DK_SKIP:\n      return parseDirectiveSpace(IDVal);\n    case DK_FILE:\n      return parseDirectiveFile(IDLoc);\n    case DK_LINE:\n      return parseDirectiveLine();\n    case DK_LOC:\n      return parseDirectiveLoc();\n    case DK_STABS:\n      return parseDirectiveStabs();\n    case DK_CV_FILE:\n      return parseDirectiveCVFile();\n    case DK_CV_FUNC_ID:\n      return parseDirectiveCVFuncId();\n    case DK_CV_INLINE_SITE_ID:\n      return parseDirectiveCVInlineSiteId();\n    case DK_CV_LOC:\n      return parseDirectiveCVLoc();\n    case DK_CV_LINETABLE:\n      return parseDirectiveCVLinetable();\n    case DK_CV_INLINE_LINETABLE:\n      return parseDirectiveCVInlineLinetable();\n    case DK_CV_DEF_RANGE:\n      return parseDirectiveCVDefRange();\n    case DK_CV_STRING:\n      return parseDirectiveCVString();\n    case DK_CV_STRINGTABLE:\n      return parseDirectiveCVStringTable();\n    case DK_CV_FILECHECKSUMS:\n      return parseDirectiveCVFileChecksums();\n    case DK_CV_FILECHECKSUM_OFFSET:\n      return parseDirectiveCVFileChecksumOffset();\n    case DK_CV_FPO_DATA:\n      return parseDirectiveCVFPOData();\n    case DK_CFI_SECTIONS:\n      return parseDirectiveCFISections();\n    case DK_CFI_STARTPROC:\n      return parseDirectiveCFIStartProc();\n    case DK_CFI_ENDPROC:\n      return parseDirectiveCFIEndProc();\n    case DK_CFI_DEF_CFA:\n      return parseDirectiveCFIDefCfa(IDLoc);\n    case DK_CFI_DEF_CFA_OFFSET:\n      return parseDirectiveCFIDefCfaOffset();\n    case DK_CFI_ADJUST_CFA_OFFSET:\n      return parseDirectiveCFIAdjustCfaOffset();\n    case DK_CFI_DEF_CFA_REGISTER:\n      return parseDirectiveCFIDefCfaRegister(IDLoc);\n    case DK_CFI_OFFSET:\n      return parseDirectiveCFIOffset(IDLoc);\n    case DK_CFI_REL_OFFSET:\n      return parseDirectiveCFIRelOffset(IDLoc);\n    case DK_CFI_PERSONALITY:\n      return parseDirectiveCFIPersonalityOrLsda(true);\n    case DK_CFI_LSDA:\n      return parseDirectiveCFIPersonalityOrLsda(false);\n    case DK_CFI_REMEMBER_STATE:\n      return parseDirectiveCFIRememberState();\n    case DK_CFI_RESTORE_STATE:\n      return parseDirectiveCFIRestoreState();\n    case DK_CFI_SAME_VALUE:\n      return parseDirectiveCFISameValue(IDLoc);\n    case DK_CFI_RESTORE:\n      return parseDirectiveCFIRestore(IDLoc);\n    case DK_CFI_ESCAPE:\n      return parseDirectiveCFIEscape();\n    case DK_CFI_RETURN_COLUMN:\n      return parseDirectiveCFIReturnColumn(IDLoc);\n    case DK_CFI_SIGNAL_FRAME:\n      return parseDirectiveCFISignalFrame();\n    case DK_CFI_UNDEFINED:\n      return parseDirectiveCFIUndefined(IDLoc);\n    case DK_CFI_REGISTER:\n      return parseDirectiveCFIRegister(IDLoc);\n    case DK_CFI_WINDOW_SAVE:\n      return parseDirectiveCFIWindowSave();\n    case DK_MACROS_ON:\n    case DK_MACROS_OFF:\n      return parseDirectiveMacrosOnOff(IDVal);\n    case DK_MACRO:\n      return parseDirectiveMacro(IDLoc);\n    case DK_ALTMACRO:\n    case DK_NOALTMACRO:\n      return parseDirectiveAltmacro(IDVal);\n    case DK_EXITM:\n      return parseDirectiveExitMacro(IDVal);\n    case DK_ENDM:\n    case DK_ENDMACRO:\n      return parseDirectiveEndMacro(IDVal);\n    case DK_PURGEM:\n      return parseDirectivePurgeMacro(IDLoc);\n    case DK_END:\n      return parseDirectiveEnd(IDLoc);\n    case DK_ERR:\n      return parseDirectiveError(IDLoc, false);\n    case DK_ERROR:\n      return parseDirectiveError(IDLoc, true);\n    case DK_WARNING:\n      return parseDirectiveWarning(IDLoc);\n    case DK_RELOC:\n      return parseDirectiveReloc(IDLoc);\n    case DK_DCB:\n    case DK_DCB_W:\n      return parseDirectiveDCB(IDVal, 2);\n    case DK_DCB_B:\n      return parseDirectiveDCB(IDVal, 1);\n    case DK_DCB_D:\n      return parseDirectiveRealDCB(IDVal, APFloat::IEEEdouble());\n    case DK_DCB_L:\n      return parseDirectiveDCB(IDVal, 4);\n    case DK_DCB_S:\n      return parseDirectiveRealDCB(IDVal, APFloat::IEEEsingle());\n    case DK_DC_X:\n    case DK_DCB_X:\n      return TokError(Twine(IDVal) +\n                      \" not currently supported for this target\");\n    case DK_DS:\n    case DK_DS_W:\n      return parseDirectiveDS(IDVal, 2);\n    case DK_DS_B:\n      return parseDirectiveDS(IDVal, 1);\n    case DK_DS_D:\n      return parseDirectiveDS(IDVal, 8);\n    case DK_DS_L:\n    case DK_DS_S:\n      return parseDirectiveDS(IDVal, 4);\n    case DK_DS_P:\n    case DK_DS_X:\n      return parseDirectiveDS(IDVal, 12);\n    case DK_PRINT:\n      return parseDirectivePrint(IDLoc);\n    case DK_ADDRSIG:\n      return parseDirectiveAddrsig();\n    case DK_ADDRSIG_SYM:\n      return parseDirectiveAddrsigSym();\n    case DK_PSEUDO_PROBE:\n      return parseDirectivePseudoProbe();\n    }\n\n    return Error(IDLoc, \"unknown directive\");\n  }\n\n  // __asm _emit or __asm __emit\n  if (ParsingMSInlineAsm && (IDVal == \"_emit\" || IDVal == \"__emit\" ||\n                             IDVal == \"_EMIT\" || IDVal == \"__EMIT\"))\n    return parseDirectiveMSEmit(IDLoc, Info, IDVal.size());\n\n  // __asm align\n  if (ParsingMSInlineAsm && (IDVal == \"align\" || IDVal == \"ALIGN\"))\n    return parseDirectiveMSAlign(IDLoc, Info);\n\n  if (ParsingMSInlineAsm && (IDVal == \"even\" || IDVal == \"EVEN\"))\n    Info.AsmRewrites->emplace_back(AOK_EVEN, IDLoc, 4);\n  if (checkForValidSection())\n    return true;\n\n  // Canonicalize the opcode to lower case.\n  std::string OpcodeStr = IDVal.lower();\n  ParseInstructionInfo IInfo(Info.AsmRewrites);\n  bool ParseHadError = getTargetParser().ParseInstruction(IInfo, OpcodeStr, ID,\n                                                          Info.ParsedOperands);\n  Info.ParseError = ParseHadError;\n\n  // Dump the parsed representation, if requested.\n  if (getShowParsedOperands()) {\n    SmallString<256> Str;\n    raw_svector_ostream OS(Str);\n    OS << \"parsed instruction: [\";\n    for (unsigned i = 0; i != Info.ParsedOperands.size(); ++i) {\n      if (i != 0)\n        OS << \", \";\n      Info.ParsedOperands[i]->print(OS);\n    }\n    OS << \"]\";\n\n    printMessage(IDLoc, SourceMgr::DK_Note, OS.str());\n  }\n\n  // Fail even if ParseInstruction erroneously returns false.\n  if (hasPendingError() || ParseHadError)\n    return true;\n\n  // If we are generating dwarf for the current section then generate a .loc\n  // directive for the instruction.\n  if (!ParseHadError && enabledGenDwarfForAssembly() &&\n      getContext().getGenDwarfSectionSyms().count(\n          getStreamer().getCurrentSectionOnly())) {\n    unsigned Line;\n    if (ActiveMacros.empty())\n      Line = SrcMgr.FindLineNumber(IDLoc, CurBuffer);\n    else\n      Line = SrcMgr.FindLineNumber(ActiveMacros.front()->InstantiationLoc,\n                                   ActiveMacros.front()->ExitBuffer);\n\n    // If we previously parsed a cpp hash file line comment then make sure the\n    // current Dwarf File is for the CppHashFilename if not then emit the\n    // Dwarf File table for it and adjust the line number for the .loc.\n    if (!CppHashInfo.Filename.empty()) {\n      unsigned FileNumber = getStreamer().emitDwarfFileDirective(\n          0, StringRef(), CppHashInfo.Filename);\n      getContext().setGenDwarfFileNumber(FileNumber);\n\n      unsigned CppHashLocLineNo =\n        SrcMgr.FindLineNumber(CppHashInfo.Loc, CppHashInfo.Buf);\n      Line = CppHashInfo.LineNumber - 1 + (Line - CppHashLocLineNo);\n    }\n\n    getStreamer().emitDwarfLocDirective(\n        getContext().getGenDwarfFileNumber(), Line, 0,\n        DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0, 0, 0,\n        StringRef());\n  }\n\n  // If parsing succeeded, match the instruction.\n  if (!ParseHadError) {\n    uint64_t ErrorInfo;\n    if (getTargetParser().MatchAndEmitInstruction(\n            IDLoc, Info.Opcode, Info.ParsedOperands, Out, ErrorInfo,\n            getTargetParser().isParsingMSInlineAsm()))\n      return true;\n  }\n  return false;\n}\n\n// Parse and erase curly braces marking block start/end\nbool\nAsmParser::parseCurlyBlockScope(SmallVectorImpl<AsmRewrite> &AsmStrRewrites) {\n  // Identify curly brace marking block start/end\n  if (Lexer.isNot(AsmToken::LCurly) && Lexer.isNot(AsmToken::RCurly))\n    return false;\n\n  SMLoc StartLoc = Lexer.getLoc();\n  Lex(); // Eat the brace\n  if (Lexer.is(AsmToken::EndOfStatement))\n    Lex(); // Eat EndOfStatement following the brace\n\n  // Erase the block start/end brace from the output asm string\n  AsmStrRewrites.emplace_back(AOK_Skip, StartLoc, Lexer.getLoc().getPointer() -\n                                                  StartLoc.getPointer());\n  return true;\n}\n\n/// parseCppHashLineFilenameComment as this:\n///   ::= # number \"filename\"\nbool AsmParser::parseCppHashLineFilenameComment(SMLoc L, bool SaveLocInfo) {\n  Lex(); // Eat the hash token.\n  // Lexer only ever emits HashDirective if it fully formed if it's\n  // done the checking already so this is an internal error.\n  assert(getTok().is(AsmToken::Integer) &&\n         \"Lexing Cpp line comment: Expected Integer\");\n  int64_t LineNumber = getTok().getIntVal();\n  Lex();\n  assert(getTok().is(AsmToken::String) &&\n         \"Lexing Cpp line comment: Expected String\");\n  StringRef Filename = getTok().getString();\n  Lex();\n\n  if (!SaveLocInfo)\n    return false;\n\n  // Get rid of the enclosing quotes.\n  Filename = Filename.substr(1, Filename.size() - 2);\n\n  // Save the SMLoc, Filename and LineNumber for later use by diagnostics\n  // and possibly DWARF file info.\n  CppHashInfo.Loc = L;\n  CppHashInfo.Filename = Filename;\n  CppHashInfo.LineNumber = LineNumber;\n  CppHashInfo.Buf = CurBuffer;\n  if (FirstCppHashFilename.empty())\n    FirstCppHashFilename = Filename;\n  return false;\n}\n\n/// will use the last parsed cpp hash line filename comment\n/// for the Filename and LineNo if any in the diagnostic.\nvoid AsmParser::DiagHandler(const SMDiagnostic &Diag, void *Context) {\n  auto *Parser = static_cast<AsmParser *>(Context);\n  raw_ostream &OS = errs();\n\n  const SourceMgr &DiagSrcMgr = *Diag.getSourceMgr();\n  SMLoc DiagLoc = Diag.getLoc();\n  unsigned DiagBuf = DiagSrcMgr.FindBufferContainingLoc(DiagLoc);\n  unsigned CppHashBuf =\n      Parser->SrcMgr.FindBufferContainingLoc(Parser->CppHashInfo.Loc);\n\n  // Like SourceMgr::printMessage() we need to print the include stack if any\n  // before printing the message.\n  unsigned DiagCurBuffer = DiagSrcMgr.FindBufferContainingLoc(DiagLoc);\n  if (!Parser->SavedDiagHandler && DiagCurBuffer &&\n      DiagCurBuffer != DiagSrcMgr.getMainFileID()) {\n    SMLoc ParentIncludeLoc = DiagSrcMgr.getParentIncludeLoc(DiagCurBuffer);\n    DiagSrcMgr.PrintIncludeStack(ParentIncludeLoc, OS);\n  }\n\n  // If we have not parsed a cpp hash line filename comment or the source\n  // manager changed or buffer changed (like in a nested include) then just\n  // print the normal diagnostic using its Filename and LineNo.\n  if (!Parser->CppHashInfo.LineNumber || DiagBuf != CppHashBuf) {\n    if (Parser->SavedDiagHandler)\n      Parser->SavedDiagHandler(Diag, Parser->SavedDiagContext);\n    else\n      Parser->getContext().diagnose(Diag);\n    return;\n  }\n\n  // Use the CppHashFilename and calculate a line number based on the\n  // CppHashInfo.Loc and CppHashInfo.LineNumber relative to this Diag's SMLoc\n  // for the diagnostic.\n  const std::string &Filename = std::string(Parser->CppHashInfo.Filename);\n\n  int DiagLocLineNo = DiagSrcMgr.FindLineNumber(DiagLoc, DiagBuf);\n  int CppHashLocLineNo =\n      Parser->SrcMgr.FindLineNumber(Parser->CppHashInfo.Loc, CppHashBuf);\n  int LineNo =\n      Parser->CppHashInfo.LineNumber - 1 + (DiagLocLineNo - CppHashLocLineNo);\n\n  SMDiagnostic NewDiag(*Diag.getSourceMgr(), Diag.getLoc(), Filename, LineNo,\n                       Diag.getColumnNo(), Diag.getKind(), Diag.getMessage(),\n                       Diag.getLineContents(), Diag.getRanges());\n\n  if (Parser->SavedDiagHandler)\n    Parser->SavedDiagHandler(Diag, Parser->SavedDiagContext);\n  else\n    Parser->getContext().diagnose(NewDiag);\n}\n\n// FIXME: This is mostly duplicated from the function in AsmLexer.cpp. The\n// difference being that that function accepts '@' as part of identifiers and\n// we can't do that. AsmLexer.cpp should probably be changed to handle\n// '@' as a special case when needed.\nstatic bool isIdentifierChar(char c) {\n  return isalnum(static_cast<unsigned char>(c)) || c == '_' || c == '$' ||\n         c == '.';\n}\n\nbool AsmParser::expandMacro(raw_svector_ostream &OS, StringRef Body,\n                            ArrayRef<MCAsmMacroParameter> Parameters,\n                            ArrayRef<MCAsmMacroArgument> A,\n                            bool EnableAtPseudoVariable, SMLoc L) {\n  unsigned NParameters = Parameters.size();\n  bool HasVararg = NParameters ? Parameters.back().Vararg : false;\n  if ((!IsDarwin || NParameters != 0) && NParameters != A.size())\n    return Error(L, \"Wrong number of arguments\");\n\n  // A macro without parameters is handled differently on Darwin:\n  // gas accepts no arguments and does no substitutions\n  while (!Body.empty()) {\n    // Scan for the next substitution.\n    std::size_t End = Body.size(), Pos = 0;\n    for (; Pos != End; ++Pos) {\n      // Check for a substitution or escape.\n      if (IsDarwin && !NParameters) {\n        // This macro has no parameters, look for $0, $1, etc.\n        if (Body[Pos] != '$' || Pos + 1 == End)\n          continue;\n\n        char Next = Body[Pos + 1];\n        if (Next == '$' || Next == 'n' ||\n            isdigit(static_cast<unsigned char>(Next)))\n          break;\n      } else {\n        // This macro has parameters, look for \\foo, \\bar, etc.\n        if (Body[Pos] == '\\\\' && Pos + 1 != End)\n          break;\n      }\n    }\n\n    // Add the prefix.\n    OS << Body.slice(0, Pos);\n\n    // Check if we reached the end.\n    if (Pos == End)\n      break;\n\n    if (IsDarwin && !NParameters) {\n      switch (Body[Pos + 1]) {\n      // $$ => $\n      case '$':\n        OS << '$';\n        break;\n\n      // $n => number of arguments\n      case 'n':\n        OS << A.size();\n        break;\n\n      // $[0-9] => argument\n      default: {\n        // Missing arguments are ignored.\n        unsigned Index = Body[Pos + 1] - '0';\n        if (Index >= A.size())\n          break;\n\n        // Otherwise substitute with the token values, with spaces eliminated.\n        for (const AsmToken &Token : A[Index])\n          OS << Token.getString();\n        break;\n      }\n      }\n      Pos += 2;\n    } else {\n      unsigned I = Pos + 1;\n\n      // Check for the \\@ pseudo-variable.\n      if (EnableAtPseudoVariable && Body[I] == '@' && I + 1 != End)\n        ++I;\n      else\n        while (isIdentifierChar(Body[I]) && I + 1 != End)\n          ++I;\n\n      const char *Begin = Body.data() + Pos + 1;\n      StringRef Argument(Begin, I - (Pos + 1));\n      unsigned Index = 0;\n\n      if (Argument == \"@\") {\n        OS << NumOfMacroInstantiations;\n        Pos += 2;\n      } else {\n        for (; Index < NParameters; ++Index)\n          if (Parameters[Index].Name == Argument)\n            break;\n\n        if (Index == NParameters) {\n          if (Body[Pos + 1] == '(' && Body[Pos + 2] == ')')\n            Pos += 3;\n          else {\n            OS << '\\\\' << Argument;\n            Pos = I;\n          }\n        } else {\n          bool VarargParameter = HasVararg && Index == (NParameters - 1);\n          for (const AsmToken &Token : A[Index])\n            // For altmacro mode, you can write '%expr'.\n            // The prefix '%' evaluates the expression 'expr'\n            // and uses the result as a string (e.g. replace %(1+2) with the\n            // string \"3\").\n            // Here, we identify the integer token which is the result of the\n            // absolute expression evaluation and replace it with its string\n            // representation.\n            if (AltMacroMode && Token.getString().front() == '%' &&\n                Token.is(AsmToken::Integer))\n              // Emit an integer value to the buffer.\n              OS << Token.getIntVal();\n            // Only Token that was validated as a string and begins with '<'\n            // is considered altMacroString!!!\n            else if (AltMacroMode && Token.getString().front() == '<' &&\n                     Token.is(AsmToken::String)) {\n              OS << angleBracketString(Token.getStringContents());\n            }\n            // We expect no quotes around the string's contents when\n            // parsing for varargs.\n            else if (Token.isNot(AsmToken::String) || VarargParameter)\n              OS << Token.getString();\n            else\n              OS << Token.getStringContents();\n\n          Pos += 1 + Argument.size();\n        }\n      }\n    }\n    // Update the scan point.\n    Body = Body.substr(Pos);\n  }\n\n  return false;\n}\n\nstatic bool isOperator(AsmToken::TokenKind kind) {\n  switch (kind) {\n  default:\n    return false;\n  case AsmToken::Plus:\n  case AsmToken::Minus:\n  case AsmToken::Tilde:\n  case AsmToken::Slash:\n  case AsmToken::Star:\n  case AsmToken::Dot:\n  case AsmToken::Equal:\n  case AsmToken::EqualEqual:\n  case AsmToken::Pipe:\n  case AsmToken::PipePipe:\n  case AsmToken::Caret:\n  case AsmToken::Amp:\n  case AsmToken::AmpAmp:\n  case AsmToken::Exclaim:\n  case AsmToken::ExclaimEqual:\n  case AsmToken::Less:\n  case AsmToken::LessEqual:\n  case AsmToken::LessLess:\n  case AsmToken::LessGreater:\n  case AsmToken::Greater:\n  case AsmToken::GreaterEqual:\n  case AsmToken::GreaterGreater:\n    return true;\n  }\n}\n\nnamespace {\n\nclass AsmLexerSkipSpaceRAII {\npublic:\n  AsmLexerSkipSpaceRAII(AsmLexer &Lexer, bool SkipSpace) : Lexer(Lexer) {\n    Lexer.setSkipSpace(SkipSpace);\n  }\n\n  ~AsmLexerSkipSpaceRAII() {\n    Lexer.setSkipSpace(true);\n  }\n\nprivate:\n  AsmLexer &Lexer;\n};\n\n} // end anonymous namespace\n\nbool AsmParser::parseMacroArgument(MCAsmMacroArgument &MA, bool Vararg) {\n\n  if (Vararg) {\n    if (Lexer.isNot(AsmToken::EndOfStatement)) {\n      StringRef Str = parseStringToEndOfStatement();\n      MA.emplace_back(AsmToken::String, Str);\n    }\n    return false;\n  }\n\n  unsigned ParenLevel = 0;\n\n  // Darwin doesn't use spaces to delmit arguments.\n  AsmLexerSkipSpaceRAII ScopedSkipSpace(Lexer, IsDarwin);\n\n  bool SpaceEaten;\n\n  while (true) {\n    SpaceEaten = false;\n    if (Lexer.is(AsmToken::Eof) || Lexer.is(AsmToken::Equal))\n      return TokError(\"unexpected token in macro instantiation\");\n\n    if (ParenLevel == 0) {\n\n      if (Lexer.is(AsmToken::Comma))\n        break;\n\n      if (Lexer.is(AsmToken::Space)) {\n        SpaceEaten = true;\n        Lexer.Lex(); // Eat spaces\n      }\n\n      // Spaces can delimit parameters, but could also be part an expression.\n      // If the token after a space is an operator, add the token and the next\n      // one into this argument\n      if (!IsDarwin) {\n        if (isOperator(Lexer.getKind())) {\n          MA.push_back(getTok());\n          Lexer.Lex();\n\n          // Whitespace after an operator can be ignored.\n          if (Lexer.is(AsmToken::Space))\n            Lexer.Lex();\n\n          continue;\n        }\n      }\n      if (SpaceEaten)\n        break;\n    }\n\n    // handleMacroEntry relies on not advancing the lexer here\n    // to be able to fill in the remaining default parameter values\n    if (Lexer.is(AsmToken::EndOfStatement))\n      break;\n\n    // Adjust the current parentheses level.\n    if (Lexer.is(AsmToken::LParen))\n      ++ParenLevel;\n    else if (Lexer.is(AsmToken::RParen) && ParenLevel)\n      --ParenLevel;\n\n    // Append the token to the current argument list.\n    MA.push_back(getTok());\n    Lexer.Lex();\n  }\n\n  if (ParenLevel != 0)\n    return TokError(\"unbalanced parentheses in macro argument\");\n  return false;\n}\n\n// Parse the macro instantiation arguments.\nbool AsmParser::parseMacroArguments(const MCAsmMacro *M,\n                                    MCAsmMacroArguments &A) {\n  const unsigned NParameters = M ? M->Parameters.size() : 0;\n  bool NamedParametersFound = false;\n  SmallVector<SMLoc, 4> FALocs;\n\n  A.resize(NParameters);\n  FALocs.resize(NParameters);\n\n  // Parse two kinds of macro invocations:\n  // - macros defined without any parameters accept an arbitrary number of them\n  // - macros defined with parameters accept at most that many of them\n  bool HasVararg = NParameters ? M->Parameters.back().Vararg : false;\n  for (unsigned Parameter = 0; !NParameters || Parameter < NParameters;\n       ++Parameter) {\n    SMLoc IDLoc = Lexer.getLoc();\n    MCAsmMacroParameter FA;\n\n    if (Lexer.is(AsmToken::Identifier) && Lexer.peekTok().is(AsmToken::Equal)) {\n      if (parseIdentifier(FA.Name))\n        return Error(IDLoc, \"invalid argument identifier for formal argument\");\n\n      if (Lexer.isNot(AsmToken::Equal))\n        return TokError(\"expected '=' after formal parameter identifier\");\n\n      Lex();\n\n      NamedParametersFound = true;\n    }\n    bool Vararg = HasVararg && Parameter == (NParameters - 1);\n\n    if (NamedParametersFound && FA.Name.empty())\n      return Error(IDLoc, \"cannot mix positional and keyword arguments\");\n\n    SMLoc StrLoc = Lexer.getLoc();\n    SMLoc EndLoc;\n    if (AltMacroMode && Lexer.is(AsmToken::Percent)) {\n      const MCExpr *AbsoluteExp;\n      int64_t Value;\n      /// Eat '%'\n      Lex();\n      if (parseExpression(AbsoluteExp, EndLoc))\n        return false;\n      if (!AbsoluteExp->evaluateAsAbsolute(Value,\n                                           getStreamer().getAssemblerPtr()))\n        return Error(StrLoc, \"expected absolute expression\");\n      const char *StrChar = StrLoc.getPointer();\n      const char *EndChar = EndLoc.getPointer();\n      AsmToken newToken(AsmToken::Integer,\n                        StringRef(StrChar, EndChar - StrChar), Value);\n      FA.Value.push_back(newToken);\n    } else if (AltMacroMode && Lexer.is(AsmToken::Less) &&\n               isAngleBracketString(StrLoc, EndLoc)) {\n      const char *StrChar = StrLoc.getPointer();\n      const char *EndChar = EndLoc.getPointer();\n      jumpToLoc(EndLoc, CurBuffer);\n      /// Eat from '<' to '>'\n      Lex();\n      AsmToken newToken(AsmToken::String,\n                        StringRef(StrChar, EndChar - StrChar));\n      FA.Value.push_back(newToken);\n    } else if(parseMacroArgument(FA.Value, Vararg))\n      return true;\n\n    unsigned PI = Parameter;\n    if (!FA.Name.empty()) {\n      unsigned FAI = 0;\n      for (FAI = 0; FAI < NParameters; ++FAI)\n        if (M->Parameters[FAI].Name == FA.Name)\n          break;\n\n      if (FAI >= NParameters) {\n        assert(M && \"expected macro to be defined\");\n        return Error(IDLoc, \"parameter named '\" + FA.Name +\n                                \"' does not exist for macro '\" + M->Name + \"'\");\n      }\n      PI = FAI;\n    }\n\n    if (!FA.Value.empty()) {\n      if (A.size() <= PI)\n        A.resize(PI + 1);\n      A[PI] = FA.Value;\n\n      if (FALocs.size() <= PI)\n        FALocs.resize(PI + 1);\n\n      FALocs[PI] = Lexer.getLoc();\n    }\n\n    // At the end of the statement, fill in remaining arguments that have\n    // default values. If there aren't any, then the next argument is\n    // required but missing\n    if (Lexer.is(AsmToken::EndOfStatement)) {\n      bool Failure = false;\n      for (unsigned FAI = 0; FAI < NParameters; ++FAI) {\n        if (A[FAI].empty()) {\n          if (M->Parameters[FAI].Required) {\n            Error(FALocs[FAI].isValid() ? FALocs[FAI] : Lexer.getLoc(),\n                  \"missing value for required parameter \"\n                  \"'\" + M->Parameters[FAI].Name + \"' in macro '\" + M->Name + \"'\");\n            Failure = true;\n          }\n\n          if (!M->Parameters[FAI].Value.empty())\n            A[FAI] = M->Parameters[FAI].Value;\n        }\n      }\n      return Failure;\n    }\n\n    if (Lexer.is(AsmToken::Comma))\n      Lex();\n  }\n\n  return TokError(\"too many positional arguments\");\n}\n\nbool AsmParser::handleMacroEntry(const MCAsmMacro *M, SMLoc NameLoc) {\n  // Arbitrarily limit macro nesting depth (default matches 'as'). We can\n  // eliminate this, although we should protect against infinite loops.\n  unsigned MaxNestingDepth = AsmMacroMaxNestingDepth;\n  if (ActiveMacros.size() == MaxNestingDepth) {\n    std::ostringstream MaxNestingDepthError;\n    MaxNestingDepthError << \"macros cannot be nested more than \"\n                         << MaxNestingDepth << \" levels deep.\"\n                         << \" Use -asm-macro-max-nesting-depth to increase \"\n                            \"this limit.\";\n    return TokError(MaxNestingDepthError.str());\n  }\n\n  MCAsmMacroArguments A;\n  if (parseMacroArguments(M, A))\n    return true;\n\n  // Macro instantiation is lexical, unfortunately. We construct a new buffer\n  // to hold the macro body with substitutions.\n  SmallString<256> Buf;\n  StringRef Body = M->Body;\n  raw_svector_ostream OS(Buf);\n\n  if (expandMacro(OS, Body, M->Parameters, A, true, getTok().getLoc()))\n    return true;\n\n  // We include the .endmacro in the buffer as our cue to exit the macro\n  // instantiation.\n  OS << \".endmacro\\n\";\n\n  std::unique_ptr<MemoryBuffer> Instantiation =\n      MemoryBuffer::getMemBufferCopy(OS.str(), \"<instantiation>\");\n\n  // Create the macro instantiation object and add to the current macro\n  // instantiation stack.\n  MacroInstantiation *MI = new MacroInstantiation{\n      NameLoc, CurBuffer, getTok().getLoc(), TheCondStack.size()};\n  ActiveMacros.push_back(MI);\n\n  ++NumOfMacroInstantiations;\n\n  // Jump to the macro instantiation and prime the lexer.\n  CurBuffer = SrcMgr.AddNewSourceBuffer(std::move(Instantiation), SMLoc());\n  Lexer.setBuffer(SrcMgr.getMemoryBuffer(CurBuffer)->getBuffer());\n  Lex();\n\n  return false;\n}\n\nvoid AsmParser::handleMacroExit() {\n  // Jump to the EndOfStatement we should return to, and consume it.\n  jumpToLoc(ActiveMacros.back()->ExitLoc, ActiveMacros.back()->ExitBuffer);\n  Lex();\n\n  // Pop the instantiation entry.\n  delete ActiveMacros.back();\n  ActiveMacros.pop_back();\n}\n\nbool AsmParser::parseAssignment(StringRef Name, bool allow_redef,\n                                bool NoDeadStrip) {\n  MCSymbol *Sym;\n  const MCExpr *Value;\n  if (MCParserUtils::parseAssignmentExpression(Name, allow_redef, *this, Sym,\n                                               Value))\n    return true;\n\n  if (!Sym) {\n    // In the case where we parse an expression starting with a '.', we will\n    // not generate an error, nor will we create a symbol.  In this case we\n    // should just return out.\n    return false;\n  }\n\n  // Do the assignment.\n  Out.emitAssignment(Sym, Value);\n  if (NoDeadStrip)\n    Out.emitSymbolAttribute(Sym, MCSA_NoDeadStrip);\n\n  return false;\n}\n\n/// parseIdentifier:\n///   ::= identifier\n///   ::= string\nbool AsmParser::parseIdentifier(StringRef &Res) {\n  // The assembler has relaxed rules for accepting identifiers, in particular we\n  // allow things like '.globl $foo' and '.def @feat.00', which would normally be\n  // separate tokens. At this level, we have already lexed so we cannot (currently)\n  // handle this as a context dependent token, instead we detect adjacent tokens\n  // and return the combined identifier.\n  if (Lexer.is(AsmToken::Dollar) || Lexer.is(AsmToken::At)) {\n    SMLoc PrefixLoc = getLexer().getLoc();\n\n    // Consume the prefix character, and check for a following identifier.\n\n    AsmToken Buf[1];\n    Lexer.peekTokens(Buf, false);\n\n    if (Buf[0].isNot(AsmToken::Identifier) && Buf[0].isNot(AsmToken::Integer))\n      return true;\n\n    // We have a '$' or '@' followed by an identifier or integer token, make\n    // sure they are adjacent.\n    if (PrefixLoc.getPointer() + 1 != Buf[0].getLoc().getPointer())\n      return true;\n\n    // eat $ or @\n    Lexer.Lex(); // Lexer's Lex guarantees consecutive token.\n    // Construct the joined identifier and consume the token.\n    Res = StringRef(PrefixLoc.getPointer(), getTok().getString().size() + 1);\n    Lex(); // Parser Lex to maintain invariants.\n    return false;\n  }\n\n  if (Lexer.isNot(AsmToken::Identifier) && Lexer.isNot(AsmToken::String))\n    return true;\n\n  Res = getTok().getIdentifier();\n\n  Lex(); // Consume the identifier token.\n\n  return false;\n}\n\n/// parseDirectiveSet:\n///   ::= .equ identifier ',' expression\n///   ::= .equiv identifier ',' expression\n///   ::= .set identifier ',' expression\nbool AsmParser::parseDirectiveSet(StringRef IDVal, bool allow_redef) {\n  StringRef Name;\n  if (check(parseIdentifier(Name), \"expected identifier\") ||\n      parseToken(AsmToken::Comma) || parseAssignment(Name, allow_redef, true))\n    return addErrorSuffix(\" in '\" + Twine(IDVal) + \"' directive\");\n  return false;\n}\n\nbool AsmParser::parseEscapedString(std::string &Data) {\n  if (check(getTok().isNot(AsmToken::String), \"expected string\"))\n    return true;\n\n  Data = \"\";\n  StringRef Str = getTok().getStringContents();\n  for (unsigned i = 0, e = Str.size(); i != e; ++i) {\n    if (Str[i] != '\\\\') {\n      Data += Str[i];\n      continue;\n    }\n\n    // Recognize escaped characters. Note that this escape semantics currently\n    // loosely follows Darwin 'as'.\n    ++i;\n    if (i == e)\n      return TokError(\"unexpected backslash at end of string\");\n\n    // Recognize hex sequences similarly to GNU 'as'.\n    if (Str[i] == 'x' || Str[i] == 'X') {\n      size_t length = Str.size();\n      if (i + 1 >= length || !isHexDigit(Str[i + 1]))\n        return TokError(\"invalid hexadecimal escape sequence\");\n\n      // Consume hex characters. GNU 'as' reads all hexadecimal characters and\n      // then truncates to the lower 16 bits. Seems reasonable.\n      unsigned Value = 0;\n      while (i + 1 < length && isHexDigit(Str[i + 1]))\n        Value = Value * 16 + hexDigitValue(Str[++i]);\n\n      Data += (unsigned char)(Value & 0xFF);\n      continue;\n    }\n\n    // Recognize octal sequences.\n    if ((unsigned)(Str[i] - '0') <= 7) {\n      // Consume up to three octal characters.\n      unsigned Value = Str[i] - '0';\n\n      if (i + 1 != e && ((unsigned)(Str[i + 1] - '0')) <= 7) {\n        ++i;\n        Value = Value * 8 + (Str[i] - '0');\n\n        if (i + 1 != e && ((unsigned)(Str[i + 1] - '0')) <= 7) {\n          ++i;\n          Value = Value * 8 + (Str[i] - '0');\n        }\n      }\n\n      if (Value > 255)\n        return TokError(\"invalid octal escape sequence (out of range)\");\n\n      Data += (unsigned char)Value;\n      continue;\n    }\n\n    // Otherwise recognize individual escapes.\n    switch (Str[i]) {\n    default:\n      // Just reject invalid escape sequences for now.\n      return TokError(\"invalid escape sequence (unrecognized character)\");\n\n    case 'b': Data += '\\b'; break;\n    case 'f': Data += '\\f'; break;\n    case 'n': Data += '\\n'; break;\n    case 'r': Data += '\\r'; break;\n    case 't': Data += '\\t'; break;\n    case '\"': Data += '\"'; break;\n    case '\\\\': Data += '\\\\'; break;\n    }\n  }\n\n  Lex();\n  return false;\n}\n\nbool AsmParser::parseAngleBracketString(std::string &Data) {\n  SMLoc EndLoc, StartLoc = getTok().getLoc();\n  if (isAngleBracketString(StartLoc, EndLoc)) {\n    const char *StartChar = StartLoc.getPointer() + 1;\n    const char *EndChar = EndLoc.getPointer() - 1;\n    jumpToLoc(EndLoc, CurBuffer);\n    /// Eat from '<' to '>'\n    Lex();\n\n    Data = angleBracketString(StringRef(StartChar, EndChar - StartChar));\n    return false;\n  }\n  return true;\n}\n\n/// parseDirectiveAscii:\n//    ::= .ascii [ \"string\"+ ( , \"string\"+ )* ]\n///   ::= ( .asciz | .string ) [ \"string\" ( , \"string\" )* ]\nbool AsmParser::parseDirectiveAscii(StringRef IDVal, bool ZeroTerminated) {\n  auto parseOp = [&]() -> bool {\n    std::string Data;\n    if (checkForValidSection())\n      return true;\n    // Only support spaces as separators for .ascii directive for now. See the\n    // discusssion at https://reviews.llvm.org/D91460 for more details.\n    do {\n      if (parseEscapedString(Data))\n        return true;\n      getStreamer().emitBytes(Data);\n    } while (!ZeroTerminated && getTok().is(AsmToken::String));\n    if (ZeroTerminated)\n      getStreamer().emitBytes(StringRef(\"\\0\", 1));\n    return false;\n  };\n\n  if (parseMany(parseOp))\n    return addErrorSuffix(\" in '\" + Twine(IDVal) + \"' directive\");\n  return false;\n}\n\n/// parseDirectiveReloc\n///  ::= .reloc expression , identifier [ , expression ]\nbool AsmParser::parseDirectiveReloc(SMLoc DirectiveLoc) {\n  const MCExpr *Offset;\n  const MCExpr *Expr = nullptr;\n  SMLoc OffsetLoc = Lexer.getTok().getLoc();\n\n  if (parseExpression(Offset))\n    return true;\n  if (parseToken(AsmToken::Comma, \"expected comma\") ||\n      check(getTok().isNot(AsmToken::Identifier), \"expected relocation name\"))\n    return true;\n\n  SMLoc NameLoc = Lexer.getTok().getLoc();\n  StringRef Name = Lexer.getTok().getIdentifier();\n  Lex();\n\n  if (Lexer.is(AsmToken::Comma)) {\n    Lex();\n    SMLoc ExprLoc = Lexer.getLoc();\n    if (parseExpression(Expr))\n      return true;\n\n    MCValue Value;\n    if (!Expr->evaluateAsRelocatable(Value, nullptr, nullptr))\n      return Error(ExprLoc, \"expression must be relocatable\");\n  }\n\n  if (parseEOL())\n    return true;\n\n  const MCTargetAsmParser &MCT = getTargetParser();\n  const MCSubtargetInfo &STI = MCT.getSTI();\n  if (Optional<std::pair<bool, std::string>> Err =\n          getStreamer().emitRelocDirective(*Offset, Name, Expr, DirectiveLoc,\n                                           STI))\n    return Error(Err->first ? NameLoc : OffsetLoc, Err->second);\n\n  return false;\n}\n\n/// parseDirectiveValue\n///  ::= (.byte | .short | ... ) [ expression (, expression)* ]\nbool AsmParser::parseDirectiveValue(StringRef IDVal, unsigned Size) {\n  auto parseOp = [&]() -> bool {\n    const MCExpr *Value;\n    SMLoc ExprLoc = getLexer().getLoc();\n    if (checkForValidSection() || parseExpression(Value))\n      return true;\n    // Special case constant expressions to match code generator.\n    if (const MCConstantExpr *MCE = dyn_cast<MCConstantExpr>(Value)) {\n      assert(Size <= 8 && \"Invalid size\");\n      uint64_t IntValue = MCE->getValue();\n      if (!isUIntN(8 * Size, IntValue) && !isIntN(8 * Size, IntValue))\n        return Error(ExprLoc, \"out of range literal value\");\n      getStreamer().emitIntValue(IntValue, Size);\n    } else\n      getStreamer().emitValue(Value, Size, ExprLoc);\n    return false;\n  };\n\n  if (parseMany(parseOp))\n    return addErrorSuffix(\" in '\" + Twine(IDVal) + \"' directive\");\n  return false;\n}\n\nstatic bool parseHexOcta(AsmParser &Asm, uint64_t &hi, uint64_t &lo) {\n  if (Asm.getTok().isNot(AsmToken::Integer) &&\n      Asm.getTok().isNot(AsmToken::BigNum))\n    return Asm.TokError(\"unknown token in expression\");\n  SMLoc ExprLoc = Asm.getTok().getLoc();\n  APInt IntValue = Asm.getTok().getAPIntVal();\n  Asm.Lex();\n  if (!IntValue.isIntN(128))\n    return Asm.Error(ExprLoc, \"out of range literal value\");\n  if (!IntValue.isIntN(64)) {\n    hi = IntValue.getHiBits(IntValue.getBitWidth() - 64).getZExtValue();\n    lo = IntValue.getLoBits(64).getZExtValue();\n  } else {\n    hi = 0;\n    lo = IntValue.getZExtValue();\n  }\n  return false;\n}\n\n/// ParseDirectiveOctaValue\n///  ::= .octa [ hexconstant (, hexconstant)* ]\n\nbool AsmParser::parseDirectiveOctaValue(StringRef IDVal) {\n  auto parseOp = [&]() -> bool {\n    if (checkForValidSection())\n      return true;\n    uint64_t hi, lo;\n    if (parseHexOcta(*this, hi, lo))\n      return true;\n    if (MAI.isLittleEndian()) {\n      getStreamer().emitInt64(lo);\n      getStreamer().emitInt64(hi);\n    } else {\n      getStreamer().emitInt64(hi);\n      getStreamer().emitInt64(lo);\n    }\n    return false;\n  };\n\n  if (parseMany(parseOp))\n    return addErrorSuffix(\" in '\" + Twine(IDVal) + \"' directive\");\n  return false;\n}\n\nbool AsmParser::parseRealValue(const fltSemantics &Semantics, APInt &Res) {\n  // We don't truly support arithmetic on floating point expressions, so we\n  // have to manually parse unary prefixes.\n  bool IsNeg = false;\n  if (getLexer().is(AsmToken::Minus)) {\n    Lexer.Lex();\n    IsNeg = true;\n  } else if (getLexer().is(AsmToken::Plus))\n    Lexer.Lex();\n\n  if (Lexer.is(AsmToken::Error))\n    return TokError(Lexer.getErr());\n  if (Lexer.isNot(AsmToken::Integer) && Lexer.isNot(AsmToken::Real) &&\n      Lexer.isNot(AsmToken::Identifier))\n    return TokError(\"unexpected token in directive\");\n\n  // Convert to an APFloat.\n  APFloat Value(Semantics);\n  StringRef IDVal = getTok().getString();\n  if (getLexer().is(AsmToken::Identifier)) {\n    if (!IDVal.compare_lower(\"infinity\") || !IDVal.compare_lower(\"inf\"))\n      Value = APFloat::getInf(Semantics);\n    else if (!IDVal.compare_lower(\"nan\"))\n      Value = APFloat::getNaN(Semantics, false, ~0);\n    else\n      return TokError(\"invalid floating point literal\");\n  } else if (errorToBool(\n                 Value.convertFromString(IDVal, APFloat::rmNearestTiesToEven)\n                     .takeError()))\n    return TokError(\"invalid floating point literal\");\n  if (IsNeg)\n    Value.changeSign();\n\n  // Consume the numeric token.\n  Lex();\n\n  Res = Value.bitcastToAPInt();\n\n  return false;\n}\n\n/// parseDirectiveRealValue\n///  ::= (.single | .double) [ expression (, expression)* ]\nbool AsmParser::parseDirectiveRealValue(StringRef IDVal,\n                                        const fltSemantics &Semantics) {\n  auto parseOp = [&]() -> bool {\n    APInt AsInt;\n    if (checkForValidSection() || parseRealValue(Semantics, AsInt))\n      return true;\n    getStreamer().emitIntValue(AsInt.getLimitedValue(),\n                               AsInt.getBitWidth() / 8);\n    return false;\n  };\n\n  if (parseMany(parseOp))\n    return addErrorSuffix(\" in '\" + Twine(IDVal) + \"' directive\");\n  return false;\n}\n\n/// parseDirectiveZero\n///  ::= .zero expression\nbool AsmParser::parseDirectiveZero() {\n  SMLoc NumBytesLoc = Lexer.getLoc();\n  const MCExpr *NumBytes;\n  if (checkForValidSection() || parseExpression(NumBytes))\n    return true;\n\n  int64_t Val = 0;\n  if (getLexer().is(AsmToken::Comma)) {\n    Lex();\n    if (parseAbsoluteExpression(Val))\n      return true;\n  }\n\n  if (parseEOL())\n    return true;\n  getStreamer().emitFill(*NumBytes, Val, NumBytesLoc);\n\n  return false;\n}\n\n/// parseDirectiveFill\n///  ::= .fill expression [ , expression [ , expression ] ]\nbool AsmParser::parseDirectiveFill() {\n  SMLoc NumValuesLoc = Lexer.getLoc();\n  const MCExpr *NumValues;\n  if (checkForValidSection() || parseExpression(NumValues))\n    return true;\n\n  int64_t FillSize = 1;\n  int64_t FillExpr = 0;\n\n  SMLoc SizeLoc, ExprLoc;\n\n  if (parseOptionalToken(AsmToken::Comma)) {\n    SizeLoc = getTok().getLoc();\n    if (parseAbsoluteExpression(FillSize))\n      return true;\n    if (parseOptionalToken(AsmToken::Comma)) {\n      ExprLoc = getTok().getLoc();\n      if (parseAbsoluteExpression(FillExpr))\n        return true;\n    }\n  }\n  if (parseEOL())\n    return true;\n\n  if (FillSize < 0) {\n    Warning(SizeLoc, \"'.fill' directive with negative size has no effect\");\n    return false;\n  }\n  if (FillSize > 8) {\n    Warning(SizeLoc, \"'.fill' directive with size greater than 8 has been truncated to 8\");\n    FillSize = 8;\n  }\n\n  if (!isUInt<32>(FillExpr) && FillSize > 4)\n    Warning(ExprLoc, \"'.fill' directive pattern has been truncated to 32-bits\");\n\n  getStreamer().emitFill(*NumValues, FillSize, FillExpr, NumValuesLoc);\n\n  return false;\n}\n\n/// parseDirectiveOrg\n///  ::= .org expression [ , expression ]\nbool AsmParser::parseDirectiveOrg() {\n  const MCExpr *Offset;\n  SMLoc OffsetLoc = Lexer.getLoc();\n  if (checkForValidSection() || parseExpression(Offset))\n    return true;\n\n  // Parse optional fill expression.\n  int64_t FillExpr = 0;\n  if (parseOptionalToken(AsmToken::Comma))\n    if (parseAbsoluteExpression(FillExpr))\n      return addErrorSuffix(\" in '.org' directive\");\n  if (parseEOL())\n    return addErrorSuffix(\" in '.org' directive\");\n\n  getStreamer().emitValueToOffset(Offset, FillExpr, OffsetLoc);\n  return false;\n}\n\n/// parseDirectiveAlign\n///  ::= {.align, ...} expression [ , expression [ , expression ]]\nbool AsmParser::parseDirectiveAlign(bool IsPow2, unsigned ValueSize) {\n  SMLoc AlignmentLoc = getLexer().getLoc();\n  int64_t Alignment;\n  SMLoc MaxBytesLoc;\n  bool HasFillExpr = false;\n  int64_t FillExpr = 0;\n  int64_t MaxBytesToFill = 0;\n\n  auto parseAlign = [&]() -> bool {\n    if (parseAbsoluteExpression(Alignment))\n      return true;\n    if (parseOptionalToken(AsmToken::Comma)) {\n      // The fill expression can be omitted while specifying a maximum number of\n      // alignment bytes, e.g:\n      //  .align 3,,4\n      if (getTok().isNot(AsmToken::Comma)) {\n        HasFillExpr = true;\n        if (parseAbsoluteExpression(FillExpr))\n          return true;\n      }\n      if (parseOptionalToken(AsmToken::Comma))\n        if (parseTokenLoc(MaxBytesLoc) ||\n            parseAbsoluteExpression(MaxBytesToFill))\n          return true;\n    }\n    return parseEOL();\n  };\n\n  if (checkForValidSection())\n    return addErrorSuffix(\" in directive\");\n  // Ignore empty '.p2align' directives for GNU-as compatibility\n  if (IsPow2 && (ValueSize == 1) && getTok().is(AsmToken::EndOfStatement)) {\n    Warning(AlignmentLoc, \"p2align directive with no operand(s) is ignored\");\n    return parseEOL();\n  }\n  if (parseAlign())\n    return addErrorSuffix(\" in directive\");\n\n  // Always emit an alignment here even if we thrown an error.\n  bool ReturnVal = false;\n\n  // Compute alignment in bytes.\n  if (IsPow2) {\n    // FIXME: Diagnose overflow.\n    if (Alignment >= 32) {\n      ReturnVal |= Error(AlignmentLoc, \"invalid alignment value\");\n      Alignment = 31;\n    }\n\n    Alignment = 1ULL << Alignment;\n  } else {\n    // Reject alignments that aren't either a power of two or zero,\n    // for gas compatibility. Alignment of zero is silently rounded\n    // up to one.\n    if (Alignment == 0)\n      Alignment = 1;\n    if (!isPowerOf2_64(Alignment))\n      ReturnVal |= Error(AlignmentLoc, \"alignment must be a power of 2\");\n    if (!isUInt<32>(Alignment))\n      ReturnVal |= Error(AlignmentLoc, \"alignment must be smaller than 2**32\");\n  }\n\n  // Diagnose non-sensical max bytes to align.\n  if (MaxBytesLoc.isValid()) {\n    if (MaxBytesToFill < 1) {\n      ReturnVal |= Error(MaxBytesLoc,\n                         \"alignment directive can never be satisfied in this \"\n                         \"many bytes, ignoring maximum bytes expression\");\n      MaxBytesToFill = 0;\n    }\n\n    if (MaxBytesToFill >= Alignment) {\n      Warning(MaxBytesLoc, \"maximum bytes expression exceeds alignment and \"\n                           \"has no effect\");\n      MaxBytesToFill = 0;\n    }\n  }\n\n  // Check whether we should use optimal code alignment for this .align\n  // directive.\n  const MCSection *Section = getStreamer().getCurrentSectionOnly();\n  assert(Section && \"must have section to emit alignment\");\n  bool UseCodeAlign = Section->UseCodeAlign();\n  if ((!HasFillExpr || Lexer.getMAI().getTextAlignFillValue() == FillExpr) &&\n      ValueSize == 1 && UseCodeAlign) {\n    getStreamer().emitCodeAlignment(Alignment, MaxBytesToFill);\n  } else {\n    // FIXME: Target specific behavior about how the \"extra\" bytes are filled.\n    getStreamer().emitValueToAlignment(Alignment, FillExpr, ValueSize,\n                                       MaxBytesToFill);\n  }\n\n  return ReturnVal;\n}\n\n/// parseDirectiveFile\n/// ::= .file filename\n/// ::= .file number [directory] filename [md5 checksum] [source source-text]\nbool AsmParser::parseDirectiveFile(SMLoc DirectiveLoc) {\n  // FIXME: I'm not sure what this is.\n  int64_t FileNumber = -1;\n  if (getLexer().is(AsmToken::Integer)) {\n    FileNumber = getTok().getIntVal();\n    Lex();\n\n    if (FileNumber < 0)\n      return TokError(\"negative file number\");\n  }\n\n  std::string Path;\n\n  // Usually the directory and filename together, otherwise just the directory.\n  // Allow the strings to have escaped octal character sequence.\n  if (check(getTok().isNot(AsmToken::String),\n            \"unexpected token in '.file' directive\") ||\n      parseEscapedString(Path))\n    return true;\n\n  StringRef Directory;\n  StringRef Filename;\n  std::string FilenameData;\n  if (getLexer().is(AsmToken::String)) {\n    if (check(FileNumber == -1,\n              \"explicit path specified, but no file number\") ||\n        parseEscapedString(FilenameData))\n      return true;\n    Filename = FilenameData;\n    Directory = Path;\n  } else {\n    Filename = Path;\n  }\n\n  uint64_t MD5Hi, MD5Lo;\n  bool HasMD5 = false;\n\n  Optional<StringRef> Source;\n  bool HasSource = false;\n  std::string SourceString;\n\n  while (!parseOptionalToken(AsmToken::EndOfStatement)) {\n    StringRef Keyword;\n    if (check(getTok().isNot(AsmToken::Identifier),\n              \"unexpected token in '.file' directive\") ||\n        parseIdentifier(Keyword))\n      return true;\n    if (Keyword == \"md5\") {\n      HasMD5 = true;\n      if (check(FileNumber == -1,\n                \"MD5 checksum specified, but no file number\") ||\n          parseHexOcta(*this, MD5Hi, MD5Lo))\n        return true;\n    } else if (Keyword == \"source\") {\n      HasSource = true;\n      if (check(FileNumber == -1,\n                \"source specified, but no file number\") ||\n          check(getTok().isNot(AsmToken::String),\n                \"unexpected token in '.file' directive\") ||\n          parseEscapedString(SourceString))\n        return true;\n    } else {\n      return TokError(\"unexpected token in '.file' directive\");\n    }\n  }\n\n  if (FileNumber == -1) {\n    // Ignore the directive if there is no number and the target doesn't support\n    // numberless .file directives. This allows some portability of assembler\n    // between different object file formats.\n    if (getContext().getAsmInfo()->hasSingleParameterDotFile())\n      getStreamer().emitFileDirective(Filename);\n  } else {\n    // In case there is a -g option as well as debug info from directive .file,\n    // we turn off the -g option, directly use the existing debug info instead.\n    // Throw away any implicit file table for the assembler source.\n    if (Ctx.getGenDwarfForAssembly()) {\n      Ctx.getMCDwarfLineTable(0).resetFileTable();\n      Ctx.setGenDwarfForAssembly(false);\n    }\n\n    Optional<MD5::MD5Result> CKMem;\n    if (HasMD5) {\n      MD5::MD5Result Sum;\n      for (unsigned i = 0; i != 8; ++i) {\n        Sum.Bytes[i] = uint8_t(MD5Hi >> ((7 - i) * 8));\n        Sum.Bytes[i + 8] = uint8_t(MD5Lo >> ((7 - i) * 8));\n      }\n      CKMem = Sum;\n    }\n    if (HasSource) {\n      char *SourceBuf = static_cast<char *>(Ctx.allocate(SourceString.size()));\n      memcpy(SourceBuf, SourceString.data(), SourceString.size());\n      Source = StringRef(SourceBuf, SourceString.size());\n    }\n    if (FileNumber == 0) {\n      // Upgrade to Version 5 for assembly actions like clang -c a.s.\n      if (Ctx.getDwarfVersion() < 5)\n        Ctx.setDwarfVersion(5);\n      getStreamer().emitDwarfFile0Directive(Directory, Filename, CKMem, Source);\n    } else {\n      Expected<unsigned> FileNumOrErr = getStreamer().tryEmitDwarfFileDirective(\n          FileNumber, Directory, Filename, CKMem, Source);\n      if (!FileNumOrErr)\n        return Error(DirectiveLoc, toString(FileNumOrErr.takeError()));\n    }\n    // Alert the user if there are some .file directives with MD5 and some not.\n    // But only do that once.\n    if (!ReportedInconsistentMD5 && !Ctx.isDwarfMD5UsageConsistent(0)) {\n      ReportedInconsistentMD5 = true;\n      return Warning(DirectiveLoc, \"inconsistent use of MD5 checksums\");\n    }\n  }\n\n  return false;\n}\n\n/// parseDirectiveLine\n/// ::= .line [number]\nbool AsmParser::parseDirectiveLine() {\n  int64_t LineNumber;\n  if (getLexer().is(AsmToken::Integer)) {\n    if (parseIntToken(LineNumber, \"unexpected token in '.line' directive\"))\n      return true;\n    (void)LineNumber;\n    // FIXME: Do something with the .line.\n  }\n  return parseEOL();\n}\n\n/// parseDirectiveLoc\n/// ::= .loc FileNumber [LineNumber] [ColumnPos] [basic_block] [prologue_end]\n///                                [epilogue_begin] [is_stmt VALUE] [isa VALUE]\n/// The first number is a file number, must have been previously assigned with\n/// a .file directive, the second number is the line number and optionally the\n/// third number is a column position (zero if not specified).  The remaining\n/// optional items are .loc sub-directives.\nbool AsmParser::parseDirectiveLoc() {\n  int64_t FileNumber = 0, LineNumber = 0;\n  SMLoc Loc = getTok().getLoc();\n  if (parseIntToken(FileNumber, \"unexpected token in '.loc' directive\") ||\n      check(FileNumber < 1 && Ctx.getDwarfVersion() < 5, Loc,\n            \"file number less than one in '.loc' directive\") ||\n      check(!getContext().isValidDwarfFileNumber(FileNumber), Loc,\n            \"unassigned file number in '.loc' directive\"))\n    return true;\n\n  // optional\n  if (getLexer().is(AsmToken::Integer)) {\n    LineNumber = getTok().getIntVal();\n    if (LineNumber < 0)\n      return TokError(\"line number less than zero in '.loc' directive\");\n    Lex();\n  }\n\n  int64_t ColumnPos = 0;\n  if (getLexer().is(AsmToken::Integer)) {\n    ColumnPos = getTok().getIntVal();\n    if (ColumnPos < 0)\n      return TokError(\"column position less than zero in '.loc' directive\");\n    Lex();\n  }\n\n  auto PrevFlags = getContext().getCurrentDwarfLoc().getFlags();\n  unsigned Flags = PrevFlags & DWARF2_FLAG_IS_STMT;\n  unsigned Isa = 0;\n  int64_t Discriminator = 0;\n\n  auto parseLocOp = [&]() -> bool {\n    StringRef Name;\n    SMLoc Loc = getTok().getLoc();\n    if (parseIdentifier(Name))\n      return TokError(\"unexpected token in '.loc' directive\");\n\n    if (Name == \"basic_block\")\n      Flags |= DWARF2_FLAG_BASIC_BLOCK;\n    else if (Name == \"prologue_end\")\n      Flags |= DWARF2_FLAG_PROLOGUE_END;\n    else if (Name == \"epilogue_begin\")\n      Flags |= DWARF2_FLAG_EPILOGUE_BEGIN;\n    else if (Name == \"is_stmt\") {\n      Loc = getTok().getLoc();\n      const MCExpr *Value;\n      if (parseExpression(Value))\n        return true;\n      // The expression must be the constant 0 or 1.\n      if (const MCConstantExpr *MCE = dyn_cast<MCConstantExpr>(Value)) {\n        int Value = MCE->getValue();\n        if (Value == 0)\n          Flags &= ~DWARF2_FLAG_IS_STMT;\n        else if (Value == 1)\n          Flags |= DWARF2_FLAG_IS_STMT;\n        else\n          return Error(Loc, \"is_stmt value not 0 or 1\");\n      } else {\n        return Error(Loc, \"is_stmt value not the constant value of 0 or 1\");\n      }\n    } else if (Name == \"isa\") {\n      Loc = getTok().getLoc();\n      const MCExpr *Value;\n      if (parseExpression(Value))\n        return true;\n      // The expression must be a constant greater or equal to 0.\n      if (const MCConstantExpr *MCE = dyn_cast<MCConstantExpr>(Value)) {\n        int Value = MCE->getValue();\n        if (Value < 0)\n          return Error(Loc, \"isa number less than zero\");\n        Isa = Value;\n      } else {\n        return Error(Loc, \"isa number not a constant value\");\n      }\n    } else if (Name == \"discriminator\") {\n      if (parseAbsoluteExpression(Discriminator))\n        return true;\n    } else {\n      return Error(Loc, \"unknown sub-directive in '.loc' directive\");\n    }\n    return false;\n  };\n\n  if (parseMany(parseLocOp, false /*hasComma*/))\n    return true;\n\n  getStreamer().emitDwarfLocDirective(FileNumber, LineNumber, ColumnPos, Flags,\n                                      Isa, Discriminator, StringRef());\n\n  return false;\n}\n\n/// parseDirectiveStabs\n/// ::= .stabs string, number, number, number\nbool AsmParser::parseDirectiveStabs() {\n  return TokError(\"unsupported directive '.stabs'\");\n}\n\n/// parseDirectiveCVFile\n/// ::= .cv_file number filename [checksum] [checksumkind]\nbool AsmParser::parseDirectiveCVFile() {\n  SMLoc FileNumberLoc = getTok().getLoc();\n  int64_t FileNumber;\n  std::string Filename;\n  std::string Checksum;\n  int64_t ChecksumKind = 0;\n\n  if (parseIntToken(FileNumber,\n                    \"expected file number in '.cv_file' directive\") ||\n      check(FileNumber < 1, FileNumberLoc, \"file number less than one\") ||\n      check(getTok().isNot(AsmToken::String),\n            \"unexpected token in '.cv_file' directive\") ||\n      parseEscapedString(Filename))\n    return true;\n  if (!parseOptionalToken(AsmToken::EndOfStatement)) {\n    if (check(getTok().isNot(AsmToken::String),\n              \"unexpected token in '.cv_file' directive\") ||\n        parseEscapedString(Checksum) ||\n        parseIntToken(ChecksumKind,\n                      \"expected checksum kind in '.cv_file' directive\") ||\n        parseToken(AsmToken::EndOfStatement,\n                   \"unexpected token in '.cv_file' directive\"))\n      return true;\n  }\n\n  Checksum = fromHex(Checksum);\n  void *CKMem = Ctx.allocate(Checksum.size(), 1);\n  memcpy(CKMem, Checksum.data(), Checksum.size());\n  ArrayRef<uint8_t> ChecksumAsBytes(reinterpret_cast<const uint8_t *>(CKMem),\n                                    Checksum.size());\n\n  if (!getStreamer().EmitCVFileDirective(FileNumber, Filename, ChecksumAsBytes,\n                                         static_cast<uint8_t>(ChecksumKind)))\n    return Error(FileNumberLoc, \"file number already allocated\");\n\n  return false;\n}\n\nbool AsmParser::parseCVFunctionId(int64_t &FunctionId,\n                                  StringRef DirectiveName) {\n  SMLoc Loc;\n  return parseTokenLoc(Loc) ||\n         parseIntToken(FunctionId, \"expected function id in '\" + DirectiveName +\n                                       \"' directive\") ||\n         check(FunctionId < 0 || FunctionId >= UINT_MAX, Loc,\n               \"expected function id within range [0, UINT_MAX)\");\n}\n\nbool AsmParser::parseCVFileId(int64_t &FileNumber, StringRef DirectiveName) {\n  SMLoc Loc;\n  return parseTokenLoc(Loc) ||\n         parseIntToken(FileNumber, \"expected integer in '\" + DirectiveName +\n                                       \"' directive\") ||\n         check(FileNumber < 1, Loc, \"file number less than one in '\" +\n                                        DirectiveName + \"' directive\") ||\n         check(!getCVContext().isValidFileNumber(FileNumber), Loc,\n               \"unassigned file number in '\" + DirectiveName + \"' directive\");\n}\n\n/// parseDirectiveCVFuncId\n/// ::= .cv_func_id FunctionId\n///\n/// Introduces a function ID that can be used with .cv_loc.\nbool AsmParser::parseDirectiveCVFuncId() {\n  SMLoc FunctionIdLoc = getTok().getLoc();\n  int64_t FunctionId;\n\n  if (parseCVFunctionId(FunctionId, \".cv_func_id\") ||\n      parseToken(AsmToken::EndOfStatement,\n                 \"unexpected token in '.cv_func_id' directive\"))\n    return true;\n\n  if (!getStreamer().EmitCVFuncIdDirective(FunctionId))\n    return Error(FunctionIdLoc, \"function id already allocated\");\n\n  return false;\n}\n\n/// parseDirectiveCVInlineSiteId\n/// ::= .cv_inline_site_id FunctionId\n///         \"within\" IAFunc\n///         \"inlined_at\" IAFile IALine [IACol]\n///\n/// Introduces a function ID that can be used with .cv_loc. Includes \"inlined\n/// at\" source location information for use in the line table of the caller,\n/// whether the caller is a real function or another inlined call site.\nbool AsmParser::parseDirectiveCVInlineSiteId() {\n  SMLoc FunctionIdLoc = getTok().getLoc();\n  int64_t FunctionId;\n  int64_t IAFunc;\n  int64_t IAFile;\n  int64_t IALine;\n  int64_t IACol = 0;\n\n  // FunctionId\n  if (parseCVFunctionId(FunctionId, \".cv_inline_site_id\"))\n    return true;\n\n  // \"within\"\n  if (check((getLexer().isNot(AsmToken::Identifier) ||\n             getTok().getIdentifier() != \"within\"),\n            \"expected 'within' identifier in '.cv_inline_site_id' directive\"))\n    return true;\n  Lex();\n\n  // IAFunc\n  if (parseCVFunctionId(IAFunc, \".cv_inline_site_id\"))\n    return true;\n\n  // \"inlined_at\"\n  if (check((getLexer().isNot(AsmToken::Identifier) ||\n             getTok().getIdentifier() != \"inlined_at\"),\n            \"expected 'inlined_at' identifier in '.cv_inline_site_id' \"\n            \"directive\") )\n    return true;\n  Lex();\n\n  // IAFile IALine\n  if (parseCVFileId(IAFile, \".cv_inline_site_id\") ||\n      parseIntToken(IALine, \"expected line number after 'inlined_at'\"))\n    return true;\n\n  // [IACol]\n  if (getLexer().is(AsmToken::Integer)) {\n    IACol = getTok().getIntVal();\n    Lex();\n  }\n\n  if (parseToken(AsmToken::EndOfStatement,\n                 \"unexpected token in '.cv_inline_site_id' directive\"))\n    return true;\n\n  if (!getStreamer().EmitCVInlineSiteIdDirective(FunctionId, IAFunc, IAFile,\n                                                 IALine, IACol, FunctionIdLoc))\n    return Error(FunctionIdLoc, \"function id already allocated\");\n\n  return false;\n}\n\n/// parseDirectiveCVLoc\n/// ::= .cv_loc FunctionId FileNumber [LineNumber] [ColumnPos] [prologue_end]\n///                                [is_stmt VALUE]\n/// The first number is a file number, must have been previously assigned with\n/// a .file directive, the second number is the line number and optionally the\n/// third number is a column position (zero if not specified).  The remaining\n/// optional items are .loc sub-directives.\nbool AsmParser::parseDirectiveCVLoc() {\n  SMLoc DirectiveLoc = getTok().getLoc();\n  int64_t FunctionId, FileNumber;\n  if (parseCVFunctionId(FunctionId, \".cv_loc\") ||\n      parseCVFileId(FileNumber, \".cv_loc\"))\n    return true;\n\n  int64_t LineNumber = 0;\n  if (getLexer().is(AsmToken::Integer)) {\n    LineNumber = getTok().getIntVal();\n    if (LineNumber < 0)\n      return TokError(\"line number less than zero in '.cv_loc' directive\");\n    Lex();\n  }\n\n  int64_t ColumnPos = 0;\n  if (getLexer().is(AsmToken::Integer)) {\n    ColumnPos = getTok().getIntVal();\n    if (ColumnPos < 0)\n      return TokError(\"column position less than zero in '.cv_loc' directive\");\n    Lex();\n  }\n\n  bool PrologueEnd = false;\n  uint64_t IsStmt = 0;\n\n  auto parseOp = [&]() -> bool {\n    StringRef Name;\n    SMLoc Loc = getTok().getLoc();\n    if (parseIdentifier(Name))\n      return TokError(\"unexpected token in '.cv_loc' directive\");\n    if (Name == \"prologue_end\")\n      PrologueEnd = true;\n    else if (Name == \"is_stmt\") {\n      Loc = getTok().getLoc();\n      const MCExpr *Value;\n      if (parseExpression(Value))\n        return true;\n      // The expression must be the constant 0 or 1.\n      IsStmt = ~0ULL;\n      if (const auto *MCE = dyn_cast<MCConstantExpr>(Value))\n        IsStmt = MCE->getValue();\n\n      if (IsStmt > 1)\n        return Error(Loc, \"is_stmt value not 0 or 1\");\n    } else {\n      return Error(Loc, \"unknown sub-directive in '.cv_loc' directive\");\n    }\n    return false;\n  };\n\n  if (parseMany(parseOp, false /*hasComma*/))\n    return true;\n\n  getStreamer().emitCVLocDirective(FunctionId, FileNumber, LineNumber,\n                                   ColumnPos, PrologueEnd, IsStmt, StringRef(),\n                                   DirectiveLoc);\n  return false;\n}\n\n/// parseDirectiveCVLinetable\n/// ::= .cv_linetable FunctionId, FnStart, FnEnd\nbool AsmParser::parseDirectiveCVLinetable() {\n  int64_t FunctionId;\n  StringRef FnStartName, FnEndName;\n  SMLoc Loc = getTok().getLoc();\n  if (parseCVFunctionId(FunctionId, \".cv_linetable\") ||\n      parseToken(AsmToken::Comma,\n                 \"unexpected token in '.cv_linetable' directive\") ||\n      parseTokenLoc(Loc) || check(parseIdentifier(FnStartName), Loc,\n                                  \"expected identifier in directive\") ||\n      parseToken(AsmToken::Comma,\n                 \"unexpected token in '.cv_linetable' directive\") ||\n      parseTokenLoc(Loc) || check(parseIdentifier(FnEndName), Loc,\n                                  \"expected identifier in directive\"))\n    return true;\n\n  MCSymbol *FnStartSym = getContext().getOrCreateSymbol(FnStartName);\n  MCSymbol *FnEndSym = getContext().getOrCreateSymbol(FnEndName);\n\n  getStreamer().emitCVLinetableDirective(FunctionId, FnStartSym, FnEndSym);\n  return false;\n}\n\n/// parseDirectiveCVInlineLinetable\n/// ::= .cv_inline_linetable PrimaryFunctionId FileId LineNum FnStart FnEnd\nbool AsmParser::parseDirectiveCVInlineLinetable() {\n  int64_t PrimaryFunctionId, SourceFileId, SourceLineNum;\n  StringRef FnStartName, FnEndName;\n  SMLoc Loc = getTok().getLoc();\n  if (parseCVFunctionId(PrimaryFunctionId, \".cv_inline_linetable\") ||\n      parseTokenLoc(Loc) ||\n      parseIntToken(\n          SourceFileId,\n          \"expected SourceField in '.cv_inline_linetable' directive\") ||\n      check(SourceFileId <= 0, Loc,\n            \"File id less than zero in '.cv_inline_linetable' directive\") ||\n      parseTokenLoc(Loc) ||\n      parseIntToken(\n          SourceLineNum,\n          \"expected SourceLineNum in '.cv_inline_linetable' directive\") ||\n      check(SourceLineNum < 0, Loc,\n            \"Line number less than zero in '.cv_inline_linetable' directive\") ||\n      parseTokenLoc(Loc) || check(parseIdentifier(FnStartName), Loc,\n                                  \"expected identifier in directive\") ||\n      parseTokenLoc(Loc) || check(parseIdentifier(FnEndName), Loc,\n                                  \"expected identifier in directive\"))\n    return true;\n\n  if (parseToken(AsmToken::EndOfStatement, \"Expected End of Statement\"))\n    return true;\n\n  MCSymbol *FnStartSym = getContext().getOrCreateSymbol(FnStartName);\n  MCSymbol *FnEndSym = getContext().getOrCreateSymbol(FnEndName);\n  getStreamer().emitCVInlineLinetableDirective(PrimaryFunctionId, SourceFileId,\n                                               SourceLineNum, FnStartSym,\n                                               FnEndSym);\n  return false;\n}\n\nvoid AsmParser::initializeCVDefRangeTypeMap() {\n  CVDefRangeTypeMap[\"reg\"] = CVDR_DEFRANGE_REGISTER;\n  CVDefRangeTypeMap[\"frame_ptr_rel\"] = CVDR_DEFRANGE_FRAMEPOINTER_REL;\n  CVDefRangeTypeMap[\"subfield_reg\"] = CVDR_DEFRANGE_SUBFIELD_REGISTER;\n  CVDefRangeTypeMap[\"reg_rel\"] = CVDR_DEFRANGE_REGISTER_REL;\n}\n\n/// parseDirectiveCVDefRange\n/// ::= .cv_def_range RangeStart RangeEnd (GapStart GapEnd)*, bytes*\nbool AsmParser::parseDirectiveCVDefRange() {\n  SMLoc Loc;\n  std::vector<std::pair<const MCSymbol *, const MCSymbol *>> Ranges;\n  while (getLexer().is(AsmToken::Identifier)) {\n    Loc = getLexer().getLoc();\n    StringRef GapStartName;\n    if (parseIdentifier(GapStartName))\n      return Error(Loc, \"expected identifier in directive\");\n    MCSymbol *GapStartSym = getContext().getOrCreateSymbol(GapStartName);\n\n    Loc = getLexer().getLoc();\n    StringRef GapEndName;\n    if (parseIdentifier(GapEndName))\n      return Error(Loc, \"expected identifier in directive\");\n    MCSymbol *GapEndSym = getContext().getOrCreateSymbol(GapEndName);\n\n    Ranges.push_back({GapStartSym, GapEndSym});\n  }\n\n  StringRef CVDefRangeTypeStr;\n  if (parseToken(\n          AsmToken::Comma,\n          \"expected comma before def_range type in .cv_def_range directive\") ||\n      parseIdentifier(CVDefRangeTypeStr))\n    return Error(Loc, \"expected def_range type in directive\");\n\n  StringMap<CVDefRangeType>::const_iterator CVTypeIt =\n      CVDefRangeTypeMap.find(CVDefRangeTypeStr);\n  CVDefRangeType CVDRType = (CVTypeIt == CVDefRangeTypeMap.end())\n                                ? CVDR_DEFRANGE\n                                : CVTypeIt->getValue();\n  switch (CVDRType) {\n  case CVDR_DEFRANGE_REGISTER: {\n    int64_t DRRegister;\n    if (parseToken(AsmToken::Comma, \"expected comma before register number in \"\n                                    \".cv_def_range directive\") ||\n        parseAbsoluteExpression(DRRegister))\n      return Error(Loc, \"expected register number\");\n\n    codeview::DefRangeRegisterHeader DRHdr;\n    DRHdr.Register = DRRegister;\n    DRHdr.MayHaveNoName = 0;\n    getStreamer().emitCVDefRangeDirective(Ranges, DRHdr);\n    break;\n  }\n  case CVDR_DEFRANGE_FRAMEPOINTER_REL: {\n    int64_t DROffset;\n    if (parseToken(AsmToken::Comma,\n                   \"expected comma before offset in .cv_def_range directive\") ||\n        parseAbsoluteExpression(DROffset))\n      return Error(Loc, \"expected offset value\");\n\n    codeview::DefRangeFramePointerRelHeader DRHdr;\n    DRHdr.Offset = DROffset;\n    getStreamer().emitCVDefRangeDirective(Ranges, DRHdr);\n    break;\n  }\n  case CVDR_DEFRANGE_SUBFIELD_REGISTER: {\n    int64_t DRRegister;\n    int64_t DROffsetInParent;\n    if (parseToken(AsmToken::Comma, \"expected comma before register number in \"\n                                    \".cv_def_range directive\") ||\n        parseAbsoluteExpression(DRRegister))\n      return Error(Loc, \"expected register number\");\n    if (parseToken(AsmToken::Comma,\n                   \"expected comma before offset in .cv_def_range directive\") ||\n        parseAbsoluteExpression(DROffsetInParent))\n      return Error(Loc, \"expected offset value\");\n\n    codeview::DefRangeSubfieldRegisterHeader DRHdr;\n    DRHdr.Register = DRRegister;\n    DRHdr.MayHaveNoName = 0;\n    DRHdr.OffsetInParent = DROffsetInParent;\n    getStreamer().emitCVDefRangeDirective(Ranges, DRHdr);\n    break;\n  }\n  case CVDR_DEFRANGE_REGISTER_REL: {\n    int64_t DRRegister;\n    int64_t DRFlags;\n    int64_t DRBasePointerOffset;\n    if (parseToken(AsmToken::Comma, \"expected comma before register number in \"\n                                    \".cv_def_range directive\") ||\n        parseAbsoluteExpression(DRRegister))\n      return Error(Loc, \"expected register value\");\n    if (parseToken(\n            AsmToken::Comma,\n            \"expected comma before flag value in .cv_def_range directive\") ||\n        parseAbsoluteExpression(DRFlags))\n      return Error(Loc, \"expected flag value\");\n    if (parseToken(AsmToken::Comma, \"expected comma before base pointer offset \"\n                                    \"in .cv_def_range directive\") ||\n        parseAbsoluteExpression(DRBasePointerOffset))\n      return Error(Loc, \"expected base pointer offset value\");\n\n    codeview::DefRangeRegisterRelHeader DRHdr;\n    DRHdr.Register = DRRegister;\n    DRHdr.Flags = DRFlags;\n    DRHdr.BasePointerOffset = DRBasePointerOffset;\n    getStreamer().emitCVDefRangeDirective(Ranges, DRHdr);\n    break;\n  }\n  default:\n    return Error(Loc, \"unexpected def_range type in .cv_def_range directive\");\n  }\n  return true;\n}\n\n/// parseDirectiveCVString\n/// ::= .cv_stringtable \"string\"\nbool AsmParser::parseDirectiveCVString() {\n  std::string Data;\n  if (checkForValidSection() || parseEscapedString(Data))\n    return addErrorSuffix(\" in '.cv_string' directive\");\n\n  // Put the string in the table and emit the offset.\n  std::pair<StringRef, unsigned> Insertion =\n      getCVContext().addToStringTable(Data);\n  getStreamer().emitInt32(Insertion.second);\n  return false;\n}\n\n/// parseDirectiveCVStringTable\n/// ::= .cv_stringtable\nbool AsmParser::parseDirectiveCVStringTable() {\n  getStreamer().emitCVStringTableDirective();\n  return false;\n}\n\n/// parseDirectiveCVFileChecksums\n/// ::= .cv_filechecksums\nbool AsmParser::parseDirectiveCVFileChecksums() {\n  getStreamer().emitCVFileChecksumsDirective();\n  return false;\n}\n\n/// parseDirectiveCVFileChecksumOffset\n/// ::= .cv_filechecksumoffset fileno\nbool AsmParser::parseDirectiveCVFileChecksumOffset() {\n  int64_t FileNo;\n  if (parseIntToken(FileNo, \"expected identifier in directive\"))\n    return true;\n  if (parseToken(AsmToken::EndOfStatement, \"Expected End of Statement\"))\n    return true;\n  getStreamer().emitCVFileChecksumOffsetDirective(FileNo);\n  return false;\n}\n\n/// parseDirectiveCVFPOData\n/// ::= .cv_fpo_data procsym\nbool AsmParser::parseDirectiveCVFPOData() {\n  SMLoc DirLoc = getLexer().getLoc();\n  StringRef ProcName;\n  if (parseIdentifier(ProcName))\n    return TokError(\"expected symbol name\");\n  if (parseEOL(\"unexpected tokens\"))\n    return addErrorSuffix(\" in '.cv_fpo_data' directive\");\n  MCSymbol *ProcSym = getContext().getOrCreateSymbol(ProcName);\n  getStreamer().EmitCVFPOData(ProcSym, DirLoc);\n  return false;\n}\n\n/// parseDirectiveCFISections\n/// ::= .cfi_sections section [, section]\nbool AsmParser::parseDirectiveCFISections() {\n  StringRef Name;\n  bool EH = false;\n  bool Debug = false;\n\n  if (!parseOptionalToken(AsmToken::EndOfStatement)) {\n    for (;;) {\n      if (parseIdentifier(Name))\n        return TokError(\"expected .eh_frame or .debug_frame\");\n      if (Name == \".eh_frame\")\n        EH = true;\n      else if (Name == \".debug_frame\")\n        Debug = true;\n      if (parseOptionalToken(AsmToken::EndOfStatement))\n        break;\n      if (parseToken(AsmToken::Comma))\n        return true;\n    }\n  }\n  getStreamer().emitCFISections(EH, Debug);\n  return false;\n}\n\n/// parseDirectiveCFIStartProc\n/// ::= .cfi_startproc [simple]\nbool AsmParser::parseDirectiveCFIStartProc() {\n  StringRef Simple;\n  if (!parseOptionalToken(AsmToken::EndOfStatement)) {\n    if (check(parseIdentifier(Simple) || Simple != \"simple\",\n              \"unexpected token\") ||\n        parseEOL())\n      return addErrorSuffix(\" in '.cfi_startproc' directive\");\n  }\n\n  // TODO(kristina): Deal with a corner case of incorrect diagnostic context\n  // being produced if this directive is emitted as part of preprocessor macro\n  // expansion which can *ONLY* happen if Clang's cc1as is the API consumer.\n  // Tools like llvm-mc on the other hand are not affected by it, and report\n  // correct context information.\n  getStreamer().emitCFIStartProc(!Simple.empty(), Lexer.getLoc());\n  return false;\n}\n\n/// parseDirectiveCFIEndProc\n/// ::= .cfi_endproc\nbool AsmParser::parseDirectiveCFIEndProc() {\n  if (parseEOL())\n    return addErrorSuffix(\" in '.cfi_endproc' directive\");\n  getStreamer().emitCFIEndProc();\n  return false;\n}\n\n/// parse register name or number.\nbool AsmParser::parseRegisterOrRegisterNumber(int64_t &Register,\n                                              SMLoc DirectiveLoc) {\n  unsigned RegNo;\n\n  if (getLexer().isNot(AsmToken::Integer)) {\n    if (getTargetParser().ParseRegister(RegNo, DirectiveLoc, DirectiveLoc))\n      return true;\n    Register = getContext().getRegisterInfo()->getDwarfRegNum(RegNo, true);\n  } else\n    return parseAbsoluteExpression(Register);\n\n  return false;\n}\n\n/// parseDirectiveCFIDefCfa\n/// ::= .cfi_def_cfa register,  offset\nbool AsmParser::parseDirectiveCFIDefCfa(SMLoc DirectiveLoc) {\n  int64_t Register = 0, Offset = 0;\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) ||\n      parseToken(AsmToken::Comma, \"unexpected token in directive\") ||\n      parseAbsoluteExpression(Offset) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIDefCfa(Register, Offset);\n  return false;\n}\n\n/// parseDirectiveCFIDefCfaOffset\n/// ::= .cfi_def_cfa_offset offset\nbool AsmParser::parseDirectiveCFIDefCfaOffset() {\n  int64_t Offset = 0;\n  if (parseAbsoluteExpression(Offset) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIDefCfaOffset(Offset);\n  return false;\n}\n\n/// parseDirectiveCFIRegister\n/// ::= .cfi_register register, register\nbool AsmParser::parseDirectiveCFIRegister(SMLoc DirectiveLoc) {\n  int64_t Register1 = 0, Register2 = 0;\n  if (parseRegisterOrRegisterNumber(Register1, DirectiveLoc) ||\n      parseToken(AsmToken::Comma, \"unexpected token in directive\") ||\n      parseRegisterOrRegisterNumber(Register2, DirectiveLoc) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIRegister(Register1, Register2);\n  return false;\n}\n\n/// parseDirectiveCFIWindowSave\n/// ::= .cfi_window_save\nbool AsmParser::parseDirectiveCFIWindowSave() {\n  if (parseEOL())\n    return true;\n  getStreamer().emitCFIWindowSave();\n  return false;\n}\n\n/// parseDirectiveCFIAdjustCfaOffset\n/// ::= .cfi_adjust_cfa_offset adjustment\nbool AsmParser::parseDirectiveCFIAdjustCfaOffset() {\n  int64_t Adjustment = 0;\n  if (parseAbsoluteExpression(Adjustment) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIAdjustCfaOffset(Adjustment);\n  return false;\n}\n\n/// parseDirectiveCFIDefCfaRegister\n/// ::= .cfi_def_cfa_register register\nbool AsmParser::parseDirectiveCFIDefCfaRegister(SMLoc DirectiveLoc) {\n  int64_t Register = 0;\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIDefCfaRegister(Register);\n  return false;\n}\n\n/// parseDirectiveCFIOffset\n/// ::= .cfi_offset register, offset\nbool AsmParser::parseDirectiveCFIOffset(SMLoc DirectiveLoc) {\n  int64_t Register = 0;\n  int64_t Offset = 0;\n\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) ||\n      parseToken(AsmToken::Comma, \"unexpected token in directive\") ||\n      parseAbsoluteExpression(Offset) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIOffset(Register, Offset);\n  return false;\n}\n\n/// parseDirectiveCFIRelOffset\n/// ::= .cfi_rel_offset register, offset\nbool AsmParser::parseDirectiveCFIRelOffset(SMLoc DirectiveLoc) {\n  int64_t Register = 0, Offset = 0;\n\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) ||\n      parseToken(AsmToken::Comma, \"unexpected token in directive\") ||\n      parseAbsoluteExpression(Offset) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIRelOffset(Register, Offset);\n  return false;\n}\n\nstatic bool isValidEncoding(int64_t Encoding) {\n  if (Encoding & ~0xff)\n    return false;\n\n  if (Encoding == dwarf::DW_EH_PE_omit)\n    return true;\n\n  const unsigned Format = Encoding & 0xf;\n  if (Format != dwarf::DW_EH_PE_absptr && Format != dwarf::DW_EH_PE_udata2 &&\n      Format != dwarf::DW_EH_PE_udata4 && Format != dwarf::DW_EH_PE_udata8 &&\n      Format != dwarf::DW_EH_PE_sdata2 && Format != dwarf::DW_EH_PE_sdata4 &&\n      Format != dwarf::DW_EH_PE_sdata8 && Format != dwarf::DW_EH_PE_signed)\n    return false;\n\n  const unsigned Application = Encoding & 0x70;\n  if (Application != dwarf::DW_EH_PE_absptr &&\n      Application != dwarf::DW_EH_PE_pcrel)\n    return false;\n\n  return true;\n}\n\n/// parseDirectiveCFIPersonalityOrLsda\n/// IsPersonality true for cfi_personality, false for cfi_lsda\n/// ::= .cfi_personality encoding, [symbol_name]\n/// ::= .cfi_lsda encoding, [symbol_name]\nbool AsmParser::parseDirectiveCFIPersonalityOrLsda(bool IsPersonality) {\n  int64_t Encoding = 0;\n  if (parseAbsoluteExpression(Encoding))\n    return true;\n  if (Encoding == dwarf::DW_EH_PE_omit)\n    return false;\n\n  StringRef Name;\n  if (check(!isValidEncoding(Encoding), \"unsupported encoding.\") ||\n      parseToken(AsmToken::Comma, \"unexpected token in directive\") ||\n      check(parseIdentifier(Name), \"expected identifier in directive\") ||\n      parseEOL())\n    return true;\n\n  MCSymbol *Sym = getContext().getOrCreateSymbol(Name);\n\n  if (IsPersonality)\n    getStreamer().emitCFIPersonality(Sym, Encoding);\n  else\n    getStreamer().emitCFILsda(Sym, Encoding);\n  return false;\n}\n\n/// parseDirectiveCFIRememberState\n/// ::= .cfi_remember_state\nbool AsmParser::parseDirectiveCFIRememberState() {\n  if (parseEOL())\n    return true;\n  getStreamer().emitCFIRememberState();\n  return false;\n}\n\n/// parseDirectiveCFIRestoreState\n/// ::= .cfi_remember_state\nbool AsmParser::parseDirectiveCFIRestoreState() {\n  if (parseEOL())\n    return true;\n  getStreamer().emitCFIRestoreState();\n  return false;\n}\n\n/// parseDirectiveCFISameValue\n/// ::= .cfi_same_value register\nbool AsmParser::parseDirectiveCFISameValue(SMLoc DirectiveLoc) {\n  int64_t Register = 0;\n\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) || parseEOL())\n    return true;\n\n  getStreamer().emitCFISameValue(Register);\n  return false;\n}\n\n/// parseDirectiveCFIRestore\n/// ::= .cfi_restore register\nbool AsmParser::parseDirectiveCFIRestore(SMLoc DirectiveLoc) {\n  int64_t Register = 0;\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIRestore(Register);\n  return false;\n}\n\n/// parseDirectiveCFIEscape\n/// ::= .cfi_escape expression[,...]\nbool AsmParser::parseDirectiveCFIEscape() {\n  std::string Values;\n  int64_t CurrValue;\n  if (parseAbsoluteExpression(CurrValue))\n    return true;\n\n  Values.push_back((uint8_t)CurrValue);\n\n  while (getLexer().is(AsmToken::Comma)) {\n    Lex();\n\n    if (parseAbsoluteExpression(CurrValue))\n      return true;\n\n    Values.push_back((uint8_t)CurrValue);\n  }\n\n  getStreamer().emitCFIEscape(Values);\n  return false;\n}\n\n/// parseDirectiveCFIReturnColumn\n/// ::= .cfi_return_column register\nbool AsmParser::parseDirectiveCFIReturnColumn(SMLoc DirectiveLoc) {\n  int64_t Register = 0;\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) || parseEOL())\n    return true;\n  getStreamer().emitCFIReturnColumn(Register);\n  return false;\n}\n\n/// parseDirectiveCFISignalFrame\n/// ::= .cfi_signal_frame\nbool AsmParser::parseDirectiveCFISignalFrame() {\n  if (parseEOL())\n    return true;\n\n  getStreamer().emitCFISignalFrame();\n  return false;\n}\n\n/// parseDirectiveCFIUndefined\n/// ::= .cfi_undefined register\nbool AsmParser::parseDirectiveCFIUndefined(SMLoc DirectiveLoc) {\n  int64_t Register = 0;\n\n  if (parseRegisterOrRegisterNumber(Register, DirectiveLoc) || parseEOL())\n    return true;\n\n  getStreamer().emitCFIUndefined(Register);\n  return false;\n}\n\n/// parseDirectiveAltmacro\n/// ::= .altmacro\n/// ::= .noaltmacro\nbool AsmParser::parseDirectiveAltmacro(StringRef Directive) {\n  if (parseEOL())\n    return true;\n  AltMacroMode = (Directive == \".altmacro\");\n  return false;\n}\n\n/// parseDirectiveMacrosOnOff\n/// ::= .macros_on\n/// ::= .macros_off\nbool AsmParser::parseDirectiveMacrosOnOff(StringRef Directive) {\n  if (parseEOL())\n    return true;\n  setMacrosEnabled(Directive == \".macros_on\");\n  return false;\n}\n\n/// parseDirectiveMacro\n/// ::= .macro name[,] [parameters]\nbool AsmParser::parseDirectiveMacro(SMLoc DirectiveLoc) {\n  StringRef Name;\n  if (parseIdentifier(Name))\n    return TokError(\"expected identifier in '.macro' directive\");\n\n  if (getLexer().is(AsmToken::Comma))\n    Lex();\n\n  MCAsmMacroParameters Parameters;\n  while (getLexer().isNot(AsmToken::EndOfStatement)) {\n\n    if (!Parameters.empty() && Parameters.back().Vararg)\n      return Error(Lexer.getLoc(), \"vararg parameter '\" +\n                                       Parameters.back().Name +\n                                       \"' should be the last parameter\");\n\n    MCAsmMacroParameter Parameter;\n    if (parseIdentifier(Parameter.Name))\n      return TokError(\"expected identifier in '.macro' directive\");\n\n    // Emit an error if two (or more) named parameters share the same name\n    for (const MCAsmMacroParameter& CurrParam : Parameters)\n      if (CurrParam.Name.equals(Parameter.Name))\n        return TokError(\"macro '\" + Name + \"' has multiple parameters\"\n                        \" named '\" + Parameter.Name + \"'\");\n\n    if (Lexer.is(AsmToken::Colon)) {\n      Lex();  // consume ':'\n\n      SMLoc QualLoc;\n      StringRef Qualifier;\n\n      QualLoc = Lexer.getLoc();\n      if (parseIdentifier(Qualifier))\n        return Error(QualLoc, \"missing parameter qualifier for \"\n                     \"'\" + Parameter.Name + \"' in macro '\" + Name + \"'\");\n\n      if (Qualifier == \"req\")\n        Parameter.Required = true;\n      else if (Qualifier == \"vararg\")\n        Parameter.Vararg = true;\n      else\n        return Error(QualLoc, Qualifier + \" is not a valid parameter qualifier \"\n                     \"for '\" + Parameter.Name + \"' in macro '\" + Name + \"'\");\n    }\n\n    if (getLexer().is(AsmToken::Equal)) {\n      Lex();\n\n      SMLoc ParamLoc;\n\n      ParamLoc = Lexer.getLoc();\n      if (parseMacroArgument(Parameter.Value, /*Vararg=*/false ))\n        return true;\n\n      if (Parameter.Required)\n        Warning(ParamLoc, \"pointless default value for required parameter \"\n                \"'\" + Parameter.Name + \"' in macro '\" + Name + \"'\");\n    }\n\n    Parameters.push_back(std::move(Parameter));\n\n    if (getLexer().is(AsmToken::Comma))\n      Lex();\n  }\n\n  // Eat just the end of statement.\n  Lexer.Lex();\n\n  // Consuming deferred text, so use Lexer.Lex to ignore Lexing Errors\n  AsmToken EndToken, StartToken = getTok();\n  unsigned MacroDepth = 0;\n  // Lex the macro definition.\n  while (true) {\n    // Ignore Lexing errors in macros.\n    while (Lexer.is(AsmToken::Error)) {\n      Lexer.Lex();\n    }\n\n    // Check whether we have reached the end of the file.\n    if (getLexer().is(AsmToken::Eof))\n      return Error(DirectiveLoc, \"no matching '.endmacro' in definition\");\n\n    // Otherwise, check whether we have reach the .endmacro or the start of a\n    // preprocessor line marker.\n    if (getLexer().is(AsmToken::Identifier)) {\n      if (getTok().getIdentifier() == \".endm\" ||\n          getTok().getIdentifier() == \".endmacro\") {\n        if (MacroDepth == 0) { // Outermost macro.\n          EndToken = getTok();\n          Lexer.Lex();\n          if (getLexer().isNot(AsmToken::EndOfStatement))\n            return TokError(\"unexpected token in '\" + EndToken.getIdentifier() +\n                            \"' directive\");\n          break;\n        } else {\n          // Otherwise we just found the end of an inner macro.\n          --MacroDepth;\n        }\n      } else if (getTok().getIdentifier() == \".macro\") {\n        // We allow nested macros. Those aren't instantiated until the outermost\n        // macro is expanded so just ignore them for now.\n        ++MacroDepth;\n      }\n    } else if (Lexer.is(AsmToken::HashDirective)) {\n      (void)parseCppHashLineFilenameComment(getLexer().getLoc());\n    }\n\n    // Otherwise, scan til the end of the statement.\n    eatToEndOfStatement();\n  }\n\n  if (getContext().lookupMacro(Name)) {\n    return Error(DirectiveLoc, \"macro '\" + Name + \"' is already defined\");\n  }\n\n  const char *BodyStart = StartToken.getLoc().getPointer();\n  const char *BodyEnd = EndToken.getLoc().getPointer();\n  StringRef Body = StringRef(BodyStart, BodyEnd - BodyStart);\n  checkForBadMacro(DirectiveLoc, Name, Body, Parameters);\n  MCAsmMacro Macro(Name, Body, std::move(Parameters));\n  DEBUG_WITH_TYPE(\"asm-macros\", dbgs() << \"Defining new macro:\\n\";\n                  Macro.dump());\n  getContext().defineMacro(Name, std::move(Macro));\n  return false;\n}\n\n/// checkForBadMacro\n///\n/// With the support added for named parameters there may be code out there that\n/// is transitioning from positional parameters.  In versions of gas that did\n/// not support named parameters they would be ignored on the macro definition.\n/// But to support both styles of parameters this is not possible so if a macro\n/// definition has named parameters but does not use them and has what appears\n/// to be positional parameters, strings like $1, $2, ... and $n, then issue a\n/// warning that the positional parameter found in body which have no effect.\n/// Hoping the developer will either remove the named parameters from the macro\n/// definition so the positional parameters get used if that was what was\n/// intended or change the macro to use the named parameters.  It is possible\n/// this warning will trigger when the none of the named parameters are used\n/// and the strings like $1 are infact to simply to be passed trough unchanged.\nvoid AsmParser::checkForBadMacro(SMLoc DirectiveLoc, StringRef Name,\n                                 StringRef Body,\n                                 ArrayRef<MCAsmMacroParameter> Parameters) {\n  // If this macro is not defined with named parameters the warning we are\n  // checking for here doesn't apply.\n  unsigned NParameters = Parameters.size();\n  if (NParameters == 0)\n    return;\n\n  bool NamedParametersFound = false;\n  bool PositionalParametersFound = false;\n\n  // Look at the body of the macro for use of both the named parameters and what\n  // are likely to be positional parameters.  This is what expandMacro() is\n  // doing when it finds the parameters in the body.\n  while (!Body.empty()) {\n    // Scan for the next possible parameter.\n    std::size_t End = Body.size(), Pos = 0;\n    for (; Pos != End; ++Pos) {\n      // Check for a substitution or escape.\n      // This macro is defined with parameters, look for \\foo, \\bar, etc.\n      if (Body[Pos] == '\\\\' && Pos + 1 != End)\n        break;\n\n      // This macro should have parameters, but look for $0, $1, ..., $n too.\n      if (Body[Pos] != '$' || Pos + 1 == End)\n        continue;\n      char Next = Body[Pos + 1];\n      if (Next == '$' || Next == 'n' ||\n          isdigit(static_cast<unsigned char>(Next)))\n        break;\n    }\n\n    // Check if we reached the end.\n    if (Pos == End)\n      break;\n\n    if (Body[Pos] == '$') {\n      switch (Body[Pos + 1]) {\n      // $$ => $\n      case '$':\n        break;\n\n      // $n => number of arguments\n      case 'n':\n        PositionalParametersFound = true;\n        break;\n\n      // $[0-9] => argument\n      default: {\n        PositionalParametersFound = true;\n        break;\n      }\n      }\n      Pos += 2;\n    } else {\n      unsigned I = Pos + 1;\n      while (isIdentifierChar(Body[I]) && I + 1 != End)\n        ++I;\n\n      const char *Begin = Body.data() + Pos + 1;\n      StringRef Argument(Begin, I - (Pos + 1));\n      unsigned Index = 0;\n      for (; Index < NParameters; ++Index)\n        if (Parameters[Index].Name == Argument)\n          break;\n\n      if (Index == NParameters) {\n        if (Body[Pos + 1] == '(' && Body[Pos + 2] == ')')\n          Pos += 3;\n        else {\n          Pos = I;\n        }\n      } else {\n        NamedParametersFound = true;\n        Pos += 1 + Argument.size();\n      }\n    }\n    // Update the scan point.\n    Body = Body.substr(Pos);\n  }\n\n  if (!NamedParametersFound && PositionalParametersFound)\n    Warning(DirectiveLoc, \"macro defined with named parameters which are not \"\n                          \"used in macro body, possible positional parameter \"\n                          \"found in body which will have no effect\");\n}\n\n/// parseDirectiveExitMacro\n/// ::= .exitm\nbool AsmParser::parseDirectiveExitMacro(StringRef Directive) {\n  if (parseEOL())\n    return true;\n\n  if (!isInsideMacroInstantiation())\n    return TokError(\"unexpected '\" + Directive + \"' in file, \"\n                                                 \"no current macro definition\");\n\n  // Exit all conditionals that are active in the current macro.\n  while (TheCondStack.size() != ActiveMacros.back()->CondStackDepth) {\n    TheCondState = TheCondStack.back();\n    TheCondStack.pop_back();\n  }\n\n  handleMacroExit();\n  return false;\n}\n\n/// parseDirectiveEndMacro\n/// ::= .endm\n/// ::= .endmacro\nbool AsmParser::parseDirectiveEndMacro(StringRef Directive) {\n  if (getLexer().isNot(AsmToken::EndOfStatement))\n    return TokError(\"unexpected token in '\" + Directive + \"' directive\");\n\n  // If we are inside a macro instantiation, terminate the current\n  // instantiation.\n  if (isInsideMacroInstantiation()) {\n    handleMacroExit();\n    return false;\n  }\n\n  // Otherwise, this .endmacro is a stray entry in the file; well formed\n  // .endmacro directives are handled during the macro definition parsing.\n  return TokError(\"unexpected '\" + Directive + \"' in file, \"\n                                               \"no current macro definition\");\n}\n\n/// parseDirectivePurgeMacro\n/// ::= .purgem name\nbool AsmParser::parseDirectivePurgeMacro(SMLoc DirectiveLoc) {\n  StringRef Name;\n  SMLoc Loc;\n  if (parseTokenLoc(Loc) ||\n      check(parseIdentifier(Name), Loc,\n            \"expected identifier in '.purgem' directive\") ||\n      parseEOL())\n    return true;\n\n  if (!getContext().lookupMacro(Name))\n    return Error(DirectiveLoc, \"macro '\" + Name + \"' is not defined\");\n\n  getContext().undefineMacro(Name);\n  DEBUG_WITH_TYPE(\"asm-macros\", dbgs()\n                                    << \"Un-defining macro: \" << Name << \"\\n\");\n  return false;\n}\n\n/// parseDirectiveBundleAlignMode\n/// ::= {.bundle_align_mode} expression\nbool AsmParser::parseDirectiveBundleAlignMode() {\n  // Expect a single argument: an expression that evaluates to a constant\n  // in the inclusive range 0-30.\n  SMLoc ExprLoc = getLexer().getLoc();\n  int64_t AlignSizePow2;\n  if (checkForValidSection() || parseAbsoluteExpression(AlignSizePow2) ||\n      parseEOL() ||\n      check(AlignSizePow2 < 0 || AlignSizePow2 > 30, ExprLoc,\n            \"invalid bundle alignment size (expected between 0 and 30)\"))\n    return true;\n\n  // Because of AlignSizePow2's verified range we can safely truncate it to\n  // unsigned.\n  getStreamer().emitBundleAlignMode(static_cast<unsigned>(AlignSizePow2));\n  return false;\n}\n\n/// parseDirectiveBundleLock\n/// ::= {.bundle_lock} [align_to_end]\nbool AsmParser::parseDirectiveBundleLock() {\n  if (checkForValidSection())\n    return true;\n  bool AlignToEnd = false;\n\n  StringRef Option;\n  SMLoc Loc = getTok().getLoc();\n  const char *kInvalidOptionError =\n      \"invalid option for '.bundle_lock' directive\";\n\n  if (!parseOptionalToken(AsmToken::EndOfStatement)) {\n    if (check(parseIdentifier(Option), Loc, kInvalidOptionError) ||\n        check(Option != \"align_to_end\", Loc, kInvalidOptionError) || parseEOL())\n      return true;\n    AlignToEnd = true;\n  }\n\n  getStreamer().emitBundleLock(AlignToEnd);\n  return false;\n}\n\n/// parseDirectiveBundleLock\n/// ::= {.bundle_lock}\nbool AsmParser::parseDirectiveBundleUnlock() {\n  if (checkForValidSection() || parseEOL())\n    return true;\n\n  getStreamer().emitBundleUnlock();\n  return false;\n}\n\n/// parseDirectiveSpace\n/// ::= (.skip | .space) expression [ , expression ]\nbool AsmParser::parseDirectiveSpace(StringRef IDVal) {\n  SMLoc NumBytesLoc = Lexer.getLoc();\n  const MCExpr *NumBytes;\n  if (checkForValidSection() || parseExpression(NumBytes))\n    return true;\n\n  int64_t FillExpr = 0;\n  if (parseOptionalToken(AsmToken::Comma))\n    if (parseAbsoluteExpression(FillExpr))\n      return addErrorSuffix(\"in '\" + Twine(IDVal) + \"' directive\");\n  if (parseEOL())\n    return addErrorSuffix(\"in '\" + Twine(IDVal) + \"' directive\");\n\n  // FIXME: Sometimes the fill expr is 'nop' if it isn't supplied, instead of 0.\n  getStreamer().emitFill(*NumBytes, FillExpr, NumBytesLoc);\n\n  return false;\n}\n\n/// parseDirectiveDCB\n/// ::= .dcb.{b, l, w} expression, expression\nbool AsmParser::parseDirectiveDCB(StringRef IDVal, unsigned Size) {\n  SMLoc NumValuesLoc = Lexer.getLoc();\n  int64_t NumValues;\n  if (checkForValidSection() || parseAbsoluteExpression(NumValues))\n    return true;\n\n  if (NumValues < 0) {\n    Warning(NumValuesLoc, \"'\" + Twine(IDVal) + \"' directive with negative repeat count has no effect\");\n    return false;\n  }\n\n  if (parseToken(AsmToken::Comma,\n                 \"unexpected token in '\" + Twine(IDVal) + \"' directive\"))\n    return true;\n\n  const MCExpr *Value;\n  SMLoc ExprLoc = getLexer().getLoc();\n  if (parseExpression(Value))\n    return true;\n\n  // Special case constant expressions to match code generator.\n  if (const MCConstantExpr *MCE = dyn_cast<MCConstantExpr>(Value)) {\n    assert(Size <= 8 && \"Invalid size\");\n    uint64_t IntValue = MCE->getValue();\n    if (!isUIntN(8 * Size, IntValue) && !isIntN(8 * Size, IntValue))\n      return Error(ExprLoc, \"literal value out of range for directive\");\n    for (uint64_t i = 0, e = NumValues; i != e; ++i)\n      getStreamer().emitIntValue(IntValue, Size);\n  } else {\n    for (uint64_t i = 0, e = NumValues; i != e; ++i)\n      getStreamer().emitValue(Value, Size, ExprLoc);\n  }\n\n  return parseEOL();\n}\n\n/// parseDirectiveRealDCB\n/// ::= .dcb.{d, s} expression, expression\nbool AsmParser::parseDirectiveRealDCB(StringRef IDVal, const fltSemantics &Semantics) {\n  SMLoc NumValuesLoc = Lexer.getLoc();\n  int64_t NumValues;\n  if (checkForValidSection() || parseAbsoluteExpression(NumValues))\n    return true;\n\n  if (NumValues < 0) {\n    Warning(NumValuesLoc, \"'\" + Twine(IDVal) + \"' directive with negative repeat count has no effect\");\n    return false;\n  }\n\n  if (parseToken(AsmToken::Comma,\n                 \"unexpected token in '\" + Twine(IDVal) + \"' directive\"))\n    return true;\n\n  APInt AsInt;\n  if (parseRealValue(Semantics, AsInt) || parseEOL())\n    return true;\n\n  for (uint64_t i = 0, e = NumValues; i != e; ++i)\n    getStreamer().emitIntValue(AsInt.getLimitedValue(),\n                               AsInt.getBitWidth() / 8);\n\n  return false;\n}\n\n/// parseDirectiveDS\n/// ::= .ds.{b, d, l, p, s, w, x} expression\nbool AsmParser::parseDirectiveDS(StringRef IDVal, unsigned Size) {\n  SMLoc NumValuesLoc = Lexer.getLoc();\n  int64_t NumValues;\n  if (checkForValidSection() || parseAbsoluteExpression(NumValues) ||\n      parseEOL())\n    return true;\n\n  if (NumValues < 0) {\n    Warning(NumValuesLoc, \"'\" + Twine(IDVal) + \"' directive with negative repeat count has no effect\");\n    return false;\n  }\n\n  for (uint64_t i = 0, e = NumValues; i != e; ++i)\n    getStreamer().emitFill(Size, 0);\n\n  return false;\n}\n\n/// parseDirectiveLEB128\n/// ::= (.sleb128 | .uleb128) [ expression (, expression)* ]\nbool AsmParser::parseDirectiveLEB128(bool Signed) {\n  if (checkForValidSection())\n    return true;\n\n  auto parseOp = [&]() -> bool {\n    const MCExpr *Value;\n    if (parseExpression(Value))\n      return true;\n    if (Signed)\n      getStreamer().emitSLEB128Value(Value);\n    else\n      getStreamer().emitULEB128Value(Value);\n    return false;\n  };\n\n  if (parseMany(parseOp))\n    return addErrorSuffix(\" in directive\");\n\n  return false;\n}\n\n/// parseDirectiveSymbolAttribute\n///  ::= { \".globl\", \".weak\", ... } [ identifier ( , identifier )* ]\nbool AsmParser::parseDirectiveSymbolAttribute(MCSymbolAttr Attr) {\n  auto parseOp = [&]() -> bool {\n    StringRef Name;\n    SMLoc Loc = getTok().getLoc();\n    if (parseIdentifier(Name))\n      return Error(Loc, \"expected identifier\");\n    MCSymbol *Sym = getContext().getOrCreateSymbol(Name);\n\n    // Assembler local symbols don't make any sense here. Complain loudly.\n    if (Sym->isTemporary())\n      return Error(Loc, \"non-local symbol required\");\n\n    if (!getStreamer().emitSymbolAttribute(Sym, Attr))\n      return Error(Loc, \"unable to emit symbol attribute\");\n    return false;\n  };\n\n  if (parseMany(parseOp))\n    return addErrorSuffix(\" in directive\");\n  return false;\n}\n\n/// parseDirectiveComm\n///  ::= ( .comm | .lcomm ) identifier , size_expression [ , align_expression ]\nbool AsmParser::parseDirectiveComm(bool IsLocal) {\n  if (checkForValidSection())\n    return true;\n\n  SMLoc IDLoc = getLexer().getLoc();\n  StringRef Name;\n  if (parseIdentifier(Name))\n    return TokError(\"expected identifier in directive\");\n\n  // Handle the identifier as the key symbol.\n  MCSymbol *Sym = getContext().getOrCreateSymbol(Name);\n\n  if (getLexer().isNot(AsmToken::Comma))\n    return TokError(\"unexpected token in directive\");\n  Lex();\n\n  int64_t Size;\n  SMLoc SizeLoc = getLexer().getLoc();\n  if (parseAbsoluteExpression(Size))\n    return true;\n\n  int64_t Pow2Alignment = 0;\n  SMLoc Pow2AlignmentLoc;\n  if (getLexer().is(AsmToken::Comma)) {\n    Lex();\n    Pow2AlignmentLoc = getLexer().getLoc();\n    if (parseAbsoluteExpression(Pow2Alignment))\n      return true;\n\n    LCOMM::LCOMMType LCOMM = Lexer.getMAI().getLCOMMDirectiveAlignmentType();\n    if (IsLocal && LCOMM == LCOMM::NoAlignment)\n      return Error(Pow2AlignmentLoc, \"alignment not supported on this target\");\n\n    // If this target takes alignments in bytes (not log) validate and convert.\n    if ((!IsLocal && Lexer.getMAI().getCOMMDirectiveAlignmentIsInBytes()) ||\n        (IsLocal && LCOMM == LCOMM::ByteAlignment)) {\n      if (!isPowerOf2_64(Pow2Alignment))\n        return Error(Pow2AlignmentLoc, \"alignment must be a power of 2\");\n      Pow2Alignment = Log2_64(Pow2Alignment);\n    }\n  }\n\n  if (parseEOL())\n    return true;\n\n  // NOTE: a size of zero for a .comm should create a undefined symbol\n  // but a size of .lcomm creates a bss symbol of size zero.\n  if (Size < 0)\n    return Error(SizeLoc, \"invalid '.comm' or '.lcomm' directive size, can't \"\n                          \"be less than zero\");\n\n  // NOTE: The alignment in the directive is a power of 2 value, the assembler\n  // may internally end up wanting an alignment in bytes.\n  // FIXME: Diagnose overflow.\n  if (Pow2Alignment < 0)\n    return Error(Pow2AlignmentLoc, \"invalid '.comm' or '.lcomm' directive \"\n                                   \"alignment, can't be less than zero\");\n\n  Sym->redefineIfPossible();\n  if (!Sym->isUndefined())\n    return Error(IDLoc, \"invalid symbol redefinition\");\n\n  // Create the Symbol as a common or local common with Size and Pow2Alignment\n  if (IsLocal) {\n    getStreamer().emitLocalCommonSymbol(Sym, Size, 1 << Pow2Alignment);\n    return false;\n  }\n\n  getStreamer().emitCommonSymbol(Sym, Size, 1 << Pow2Alignment);\n  return false;\n}\n\n/// parseDirectiveAbort\n///  ::= .abort [... message ...]\nbool AsmParser::parseDirectiveAbort() {\n  // FIXME: Use loc from directive.\n  SMLoc Loc = getLexer().getLoc();\n\n  StringRef Str = parseStringToEndOfStatement();\n  if (parseEOL())\n    return true;\n\n  if (Str.empty())\n    return Error(Loc, \".abort detected. Assembly stopping.\");\n  else\n    return Error(Loc, \".abort '\" + Str + \"' detected. Assembly stopping.\");\n  // FIXME: Actually abort assembly here.\n\n  return false;\n}\n\n/// parseDirectiveInclude\n///  ::= .include \"filename\"\nbool AsmParser::parseDirectiveInclude() {\n  // Allow the strings to have escaped octal character sequence.\n  std::string Filename;\n  SMLoc IncludeLoc = getTok().getLoc();\n\n  if (check(getTok().isNot(AsmToken::String),\n            \"expected string in '.include' directive\") ||\n      parseEscapedString(Filename) ||\n      check(getTok().isNot(AsmToken::EndOfStatement),\n            \"unexpected token in '.include' directive\") ||\n      // Attempt to switch the lexer to the included file before consuming the\n      // end of statement to avoid losing it when we switch.\n      check(enterIncludeFile(Filename), IncludeLoc,\n            \"Could not find include file '\" + Filename + \"'\"))\n    return true;\n\n  return false;\n}\n\n/// parseDirectiveIncbin\n///  ::= .incbin \"filename\" [ , skip [ , count ] ]\nbool AsmParser::parseDirectiveIncbin() {\n  // Allow the strings to have escaped octal character sequence.\n  std::string Filename;\n  SMLoc IncbinLoc = getTok().getLoc();\n  if (check(getTok().isNot(AsmToken::String),\n            \"expected string in '.incbin' directive\") ||\n      parseEscapedString(Filename))\n    return true;\n\n  int64_t Skip = 0;\n  const MCExpr *Count = nullptr;\n  SMLoc SkipLoc, CountLoc;\n  if (parseOptionalToken(AsmToken::Comma)) {\n    // The skip expression can be omitted while specifying the count, e.g:\n    //  .incbin \"filename\",,4\n    if (getTok().isNot(AsmToken::Comma)) {\n      if (parseTokenLoc(SkipLoc) || parseAbsoluteExpression(Skip))\n        return true;\n    }\n    if (parseOptionalToken(AsmToken::Comma)) {\n      CountLoc = getTok().getLoc();\n      if (parseExpression(Count))\n        return true;\n    }\n  }\n\n  if (parseEOL())\n    return true;\n\n  if (check(Skip < 0, SkipLoc, \"skip is negative\"))\n    return true;\n\n  // Attempt to process the included file.\n  if (processIncbinFile(Filename, Skip, Count, CountLoc))\n    return Error(IncbinLoc, \"Could not find incbin file '\" + Filename + \"'\");\n  return false;\n}\n\n/// parseDirectiveIf\n/// ::= .if{,eq,ge,gt,le,lt,ne} expression\nbool AsmParser::parseDirectiveIf(SMLoc DirectiveLoc, DirectiveKind DirKind) {\n  TheCondStack.push_back(TheCondState);\n  TheCondState.TheCond = AsmCond::IfCond;\n  if (TheCondState.Ignore) {\n    eatToEndOfStatement();\n  } else {\n    int64_t ExprValue;\n    if (parseAbsoluteExpression(ExprValue) || parseEOL())\n      return true;\n\n    switch (DirKind) {\n    default:\n      llvm_unreachable(\"unsupported directive\");\n    case DK_IF:\n    case DK_IFNE:\n      break;\n    case DK_IFEQ:\n      ExprValue = ExprValue == 0;\n      break;\n    case DK_IFGE:\n      ExprValue = ExprValue >= 0;\n      break;\n    case DK_IFGT:\n      ExprValue = ExprValue > 0;\n      break;\n    case DK_IFLE:\n      ExprValue = ExprValue <= 0;\n      break;\n    case DK_IFLT:\n      ExprValue = ExprValue < 0;\n      break;\n    }\n\n    TheCondState.CondMet = ExprValue;\n    TheCondState.Ignore = !TheCondState.CondMet;\n  }\n\n  return false;\n}\n\n/// parseDirectiveIfb\n/// ::= .ifb string\nbool AsmParser::parseDirectiveIfb(SMLoc DirectiveLoc, bool ExpectBlank) {\n  TheCondStack.push_back(TheCondState);\n  TheCondState.TheCond = AsmCond::IfCond;\n\n  if (TheCondState.Ignore) {\n    eatToEndOfStatement();\n  } else {\n    StringRef Str = parseStringToEndOfStatement();\n\n    if (parseEOL())\n      return true;\n\n    TheCondState.CondMet = ExpectBlank == Str.empty();\n    TheCondState.Ignore = !TheCondState.CondMet;\n  }\n\n  return false;\n}\n\n/// parseDirectiveIfc\n/// ::= .ifc string1, string2\n/// ::= .ifnc string1, string2\nbool AsmParser::parseDirectiveIfc(SMLoc DirectiveLoc, bool ExpectEqual) {\n  TheCondStack.push_back(TheCondState);\n  TheCondState.TheCond = AsmCond::IfCond;\n\n  if (TheCondState.Ignore) {\n    eatToEndOfStatement();\n  } else {\n    StringRef Str1 = parseStringToComma();\n\n    if (parseToken(AsmToken::Comma, \"unexpected token in '.ifc' directive\"))\n      return true;\n\n    StringRef Str2 = parseStringToEndOfStatement();\n\n    if (parseEOL())\n      return true;\n\n    TheCondState.CondMet = ExpectEqual == (Str1.trim() == Str2.trim());\n    TheCondState.Ignore = !TheCondState.CondMet;\n  }\n\n  return false;\n}\n\n/// parseDirectiveIfeqs\n///   ::= .ifeqs string1, string2\nbool AsmParser::parseDirectiveIfeqs(SMLoc DirectiveLoc, bool ExpectEqual) {\n  if (Lexer.isNot(AsmToken::String)) {\n    if (ExpectEqual)\n      return TokError(\"expected string parameter for '.ifeqs' directive\");\n    return TokError(\"expected string parameter for '.ifnes' directive\");\n  }\n\n  StringRef String1 = getTok().getStringContents();\n  Lex();\n\n  if (Lexer.isNot(AsmToken::Comma)) {\n    if (ExpectEqual)\n      return TokError(\n          \"expected comma after first string for '.ifeqs' directive\");\n    return TokError(\"expected comma after first string for '.ifnes' directive\");\n  }\n\n  Lex();\n\n  if (Lexer.isNot(AsmToken::String)) {\n    if (ExpectEqual)\n      return TokError(\"expected string parameter for '.ifeqs' directive\");\n    return TokError(\"expected string parameter for '.ifnes' directive\");\n  }\n\n  StringRef String2 = getTok().getStringContents();\n  Lex();\n\n  TheCondStack.push_back(TheCondState);\n  TheCondState.TheCond = AsmCond::IfCond;\n  TheCondState.CondMet = ExpectEqual == (String1 == String2);\n  TheCondState.Ignore = !TheCondState.CondMet;\n\n  return false;\n}\n\n/// parseDirectiveIfdef\n/// ::= .ifdef symbol\nbool AsmParser::parseDirectiveIfdef(SMLoc DirectiveLoc, bool expect_defined) {\n  StringRef Name;\n  TheCondStack.push_back(TheCondState);\n  TheCondState.TheCond = AsmCond::IfCond;\n\n  if (TheCondState.Ignore) {\n    eatToEndOfStatement();\n  } else {\n    if (check(parseIdentifier(Name), \"expected identifier after '.ifdef'\") ||\n        parseEOL())\n      return true;\n\n    MCSymbol *Sym = getContext().lookupSymbol(Name);\n\n    if (expect_defined)\n      TheCondState.CondMet = (Sym && !Sym->isUndefined(false));\n    else\n      TheCondState.CondMet = (!Sym || Sym->isUndefined(false));\n    TheCondState.Ignore = !TheCondState.CondMet;\n  }\n\n  return false;\n}\n\n/// parseDirectiveElseIf\n/// ::= .elseif expression\nbool AsmParser::parseDirectiveElseIf(SMLoc DirectiveLoc) {\n  if (TheCondState.TheCond != AsmCond::IfCond &&\n      TheCondState.TheCond != AsmCond::ElseIfCond)\n    return Error(DirectiveLoc, \"Encountered a .elseif that doesn't follow an\"\n                               \" .if or  an .elseif\");\n  TheCondState.TheCond = AsmCond::ElseIfCond;\n\n  bool LastIgnoreState = false;\n  if (!TheCondStack.empty())\n    LastIgnoreState = TheCondStack.back().Ignore;\n  if (LastIgnoreState || TheCondState.CondMet) {\n    TheCondState.Ignore = true;\n    eatToEndOfStatement();\n  } else {\n    int64_t ExprValue;\n    if (parseAbsoluteExpression(ExprValue))\n      return true;\n\n    if (parseEOL())\n      return true;\n\n    TheCondState.CondMet = ExprValue;\n    TheCondState.Ignore = !TheCondState.CondMet;\n  }\n\n  return false;\n}\n\n/// parseDirectiveElse\n/// ::= .else\nbool AsmParser::parseDirectiveElse(SMLoc DirectiveLoc) {\n  if (parseEOL())\n    return true;\n\n  if (TheCondState.TheCond != AsmCond::IfCond &&\n      TheCondState.TheCond != AsmCond::ElseIfCond)\n    return Error(DirectiveLoc, \"Encountered a .else that doesn't follow \"\n                               \" an .if or an .elseif\");\n  TheCondState.TheCond = AsmCond::ElseCond;\n  bool LastIgnoreState = false;\n  if (!TheCondStack.empty())\n    LastIgnoreState = TheCondStack.back().Ignore;\n  if (LastIgnoreState || TheCondState.CondMet)\n    TheCondState.Ignore = true;\n  else\n    TheCondState.Ignore = false;\n\n  return false;\n}\n\n/// parseDirectiveEnd\n/// ::= .end\nbool AsmParser::parseDirectiveEnd(SMLoc DirectiveLoc) {\n  if (parseEOL())\n    return true;\n\n  while (Lexer.isNot(AsmToken::Eof))\n    Lexer.Lex();\n\n  return false;\n}\n\n/// parseDirectiveError\n///   ::= .err\n///   ::= .error [string]\nbool AsmParser::parseDirectiveError(SMLoc L, bool WithMessage) {\n  if (!TheCondStack.empty()) {\n    if (TheCondStack.back().Ignore) {\n      eatToEndOfStatement();\n      return false;\n    }\n  }\n\n  if (!WithMessage)\n    return Error(L, \".err encountered\");\n\n  StringRef Message = \".error directive invoked in source file\";\n  if (Lexer.isNot(AsmToken::EndOfStatement)) {\n    if (Lexer.isNot(AsmToken::String))\n      return TokError(\".error argument must be a string\");\n\n    Message = getTok().getStringContents();\n    Lex();\n  }\n\n  return Error(L, Message);\n}\n\n/// parseDirectiveWarning\n///   ::= .warning [string]\nbool AsmParser::parseDirectiveWarning(SMLoc L) {\n  if (!TheCondStack.empty()) {\n    if (TheCondStack.back().Ignore) {\n      eatToEndOfStatement();\n      return false;\n    }\n  }\n\n  StringRef Message = \".warning directive invoked in source file\";\n\n  if (!parseOptionalToken(AsmToken::EndOfStatement)) {\n    if (Lexer.isNot(AsmToken::String))\n      return TokError(\".warning argument must be a string\");\n\n    Message = getTok().getStringContents();\n    Lex();\n    if (parseEOL())\n      return true;\n  }\n\n  return Warning(L, Message);\n}\n\n/// parseDirectiveEndIf\n/// ::= .endif\nbool AsmParser::parseDirectiveEndIf(SMLoc DirectiveLoc) {\n  if (parseEOL())\n    return true;\n\n  if ((TheCondState.TheCond == AsmCond::NoCond) || TheCondStack.empty())\n    return Error(DirectiveLoc, \"Encountered a .endif that doesn't follow \"\n                               \"an .if or .else\");\n  if (!TheCondStack.empty()) {\n    TheCondState = TheCondStack.back();\n    TheCondStack.pop_back();\n  }\n\n  return false;\n}\n\nvoid AsmParser::initializeDirectiveKindMap() {\n  /* Lookup will be done with the directive\n   * converted to lower case, so all these\n   * keys should be lower case.\n   * (target specific directives are handled\n   *  elsewhere)\n   */\n  DirectiveKindMap[\".set\"] = DK_SET;\n  DirectiveKindMap[\".equ\"] = DK_EQU;\n  DirectiveKindMap[\".equiv\"] = DK_EQUIV;\n  DirectiveKindMap[\".ascii\"] = DK_ASCII;\n  DirectiveKindMap[\".asciz\"] = DK_ASCIZ;\n  DirectiveKindMap[\".string\"] = DK_STRING;\n  DirectiveKindMap[\".byte\"] = DK_BYTE;\n  DirectiveKindMap[\".short\"] = DK_SHORT;\n  DirectiveKindMap[\".value\"] = DK_VALUE;\n  DirectiveKindMap[\".2byte\"] = DK_2BYTE;\n  DirectiveKindMap[\".long\"] = DK_LONG;\n  DirectiveKindMap[\".int\"] = DK_INT;\n  DirectiveKindMap[\".4byte\"] = DK_4BYTE;\n  DirectiveKindMap[\".quad\"] = DK_QUAD;\n  DirectiveKindMap[\".8byte\"] = DK_8BYTE;\n  DirectiveKindMap[\".octa\"] = DK_OCTA;\n  DirectiveKindMap[\".single\"] = DK_SINGLE;\n  DirectiveKindMap[\".float\"] = DK_FLOAT;\n  DirectiveKindMap[\".double\"] = DK_DOUBLE;\n  DirectiveKindMap[\".align\"] = DK_ALIGN;\n  DirectiveKindMap[\".align32\"] = DK_ALIGN32;\n  DirectiveKindMap[\".balign\"] = DK_BALIGN;\n  DirectiveKindMap[\".balignw\"] = DK_BALIGNW;\n  DirectiveKindMap[\".balignl\"] = DK_BALIGNL;\n  DirectiveKindMap[\".p2align\"] = DK_P2ALIGN;\n  DirectiveKindMap[\".p2alignw\"] = DK_P2ALIGNW;\n  DirectiveKindMap[\".p2alignl\"] = DK_P2ALIGNL;\n  DirectiveKindMap[\".org\"] = DK_ORG;\n  DirectiveKindMap[\".fill\"] = DK_FILL;\n  DirectiveKindMap[\".zero\"] = DK_ZERO;\n  DirectiveKindMap[\".extern\"] = DK_EXTERN;\n  DirectiveKindMap[\".globl\"] = DK_GLOBL;\n  DirectiveKindMap[\".global\"] = DK_GLOBAL;\n  DirectiveKindMap[\".lazy_reference\"] = DK_LAZY_REFERENCE;\n  DirectiveKindMap[\".no_dead_strip\"] = DK_NO_DEAD_STRIP;\n  DirectiveKindMap[\".symbol_resolver\"] = DK_SYMBOL_RESOLVER;\n  DirectiveKindMap[\".private_extern\"] = DK_PRIVATE_EXTERN;\n  DirectiveKindMap[\".reference\"] = DK_REFERENCE;\n  DirectiveKindMap[\".weak_definition\"] = DK_WEAK_DEFINITION;\n  DirectiveKindMap[\".weak_reference\"] = DK_WEAK_REFERENCE;\n  DirectiveKindMap[\".weak_def_can_be_hidden\"] = DK_WEAK_DEF_CAN_BE_HIDDEN;\n  DirectiveKindMap[\".cold\"] = DK_COLD;\n  DirectiveKindMap[\".comm\"] = DK_COMM;\n  DirectiveKindMap[\".common\"] = DK_COMMON;\n  DirectiveKindMap[\".lcomm\"] = DK_LCOMM;\n  DirectiveKindMap[\".abort\"] = DK_ABORT;\n  DirectiveKindMap[\".include\"] = DK_INCLUDE;\n  DirectiveKindMap[\".incbin\"] = DK_INCBIN;\n  DirectiveKindMap[\".code16\"] = DK_CODE16;\n  DirectiveKindMap[\".code16gcc\"] = DK_CODE16GCC;\n  DirectiveKindMap[\".rept\"] = DK_REPT;\n  DirectiveKindMap[\".rep\"] = DK_REPT;\n  DirectiveKindMap[\".irp\"] = DK_IRP;\n  DirectiveKindMap[\".irpc\"] = DK_IRPC;\n  DirectiveKindMap[\".endr\"] = DK_ENDR;\n  DirectiveKindMap[\".bundle_align_mode\"] = DK_BUNDLE_ALIGN_MODE;\n  DirectiveKindMap[\".bundle_lock\"] = DK_BUNDLE_LOCK;\n  DirectiveKindMap[\".bundle_unlock\"] = DK_BUNDLE_UNLOCK;\n  DirectiveKindMap[\".if\"] = DK_IF;\n  DirectiveKindMap[\".ifeq\"] = DK_IFEQ;\n  DirectiveKindMap[\".ifge\"] = DK_IFGE;\n  DirectiveKindMap[\".ifgt\"] = DK_IFGT;\n  DirectiveKindMap[\".ifle\"] = DK_IFLE;\n  DirectiveKindMap[\".iflt\"] = DK_IFLT;\n  DirectiveKindMap[\".ifne\"] = DK_IFNE;\n  DirectiveKindMap[\".ifb\"] = DK_IFB;\n  DirectiveKindMap[\".ifnb\"] = DK_IFNB;\n  DirectiveKindMap[\".ifc\"] = DK_IFC;\n  DirectiveKindMap[\".ifeqs\"] = DK_IFEQS;\n  DirectiveKindMap[\".ifnc\"] = DK_IFNC;\n  DirectiveKindMap[\".ifnes\"] = DK_IFNES;\n  DirectiveKindMap[\".ifdef\"] = DK_IFDEF;\n  DirectiveKindMap[\".ifndef\"] = DK_IFNDEF;\n  DirectiveKindMap[\".ifnotdef\"] = DK_IFNOTDEF;\n  DirectiveKindMap[\".elseif\"] = DK_ELSEIF;\n  DirectiveKindMap[\".else\"] = DK_ELSE;\n  DirectiveKindMap[\".end\"] = DK_END;\n  DirectiveKindMap[\".endif\"] = DK_ENDIF;\n  DirectiveKindMap[\".skip\"] = DK_SKIP;\n  DirectiveKindMap[\".space\"] = DK_SPACE;\n  DirectiveKindMap[\".file\"] = DK_FILE;\n  DirectiveKindMap[\".line\"] = DK_LINE;\n  DirectiveKindMap[\".loc\"] = DK_LOC;\n  DirectiveKindMap[\".stabs\"] = DK_STABS;\n  DirectiveKindMap[\".cv_file\"] = DK_CV_FILE;\n  DirectiveKindMap[\".cv_func_id\"] = DK_CV_FUNC_ID;\n  DirectiveKindMap[\".cv_loc\"] = DK_CV_LOC;\n  DirectiveKindMap[\".cv_linetable\"] = DK_CV_LINETABLE;\n  DirectiveKindMap[\".cv_inline_linetable\"] = DK_CV_INLINE_LINETABLE;\n  DirectiveKindMap[\".cv_inline_site_id\"] = DK_CV_INLINE_SITE_ID;\n  DirectiveKindMap[\".cv_def_range\"] = DK_CV_DEF_RANGE;\n  DirectiveKindMap[\".cv_string\"] = DK_CV_STRING;\n  DirectiveKindMap[\".cv_stringtable\"] = DK_CV_STRINGTABLE;\n  DirectiveKindMap[\".cv_filechecksums\"] = DK_CV_FILECHECKSUMS;\n  DirectiveKindMap[\".cv_filechecksumoffset\"] = DK_CV_FILECHECKSUM_OFFSET;\n  DirectiveKindMap[\".cv_fpo_data\"] = DK_CV_FPO_DATA;\n  DirectiveKindMap[\".sleb128\"] = DK_SLEB128;\n  DirectiveKindMap[\".uleb128\"] = DK_ULEB128;\n  DirectiveKindMap[\".cfi_sections\"] = DK_CFI_SECTIONS;\n  DirectiveKindMap[\".cfi_startproc\"] = DK_CFI_STARTPROC;\n  DirectiveKindMap[\".cfi_endproc\"] = DK_CFI_ENDPROC;\n  DirectiveKindMap[\".cfi_def_cfa\"] = DK_CFI_DEF_CFA;\n  DirectiveKindMap[\".cfi_def_cfa_offset\"] = DK_CFI_DEF_CFA_OFFSET;\n  DirectiveKindMap[\".cfi_adjust_cfa_offset\"] = DK_CFI_ADJUST_CFA_OFFSET;\n  DirectiveKindMap[\".cfi_def_cfa_register\"] = DK_CFI_DEF_CFA_REGISTER;\n  DirectiveKindMap[\".cfi_offset\"] = DK_CFI_OFFSET;\n  DirectiveKindMap[\".cfi_rel_offset\"] = DK_CFI_REL_OFFSET;\n  DirectiveKindMap[\".cfi_personality\"] = DK_CFI_PERSONALITY;\n  DirectiveKindMap[\".cfi_lsda\"] = DK_CFI_LSDA;\n  DirectiveKindMap[\".cfi_remember_state\"] = DK_CFI_REMEMBER_STATE;\n  DirectiveKindMap[\".cfi_restore_state\"] = DK_CFI_RESTORE_STATE;\n  DirectiveKindMap[\".cfi_same_value\"] = DK_CFI_SAME_VALUE;\n  DirectiveKindMap[\".cfi_restore\"] = DK_CFI_RESTORE;\n  DirectiveKindMap[\".cfi_escape\"] = DK_CFI_ESCAPE;\n  DirectiveKindMap[\".cfi_return_column\"] = DK_CFI_RETURN_COLUMN;\n  DirectiveKindMap[\".cfi_signal_frame\"] = DK_CFI_SIGNAL_FRAME;\n  DirectiveKindMap[\".cfi_undefined\"] = DK_CFI_UNDEFINED;\n  DirectiveKindMap[\".cfi_register\"] = DK_CFI_REGISTER;\n  DirectiveKindMap[\".cfi_window_save\"] = DK_CFI_WINDOW_SAVE;\n  DirectiveKindMap[\".cfi_b_key_frame\"] = DK_CFI_B_KEY_FRAME;\n  DirectiveKindMap[\".macros_on\"] = DK_MACROS_ON;\n  DirectiveKindMap[\".macros_off\"] = DK_MACROS_OFF;\n  DirectiveKindMap[\".macro\"] = DK_MACRO;\n  DirectiveKindMap[\".exitm\"] = DK_EXITM;\n  DirectiveKindMap[\".endm\"] = DK_ENDM;\n  DirectiveKindMap[\".endmacro\"] = DK_ENDMACRO;\n  DirectiveKindMap[\".purgem\"] = DK_PURGEM;\n  DirectiveKindMap[\".err\"] = DK_ERR;\n  DirectiveKindMap[\".error\"] = DK_ERROR;\n  DirectiveKindMap[\".warning\"] = DK_WARNING;\n  DirectiveKindMap[\".altmacro\"] = DK_ALTMACRO;\n  DirectiveKindMap[\".noaltmacro\"] = DK_NOALTMACRO;\n  DirectiveKindMap[\".reloc\"] = DK_RELOC;\n  DirectiveKindMap[\".dc\"] = DK_DC;\n  DirectiveKindMap[\".dc.a\"] = DK_DC_A;\n  DirectiveKindMap[\".dc.b\"] = DK_DC_B;\n  DirectiveKindMap[\".dc.d\"] = DK_DC_D;\n  DirectiveKindMap[\".dc.l\"] = DK_DC_L;\n  DirectiveKindMap[\".dc.s\"] = DK_DC_S;\n  DirectiveKindMap[\".dc.w\"] = DK_DC_W;\n  DirectiveKindMap[\".dc.x\"] = DK_DC_X;\n  DirectiveKindMap[\".dcb\"] = DK_DCB;\n  DirectiveKindMap[\".dcb.b\"] = DK_DCB_B;\n  DirectiveKindMap[\".dcb.d\"] = DK_DCB_D;\n  DirectiveKindMap[\".dcb.l\"] = DK_DCB_L;\n  DirectiveKindMap[\".dcb.s\"] = DK_DCB_S;\n  DirectiveKindMap[\".dcb.w\"] = DK_DCB_W;\n  DirectiveKindMap[\".dcb.x\"] = DK_DCB_X;\n  DirectiveKindMap[\".ds\"] = DK_DS;\n  DirectiveKindMap[\".ds.b\"] = DK_DS_B;\n  DirectiveKindMap[\".ds.d\"] = DK_DS_D;\n  DirectiveKindMap[\".ds.l\"] = DK_DS_L;\n  DirectiveKindMap[\".ds.p\"] = DK_DS_P;\n  DirectiveKindMap[\".ds.s\"] = DK_DS_S;\n  DirectiveKindMap[\".ds.w\"] = DK_DS_W;\n  DirectiveKindMap[\".ds.x\"] = DK_DS_X;\n  DirectiveKindMap[\".print\"] = DK_PRINT;\n  DirectiveKindMap[\".addrsig\"] = DK_ADDRSIG;\n  DirectiveKindMap[\".addrsig_sym\"] = DK_ADDRSIG_SYM;\n  DirectiveKindMap[\".pseudoprobe\"] = DK_PSEUDO_PROBE;\n}\n\nMCAsmMacro *AsmParser::parseMacroLikeBody(SMLoc DirectiveLoc) {\n  AsmToken EndToken, StartToken = getTok();\n\n  unsigned NestLevel = 0;\n  while (true) {\n    // Check whether we have reached the end of the file.\n    if (getLexer().is(AsmToken::Eof)) {\n      printError(DirectiveLoc, \"no matching '.endr' in definition\");\n      return nullptr;\n    }\n\n    if (Lexer.is(AsmToken::Identifier) &&\n        (getTok().getIdentifier() == \".rep\" ||\n         getTok().getIdentifier() == \".rept\" ||\n         getTok().getIdentifier() == \".irp\" ||\n         getTok().getIdentifier() == \".irpc\")) {\n      ++NestLevel;\n    }\n\n    // Otherwise, check whether we have reached the .endr.\n    if (Lexer.is(AsmToken::Identifier) && getTok().getIdentifier() == \".endr\") {\n      if (NestLevel == 0) {\n        EndToken = getTok();\n        Lex();\n        if (Lexer.isNot(AsmToken::EndOfStatement)) {\n          printError(getTok().getLoc(),\n                     \"unexpected token in '.endr' directive\");\n          return nullptr;\n        }\n        break;\n      }\n      --NestLevel;\n    }\n\n    // Otherwise, scan till the end of the statement.\n    eatToEndOfStatement();\n  }\n\n  const char *BodyStart = StartToken.getLoc().getPointer();\n  const char *BodyEnd = EndToken.getLoc().getPointer();\n  StringRef Body = StringRef(BodyStart, BodyEnd - BodyStart);\n\n  // We Are Anonymous.\n  MacroLikeBodies.emplace_back(StringRef(), Body, MCAsmMacroParameters());\n  return &MacroLikeBodies.back();\n}\n\nvoid AsmParser::instantiateMacroLikeBody(MCAsmMacro *M, SMLoc DirectiveLoc,\n                                         raw_svector_ostream &OS) {\n  OS << \".endr\\n\";\n\n  std::unique_ptr<MemoryBuffer> Instantiation =\n      MemoryBuffer::getMemBufferCopy(OS.str(), \"<instantiation>\");\n\n  // Create the macro instantiation object and add to the current macro\n  // instantiation stack.\n  MacroInstantiation *MI = new MacroInstantiation{\n      DirectiveLoc, CurBuffer, getTok().getLoc(), TheCondStack.size()};\n  ActiveMacros.push_back(MI);\n\n  // Jump to the macro instantiation and prime the lexer.\n  CurBuffer = SrcMgr.AddNewSourceBuffer(std::move(Instantiation), SMLoc());\n  Lexer.setBuffer(SrcMgr.getMemoryBuffer(CurBuffer)->getBuffer());\n  Lex();\n}\n\n/// parseDirectiveRept\n///   ::= .rep | .rept count\nbool AsmParser::parseDirectiveRept(SMLoc DirectiveLoc, StringRef Dir) {\n  const MCExpr *CountExpr;\n  SMLoc CountLoc = getTok().getLoc();\n  if (parseExpression(CountExpr))\n    return true;\n\n  int64_t Count;\n  if (!CountExpr->evaluateAsAbsolute(Count, getStreamer().getAssemblerPtr())) {\n    return Error(CountLoc, \"unexpected token in '\" + Dir + \"' directive\");\n  }\n\n  if (check(Count < 0, CountLoc, \"Count is negative\") || parseEOL())\n    return true;\n\n  // Lex the rept definition.\n  MCAsmMacro *M = parseMacroLikeBody(DirectiveLoc);\n  if (!M)\n    return true;\n\n  // Macro instantiation is lexical, unfortunately. We construct a new buffer\n  // to hold the macro body with substitutions.\n  SmallString<256> Buf;\n  raw_svector_ostream OS(Buf);\n  while (Count--) {\n    // Note that the AtPseudoVariable is disabled for instantiations of .rep(t).\n    if (expandMacro(OS, M->Body, None, None, false, getTok().getLoc()))\n      return true;\n  }\n  instantiateMacroLikeBody(M, DirectiveLoc, OS);\n\n  return false;\n}\n\n/// parseDirectiveIrp\n/// ::= .irp symbol,values\nbool AsmParser::parseDirectiveIrp(SMLoc DirectiveLoc) {\n  MCAsmMacroParameter Parameter;\n  MCAsmMacroArguments A;\n  if (check(parseIdentifier(Parameter.Name),\n            \"expected identifier in '.irp' directive\") ||\n      parseToken(AsmToken::Comma, \"expected comma in '.irp' directive\") ||\n      parseMacroArguments(nullptr, A) || parseEOL())\n    return true;\n\n  // Lex the irp definition.\n  MCAsmMacro *M = parseMacroLikeBody(DirectiveLoc);\n  if (!M)\n    return true;\n\n  // Macro instantiation is lexical, unfortunately. We construct a new buffer\n  // to hold the macro body with substitutions.\n  SmallString<256> Buf;\n  raw_svector_ostream OS(Buf);\n\n  for (const MCAsmMacroArgument &Arg : A) {\n    // Note that the AtPseudoVariable is enabled for instantiations of .irp.\n    // This is undocumented, but GAS seems to support it.\n    if (expandMacro(OS, M->Body, Parameter, Arg, true, getTok().getLoc()))\n      return true;\n  }\n\n  instantiateMacroLikeBody(M, DirectiveLoc, OS);\n\n  return false;\n}\n\n/// parseDirectiveIrpc\n/// ::= .irpc symbol,values\nbool AsmParser::parseDirectiveIrpc(SMLoc DirectiveLoc) {\n  MCAsmMacroParameter Parameter;\n  MCAsmMacroArguments A;\n\n  if (check(parseIdentifier(Parameter.Name),\n            \"expected identifier in '.irpc' directive\") ||\n      parseToken(AsmToken::Comma, \"expected comma in '.irpc' directive\") ||\n      parseMacroArguments(nullptr, A))\n    return true;\n\n  if (A.size() != 1 || A.front().size() != 1)\n    return TokError(\"unexpected token in '.irpc' directive\");\n  if (parseEOL())\n    return true;\n\n  // Lex the irpc definition.\n  MCAsmMacro *M = parseMacroLikeBody(DirectiveLoc);\n  if (!M)\n    return true;\n\n  // Macro instantiation is lexical, unfortunately. We construct a new buffer\n  // to hold the macro body with substitutions.\n  SmallString<256> Buf;\n  raw_svector_ostream OS(Buf);\n\n  StringRef Values = A.front().front().getString();\n  for (std::size_t I = 0, End = Values.size(); I != End; ++I) {\n    MCAsmMacroArgument Arg;\n    Arg.emplace_back(AsmToken::Identifier, Values.slice(I, I + 1));\n\n    // Note that the AtPseudoVariable is enabled for instantiations of .irpc.\n    // This is undocumented, but GAS seems to support it.\n    if (expandMacro(OS, M->Body, Parameter, Arg, true, getTok().getLoc()))\n      return true;\n  }\n\n  instantiateMacroLikeBody(M, DirectiveLoc, OS);\n\n  return false;\n}\n\nbool AsmParser::parseDirectiveEndr(SMLoc DirectiveLoc) {\n  if (ActiveMacros.empty())\n    return TokError(\"unmatched '.endr' directive\");\n\n  // The only .repl that should get here are the ones created by\n  // instantiateMacroLikeBody.\n  assert(getLexer().is(AsmToken::EndOfStatement));\n\n  handleMacroExit();\n  return false;\n}\n\nbool AsmParser::parseDirectiveMSEmit(SMLoc IDLoc, ParseStatementInfo &Info,\n                                     size_t Len) {\n  const MCExpr *Value;\n  SMLoc ExprLoc = getLexer().getLoc();\n  if (parseExpression(Value))\n    return true;\n  const MCConstantExpr *MCE = dyn_cast<MCConstantExpr>(Value);\n  if (!MCE)\n    return Error(ExprLoc, \"unexpected expression in _emit\");\n  uint64_t IntValue = MCE->getValue();\n  if (!isUInt<8>(IntValue) && !isInt<8>(IntValue))\n    return Error(ExprLoc, \"literal value out of range for directive\");\n\n  Info.AsmRewrites->emplace_back(AOK_Emit, IDLoc, Len);\n  return false;\n}\n\nbool AsmParser::parseDirectiveMSAlign(SMLoc IDLoc, ParseStatementInfo &Info) {\n  const MCExpr *Value;\n  SMLoc ExprLoc = getLexer().getLoc();\n  if (parseExpression(Value))\n    return true;\n  const MCConstantExpr *MCE = dyn_cast<MCConstantExpr>(Value);\n  if (!MCE)\n    return Error(ExprLoc, \"unexpected expression in align\");\n  uint64_t IntValue = MCE->getValue();\n  if (!isPowerOf2_64(IntValue))\n    return Error(ExprLoc, \"literal value not a power of two greater then zero\");\n\n  Info.AsmRewrites->emplace_back(AOK_Align, IDLoc, 5, Log2_64(IntValue));\n  return false;\n}\n\nbool AsmParser::parseDirectivePrint(SMLoc DirectiveLoc) {\n  const AsmToken StrTok = getTok();\n  Lex();\n  if (StrTok.isNot(AsmToken::String) || StrTok.getString().front() != '\"')\n    return Error(DirectiveLoc, \"expected double quoted string after .print\");\n  if (parseEOL())\n    return true;\n  llvm::outs() << StrTok.getStringContents() << '\\n';\n  return false;\n}\n\nbool AsmParser::parseDirectiveAddrsig() {\n  if (parseEOL())\n    return true;\n  getStreamer().emitAddrsig();\n  return false;\n}\n\nbool AsmParser::parseDirectiveAddrsigSym() {\n  StringRef Name;\n  if (check(parseIdentifier(Name), \"expected identifier\") || parseEOL())\n    return true;\n  MCSymbol *Sym = getContext().getOrCreateSymbol(Name);\n  getStreamer().emitAddrsigSym(Sym);\n  return false;\n}\n\nbool AsmParser::parseDirectivePseudoProbe() {\n  int64_t Guid;\n  int64_t Index;\n  int64_t Type;\n  int64_t Attr;\n\n  if (getLexer().is(AsmToken::Integer)) {\n    if (parseIntToken(Guid, \"unexpected token in '.pseudoprobe' directive\"))\n      return true;\n  }\n\n  if (getLexer().is(AsmToken::Integer)) {\n    if (parseIntToken(Index, \"unexpected token in '.pseudoprobe' directive\"))\n      return true;\n  }\n\n  if (getLexer().is(AsmToken::Integer)) {\n    if (parseIntToken(Type, \"unexpected token in '.pseudoprobe' directive\"))\n      return true;\n  }\n\n  if (getLexer().is(AsmToken::Integer)) {\n    if (parseIntToken(Attr, \"unexpected token in '.pseudoprobe' directive\"))\n      return true;\n  }\n\n  // Parse inline stack like @ GUID:11:12 @ GUID:1:11 @ GUID:3:21\n  MCPseudoProbeInlineStack InlineStack;\n\n  while (getLexer().is(AsmToken::At)) {\n    // eat @\n    Lex();\n\n    int64_t CallerGuid = 0;\n    if (getLexer().is(AsmToken::Integer)) {\n      if (parseIntToken(CallerGuid,\n                        \"unexpected token in '.pseudoprobe' directive\"))\n        return true;\n    }\n\n    // eat colon\n    if (getLexer().is(AsmToken::Colon))\n      Lex();\n\n    int64_t CallerProbeId = 0;\n    if (getLexer().is(AsmToken::Integer)) {\n      if (parseIntToken(CallerProbeId,\n                        \"unexpected token in '.pseudoprobe' directive\"))\n        return true;\n    }\n\n    InlineSite Site(CallerGuid, CallerProbeId);\n    InlineStack.push_back(Site);\n  }\n\n  if (parseEOL())\n    return true;\n\n  getStreamer().emitPseudoProbe(Guid, Index, Type, Attr, InlineStack);\n  return false;\n}\n\n// We are comparing pointers, but the pointers are relative to a single string.\n// Thus, this should always be deterministic.\nstatic int rewritesSort(const AsmRewrite *AsmRewriteA,\n                        const AsmRewrite *AsmRewriteB) {\n  if (AsmRewriteA->Loc.getPointer() < AsmRewriteB->Loc.getPointer())\n    return -1;\n  if (AsmRewriteB->Loc.getPointer() < AsmRewriteA->Loc.getPointer())\n    return 1;\n\n  // It's possible to have a SizeDirective, Imm/ImmPrefix and an Input/Output\n  // rewrite to the same location.  Make sure the SizeDirective rewrite is\n  // performed first, then the Imm/ImmPrefix and finally the Input/Output.  This\n  // ensures the sort algorithm is stable.\n  if (AsmRewritePrecedence[AsmRewriteA->Kind] >\n      AsmRewritePrecedence[AsmRewriteB->Kind])\n    return -1;\n\n  if (AsmRewritePrecedence[AsmRewriteA->Kind] <\n      AsmRewritePrecedence[AsmRewriteB->Kind])\n    return 1;\n  llvm_unreachable(\"Unstable rewrite sort.\");\n}\n\nbool AsmParser::parseMSInlineAsm(\n    void *AsmLoc, std::string &AsmString, unsigned &NumOutputs,\n    unsigned &NumInputs, SmallVectorImpl<std::pair<void *, bool>> &OpDecls,\n    SmallVectorImpl<std::string> &Constraints,\n    SmallVectorImpl<std::string> &Clobbers, const MCInstrInfo *MII,\n    const MCInstPrinter *IP, MCAsmParserSemaCallback &SI) {\n  SmallVector<void *, 4> InputDecls;\n  SmallVector<void *, 4> OutputDecls;\n  SmallVector<bool, 4> InputDeclsAddressOf;\n  SmallVector<bool, 4> OutputDeclsAddressOf;\n  SmallVector<std::string, 4> InputConstraints;\n  SmallVector<std::string, 4> OutputConstraints;\n  SmallVector<unsigned, 4> ClobberRegs;\n\n  SmallVector<AsmRewrite, 4> AsmStrRewrites;\n\n  // Prime the lexer.\n  Lex();\n\n  // While we have input, parse each statement.\n  unsigned InputIdx = 0;\n  unsigned OutputIdx = 0;\n  while (getLexer().isNot(AsmToken::Eof)) {\n    // Parse curly braces marking block start/end\n    if (parseCurlyBlockScope(AsmStrRewrites))\n      continue;\n\n    ParseStatementInfo Info(&AsmStrRewrites);\n    bool StatementErr = parseStatement(Info, &SI);\n\n    if (StatementErr || Info.ParseError) {\n      // Emit pending errors if any exist.\n      printPendingErrors();\n      return true;\n    }\n\n    // No pending error should exist here.\n    assert(!hasPendingError() && \"unexpected error from parseStatement\");\n\n    if (Info.Opcode == ~0U)\n      continue;\n\n    const MCInstrDesc &Desc = MII->get(Info.Opcode);\n\n    // Build the list of clobbers, outputs and inputs.\n    for (unsigned i = 1, e = Info.ParsedOperands.size(); i != e; ++i) {\n      MCParsedAsmOperand &Operand = *Info.ParsedOperands[i];\n\n      // Register operand.\n      if (Operand.isReg() && !Operand.needAddressOf() &&\n          !getTargetParser().OmitRegisterFromClobberLists(Operand.getReg())) {\n        unsigned NumDefs = Desc.getNumDefs();\n        // Clobber.\n        if (NumDefs && Operand.getMCOperandNum() < NumDefs)\n          ClobberRegs.push_back(Operand.getReg());\n        continue;\n      }\n\n      // Expr/Input or Output.\n      StringRef SymName = Operand.getSymName();\n      if (SymName.empty())\n        continue;\n\n      void *OpDecl = Operand.getOpDecl();\n      if (!OpDecl)\n        continue;\n\n      StringRef Constraint = Operand.getConstraint();\n      if (Operand.isImm()) {\n        // Offset as immediate\n        if (Operand.isOffsetOfLocal())\n          Constraint = \"r\";\n        else\n          Constraint = \"i\";\n      }\n\n      bool isOutput = (i == 1) && Desc.mayStore();\n      SMLoc Start = SMLoc::getFromPointer(SymName.data());\n      if (isOutput) {\n        ++InputIdx;\n        OutputDecls.push_back(OpDecl);\n        OutputDeclsAddressOf.push_back(Operand.needAddressOf());\n        OutputConstraints.push_back((\"=\" + Constraint).str());\n        AsmStrRewrites.emplace_back(AOK_Output, Start, SymName.size());\n      } else {\n        InputDecls.push_back(OpDecl);\n        InputDeclsAddressOf.push_back(Operand.needAddressOf());\n        InputConstraints.push_back(Constraint.str());\n        if (Desc.OpInfo[i - 1].isBranchTarget())\n          AsmStrRewrites.emplace_back(AOK_CallInput, Start, SymName.size());\n        else\n          AsmStrRewrites.emplace_back(AOK_Input, Start, SymName.size());\n      }\n    }\n\n    // Consider implicit defs to be clobbers.  Think of cpuid and push.\n    ArrayRef<MCPhysReg> ImpDefs(Desc.getImplicitDefs(),\n                                Desc.getNumImplicitDefs());\n    llvm::append_range(ClobberRegs, ImpDefs);\n  }\n\n  // Set the number of Outputs and Inputs.\n  NumOutputs = OutputDecls.size();\n  NumInputs = InputDecls.size();\n\n  // Set the unique clobbers.\n  array_pod_sort(ClobberRegs.begin(), ClobberRegs.end());\n  ClobberRegs.erase(std::unique(ClobberRegs.begin(), ClobberRegs.end()),\n                    ClobberRegs.end());\n  Clobbers.assign(ClobberRegs.size(), std::string());\n  for (unsigned I = 0, E = ClobberRegs.size(); I != E; ++I) {\n    raw_string_ostream OS(Clobbers[I]);\n    IP->printRegName(OS, ClobberRegs[I]);\n  }\n\n  // Merge the various outputs and inputs.  Output are expected first.\n  if (NumOutputs || NumInputs) {\n    unsigned NumExprs = NumOutputs + NumInputs;\n    OpDecls.resize(NumExprs);\n    Constraints.resize(NumExprs);\n    for (unsigned i = 0; i < NumOutputs; ++i) {\n      OpDecls[i] = std::make_pair(OutputDecls[i], OutputDeclsAddressOf[i]);\n      Constraints[i] = OutputConstraints[i];\n    }\n    for (unsigned i = 0, j = NumOutputs; i < NumInputs; ++i, ++j) {\n      OpDecls[j] = std::make_pair(InputDecls[i], InputDeclsAddressOf[i]);\n      Constraints[j] = InputConstraints[i];\n    }\n  }\n\n  // Build the IR assembly string.\n  std::string AsmStringIR;\n  raw_string_ostream OS(AsmStringIR);\n  StringRef ASMString =\n      SrcMgr.getMemoryBuffer(SrcMgr.getMainFileID())->getBuffer();\n  const char *AsmStart = ASMString.begin();\n  const char *AsmEnd = ASMString.end();\n  array_pod_sort(AsmStrRewrites.begin(), AsmStrRewrites.end(), rewritesSort);\n  for (auto it = AsmStrRewrites.begin(); it != AsmStrRewrites.end(); ++it) {\n    const AsmRewrite &AR = *it;\n    // Check if this has already been covered by another rewrite...\n    if (AR.Done)\n      continue;\n    AsmRewriteKind Kind = AR.Kind;\n\n    const char *Loc = AR.Loc.getPointer();\n    assert(Loc >= AsmStart && \"Expected Loc to be at or after Start!\");\n\n    // Emit everything up to the immediate/expression.\n    if (unsigned Len = Loc - AsmStart)\n      OS << StringRef(AsmStart, Len);\n\n    // Skip the original expression.\n    if (Kind == AOK_Skip) {\n      AsmStart = Loc + AR.Len;\n      continue;\n    }\n\n    unsigned AdditionalSkip = 0;\n    // Rewrite expressions in $N notation.\n    switch (Kind) {\n    default:\n      break;\n    case AOK_IntelExpr:\n      assert(AR.IntelExp.isValid() && \"cannot write invalid intel expression\");\n      if (AR.IntelExp.NeedBracs)\n        OS << \"[\";\n      if (AR.IntelExp.hasBaseReg())\n        OS << AR.IntelExp.BaseReg;\n      if (AR.IntelExp.hasIndexReg())\n        OS << (AR.IntelExp.hasBaseReg() ? \" + \" : \"\")\n           << AR.IntelExp.IndexReg;\n      if (AR.IntelExp.Scale > 1)\n        OS << \" * $$\" << AR.IntelExp.Scale;\n      if (AR.IntelExp.hasOffset()) {\n        if (AR.IntelExp.hasRegs())\n          OS << \" + \";\n        // Fuse this rewrite with a rewrite of the offset name, if present.\n        StringRef OffsetName = AR.IntelExp.OffsetName;\n        SMLoc OffsetLoc = SMLoc::getFromPointer(AR.IntelExp.OffsetName.data());\n        size_t OffsetLen = OffsetName.size();\n        auto rewrite_it = std::find_if(\n            it, AsmStrRewrites.end(), [&](const AsmRewrite &FusingAR) {\n              return FusingAR.Loc == OffsetLoc && FusingAR.Len == OffsetLen &&\n                     (FusingAR.Kind == AOK_Input ||\n                      FusingAR.Kind == AOK_CallInput);\n            });\n        if (rewrite_it == AsmStrRewrites.end()) {\n          OS << \"offset \" << OffsetName;\n        } else if (rewrite_it->Kind == AOK_CallInput) {\n          OS << \"${\" << InputIdx++ << \":P}\";\n          rewrite_it->Done = true;\n        } else {\n          OS << '$' << InputIdx++;\n          rewrite_it->Done = true;\n        }\n      }\n      if (AR.IntelExp.Imm || AR.IntelExp.emitImm())\n        OS << (AR.IntelExp.emitImm() ? \"$$\" : \" + $$\") << AR.IntelExp.Imm;\n      if (AR.IntelExp.NeedBracs)\n        OS << \"]\";\n      break;\n    case AOK_Label:\n      OS << Ctx.getAsmInfo()->getPrivateLabelPrefix() << AR.Label;\n      break;\n    case AOK_Input:\n      OS << '$' << InputIdx++;\n      break;\n    case AOK_CallInput:\n      OS << \"${\" << InputIdx++ << \":P}\";\n      break;\n    case AOK_Output:\n      OS << '$' << OutputIdx++;\n      break;\n    case AOK_SizeDirective:\n      switch (AR.Val) {\n      default: break;\n      case 8:  OS << \"byte ptr \"; break;\n      case 16: OS << \"word ptr \"; break;\n      case 32: OS << \"dword ptr \"; break;\n      case 64: OS << \"qword ptr \"; break;\n      case 80: OS << \"xword ptr \"; break;\n      case 128: OS << \"xmmword ptr \"; break;\n      case 256: OS << \"ymmword ptr \"; break;\n      }\n      break;\n    case AOK_Emit:\n      OS << \".byte\";\n      break;\n    case AOK_Align: {\n      // MS alignment directives are measured in bytes. If the native assembler\n      // measures alignment in bytes, we can pass it straight through.\n      OS << \".align\";\n      if (getContext().getAsmInfo()->getAlignmentIsInBytes())\n        break;\n\n      // Alignment is in log2 form, so print that instead and skip the original\n      // immediate.\n      unsigned Val = AR.Val;\n      OS << ' ' << Val;\n      assert(Val < 10 && \"Expected alignment less then 2^10.\");\n      AdditionalSkip = (Val < 4) ? 2 : Val < 7 ? 3 : 4;\n      break;\n    }\n    case AOK_EVEN:\n      OS << \".even\";\n      break;\n    case AOK_EndOfStatement:\n      OS << \"\\n\\t\";\n      break;\n    }\n\n    // Skip the original expression.\n    AsmStart = Loc + AR.Len + AdditionalSkip;\n  }\n\n  // Emit the remainder of the asm string.\n  if (AsmStart != AsmEnd)\n    OS << StringRef(AsmStart, AsmEnd - AsmStart);\n\n  AsmString = OS.str();\n  return false;\n}\n\nnamespace llvm {\nnamespace MCParserUtils {\n\n/// Returns whether the given symbol is used anywhere in the given expression,\n/// or subexpressions.\nstatic bool isSymbolUsedInExpression(const MCSymbol *Sym, const MCExpr *Value) {\n  switch (Value->getKind()) {\n  case MCExpr::Binary: {\n    const MCBinaryExpr *BE = static_cast<const MCBinaryExpr *>(Value);\n    return isSymbolUsedInExpression(Sym, BE->getLHS()) ||\n           isSymbolUsedInExpression(Sym, BE->getRHS());\n  }\n  case MCExpr::Target:\n  case MCExpr::Constant:\n    return false;\n  case MCExpr::SymbolRef: {\n    const MCSymbol &S =\n        static_cast<const MCSymbolRefExpr *>(Value)->getSymbol();\n    if (S.isVariable())\n      return isSymbolUsedInExpression(Sym, S.getVariableValue());\n    return &S == Sym;\n  }\n  case MCExpr::Unary:\n    return isSymbolUsedInExpression(\n        Sym, static_cast<const MCUnaryExpr *>(Value)->getSubExpr());\n  }\n\n  llvm_unreachable(\"Unknown expr kind!\");\n}\n\nbool parseAssignmentExpression(StringRef Name, bool allow_redef,\n                               MCAsmParser &Parser, MCSymbol *&Sym,\n                               const MCExpr *&Value) {\n\n  // FIXME: Use better location, we should use proper tokens.\n  SMLoc EqualLoc = Parser.getTok().getLoc();\n  if (Parser.parseExpression(Value))\n    return Parser.TokError(\"missing expression\");\n\n  // Note: we don't count b as used in \"a = b\". This is to allow\n  // a = b\n  // b = c\n\n  if (Parser.parseEOL())\n    return true;\n\n  // Validate that the LHS is allowed to be a variable (either it has not been\n  // used as a symbol, or it is an absolute symbol).\n  Sym = Parser.getContext().lookupSymbol(Name);\n  if (Sym) {\n    // Diagnose assignment to a label.\n    //\n    // FIXME: Diagnostics. Note the location of the definition as a label.\n    // FIXME: Diagnose assignment to protected identifier (e.g., register name).\n    if (isSymbolUsedInExpression(Sym, Value))\n      return Parser.Error(EqualLoc, \"Recursive use of '\" + Name + \"'\");\n    else if (Sym->isUndefined(/*SetUsed*/ false) && !Sym->isUsed() &&\n             !Sym->isVariable())\n      ; // Allow redefinitions of undefined symbols only used in directives.\n    else if (Sym->isVariable() && !Sym->isUsed() && allow_redef)\n      ; // Allow redefinitions of variables that haven't yet been used.\n    else if (!Sym->isUndefined() && (!Sym->isVariable() || !allow_redef))\n      return Parser.Error(EqualLoc, \"redefinition of '\" + Name + \"'\");\n    else if (!Sym->isVariable())\n      return Parser.Error(EqualLoc, \"invalid assignment to '\" + Name + \"'\");\n    else if (!isa<MCConstantExpr>(Sym->getVariableValue()))\n      return Parser.Error(EqualLoc,\n                          \"invalid reassignment of non-absolute variable '\" +\n                              Name + \"'\");\n  } else if (Name == \".\") {\n    Parser.getStreamer().emitValueToOffset(Value, 0, EqualLoc);\n    return false;\n  } else\n    Sym = Parser.getContext().getOrCreateSymbol(Name);\n\n  Sym->setRedefinable(allow_redef);\n\n  return false;\n}\n\n} // end namespace MCParserUtils\n} // end namespace llvm\n\n/// Create an MCAsmParser instance.\nMCAsmParser *llvm::createMCAsmParser(SourceMgr &SM, MCContext &C,\n                                     MCStreamer &Out, const MCAsmInfo &MAI,\n                                     unsigned CB) {\n  return new AsmParser(SM, C, Out, MAI, CB);\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 8, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 8, "line": 37}, "message": "default constructor 'MapVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/MapVector.h", "reportHash": "38a675859d2cc8869b94191130d0e1ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 21, "line": 400}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 21, "line": 400}, "message": "move constructor 'iplist' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "7063e9b83cfb368677b1540f0c276fcd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 21}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 32, "line": 21}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h", "reportHash": "2c6adc1fa10864b61254637219a7361e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 139}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 139}, "message": "default constructor 'CodeViewContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCCodeView.h", "reportHash": "4447eb369973f338c2ec11a606e21b5f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 58}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 34, "line": 58}, "message": "default constructor 'MCDwarfFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "999157f8e48f6bc36817f68cfcf8b495", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 183}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 34, "line": 183}, "message": "default constructor 'MCLineSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "a9f7eab8139dd1717caff2b67c950547", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 34, "line": 232}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 34, "line": 232}, "message": "default constructor 'MCDwarfLineTableHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "5d0f3d05598cf49bb898aadd41452f37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 308}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 34, "line": 308}, "message": "default constructor 'MCDwarfLineTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "262d88b8675db05f0c2ad6f8f53fefda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 102}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 38, "line": 102}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h", "reportHash": "047f9128a698fac61beb7aac42647624", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 102}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 38, "line": 102}, "message": "move constructor 'MCLOHDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h", "reportHash": "66a2f5b3e156b1cf67798c1768939796", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 64, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 64, "line": 113}, "message": "default constructor 'ParseStatementInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp", "reportHash": "6f6a943145202b5ab5b24514325f8deb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 64, "line": 161}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 64, "line": 161}, "message": "default constructor 'CppHashInfoTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp", "reportHash": "7e7d36c641fc110fbb4a7abe50c0ad6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
